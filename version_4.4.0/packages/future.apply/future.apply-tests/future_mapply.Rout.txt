
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:37:33.568] plan(): Setting new future strategy stack:
[17:37:33.568] List of future strategies:
[17:37:33.568] 1. sequential:
[17:37:33.568]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:33.568]    - tweaked: FALSE
[17:37:33.568]    - call: future::plan("sequential")
[17:37:33.583] plan(): nbrOfWorkers() = 1
> 
> message("*** future_mapply() ...")
*** future_mapply() ...
> 
> message("- Parallel RNG truth (for later)...")
- Parallel RNG truth (for later)...
> plan(sequential)
[17:37:33.591] plan(): Setting new future strategy stack:
[17:37:33.591] List of future strategies:
[17:37:33.591] 1. sequential:
[17:37:33.591]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:33.591]    - tweaked: FALSE
[17:37:33.591]    - call: plan(sequential)
[17:37:33.603] plan(): nbrOfWorkers() = 1
> y_rng_0 <- future_mapply(stats::runif, n = 1:4, max = 2:5,
+                          MoreArgs = list(min = 1), future.seed = 0xBEEF)
[17:37:33.603] future_mapply() ...
[17:37:33.604] Generating random seeds ...
[17:37:33.604] Generating random seed streams for 4 elements ...
[17:37:33.604] Generating random seed streams for 4 elements ... DONE
[17:37:33.604] Generating random seeds ... DONE
[17:37:33.605] Will set RNG state on exit: 10407, 159827702, 59078765, -156231338, -106622811, 1431714870, -1786728155
[17:37:33.605] Number of chunks: 1
[17:37:33.605] getGlobalsAndPackagesXApply() ...
[17:37:33.605]  - future.globals: TRUE
[17:37:33.606] getGlobalsAndPackages() ...
[17:37:33.606] Searching for globals...
[17:37:33.611] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[17:37:33.611] Searching for globals ... DONE
[17:37:33.611] Resolving globals: FALSE
[17:37:33.612] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[17:37:33.613] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[17:37:33.613] - globals: [1] ‘FUN’
[17:37:33.613] - packages: [1] ‘stats’
[17:37:33.613] getGlobalsAndPackages() ... DONE
[17:37:33.613]  - globals found/used: [n=1] ‘FUN’
[17:37:33.613]  - needed namespaces: [n=1] ‘stats’
[17:37:33.614] Finding globals ... DONE
[17:37:33.614] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:33.614] List of 2
[17:37:33.614]  $ ...future.FUN:function (n, min = 0, max = 1)  
[17:37:33.614]  $ MoreArgs     :List of 1
[17:37:33.614]   ..$ min: num 1
[17:37:33.614]  - attr(*, "where")=List of 2
[17:37:33.614]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:33.614]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:33.614]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:33.614]  - attr(*, "resolved")= logi FALSE
[17:37:33.614]  - attr(*, "total_size")= num NA
[17:37:33.619] Packages to be attached in all futures: [n=1] ‘stats’
[17:37:33.619] getGlobalsAndPackagesXApply() ... DONE
[17:37:33.619] Number of futures (= number of chunks): 1
[17:37:33.619] Launching 1 futures (chunks) ...
[17:37:33.622] Chunk #1 of 1 ...
[17:37:33.622]  - Finding globals in '...' for chunk #1 ...
[17:37:33.622] getGlobalsAndPackages() ...
[17:37:33.622] Searching for globals...
[17:37:33.623] 
[17:37:33.623] Searching for globals ... DONE
[17:37:33.623] - globals: [0] <none>
[17:37:33.623] getGlobalsAndPackages() ... DONE
[17:37:33.623]    + additional globals found: [n=0] 
[17:37:33.623]    + additional namespaces needed: [n=0] 
[17:37:33.623]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:33.623]  - seeds: [4] <seeds>
[17:37:33.624]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:33.624] getGlobalsAndPackages() ...
[17:37:33.624] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:33.624] Resolving globals: FALSE
[17:37:33.625] The total size of the 5 globals is 2.84 KiB (2912 bytes)
[17:37:33.625] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (448 bytes of class ‘list’) and ‘...future.seeds_ii’ (320 bytes of class ‘list’)
[17:37:33.625] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:33.625] - packages: [1] ‘stats’
[17:37:33.625] getGlobalsAndPackages() ... DONE
[17:37:33.626] run() for ‘Future’ ...
[17:37:33.626] - state: ‘created’
[17:37:33.626] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:33.627] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:33.627] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:33.627]   - Field: ‘label’
[17:37:33.627]   - Field: ‘local’
[17:37:33.627]   - Field: ‘owner’
[17:37:33.627]   - Field: ‘envir’
[17:37:33.627]   - Field: ‘packages’
[17:37:33.627]   - Field: ‘gc’
[17:37:33.628]   - Field: ‘conditions’
[17:37:33.628]   - Field: ‘expr’
[17:37:33.628]   - Field: ‘uuid’
[17:37:33.628]   - Field: ‘seed’
[17:37:33.628]   - Field: ‘version’
[17:37:33.628]   - Field: ‘result’
[17:37:33.628]   - Field: ‘asynchronous’
[17:37:33.628]   - Field: ‘calls’
[17:37:33.628]   - Field: ‘globals’
[17:37:33.628]   - Field: ‘stdout’
[17:37:33.628]   - Field: ‘earlySignal’
[17:37:33.629]   - Field: ‘lazy’
[17:37:33.629]   - Field: ‘state’
[17:37:33.629] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:33.629] - Launch lazy future ...
[17:37:33.629] Packages needed by the future expression (n = 1): ‘stats’
[17:37:33.630] Packages needed by future strategies (n = 0): <none>
[17:37:33.630] {
[17:37:33.630]     {
[17:37:33.630]         {
[17:37:33.630]             ...future.startTime <- base::Sys.time()
[17:37:33.630]             {
[17:37:33.630]                 {
[17:37:33.630]                   {
[17:37:33.630]                     {
[17:37:33.630]                       base::local({
[17:37:33.630]                         has_future <- base::requireNamespace("future", 
[17:37:33.630]                           quietly = TRUE)
[17:37:33.630]                         if (has_future) {
[17:37:33.630]                           ns <- base::getNamespace("future")
[17:37:33.630]                           version <- ns[[".package"]][["version"]]
[17:37:33.630]                           if (is.null(version)) 
[17:37:33.630]                             version <- utils::packageVersion("future")
[17:37:33.630]                         }
[17:37:33.630]                         else {
[17:37:33.630]                           version <- NULL
[17:37:33.630]                         }
[17:37:33.630]                         if (!has_future || version < "1.8.0") {
[17:37:33.630]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:33.630]                             "", base::R.version$version.string), 
[17:37:33.630]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:33.630]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:33.630]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:33.630]                               "release", "version")], collapse = " "), 
[17:37:33.630]                             hostname = base::Sys.info()[["nodename"]])
[17:37:33.630]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:33.630]                             info)
[17:37:33.630]                           info <- base::paste(info, collapse = "; ")
[17:37:33.630]                           if (!has_future) {
[17:37:33.630]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:33.630]                               info)
[17:37:33.630]                           }
[17:37:33.630]                           else {
[17:37:33.630]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:33.630]                               info, version)
[17:37:33.630]                           }
[17:37:33.630]                           base::stop(msg)
[17:37:33.630]                         }
[17:37:33.630]                       })
[17:37:33.630]                     }
[17:37:33.630]                     base::local({
[17:37:33.630]                       for (pkg in "stats") {
[17:37:33.630]                         base::loadNamespace(pkg)
[17:37:33.630]                         base::library(pkg, character.only = TRUE)
[17:37:33.630]                       }
[17:37:33.630]                     })
[17:37:33.630]                   }
[17:37:33.630]                   ...future.strategy.old <- future::plan("list")
[17:37:33.630]                   options(future.plan = NULL)
[17:37:33.630]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:33.630]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:33.630]                 }
[17:37:33.630]                 ...future.workdir <- getwd()
[17:37:33.630]             }
[17:37:33.630]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:33.630]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:33.630]         }
[17:37:33.630]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:33.630]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:33.630]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:33.630]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:33.630]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:33.630]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:33.630]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:33.630]             base::names(...future.oldOptions))
[17:37:33.630]     }
[17:37:33.630]     if (FALSE) {
[17:37:33.630]     }
[17:37:33.630]     else {
[17:37:33.630]         if (TRUE) {
[17:37:33.630]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:33.630]                 open = "w")
[17:37:33.630]         }
[17:37:33.630]         else {
[17:37:33.630]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:33.630]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:33.630]         }
[17:37:33.630]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:33.630]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:33.630]             base::sink(type = "output", split = FALSE)
[17:37:33.630]             base::close(...future.stdout)
[17:37:33.630]         }, add = TRUE)
[17:37:33.630]     }
[17:37:33.630]     ...future.frame <- base::sys.nframe()
[17:37:33.630]     ...future.conditions <- base::list()
[17:37:33.630]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:33.630]     if (FALSE) {
[17:37:33.630]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:33.630]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:33.630]     }
[17:37:33.630]     ...future.result <- base::tryCatch({
[17:37:33.630]         base::withCallingHandlers({
[17:37:33.630]             ...future.value <- base::withVisible(base::local({
[17:37:33.630]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:33.630]                 if (!identical(...future.globals.maxSize.org, 
[17:37:33.630]                   ...future.globals.maxSize)) {
[17:37:33.630]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:33.630]                   on.exit(options(oopts), add = TRUE)
[17:37:33.630]                 }
[17:37:33.630]                 {
[17:37:33.630]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:37:33.630]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[17:37:33.630]                       envir = globalenv(), inherits = FALSE)
[17:37:33.630]                     ...future.FUN(...)
[17:37:33.630]                   }
[17:37:33.630]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:37:33.630]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:37:33.630]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:33.630]                     USE.NAMES = FALSE)
[17:37:33.630]                   do.call(mapply, args = args)
[17:37:33.630]                 }
[17:37:33.630]             }))
[17:37:33.630]             future::FutureResult(value = ...future.value$value, 
[17:37:33.630]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:33.630]                   ...future.rng), globalenv = if (FALSE) 
[17:37:33.630]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:33.630]                     ...future.globalenv.names))
[17:37:33.630]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:33.630]         }, condition = base::local({
[17:37:33.630]             c <- base::c
[17:37:33.630]             inherits <- base::inherits
[17:37:33.630]             invokeRestart <- base::invokeRestart
[17:37:33.630]             length <- base::length
[17:37:33.630]             list <- base::list
[17:37:33.630]             seq.int <- base::seq.int
[17:37:33.630]             signalCondition <- base::signalCondition
[17:37:33.630]             sys.calls <- base::sys.calls
[17:37:33.630]             `[[` <- base::`[[`
[17:37:33.630]             `+` <- base::`+`
[17:37:33.630]             `<<-` <- base::`<<-`
[17:37:33.630]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:33.630]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:33.630]                   3L)]
[17:37:33.630]             }
[17:37:33.630]             function(cond) {
[17:37:33.630]                 is_error <- inherits(cond, "error")
[17:37:33.630]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:33.630]                   NULL)
[17:37:33.630]                 if (is_error) {
[17:37:33.630]                   sessionInformation <- function() {
[17:37:33.630]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:33.630]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:33.630]                       search = base::search(), system = base::Sys.info())
[17:37:33.630]                   }
[17:37:33.630]                   ...future.conditions[[length(...future.conditions) + 
[17:37:33.630]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:33.630]                     cond$call), session = sessionInformation(), 
[17:37:33.630]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:33.630]                   signalCondition(cond)
[17:37:33.630]                 }
[17:37:33.630]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:33.630]                 "immediateCondition"))) {
[17:37:33.630]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:33.630]                   ...future.conditions[[length(...future.conditions) + 
[17:37:33.630]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:33.630]                   if (TRUE && !signal) {
[17:37:33.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:33.630]                     {
[17:37:33.630]                       inherits <- base::inherits
[17:37:33.630]                       invokeRestart <- base::invokeRestart
[17:37:33.630]                       is.null <- base::is.null
[17:37:33.630]                       muffled <- FALSE
[17:37:33.630]                       if (inherits(cond, "message")) {
[17:37:33.630]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:33.630]                         if (muffled) 
[17:37:33.630]                           invokeRestart("muffleMessage")
[17:37:33.630]                       }
[17:37:33.630]                       else if (inherits(cond, "warning")) {
[17:37:33.630]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:33.630]                         if (muffled) 
[17:37:33.630]                           invokeRestart("muffleWarning")
[17:37:33.630]                       }
[17:37:33.630]                       else if (inherits(cond, "condition")) {
[17:37:33.630]                         if (!is.null(pattern)) {
[17:37:33.630]                           computeRestarts <- base::computeRestarts
[17:37:33.630]                           grepl <- base::grepl
[17:37:33.630]                           restarts <- computeRestarts(cond)
[17:37:33.630]                           for (restart in restarts) {
[17:37:33.630]                             name <- restart$name
[17:37:33.630]                             if (is.null(name)) 
[17:37:33.630]                               next
[17:37:33.630]                             if (!grepl(pattern, name)) 
[17:37:33.630]                               next
[17:37:33.630]                             invokeRestart(restart)
[17:37:33.630]                             muffled <- TRUE
[17:37:33.630]                             break
[17:37:33.630]                           }
[17:37:33.630]                         }
[17:37:33.630]                       }
[17:37:33.630]                       invisible(muffled)
[17:37:33.630]                     }
[17:37:33.630]                     muffleCondition(cond, pattern = "^muffle")
[17:37:33.630]                   }
[17:37:33.630]                 }
[17:37:33.630]                 else {
[17:37:33.630]                   if (TRUE) {
[17:37:33.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:33.630]                     {
[17:37:33.630]                       inherits <- base::inherits
[17:37:33.630]                       invokeRestart <- base::invokeRestart
[17:37:33.630]                       is.null <- base::is.null
[17:37:33.630]                       muffled <- FALSE
[17:37:33.630]                       if (inherits(cond, "message")) {
[17:37:33.630]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:33.630]                         if (muffled) 
[17:37:33.630]                           invokeRestart("muffleMessage")
[17:37:33.630]                       }
[17:37:33.630]                       else if (inherits(cond, "warning")) {
[17:37:33.630]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:33.630]                         if (muffled) 
[17:37:33.630]                           invokeRestart("muffleWarning")
[17:37:33.630]                       }
[17:37:33.630]                       else if (inherits(cond, "condition")) {
[17:37:33.630]                         if (!is.null(pattern)) {
[17:37:33.630]                           computeRestarts <- base::computeRestarts
[17:37:33.630]                           grepl <- base::grepl
[17:37:33.630]                           restarts <- computeRestarts(cond)
[17:37:33.630]                           for (restart in restarts) {
[17:37:33.630]                             name <- restart$name
[17:37:33.630]                             if (is.null(name)) 
[17:37:33.630]                               next
[17:37:33.630]                             if (!grepl(pattern, name)) 
[17:37:33.630]                               next
[17:37:33.630]                             invokeRestart(restart)
[17:37:33.630]                             muffled <- TRUE
[17:37:33.630]                             break
[17:37:33.630]                           }
[17:37:33.630]                         }
[17:37:33.630]                       }
[17:37:33.630]                       invisible(muffled)
[17:37:33.630]                     }
[17:37:33.630]                     muffleCondition(cond, pattern = "^muffle")
[17:37:33.630]                   }
[17:37:33.630]                 }
[17:37:33.630]             }
[17:37:33.630]         }))
[17:37:33.630]     }, error = function(ex) {
[17:37:33.630]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:33.630]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:33.630]                 ...future.rng), started = ...future.startTime, 
[17:37:33.630]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:33.630]             version = "1.8"), class = "FutureResult")
[17:37:33.630]     }, finally = {
[17:37:33.630]         if (!identical(...future.workdir, getwd())) 
[17:37:33.630]             setwd(...future.workdir)
[17:37:33.630]         {
[17:37:33.630]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:33.630]                 ...future.oldOptions$nwarnings <- NULL
[17:37:33.630]             }
[17:37:33.630]             base::options(...future.oldOptions)
[17:37:33.630]             if (.Platform$OS.type == "windows") {
[17:37:33.630]                 old_names <- names(...future.oldEnvVars)
[17:37:33.630]                 envs <- base::Sys.getenv()
[17:37:33.630]                 names <- names(envs)
[17:37:33.630]                 common <- intersect(names, old_names)
[17:37:33.630]                 added <- setdiff(names, old_names)
[17:37:33.630]                 removed <- setdiff(old_names, names)
[17:37:33.630]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:33.630]                   envs[common]]
[17:37:33.630]                 NAMES <- toupper(changed)
[17:37:33.630]                 args <- list()
[17:37:33.630]                 for (kk in seq_along(NAMES)) {
[17:37:33.630]                   name <- changed[[kk]]
[17:37:33.630]                   NAME <- NAMES[[kk]]
[17:37:33.630]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:33.630]                     next
[17:37:33.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:33.630]                 }
[17:37:33.630]                 NAMES <- toupper(added)
[17:37:33.630]                 for (kk in seq_along(NAMES)) {
[17:37:33.630]                   name <- added[[kk]]
[17:37:33.630]                   NAME <- NAMES[[kk]]
[17:37:33.630]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:33.630]                     next
[17:37:33.630]                   args[[name]] <- ""
[17:37:33.630]                 }
[17:37:33.630]                 NAMES <- toupper(removed)
[17:37:33.630]                 for (kk in seq_along(NAMES)) {
[17:37:33.630]                   name <- removed[[kk]]
[17:37:33.630]                   NAME <- NAMES[[kk]]
[17:37:33.630]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:33.630]                     next
[17:37:33.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:33.630]                 }
[17:37:33.630]                 if (length(args) > 0) 
[17:37:33.630]                   base::do.call(base::Sys.setenv, args = args)
[17:37:33.630]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:33.630]             }
[17:37:33.630]             else {
[17:37:33.630]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:33.630]             }
[17:37:33.630]             {
[17:37:33.630]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:33.630]                   0L) {
[17:37:33.630]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:33.630]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:33.630]                   base::options(opts)
[17:37:33.630]                 }
[17:37:33.630]                 {
[17:37:33.630]                   {
[17:37:33.630]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:33.630]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:33.630]                     -1786728155L), envir = base::globalenv(), 
[17:37:33.630]                       inherits = FALSE)
[17:37:33.630]                     NULL
[17:37:33.630]                   }
[17:37:33.630]                   options(future.plan = NULL)
[17:37:33.630]                   if (is.na(NA_character_)) 
[17:37:33.630]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:33.630]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:33.630]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:33.630]                     .init = FALSE)
[17:37:33.630]                 }
[17:37:33.630]             }
[17:37:33.630]         }
[17:37:33.630]     })
[17:37:33.630]     if (TRUE) {
[17:37:33.630]         base::sink(type = "output", split = FALSE)
[17:37:33.630]         if (TRUE) {
[17:37:33.630]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:33.630]         }
[17:37:33.630]         else {
[17:37:33.630]             ...future.result["stdout"] <- base::list(NULL)
[17:37:33.630]         }
[17:37:33.630]         base::close(...future.stdout)
[17:37:33.630]         ...future.stdout <- NULL
[17:37:33.630]     }
[17:37:33.630]     ...future.result$conditions <- ...future.conditions
[17:37:33.630]     ...future.result$finished <- base::Sys.time()
[17:37:33.630]     ...future.result
[17:37:33.630] }
[17:37:33.632] assign_globals() ...
[17:37:33.632] List of 5
[17:37:33.632]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[17:37:33.632]  $ MoreArgs                 :List of 1
[17:37:33.632]   ..$ min: num 1
[17:37:33.632]  $ ...future.elements_ii    :List of 2
[17:37:33.632]   ..$ n  :List of 4
[17:37:33.632]   .. ..$ : int 1
[17:37:33.632]   .. ..$ : int 2
[17:37:33.632]   .. ..$ : int 3
[17:37:33.632]   .. ..$ : int 4
[17:37:33.632]   ..$ max:List of 4
[17:37:33.632]   .. ..$ : int 2
[17:37:33.632]   .. ..$ : int 3
[17:37:33.632]   .. ..$ : int 4
[17:37:33.632]   .. ..$ : int 5
[17:37:33.632]  $ ...future.seeds_ii       :List of 4
[17:37:33.632]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[17:37:33.632]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[17:37:33.632]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[17:37:33.632]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[17:37:33.632]  $ ...future.globals.maxSize: NULL
[17:37:33.632]  - attr(*, "where")=List of 5
[17:37:33.632]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:33.632]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:33.632]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:33.632]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:33.632]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:33.632]  - attr(*, "resolved")= logi FALSE
[17:37:33.632]  - attr(*, "total_size")= num 2912
[17:37:33.632]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:33.632]  - attr(*, "already-done")= logi TRUE
[17:37:33.640] - copied ‘...future.FUN’ to environment
[17:37:33.641] - copied ‘MoreArgs’ to environment
[17:37:33.641] - copied ‘...future.elements_ii’ to environment
[17:37:33.641] - copied ‘...future.seeds_ii’ to environment
[17:37:33.641] - copied ‘...future.globals.maxSize’ to environment
[17:37:33.641] assign_globals() ... done
[17:37:33.641] plan(): Setting new future strategy stack:
[17:37:33.642] List of future strategies:
[17:37:33.642] 1. sequential:
[17:37:33.642]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:33.642]    - tweaked: FALSE
[17:37:33.642]    - call: NULL
[17:37:33.642] plan(): nbrOfWorkers() = 1
[17:37:33.643] plan(): Setting new future strategy stack:
[17:37:33.643] List of future strategies:
[17:37:33.643] 1. sequential:
[17:37:33.643]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:33.643]    - tweaked: FALSE
[17:37:33.643]    - call: plan(sequential)
[17:37:33.644] plan(): nbrOfWorkers() = 1
[17:37:33.644] SequentialFuture started (and completed)
[17:37:33.644] - Launch lazy future ... done
[17:37:33.644] run() for ‘SequentialFuture’ ... done
[17:37:33.645] Created future:
[17:37:33.645] SequentialFuture:
[17:37:33.645] Label: ‘future_mapply-1’
[17:37:33.645] Expression:
[17:37:33.645] {
[17:37:33.645]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:33.645]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:33.645]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:33.645]         on.exit(options(oopts), add = TRUE)
[17:37:33.645]     }
[17:37:33.645]     {
[17:37:33.645]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:37:33.645]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:37:33.645]                 inherits = FALSE)
[17:37:33.645]             ...future.FUN(...)
[17:37:33.645]         }
[17:37:33.645]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:37:33.645]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:37:33.645]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:33.645]         do.call(mapply, args = args)
[17:37:33.645]     }
[17:37:33.645] }
[17:37:33.645] Lazy evaluation: FALSE
[17:37:33.645] Asynchronous evaluation: FALSE
[17:37:33.645] Local evaluation: TRUE
[17:37:33.645] Environment: R_GlobalEnv
[17:37:33.645] Capture standard output: TRUE
[17:37:33.645] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:33.645] Globals: 5 objects totaling 2.84 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 448 bytes, list ‘...future.seeds_ii’ of 320 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:33.645] Packages: 1 packages (‘stats’)
[17:37:33.645] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:37:33.645] Resolved: TRUE
[17:37:33.645] Value: 280 bytes of class ‘list’
[17:37:33.645] Early signaling: FALSE
[17:37:33.645] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:33.645] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:33.646] Chunk #1 of 1 ... DONE
[17:37:33.646] Launching 1 futures (chunks) ... DONE
[17:37:33.646] Resolving 1 futures (chunks) ...
[17:37:33.647] resolve() on list ...
[17:37:33.647]  recursive: 0
[17:37:33.647]  length: 1
[17:37:33.647] 
[17:37:33.647] resolved() for ‘SequentialFuture’ ...
[17:37:33.647] - state: ‘finished’
[17:37:33.648] - run: TRUE
[17:37:33.648] - result: ‘FutureResult’
[17:37:33.648] resolved() for ‘SequentialFuture’ ... done
[17:37:33.648] Future #1
[17:37:33.648] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:33.648] - nx: 1
[17:37:33.648] - relay: TRUE
[17:37:33.648] - stdout: TRUE
[17:37:33.649] - signal: TRUE
[17:37:33.649] - resignal: FALSE
[17:37:33.649] - force: TRUE
[17:37:33.649] - relayed: [n=1] FALSE
[17:37:33.649] - queued futures: [n=1] FALSE
[17:37:33.649]  - until=1
[17:37:33.649]  - relaying element #1
[17:37:33.649] - relayed: [n=1] TRUE
[17:37:33.649] - queued futures: [n=1] TRUE
[17:37:33.649] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:33.650]  length: 0 (resolved future 1)
[17:37:33.650] Relaying remaining futures
[17:37:33.650] signalConditionsASAP(NULL, pos=0) ...
[17:37:33.650] - nx: 1
[17:37:33.650] - relay: TRUE
[17:37:33.650] - stdout: TRUE
[17:37:33.650] - signal: TRUE
[17:37:33.650] - resignal: FALSE
[17:37:33.650] - force: TRUE
[17:37:33.650] - relayed: [n=1] TRUE
[17:37:33.650] - queued futures: [n=1] TRUE
 - flush all
[17:37:33.651] - relayed: [n=1] TRUE
[17:37:33.651] - queued futures: [n=1] TRUE
[17:37:33.651] signalConditionsASAP(NULL, pos=0) ... done
[17:37:33.651] resolve() on list ... DONE
[17:37:33.651]  - Number of value chunks collected: 1
[17:37:33.651] Resolving 1 futures (chunks) ... DONE
[17:37:33.651] Reducing values from 1 chunks ...
[17:37:33.651]  - Number of values collected after concatenation: 4
[17:37:33.651]  - Number of values expected: 4
[17:37:33.651] Reducing values from 1 chunks ... DONE
[17:37:33.652] future_mapply() ... DONE
> print(y_rng_0)
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(mapply) ...")
+   y0 <- mapply(rep, 1:4, 4:1)
+   y1 <- future_mapply(rep, 1:4, 4:1)
+   stopifnot(identical(y1, y0))
+   y2 <- future_mapply("rep", 1:4, 4:1)
+   stopifnot(identical(y2, y0))
+   
+   y0 <- mapply(rep, times = 1:4, x = 4:1)
+   y1 <- future_mapply(rep, times = 1:4, x = 4:1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- mapply(rep, times = 1:4, MoreArgs = list(x = 42))
+   y1 <- future_mapply(rep, times = 1:4, MoreArgs = list(x = 42))
+   stopifnot(identical(y1, y0))
+   
+   y0 <- mapply(function(x, y) seq_len(x) + y,
+                c(a =  1, b = 2, c = 3),  # names from first
+                c(A = 10, B = 0, C = -10))
+   y1 <- future_mapply(function(x, y) seq_len(x) + y,
+                       c(a =  1, b = 2, c = 3),  # names from first
+                       c(A = 10, B = 0, C = -10))
+   stopifnot(identical(y1, y0))
+ 
+   message("- future_.mapply()")
+   dots <- list(c(a =  1, b = 2, c = 3),  # names from first
+                c(A = 10, B = 0, C = -10))
+   y2 <- .mapply(function(x, y) seq_len(x) + y, dots = dots, MoreArgs = list())
+   names(y0) <- NULL  ## .mapply() don't set names
+   stopifnot(all.equal(y2, y0))
+   y3 <- future_.mapply(function(x, y) seq_len(x) + y, dots = dots, MoreArgs = list())
+   stopifnot(all.equal(y3, y2))
+ 
+   word <- function(C, k) paste(rep.int(C, k), collapse = "")
+   for (chunk.size in list(1L, structure(2L, ordering = "random"), structure(3L, ordering = 5:1))) {
+     y0 <- mapply(word, LETTERS[1:5], 5:1, SIMPLIFY = FALSE)
+     y1 <- future_mapply(word, LETTERS[1:5], 5:1, SIMPLIFY = FALSE, future.chunk.size = chunk.size)
+     stopifnot(identical(y1, y0))
+ 
+     dots <- list(LETTERS[1:5], 5:1)
+     MoreArgs <- list()
+     y2 <- .mapply(word, dots = dots, MoreArgs = list())
+     names(y0) <- NULL  ## .mapply() don't set names
+     stopifnot(all.equal(y2, y0))
+     y3 <- future_.mapply(word, dots = dots, MoreArgs = list())
+     stopifnot(all.equal(y3, y2))
+   }
+ 
+   message("- Subsetting (Issue #17) ...")
+   X <- as.Date("2018-06-01")
+   y0 <- mapply(FUN = identity, X, SIMPLIFY = FALSE)
+   y1 <- future_mapply(FUN = identity, X, SIMPLIFY = FALSE)
+   stopifnot(identical(y1, y0))
+ 
+   dots <- list(X)
+   y2 <- .mapply(FUN = identity, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y2, y0))
+   y3 <- future_.mapply(FUN = identity, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y3, y2))
+ 
+   message("- Non-recycling of MoreArgs (Issue #51) ...")
+   y0 <- base::mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4)
+   )
+   y1 <- future.apply::future_mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4),
+     future.seed = FALSE
+   )
+   stopifnot(identical(y1, y0))
+   y2 <- future.apply::future_mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4),
+     future.seed = TRUE
+   )
+   stopifnot(identical(y2, y0))
+ 
+   dots <- list(x = 1:2)
+   MoreArgs <- list(y = 3:4)
+   y3 <- .mapply(function(x, y) y, dots = dots, MoreArgs = MoreArgs)
+   y4 <- future_.mapply(function(x, y) y, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y4, y3))
+ 
+   message("- Recycle arguments to same length ...")
+   y0 <- mapply(rep, 1:4, 2:1)
+   y1 <- future_mapply(rep, 1:4, 2:1)
+   stopifnot(identical(y1, y0))
+ 
+   
+   message("- Parallel RNG ...")
+   y_rng_1 <- future_mapply(stats::runif, n = 1:4, max = 2:5,
+                            MoreArgs = list(min = 1), future.seed = 0xBEEF)
+   print(y_rng_1)
+   stopifnot(all.equal(y_rng_1, y_rng_0))
+ 
+   message("- future_Map() ...")
+   xs <- replicate(5, stats::runif(10), simplify = FALSE)
+   ws <- replicate(5, stats::rpois(10, 5) + 1, simplify = FALSE)
+   y0 <- Map(weighted.mean, xs, ws)
+   y1 <- future_Map(stats::weighted.mean, xs, ws)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_mapply() - 'max-or-0-if' recycling rule ...")
+   ## R (>= 4.2.0): mapply() & Map() follow usual "max-or-0-if" recycling rule
+   ## and keeps returning a named list in the "empty" case.
+   
+   truth <- list()
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(`+`, 1:3, NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(`+`, 1:3, NULL)
+   stopifnot(identical(y, truth))
+   
+   truth <- setNames(list(), character())
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), NULL)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, "A", character())
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, "A", character())
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters) 
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), NULL)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, "A", character()) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, "A", character()) 
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters) 
+   stopifnot(identical(y, truth))
+ 
+   ## Gives an error in R-devel (2021-11-26 r81252)
+   if (getRversion() >= "4.2.0" && FALSE) {
+     y0 <- mapply(paste, c(a = "A"), character())
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, c(a = "A"), character())
+   stopifnot(identical(y, truth))
+ 
+   ## R (>= 4.2.0): Map() now recycles similar to basic Ops:
+   truth <- as.list(1 + 1:3)
+   if (getRversion() >= "4.2.0") {
+     y0 <- Map(`+`, 1, 1:3)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_Map(`+`, 1, 1:3)
+   stopifnot(identical(y, truth))
+   
+   truth <- as.list(numeric() + 1:3)
+   if (getRversion() >= "4.2.0") {
+     y0 <- Map(`+`, numeric(), 1:3)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_Map(`+`, numeric(), 1:3)
+   stopifnot(identical(y, truth))
+ 
+   message("- future_mapply(x, ...) where x[[i]] subsets via S3 method ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   `[[.Foo` <- function(x, ...) 0
+   y0 <- mapply(x, FUN = identity)
+   stopifnot(identical(y0, c(a = 0, b = 0)))
+   y1 <- future_mapply(x, FUN = identity)
+   if (getOption("future.apply.chunkWith", "[[") == "[") {
+     stopifnot(identical(y1, unlist(x)))
+   } else {
+     stopifnot(identical(y1, y0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[17:37:33.814] plan(): Setting new future strategy stack:
[17:37:33.814] List of future strategies:
[17:37:33.814] 1. sequential:
[17:37:33.814]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:33.814]    - tweaked: FALSE
[17:37:33.814]    - call: plan(strategy)
[17:37:33.814] plan(): nbrOfWorkers() = 1
- From example(mapply) ...
[17:37:33.815] future_mapply() ...
[17:37:33.815] Number of chunks: 1
[17:37:33.815] getGlobalsAndPackagesXApply() ...
[17:37:33.815]  - future.globals: TRUE
[17:37:33.815] getGlobalsAndPackages() ...
[17:37:33.815] Searching for globals...
[17:37:33.816] - globals found: [1] ‘FUN’
[17:37:33.816] Searching for globals ... DONE
[17:37:33.816] Resolving globals: FALSE
[17:37:33.816] The total size of the 1 globals is 56 bytes (56 bytes)
[17:37:33.817] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:37:33.817] - globals: [1] ‘FUN’
[17:37:33.817] 
[17:37:33.817] getGlobalsAndPackages() ... DONE
[17:37:33.817]  - globals found/used: [n=1] ‘FUN’
[17:37:33.817]  - needed namespaces: [n=0] 
[17:37:33.817] Finding globals ... DONE
[17:37:33.817] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:33.817] List of 2
[17:37:33.817]  $ ...future.FUN:function (x, ...)  
[17:37:33.817]  $ MoreArgs     : NULL
[17:37:33.817]  - attr(*, "where")=List of 2
[17:37:33.817]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:33.817]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:33.817]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:33.817]  - attr(*, "resolved")= logi FALSE
[17:37:33.817]  - attr(*, "total_size")= num NA
[17:37:33.820] Packages to be attached in all futures: [n=0] 
[17:37:33.820] getGlobalsAndPackagesXApply() ... DONE
[17:37:33.820] Number of futures (= number of chunks): 1
[17:37:33.820] Launching 1 futures (chunks) ...
[17:37:33.820] Chunk #1 of 1 ...
[17:37:33.821]  - Finding globals in '...' for chunk #1 ...
[17:37:33.821] getGlobalsAndPackages() ...
[17:37:33.821] Searching for globals...
[17:37:33.821] 
[17:37:33.821] Searching for globals ... DONE
[17:37:33.821] - globals: [0] <none>
[17:37:33.821] getGlobalsAndPackages() ... DONE
[17:37:33.821]    + additional globals found: [n=0] 
[17:37:33.821]    + additional namespaces needed: [n=0] 
[17:37:33.822]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:33.822]  - seeds: <none>
[17:37:33.822]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:33.822] getGlobalsAndPackages() ...
[17:37:33.822] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:33.822] Resolving globals: FALSE
[17:37:33.823] The total size of the 5 globals is 504 bytes (504 bytes)
[17:37:33.823] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:33.823] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:33.823] 
[17:37:33.823] getGlobalsAndPackages() ... DONE
[17:37:33.824] run() for ‘Future’ ...
[17:37:33.824] - state: ‘created’
[17:37:33.824] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:33.824] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:33.824] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:33.824]   - Field: ‘label’
[17:37:33.824]   - Field: ‘local’
[17:37:33.825]   - Field: ‘owner’
[17:37:33.825]   - Field: ‘envir’
[17:37:33.825]   - Field: ‘packages’
[17:37:33.825]   - Field: ‘gc’
[17:37:33.825]   - Field: ‘conditions’
[17:37:33.825]   - Field: ‘expr’
[17:37:33.825]   - Field: ‘uuid’
[17:37:33.825]   - Field: ‘seed’
[17:37:33.825]   - Field: ‘version’
[17:37:33.825]   - Field: ‘result’
[17:37:33.825]   - Field: ‘asynchronous’
[17:37:33.826]   - Field: ‘calls’
[17:37:33.826]   - Field: ‘globals’
[17:37:33.826]   - Field: ‘stdout’
[17:37:33.826]   - Field: ‘earlySignal’
[17:37:33.826]   - Field: ‘lazy’
[17:37:33.826]   - Field: ‘state’
[17:37:33.826] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:33.826] - Launch lazy future ...
[17:37:33.826] Packages needed by the future expression (n = 0): <none>
[17:37:33.826] Packages needed by future strategies (n = 0): <none>
[17:37:33.828] {
[17:37:33.828]     {
[17:37:33.828]         {
[17:37:33.828]             ...future.startTime <- base::Sys.time()
[17:37:33.828]             {
[17:37:33.828]                 {
[17:37:33.828]                   {
[17:37:33.828]                     base::local({
[17:37:33.828]                       has_future <- base::requireNamespace("future", 
[17:37:33.828]                         quietly = TRUE)
[17:37:33.828]                       if (has_future) {
[17:37:33.828]                         ns <- base::getNamespace("future")
[17:37:33.828]                         version <- ns[[".package"]][["version"]]
[17:37:33.828]                         if (is.null(version)) 
[17:37:33.828]                           version <- utils::packageVersion("future")
[17:37:33.828]                       }
[17:37:33.828]                       else {
[17:37:33.828]                         version <- NULL
[17:37:33.828]                       }
[17:37:33.828]                       if (!has_future || version < "1.8.0") {
[17:37:33.828]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:33.828]                           "", base::R.version$version.string), 
[17:37:33.828]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:33.828]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:33.828]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:33.828]                             "release", "version")], collapse = " "), 
[17:37:33.828]                           hostname = base::Sys.info()[["nodename"]])
[17:37:33.828]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:33.828]                           info)
[17:37:33.828]                         info <- base::paste(info, collapse = "; ")
[17:37:33.828]                         if (!has_future) {
[17:37:33.828]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:33.828]                             info)
[17:37:33.828]                         }
[17:37:33.828]                         else {
[17:37:33.828]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:33.828]                             info, version)
[17:37:33.828]                         }
[17:37:33.828]                         base::stop(msg)
[17:37:33.828]                       }
[17:37:33.828]                     })
[17:37:33.828]                   }
[17:37:33.828]                   ...future.strategy.old <- future::plan("list")
[17:37:33.828]                   options(future.plan = NULL)
[17:37:33.828]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:33.828]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:33.828]                 }
[17:37:33.828]                 ...future.workdir <- getwd()
[17:37:33.828]             }
[17:37:33.828]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:33.828]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:33.828]         }
[17:37:33.828]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:33.828]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:33.828]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:33.828]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:33.828]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:33.828]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:33.828]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:33.828]             base::names(...future.oldOptions))
[17:37:33.828]     }
[17:37:33.828]     if (FALSE) {
[17:37:33.828]     }
[17:37:33.828]     else {
[17:37:33.828]         if (TRUE) {
[17:37:33.828]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:33.828]                 open = "w")
[17:37:33.828]         }
[17:37:33.828]         else {
[17:37:33.828]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:33.828]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:33.828]         }
[17:37:33.828]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:33.828]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:33.828]             base::sink(type = "output", split = FALSE)
[17:37:33.828]             base::close(...future.stdout)
[17:37:33.828]         }, add = TRUE)
[17:37:33.828]     }
[17:37:33.828]     ...future.frame <- base::sys.nframe()
[17:37:33.828]     ...future.conditions <- base::list()
[17:37:33.828]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:33.828]     if (FALSE) {
[17:37:33.828]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:33.828]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:33.828]     }
[17:37:33.828]     ...future.result <- base::tryCatch({
[17:37:33.828]         base::withCallingHandlers({
[17:37:33.828]             ...future.value <- base::withVisible(base::local({
[17:37:33.828]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:33.828]                 if (!identical(...future.globals.maxSize.org, 
[17:37:33.828]                   ...future.globals.maxSize)) {
[17:37:33.828]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:33.828]                   on.exit(options(oopts), add = TRUE)
[17:37:33.828]                 }
[17:37:33.828]                 {
[17:37:33.828]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:33.828]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:33.828]                     USE.NAMES = FALSE)
[17:37:33.828]                   do.call(mapply, args = args)
[17:37:33.828]                 }
[17:37:33.828]             }))
[17:37:33.828]             future::FutureResult(value = ...future.value$value, 
[17:37:33.828]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:33.828]                   ...future.rng), globalenv = if (FALSE) 
[17:37:33.828]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:33.828]                     ...future.globalenv.names))
[17:37:33.828]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:33.828]         }, condition = base::local({
[17:37:33.828]             c <- base::c
[17:37:33.828]             inherits <- base::inherits
[17:37:33.828]             invokeRestart <- base::invokeRestart
[17:37:33.828]             length <- base::length
[17:37:33.828]             list <- base::list
[17:37:33.828]             seq.int <- base::seq.int
[17:37:33.828]             signalCondition <- base::signalCondition
[17:37:33.828]             sys.calls <- base::sys.calls
[17:37:33.828]             `[[` <- base::`[[`
[17:37:33.828]             `+` <- base::`+`
[17:37:33.828]             `<<-` <- base::`<<-`
[17:37:33.828]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:33.828]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:33.828]                   3L)]
[17:37:33.828]             }
[17:37:33.828]             function(cond) {
[17:37:33.828]                 is_error <- inherits(cond, "error")
[17:37:33.828]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:33.828]                   NULL)
[17:37:33.828]                 if (is_error) {
[17:37:33.828]                   sessionInformation <- function() {
[17:37:33.828]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:33.828]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:33.828]                       search = base::search(), system = base::Sys.info())
[17:37:33.828]                   }
[17:37:33.828]                   ...future.conditions[[length(...future.conditions) + 
[17:37:33.828]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:33.828]                     cond$call), session = sessionInformation(), 
[17:37:33.828]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:33.828]                   signalCondition(cond)
[17:37:33.828]                 }
[17:37:33.828]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:33.828]                 "immediateCondition"))) {
[17:37:33.828]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:33.828]                   ...future.conditions[[length(...future.conditions) + 
[17:37:33.828]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:33.828]                   if (TRUE && !signal) {
[17:37:33.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:33.828]                     {
[17:37:33.828]                       inherits <- base::inherits
[17:37:33.828]                       invokeRestart <- base::invokeRestart
[17:37:33.828]                       is.null <- base::is.null
[17:37:33.828]                       muffled <- FALSE
[17:37:33.828]                       if (inherits(cond, "message")) {
[17:37:33.828]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:33.828]                         if (muffled) 
[17:37:33.828]                           invokeRestart("muffleMessage")
[17:37:33.828]                       }
[17:37:33.828]                       else if (inherits(cond, "warning")) {
[17:37:33.828]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:33.828]                         if (muffled) 
[17:37:33.828]                           invokeRestart("muffleWarning")
[17:37:33.828]                       }
[17:37:33.828]                       else if (inherits(cond, "condition")) {
[17:37:33.828]                         if (!is.null(pattern)) {
[17:37:33.828]                           computeRestarts <- base::computeRestarts
[17:37:33.828]                           grepl <- base::grepl
[17:37:33.828]                           restarts <- computeRestarts(cond)
[17:37:33.828]                           for (restart in restarts) {
[17:37:33.828]                             name <- restart$name
[17:37:33.828]                             if (is.null(name)) 
[17:37:33.828]                               next
[17:37:33.828]                             if (!grepl(pattern, name)) 
[17:37:33.828]                               next
[17:37:33.828]                             invokeRestart(restart)
[17:37:33.828]                             muffled <- TRUE
[17:37:33.828]                             break
[17:37:33.828]                           }
[17:37:33.828]                         }
[17:37:33.828]                       }
[17:37:33.828]                       invisible(muffled)
[17:37:33.828]                     }
[17:37:33.828]                     muffleCondition(cond, pattern = "^muffle")
[17:37:33.828]                   }
[17:37:33.828]                 }
[17:37:33.828]                 else {
[17:37:33.828]                   if (TRUE) {
[17:37:33.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:33.828]                     {
[17:37:33.828]                       inherits <- base::inherits
[17:37:33.828]                       invokeRestart <- base::invokeRestart
[17:37:33.828]                       is.null <- base::is.null
[17:37:33.828]                       muffled <- FALSE
[17:37:33.828]                       if (inherits(cond, "message")) {
[17:37:33.828]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:33.828]                         if (muffled) 
[17:37:33.828]                           invokeRestart("muffleMessage")
[17:37:33.828]                       }
[17:37:33.828]                       else if (inherits(cond, "warning")) {
[17:37:33.828]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:33.828]                         if (muffled) 
[17:37:33.828]                           invokeRestart("muffleWarning")
[17:37:33.828]                       }
[17:37:33.828]                       else if (inherits(cond, "condition")) {
[17:37:33.828]                         if (!is.null(pattern)) {
[17:37:33.828]                           computeRestarts <- base::computeRestarts
[17:37:33.828]                           grepl <- base::grepl
[17:37:33.828]                           restarts <- computeRestarts(cond)
[17:37:33.828]                           for (restart in restarts) {
[17:37:33.828]                             name <- restart$name
[17:37:33.828]                             if (is.null(name)) 
[17:37:33.828]                               next
[17:37:33.828]                             if (!grepl(pattern, name)) 
[17:37:33.828]                               next
[17:37:33.828]                             invokeRestart(restart)
[17:37:33.828]                             muffled <- TRUE
[17:37:33.828]                             break
[17:37:33.828]                           }
[17:37:33.828]                         }
[17:37:33.828]                       }
[17:37:33.828]                       invisible(muffled)
[17:37:33.828]                     }
[17:37:33.828]                     muffleCondition(cond, pattern = "^muffle")
[17:37:33.828]                   }
[17:37:33.828]                 }
[17:37:33.828]             }
[17:37:33.828]         }))
[17:37:33.828]     }, error = function(ex) {
[17:37:33.828]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:33.828]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:33.828]                 ...future.rng), started = ...future.startTime, 
[17:37:33.828]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:33.828]             version = "1.8"), class = "FutureResult")
[17:37:33.828]     }, finally = {
[17:37:33.828]         if (!identical(...future.workdir, getwd())) 
[17:37:33.828]             setwd(...future.workdir)
[17:37:33.828]         {
[17:37:33.828]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:33.828]                 ...future.oldOptions$nwarnings <- NULL
[17:37:33.828]             }
[17:37:33.828]             base::options(...future.oldOptions)
[17:37:33.828]             if (.Platform$OS.type == "windows") {
[17:37:33.828]                 old_names <- names(...future.oldEnvVars)
[17:37:33.828]                 envs <- base::Sys.getenv()
[17:37:33.828]                 names <- names(envs)
[17:37:33.828]                 common <- intersect(names, old_names)
[17:37:33.828]                 added <- setdiff(names, old_names)
[17:37:33.828]                 removed <- setdiff(old_names, names)
[17:37:33.828]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:33.828]                   envs[common]]
[17:37:33.828]                 NAMES <- toupper(changed)
[17:37:33.828]                 args <- list()
[17:37:33.828]                 for (kk in seq_along(NAMES)) {
[17:37:33.828]                   name <- changed[[kk]]
[17:37:33.828]                   NAME <- NAMES[[kk]]
[17:37:33.828]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:33.828]                     next
[17:37:33.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:33.828]                 }
[17:37:33.828]                 NAMES <- toupper(added)
[17:37:33.828]                 for (kk in seq_along(NAMES)) {
[17:37:33.828]                   name <- added[[kk]]
[17:37:33.828]                   NAME <- NAMES[[kk]]
[17:37:33.828]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:33.828]                     next
[17:37:33.828]                   args[[name]] <- ""
[17:37:33.828]                 }
[17:37:33.828]                 NAMES <- toupper(removed)
[17:37:33.828]                 for (kk in seq_along(NAMES)) {
[17:37:33.828]                   name <- removed[[kk]]
[17:37:33.828]                   NAME <- NAMES[[kk]]
[17:37:33.828]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:33.828]                     next
[17:37:33.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:33.828]                 }
[17:37:33.828]                 if (length(args) > 0) 
[17:37:33.828]                   base::do.call(base::Sys.setenv, args = args)
[17:37:33.828]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:33.828]             }
[17:37:33.828]             else {
[17:37:33.828]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:33.828]             }
[17:37:33.828]             {
[17:37:33.828]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:33.828]                   0L) {
[17:37:33.828]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:33.828]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:33.828]                   base::options(opts)
[17:37:33.828]                 }
[17:37:33.828]                 {
[17:37:33.828]                   {
[17:37:33.828]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:33.828]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:33.828]                     -1786728155L), envir = base::globalenv(), 
[17:37:33.828]                       inherits = FALSE)
[17:37:33.828]                     NULL
[17:37:33.828]                   }
[17:37:33.828]                   options(future.plan = NULL)
[17:37:33.828]                   if (is.na(NA_character_)) 
[17:37:33.828]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:33.828]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:33.828]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:33.828]                     .init = FALSE)
[17:37:33.828]                 }
[17:37:33.828]             }
[17:37:33.828]         }
[17:37:33.828]     })
[17:37:33.828]     if (TRUE) {
[17:37:33.828]         base::sink(type = "output", split = FALSE)
[17:37:33.828]         if (TRUE) {
[17:37:33.828]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:33.828]         }
[17:37:33.828]         else {
[17:37:33.828]             ...future.result["stdout"] <- base::list(NULL)
[17:37:33.828]         }
[17:37:33.828]         base::close(...future.stdout)
[17:37:33.828]         ...future.stdout <- NULL
[17:37:33.828]     }
[17:37:33.828]     ...future.result$conditions <- ...future.conditions
[17:37:33.828]     ...future.result$finished <- base::Sys.time()
[17:37:33.828]     ...future.result
[17:37:33.828] }
[17:37:33.830] assign_globals() ...
[17:37:33.830] List of 5
[17:37:33.830]  $ ...future.FUN            :function (x, ...)  
[17:37:33.830]  $ MoreArgs                 : NULL
[17:37:33.830]  $ ...future.elements_ii    :List of 2
[17:37:33.830]   ..$ :List of 4
[17:37:33.830]   .. ..$ : int 1
[17:37:33.830]   .. ..$ : int 2
[17:37:33.830]   .. ..$ : int 3
[17:37:33.830]   .. ..$ : int 4
[17:37:33.830]   ..$ :List of 4
[17:37:33.830]   .. ..$ : int 4
[17:37:33.830]   .. ..$ : int 3
[17:37:33.830]   .. ..$ : int 2
[17:37:33.830]   .. ..$ : int 1
[17:37:33.830]  $ ...future.seeds_ii       : NULL
[17:37:33.830]  $ ...future.globals.maxSize: NULL
[17:37:33.830]  - attr(*, "where")=List of 5
[17:37:33.830]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:33.830]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:33.830]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:33.830]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:33.830]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:33.830]  - attr(*, "resolved")= logi FALSE
[17:37:33.830]  - attr(*, "total_size")= num 504
[17:37:33.830]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:33.830]  - attr(*, "already-done")= logi TRUE
[17:37:33.837] - copied ‘...future.FUN’ to environment
[17:37:33.837] - copied ‘MoreArgs’ to environment
[17:37:33.837] - copied ‘...future.elements_ii’ to environment
[17:37:33.837] - copied ‘...future.seeds_ii’ to environment
[17:37:33.837] - copied ‘...future.globals.maxSize’ to environment
[17:37:33.837] assign_globals() ... done
[17:37:33.837] plan(): Setting new future strategy stack:
[17:37:33.837] List of future strategies:
[17:37:33.837] 1. sequential:
[17:37:33.837]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:33.837]    - tweaked: FALSE
[17:37:33.837]    - call: NULL
[17:37:33.838] plan(): nbrOfWorkers() = 1
[17:37:33.839] plan(): Setting new future strategy stack:
[17:37:33.839] List of future strategies:
[17:37:33.839] 1. sequential:
[17:37:33.839]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:33.839]    - tweaked: FALSE
[17:37:33.839]    - call: plan(strategy)
[17:37:33.839] plan(): nbrOfWorkers() = 1
[17:37:33.839] SequentialFuture started (and completed)
[17:37:33.839] - Launch lazy future ... done
[17:37:33.840] run() for ‘SequentialFuture’ ... done
[17:37:33.840] Created future:
[17:37:33.840] SequentialFuture:
[17:37:33.840] Label: ‘future_mapply-1’
[17:37:33.840] Expression:
[17:37:33.840] {
[17:37:33.840]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:33.840]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:33.840]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:33.840]         on.exit(options(oopts), add = TRUE)
[17:37:33.840]     }
[17:37:33.840]     {
[17:37:33.840]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:33.840]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:33.840]         do.call(mapply, args = args)
[17:37:33.840]     }
[17:37:33.840] }
[17:37:33.840] Lazy evaluation: FALSE
[17:37:33.840] Asynchronous evaluation: FALSE
[17:37:33.840] Local evaluation: TRUE
[17:37:33.840] Environment: R_GlobalEnv
[17:37:33.840] Capture standard output: TRUE
[17:37:33.840] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:33.840] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:33.840] Packages: <none>
[17:37:33.840] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:33.840] Resolved: TRUE
[17:37:33.840] Value: 240 bytes of class ‘list’
[17:37:33.840] Early signaling: FALSE
[17:37:33.840] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:33.840] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:33.841] Chunk #1 of 1 ... DONE
[17:37:33.841] Launching 1 futures (chunks) ... DONE
[17:37:33.841] Resolving 1 futures (chunks) ...
[17:37:33.841] resolve() on list ...
[17:37:33.841]  recursive: 0
[17:37:33.841]  length: 1
[17:37:33.841] 
[17:37:33.841] resolved() for ‘SequentialFuture’ ...
[17:37:33.841] - state: ‘finished’
[17:37:33.842] - run: TRUE
[17:37:33.842] - result: ‘FutureResult’
[17:37:33.842] resolved() for ‘SequentialFuture’ ... done
[17:37:33.842] Future #1
[17:37:33.842] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:33.842] - nx: 1
[17:37:33.842] - relay: TRUE
[17:37:33.842] - stdout: TRUE
[17:37:33.842] - signal: TRUE
[17:37:33.842] - resignal: FALSE
[17:37:33.842] - force: TRUE
[17:37:33.843] - relayed: [n=1] FALSE
[17:37:33.843] - queued futures: [n=1] FALSE
[17:37:33.843]  - until=1
[17:37:33.843]  - relaying element #1
[17:37:33.843] - relayed: [n=1] TRUE
[17:37:33.843] - queued futures: [n=1] TRUE
[17:37:33.843] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:33.843]  length: 0 (resolved future 1)
[17:37:33.843] Relaying remaining futures
[17:37:33.843] signalConditionsASAP(NULL, pos=0) ...
[17:37:33.844] - nx: 1
[17:37:33.844] - relay: TRUE
[17:37:33.844] - stdout: TRUE
[17:37:33.844] - signal: TRUE
[17:37:33.844] - resignal: FALSE
[17:37:33.844] - force: TRUE
[17:37:33.844] - relayed: [n=1] TRUE
[17:37:33.844] - queued futures: [n=1] TRUE
 - flush all
[17:37:33.844] - relayed: [n=1] TRUE
[17:37:33.844] - queued futures: [n=1] TRUE
[17:37:33.844] signalConditionsASAP(NULL, pos=0) ... done
[17:37:33.845] resolve() on list ... DONE
[17:37:33.845]  - Number of value chunks collected: 1
[17:37:33.845] Resolving 1 futures (chunks) ... DONE
[17:37:33.845] Reducing values from 1 chunks ...
[17:37:33.845]  - Number of values collected after concatenation: 4
[17:37:33.845]  - Number of values expected: 4
[17:37:33.845] Reducing values from 1 chunks ... DONE
[17:37:33.845] future_mapply() ... DONE
[17:37:33.845] future_mapply() ...
[17:37:33.845] Number of chunks: 1
[17:37:33.846] getGlobalsAndPackagesXApply() ...
[17:37:33.846]  - future.globals: TRUE
[17:37:33.846] getGlobalsAndPackages() ...
[17:37:33.846] Searching for globals...
[17:37:33.846] - globals found: [1] ‘FUN’
[17:37:33.847] Searching for globals ... DONE
[17:37:33.847] Resolving globals: FALSE
[17:37:33.847] The total size of the 1 globals is 56 bytes (56 bytes)
[17:37:33.847] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:37:33.847] - globals: [1] ‘FUN’
[17:37:33.847] 
[17:37:33.848] getGlobalsAndPackages() ... DONE
[17:37:33.848]  - globals found/used: [n=1] ‘FUN’
[17:37:33.848]  - needed namespaces: [n=0] 
[17:37:33.848] Finding globals ... DONE
[17:37:33.848] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:33.848] List of 2
[17:37:33.848]  $ ...future.FUN:function (x, ...)  
[17:37:33.848]  $ MoreArgs     : NULL
[17:37:33.848]  - attr(*, "where")=List of 2
[17:37:33.848]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:33.848]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:33.848]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:33.848]  - attr(*, "resolved")= logi FALSE
[17:37:33.848]  - attr(*, "total_size")= num NA
[17:37:33.851] Packages to be attached in all futures: [n=0] 
[17:37:33.851] getGlobalsAndPackagesXApply() ... DONE
[17:37:33.851] Number of futures (= number of chunks): 1
[17:37:33.851] Launching 1 futures (chunks) ...
[17:37:33.851] Chunk #1 of 1 ...
[17:37:33.851]  - Finding globals in '...' for chunk #1 ...
[17:37:33.851] getGlobalsAndPackages() ...
[17:37:33.851] Searching for globals...
[17:37:33.852] 
[17:37:33.852] Searching for globals ... DONE
[17:37:33.852] - globals: [0] <none>
[17:37:33.852] getGlobalsAndPackages() ... DONE
[17:37:33.852]    + additional globals found: [n=0] 
[17:37:33.852]    + additional namespaces needed: [n=0] 
[17:37:33.852]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:33.852]  - seeds: <none>
[17:37:33.852]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:33.853] getGlobalsAndPackages() ...
[17:37:33.853] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:33.853] Resolving globals: FALSE
[17:37:33.855] The total size of the 5 globals is 504 bytes (504 bytes)
[17:37:33.855] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:33.855] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:33.856] 
[17:37:33.856] getGlobalsAndPackages() ... DONE
[17:37:33.856] run() for ‘Future’ ...
[17:37:33.856] - state: ‘created’
[17:37:33.856] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:33.856] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:33.857] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:33.857]   - Field: ‘label’
[17:37:33.857]   - Field: ‘local’
[17:37:33.857]   - Field: ‘owner’
[17:37:33.857]   - Field: ‘envir’
[17:37:33.857]   - Field: ‘packages’
[17:37:33.857]   - Field: ‘gc’
[17:37:33.857]   - Field: ‘conditions’
[17:37:33.857]   - Field: ‘expr’
[17:37:33.857]   - Field: ‘uuid’
[17:37:33.857]   - Field: ‘seed’
[17:37:33.858]   - Field: ‘version’
[17:37:33.858]   - Field: ‘result’
[17:37:33.858]   - Field: ‘asynchronous’
[17:37:33.858]   - Field: ‘calls’
[17:37:33.858]   - Field: ‘globals’
[17:37:33.858]   - Field: ‘stdout’
[17:37:33.858]   - Field: ‘earlySignal’
[17:37:33.858]   - Field: ‘lazy’
[17:37:33.858]   - Field: ‘state’
[17:37:33.858] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:33.859] - Launch lazy future ...
[17:37:33.859] Packages needed by the future expression (n = 0): <none>
[17:37:33.859] Packages needed by future strategies (n = 0): <none>
[17:37:33.859] {
[17:37:33.859]     {
[17:37:33.859]         {
[17:37:33.859]             ...future.startTime <- base::Sys.time()
[17:37:33.859]             {
[17:37:33.859]                 {
[17:37:33.859]                   {
[17:37:33.859]                     base::local({
[17:37:33.859]                       has_future <- base::requireNamespace("future", 
[17:37:33.859]                         quietly = TRUE)
[17:37:33.859]                       if (has_future) {
[17:37:33.859]                         ns <- base::getNamespace("future")
[17:37:33.859]                         version <- ns[[".package"]][["version"]]
[17:37:33.859]                         if (is.null(version)) 
[17:37:33.859]                           version <- utils::packageVersion("future")
[17:37:33.859]                       }
[17:37:33.859]                       else {
[17:37:33.859]                         version <- NULL
[17:37:33.859]                       }
[17:37:33.859]                       if (!has_future || version < "1.8.0") {
[17:37:33.859]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:33.859]                           "", base::R.version$version.string), 
[17:37:33.859]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:33.859]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:33.859]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:33.859]                             "release", "version")], collapse = " "), 
[17:37:33.859]                           hostname = base::Sys.info()[["nodename"]])
[17:37:33.859]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:33.859]                           info)
[17:37:33.859]                         info <- base::paste(info, collapse = "; ")
[17:37:33.859]                         if (!has_future) {
[17:37:33.859]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:33.859]                             info)
[17:37:33.859]                         }
[17:37:33.859]                         else {
[17:37:33.859]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:33.859]                             info, version)
[17:37:33.859]                         }
[17:37:33.859]                         base::stop(msg)
[17:37:33.859]                       }
[17:37:33.859]                     })
[17:37:33.859]                   }
[17:37:33.859]                   ...future.strategy.old <- future::plan("list")
[17:37:33.859]                   options(future.plan = NULL)
[17:37:33.859]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:33.859]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:33.859]                 }
[17:37:33.859]                 ...future.workdir <- getwd()
[17:37:33.859]             }
[17:37:33.859]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:33.859]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:33.859]         }
[17:37:33.859]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:33.859]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:33.859]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:33.859]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:33.859]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:33.859]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:33.859]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:33.859]             base::names(...future.oldOptions))
[17:37:33.859]     }
[17:37:33.859]     if (FALSE) {
[17:37:33.859]     }
[17:37:33.859]     else {
[17:37:33.859]         if (TRUE) {
[17:37:33.859]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:33.859]                 open = "w")
[17:37:33.859]         }
[17:37:33.859]         else {
[17:37:33.859]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:33.859]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:33.859]         }
[17:37:33.859]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:33.859]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:33.859]             base::sink(type = "output", split = FALSE)
[17:37:33.859]             base::close(...future.stdout)
[17:37:33.859]         }, add = TRUE)
[17:37:33.859]     }
[17:37:33.859]     ...future.frame <- base::sys.nframe()
[17:37:33.859]     ...future.conditions <- base::list()
[17:37:33.859]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:33.859]     if (FALSE) {
[17:37:33.859]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:33.859]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:33.859]     }
[17:37:33.859]     ...future.result <- base::tryCatch({
[17:37:33.859]         base::withCallingHandlers({
[17:37:33.859]             ...future.value <- base::withVisible(base::local({
[17:37:33.859]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:33.859]                 if (!identical(...future.globals.maxSize.org, 
[17:37:33.859]                   ...future.globals.maxSize)) {
[17:37:33.859]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:33.859]                   on.exit(options(oopts), add = TRUE)
[17:37:33.859]                 }
[17:37:33.859]                 {
[17:37:33.859]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:33.859]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:33.859]                     USE.NAMES = FALSE)
[17:37:33.859]                   do.call(mapply, args = args)
[17:37:33.859]                 }
[17:37:33.859]             }))
[17:37:33.859]             future::FutureResult(value = ...future.value$value, 
[17:37:33.859]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:33.859]                   ...future.rng), globalenv = if (FALSE) 
[17:37:33.859]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:33.859]                     ...future.globalenv.names))
[17:37:33.859]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:33.859]         }, condition = base::local({
[17:37:33.859]             c <- base::c
[17:37:33.859]             inherits <- base::inherits
[17:37:33.859]             invokeRestart <- base::invokeRestart
[17:37:33.859]             length <- base::length
[17:37:33.859]             list <- base::list
[17:37:33.859]             seq.int <- base::seq.int
[17:37:33.859]             signalCondition <- base::signalCondition
[17:37:33.859]             sys.calls <- base::sys.calls
[17:37:33.859]             `[[` <- base::`[[`
[17:37:33.859]             `+` <- base::`+`
[17:37:33.859]             `<<-` <- base::`<<-`
[17:37:33.859]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:33.859]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:33.859]                   3L)]
[17:37:33.859]             }
[17:37:33.859]             function(cond) {
[17:37:33.859]                 is_error <- inherits(cond, "error")
[17:37:33.859]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:33.859]                   NULL)
[17:37:33.859]                 if (is_error) {
[17:37:33.859]                   sessionInformation <- function() {
[17:37:33.859]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:33.859]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:33.859]                       search = base::search(), system = base::Sys.info())
[17:37:33.859]                   }
[17:37:33.859]                   ...future.conditions[[length(...future.conditions) + 
[17:37:33.859]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:33.859]                     cond$call), session = sessionInformation(), 
[17:37:33.859]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:33.859]                   signalCondition(cond)
[17:37:33.859]                 }
[17:37:33.859]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:33.859]                 "immediateCondition"))) {
[17:37:33.859]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:33.859]                   ...future.conditions[[length(...future.conditions) + 
[17:37:33.859]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:33.859]                   if (TRUE && !signal) {
[17:37:33.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:33.859]                     {
[17:37:33.859]                       inherits <- base::inherits
[17:37:33.859]                       invokeRestart <- base::invokeRestart
[17:37:33.859]                       is.null <- base::is.null
[17:37:33.859]                       muffled <- FALSE
[17:37:33.859]                       if (inherits(cond, "message")) {
[17:37:33.859]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:33.859]                         if (muffled) 
[17:37:33.859]                           invokeRestart("muffleMessage")
[17:37:33.859]                       }
[17:37:33.859]                       else if (inherits(cond, "warning")) {
[17:37:33.859]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:33.859]                         if (muffled) 
[17:37:33.859]                           invokeRestart("muffleWarning")
[17:37:33.859]                       }
[17:37:33.859]                       else if (inherits(cond, "condition")) {
[17:37:33.859]                         if (!is.null(pattern)) {
[17:37:33.859]                           computeRestarts <- base::computeRestarts
[17:37:33.859]                           grepl <- base::grepl
[17:37:33.859]                           restarts <- computeRestarts(cond)
[17:37:33.859]                           for (restart in restarts) {
[17:37:33.859]                             name <- restart$name
[17:37:33.859]                             if (is.null(name)) 
[17:37:33.859]                               next
[17:37:33.859]                             if (!grepl(pattern, name)) 
[17:37:33.859]                               next
[17:37:33.859]                             invokeRestart(restart)
[17:37:33.859]                             muffled <- TRUE
[17:37:33.859]                             break
[17:37:33.859]                           }
[17:37:33.859]                         }
[17:37:33.859]                       }
[17:37:33.859]                       invisible(muffled)
[17:37:33.859]                     }
[17:37:33.859]                     muffleCondition(cond, pattern = "^muffle")
[17:37:33.859]                   }
[17:37:33.859]                 }
[17:37:33.859]                 else {
[17:37:33.859]                   if (TRUE) {
[17:37:33.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:33.859]                     {
[17:37:33.859]                       inherits <- base::inherits
[17:37:33.859]                       invokeRestart <- base::invokeRestart
[17:37:33.859]                       is.null <- base::is.null
[17:37:33.859]                       muffled <- FALSE
[17:37:33.859]                       if (inherits(cond, "message")) {
[17:37:33.859]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:33.859]                         if (muffled) 
[17:37:33.859]                           invokeRestart("muffleMessage")
[17:37:33.859]                       }
[17:37:33.859]                       else if (inherits(cond, "warning")) {
[17:37:33.859]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:33.859]                         if (muffled) 
[17:37:33.859]                           invokeRestart("muffleWarning")
[17:37:33.859]                       }
[17:37:33.859]                       else if (inherits(cond, "condition")) {
[17:37:33.859]                         if (!is.null(pattern)) {
[17:37:33.859]                           computeRestarts <- base::computeRestarts
[17:37:33.859]                           grepl <- base::grepl
[17:37:33.859]                           restarts <- computeRestarts(cond)
[17:37:33.859]                           for (restart in restarts) {
[17:37:33.859]                             name <- restart$name
[17:37:33.859]                             if (is.null(name)) 
[17:37:33.859]                               next
[17:37:33.859]                             if (!grepl(pattern, name)) 
[17:37:33.859]                               next
[17:37:33.859]                             invokeRestart(restart)
[17:37:33.859]                             muffled <- TRUE
[17:37:33.859]                             break
[17:37:33.859]                           }
[17:37:33.859]                         }
[17:37:33.859]                       }
[17:37:33.859]                       invisible(muffled)
[17:37:33.859]                     }
[17:37:33.859]                     muffleCondition(cond, pattern = "^muffle")
[17:37:33.859]                   }
[17:37:33.859]                 }
[17:37:33.859]             }
[17:37:33.859]         }))
[17:37:33.859]     }, error = function(ex) {
[17:37:33.859]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:33.859]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:33.859]                 ...future.rng), started = ...future.startTime, 
[17:37:33.859]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:33.859]             version = "1.8"), class = "FutureResult")
[17:37:33.859]     }, finally = {
[17:37:33.859]         if (!identical(...future.workdir, getwd())) 
[17:37:33.859]             setwd(...future.workdir)
[17:37:33.859]         {
[17:37:33.859]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:33.859]                 ...future.oldOptions$nwarnings <- NULL
[17:37:33.859]             }
[17:37:33.859]             base::options(...future.oldOptions)
[17:37:33.859]             if (.Platform$OS.type == "windows") {
[17:37:33.859]                 old_names <- names(...future.oldEnvVars)
[17:37:33.859]                 envs <- base::Sys.getenv()
[17:37:33.859]                 names <- names(envs)
[17:37:33.859]                 common <- intersect(names, old_names)
[17:37:33.859]                 added <- setdiff(names, old_names)
[17:37:33.859]                 removed <- setdiff(old_names, names)
[17:37:33.859]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:33.859]                   envs[common]]
[17:37:33.859]                 NAMES <- toupper(changed)
[17:37:33.859]                 args <- list()
[17:37:33.859]                 for (kk in seq_along(NAMES)) {
[17:37:33.859]                   name <- changed[[kk]]
[17:37:33.859]                   NAME <- NAMES[[kk]]
[17:37:33.859]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:33.859]                     next
[17:37:33.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:33.859]                 }
[17:37:33.859]                 NAMES <- toupper(added)
[17:37:33.859]                 for (kk in seq_along(NAMES)) {
[17:37:33.859]                   name <- added[[kk]]
[17:37:33.859]                   NAME <- NAMES[[kk]]
[17:37:33.859]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:33.859]                     next
[17:37:33.859]                   args[[name]] <- ""
[17:37:33.859]                 }
[17:37:33.859]                 NAMES <- toupper(removed)
[17:37:33.859]                 for (kk in seq_along(NAMES)) {
[17:37:33.859]                   name <- removed[[kk]]
[17:37:33.859]                   NAME <- NAMES[[kk]]
[17:37:33.859]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:33.859]                     next
[17:37:33.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:33.859]                 }
[17:37:33.859]                 if (length(args) > 0) 
[17:37:33.859]                   base::do.call(base::Sys.setenv, args = args)
[17:37:33.859]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:33.859]             }
[17:37:33.859]             else {
[17:37:33.859]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:33.859]             }
[17:37:33.859]             {
[17:37:33.859]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:33.859]                   0L) {
[17:37:33.859]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:33.859]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:33.859]                   base::options(opts)
[17:37:33.859]                 }
[17:37:33.859]                 {
[17:37:33.859]                   {
[17:37:33.859]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:33.859]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:33.859]                     -1786728155L), envir = base::globalenv(), 
[17:37:33.859]                       inherits = FALSE)
[17:37:33.859]                     NULL
[17:37:33.859]                   }
[17:37:33.859]                   options(future.plan = NULL)
[17:37:33.859]                   if (is.na(NA_character_)) 
[17:37:33.859]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:33.859]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:33.859]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:33.859]                     .init = FALSE)
[17:37:33.859]                 }
[17:37:33.859]             }
[17:37:33.859]         }
[17:37:33.859]     })
[17:37:33.859]     if (TRUE) {
[17:37:33.859]         base::sink(type = "output", split = FALSE)
[17:37:33.859]         if (TRUE) {
[17:37:33.859]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:33.859]         }
[17:37:33.859]         else {
[17:37:33.859]             ...future.result["stdout"] <- base::list(NULL)
[17:37:33.859]         }
[17:37:33.859]         base::close(...future.stdout)
[17:37:33.859]         ...future.stdout <- NULL
[17:37:33.859]     }
[17:37:33.859]     ...future.result$conditions <- ...future.conditions
[17:37:33.859]     ...future.result$finished <- base::Sys.time()
[17:37:33.859]     ...future.result
[17:37:33.859] }
[17:37:33.861] assign_globals() ...
[17:37:33.861] List of 5
[17:37:33.861]  $ ...future.FUN            :function (x, ...)  
[17:37:33.861]  $ MoreArgs                 : NULL
[17:37:33.861]  $ ...future.elements_ii    :List of 2
[17:37:33.861]   ..$ :List of 4
[17:37:33.861]   .. ..$ : int 1
[17:37:33.861]   .. ..$ : int 2
[17:37:33.861]   .. ..$ : int 3
[17:37:33.861]   .. ..$ : int 4
[17:37:33.861]   ..$ :List of 4
[17:37:33.861]   .. ..$ : int 4
[17:37:33.861]   .. ..$ : int 3
[17:37:33.861]   .. ..$ : int 2
[17:37:33.861]   .. ..$ : int 1
[17:37:33.861]  $ ...future.seeds_ii       : NULL
[17:37:33.861]  $ ...future.globals.maxSize: NULL
[17:37:33.861]  - attr(*, "where")=List of 5
[17:37:33.861]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:33.861]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:33.861]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:33.861]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:33.861]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:33.861]  - attr(*, "resolved")= logi FALSE
[17:37:33.861]  - attr(*, "total_size")= num 504
[17:37:33.861]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:33.861]  - attr(*, "already-done")= logi TRUE
[17:37:33.868] - copied ‘...future.FUN’ to environment
[17:37:33.868] - copied ‘MoreArgs’ to environment
[17:37:33.868] - copied ‘...future.elements_ii’ to environment
[17:37:33.868] - copied ‘...future.seeds_ii’ to environment
[17:37:33.868] - copied ‘...future.globals.maxSize’ to environment
[17:37:33.868] assign_globals() ... done
[17:37:33.868] plan(): Setting new future strategy stack:
[17:37:33.868] List of future strategies:
[17:37:33.868] 1. sequential:
[17:37:33.868]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:33.868]    - tweaked: FALSE
[17:37:33.868]    - call: NULL
[17:37:33.869] plan(): nbrOfWorkers() = 1
[17:37:33.870] plan(): Setting new future strategy stack:
[17:37:33.870] List of future strategies:
[17:37:33.870] 1. sequential:
[17:37:33.870]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:33.870]    - tweaked: FALSE
[17:37:33.870]    - call: plan(strategy)
[17:37:33.870] plan(): nbrOfWorkers() = 1
[17:37:33.870] SequentialFuture started (and completed)
[17:37:33.870] - Launch lazy future ... done
[17:37:33.870] run() for ‘SequentialFuture’ ... done
[17:37:33.871] Created future:
[17:37:33.871] SequentialFuture:
[17:37:33.871] Label: ‘future_mapply-1’
[17:37:33.871] Expression:
[17:37:33.871] {
[17:37:33.871]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:33.871]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:33.871]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:33.871]         on.exit(options(oopts), add = TRUE)
[17:37:33.871]     }
[17:37:33.871]     {
[17:37:33.871]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:33.871]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:33.871]         do.call(mapply, args = args)
[17:37:33.871]     }
[17:37:33.871] }
[17:37:33.871] Lazy evaluation: FALSE
[17:37:33.871] Asynchronous evaluation: FALSE
[17:37:33.871] Local evaluation: TRUE
[17:37:33.871] Environment: R_GlobalEnv
[17:37:33.871] Capture standard output: TRUE
[17:37:33.871] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:33.871] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:33.871] Packages: <none>
[17:37:33.871] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:33.871] Resolved: TRUE
[17:37:33.871] Value: 240 bytes of class ‘list’
[17:37:33.871] Early signaling: FALSE
[17:37:33.871] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:33.871] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:33.872] Chunk #1 of 1 ... DONE
[17:37:33.872] Launching 1 futures (chunks) ... DONE
[17:37:33.872] Resolving 1 futures (chunks) ...
[17:37:33.872] resolve() on list ...
[17:37:33.872]  recursive: 0
[17:37:33.872]  length: 1
[17:37:33.872] 
[17:37:33.872] resolved() for ‘SequentialFuture’ ...
[17:37:33.872] - state: ‘finished’
[17:37:33.872] - run: TRUE
[17:37:33.873] - result: ‘FutureResult’
[17:37:33.873] resolved() for ‘SequentialFuture’ ... done
[17:37:33.873] Future #1
[17:37:33.873] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:33.873] - nx: 1
[17:37:33.873] - relay: TRUE
[17:37:33.873] - stdout: TRUE
[17:37:33.873] - signal: TRUE
[17:37:33.873] - resignal: FALSE
[17:37:33.873] - force: TRUE
[17:37:33.873] - relayed: [n=1] FALSE
[17:37:33.874] - queued futures: [n=1] FALSE
[17:37:33.874]  - until=1
[17:37:33.874]  - relaying element #1
[17:37:33.874] - relayed: [n=1] TRUE
[17:37:33.874] - queued futures: [n=1] TRUE
[17:37:33.874] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:33.874]  length: 0 (resolved future 1)
[17:37:33.874] Relaying remaining futures
[17:37:33.874] signalConditionsASAP(NULL, pos=0) ...
[17:37:33.874] - nx: 1
[17:37:33.875] - relay: TRUE
[17:37:33.875] - stdout: TRUE
[17:37:33.875] - signal: TRUE
[17:37:33.875] - resignal: FALSE
[17:37:33.875] - force: TRUE
[17:37:33.875] - relayed: [n=1] TRUE
[17:37:33.875] - queued futures: [n=1] TRUE
 - flush all
[17:37:33.875] - relayed: [n=1] TRUE
[17:37:33.875] - queued futures: [n=1] TRUE
[17:37:33.875] signalConditionsASAP(NULL, pos=0) ... done
[17:37:33.875] resolve() on list ... DONE
[17:37:33.876]  - Number of value chunks collected: 1
[17:37:33.876] Resolving 1 futures (chunks) ... DONE
[17:37:33.876] Reducing values from 1 chunks ...
[17:37:33.876]  - Number of values collected after concatenation: 4
[17:37:33.876]  - Number of values expected: 4
[17:37:33.876] Reducing values from 1 chunks ... DONE
[17:37:33.876] future_mapply() ... DONE
[17:37:33.876] future_mapply() ...
[17:37:33.876] Number of chunks: 1
[17:37:33.877] getGlobalsAndPackagesXApply() ...
[17:37:33.877]  - future.globals: TRUE
[17:37:33.877] getGlobalsAndPackages() ...
[17:37:33.877] Searching for globals...
[17:37:33.877] - globals found: [1] ‘FUN’
[17:37:33.878] Searching for globals ... DONE
[17:37:33.878] Resolving globals: FALSE
[17:37:33.878] The total size of the 1 globals is 56 bytes (56 bytes)
[17:37:33.878] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:37:33.878] - globals: [1] ‘FUN’
[17:37:33.878] 
[17:37:33.879] getGlobalsAndPackages() ... DONE
[17:37:33.879]  - globals found/used: [n=1] ‘FUN’
[17:37:33.879]  - needed namespaces: [n=0] 
[17:37:33.879] Finding globals ... DONE
[17:37:33.879] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:33.879] List of 2
[17:37:33.879]  $ ...future.FUN:function (x, ...)  
[17:37:33.879]  $ MoreArgs     : NULL
[17:37:33.879]  - attr(*, "where")=List of 2
[17:37:33.879]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:33.879]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:33.879]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:33.879]  - attr(*, "resolved")= logi FALSE
[17:37:33.879]  - attr(*, "total_size")= num NA
[17:37:33.883] Packages to be attached in all futures: [n=0] 
[17:37:33.883] getGlobalsAndPackagesXApply() ... DONE
[17:37:33.883] Number of futures (= number of chunks): 1
[17:37:33.883] Launching 1 futures (chunks) ...
[17:37:33.883] Chunk #1 of 1 ...
[17:37:33.884]  - Finding globals in '...' for chunk #1 ...
[17:37:33.884] getGlobalsAndPackages() ...
[17:37:33.884] Searching for globals...
[17:37:33.884] 
[17:37:33.884] Searching for globals ... DONE
[17:37:33.884] - globals: [0] <none>
[17:37:33.884] getGlobalsAndPackages() ... DONE
[17:37:33.884]    + additional globals found: [n=0] 
[17:37:33.885]    + additional namespaces needed: [n=0] 
[17:37:33.885]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:33.885]  - seeds: <none>
[17:37:33.885]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:33.885] getGlobalsAndPackages() ...
[17:37:33.885] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:33.885] Resolving globals: FALSE
[17:37:33.886] The total size of the 5 globals is 504 bytes (504 bytes)
[17:37:33.886] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:33.886] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:33.886] 
[17:37:33.886] getGlobalsAndPackages() ... DONE
[17:37:33.887] run() for ‘Future’ ...
[17:37:33.887] - state: ‘created’
[17:37:33.887] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:33.887] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:33.887] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:33.887]   - Field: ‘label’
[17:37:33.887]   - Field: ‘local’
[17:37:33.887]   - Field: ‘owner’
[17:37:33.888]   - Field: ‘envir’
[17:37:33.888]   - Field: ‘packages’
[17:37:33.888]   - Field: ‘gc’
[17:37:33.888]   - Field: ‘conditions’
[17:37:33.888]   - Field: ‘expr’
[17:37:33.888]   - Field: ‘uuid’
[17:37:33.888]   - Field: ‘seed’
[17:37:33.888]   - Field: ‘version’
[17:37:33.888]   - Field: ‘result’
[17:37:33.888]   - Field: ‘asynchronous’
[17:37:33.888]   - Field: ‘calls’
[17:37:33.889]   - Field: ‘globals’
[17:37:33.889]   - Field: ‘stdout’
[17:37:33.889]   - Field: ‘earlySignal’
[17:37:33.889]   - Field: ‘lazy’
[17:37:33.889]   - Field: ‘state’
[17:37:33.889] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:33.889] - Launch lazy future ...
[17:37:33.889] Packages needed by the future expression (n = 0): <none>
[17:37:33.889] Packages needed by future strategies (n = 0): <none>
[17:37:33.890] {
[17:37:33.890]     {
[17:37:33.890]         {
[17:37:33.890]             ...future.startTime <- base::Sys.time()
[17:37:33.890]             {
[17:37:33.890]                 {
[17:37:33.890]                   {
[17:37:33.890]                     base::local({
[17:37:33.890]                       has_future <- base::requireNamespace("future", 
[17:37:33.890]                         quietly = TRUE)
[17:37:33.890]                       if (has_future) {
[17:37:33.890]                         ns <- base::getNamespace("future")
[17:37:33.890]                         version <- ns[[".package"]][["version"]]
[17:37:33.890]                         if (is.null(version)) 
[17:37:33.890]                           version <- utils::packageVersion("future")
[17:37:33.890]                       }
[17:37:33.890]                       else {
[17:37:33.890]                         version <- NULL
[17:37:33.890]                       }
[17:37:33.890]                       if (!has_future || version < "1.8.0") {
[17:37:33.890]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:33.890]                           "", base::R.version$version.string), 
[17:37:33.890]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:33.890]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:33.890]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:33.890]                             "release", "version")], collapse = " "), 
[17:37:33.890]                           hostname = base::Sys.info()[["nodename"]])
[17:37:33.890]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:33.890]                           info)
[17:37:33.890]                         info <- base::paste(info, collapse = "; ")
[17:37:33.890]                         if (!has_future) {
[17:37:33.890]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:33.890]                             info)
[17:37:33.890]                         }
[17:37:33.890]                         else {
[17:37:33.890]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:33.890]                             info, version)
[17:37:33.890]                         }
[17:37:33.890]                         base::stop(msg)
[17:37:33.890]                       }
[17:37:33.890]                     })
[17:37:33.890]                   }
[17:37:33.890]                   ...future.strategy.old <- future::plan("list")
[17:37:33.890]                   options(future.plan = NULL)
[17:37:33.890]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:33.890]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:33.890]                 }
[17:37:33.890]                 ...future.workdir <- getwd()
[17:37:33.890]             }
[17:37:33.890]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:33.890]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:33.890]         }
[17:37:33.890]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:33.890]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:33.890]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:33.890]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:33.890]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:33.890]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:33.890]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:33.890]             base::names(...future.oldOptions))
[17:37:33.890]     }
[17:37:33.890]     if (FALSE) {
[17:37:33.890]     }
[17:37:33.890]     else {
[17:37:33.890]         if (TRUE) {
[17:37:33.890]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:33.890]                 open = "w")
[17:37:33.890]         }
[17:37:33.890]         else {
[17:37:33.890]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:33.890]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:33.890]         }
[17:37:33.890]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:33.890]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:33.890]             base::sink(type = "output", split = FALSE)
[17:37:33.890]             base::close(...future.stdout)
[17:37:33.890]         }, add = TRUE)
[17:37:33.890]     }
[17:37:33.890]     ...future.frame <- base::sys.nframe()
[17:37:33.890]     ...future.conditions <- base::list()
[17:37:33.890]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:33.890]     if (FALSE) {
[17:37:33.890]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:33.890]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:33.890]     }
[17:37:33.890]     ...future.result <- base::tryCatch({
[17:37:33.890]         base::withCallingHandlers({
[17:37:33.890]             ...future.value <- base::withVisible(base::local({
[17:37:33.890]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:33.890]                 if (!identical(...future.globals.maxSize.org, 
[17:37:33.890]                   ...future.globals.maxSize)) {
[17:37:33.890]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:33.890]                   on.exit(options(oopts), add = TRUE)
[17:37:33.890]                 }
[17:37:33.890]                 {
[17:37:33.890]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:33.890]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:33.890]                     USE.NAMES = FALSE)
[17:37:33.890]                   do.call(mapply, args = args)
[17:37:33.890]                 }
[17:37:33.890]             }))
[17:37:33.890]             future::FutureResult(value = ...future.value$value, 
[17:37:33.890]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:33.890]                   ...future.rng), globalenv = if (FALSE) 
[17:37:33.890]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:33.890]                     ...future.globalenv.names))
[17:37:33.890]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:33.890]         }, condition = base::local({
[17:37:33.890]             c <- base::c
[17:37:33.890]             inherits <- base::inherits
[17:37:33.890]             invokeRestart <- base::invokeRestart
[17:37:33.890]             length <- base::length
[17:37:33.890]             list <- base::list
[17:37:33.890]             seq.int <- base::seq.int
[17:37:33.890]             signalCondition <- base::signalCondition
[17:37:33.890]             sys.calls <- base::sys.calls
[17:37:33.890]             `[[` <- base::`[[`
[17:37:33.890]             `+` <- base::`+`
[17:37:33.890]             `<<-` <- base::`<<-`
[17:37:33.890]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:33.890]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:33.890]                   3L)]
[17:37:33.890]             }
[17:37:33.890]             function(cond) {
[17:37:33.890]                 is_error <- inherits(cond, "error")
[17:37:33.890]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:33.890]                   NULL)
[17:37:33.890]                 if (is_error) {
[17:37:33.890]                   sessionInformation <- function() {
[17:37:33.890]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:33.890]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:33.890]                       search = base::search(), system = base::Sys.info())
[17:37:33.890]                   }
[17:37:33.890]                   ...future.conditions[[length(...future.conditions) + 
[17:37:33.890]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:33.890]                     cond$call), session = sessionInformation(), 
[17:37:33.890]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:33.890]                   signalCondition(cond)
[17:37:33.890]                 }
[17:37:33.890]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:33.890]                 "immediateCondition"))) {
[17:37:33.890]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:33.890]                   ...future.conditions[[length(...future.conditions) + 
[17:37:33.890]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:33.890]                   if (TRUE && !signal) {
[17:37:33.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:33.890]                     {
[17:37:33.890]                       inherits <- base::inherits
[17:37:33.890]                       invokeRestart <- base::invokeRestart
[17:37:33.890]                       is.null <- base::is.null
[17:37:33.890]                       muffled <- FALSE
[17:37:33.890]                       if (inherits(cond, "message")) {
[17:37:33.890]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:33.890]                         if (muffled) 
[17:37:33.890]                           invokeRestart("muffleMessage")
[17:37:33.890]                       }
[17:37:33.890]                       else if (inherits(cond, "warning")) {
[17:37:33.890]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:33.890]                         if (muffled) 
[17:37:33.890]                           invokeRestart("muffleWarning")
[17:37:33.890]                       }
[17:37:33.890]                       else if (inherits(cond, "condition")) {
[17:37:33.890]                         if (!is.null(pattern)) {
[17:37:33.890]                           computeRestarts <- base::computeRestarts
[17:37:33.890]                           grepl <- base::grepl
[17:37:33.890]                           restarts <- computeRestarts(cond)
[17:37:33.890]                           for (restart in restarts) {
[17:37:33.890]                             name <- restart$name
[17:37:33.890]                             if (is.null(name)) 
[17:37:33.890]                               next
[17:37:33.890]                             if (!grepl(pattern, name)) 
[17:37:33.890]                               next
[17:37:33.890]                             invokeRestart(restart)
[17:37:33.890]                             muffled <- TRUE
[17:37:33.890]                             break
[17:37:33.890]                           }
[17:37:33.890]                         }
[17:37:33.890]                       }
[17:37:33.890]                       invisible(muffled)
[17:37:33.890]                     }
[17:37:33.890]                     muffleCondition(cond, pattern = "^muffle")
[17:37:33.890]                   }
[17:37:33.890]                 }
[17:37:33.890]                 else {
[17:37:33.890]                   if (TRUE) {
[17:37:33.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:33.890]                     {
[17:37:33.890]                       inherits <- base::inherits
[17:37:33.890]                       invokeRestart <- base::invokeRestart
[17:37:33.890]                       is.null <- base::is.null
[17:37:33.890]                       muffled <- FALSE
[17:37:33.890]                       if (inherits(cond, "message")) {
[17:37:33.890]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:33.890]                         if (muffled) 
[17:37:33.890]                           invokeRestart("muffleMessage")
[17:37:33.890]                       }
[17:37:33.890]                       else if (inherits(cond, "warning")) {
[17:37:33.890]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:33.890]                         if (muffled) 
[17:37:33.890]                           invokeRestart("muffleWarning")
[17:37:33.890]                       }
[17:37:33.890]                       else if (inherits(cond, "condition")) {
[17:37:33.890]                         if (!is.null(pattern)) {
[17:37:33.890]                           computeRestarts <- base::computeRestarts
[17:37:33.890]                           grepl <- base::grepl
[17:37:33.890]                           restarts <- computeRestarts(cond)
[17:37:33.890]                           for (restart in restarts) {
[17:37:33.890]                             name <- restart$name
[17:37:33.890]                             if (is.null(name)) 
[17:37:33.890]                               next
[17:37:33.890]                             if (!grepl(pattern, name)) 
[17:37:33.890]                               next
[17:37:33.890]                             invokeRestart(restart)
[17:37:33.890]                             muffled <- TRUE
[17:37:33.890]                             break
[17:37:33.890]                           }
[17:37:33.890]                         }
[17:37:33.890]                       }
[17:37:33.890]                       invisible(muffled)
[17:37:33.890]                     }
[17:37:33.890]                     muffleCondition(cond, pattern = "^muffle")
[17:37:33.890]                   }
[17:37:33.890]                 }
[17:37:33.890]             }
[17:37:33.890]         }))
[17:37:33.890]     }, error = function(ex) {
[17:37:33.890]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:33.890]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:33.890]                 ...future.rng), started = ...future.startTime, 
[17:37:33.890]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:33.890]             version = "1.8"), class = "FutureResult")
[17:37:33.890]     }, finally = {
[17:37:33.890]         if (!identical(...future.workdir, getwd())) 
[17:37:33.890]             setwd(...future.workdir)
[17:37:33.890]         {
[17:37:33.890]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:33.890]                 ...future.oldOptions$nwarnings <- NULL
[17:37:33.890]             }
[17:37:33.890]             base::options(...future.oldOptions)
[17:37:33.890]             if (.Platform$OS.type == "windows") {
[17:37:33.890]                 old_names <- names(...future.oldEnvVars)
[17:37:33.890]                 envs <- base::Sys.getenv()
[17:37:33.890]                 names <- names(envs)
[17:37:33.890]                 common <- intersect(names, old_names)
[17:37:33.890]                 added <- setdiff(names, old_names)
[17:37:33.890]                 removed <- setdiff(old_names, names)
[17:37:33.890]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:33.890]                   envs[common]]
[17:37:33.890]                 NAMES <- toupper(changed)
[17:37:33.890]                 args <- list()
[17:37:33.890]                 for (kk in seq_along(NAMES)) {
[17:37:33.890]                   name <- changed[[kk]]
[17:37:33.890]                   NAME <- NAMES[[kk]]
[17:37:33.890]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:33.890]                     next
[17:37:33.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:33.890]                 }
[17:37:33.890]                 NAMES <- toupper(added)
[17:37:33.890]                 for (kk in seq_along(NAMES)) {
[17:37:33.890]                   name <- added[[kk]]
[17:37:33.890]                   NAME <- NAMES[[kk]]
[17:37:33.890]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:33.890]                     next
[17:37:33.890]                   args[[name]] <- ""
[17:37:33.890]                 }
[17:37:33.890]                 NAMES <- toupper(removed)
[17:37:33.890]                 for (kk in seq_along(NAMES)) {
[17:37:33.890]                   name <- removed[[kk]]
[17:37:33.890]                   NAME <- NAMES[[kk]]
[17:37:33.890]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:33.890]                     next
[17:37:33.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:33.890]                 }
[17:37:33.890]                 if (length(args) > 0) 
[17:37:33.890]                   base::do.call(base::Sys.setenv, args = args)
[17:37:33.890]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:33.890]             }
[17:37:33.890]             else {
[17:37:33.890]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:33.890]             }
[17:37:33.890]             {
[17:37:33.890]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:33.890]                   0L) {
[17:37:33.890]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:33.890]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:33.890]                   base::options(opts)
[17:37:33.890]                 }
[17:37:33.890]                 {
[17:37:33.890]                   {
[17:37:33.890]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:33.890]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:33.890]                     -1786728155L), envir = base::globalenv(), 
[17:37:33.890]                       inherits = FALSE)
[17:37:33.890]                     NULL
[17:37:33.890]                   }
[17:37:33.890]                   options(future.plan = NULL)
[17:37:33.890]                   if (is.na(NA_character_)) 
[17:37:33.890]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:33.890]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:33.890]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:33.890]                     .init = FALSE)
[17:37:33.890]                 }
[17:37:33.890]             }
[17:37:33.890]         }
[17:37:33.890]     })
[17:37:33.890]     if (TRUE) {
[17:37:33.890]         base::sink(type = "output", split = FALSE)
[17:37:33.890]         if (TRUE) {
[17:37:33.890]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:33.890]         }
[17:37:33.890]         else {
[17:37:33.890]             ...future.result["stdout"] <- base::list(NULL)
[17:37:33.890]         }
[17:37:33.890]         base::close(...future.stdout)
[17:37:33.890]         ...future.stdout <- NULL
[17:37:33.890]     }
[17:37:33.890]     ...future.result$conditions <- ...future.conditions
[17:37:33.890]     ...future.result$finished <- base::Sys.time()
[17:37:33.890]     ...future.result
[17:37:33.890] }
[17:37:33.891] assign_globals() ...
[17:37:33.891] List of 5
[17:37:33.891]  $ ...future.FUN            :function (x, ...)  
[17:37:33.891]  $ MoreArgs                 : NULL
[17:37:33.891]  $ ...future.elements_ii    :List of 2
[17:37:33.891]   ..$ times:List of 4
[17:37:33.891]   .. ..$ : int 1
[17:37:33.891]   .. ..$ : int 2
[17:37:33.891]   .. ..$ : int 3
[17:37:33.891]   .. ..$ : int 4
[17:37:33.891]   ..$ x    :List of 4
[17:37:33.891]   .. ..$ : int 4
[17:37:33.891]   .. ..$ : int 3
[17:37:33.891]   .. ..$ : int 2
[17:37:33.891]   .. ..$ : int 1
[17:37:33.891]  $ ...future.seeds_ii       : NULL
[17:37:33.891]  $ ...future.globals.maxSize: NULL
[17:37:33.891]  - attr(*, "where")=List of 5
[17:37:33.891]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:33.891]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:33.891]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:33.891]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:33.891]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:33.891]  - attr(*, "resolved")= logi FALSE
[17:37:33.891]  - attr(*, "total_size")= num 504
[17:37:33.891]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:33.891]  - attr(*, "already-done")= logi TRUE
[17:37:33.898] - copied ‘...future.FUN’ to environment
[17:37:33.898] - copied ‘MoreArgs’ to environment
[17:37:33.898] - copied ‘...future.elements_ii’ to environment
[17:37:33.898] - copied ‘...future.seeds_ii’ to environment
[17:37:33.898] - copied ‘...future.globals.maxSize’ to environment
[17:37:33.898] assign_globals() ... done
[17:37:33.899] plan(): Setting new future strategy stack:
[17:37:33.899] List of future strategies:
[17:37:33.899] 1. sequential:
[17:37:33.899]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:33.899]    - tweaked: FALSE
[17:37:33.899]    - call: NULL
[17:37:33.899] plan(): nbrOfWorkers() = 1
[17:37:33.900] plan(): Setting new future strategy stack:
[17:37:33.900] List of future strategies:
[17:37:33.900] 1. sequential:
[17:37:33.900]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:33.900]    - tweaked: FALSE
[17:37:33.900]    - call: plan(strategy)
[17:37:33.900] plan(): nbrOfWorkers() = 1
[17:37:33.900] SequentialFuture started (and completed)
[17:37:33.901] - Launch lazy future ... done
[17:37:33.901] run() for ‘SequentialFuture’ ... done
[17:37:33.901] Created future:
[17:37:33.901] SequentialFuture:
[17:37:33.901] Label: ‘future_mapply-1’
[17:37:33.901] Expression:
[17:37:33.901] {
[17:37:33.901]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:33.901]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:33.901]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:33.901]         on.exit(options(oopts), add = TRUE)
[17:37:33.901]     }
[17:37:33.901]     {
[17:37:33.901]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:33.901]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:33.901]         do.call(mapply, args = args)
[17:37:33.901]     }
[17:37:33.901] }
[17:37:33.901] Lazy evaluation: FALSE
[17:37:33.901] Asynchronous evaluation: FALSE
[17:37:33.901] Local evaluation: TRUE
[17:37:33.901] Environment: R_GlobalEnv
[17:37:33.901] Capture standard output: TRUE
[17:37:33.901] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:33.901] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:33.901] Packages: <none>
[17:37:33.901] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:33.901] Resolved: TRUE
[17:37:33.901] Value: 240 bytes of class ‘list’
[17:37:33.901] Early signaling: FALSE
[17:37:33.901] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:33.901] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:33.902] Chunk #1 of 1 ... DONE
[17:37:33.902] Launching 1 futures (chunks) ... DONE
[17:37:33.902] Resolving 1 futures (chunks) ...
[17:37:33.902] resolve() on list ...
[17:37:33.902]  recursive: 0
[17:37:33.902]  length: 1
[17:37:33.902] 
[17:37:33.902] resolved() for ‘SequentialFuture’ ...
[17:37:33.902] - state: ‘finished’
[17:37:33.903] - run: TRUE
[17:37:33.903] - result: ‘FutureResult’
[17:37:33.903] resolved() for ‘SequentialFuture’ ... done
[17:37:33.903] Future #1
[17:37:33.903] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:33.903] - nx: 1
[17:37:33.903] - relay: TRUE
[17:37:33.903] - stdout: TRUE
[17:37:33.903] - signal: TRUE
[17:37:33.903] - resignal: FALSE
[17:37:33.903] - force: TRUE
[17:37:33.904] - relayed: [n=1] FALSE
[17:37:33.904] - queued futures: [n=1] FALSE
[17:37:33.904]  - until=1
[17:37:33.904]  - relaying element #1
[17:37:33.904] - relayed: [n=1] TRUE
[17:37:33.904] - queued futures: [n=1] TRUE
[17:37:33.904] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:33.904]  length: 0 (resolved future 1)
[17:37:33.904] Relaying remaining futures
[17:37:33.904] signalConditionsASAP(NULL, pos=0) ...
[17:37:33.905] - nx: 1
[17:37:33.905] - relay: TRUE
[17:37:33.905] - stdout: TRUE
[17:37:33.905] - signal: TRUE
[17:37:33.905] - resignal: FALSE
[17:37:33.905] - force: TRUE
[17:37:33.905] - relayed: [n=1] TRUE
[17:37:33.905] - queued futures: [n=1] TRUE
 - flush all
[17:37:33.905] - relayed: [n=1] TRUE
[17:37:33.905] - queued futures: [n=1] TRUE
[17:37:33.905] signalConditionsASAP(NULL, pos=0) ... done
[17:37:33.906] resolve() on list ... DONE
[17:37:33.907]  - Number of value chunks collected: 1
[17:37:33.907] Resolving 1 futures (chunks) ... DONE
[17:37:33.907] Reducing values from 1 chunks ...
[17:37:33.907]  - Number of values collected after concatenation: 4
[17:37:33.907]  - Number of values expected: 4
[17:37:33.907] Reducing values from 1 chunks ... DONE
[17:37:33.908] future_mapply() ... DONE
[17:37:33.908] future_mapply() ...
[17:37:33.908] Number of chunks: 1
[17:37:33.908] getGlobalsAndPackagesXApply() ...
[17:37:33.908]  - future.globals: TRUE
[17:37:33.908] getGlobalsAndPackages() ...
[17:37:33.908] Searching for globals...
[17:37:33.909] - globals found: [1] ‘FUN’
[17:37:33.909] Searching for globals ... DONE
[17:37:33.909] Resolving globals: FALSE
[17:37:33.909] The total size of the 1 globals is 56 bytes (56 bytes)
[17:37:33.910] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:37:33.910] - globals: [1] ‘FUN’
[17:37:33.910] 
[17:37:33.910] getGlobalsAndPackages() ... DONE
[17:37:33.910]  - globals found/used: [n=1] ‘FUN’
[17:37:33.910]  - needed namespaces: [n=0] 
[17:37:33.910] Finding globals ... DONE
[17:37:33.910] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:33.911] List of 2
[17:37:33.911]  $ ...future.FUN:function (x, ...)  
[17:37:33.911]  $ MoreArgs     :List of 1
[17:37:33.911]   ..$ x: num 42
[17:37:33.911]  - attr(*, "where")=List of 2
[17:37:33.911]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:33.911]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:33.911]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:33.911]  - attr(*, "resolved")= logi FALSE
[17:37:33.911]  - attr(*, "total_size")= num NA
[17:37:33.913] Packages to be attached in all futures: [n=0] 
[17:37:33.913] getGlobalsAndPackagesXApply() ... DONE
[17:37:33.914] Number of futures (= number of chunks): 1
[17:37:33.914] Launching 1 futures (chunks) ...
[17:37:33.914] Chunk #1 of 1 ...
[17:37:33.914]  - Finding globals in '...' for chunk #1 ...
[17:37:33.914] getGlobalsAndPackages() ...
[17:37:33.914] Searching for globals...
[17:37:33.914] 
[17:37:33.914] Searching for globals ... DONE
[17:37:33.915] - globals: [0] <none>
[17:37:33.915] getGlobalsAndPackages() ... DONE
[17:37:33.915]    + additional globals found: [n=0] 
[17:37:33.915]    + additional namespaces needed: [n=0] 
[17:37:33.915]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:33.915]  - seeds: <none>
[17:37:33.915]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:33.915] getGlobalsAndPackages() ...
[17:37:33.915] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:33.915] Resolving globals: FALSE
[17:37:33.916] The total size of the 5 globals is 336 bytes (336 bytes)
[17:37:33.916] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 336 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:37:33.916] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:33.916] 
[17:37:33.917] getGlobalsAndPackages() ... DONE
[17:37:33.917] run() for ‘Future’ ...
[17:37:33.917] - state: ‘created’
[17:37:33.917] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:33.917] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:33.917] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:33.917]   - Field: ‘label’
[17:37:33.918]   - Field: ‘local’
[17:37:33.918]   - Field: ‘owner’
[17:37:33.918]   - Field: ‘envir’
[17:37:33.918]   - Field: ‘packages’
[17:37:33.918]   - Field: ‘gc’
[17:37:33.918]   - Field: ‘conditions’
[17:37:33.918]   - Field: ‘expr’
[17:37:33.918]   - Field: ‘uuid’
[17:37:33.918]   - Field: ‘seed’
[17:37:33.918]   - Field: ‘version’
[17:37:33.918]   - Field: ‘result’
[17:37:33.919]   - Field: ‘asynchronous’
[17:37:33.919]   - Field: ‘calls’
[17:37:33.919]   - Field: ‘globals’
[17:37:33.919]   - Field: ‘stdout’
[17:37:33.919]   - Field: ‘earlySignal’
[17:37:33.919]   - Field: ‘lazy’
[17:37:33.919]   - Field: ‘state’
[17:37:33.919] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:33.919] - Launch lazy future ...
[17:37:33.919] Packages needed by the future expression (n = 0): <none>
[17:37:33.920] Packages needed by future strategies (n = 0): <none>
[17:37:33.920] {
[17:37:33.920]     {
[17:37:33.920]         {
[17:37:33.920]             ...future.startTime <- base::Sys.time()
[17:37:33.920]             {
[17:37:33.920]                 {
[17:37:33.920]                   {
[17:37:33.920]                     base::local({
[17:37:33.920]                       has_future <- base::requireNamespace("future", 
[17:37:33.920]                         quietly = TRUE)
[17:37:33.920]                       if (has_future) {
[17:37:33.920]                         ns <- base::getNamespace("future")
[17:37:33.920]                         version <- ns[[".package"]][["version"]]
[17:37:33.920]                         if (is.null(version)) 
[17:37:33.920]                           version <- utils::packageVersion("future")
[17:37:33.920]                       }
[17:37:33.920]                       else {
[17:37:33.920]                         version <- NULL
[17:37:33.920]                       }
[17:37:33.920]                       if (!has_future || version < "1.8.0") {
[17:37:33.920]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:33.920]                           "", base::R.version$version.string), 
[17:37:33.920]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:33.920]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:33.920]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:33.920]                             "release", "version")], collapse = " "), 
[17:37:33.920]                           hostname = base::Sys.info()[["nodename"]])
[17:37:33.920]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:33.920]                           info)
[17:37:33.920]                         info <- base::paste(info, collapse = "; ")
[17:37:33.920]                         if (!has_future) {
[17:37:33.920]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:33.920]                             info)
[17:37:33.920]                         }
[17:37:33.920]                         else {
[17:37:33.920]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:33.920]                             info, version)
[17:37:33.920]                         }
[17:37:33.920]                         base::stop(msg)
[17:37:33.920]                       }
[17:37:33.920]                     })
[17:37:33.920]                   }
[17:37:33.920]                   ...future.strategy.old <- future::plan("list")
[17:37:33.920]                   options(future.plan = NULL)
[17:37:33.920]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:33.920]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:33.920]                 }
[17:37:33.920]                 ...future.workdir <- getwd()
[17:37:33.920]             }
[17:37:33.920]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:33.920]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:33.920]         }
[17:37:33.920]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:33.920]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:33.920]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:33.920]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:33.920]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:33.920]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:33.920]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:33.920]             base::names(...future.oldOptions))
[17:37:33.920]     }
[17:37:33.920]     if (FALSE) {
[17:37:33.920]     }
[17:37:33.920]     else {
[17:37:33.920]         if (TRUE) {
[17:37:33.920]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:33.920]                 open = "w")
[17:37:33.920]         }
[17:37:33.920]         else {
[17:37:33.920]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:33.920]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:33.920]         }
[17:37:33.920]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:33.920]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:33.920]             base::sink(type = "output", split = FALSE)
[17:37:33.920]             base::close(...future.stdout)
[17:37:33.920]         }, add = TRUE)
[17:37:33.920]     }
[17:37:33.920]     ...future.frame <- base::sys.nframe()
[17:37:33.920]     ...future.conditions <- base::list()
[17:37:33.920]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:33.920]     if (FALSE) {
[17:37:33.920]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:33.920]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:33.920]     }
[17:37:33.920]     ...future.result <- base::tryCatch({
[17:37:33.920]         base::withCallingHandlers({
[17:37:33.920]             ...future.value <- base::withVisible(base::local({
[17:37:33.920]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:33.920]                 if (!identical(...future.globals.maxSize.org, 
[17:37:33.920]                   ...future.globals.maxSize)) {
[17:37:33.920]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:33.920]                   on.exit(options(oopts), add = TRUE)
[17:37:33.920]                 }
[17:37:33.920]                 {
[17:37:33.920]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:33.920]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:33.920]                     USE.NAMES = FALSE)
[17:37:33.920]                   do.call(mapply, args = args)
[17:37:33.920]                 }
[17:37:33.920]             }))
[17:37:33.920]             future::FutureResult(value = ...future.value$value, 
[17:37:33.920]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:33.920]                   ...future.rng), globalenv = if (FALSE) 
[17:37:33.920]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:33.920]                     ...future.globalenv.names))
[17:37:33.920]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:33.920]         }, condition = base::local({
[17:37:33.920]             c <- base::c
[17:37:33.920]             inherits <- base::inherits
[17:37:33.920]             invokeRestart <- base::invokeRestart
[17:37:33.920]             length <- base::length
[17:37:33.920]             list <- base::list
[17:37:33.920]             seq.int <- base::seq.int
[17:37:33.920]             signalCondition <- base::signalCondition
[17:37:33.920]             sys.calls <- base::sys.calls
[17:37:33.920]             `[[` <- base::`[[`
[17:37:33.920]             `+` <- base::`+`
[17:37:33.920]             `<<-` <- base::`<<-`
[17:37:33.920]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:33.920]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:33.920]                   3L)]
[17:37:33.920]             }
[17:37:33.920]             function(cond) {
[17:37:33.920]                 is_error <- inherits(cond, "error")
[17:37:33.920]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:33.920]                   NULL)
[17:37:33.920]                 if (is_error) {
[17:37:33.920]                   sessionInformation <- function() {
[17:37:33.920]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:33.920]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:33.920]                       search = base::search(), system = base::Sys.info())
[17:37:33.920]                   }
[17:37:33.920]                   ...future.conditions[[length(...future.conditions) + 
[17:37:33.920]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:33.920]                     cond$call), session = sessionInformation(), 
[17:37:33.920]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:33.920]                   signalCondition(cond)
[17:37:33.920]                 }
[17:37:33.920]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:33.920]                 "immediateCondition"))) {
[17:37:33.920]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:33.920]                   ...future.conditions[[length(...future.conditions) + 
[17:37:33.920]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:33.920]                   if (TRUE && !signal) {
[17:37:33.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:33.920]                     {
[17:37:33.920]                       inherits <- base::inherits
[17:37:33.920]                       invokeRestart <- base::invokeRestart
[17:37:33.920]                       is.null <- base::is.null
[17:37:33.920]                       muffled <- FALSE
[17:37:33.920]                       if (inherits(cond, "message")) {
[17:37:33.920]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:33.920]                         if (muffled) 
[17:37:33.920]                           invokeRestart("muffleMessage")
[17:37:33.920]                       }
[17:37:33.920]                       else if (inherits(cond, "warning")) {
[17:37:33.920]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:33.920]                         if (muffled) 
[17:37:33.920]                           invokeRestart("muffleWarning")
[17:37:33.920]                       }
[17:37:33.920]                       else if (inherits(cond, "condition")) {
[17:37:33.920]                         if (!is.null(pattern)) {
[17:37:33.920]                           computeRestarts <- base::computeRestarts
[17:37:33.920]                           grepl <- base::grepl
[17:37:33.920]                           restarts <- computeRestarts(cond)
[17:37:33.920]                           for (restart in restarts) {
[17:37:33.920]                             name <- restart$name
[17:37:33.920]                             if (is.null(name)) 
[17:37:33.920]                               next
[17:37:33.920]                             if (!grepl(pattern, name)) 
[17:37:33.920]                               next
[17:37:33.920]                             invokeRestart(restart)
[17:37:33.920]                             muffled <- TRUE
[17:37:33.920]                             break
[17:37:33.920]                           }
[17:37:33.920]                         }
[17:37:33.920]                       }
[17:37:33.920]                       invisible(muffled)
[17:37:33.920]                     }
[17:37:33.920]                     muffleCondition(cond, pattern = "^muffle")
[17:37:33.920]                   }
[17:37:33.920]                 }
[17:37:33.920]                 else {
[17:37:33.920]                   if (TRUE) {
[17:37:33.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:33.920]                     {
[17:37:33.920]                       inherits <- base::inherits
[17:37:33.920]                       invokeRestart <- base::invokeRestart
[17:37:33.920]                       is.null <- base::is.null
[17:37:33.920]                       muffled <- FALSE
[17:37:33.920]                       if (inherits(cond, "message")) {
[17:37:33.920]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:33.920]                         if (muffled) 
[17:37:33.920]                           invokeRestart("muffleMessage")
[17:37:33.920]                       }
[17:37:33.920]                       else if (inherits(cond, "warning")) {
[17:37:33.920]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:33.920]                         if (muffled) 
[17:37:33.920]                           invokeRestart("muffleWarning")
[17:37:33.920]                       }
[17:37:33.920]                       else if (inherits(cond, "condition")) {
[17:37:33.920]                         if (!is.null(pattern)) {
[17:37:33.920]                           computeRestarts <- base::computeRestarts
[17:37:33.920]                           grepl <- base::grepl
[17:37:33.920]                           restarts <- computeRestarts(cond)
[17:37:33.920]                           for (restart in restarts) {
[17:37:33.920]                             name <- restart$name
[17:37:33.920]                             if (is.null(name)) 
[17:37:33.920]                               next
[17:37:33.920]                             if (!grepl(pattern, name)) 
[17:37:33.920]                               next
[17:37:33.920]                             invokeRestart(restart)
[17:37:33.920]                             muffled <- TRUE
[17:37:33.920]                             break
[17:37:33.920]                           }
[17:37:33.920]                         }
[17:37:33.920]                       }
[17:37:33.920]                       invisible(muffled)
[17:37:33.920]                     }
[17:37:33.920]                     muffleCondition(cond, pattern = "^muffle")
[17:37:33.920]                   }
[17:37:33.920]                 }
[17:37:33.920]             }
[17:37:33.920]         }))
[17:37:33.920]     }, error = function(ex) {
[17:37:33.920]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:33.920]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:33.920]                 ...future.rng), started = ...future.startTime, 
[17:37:33.920]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:33.920]             version = "1.8"), class = "FutureResult")
[17:37:33.920]     }, finally = {
[17:37:33.920]         if (!identical(...future.workdir, getwd())) 
[17:37:33.920]             setwd(...future.workdir)
[17:37:33.920]         {
[17:37:33.920]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:33.920]                 ...future.oldOptions$nwarnings <- NULL
[17:37:33.920]             }
[17:37:33.920]             base::options(...future.oldOptions)
[17:37:33.920]             if (.Platform$OS.type == "windows") {
[17:37:33.920]                 old_names <- names(...future.oldEnvVars)
[17:37:33.920]                 envs <- base::Sys.getenv()
[17:37:33.920]                 names <- names(envs)
[17:37:33.920]                 common <- intersect(names, old_names)
[17:37:33.920]                 added <- setdiff(names, old_names)
[17:37:33.920]                 removed <- setdiff(old_names, names)
[17:37:33.920]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:33.920]                   envs[common]]
[17:37:33.920]                 NAMES <- toupper(changed)
[17:37:33.920]                 args <- list()
[17:37:33.920]                 for (kk in seq_along(NAMES)) {
[17:37:33.920]                   name <- changed[[kk]]
[17:37:33.920]                   NAME <- NAMES[[kk]]
[17:37:33.920]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:33.920]                     next
[17:37:33.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:33.920]                 }
[17:37:33.920]                 NAMES <- toupper(added)
[17:37:33.920]                 for (kk in seq_along(NAMES)) {
[17:37:33.920]                   name <- added[[kk]]
[17:37:33.920]                   NAME <- NAMES[[kk]]
[17:37:33.920]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:33.920]                     next
[17:37:33.920]                   args[[name]] <- ""
[17:37:33.920]                 }
[17:37:33.920]                 NAMES <- toupper(removed)
[17:37:33.920]                 for (kk in seq_along(NAMES)) {
[17:37:33.920]                   name <- removed[[kk]]
[17:37:33.920]                   NAME <- NAMES[[kk]]
[17:37:33.920]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:33.920]                     next
[17:37:33.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:33.920]                 }
[17:37:33.920]                 if (length(args) > 0) 
[17:37:33.920]                   base::do.call(base::Sys.setenv, args = args)
[17:37:33.920]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:33.920]             }
[17:37:33.920]             else {
[17:37:33.920]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:33.920]             }
[17:37:33.920]             {
[17:37:33.920]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:33.920]                   0L) {
[17:37:33.920]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:33.920]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:33.920]                   base::options(opts)
[17:37:33.920]                 }
[17:37:33.920]                 {
[17:37:33.920]                   {
[17:37:33.920]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:33.920]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:33.920]                     -1786728155L), envir = base::globalenv(), 
[17:37:33.920]                       inherits = FALSE)
[17:37:33.920]                     NULL
[17:37:33.920]                   }
[17:37:33.920]                   options(future.plan = NULL)
[17:37:33.920]                   if (is.na(NA_character_)) 
[17:37:33.920]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:33.920]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:33.920]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:33.920]                     .init = FALSE)
[17:37:33.920]                 }
[17:37:33.920]             }
[17:37:33.920]         }
[17:37:33.920]     })
[17:37:33.920]     if (TRUE) {
[17:37:33.920]         base::sink(type = "output", split = FALSE)
[17:37:33.920]         if (TRUE) {
[17:37:33.920]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:33.920]         }
[17:37:33.920]         else {
[17:37:33.920]             ...future.result["stdout"] <- base::list(NULL)
[17:37:33.920]         }
[17:37:33.920]         base::close(...future.stdout)
[17:37:33.920]         ...future.stdout <- NULL
[17:37:33.920]     }
[17:37:33.920]     ...future.result$conditions <- ...future.conditions
[17:37:33.920]     ...future.result$finished <- base::Sys.time()
[17:37:33.920]     ...future.result
[17:37:33.920] }
[17:37:33.922] assign_globals() ...
[17:37:33.922] List of 5
[17:37:33.922]  $ ...future.FUN            :function (x, ...)  
[17:37:33.922]  $ MoreArgs                 :List of 1
[17:37:33.922]   ..$ x: num 42
[17:37:33.922]  $ ...future.elements_ii    :List of 1
[17:37:33.922]   ..$ times:List of 4
[17:37:33.922]   .. ..$ : int 1
[17:37:33.922]   .. ..$ : int 2
[17:37:33.922]   .. ..$ : int 3
[17:37:33.922]   .. ..$ : int 4
[17:37:33.922]  $ ...future.seeds_ii       : NULL
[17:37:33.922]  $ ...future.globals.maxSize: NULL
[17:37:33.922]  - attr(*, "where")=List of 5
[17:37:33.922]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:33.922]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:33.922]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:33.922]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:33.922]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:33.922]  - attr(*, "resolved")= logi FALSE
[17:37:33.922]  - attr(*, "total_size")= num 336
[17:37:33.922]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:33.922]  - attr(*, "already-done")= logi TRUE
[17:37:33.927] - copied ‘...future.FUN’ to environment
[17:37:33.927] - copied ‘MoreArgs’ to environment
[17:37:33.927] - copied ‘...future.elements_ii’ to environment
[17:37:33.927] - copied ‘...future.seeds_ii’ to environment
[17:37:33.928] - copied ‘...future.globals.maxSize’ to environment
[17:37:33.928] assign_globals() ... done
[17:37:33.928] plan(): Setting new future strategy stack:
[17:37:33.928] List of future strategies:
[17:37:33.928] 1. sequential:
[17:37:33.928]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:33.928]    - tweaked: FALSE
[17:37:33.928]    - call: NULL
[17:37:33.928] plan(): nbrOfWorkers() = 1
[17:37:33.929] plan(): Setting new future strategy stack:
[17:37:33.929] List of future strategies:
[17:37:33.929] 1. sequential:
[17:37:33.929]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:33.929]    - tweaked: FALSE
[17:37:33.929]    - call: plan(strategy)
[17:37:33.930] plan(): nbrOfWorkers() = 1
[17:37:33.930] SequentialFuture started (and completed)
[17:37:33.930] - Launch lazy future ... done
[17:37:33.930] run() for ‘SequentialFuture’ ... done
[17:37:33.930] Created future:
[17:37:33.930] SequentialFuture:
[17:37:33.930] Label: ‘future_mapply-1’
[17:37:33.930] Expression:
[17:37:33.930] {
[17:37:33.930]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:33.930]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:33.930]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:33.930]         on.exit(options(oopts), add = TRUE)
[17:37:33.930]     }
[17:37:33.930]     {
[17:37:33.930]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:33.930]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:33.930]         do.call(mapply, args = args)
[17:37:33.930]     }
[17:37:33.930] }
[17:37:33.930] Lazy evaluation: FALSE
[17:37:33.930] Asynchronous evaluation: FALSE
[17:37:33.930] Local evaluation: TRUE
[17:37:33.930] Environment: R_GlobalEnv
[17:37:33.930] Capture standard output: TRUE
[17:37:33.930] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:33.930] Globals: 5 objects totaling 336 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:33.930] Packages: <none>
[17:37:33.930] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:33.930] Resolved: TRUE
[17:37:33.930] Value: 280 bytes of class ‘list’
[17:37:33.930] Early signaling: FALSE
[17:37:33.930] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:33.930] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:33.931] Chunk #1 of 1 ... DONE
[17:37:33.931] Launching 1 futures (chunks) ... DONE
[17:37:33.931] Resolving 1 futures (chunks) ...
[17:37:33.931] resolve() on list ...
[17:37:33.931]  recursive: 0
[17:37:33.933]  length: 1
[17:37:33.933] 
[17:37:33.933] resolved() for ‘SequentialFuture’ ...
[17:37:33.933] - state: ‘finished’
[17:37:33.933] - run: TRUE
[17:37:33.933] - result: ‘FutureResult’
[17:37:33.933] resolved() for ‘SequentialFuture’ ... done
[17:37:33.933] Future #1
[17:37:33.934] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:33.934] - nx: 1
[17:37:33.934] - relay: TRUE
[17:37:33.934] - stdout: TRUE
[17:37:33.934] - signal: TRUE
[17:37:33.934] - resignal: FALSE
[17:37:33.934] - force: TRUE
[17:37:33.934] - relayed: [n=1] FALSE
[17:37:33.934] - queued futures: [n=1] FALSE
[17:37:33.934]  - until=1
[17:37:33.935]  - relaying element #1
[17:37:33.935] - relayed: [n=1] TRUE
[17:37:33.935] - queued futures: [n=1] TRUE
[17:37:33.935] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:33.935]  length: 0 (resolved future 1)
[17:37:33.935] Relaying remaining futures
[17:37:33.935] signalConditionsASAP(NULL, pos=0) ...
[17:37:33.935] - nx: 1
[17:37:33.935] - relay: TRUE
[17:37:33.935] - stdout: TRUE
[17:37:33.935] - signal: TRUE
[17:37:33.936] - resignal: FALSE
[17:37:33.936] - force: TRUE
[17:37:33.936] - relayed: [n=1] TRUE
[17:37:33.936] - queued futures: [n=1] TRUE
 - flush all
[17:37:33.936] - relayed: [n=1] TRUE
[17:37:33.936] - queued futures: [n=1] TRUE
[17:37:33.936] signalConditionsASAP(NULL, pos=0) ... done
[17:37:33.936] resolve() on list ... DONE
[17:37:33.936]  - Number of value chunks collected: 1
[17:37:33.936] Resolving 1 futures (chunks) ... DONE
[17:37:33.937] Reducing values from 1 chunks ...
[17:37:33.937]  - Number of values collected after concatenation: 4
[17:37:33.937]  - Number of values expected: 4
[17:37:33.937] Reducing values from 1 chunks ... DONE
[17:37:33.937] future_mapply() ... DONE
[17:37:33.937] future_mapply() ...
[17:37:33.937] Number of chunks: 1
[17:37:33.937] getGlobalsAndPackagesXApply() ...
[17:37:33.937]  - future.globals: TRUE
[17:37:33.937] getGlobalsAndPackages() ...
[17:37:33.938] Searching for globals...
[17:37:33.939] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[17:37:33.939] Searching for globals ... DONE
[17:37:33.939] Resolving globals: FALSE
[17:37:33.939] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[17:37:33.940] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[17:37:33.940] - globals: [1] ‘FUN’
[17:37:33.940] 
[17:37:33.940] getGlobalsAndPackages() ... DONE
[17:37:33.940]  - globals found/used: [n=1] ‘FUN’
[17:37:33.940]  - needed namespaces: [n=0] 
[17:37:33.940] Finding globals ... DONE
[17:37:33.940] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:33.940] List of 2
[17:37:33.940]  $ ...future.FUN:function (x, y)  
[17:37:33.940]  $ MoreArgs     : NULL
[17:37:33.940]  - attr(*, "where")=List of 2
[17:37:33.940]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:33.940]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:33.940]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:33.940]  - attr(*, "resolved")= logi FALSE
[17:37:33.940]  - attr(*, "total_size")= num NA
[17:37:33.943] Packages to be attached in all futures: [n=0] 
[17:37:33.943] getGlobalsAndPackagesXApply() ... DONE
[17:37:33.943] Number of futures (= number of chunks): 1
[17:37:33.943] Launching 1 futures (chunks) ...
[17:37:33.943] Chunk #1 of 1 ...
[17:37:33.943]  - Finding globals in '...' for chunk #1 ...
[17:37:33.943] getGlobalsAndPackages() ...
[17:37:33.944] Searching for globals...
[17:37:33.944] 
[17:37:33.944] Searching for globals ... DONE
[17:37:33.944] - globals: [0] <none>
[17:37:33.944] getGlobalsAndPackages() ... DONE
[17:37:33.944]    + additional globals found: [n=0] 
[17:37:33.944]    + additional namespaces needed: [n=0] 
[17:37:33.944]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:33.944]  - seeds: <none>
[17:37:33.945]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:33.945] getGlobalsAndPackages() ...
[17:37:33.945] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:33.945] Resolving globals: FALSE
[17:37:33.945] The total size of the 5 globals is 2.26 KiB (2312 bytes)
[17:37:33.946] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:33.946] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:33.946] 
[17:37:33.946] getGlobalsAndPackages() ... DONE
[17:37:33.946] run() for ‘Future’ ...
[17:37:33.946] - state: ‘created’
[17:37:33.947] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:33.947] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:33.947] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:33.947]   - Field: ‘label’
[17:37:33.947]   - Field: ‘local’
[17:37:33.947]   - Field: ‘owner’
[17:37:33.947]   - Field: ‘envir’
[17:37:33.947]   - Field: ‘packages’
[17:37:33.947]   - Field: ‘gc’
[17:37:33.948]   - Field: ‘conditions’
[17:37:33.948]   - Field: ‘expr’
[17:37:33.948]   - Field: ‘uuid’
[17:37:33.948]   - Field: ‘seed’
[17:37:33.948]   - Field: ‘version’
[17:37:33.948]   - Field: ‘result’
[17:37:33.948]   - Field: ‘asynchronous’
[17:37:33.948]   - Field: ‘calls’
[17:37:33.948]   - Field: ‘globals’
[17:37:33.948]   - Field: ‘stdout’
[17:37:33.949]   - Field: ‘earlySignal’
[17:37:33.949]   - Field: ‘lazy’
[17:37:33.949]   - Field: ‘state’
[17:37:33.949] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:33.949] - Launch lazy future ...
[17:37:33.949] Packages needed by the future expression (n = 0): <none>
[17:37:33.949] Packages needed by future strategies (n = 0): <none>
[17:37:33.950] {
[17:37:33.950]     {
[17:37:33.950]         {
[17:37:33.950]             ...future.startTime <- base::Sys.time()
[17:37:33.950]             {
[17:37:33.950]                 {
[17:37:33.950]                   {
[17:37:33.950]                     base::local({
[17:37:33.950]                       has_future <- base::requireNamespace("future", 
[17:37:33.950]                         quietly = TRUE)
[17:37:33.950]                       if (has_future) {
[17:37:33.950]                         ns <- base::getNamespace("future")
[17:37:33.950]                         version <- ns[[".package"]][["version"]]
[17:37:33.950]                         if (is.null(version)) 
[17:37:33.950]                           version <- utils::packageVersion("future")
[17:37:33.950]                       }
[17:37:33.950]                       else {
[17:37:33.950]                         version <- NULL
[17:37:33.950]                       }
[17:37:33.950]                       if (!has_future || version < "1.8.0") {
[17:37:33.950]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:33.950]                           "", base::R.version$version.string), 
[17:37:33.950]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:33.950]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:33.950]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:33.950]                             "release", "version")], collapse = " "), 
[17:37:33.950]                           hostname = base::Sys.info()[["nodename"]])
[17:37:33.950]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:33.950]                           info)
[17:37:33.950]                         info <- base::paste(info, collapse = "; ")
[17:37:33.950]                         if (!has_future) {
[17:37:33.950]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:33.950]                             info)
[17:37:33.950]                         }
[17:37:33.950]                         else {
[17:37:33.950]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:33.950]                             info, version)
[17:37:33.950]                         }
[17:37:33.950]                         base::stop(msg)
[17:37:33.950]                       }
[17:37:33.950]                     })
[17:37:33.950]                   }
[17:37:33.950]                   ...future.strategy.old <- future::plan("list")
[17:37:33.950]                   options(future.plan = NULL)
[17:37:33.950]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:33.950]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:33.950]                 }
[17:37:33.950]                 ...future.workdir <- getwd()
[17:37:33.950]             }
[17:37:33.950]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:33.950]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:33.950]         }
[17:37:33.950]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:33.950]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:33.950]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:33.950]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:33.950]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:33.950]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:33.950]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:33.950]             base::names(...future.oldOptions))
[17:37:33.950]     }
[17:37:33.950]     if (FALSE) {
[17:37:33.950]     }
[17:37:33.950]     else {
[17:37:33.950]         if (TRUE) {
[17:37:33.950]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:33.950]                 open = "w")
[17:37:33.950]         }
[17:37:33.950]         else {
[17:37:33.950]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:33.950]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:33.950]         }
[17:37:33.950]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:33.950]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:33.950]             base::sink(type = "output", split = FALSE)
[17:37:33.950]             base::close(...future.stdout)
[17:37:33.950]         }, add = TRUE)
[17:37:33.950]     }
[17:37:33.950]     ...future.frame <- base::sys.nframe()
[17:37:33.950]     ...future.conditions <- base::list()
[17:37:33.950]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:33.950]     if (FALSE) {
[17:37:33.950]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:33.950]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:33.950]     }
[17:37:33.950]     ...future.result <- base::tryCatch({
[17:37:33.950]         base::withCallingHandlers({
[17:37:33.950]             ...future.value <- base::withVisible(base::local({
[17:37:33.950]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:33.950]                 if (!identical(...future.globals.maxSize.org, 
[17:37:33.950]                   ...future.globals.maxSize)) {
[17:37:33.950]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:33.950]                   on.exit(options(oopts), add = TRUE)
[17:37:33.950]                 }
[17:37:33.950]                 {
[17:37:33.950]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:33.950]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:33.950]                     USE.NAMES = FALSE)
[17:37:33.950]                   do.call(mapply, args = args)
[17:37:33.950]                 }
[17:37:33.950]             }))
[17:37:33.950]             future::FutureResult(value = ...future.value$value, 
[17:37:33.950]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:33.950]                   ...future.rng), globalenv = if (FALSE) 
[17:37:33.950]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:33.950]                     ...future.globalenv.names))
[17:37:33.950]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:33.950]         }, condition = base::local({
[17:37:33.950]             c <- base::c
[17:37:33.950]             inherits <- base::inherits
[17:37:33.950]             invokeRestart <- base::invokeRestart
[17:37:33.950]             length <- base::length
[17:37:33.950]             list <- base::list
[17:37:33.950]             seq.int <- base::seq.int
[17:37:33.950]             signalCondition <- base::signalCondition
[17:37:33.950]             sys.calls <- base::sys.calls
[17:37:33.950]             `[[` <- base::`[[`
[17:37:33.950]             `+` <- base::`+`
[17:37:33.950]             `<<-` <- base::`<<-`
[17:37:33.950]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:33.950]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:33.950]                   3L)]
[17:37:33.950]             }
[17:37:33.950]             function(cond) {
[17:37:33.950]                 is_error <- inherits(cond, "error")
[17:37:33.950]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:33.950]                   NULL)
[17:37:33.950]                 if (is_error) {
[17:37:33.950]                   sessionInformation <- function() {
[17:37:33.950]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:33.950]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:33.950]                       search = base::search(), system = base::Sys.info())
[17:37:33.950]                   }
[17:37:33.950]                   ...future.conditions[[length(...future.conditions) + 
[17:37:33.950]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:33.950]                     cond$call), session = sessionInformation(), 
[17:37:33.950]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:33.950]                   signalCondition(cond)
[17:37:33.950]                 }
[17:37:33.950]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:33.950]                 "immediateCondition"))) {
[17:37:33.950]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:33.950]                   ...future.conditions[[length(...future.conditions) + 
[17:37:33.950]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:33.950]                   if (TRUE && !signal) {
[17:37:33.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:33.950]                     {
[17:37:33.950]                       inherits <- base::inherits
[17:37:33.950]                       invokeRestart <- base::invokeRestart
[17:37:33.950]                       is.null <- base::is.null
[17:37:33.950]                       muffled <- FALSE
[17:37:33.950]                       if (inherits(cond, "message")) {
[17:37:33.950]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:33.950]                         if (muffled) 
[17:37:33.950]                           invokeRestart("muffleMessage")
[17:37:33.950]                       }
[17:37:33.950]                       else if (inherits(cond, "warning")) {
[17:37:33.950]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:33.950]                         if (muffled) 
[17:37:33.950]                           invokeRestart("muffleWarning")
[17:37:33.950]                       }
[17:37:33.950]                       else if (inherits(cond, "condition")) {
[17:37:33.950]                         if (!is.null(pattern)) {
[17:37:33.950]                           computeRestarts <- base::computeRestarts
[17:37:33.950]                           grepl <- base::grepl
[17:37:33.950]                           restarts <- computeRestarts(cond)
[17:37:33.950]                           for (restart in restarts) {
[17:37:33.950]                             name <- restart$name
[17:37:33.950]                             if (is.null(name)) 
[17:37:33.950]                               next
[17:37:33.950]                             if (!grepl(pattern, name)) 
[17:37:33.950]                               next
[17:37:33.950]                             invokeRestart(restart)
[17:37:33.950]                             muffled <- TRUE
[17:37:33.950]                             break
[17:37:33.950]                           }
[17:37:33.950]                         }
[17:37:33.950]                       }
[17:37:33.950]                       invisible(muffled)
[17:37:33.950]                     }
[17:37:33.950]                     muffleCondition(cond, pattern = "^muffle")
[17:37:33.950]                   }
[17:37:33.950]                 }
[17:37:33.950]                 else {
[17:37:33.950]                   if (TRUE) {
[17:37:33.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:33.950]                     {
[17:37:33.950]                       inherits <- base::inherits
[17:37:33.950]                       invokeRestart <- base::invokeRestart
[17:37:33.950]                       is.null <- base::is.null
[17:37:33.950]                       muffled <- FALSE
[17:37:33.950]                       if (inherits(cond, "message")) {
[17:37:33.950]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:33.950]                         if (muffled) 
[17:37:33.950]                           invokeRestart("muffleMessage")
[17:37:33.950]                       }
[17:37:33.950]                       else if (inherits(cond, "warning")) {
[17:37:33.950]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:33.950]                         if (muffled) 
[17:37:33.950]                           invokeRestart("muffleWarning")
[17:37:33.950]                       }
[17:37:33.950]                       else if (inherits(cond, "condition")) {
[17:37:33.950]                         if (!is.null(pattern)) {
[17:37:33.950]                           computeRestarts <- base::computeRestarts
[17:37:33.950]                           grepl <- base::grepl
[17:37:33.950]                           restarts <- computeRestarts(cond)
[17:37:33.950]                           for (restart in restarts) {
[17:37:33.950]                             name <- restart$name
[17:37:33.950]                             if (is.null(name)) 
[17:37:33.950]                               next
[17:37:33.950]                             if (!grepl(pattern, name)) 
[17:37:33.950]                               next
[17:37:33.950]                             invokeRestart(restart)
[17:37:33.950]                             muffled <- TRUE
[17:37:33.950]                             break
[17:37:33.950]                           }
[17:37:33.950]                         }
[17:37:33.950]                       }
[17:37:33.950]                       invisible(muffled)
[17:37:33.950]                     }
[17:37:33.950]                     muffleCondition(cond, pattern = "^muffle")
[17:37:33.950]                   }
[17:37:33.950]                 }
[17:37:33.950]             }
[17:37:33.950]         }))
[17:37:33.950]     }, error = function(ex) {
[17:37:33.950]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:33.950]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:33.950]                 ...future.rng), started = ...future.startTime, 
[17:37:33.950]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:33.950]             version = "1.8"), class = "FutureResult")
[17:37:33.950]     }, finally = {
[17:37:33.950]         if (!identical(...future.workdir, getwd())) 
[17:37:33.950]             setwd(...future.workdir)
[17:37:33.950]         {
[17:37:33.950]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:33.950]                 ...future.oldOptions$nwarnings <- NULL
[17:37:33.950]             }
[17:37:33.950]             base::options(...future.oldOptions)
[17:37:33.950]             if (.Platform$OS.type == "windows") {
[17:37:33.950]                 old_names <- names(...future.oldEnvVars)
[17:37:33.950]                 envs <- base::Sys.getenv()
[17:37:33.950]                 names <- names(envs)
[17:37:33.950]                 common <- intersect(names, old_names)
[17:37:33.950]                 added <- setdiff(names, old_names)
[17:37:33.950]                 removed <- setdiff(old_names, names)
[17:37:33.950]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:33.950]                   envs[common]]
[17:37:33.950]                 NAMES <- toupper(changed)
[17:37:33.950]                 args <- list()
[17:37:33.950]                 for (kk in seq_along(NAMES)) {
[17:37:33.950]                   name <- changed[[kk]]
[17:37:33.950]                   NAME <- NAMES[[kk]]
[17:37:33.950]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:33.950]                     next
[17:37:33.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:33.950]                 }
[17:37:33.950]                 NAMES <- toupper(added)
[17:37:33.950]                 for (kk in seq_along(NAMES)) {
[17:37:33.950]                   name <- added[[kk]]
[17:37:33.950]                   NAME <- NAMES[[kk]]
[17:37:33.950]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:33.950]                     next
[17:37:33.950]                   args[[name]] <- ""
[17:37:33.950]                 }
[17:37:33.950]                 NAMES <- toupper(removed)
[17:37:33.950]                 for (kk in seq_along(NAMES)) {
[17:37:33.950]                   name <- removed[[kk]]
[17:37:33.950]                   NAME <- NAMES[[kk]]
[17:37:33.950]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:33.950]                     next
[17:37:33.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:33.950]                 }
[17:37:33.950]                 if (length(args) > 0) 
[17:37:33.950]                   base::do.call(base::Sys.setenv, args = args)
[17:37:33.950]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:33.950]             }
[17:37:33.950]             else {
[17:37:33.950]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:33.950]             }
[17:37:33.950]             {
[17:37:33.950]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:33.950]                   0L) {
[17:37:33.950]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:33.950]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:33.950]                   base::options(opts)
[17:37:33.950]                 }
[17:37:33.950]                 {
[17:37:33.950]                   {
[17:37:33.950]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:33.950]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:33.950]                     -1786728155L), envir = base::globalenv(), 
[17:37:33.950]                       inherits = FALSE)
[17:37:33.950]                     NULL
[17:37:33.950]                   }
[17:37:33.950]                   options(future.plan = NULL)
[17:37:33.950]                   if (is.na(NA_character_)) 
[17:37:33.950]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:33.950]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:33.950]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:33.950]                     .init = FALSE)
[17:37:33.950]                 }
[17:37:33.950]             }
[17:37:33.950]         }
[17:37:33.950]     })
[17:37:33.950]     if (TRUE) {
[17:37:33.950]         base::sink(type = "output", split = FALSE)
[17:37:33.950]         if (TRUE) {
[17:37:33.950]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:33.950]         }
[17:37:33.950]         else {
[17:37:33.950]             ...future.result["stdout"] <- base::list(NULL)
[17:37:33.950]         }
[17:37:33.950]         base::close(...future.stdout)
[17:37:33.950]         ...future.stdout <- NULL
[17:37:33.950]     }
[17:37:33.950]     ...future.result$conditions <- ...future.conditions
[17:37:33.950]     ...future.result$finished <- base::Sys.time()
[17:37:33.950]     ...future.result
[17:37:33.950] }
[17:37:33.951] assign_globals() ...
[17:37:33.951] List of 5
[17:37:33.951]  $ ...future.FUN            :function (x, y)  
[17:37:33.951]  $ MoreArgs                 : NULL
[17:37:33.951]  $ ...future.elements_ii    :List of 2
[17:37:33.951]   ..$ :List of 3
[17:37:33.951]   .. ..$ a: num 1
[17:37:33.951]   .. ..$ b: num 2
[17:37:33.951]   .. ..$ c: num 3
[17:37:33.951]   ..$ :List of 3
[17:37:33.951]   .. ..$ A: num 10
[17:37:33.951]   .. ..$ B: num 0
[17:37:33.951]   .. ..$ C: num -10
[17:37:33.951]  $ ...future.seeds_ii       : NULL
[17:37:33.951]  $ ...future.globals.maxSize: NULL
[17:37:33.951]  - attr(*, "where")=List of 5
[17:37:33.951]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:33.951]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:33.951]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:33.951]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:33.951]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:33.951]  - attr(*, "resolved")= logi FALSE
[17:37:33.951]  - attr(*, "total_size")= num 2312
[17:37:33.951]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:33.951]  - attr(*, "already-done")= logi TRUE
[17:37:33.959] - reassign environment for ‘...future.FUN’
[17:37:33.959] - copied ‘...future.FUN’ to environment
[17:37:33.959] - copied ‘MoreArgs’ to environment
[17:37:33.959] - copied ‘...future.elements_ii’ to environment
[17:37:33.960] - copied ‘...future.seeds_ii’ to environment
[17:37:33.960] - copied ‘...future.globals.maxSize’ to environment
[17:37:33.960] assign_globals() ... done
[17:37:33.960] plan(): Setting new future strategy stack:
[17:37:33.960] List of future strategies:
[17:37:33.960] 1. sequential:
[17:37:33.960]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:33.960]    - tweaked: FALSE
[17:37:33.960]    - call: NULL
[17:37:33.961] plan(): nbrOfWorkers() = 1
[17:37:33.961] plan(): Setting new future strategy stack:
[17:37:33.961] List of future strategies:
[17:37:33.961] 1. sequential:
[17:37:33.961]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:33.961]    - tweaked: FALSE
[17:37:33.961]    - call: plan(strategy)
[17:37:33.962] plan(): nbrOfWorkers() = 1
[17:37:33.962] SequentialFuture started (and completed)
[17:37:33.962] - Launch lazy future ... done
[17:37:33.962] run() for ‘SequentialFuture’ ... done
[17:37:33.962] Created future:
[17:37:33.962] SequentialFuture:
[17:37:33.962] Label: ‘future_mapply-1’
[17:37:33.962] Expression:
[17:37:33.962] {
[17:37:33.962]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:33.962]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:33.962]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:33.962]         on.exit(options(oopts), add = TRUE)
[17:37:33.962]     }
[17:37:33.962]     {
[17:37:33.962]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:33.962]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:33.962]         do.call(mapply, args = args)
[17:37:33.962]     }
[17:37:33.962] }
[17:37:33.962] Lazy evaluation: FALSE
[17:37:33.962] Asynchronous evaluation: FALSE
[17:37:33.962] Local evaluation: TRUE
[17:37:33.962] Environment: R_GlobalEnv
[17:37:33.962] Capture standard output: TRUE
[17:37:33.962] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:33.962] Globals: 5 objects totaling 2.26 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:33.962] Packages: <none>
[17:37:33.962] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:33.962] Resolved: TRUE
[17:37:33.962] Value: 200 bytes of class ‘list’
[17:37:33.962] Early signaling: FALSE
[17:37:33.962] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:33.962] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:33.963] Chunk #1 of 1 ... DONE
[17:37:33.963] Launching 1 futures (chunks) ... DONE
[17:37:33.964] Resolving 1 futures (chunks) ...
[17:37:33.964] resolve() on list ...
[17:37:33.964]  recursive: 0
[17:37:33.964]  length: 1
[17:37:33.964] 
[17:37:33.964] resolved() for ‘SequentialFuture’ ...
[17:37:33.964] - state: ‘finished’
[17:37:33.964] - run: TRUE
[17:37:33.964] - result: ‘FutureResult’
[17:37:33.964] resolved() for ‘SequentialFuture’ ... done
[17:37:33.965] Future #1
[17:37:33.965] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:33.965] - nx: 1
[17:37:33.965] - relay: TRUE
[17:37:33.965] - stdout: TRUE
[17:37:33.965] - signal: TRUE
[17:37:33.965] - resignal: FALSE
[17:37:33.965] - force: TRUE
[17:37:33.965] - relayed: [n=1] FALSE
[17:37:33.965] - queued futures: [n=1] FALSE
[17:37:33.965]  - until=1
[17:37:33.966]  - relaying element #1
[17:37:33.966] - relayed: [n=1] TRUE
[17:37:33.966] - queued futures: [n=1] TRUE
[17:37:33.966] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:33.966]  length: 0 (resolved future 1)
[17:37:33.966] Relaying remaining futures
[17:37:33.966] signalConditionsASAP(NULL, pos=0) ...
[17:37:33.966] - nx: 1
[17:37:33.966] - relay: TRUE
[17:37:33.967] - stdout: TRUE
[17:37:33.967] - signal: TRUE
[17:37:33.967] - resignal: FALSE
[17:37:33.967] - force: TRUE
[17:37:33.967] - relayed: [n=1] TRUE
[17:37:33.967] - queued futures: [n=1] TRUE
 - flush all
[17:37:33.967] - relayed: [n=1] TRUE
[17:37:33.967] - queued futures: [n=1] TRUE
[17:37:33.967] signalConditionsASAP(NULL, pos=0) ... done
[17:37:33.967] resolve() on list ... DONE
[17:37:33.968]  - Number of value chunks collected: 1
[17:37:33.968] Resolving 1 futures (chunks) ... DONE
[17:37:33.968] Reducing values from 1 chunks ...
[17:37:33.968]  - Number of values collected after concatenation: 3
[17:37:33.968]  - Number of values expected: 3
[17:37:33.968] Reducing values from 1 chunks ... DONE
[17:37:33.968] future_mapply() ... DONE
- future_.mapply()
[17:37:33.969] future_mapply() ...
[17:37:33.969] Number of chunks: 1
[17:37:33.969] getGlobalsAndPackagesXApply() ...
[17:37:33.969]  - future.globals: TRUE
[17:37:33.969] getGlobalsAndPackages() ...
[17:37:33.969] Searching for globals...
[17:37:33.971] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[17:37:33.971] Searching for globals ... DONE
[17:37:33.971] Resolving globals: FALSE
[17:37:33.971] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[17:37:33.971] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[17:37:33.972] - globals: [1] ‘FUN’
[17:37:33.972] 
[17:37:33.972] getGlobalsAndPackages() ... DONE
[17:37:33.972]  - globals found/used: [n=1] ‘FUN’
[17:37:33.972]  - needed namespaces: [n=0] 
[17:37:33.972] Finding globals ... DONE
[17:37:33.972] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:33.972] List of 2
[17:37:33.972]  $ ...future.FUN:function (x, y)  
[17:37:33.972]  $ MoreArgs     : list()
[17:37:33.972]  - attr(*, "where")=List of 2
[17:37:33.972]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:33.972]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:33.972]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:33.972]  - attr(*, "resolved")= logi FALSE
[17:37:33.972]  - attr(*, "total_size")= num NA
[17:37:33.975] Packages to be attached in all futures: [n=0] 
[17:37:33.975] getGlobalsAndPackagesXApply() ... DONE
[17:37:33.975] Number of futures (= number of chunks): 1
[17:37:33.975] Launching 1 futures (chunks) ...
[17:37:33.975] Chunk #1 of 1 ...
[17:37:33.975]  - Finding globals in '...' for chunk #1 ...
[17:37:33.975] getGlobalsAndPackages() ...
[17:37:33.976] Searching for globals...
[17:37:33.976] 
[17:37:33.976] Searching for globals ... DONE
[17:37:33.976] - globals: [0] <none>
[17:37:33.976] getGlobalsAndPackages() ... DONE
[17:37:33.976]    + additional globals found: [n=0] 
[17:37:33.976]    + additional namespaces needed: [n=0] 
[17:37:33.976]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:33.976]  - seeds: <none>
[17:37:33.977]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:33.977] getGlobalsAndPackages() ...
[17:37:33.977] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:33.977] Resolving globals: FALSE
[17:37:33.977] The total size of the 5 globals is 2.26 KiB (2312 bytes)
[17:37:33.978] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:33.978] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:33.978] 
[17:37:33.978] getGlobalsAndPackages() ... DONE
[17:37:33.978] run() for ‘Future’ ...
[17:37:33.979] - state: ‘created’
[17:37:33.979] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:33.979] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:33.979] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:33.979]   - Field: ‘label’
[17:37:33.979]   - Field: ‘local’
[17:37:33.979]   - Field: ‘owner’
[17:37:33.979]   - Field: ‘envir’
[17:37:33.980]   - Field: ‘packages’
[17:37:33.980]   - Field: ‘gc’
[17:37:33.980]   - Field: ‘conditions’
[17:37:33.980]   - Field: ‘expr’
[17:37:33.980]   - Field: ‘uuid’
[17:37:33.980]   - Field: ‘seed’
[17:37:33.980]   - Field: ‘version’
[17:37:33.980]   - Field: ‘result’
[17:37:33.980]   - Field: ‘asynchronous’
[17:37:33.980]   - Field: ‘calls’
[17:37:33.980]   - Field: ‘globals’
[17:37:33.981]   - Field: ‘stdout’
[17:37:33.981]   - Field: ‘earlySignal’
[17:37:33.981]   - Field: ‘lazy’
[17:37:33.981]   - Field: ‘state’
[17:37:33.981] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:33.981] - Launch lazy future ...
[17:37:33.981] Packages needed by the future expression (n = 0): <none>
[17:37:33.981] Packages needed by future strategies (n = 0): <none>
[17:37:33.982] {
[17:37:33.982]     {
[17:37:33.982]         {
[17:37:33.982]             ...future.startTime <- base::Sys.time()
[17:37:33.982]             {
[17:37:33.982]                 {
[17:37:33.982]                   {
[17:37:33.982]                     base::local({
[17:37:33.982]                       has_future <- base::requireNamespace("future", 
[17:37:33.982]                         quietly = TRUE)
[17:37:33.982]                       if (has_future) {
[17:37:33.982]                         ns <- base::getNamespace("future")
[17:37:33.982]                         version <- ns[[".package"]][["version"]]
[17:37:33.982]                         if (is.null(version)) 
[17:37:33.982]                           version <- utils::packageVersion("future")
[17:37:33.982]                       }
[17:37:33.982]                       else {
[17:37:33.982]                         version <- NULL
[17:37:33.982]                       }
[17:37:33.982]                       if (!has_future || version < "1.8.0") {
[17:37:33.982]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:33.982]                           "", base::R.version$version.string), 
[17:37:33.982]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:33.982]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:33.982]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:33.982]                             "release", "version")], collapse = " "), 
[17:37:33.982]                           hostname = base::Sys.info()[["nodename"]])
[17:37:33.982]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:33.982]                           info)
[17:37:33.982]                         info <- base::paste(info, collapse = "; ")
[17:37:33.982]                         if (!has_future) {
[17:37:33.982]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:33.982]                             info)
[17:37:33.982]                         }
[17:37:33.982]                         else {
[17:37:33.982]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:33.982]                             info, version)
[17:37:33.982]                         }
[17:37:33.982]                         base::stop(msg)
[17:37:33.982]                       }
[17:37:33.982]                     })
[17:37:33.982]                   }
[17:37:33.982]                   ...future.strategy.old <- future::plan("list")
[17:37:33.982]                   options(future.plan = NULL)
[17:37:33.982]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:33.982]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:33.982]                 }
[17:37:33.982]                 ...future.workdir <- getwd()
[17:37:33.982]             }
[17:37:33.982]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:33.982]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:33.982]         }
[17:37:33.982]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:33.982]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:33.982]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:33.982]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:33.982]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:33.982]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:33.982]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:33.982]             base::names(...future.oldOptions))
[17:37:33.982]     }
[17:37:33.982]     if (FALSE) {
[17:37:33.982]     }
[17:37:33.982]     else {
[17:37:33.982]         if (TRUE) {
[17:37:33.982]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:33.982]                 open = "w")
[17:37:33.982]         }
[17:37:33.982]         else {
[17:37:33.982]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:33.982]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:33.982]         }
[17:37:33.982]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:33.982]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:33.982]             base::sink(type = "output", split = FALSE)
[17:37:33.982]             base::close(...future.stdout)
[17:37:33.982]         }, add = TRUE)
[17:37:33.982]     }
[17:37:33.982]     ...future.frame <- base::sys.nframe()
[17:37:33.982]     ...future.conditions <- base::list()
[17:37:33.982]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:33.982]     if (FALSE) {
[17:37:33.982]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:33.982]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:33.982]     }
[17:37:33.982]     ...future.result <- base::tryCatch({
[17:37:33.982]         base::withCallingHandlers({
[17:37:33.982]             ...future.value <- base::withVisible(base::local({
[17:37:33.982]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:33.982]                 if (!identical(...future.globals.maxSize.org, 
[17:37:33.982]                   ...future.globals.maxSize)) {
[17:37:33.982]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:33.982]                   on.exit(options(oopts), add = TRUE)
[17:37:33.982]                 }
[17:37:33.982]                 {
[17:37:33.982]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:33.982]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:33.982]                     USE.NAMES = FALSE)
[17:37:33.982]                   do.call(mapply, args = args)
[17:37:33.982]                 }
[17:37:33.982]             }))
[17:37:33.982]             future::FutureResult(value = ...future.value$value, 
[17:37:33.982]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:33.982]                   ...future.rng), globalenv = if (FALSE) 
[17:37:33.982]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:33.982]                     ...future.globalenv.names))
[17:37:33.982]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:33.982]         }, condition = base::local({
[17:37:33.982]             c <- base::c
[17:37:33.982]             inherits <- base::inherits
[17:37:33.982]             invokeRestart <- base::invokeRestart
[17:37:33.982]             length <- base::length
[17:37:33.982]             list <- base::list
[17:37:33.982]             seq.int <- base::seq.int
[17:37:33.982]             signalCondition <- base::signalCondition
[17:37:33.982]             sys.calls <- base::sys.calls
[17:37:33.982]             `[[` <- base::`[[`
[17:37:33.982]             `+` <- base::`+`
[17:37:33.982]             `<<-` <- base::`<<-`
[17:37:33.982]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:33.982]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:33.982]                   3L)]
[17:37:33.982]             }
[17:37:33.982]             function(cond) {
[17:37:33.982]                 is_error <- inherits(cond, "error")
[17:37:33.982]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:33.982]                   NULL)
[17:37:33.982]                 if (is_error) {
[17:37:33.982]                   sessionInformation <- function() {
[17:37:33.982]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:33.982]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:33.982]                       search = base::search(), system = base::Sys.info())
[17:37:33.982]                   }
[17:37:33.982]                   ...future.conditions[[length(...future.conditions) + 
[17:37:33.982]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:33.982]                     cond$call), session = sessionInformation(), 
[17:37:33.982]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:33.982]                   signalCondition(cond)
[17:37:33.982]                 }
[17:37:33.982]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:33.982]                 "immediateCondition"))) {
[17:37:33.982]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:33.982]                   ...future.conditions[[length(...future.conditions) + 
[17:37:33.982]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:33.982]                   if (TRUE && !signal) {
[17:37:33.982]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:33.982]                     {
[17:37:33.982]                       inherits <- base::inherits
[17:37:33.982]                       invokeRestart <- base::invokeRestart
[17:37:33.982]                       is.null <- base::is.null
[17:37:33.982]                       muffled <- FALSE
[17:37:33.982]                       if (inherits(cond, "message")) {
[17:37:33.982]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:33.982]                         if (muffled) 
[17:37:33.982]                           invokeRestart("muffleMessage")
[17:37:33.982]                       }
[17:37:33.982]                       else if (inherits(cond, "warning")) {
[17:37:33.982]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:33.982]                         if (muffled) 
[17:37:33.982]                           invokeRestart("muffleWarning")
[17:37:33.982]                       }
[17:37:33.982]                       else if (inherits(cond, "condition")) {
[17:37:33.982]                         if (!is.null(pattern)) {
[17:37:33.982]                           computeRestarts <- base::computeRestarts
[17:37:33.982]                           grepl <- base::grepl
[17:37:33.982]                           restarts <- computeRestarts(cond)
[17:37:33.982]                           for (restart in restarts) {
[17:37:33.982]                             name <- restart$name
[17:37:33.982]                             if (is.null(name)) 
[17:37:33.982]                               next
[17:37:33.982]                             if (!grepl(pattern, name)) 
[17:37:33.982]                               next
[17:37:33.982]                             invokeRestart(restart)
[17:37:33.982]                             muffled <- TRUE
[17:37:33.982]                             break
[17:37:33.982]                           }
[17:37:33.982]                         }
[17:37:33.982]                       }
[17:37:33.982]                       invisible(muffled)
[17:37:33.982]                     }
[17:37:33.982]                     muffleCondition(cond, pattern = "^muffle")
[17:37:33.982]                   }
[17:37:33.982]                 }
[17:37:33.982]                 else {
[17:37:33.982]                   if (TRUE) {
[17:37:33.982]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:33.982]                     {
[17:37:33.982]                       inherits <- base::inherits
[17:37:33.982]                       invokeRestart <- base::invokeRestart
[17:37:33.982]                       is.null <- base::is.null
[17:37:33.982]                       muffled <- FALSE
[17:37:33.982]                       if (inherits(cond, "message")) {
[17:37:33.982]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:33.982]                         if (muffled) 
[17:37:33.982]                           invokeRestart("muffleMessage")
[17:37:33.982]                       }
[17:37:33.982]                       else if (inherits(cond, "warning")) {
[17:37:33.982]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:33.982]                         if (muffled) 
[17:37:33.982]                           invokeRestart("muffleWarning")
[17:37:33.982]                       }
[17:37:33.982]                       else if (inherits(cond, "condition")) {
[17:37:33.982]                         if (!is.null(pattern)) {
[17:37:33.982]                           computeRestarts <- base::computeRestarts
[17:37:33.982]                           grepl <- base::grepl
[17:37:33.982]                           restarts <- computeRestarts(cond)
[17:37:33.982]                           for (restart in restarts) {
[17:37:33.982]                             name <- restart$name
[17:37:33.982]                             if (is.null(name)) 
[17:37:33.982]                               next
[17:37:33.982]                             if (!grepl(pattern, name)) 
[17:37:33.982]                               next
[17:37:33.982]                             invokeRestart(restart)
[17:37:33.982]                             muffled <- TRUE
[17:37:33.982]                             break
[17:37:33.982]                           }
[17:37:33.982]                         }
[17:37:33.982]                       }
[17:37:33.982]                       invisible(muffled)
[17:37:33.982]                     }
[17:37:33.982]                     muffleCondition(cond, pattern = "^muffle")
[17:37:33.982]                   }
[17:37:33.982]                 }
[17:37:33.982]             }
[17:37:33.982]         }))
[17:37:33.982]     }, error = function(ex) {
[17:37:33.982]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:33.982]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:33.982]                 ...future.rng), started = ...future.startTime, 
[17:37:33.982]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:33.982]             version = "1.8"), class = "FutureResult")
[17:37:33.982]     }, finally = {
[17:37:33.982]         if (!identical(...future.workdir, getwd())) 
[17:37:33.982]             setwd(...future.workdir)
[17:37:33.982]         {
[17:37:33.982]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:33.982]                 ...future.oldOptions$nwarnings <- NULL
[17:37:33.982]             }
[17:37:33.982]             base::options(...future.oldOptions)
[17:37:33.982]             if (.Platform$OS.type == "windows") {
[17:37:33.982]                 old_names <- names(...future.oldEnvVars)
[17:37:33.982]                 envs <- base::Sys.getenv()
[17:37:33.982]                 names <- names(envs)
[17:37:33.982]                 common <- intersect(names, old_names)
[17:37:33.982]                 added <- setdiff(names, old_names)
[17:37:33.982]                 removed <- setdiff(old_names, names)
[17:37:33.982]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:33.982]                   envs[common]]
[17:37:33.982]                 NAMES <- toupper(changed)
[17:37:33.982]                 args <- list()
[17:37:33.982]                 for (kk in seq_along(NAMES)) {
[17:37:33.982]                   name <- changed[[kk]]
[17:37:33.982]                   NAME <- NAMES[[kk]]
[17:37:33.982]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:33.982]                     next
[17:37:33.982]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:33.982]                 }
[17:37:33.982]                 NAMES <- toupper(added)
[17:37:33.982]                 for (kk in seq_along(NAMES)) {
[17:37:33.982]                   name <- added[[kk]]
[17:37:33.982]                   NAME <- NAMES[[kk]]
[17:37:33.982]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:33.982]                     next
[17:37:33.982]                   args[[name]] <- ""
[17:37:33.982]                 }
[17:37:33.982]                 NAMES <- toupper(removed)
[17:37:33.982]                 for (kk in seq_along(NAMES)) {
[17:37:33.982]                   name <- removed[[kk]]
[17:37:33.982]                   NAME <- NAMES[[kk]]
[17:37:33.982]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:33.982]                     next
[17:37:33.982]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:33.982]                 }
[17:37:33.982]                 if (length(args) > 0) 
[17:37:33.982]                   base::do.call(base::Sys.setenv, args = args)
[17:37:33.982]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:33.982]             }
[17:37:33.982]             else {
[17:37:33.982]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:33.982]             }
[17:37:33.982]             {
[17:37:33.982]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:33.982]                   0L) {
[17:37:33.982]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:33.982]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:33.982]                   base::options(opts)
[17:37:33.982]                 }
[17:37:33.982]                 {
[17:37:33.982]                   {
[17:37:33.982]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:33.982]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:33.982]                     -1786728155L), envir = base::globalenv(), 
[17:37:33.982]                       inherits = FALSE)
[17:37:33.982]                     NULL
[17:37:33.982]                   }
[17:37:33.982]                   options(future.plan = NULL)
[17:37:33.982]                   if (is.na(NA_character_)) 
[17:37:33.982]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:33.982]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:33.982]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:33.982]                     .init = FALSE)
[17:37:33.982]                 }
[17:37:33.982]             }
[17:37:33.982]         }
[17:37:33.982]     })
[17:37:33.982]     if (TRUE) {
[17:37:33.982]         base::sink(type = "output", split = FALSE)
[17:37:33.982]         if (TRUE) {
[17:37:33.982]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:33.982]         }
[17:37:33.982]         else {
[17:37:33.982]             ...future.result["stdout"] <- base::list(NULL)
[17:37:33.982]         }
[17:37:33.982]         base::close(...future.stdout)
[17:37:33.982]         ...future.stdout <- NULL
[17:37:33.982]     }
[17:37:33.982]     ...future.result$conditions <- ...future.conditions
[17:37:33.982]     ...future.result$finished <- base::Sys.time()
[17:37:33.982]     ...future.result
[17:37:33.982] }
[17:37:33.983] assign_globals() ...
[17:37:33.984] List of 5
[17:37:33.984]  $ ...future.FUN            :function (x, y)  
[17:37:33.984]  $ MoreArgs                 : list()
[17:37:33.984]  $ ...future.elements_ii    :List of 2
[17:37:33.984]   ..$ :List of 3
[17:37:33.984]   .. ..$ a: num 1
[17:37:33.984]   .. ..$ b: num 2
[17:37:33.984]   .. ..$ c: num 3
[17:37:33.984]   ..$ :List of 3
[17:37:33.984]   .. ..$ A: num 10
[17:37:33.984]   .. ..$ B: num 0
[17:37:33.984]   .. ..$ C: num -10
[17:37:33.984]  $ ...future.seeds_ii       : NULL
[17:37:33.984]  $ ...future.globals.maxSize: NULL
[17:37:33.984]  - attr(*, "where")=List of 5
[17:37:33.984]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:33.984]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:33.984]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:33.984]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:33.984]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:33.984]  - attr(*, "resolved")= logi FALSE
[17:37:33.984]  - attr(*, "total_size")= num 2312
[17:37:33.984]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:33.984]  - attr(*, "already-done")= logi TRUE
[17:37:33.991] - reassign environment for ‘...future.FUN’
[17:37:33.992] - copied ‘...future.FUN’ to environment
[17:37:33.992] - copied ‘MoreArgs’ to environment
[17:37:33.992] - copied ‘...future.elements_ii’ to environment
[17:37:33.992] - copied ‘...future.seeds_ii’ to environment
[17:37:33.992] - copied ‘...future.globals.maxSize’ to environment
[17:37:33.992] assign_globals() ... done
[17:37:33.992] plan(): Setting new future strategy stack:
[17:37:33.992] List of future strategies:
[17:37:33.992] 1. sequential:
[17:37:33.992]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:33.992]    - tweaked: FALSE
[17:37:33.992]    - call: NULL
[17:37:33.993] plan(): nbrOfWorkers() = 1
[17:37:33.994] plan(): Setting new future strategy stack:
[17:37:33.994] List of future strategies:
[17:37:33.994] 1. sequential:
[17:37:33.994]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:33.994]    - tweaked: FALSE
[17:37:33.994]    - call: plan(strategy)
[17:37:33.994] plan(): nbrOfWorkers() = 1
[17:37:33.994] SequentialFuture started (and completed)
[17:37:33.994] - Launch lazy future ... done
[17:37:33.994] run() for ‘SequentialFuture’ ... done
[17:37:33.995] Created future:
[17:37:33.995] SequentialFuture:
[17:37:33.995] Label: ‘future_.mapply-1’
[17:37:33.995] Expression:
[17:37:33.995] {
[17:37:33.995]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:33.995]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:33.995]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:33.995]         on.exit(options(oopts), add = TRUE)
[17:37:33.995]     }
[17:37:33.995]     {
[17:37:33.995]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:33.995]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:33.995]         do.call(mapply, args = args)
[17:37:33.995]     }
[17:37:33.995] }
[17:37:33.995] Lazy evaluation: FALSE
[17:37:33.995] Asynchronous evaluation: FALSE
[17:37:33.995] Local evaluation: TRUE
[17:37:33.995] Environment: R_GlobalEnv
[17:37:33.995] Capture standard output: TRUE
[17:37:33.995] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:33.995] Globals: 5 objects totaling 2.26 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:33.995] Packages: <none>
[17:37:33.995] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:33.995] Resolved: TRUE
[17:37:33.995] Value: 200 bytes of class ‘list’
[17:37:33.995] Early signaling: FALSE
[17:37:33.995] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:33.995] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:33.996] Chunk #1 of 1 ... DONE
[17:37:33.996] Launching 1 futures (chunks) ... DONE
[17:37:33.996] Resolving 1 futures (chunks) ...
[17:37:33.996] resolve() on list ...
[17:37:33.996]  recursive: 0
[17:37:33.996]  length: 1
[17:37:33.996] 
[17:37:33.996] resolved() for ‘SequentialFuture’ ...
[17:37:33.996] - state: ‘finished’
[17:37:33.996] - run: TRUE
[17:37:33.997] - result: ‘FutureResult’
[17:37:33.997] resolved() for ‘SequentialFuture’ ... done
[17:37:33.997] Future #1
[17:37:33.997] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:33.997] - nx: 1
[17:37:33.997] - relay: TRUE
[17:37:33.997] - stdout: TRUE
[17:37:33.997] - signal: TRUE
[17:37:33.997] - resignal: FALSE
[17:37:33.997] - force: TRUE
[17:37:33.997] - relayed: [n=1] FALSE
[17:37:33.998] - queued futures: [n=1] FALSE
[17:37:33.998]  - until=1
[17:37:33.998]  - relaying element #1
[17:37:33.998] - relayed: [n=1] TRUE
[17:37:33.998] - queued futures: [n=1] TRUE
[17:37:33.998] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:33.998]  length: 0 (resolved future 1)
[17:37:33.998] Relaying remaining futures
[17:37:33.998] signalConditionsASAP(NULL, pos=0) ...
[17:37:33.998] - nx: 1
[17:37:33.999] - relay: TRUE
[17:37:33.999] - stdout: TRUE
[17:37:33.999] - signal: TRUE
[17:37:33.999] - resignal: FALSE
[17:37:33.999] - force: TRUE
[17:37:33.999] - relayed: [n=1] TRUE
[17:37:33.999] - queued futures: [n=1] TRUE
 - flush all
[17:37:33.999] - relayed: [n=1] TRUE
[17:37:33.999] - queued futures: [n=1] TRUE
[17:37:33.999] signalConditionsASAP(NULL, pos=0) ... done
[17:37:33.999] resolve() on list ... DONE
[17:37:34.000]  - Number of value chunks collected: 1
[17:37:34.000] Resolving 1 futures (chunks) ... DONE
[17:37:34.000] Reducing values from 1 chunks ...
[17:37:34.000]  - Number of values collected after concatenation: 3
[17:37:34.000]  - Number of values expected: 3
[17:37:34.000] Reducing values from 1 chunks ... DONE
[17:37:34.000] future_mapply() ... DONE
[17:37:34.000] future_mapply() ...
[17:37:34.002] Number of chunks: 5
[17:37:34.002] getGlobalsAndPackagesXApply() ...
[17:37:34.002]  - future.globals: TRUE
[17:37:34.002] getGlobalsAndPackages() ...
[17:37:34.003] Searching for globals...
[17:37:34.004] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:37:34.004] Searching for globals ... DONE
[17:37:34.004] Resolving globals: FALSE
[17:37:34.004] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:37:34.005] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:37:34.005] - globals: [1] ‘FUN’
[17:37:34.005] 
[17:37:34.005] getGlobalsAndPackages() ... DONE
[17:37:34.005]  - globals found/used: [n=1] ‘FUN’
[17:37:34.005]  - needed namespaces: [n=0] 
[17:37:34.005] Finding globals ... DONE
[17:37:34.005] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:34.006] List of 2
[17:37:34.006]  $ ...future.FUN:function (C, k)  
[17:37:34.006]  $ MoreArgs     : NULL
[17:37:34.006]  - attr(*, "where")=List of 2
[17:37:34.006]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:34.006]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:34.006]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.006]  - attr(*, "resolved")= logi FALSE
[17:37:34.006]  - attr(*, "total_size")= num NA
[17:37:34.008] Packages to be attached in all futures: [n=0] 
[17:37:34.008] getGlobalsAndPackagesXApply() ... DONE
[17:37:34.008] Number of futures (= number of chunks): 5
[17:37:34.008] Launching 5 futures (chunks) ...
[17:37:34.008] Chunk #1 of 5 ...
[17:37:34.008]  - Finding globals in '...' for chunk #1 ...
[17:37:34.009] getGlobalsAndPackages() ...
[17:37:34.009] Searching for globals...
[17:37:34.011] 
[17:37:34.011] Searching for globals ... DONE
[17:37:34.011] - globals: [0] <none>
[17:37:34.011] getGlobalsAndPackages() ... DONE
[17:37:34.011]    + additional globals found: [n=0] 
[17:37:34.011]    + additional namespaces needed: [n=0] 
[17:37:34.011]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:34.011]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:37:34.011]  - seeds: <none>
[17:37:34.011]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.011] getGlobalsAndPackages() ...
[17:37:34.012] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.012] Resolving globals: FALSE
[17:37:34.012] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:37:34.013] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:34.013] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.013] 
[17:37:34.013] getGlobalsAndPackages() ... DONE
[17:37:34.013] run() for ‘Future’ ...
[17:37:34.013] - state: ‘created’
[17:37:34.013] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.014] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.014] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.014]   - Field: ‘label’
[17:37:34.014]   - Field: ‘local’
[17:37:34.014]   - Field: ‘owner’
[17:37:34.014]   - Field: ‘envir’
[17:37:34.014]   - Field: ‘packages’
[17:37:34.014]   - Field: ‘gc’
[17:37:34.014]   - Field: ‘conditions’
[17:37:34.014]   - Field: ‘expr’
[17:37:34.015]   - Field: ‘uuid’
[17:37:34.015]   - Field: ‘seed’
[17:37:34.015]   - Field: ‘version’
[17:37:34.015]   - Field: ‘result’
[17:37:34.015]   - Field: ‘asynchronous’
[17:37:34.015]   - Field: ‘calls’
[17:37:34.015]   - Field: ‘globals’
[17:37:34.015]   - Field: ‘stdout’
[17:37:34.015]   - Field: ‘earlySignal’
[17:37:34.015]   - Field: ‘lazy’
[17:37:34.015]   - Field: ‘state’
[17:37:34.016] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.016] - Launch lazy future ...
[17:37:34.016] Packages needed by the future expression (n = 0): <none>
[17:37:34.016] Packages needed by future strategies (n = 0): <none>
[17:37:34.016] {
[17:37:34.016]     {
[17:37:34.016]         {
[17:37:34.016]             ...future.startTime <- base::Sys.time()
[17:37:34.016]             {
[17:37:34.016]                 {
[17:37:34.016]                   {
[17:37:34.016]                     base::local({
[17:37:34.016]                       has_future <- base::requireNamespace("future", 
[17:37:34.016]                         quietly = TRUE)
[17:37:34.016]                       if (has_future) {
[17:37:34.016]                         ns <- base::getNamespace("future")
[17:37:34.016]                         version <- ns[[".package"]][["version"]]
[17:37:34.016]                         if (is.null(version)) 
[17:37:34.016]                           version <- utils::packageVersion("future")
[17:37:34.016]                       }
[17:37:34.016]                       else {
[17:37:34.016]                         version <- NULL
[17:37:34.016]                       }
[17:37:34.016]                       if (!has_future || version < "1.8.0") {
[17:37:34.016]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.016]                           "", base::R.version$version.string), 
[17:37:34.016]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:34.016]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.016]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.016]                             "release", "version")], collapse = " "), 
[17:37:34.016]                           hostname = base::Sys.info()[["nodename"]])
[17:37:34.016]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.016]                           info)
[17:37:34.016]                         info <- base::paste(info, collapse = "; ")
[17:37:34.016]                         if (!has_future) {
[17:37:34.016]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.016]                             info)
[17:37:34.016]                         }
[17:37:34.016]                         else {
[17:37:34.016]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.016]                             info, version)
[17:37:34.016]                         }
[17:37:34.016]                         base::stop(msg)
[17:37:34.016]                       }
[17:37:34.016]                     })
[17:37:34.016]                   }
[17:37:34.016]                   ...future.strategy.old <- future::plan("list")
[17:37:34.016]                   options(future.plan = NULL)
[17:37:34.016]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.016]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.016]                 }
[17:37:34.016]                 ...future.workdir <- getwd()
[17:37:34.016]             }
[17:37:34.016]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.016]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.016]         }
[17:37:34.016]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.016]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:37:34.016]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.016]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.016]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.016]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.016]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.016]             base::names(...future.oldOptions))
[17:37:34.016]     }
[17:37:34.016]     if (FALSE) {
[17:37:34.016]     }
[17:37:34.016]     else {
[17:37:34.016]         if (TRUE) {
[17:37:34.016]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.016]                 open = "w")
[17:37:34.016]         }
[17:37:34.016]         else {
[17:37:34.016]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.016]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.016]         }
[17:37:34.016]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.016]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.016]             base::sink(type = "output", split = FALSE)
[17:37:34.016]             base::close(...future.stdout)
[17:37:34.016]         }, add = TRUE)
[17:37:34.016]     }
[17:37:34.016]     ...future.frame <- base::sys.nframe()
[17:37:34.016]     ...future.conditions <- base::list()
[17:37:34.016]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.016]     if (FALSE) {
[17:37:34.016]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.016]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.016]     }
[17:37:34.016]     ...future.result <- base::tryCatch({
[17:37:34.016]         base::withCallingHandlers({
[17:37:34.016]             ...future.value <- base::withVisible(base::local({
[17:37:34.016]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.016]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.016]                   ...future.globals.maxSize)) {
[17:37:34.016]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.016]                   on.exit(options(oopts), add = TRUE)
[17:37:34.016]                 }
[17:37:34.016]                 {
[17:37:34.016]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.016]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.016]                     USE.NAMES = FALSE)
[17:37:34.016]                   do.call(mapply, args = args)
[17:37:34.016]                 }
[17:37:34.016]             }))
[17:37:34.016]             future::FutureResult(value = ...future.value$value, 
[17:37:34.016]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.016]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.016]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.016]                     ...future.globalenv.names))
[17:37:34.016]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.016]         }, condition = base::local({
[17:37:34.016]             c <- base::c
[17:37:34.016]             inherits <- base::inherits
[17:37:34.016]             invokeRestart <- base::invokeRestart
[17:37:34.016]             length <- base::length
[17:37:34.016]             list <- base::list
[17:37:34.016]             seq.int <- base::seq.int
[17:37:34.016]             signalCondition <- base::signalCondition
[17:37:34.016]             sys.calls <- base::sys.calls
[17:37:34.016]             `[[` <- base::`[[`
[17:37:34.016]             `+` <- base::`+`
[17:37:34.016]             `<<-` <- base::`<<-`
[17:37:34.016]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.016]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.016]                   3L)]
[17:37:34.016]             }
[17:37:34.016]             function(cond) {
[17:37:34.016]                 is_error <- inherits(cond, "error")
[17:37:34.016]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.016]                   NULL)
[17:37:34.016]                 if (is_error) {
[17:37:34.016]                   sessionInformation <- function() {
[17:37:34.016]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.016]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.016]                       search = base::search(), system = base::Sys.info())
[17:37:34.016]                   }
[17:37:34.016]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.016]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.016]                     cond$call), session = sessionInformation(), 
[17:37:34.016]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.016]                   signalCondition(cond)
[17:37:34.016]                 }
[17:37:34.016]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.016]                 "immediateCondition"))) {
[17:37:34.016]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.016]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.016]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.016]                   if (TRUE && !signal) {
[17:37:34.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.016]                     {
[17:37:34.016]                       inherits <- base::inherits
[17:37:34.016]                       invokeRestart <- base::invokeRestart
[17:37:34.016]                       is.null <- base::is.null
[17:37:34.016]                       muffled <- FALSE
[17:37:34.016]                       if (inherits(cond, "message")) {
[17:37:34.016]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.016]                         if (muffled) 
[17:37:34.016]                           invokeRestart("muffleMessage")
[17:37:34.016]                       }
[17:37:34.016]                       else if (inherits(cond, "warning")) {
[17:37:34.016]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.016]                         if (muffled) 
[17:37:34.016]                           invokeRestart("muffleWarning")
[17:37:34.016]                       }
[17:37:34.016]                       else if (inherits(cond, "condition")) {
[17:37:34.016]                         if (!is.null(pattern)) {
[17:37:34.016]                           computeRestarts <- base::computeRestarts
[17:37:34.016]                           grepl <- base::grepl
[17:37:34.016]                           restarts <- computeRestarts(cond)
[17:37:34.016]                           for (restart in restarts) {
[17:37:34.016]                             name <- restart$name
[17:37:34.016]                             if (is.null(name)) 
[17:37:34.016]                               next
[17:37:34.016]                             if (!grepl(pattern, name)) 
[17:37:34.016]                               next
[17:37:34.016]                             invokeRestart(restart)
[17:37:34.016]                             muffled <- TRUE
[17:37:34.016]                             break
[17:37:34.016]                           }
[17:37:34.016]                         }
[17:37:34.016]                       }
[17:37:34.016]                       invisible(muffled)
[17:37:34.016]                     }
[17:37:34.016]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.016]                   }
[17:37:34.016]                 }
[17:37:34.016]                 else {
[17:37:34.016]                   if (TRUE) {
[17:37:34.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.016]                     {
[17:37:34.016]                       inherits <- base::inherits
[17:37:34.016]                       invokeRestart <- base::invokeRestart
[17:37:34.016]                       is.null <- base::is.null
[17:37:34.016]                       muffled <- FALSE
[17:37:34.016]                       if (inherits(cond, "message")) {
[17:37:34.016]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.016]                         if (muffled) 
[17:37:34.016]                           invokeRestart("muffleMessage")
[17:37:34.016]                       }
[17:37:34.016]                       else if (inherits(cond, "warning")) {
[17:37:34.016]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.016]                         if (muffled) 
[17:37:34.016]                           invokeRestart("muffleWarning")
[17:37:34.016]                       }
[17:37:34.016]                       else if (inherits(cond, "condition")) {
[17:37:34.016]                         if (!is.null(pattern)) {
[17:37:34.016]                           computeRestarts <- base::computeRestarts
[17:37:34.016]                           grepl <- base::grepl
[17:37:34.016]                           restarts <- computeRestarts(cond)
[17:37:34.016]                           for (restart in restarts) {
[17:37:34.016]                             name <- restart$name
[17:37:34.016]                             if (is.null(name)) 
[17:37:34.016]                               next
[17:37:34.016]                             if (!grepl(pattern, name)) 
[17:37:34.016]                               next
[17:37:34.016]                             invokeRestart(restart)
[17:37:34.016]                             muffled <- TRUE
[17:37:34.016]                             break
[17:37:34.016]                           }
[17:37:34.016]                         }
[17:37:34.016]                       }
[17:37:34.016]                       invisible(muffled)
[17:37:34.016]                     }
[17:37:34.016]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.016]                   }
[17:37:34.016]                 }
[17:37:34.016]             }
[17:37:34.016]         }))
[17:37:34.016]     }, error = function(ex) {
[17:37:34.016]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.016]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.016]                 ...future.rng), started = ...future.startTime, 
[17:37:34.016]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.016]             version = "1.8"), class = "FutureResult")
[17:37:34.016]     }, finally = {
[17:37:34.016]         if (!identical(...future.workdir, getwd())) 
[17:37:34.016]             setwd(...future.workdir)
[17:37:34.016]         {
[17:37:34.016]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.016]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.016]             }
[17:37:34.016]             base::options(...future.oldOptions)
[17:37:34.016]             if (.Platform$OS.type == "windows") {
[17:37:34.016]                 old_names <- names(...future.oldEnvVars)
[17:37:34.016]                 envs <- base::Sys.getenv()
[17:37:34.016]                 names <- names(envs)
[17:37:34.016]                 common <- intersect(names, old_names)
[17:37:34.016]                 added <- setdiff(names, old_names)
[17:37:34.016]                 removed <- setdiff(old_names, names)
[17:37:34.016]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.016]                   envs[common]]
[17:37:34.016]                 NAMES <- toupper(changed)
[17:37:34.016]                 args <- list()
[17:37:34.016]                 for (kk in seq_along(NAMES)) {
[17:37:34.016]                   name <- changed[[kk]]
[17:37:34.016]                   NAME <- NAMES[[kk]]
[17:37:34.016]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.016]                     next
[17:37:34.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.016]                 }
[17:37:34.016]                 NAMES <- toupper(added)
[17:37:34.016]                 for (kk in seq_along(NAMES)) {
[17:37:34.016]                   name <- added[[kk]]
[17:37:34.016]                   NAME <- NAMES[[kk]]
[17:37:34.016]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.016]                     next
[17:37:34.016]                   args[[name]] <- ""
[17:37:34.016]                 }
[17:37:34.016]                 NAMES <- toupper(removed)
[17:37:34.016]                 for (kk in seq_along(NAMES)) {
[17:37:34.016]                   name <- removed[[kk]]
[17:37:34.016]                   NAME <- NAMES[[kk]]
[17:37:34.016]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.016]                     next
[17:37:34.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.016]                 }
[17:37:34.016]                 if (length(args) > 0) 
[17:37:34.016]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.016]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.016]             }
[17:37:34.016]             else {
[17:37:34.016]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.016]             }
[17:37:34.016]             {
[17:37:34.016]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.016]                   0L) {
[17:37:34.016]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.016]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.016]                   base::options(opts)
[17:37:34.016]                 }
[17:37:34.016]                 {
[17:37:34.016]                   {
[17:37:34.016]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:34.016]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:34.016]                     -1786728155L), envir = base::globalenv(), 
[17:37:34.016]                       inherits = FALSE)
[17:37:34.016]                     NULL
[17:37:34.016]                   }
[17:37:34.016]                   options(future.plan = NULL)
[17:37:34.016]                   if (is.na(NA_character_)) 
[17:37:34.016]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.016]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.016]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.016]                     .init = FALSE)
[17:37:34.016]                 }
[17:37:34.016]             }
[17:37:34.016]         }
[17:37:34.016]     })
[17:37:34.016]     if (TRUE) {
[17:37:34.016]         base::sink(type = "output", split = FALSE)
[17:37:34.016]         if (TRUE) {
[17:37:34.016]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.016]         }
[17:37:34.016]         else {
[17:37:34.016]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.016]         }
[17:37:34.016]         base::close(...future.stdout)
[17:37:34.016]         ...future.stdout <- NULL
[17:37:34.016]     }
[17:37:34.016]     ...future.result$conditions <- ...future.conditions
[17:37:34.016]     ...future.result$finished <- base::Sys.time()
[17:37:34.016]     ...future.result
[17:37:34.016] }
[17:37:34.018] assign_globals() ...
[17:37:34.018] List of 5
[17:37:34.018]  $ ...future.FUN            :function (C, k)  
[17:37:34.018]  $ MoreArgs                 : NULL
[17:37:34.018]  $ ...future.elements_ii    :List of 2
[17:37:34.018]   ..$ :List of 1
[17:37:34.018]   .. ..$ : chr "A"
[17:37:34.018]   ..$ :List of 1
[17:37:34.018]   .. ..$ : int 5
[17:37:34.018]  $ ...future.seeds_ii       : NULL
[17:37:34.018]  $ ...future.globals.maxSize: NULL
[17:37:34.018]  - attr(*, "where")=List of 5
[17:37:34.018]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.018]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.018]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.018]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.018]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.018]  - attr(*, "resolved")= logi FALSE
[17:37:34.018]  - attr(*, "total_size")= num 3488
[17:37:34.018]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.018]  - attr(*, "already-done")= logi TRUE
[17:37:34.023] - reassign environment for ‘...future.FUN’
[17:37:34.023] - copied ‘...future.FUN’ to environment
[17:37:34.023] - copied ‘MoreArgs’ to environment
[17:37:34.023] - copied ‘...future.elements_ii’ to environment
[17:37:34.023] - copied ‘...future.seeds_ii’ to environment
[17:37:34.023] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.023] assign_globals() ... done
[17:37:34.023] plan(): Setting new future strategy stack:
[17:37:34.024] List of future strategies:
[17:37:34.024] 1. sequential:
[17:37:34.024]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.024]    - tweaked: FALSE
[17:37:34.024]    - call: NULL
[17:37:34.024] plan(): nbrOfWorkers() = 1
[17:37:34.025] plan(): Setting new future strategy stack:
[17:37:34.025] List of future strategies:
[17:37:34.025] 1. sequential:
[17:37:34.025]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.025]    - tweaked: FALSE
[17:37:34.025]    - call: plan(strategy)
[17:37:34.025] plan(): nbrOfWorkers() = 1
[17:37:34.025] SequentialFuture started (and completed)
[17:37:34.026] - Launch lazy future ... done
[17:37:34.026] run() for ‘SequentialFuture’ ... done
[17:37:34.026] Created future:
[17:37:34.026] SequentialFuture:
[17:37:34.026] Label: ‘future_mapply-1’
[17:37:34.026] Expression:
[17:37:34.026] {
[17:37:34.026]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.026]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.026]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.026]         on.exit(options(oopts), add = TRUE)
[17:37:34.026]     }
[17:37:34.026]     {
[17:37:34.026]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.026]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.026]         do.call(mapply, args = args)
[17:37:34.026]     }
[17:37:34.026] }
[17:37:34.026] Lazy evaluation: FALSE
[17:37:34.026] Asynchronous evaluation: FALSE
[17:37:34.026] Local evaluation: TRUE
[17:37:34.026] Environment: R_GlobalEnv
[17:37:34.026] Capture standard output: TRUE
[17:37:34.026] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.026] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.026] Packages: <none>
[17:37:34.026] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.026] Resolved: TRUE
[17:37:34.026] Value: 112 bytes of class ‘list’
[17:37:34.026] Early signaling: FALSE
[17:37:34.026] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.026] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.027] Chunk #1 of 5 ... DONE
[17:37:34.027] Chunk #2 of 5 ...
[17:37:34.027]  - Finding globals in '...' for chunk #2 ...
[17:37:34.027] getGlobalsAndPackages() ...
[17:37:34.027] Searching for globals...
[17:37:34.027] 
[17:37:34.027] Searching for globals ... DONE
[17:37:34.028] - globals: [0] <none>
[17:37:34.028] getGlobalsAndPackages() ... DONE
[17:37:34.028]    + additional globals found: [n=0] 
[17:37:34.028]    + additional namespaces needed: [n=0] 
[17:37:34.028]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:34.028]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:37:34.028]  - seeds: <none>
[17:37:34.028]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.028] getGlobalsAndPackages() ...
[17:37:34.028] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.029] Resolving globals: FALSE
[17:37:34.029] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:37:34.029] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:34.029] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.030] 
[17:37:34.030] getGlobalsAndPackages() ... DONE
[17:37:34.030] run() for ‘Future’ ...
[17:37:34.030] - state: ‘created’
[17:37:34.030] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.030] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.031] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.031]   - Field: ‘label’
[17:37:34.031]   - Field: ‘local’
[17:37:34.031]   - Field: ‘owner’
[17:37:34.031]   - Field: ‘envir’
[17:37:34.031]   - Field: ‘packages’
[17:37:34.031]   - Field: ‘gc’
[17:37:34.031]   - Field: ‘conditions’
[17:37:34.031]   - Field: ‘expr’
[17:37:34.031]   - Field: ‘uuid’
[17:37:34.031]   - Field: ‘seed’
[17:37:34.032]   - Field: ‘version’
[17:37:34.032]   - Field: ‘result’
[17:37:34.032]   - Field: ‘asynchronous’
[17:37:34.032]   - Field: ‘calls’
[17:37:34.032]   - Field: ‘globals’
[17:37:34.032]   - Field: ‘stdout’
[17:37:34.032]   - Field: ‘earlySignal’
[17:37:34.032]   - Field: ‘lazy’
[17:37:34.032]   - Field: ‘state’
[17:37:34.032] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.032] - Launch lazy future ...
[17:37:34.033] Packages needed by the future expression (n = 0): <none>
[17:37:34.033] Packages needed by future strategies (n = 0): <none>
[17:37:34.033] {
[17:37:34.033]     {
[17:37:34.033]         {
[17:37:34.033]             ...future.startTime <- base::Sys.time()
[17:37:34.033]             {
[17:37:34.033]                 {
[17:37:34.033]                   {
[17:37:34.033]                     base::local({
[17:37:34.033]                       has_future <- base::requireNamespace("future", 
[17:37:34.033]                         quietly = TRUE)
[17:37:34.033]                       if (has_future) {
[17:37:34.033]                         ns <- base::getNamespace("future")
[17:37:34.033]                         version <- ns[[".package"]][["version"]]
[17:37:34.033]                         if (is.null(version)) 
[17:37:34.033]                           version <- utils::packageVersion("future")
[17:37:34.033]                       }
[17:37:34.033]                       else {
[17:37:34.033]                         version <- NULL
[17:37:34.033]                       }
[17:37:34.033]                       if (!has_future || version < "1.8.0") {
[17:37:34.033]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.033]                           "", base::R.version$version.string), 
[17:37:34.033]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:34.033]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.033]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.033]                             "release", "version")], collapse = " "), 
[17:37:34.033]                           hostname = base::Sys.info()[["nodename"]])
[17:37:34.033]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.033]                           info)
[17:37:34.033]                         info <- base::paste(info, collapse = "; ")
[17:37:34.033]                         if (!has_future) {
[17:37:34.033]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.033]                             info)
[17:37:34.033]                         }
[17:37:34.033]                         else {
[17:37:34.033]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.033]                             info, version)
[17:37:34.033]                         }
[17:37:34.033]                         base::stop(msg)
[17:37:34.033]                       }
[17:37:34.033]                     })
[17:37:34.033]                   }
[17:37:34.033]                   ...future.strategy.old <- future::plan("list")
[17:37:34.033]                   options(future.plan = NULL)
[17:37:34.033]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.033]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.033]                 }
[17:37:34.033]                 ...future.workdir <- getwd()
[17:37:34.033]             }
[17:37:34.033]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.033]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.033]         }
[17:37:34.033]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.033]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:37:34.033]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.033]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.033]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.033]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.033]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.033]             base::names(...future.oldOptions))
[17:37:34.033]     }
[17:37:34.033]     if (FALSE) {
[17:37:34.033]     }
[17:37:34.033]     else {
[17:37:34.033]         if (TRUE) {
[17:37:34.033]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.033]                 open = "w")
[17:37:34.033]         }
[17:37:34.033]         else {
[17:37:34.033]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.033]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.033]         }
[17:37:34.033]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.033]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.033]             base::sink(type = "output", split = FALSE)
[17:37:34.033]             base::close(...future.stdout)
[17:37:34.033]         }, add = TRUE)
[17:37:34.033]     }
[17:37:34.033]     ...future.frame <- base::sys.nframe()
[17:37:34.033]     ...future.conditions <- base::list()
[17:37:34.033]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.033]     if (FALSE) {
[17:37:34.033]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.033]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.033]     }
[17:37:34.033]     ...future.result <- base::tryCatch({
[17:37:34.033]         base::withCallingHandlers({
[17:37:34.033]             ...future.value <- base::withVisible(base::local({
[17:37:34.033]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.033]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.033]                   ...future.globals.maxSize)) {
[17:37:34.033]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.033]                   on.exit(options(oopts), add = TRUE)
[17:37:34.033]                 }
[17:37:34.033]                 {
[17:37:34.033]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.033]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.033]                     USE.NAMES = FALSE)
[17:37:34.033]                   do.call(mapply, args = args)
[17:37:34.033]                 }
[17:37:34.033]             }))
[17:37:34.033]             future::FutureResult(value = ...future.value$value, 
[17:37:34.033]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.033]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.033]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.033]                     ...future.globalenv.names))
[17:37:34.033]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.033]         }, condition = base::local({
[17:37:34.033]             c <- base::c
[17:37:34.033]             inherits <- base::inherits
[17:37:34.033]             invokeRestart <- base::invokeRestart
[17:37:34.033]             length <- base::length
[17:37:34.033]             list <- base::list
[17:37:34.033]             seq.int <- base::seq.int
[17:37:34.033]             signalCondition <- base::signalCondition
[17:37:34.033]             sys.calls <- base::sys.calls
[17:37:34.033]             `[[` <- base::`[[`
[17:37:34.033]             `+` <- base::`+`
[17:37:34.033]             `<<-` <- base::`<<-`
[17:37:34.033]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.033]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.033]                   3L)]
[17:37:34.033]             }
[17:37:34.033]             function(cond) {
[17:37:34.033]                 is_error <- inherits(cond, "error")
[17:37:34.033]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.033]                   NULL)
[17:37:34.033]                 if (is_error) {
[17:37:34.033]                   sessionInformation <- function() {
[17:37:34.033]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.033]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.033]                       search = base::search(), system = base::Sys.info())
[17:37:34.033]                   }
[17:37:34.033]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.033]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.033]                     cond$call), session = sessionInformation(), 
[17:37:34.033]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.033]                   signalCondition(cond)
[17:37:34.033]                 }
[17:37:34.033]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.033]                 "immediateCondition"))) {
[17:37:34.033]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.033]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.033]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.033]                   if (TRUE && !signal) {
[17:37:34.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.033]                     {
[17:37:34.033]                       inherits <- base::inherits
[17:37:34.033]                       invokeRestart <- base::invokeRestart
[17:37:34.033]                       is.null <- base::is.null
[17:37:34.033]                       muffled <- FALSE
[17:37:34.033]                       if (inherits(cond, "message")) {
[17:37:34.033]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.033]                         if (muffled) 
[17:37:34.033]                           invokeRestart("muffleMessage")
[17:37:34.033]                       }
[17:37:34.033]                       else if (inherits(cond, "warning")) {
[17:37:34.033]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.033]                         if (muffled) 
[17:37:34.033]                           invokeRestart("muffleWarning")
[17:37:34.033]                       }
[17:37:34.033]                       else if (inherits(cond, "condition")) {
[17:37:34.033]                         if (!is.null(pattern)) {
[17:37:34.033]                           computeRestarts <- base::computeRestarts
[17:37:34.033]                           grepl <- base::grepl
[17:37:34.033]                           restarts <- computeRestarts(cond)
[17:37:34.033]                           for (restart in restarts) {
[17:37:34.033]                             name <- restart$name
[17:37:34.033]                             if (is.null(name)) 
[17:37:34.033]                               next
[17:37:34.033]                             if (!grepl(pattern, name)) 
[17:37:34.033]                               next
[17:37:34.033]                             invokeRestart(restart)
[17:37:34.033]                             muffled <- TRUE
[17:37:34.033]                             break
[17:37:34.033]                           }
[17:37:34.033]                         }
[17:37:34.033]                       }
[17:37:34.033]                       invisible(muffled)
[17:37:34.033]                     }
[17:37:34.033]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.033]                   }
[17:37:34.033]                 }
[17:37:34.033]                 else {
[17:37:34.033]                   if (TRUE) {
[17:37:34.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.033]                     {
[17:37:34.033]                       inherits <- base::inherits
[17:37:34.033]                       invokeRestart <- base::invokeRestart
[17:37:34.033]                       is.null <- base::is.null
[17:37:34.033]                       muffled <- FALSE
[17:37:34.033]                       if (inherits(cond, "message")) {
[17:37:34.033]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.033]                         if (muffled) 
[17:37:34.033]                           invokeRestart("muffleMessage")
[17:37:34.033]                       }
[17:37:34.033]                       else if (inherits(cond, "warning")) {
[17:37:34.033]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.033]                         if (muffled) 
[17:37:34.033]                           invokeRestart("muffleWarning")
[17:37:34.033]                       }
[17:37:34.033]                       else if (inherits(cond, "condition")) {
[17:37:34.033]                         if (!is.null(pattern)) {
[17:37:34.033]                           computeRestarts <- base::computeRestarts
[17:37:34.033]                           grepl <- base::grepl
[17:37:34.033]                           restarts <- computeRestarts(cond)
[17:37:34.033]                           for (restart in restarts) {
[17:37:34.033]                             name <- restart$name
[17:37:34.033]                             if (is.null(name)) 
[17:37:34.033]                               next
[17:37:34.033]                             if (!grepl(pattern, name)) 
[17:37:34.033]                               next
[17:37:34.033]                             invokeRestart(restart)
[17:37:34.033]                             muffled <- TRUE
[17:37:34.033]                             break
[17:37:34.033]                           }
[17:37:34.033]                         }
[17:37:34.033]                       }
[17:37:34.033]                       invisible(muffled)
[17:37:34.033]                     }
[17:37:34.033]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.033]                   }
[17:37:34.033]                 }
[17:37:34.033]             }
[17:37:34.033]         }))
[17:37:34.033]     }, error = function(ex) {
[17:37:34.033]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.033]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.033]                 ...future.rng), started = ...future.startTime, 
[17:37:34.033]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.033]             version = "1.8"), class = "FutureResult")
[17:37:34.033]     }, finally = {
[17:37:34.033]         if (!identical(...future.workdir, getwd())) 
[17:37:34.033]             setwd(...future.workdir)
[17:37:34.033]         {
[17:37:34.033]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.033]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.033]             }
[17:37:34.033]             base::options(...future.oldOptions)
[17:37:34.033]             if (.Platform$OS.type == "windows") {
[17:37:34.033]                 old_names <- names(...future.oldEnvVars)
[17:37:34.033]                 envs <- base::Sys.getenv()
[17:37:34.033]                 names <- names(envs)
[17:37:34.033]                 common <- intersect(names, old_names)
[17:37:34.033]                 added <- setdiff(names, old_names)
[17:37:34.033]                 removed <- setdiff(old_names, names)
[17:37:34.033]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.033]                   envs[common]]
[17:37:34.033]                 NAMES <- toupper(changed)
[17:37:34.033]                 args <- list()
[17:37:34.033]                 for (kk in seq_along(NAMES)) {
[17:37:34.033]                   name <- changed[[kk]]
[17:37:34.033]                   NAME <- NAMES[[kk]]
[17:37:34.033]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.033]                     next
[17:37:34.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.033]                 }
[17:37:34.033]                 NAMES <- toupper(added)
[17:37:34.033]                 for (kk in seq_along(NAMES)) {
[17:37:34.033]                   name <- added[[kk]]
[17:37:34.033]                   NAME <- NAMES[[kk]]
[17:37:34.033]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.033]                     next
[17:37:34.033]                   args[[name]] <- ""
[17:37:34.033]                 }
[17:37:34.033]                 NAMES <- toupper(removed)
[17:37:34.033]                 for (kk in seq_along(NAMES)) {
[17:37:34.033]                   name <- removed[[kk]]
[17:37:34.033]                   NAME <- NAMES[[kk]]
[17:37:34.033]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.033]                     next
[17:37:34.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.033]                 }
[17:37:34.033]                 if (length(args) > 0) 
[17:37:34.033]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.033]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.033]             }
[17:37:34.033]             else {
[17:37:34.033]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.033]             }
[17:37:34.033]             {
[17:37:34.033]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.033]                   0L) {
[17:37:34.033]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.033]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.033]                   base::options(opts)
[17:37:34.033]                 }
[17:37:34.033]                 {
[17:37:34.033]                   {
[17:37:34.033]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:34.033]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:34.033]                     -1786728155L), envir = base::globalenv(), 
[17:37:34.033]                       inherits = FALSE)
[17:37:34.033]                     NULL
[17:37:34.033]                   }
[17:37:34.033]                   options(future.plan = NULL)
[17:37:34.033]                   if (is.na(NA_character_)) 
[17:37:34.033]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.033]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.033]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.033]                     .init = FALSE)
[17:37:34.033]                 }
[17:37:34.033]             }
[17:37:34.033]         }
[17:37:34.033]     })
[17:37:34.033]     if (TRUE) {
[17:37:34.033]         base::sink(type = "output", split = FALSE)
[17:37:34.033]         if (TRUE) {
[17:37:34.033]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.033]         }
[17:37:34.033]         else {
[17:37:34.033]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.033]         }
[17:37:34.033]         base::close(...future.stdout)
[17:37:34.033]         ...future.stdout <- NULL
[17:37:34.033]     }
[17:37:34.033]     ...future.result$conditions <- ...future.conditions
[17:37:34.033]     ...future.result$finished <- base::Sys.time()
[17:37:34.033]     ...future.result
[17:37:34.033] }
[17:37:34.036] assign_globals() ...
[17:37:34.036] List of 5
[17:37:34.036]  $ ...future.FUN            :function (C, k)  
[17:37:34.036]  $ MoreArgs                 : NULL
[17:37:34.036]  $ ...future.elements_ii    :List of 2
[17:37:34.036]   ..$ :List of 1
[17:37:34.036]   .. ..$ : chr "B"
[17:37:34.036]   ..$ :List of 1
[17:37:34.036]   .. ..$ : int 4
[17:37:34.036]  $ ...future.seeds_ii       : NULL
[17:37:34.036]  $ ...future.globals.maxSize: NULL
[17:37:34.036]  - attr(*, "where")=List of 5
[17:37:34.036]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.036]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.036]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.036]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.036]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.036]  - attr(*, "resolved")= logi FALSE
[17:37:34.036]  - attr(*, "total_size")= num 3488
[17:37:34.036]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.036]  - attr(*, "already-done")= logi TRUE
[17:37:34.041] - reassign environment for ‘...future.FUN’
[17:37:34.041] - copied ‘...future.FUN’ to environment
[17:37:34.041] - copied ‘MoreArgs’ to environment
[17:37:34.042] - copied ‘...future.elements_ii’ to environment
[17:37:34.042] - copied ‘...future.seeds_ii’ to environment
[17:37:34.042] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.042] assign_globals() ... done
[17:37:34.042] plan(): Setting new future strategy stack:
[17:37:34.042] List of future strategies:
[17:37:34.042] 1. sequential:
[17:37:34.042]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.042]    - tweaked: FALSE
[17:37:34.042]    - call: NULL
[17:37:34.043] plan(): nbrOfWorkers() = 1
[17:37:34.043] plan(): Setting new future strategy stack:
[17:37:34.043] List of future strategies:
[17:37:34.043] 1. sequential:
[17:37:34.043]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.043]    - tweaked: FALSE
[17:37:34.043]    - call: plan(strategy)
[17:37:34.044] plan(): nbrOfWorkers() = 1
[17:37:34.044] SequentialFuture started (and completed)
[17:37:34.044] - Launch lazy future ... done
[17:37:34.044] run() for ‘SequentialFuture’ ... done
[17:37:34.044] Created future:
[17:37:34.044] SequentialFuture:
[17:37:34.044] Label: ‘future_mapply-2’
[17:37:34.044] Expression:
[17:37:34.044] {
[17:37:34.044]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.044]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.044]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.044]         on.exit(options(oopts), add = TRUE)
[17:37:34.044]     }
[17:37:34.044]     {
[17:37:34.044]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.044]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.044]         do.call(mapply, args = args)
[17:37:34.044]     }
[17:37:34.044] }
[17:37:34.044] Lazy evaluation: FALSE
[17:37:34.044] Asynchronous evaluation: FALSE
[17:37:34.044] Local evaluation: TRUE
[17:37:34.044] Environment: R_GlobalEnv
[17:37:34.044] Capture standard output: TRUE
[17:37:34.044] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.044] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.044] Packages: <none>
[17:37:34.044] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.044] Resolved: TRUE
[17:37:34.044] Value: 112 bytes of class ‘list’
[17:37:34.044] Early signaling: FALSE
[17:37:34.044] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.044] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.045] Chunk #2 of 5 ... DONE
[17:37:34.045] Chunk #3 of 5 ...
[17:37:34.045]  - Finding globals in '...' for chunk #3 ...
[17:37:34.045] getGlobalsAndPackages() ...
[17:37:34.046] Searching for globals...
[17:37:34.046] 
[17:37:34.046] Searching for globals ... DONE
[17:37:34.046] - globals: [0] <none>
[17:37:34.046] getGlobalsAndPackages() ... DONE
[17:37:34.046]    + additional globals found: [n=0] 
[17:37:34.046]    + additional namespaces needed: [n=0] 
[17:37:34.046]  - Finding globals in '...' for chunk #3 ... DONE
[17:37:34.046]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:37:34.047]  - seeds: <none>
[17:37:34.047]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.047] getGlobalsAndPackages() ...
[17:37:34.047] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.047] Resolving globals: FALSE
[17:37:34.047] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:37:34.048] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:34.048] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.048] 
[17:37:34.048] getGlobalsAndPackages() ... DONE
[17:37:34.048] run() for ‘Future’ ...
[17:37:34.049] - state: ‘created’
[17:37:34.049] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.049] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.049] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.049]   - Field: ‘label’
[17:37:34.049]   - Field: ‘local’
[17:37:34.049]   - Field: ‘owner’
[17:37:34.049]   - Field: ‘envir’
[17:37:34.050]   - Field: ‘packages’
[17:37:34.050]   - Field: ‘gc’
[17:37:34.050]   - Field: ‘conditions’
[17:37:34.050]   - Field: ‘expr’
[17:37:34.050]   - Field: ‘uuid’
[17:37:34.050]   - Field: ‘seed’
[17:37:34.050]   - Field: ‘version’
[17:37:34.050]   - Field: ‘result’
[17:37:34.050]   - Field: ‘asynchronous’
[17:37:34.050]   - Field: ‘calls’
[17:37:34.050]   - Field: ‘globals’
[17:37:34.050]   - Field: ‘stdout’
[17:37:34.051]   - Field: ‘earlySignal’
[17:37:34.051]   - Field: ‘lazy’
[17:37:34.051]   - Field: ‘state’
[17:37:34.051] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.051] - Launch lazy future ...
[17:37:34.051] Packages needed by the future expression (n = 0): <none>
[17:37:34.051] Packages needed by future strategies (n = 0): <none>
[17:37:34.052] {
[17:37:34.052]     {
[17:37:34.052]         {
[17:37:34.052]             ...future.startTime <- base::Sys.time()
[17:37:34.052]             {
[17:37:34.052]                 {
[17:37:34.052]                   {
[17:37:34.052]                     base::local({
[17:37:34.052]                       has_future <- base::requireNamespace("future", 
[17:37:34.052]                         quietly = TRUE)
[17:37:34.052]                       if (has_future) {
[17:37:34.052]                         ns <- base::getNamespace("future")
[17:37:34.052]                         version <- ns[[".package"]][["version"]]
[17:37:34.052]                         if (is.null(version)) 
[17:37:34.052]                           version <- utils::packageVersion("future")
[17:37:34.052]                       }
[17:37:34.052]                       else {
[17:37:34.052]                         version <- NULL
[17:37:34.052]                       }
[17:37:34.052]                       if (!has_future || version < "1.8.0") {
[17:37:34.052]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.052]                           "", base::R.version$version.string), 
[17:37:34.052]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:34.052]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.052]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.052]                             "release", "version")], collapse = " "), 
[17:37:34.052]                           hostname = base::Sys.info()[["nodename"]])
[17:37:34.052]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.052]                           info)
[17:37:34.052]                         info <- base::paste(info, collapse = "; ")
[17:37:34.052]                         if (!has_future) {
[17:37:34.052]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.052]                             info)
[17:37:34.052]                         }
[17:37:34.052]                         else {
[17:37:34.052]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.052]                             info, version)
[17:37:34.052]                         }
[17:37:34.052]                         base::stop(msg)
[17:37:34.052]                       }
[17:37:34.052]                     })
[17:37:34.052]                   }
[17:37:34.052]                   ...future.strategy.old <- future::plan("list")
[17:37:34.052]                   options(future.plan = NULL)
[17:37:34.052]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.052]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.052]                 }
[17:37:34.052]                 ...future.workdir <- getwd()
[17:37:34.052]             }
[17:37:34.052]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.052]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.052]         }
[17:37:34.052]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.052]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:37:34.052]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.052]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.052]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.052]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.052]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.052]             base::names(...future.oldOptions))
[17:37:34.052]     }
[17:37:34.052]     if (FALSE) {
[17:37:34.052]     }
[17:37:34.052]     else {
[17:37:34.052]         if (TRUE) {
[17:37:34.052]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.052]                 open = "w")
[17:37:34.052]         }
[17:37:34.052]         else {
[17:37:34.052]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.052]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.052]         }
[17:37:34.052]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.052]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.052]             base::sink(type = "output", split = FALSE)
[17:37:34.052]             base::close(...future.stdout)
[17:37:34.052]         }, add = TRUE)
[17:37:34.052]     }
[17:37:34.052]     ...future.frame <- base::sys.nframe()
[17:37:34.052]     ...future.conditions <- base::list()
[17:37:34.052]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.052]     if (FALSE) {
[17:37:34.052]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.052]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.052]     }
[17:37:34.052]     ...future.result <- base::tryCatch({
[17:37:34.052]         base::withCallingHandlers({
[17:37:34.052]             ...future.value <- base::withVisible(base::local({
[17:37:34.052]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.052]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.052]                   ...future.globals.maxSize)) {
[17:37:34.052]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.052]                   on.exit(options(oopts), add = TRUE)
[17:37:34.052]                 }
[17:37:34.052]                 {
[17:37:34.052]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.052]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.052]                     USE.NAMES = FALSE)
[17:37:34.052]                   do.call(mapply, args = args)
[17:37:34.052]                 }
[17:37:34.052]             }))
[17:37:34.052]             future::FutureResult(value = ...future.value$value, 
[17:37:34.052]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.052]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.052]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.052]                     ...future.globalenv.names))
[17:37:34.052]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.052]         }, condition = base::local({
[17:37:34.052]             c <- base::c
[17:37:34.052]             inherits <- base::inherits
[17:37:34.052]             invokeRestart <- base::invokeRestart
[17:37:34.052]             length <- base::length
[17:37:34.052]             list <- base::list
[17:37:34.052]             seq.int <- base::seq.int
[17:37:34.052]             signalCondition <- base::signalCondition
[17:37:34.052]             sys.calls <- base::sys.calls
[17:37:34.052]             `[[` <- base::`[[`
[17:37:34.052]             `+` <- base::`+`
[17:37:34.052]             `<<-` <- base::`<<-`
[17:37:34.052]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.052]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.052]                   3L)]
[17:37:34.052]             }
[17:37:34.052]             function(cond) {
[17:37:34.052]                 is_error <- inherits(cond, "error")
[17:37:34.052]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.052]                   NULL)
[17:37:34.052]                 if (is_error) {
[17:37:34.052]                   sessionInformation <- function() {
[17:37:34.052]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.052]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.052]                       search = base::search(), system = base::Sys.info())
[17:37:34.052]                   }
[17:37:34.052]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.052]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.052]                     cond$call), session = sessionInformation(), 
[17:37:34.052]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.052]                   signalCondition(cond)
[17:37:34.052]                 }
[17:37:34.052]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.052]                 "immediateCondition"))) {
[17:37:34.052]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.052]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.052]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.052]                   if (TRUE && !signal) {
[17:37:34.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.052]                     {
[17:37:34.052]                       inherits <- base::inherits
[17:37:34.052]                       invokeRestart <- base::invokeRestart
[17:37:34.052]                       is.null <- base::is.null
[17:37:34.052]                       muffled <- FALSE
[17:37:34.052]                       if (inherits(cond, "message")) {
[17:37:34.052]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.052]                         if (muffled) 
[17:37:34.052]                           invokeRestart("muffleMessage")
[17:37:34.052]                       }
[17:37:34.052]                       else if (inherits(cond, "warning")) {
[17:37:34.052]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.052]                         if (muffled) 
[17:37:34.052]                           invokeRestart("muffleWarning")
[17:37:34.052]                       }
[17:37:34.052]                       else if (inherits(cond, "condition")) {
[17:37:34.052]                         if (!is.null(pattern)) {
[17:37:34.052]                           computeRestarts <- base::computeRestarts
[17:37:34.052]                           grepl <- base::grepl
[17:37:34.052]                           restarts <- computeRestarts(cond)
[17:37:34.052]                           for (restart in restarts) {
[17:37:34.052]                             name <- restart$name
[17:37:34.052]                             if (is.null(name)) 
[17:37:34.052]                               next
[17:37:34.052]                             if (!grepl(pattern, name)) 
[17:37:34.052]                               next
[17:37:34.052]                             invokeRestart(restart)
[17:37:34.052]                             muffled <- TRUE
[17:37:34.052]                             break
[17:37:34.052]                           }
[17:37:34.052]                         }
[17:37:34.052]                       }
[17:37:34.052]                       invisible(muffled)
[17:37:34.052]                     }
[17:37:34.052]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.052]                   }
[17:37:34.052]                 }
[17:37:34.052]                 else {
[17:37:34.052]                   if (TRUE) {
[17:37:34.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.052]                     {
[17:37:34.052]                       inherits <- base::inherits
[17:37:34.052]                       invokeRestart <- base::invokeRestart
[17:37:34.052]                       is.null <- base::is.null
[17:37:34.052]                       muffled <- FALSE
[17:37:34.052]                       if (inherits(cond, "message")) {
[17:37:34.052]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.052]                         if (muffled) 
[17:37:34.052]                           invokeRestart("muffleMessage")
[17:37:34.052]                       }
[17:37:34.052]                       else if (inherits(cond, "warning")) {
[17:37:34.052]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.052]                         if (muffled) 
[17:37:34.052]                           invokeRestart("muffleWarning")
[17:37:34.052]                       }
[17:37:34.052]                       else if (inherits(cond, "condition")) {
[17:37:34.052]                         if (!is.null(pattern)) {
[17:37:34.052]                           computeRestarts <- base::computeRestarts
[17:37:34.052]                           grepl <- base::grepl
[17:37:34.052]                           restarts <- computeRestarts(cond)
[17:37:34.052]                           for (restart in restarts) {
[17:37:34.052]                             name <- restart$name
[17:37:34.052]                             if (is.null(name)) 
[17:37:34.052]                               next
[17:37:34.052]                             if (!grepl(pattern, name)) 
[17:37:34.052]                               next
[17:37:34.052]                             invokeRestart(restart)
[17:37:34.052]                             muffled <- TRUE
[17:37:34.052]                             break
[17:37:34.052]                           }
[17:37:34.052]                         }
[17:37:34.052]                       }
[17:37:34.052]                       invisible(muffled)
[17:37:34.052]                     }
[17:37:34.052]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.052]                   }
[17:37:34.052]                 }
[17:37:34.052]             }
[17:37:34.052]         }))
[17:37:34.052]     }, error = function(ex) {
[17:37:34.052]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.052]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.052]                 ...future.rng), started = ...future.startTime, 
[17:37:34.052]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.052]             version = "1.8"), class = "FutureResult")
[17:37:34.052]     }, finally = {
[17:37:34.052]         if (!identical(...future.workdir, getwd())) 
[17:37:34.052]             setwd(...future.workdir)
[17:37:34.052]         {
[17:37:34.052]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.052]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.052]             }
[17:37:34.052]             base::options(...future.oldOptions)
[17:37:34.052]             if (.Platform$OS.type == "windows") {
[17:37:34.052]                 old_names <- names(...future.oldEnvVars)
[17:37:34.052]                 envs <- base::Sys.getenv()
[17:37:34.052]                 names <- names(envs)
[17:37:34.052]                 common <- intersect(names, old_names)
[17:37:34.052]                 added <- setdiff(names, old_names)
[17:37:34.052]                 removed <- setdiff(old_names, names)
[17:37:34.052]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.052]                   envs[common]]
[17:37:34.052]                 NAMES <- toupper(changed)
[17:37:34.052]                 args <- list()
[17:37:34.052]                 for (kk in seq_along(NAMES)) {
[17:37:34.052]                   name <- changed[[kk]]
[17:37:34.052]                   NAME <- NAMES[[kk]]
[17:37:34.052]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.052]                     next
[17:37:34.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.052]                 }
[17:37:34.052]                 NAMES <- toupper(added)
[17:37:34.052]                 for (kk in seq_along(NAMES)) {
[17:37:34.052]                   name <- added[[kk]]
[17:37:34.052]                   NAME <- NAMES[[kk]]
[17:37:34.052]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.052]                     next
[17:37:34.052]                   args[[name]] <- ""
[17:37:34.052]                 }
[17:37:34.052]                 NAMES <- toupper(removed)
[17:37:34.052]                 for (kk in seq_along(NAMES)) {
[17:37:34.052]                   name <- removed[[kk]]
[17:37:34.052]                   NAME <- NAMES[[kk]]
[17:37:34.052]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.052]                     next
[17:37:34.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.052]                 }
[17:37:34.052]                 if (length(args) > 0) 
[17:37:34.052]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.052]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.052]             }
[17:37:34.052]             else {
[17:37:34.052]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.052]             }
[17:37:34.052]             {
[17:37:34.052]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.052]                   0L) {
[17:37:34.052]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.052]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.052]                   base::options(opts)
[17:37:34.052]                 }
[17:37:34.052]                 {
[17:37:34.052]                   {
[17:37:34.052]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:34.052]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:34.052]                     -1786728155L), envir = base::globalenv(), 
[17:37:34.052]                       inherits = FALSE)
[17:37:34.052]                     NULL
[17:37:34.052]                   }
[17:37:34.052]                   options(future.plan = NULL)
[17:37:34.052]                   if (is.na(NA_character_)) 
[17:37:34.052]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.052]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.052]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.052]                     .init = FALSE)
[17:37:34.052]                 }
[17:37:34.052]             }
[17:37:34.052]         }
[17:37:34.052]     })
[17:37:34.052]     if (TRUE) {
[17:37:34.052]         base::sink(type = "output", split = FALSE)
[17:37:34.052]         if (TRUE) {
[17:37:34.052]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.052]         }
[17:37:34.052]         else {
[17:37:34.052]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.052]         }
[17:37:34.052]         base::close(...future.stdout)
[17:37:34.052]         ...future.stdout <- NULL
[17:37:34.052]     }
[17:37:34.052]     ...future.result$conditions <- ...future.conditions
[17:37:34.052]     ...future.result$finished <- base::Sys.time()
[17:37:34.052]     ...future.result
[17:37:34.052] }
[17:37:34.053] assign_globals() ...
[17:37:34.053] List of 5
[17:37:34.053]  $ ...future.FUN            :function (C, k)  
[17:37:34.053]  $ MoreArgs                 : NULL
[17:37:34.053]  $ ...future.elements_ii    :List of 2
[17:37:34.053]   ..$ :List of 1
[17:37:34.053]   .. ..$ : chr "C"
[17:37:34.053]   ..$ :List of 1
[17:37:34.053]   .. ..$ : int 3
[17:37:34.053]  $ ...future.seeds_ii       : NULL
[17:37:34.053]  $ ...future.globals.maxSize: NULL
[17:37:34.053]  - attr(*, "where")=List of 5
[17:37:34.053]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.053]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.053]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.053]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.053]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.053]  - attr(*, "resolved")= logi FALSE
[17:37:34.053]  - attr(*, "total_size")= num 3488
[17:37:34.053]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.053]  - attr(*, "already-done")= logi TRUE
[17:37:34.058] - reassign environment for ‘...future.FUN’
[17:37:34.058] - copied ‘...future.FUN’ to environment
[17:37:34.058] - copied ‘MoreArgs’ to environment
[17:37:34.058] - copied ‘...future.elements_ii’ to environment
[17:37:34.058] - copied ‘...future.seeds_ii’ to environment
[17:37:34.060] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.060] assign_globals() ... done
[17:37:34.060] plan(): Setting new future strategy stack:
[17:37:34.060] List of future strategies:
[17:37:34.060] 1. sequential:
[17:37:34.060]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.060]    - tweaked: FALSE
[17:37:34.060]    - call: NULL
[17:37:34.061] plan(): nbrOfWorkers() = 1
[17:37:34.062] plan(): Setting new future strategy stack:
[17:37:34.062] List of future strategies:
[17:37:34.062] 1. sequential:
[17:37:34.062]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.062]    - tweaked: FALSE
[17:37:34.062]    - call: plan(strategy)
[17:37:34.062] plan(): nbrOfWorkers() = 1
[17:37:34.062] SequentialFuture started (and completed)
[17:37:34.062] - Launch lazy future ... done
[17:37:34.062] run() for ‘SequentialFuture’ ... done
[17:37:34.063] Created future:
[17:37:34.063] SequentialFuture:
[17:37:34.063] Label: ‘future_mapply-3’
[17:37:34.063] Expression:
[17:37:34.063] {
[17:37:34.063]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.063]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.063]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.063]         on.exit(options(oopts), add = TRUE)
[17:37:34.063]     }
[17:37:34.063]     {
[17:37:34.063]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.063]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.063]         do.call(mapply, args = args)
[17:37:34.063]     }
[17:37:34.063] }
[17:37:34.063] Lazy evaluation: FALSE
[17:37:34.063] Asynchronous evaluation: FALSE
[17:37:34.063] Local evaluation: TRUE
[17:37:34.063] Environment: R_GlobalEnv
[17:37:34.063] Capture standard output: TRUE
[17:37:34.063] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.063] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.063] Packages: <none>
[17:37:34.063] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.063] Resolved: TRUE
[17:37:34.063] Value: 112 bytes of class ‘list’
[17:37:34.063] Early signaling: FALSE
[17:37:34.063] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.063] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.063] Chunk #3 of 5 ... DONE
[17:37:34.064] Chunk #4 of 5 ...
[17:37:34.064]  - Finding globals in '...' for chunk #4 ...
[17:37:34.064] getGlobalsAndPackages() ...
[17:37:34.064] Searching for globals...
[17:37:34.064] 
[17:37:34.064] Searching for globals ... DONE
[17:37:34.064] - globals: [0] <none>
[17:37:34.065] getGlobalsAndPackages() ... DONE
[17:37:34.065]    + additional globals found: [n=0] 
[17:37:34.065]    + additional namespaces needed: [n=0] 
[17:37:34.065]  - Finding globals in '...' for chunk #4 ... DONE
[17:37:34.065]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:37:34.065]  - seeds: <none>
[17:37:34.065]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.065] getGlobalsAndPackages() ...
[17:37:34.065] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.065] Resolving globals: FALSE
[17:37:34.066] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:37:34.066] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:34.066] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.067] 
[17:37:34.067] getGlobalsAndPackages() ... DONE
[17:37:34.067] run() for ‘Future’ ...
[17:37:34.067] - state: ‘created’
[17:37:34.067] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.067] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.067] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.068]   - Field: ‘label’
[17:37:34.068]   - Field: ‘local’
[17:37:34.068]   - Field: ‘owner’
[17:37:34.068]   - Field: ‘envir’
[17:37:34.068]   - Field: ‘packages’
[17:37:34.068]   - Field: ‘gc’
[17:37:34.068]   - Field: ‘conditions’
[17:37:34.068]   - Field: ‘expr’
[17:37:34.068]   - Field: ‘uuid’
[17:37:34.068]   - Field: ‘seed’
[17:37:34.068]   - Field: ‘version’
[17:37:34.069]   - Field: ‘result’
[17:37:34.069]   - Field: ‘asynchronous’
[17:37:34.069]   - Field: ‘calls’
[17:37:34.069]   - Field: ‘globals’
[17:37:34.069]   - Field: ‘stdout’
[17:37:34.069]   - Field: ‘earlySignal’
[17:37:34.069]   - Field: ‘lazy’
[17:37:34.069]   - Field: ‘state’
[17:37:34.069] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.069] - Launch lazy future ...
[17:37:34.070] Packages needed by the future expression (n = 0): <none>
[17:37:34.070] Packages needed by future strategies (n = 0): <none>
[17:37:34.070] {
[17:37:34.070]     {
[17:37:34.070]         {
[17:37:34.070]             ...future.startTime <- base::Sys.time()
[17:37:34.070]             {
[17:37:34.070]                 {
[17:37:34.070]                   {
[17:37:34.070]                     base::local({
[17:37:34.070]                       has_future <- base::requireNamespace("future", 
[17:37:34.070]                         quietly = TRUE)
[17:37:34.070]                       if (has_future) {
[17:37:34.070]                         ns <- base::getNamespace("future")
[17:37:34.070]                         version <- ns[[".package"]][["version"]]
[17:37:34.070]                         if (is.null(version)) 
[17:37:34.070]                           version <- utils::packageVersion("future")
[17:37:34.070]                       }
[17:37:34.070]                       else {
[17:37:34.070]                         version <- NULL
[17:37:34.070]                       }
[17:37:34.070]                       if (!has_future || version < "1.8.0") {
[17:37:34.070]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.070]                           "", base::R.version$version.string), 
[17:37:34.070]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:34.070]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.070]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.070]                             "release", "version")], collapse = " "), 
[17:37:34.070]                           hostname = base::Sys.info()[["nodename"]])
[17:37:34.070]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.070]                           info)
[17:37:34.070]                         info <- base::paste(info, collapse = "; ")
[17:37:34.070]                         if (!has_future) {
[17:37:34.070]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.070]                             info)
[17:37:34.070]                         }
[17:37:34.070]                         else {
[17:37:34.070]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.070]                             info, version)
[17:37:34.070]                         }
[17:37:34.070]                         base::stop(msg)
[17:37:34.070]                       }
[17:37:34.070]                     })
[17:37:34.070]                   }
[17:37:34.070]                   ...future.strategy.old <- future::plan("list")
[17:37:34.070]                   options(future.plan = NULL)
[17:37:34.070]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.070]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.070]                 }
[17:37:34.070]                 ...future.workdir <- getwd()
[17:37:34.070]             }
[17:37:34.070]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.070]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.070]         }
[17:37:34.070]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.070]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:37:34.070]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.070]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.070]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.070]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.070]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.070]             base::names(...future.oldOptions))
[17:37:34.070]     }
[17:37:34.070]     if (FALSE) {
[17:37:34.070]     }
[17:37:34.070]     else {
[17:37:34.070]         if (TRUE) {
[17:37:34.070]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.070]                 open = "w")
[17:37:34.070]         }
[17:37:34.070]         else {
[17:37:34.070]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.070]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.070]         }
[17:37:34.070]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.070]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.070]             base::sink(type = "output", split = FALSE)
[17:37:34.070]             base::close(...future.stdout)
[17:37:34.070]         }, add = TRUE)
[17:37:34.070]     }
[17:37:34.070]     ...future.frame <- base::sys.nframe()
[17:37:34.070]     ...future.conditions <- base::list()
[17:37:34.070]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.070]     if (FALSE) {
[17:37:34.070]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.070]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.070]     }
[17:37:34.070]     ...future.result <- base::tryCatch({
[17:37:34.070]         base::withCallingHandlers({
[17:37:34.070]             ...future.value <- base::withVisible(base::local({
[17:37:34.070]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.070]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.070]                   ...future.globals.maxSize)) {
[17:37:34.070]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.070]                   on.exit(options(oopts), add = TRUE)
[17:37:34.070]                 }
[17:37:34.070]                 {
[17:37:34.070]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.070]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.070]                     USE.NAMES = FALSE)
[17:37:34.070]                   do.call(mapply, args = args)
[17:37:34.070]                 }
[17:37:34.070]             }))
[17:37:34.070]             future::FutureResult(value = ...future.value$value, 
[17:37:34.070]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.070]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.070]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.070]                     ...future.globalenv.names))
[17:37:34.070]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.070]         }, condition = base::local({
[17:37:34.070]             c <- base::c
[17:37:34.070]             inherits <- base::inherits
[17:37:34.070]             invokeRestart <- base::invokeRestart
[17:37:34.070]             length <- base::length
[17:37:34.070]             list <- base::list
[17:37:34.070]             seq.int <- base::seq.int
[17:37:34.070]             signalCondition <- base::signalCondition
[17:37:34.070]             sys.calls <- base::sys.calls
[17:37:34.070]             `[[` <- base::`[[`
[17:37:34.070]             `+` <- base::`+`
[17:37:34.070]             `<<-` <- base::`<<-`
[17:37:34.070]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.070]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.070]                   3L)]
[17:37:34.070]             }
[17:37:34.070]             function(cond) {
[17:37:34.070]                 is_error <- inherits(cond, "error")
[17:37:34.070]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.070]                   NULL)
[17:37:34.070]                 if (is_error) {
[17:37:34.070]                   sessionInformation <- function() {
[17:37:34.070]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.070]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.070]                       search = base::search(), system = base::Sys.info())
[17:37:34.070]                   }
[17:37:34.070]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.070]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.070]                     cond$call), session = sessionInformation(), 
[17:37:34.070]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.070]                   signalCondition(cond)
[17:37:34.070]                 }
[17:37:34.070]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.070]                 "immediateCondition"))) {
[17:37:34.070]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.070]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.070]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.070]                   if (TRUE && !signal) {
[17:37:34.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.070]                     {
[17:37:34.070]                       inherits <- base::inherits
[17:37:34.070]                       invokeRestart <- base::invokeRestart
[17:37:34.070]                       is.null <- base::is.null
[17:37:34.070]                       muffled <- FALSE
[17:37:34.070]                       if (inherits(cond, "message")) {
[17:37:34.070]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.070]                         if (muffled) 
[17:37:34.070]                           invokeRestart("muffleMessage")
[17:37:34.070]                       }
[17:37:34.070]                       else if (inherits(cond, "warning")) {
[17:37:34.070]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.070]                         if (muffled) 
[17:37:34.070]                           invokeRestart("muffleWarning")
[17:37:34.070]                       }
[17:37:34.070]                       else if (inherits(cond, "condition")) {
[17:37:34.070]                         if (!is.null(pattern)) {
[17:37:34.070]                           computeRestarts <- base::computeRestarts
[17:37:34.070]                           grepl <- base::grepl
[17:37:34.070]                           restarts <- computeRestarts(cond)
[17:37:34.070]                           for (restart in restarts) {
[17:37:34.070]                             name <- restart$name
[17:37:34.070]                             if (is.null(name)) 
[17:37:34.070]                               next
[17:37:34.070]                             if (!grepl(pattern, name)) 
[17:37:34.070]                               next
[17:37:34.070]                             invokeRestart(restart)
[17:37:34.070]                             muffled <- TRUE
[17:37:34.070]                             break
[17:37:34.070]                           }
[17:37:34.070]                         }
[17:37:34.070]                       }
[17:37:34.070]                       invisible(muffled)
[17:37:34.070]                     }
[17:37:34.070]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.070]                   }
[17:37:34.070]                 }
[17:37:34.070]                 else {
[17:37:34.070]                   if (TRUE) {
[17:37:34.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.070]                     {
[17:37:34.070]                       inherits <- base::inherits
[17:37:34.070]                       invokeRestart <- base::invokeRestart
[17:37:34.070]                       is.null <- base::is.null
[17:37:34.070]                       muffled <- FALSE
[17:37:34.070]                       if (inherits(cond, "message")) {
[17:37:34.070]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.070]                         if (muffled) 
[17:37:34.070]                           invokeRestart("muffleMessage")
[17:37:34.070]                       }
[17:37:34.070]                       else if (inherits(cond, "warning")) {
[17:37:34.070]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.070]                         if (muffled) 
[17:37:34.070]                           invokeRestart("muffleWarning")
[17:37:34.070]                       }
[17:37:34.070]                       else if (inherits(cond, "condition")) {
[17:37:34.070]                         if (!is.null(pattern)) {
[17:37:34.070]                           computeRestarts <- base::computeRestarts
[17:37:34.070]                           grepl <- base::grepl
[17:37:34.070]                           restarts <- computeRestarts(cond)
[17:37:34.070]                           for (restart in restarts) {
[17:37:34.070]                             name <- restart$name
[17:37:34.070]                             if (is.null(name)) 
[17:37:34.070]                               next
[17:37:34.070]                             if (!grepl(pattern, name)) 
[17:37:34.070]                               next
[17:37:34.070]                             invokeRestart(restart)
[17:37:34.070]                             muffled <- TRUE
[17:37:34.070]                             break
[17:37:34.070]                           }
[17:37:34.070]                         }
[17:37:34.070]                       }
[17:37:34.070]                       invisible(muffled)
[17:37:34.070]                     }
[17:37:34.070]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.070]                   }
[17:37:34.070]                 }
[17:37:34.070]             }
[17:37:34.070]         }))
[17:37:34.070]     }, error = function(ex) {
[17:37:34.070]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.070]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.070]                 ...future.rng), started = ...future.startTime, 
[17:37:34.070]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.070]             version = "1.8"), class = "FutureResult")
[17:37:34.070]     }, finally = {
[17:37:34.070]         if (!identical(...future.workdir, getwd())) 
[17:37:34.070]             setwd(...future.workdir)
[17:37:34.070]         {
[17:37:34.070]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.070]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.070]             }
[17:37:34.070]             base::options(...future.oldOptions)
[17:37:34.070]             if (.Platform$OS.type == "windows") {
[17:37:34.070]                 old_names <- names(...future.oldEnvVars)
[17:37:34.070]                 envs <- base::Sys.getenv()
[17:37:34.070]                 names <- names(envs)
[17:37:34.070]                 common <- intersect(names, old_names)
[17:37:34.070]                 added <- setdiff(names, old_names)
[17:37:34.070]                 removed <- setdiff(old_names, names)
[17:37:34.070]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.070]                   envs[common]]
[17:37:34.070]                 NAMES <- toupper(changed)
[17:37:34.070]                 args <- list()
[17:37:34.070]                 for (kk in seq_along(NAMES)) {
[17:37:34.070]                   name <- changed[[kk]]
[17:37:34.070]                   NAME <- NAMES[[kk]]
[17:37:34.070]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.070]                     next
[17:37:34.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.070]                 }
[17:37:34.070]                 NAMES <- toupper(added)
[17:37:34.070]                 for (kk in seq_along(NAMES)) {
[17:37:34.070]                   name <- added[[kk]]
[17:37:34.070]                   NAME <- NAMES[[kk]]
[17:37:34.070]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.070]                     next
[17:37:34.070]                   args[[name]] <- ""
[17:37:34.070]                 }
[17:37:34.070]                 NAMES <- toupper(removed)
[17:37:34.070]                 for (kk in seq_along(NAMES)) {
[17:37:34.070]                   name <- removed[[kk]]
[17:37:34.070]                   NAME <- NAMES[[kk]]
[17:37:34.070]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.070]                     next
[17:37:34.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.070]                 }
[17:37:34.070]                 if (length(args) > 0) 
[17:37:34.070]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.070]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.070]             }
[17:37:34.070]             else {
[17:37:34.070]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.070]             }
[17:37:34.070]             {
[17:37:34.070]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.070]                   0L) {
[17:37:34.070]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.070]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.070]                   base::options(opts)
[17:37:34.070]                 }
[17:37:34.070]                 {
[17:37:34.070]                   {
[17:37:34.070]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:34.070]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:34.070]                     -1786728155L), envir = base::globalenv(), 
[17:37:34.070]                       inherits = FALSE)
[17:37:34.070]                     NULL
[17:37:34.070]                   }
[17:37:34.070]                   options(future.plan = NULL)
[17:37:34.070]                   if (is.na(NA_character_)) 
[17:37:34.070]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.070]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.070]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.070]                     .init = FALSE)
[17:37:34.070]                 }
[17:37:34.070]             }
[17:37:34.070]         }
[17:37:34.070]     })
[17:37:34.070]     if (TRUE) {
[17:37:34.070]         base::sink(type = "output", split = FALSE)
[17:37:34.070]         if (TRUE) {
[17:37:34.070]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.070]         }
[17:37:34.070]         else {
[17:37:34.070]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.070]         }
[17:37:34.070]         base::close(...future.stdout)
[17:37:34.070]         ...future.stdout <- NULL
[17:37:34.070]     }
[17:37:34.070]     ...future.result$conditions <- ...future.conditions
[17:37:34.070]     ...future.result$finished <- base::Sys.time()
[17:37:34.070]     ...future.result
[17:37:34.070] }
[17:37:34.072] assign_globals() ...
[17:37:34.072] List of 5
[17:37:34.072]  $ ...future.FUN            :function (C, k)  
[17:37:34.072]  $ MoreArgs                 : NULL
[17:37:34.072]  $ ...future.elements_ii    :List of 2
[17:37:34.072]   ..$ :List of 1
[17:37:34.072]   .. ..$ : chr "D"
[17:37:34.072]   ..$ :List of 1
[17:37:34.072]   .. ..$ : int 2
[17:37:34.072]  $ ...future.seeds_ii       : NULL
[17:37:34.072]  $ ...future.globals.maxSize: NULL
[17:37:34.072]  - attr(*, "where")=List of 5
[17:37:34.072]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.072]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.072]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.072]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.072]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.072]  - attr(*, "resolved")= logi FALSE
[17:37:34.072]  - attr(*, "total_size")= num 3488
[17:37:34.072]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.072]  - attr(*, "already-done")= logi TRUE
[17:37:34.077] - reassign environment for ‘...future.FUN’
[17:37:34.077] - copied ‘...future.FUN’ to environment
[17:37:34.077] - copied ‘MoreArgs’ to environment
[17:37:34.077] - copied ‘...future.elements_ii’ to environment
[17:37:34.077] - copied ‘...future.seeds_ii’ to environment
[17:37:34.077] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.077] assign_globals() ... done
[17:37:34.077] plan(): Setting new future strategy stack:
[17:37:34.077] List of future strategies:
[17:37:34.077] 1. sequential:
[17:37:34.077]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.077]    - tweaked: FALSE
[17:37:34.077]    - call: NULL
[17:37:34.078] plan(): nbrOfWorkers() = 1
[17:37:34.079] plan(): Setting new future strategy stack:
[17:37:34.079] List of future strategies:
[17:37:34.079] 1. sequential:
[17:37:34.079]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.079]    - tweaked: FALSE
[17:37:34.079]    - call: plan(strategy)
[17:37:34.079] plan(): nbrOfWorkers() = 1
[17:37:34.079] SequentialFuture started (and completed)
[17:37:34.079] - Launch lazy future ... done
[17:37:34.080] run() for ‘SequentialFuture’ ... done
[17:37:34.080] Created future:
[17:37:34.080] SequentialFuture:
[17:37:34.080] Label: ‘future_mapply-4’
[17:37:34.080] Expression:
[17:37:34.080] {
[17:37:34.080]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.080]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.080]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.080]         on.exit(options(oopts), add = TRUE)
[17:37:34.080]     }
[17:37:34.080]     {
[17:37:34.080]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.080]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.080]         do.call(mapply, args = args)
[17:37:34.080]     }
[17:37:34.080] }
[17:37:34.080] Lazy evaluation: FALSE
[17:37:34.080] Asynchronous evaluation: FALSE
[17:37:34.080] Local evaluation: TRUE
[17:37:34.080] Environment: R_GlobalEnv
[17:37:34.080] Capture standard output: TRUE
[17:37:34.080] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.080] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.080] Packages: <none>
[17:37:34.080] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.080] Resolved: TRUE
[17:37:34.080] Value: 112 bytes of class ‘list’
[17:37:34.080] Early signaling: FALSE
[17:37:34.080] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.080] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.081] Chunk #4 of 5 ... DONE
[17:37:34.081] Chunk #5 of 5 ...
[17:37:34.081]  - Finding globals in '...' for chunk #5 ...
[17:37:34.081] getGlobalsAndPackages() ...
[17:37:34.081] Searching for globals...
[17:37:34.081] 
[17:37:34.081] Searching for globals ... DONE
[17:37:34.082] - globals: [0] <none>
[17:37:34.082] getGlobalsAndPackages() ... DONE
[17:37:34.082]    + additional globals found: [n=0] 
[17:37:34.082]    + additional namespaces needed: [n=0] 
[17:37:34.082]  - Finding globals in '...' for chunk #5 ... DONE
[17:37:34.082]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:37:34.082]  - seeds: <none>
[17:37:34.082]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.082] getGlobalsAndPackages() ...
[17:37:34.082] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.083] Resolving globals: FALSE
[17:37:34.083] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:37:34.083] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:34.115] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.115] 
[17:37:34.115] getGlobalsAndPackages() ... DONE
[17:37:34.116] run() for ‘Future’ ...
[17:37:34.116] - state: ‘created’
[17:37:34.116] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.116] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.116] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.116]   - Field: ‘label’
[17:37:34.117]   - Field: ‘local’
[17:37:34.117]   - Field: ‘owner’
[17:37:34.117]   - Field: ‘envir’
[17:37:34.117]   - Field: ‘packages’
[17:37:34.117]   - Field: ‘gc’
[17:37:34.117]   - Field: ‘conditions’
[17:37:34.117]   - Field: ‘expr’
[17:37:34.117]   - Field: ‘uuid’
[17:37:34.118]   - Field: ‘seed’
[17:37:34.118]   - Field: ‘version’
[17:37:34.118]   - Field: ‘result’
[17:37:34.118]   - Field: ‘asynchronous’
[17:37:34.118]   - Field: ‘calls’
[17:37:34.118]   - Field: ‘globals’
[17:37:34.118]   - Field: ‘stdout’
[17:37:34.118]   - Field: ‘earlySignal’
[17:37:34.118]   - Field: ‘lazy’
[17:37:34.118]   - Field: ‘state’
[17:37:34.118] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.119] - Launch lazy future ...
[17:37:34.119] Packages needed by the future expression (n = 0): <none>
[17:37:34.119] Packages needed by future strategies (n = 0): <none>
[17:37:34.119] {
[17:37:34.119]     {
[17:37:34.119]         {
[17:37:34.119]             ...future.startTime <- base::Sys.time()
[17:37:34.119]             {
[17:37:34.119]                 {
[17:37:34.119]                   {
[17:37:34.119]                     base::local({
[17:37:34.119]                       has_future <- base::requireNamespace("future", 
[17:37:34.119]                         quietly = TRUE)
[17:37:34.119]                       if (has_future) {
[17:37:34.119]                         ns <- base::getNamespace("future")
[17:37:34.119]                         version <- ns[[".package"]][["version"]]
[17:37:34.119]                         if (is.null(version)) 
[17:37:34.119]                           version <- utils::packageVersion("future")
[17:37:34.119]                       }
[17:37:34.119]                       else {
[17:37:34.119]                         version <- NULL
[17:37:34.119]                       }
[17:37:34.119]                       if (!has_future || version < "1.8.0") {
[17:37:34.119]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.119]                           "", base::R.version$version.string), 
[17:37:34.119]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:34.119]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.119]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.119]                             "release", "version")], collapse = " "), 
[17:37:34.119]                           hostname = base::Sys.info()[["nodename"]])
[17:37:34.119]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.119]                           info)
[17:37:34.119]                         info <- base::paste(info, collapse = "; ")
[17:37:34.119]                         if (!has_future) {
[17:37:34.119]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.119]                             info)
[17:37:34.119]                         }
[17:37:34.119]                         else {
[17:37:34.119]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.119]                             info, version)
[17:37:34.119]                         }
[17:37:34.119]                         base::stop(msg)
[17:37:34.119]                       }
[17:37:34.119]                     })
[17:37:34.119]                   }
[17:37:34.119]                   ...future.strategy.old <- future::plan("list")
[17:37:34.119]                   options(future.plan = NULL)
[17:37:34.119]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.119]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.119]                 }
[17:37:34.119]                 ...future.workdir <- getwd()
[17:37:34.119]             }
[17:37:34.119]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.119]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.119]         }
[17:37:34.119]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.119]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:37:34.119]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.119]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.119]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.119]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.119]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.119]             base::names(...future.oldOptions))
[17:37:34.119]     }
[17:37:34.119]     if (FALSE) {
[17:37:34.119]     }
[17:37:34.119]     else {
[17:37:34.119]         if (TRUE) {
[17:37:34.119]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.119]                 open = "w")
[17:37:34.119]         }
[17:37:34.119]         else {
[17:37:34.119]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.119]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.119]         }
[17:37:34.119]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.119]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.119]             base::sink(type = "output", split = FALSE)
[17:37:34.119]             base::close(...future.stdout)
[17:37:34.119]         }, add = TRUE)
[17:37:34.119]     }
[17:37:34.119]     ...future.frame <- base::sys.nframe()
[17:37:34.119]     ...future.conditions <- base::list()
[17:37:34.119]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.119]     if (FALSE) {
[17:37:34.119]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.119]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.119]     }
[17:37:34.119]     ...future.result <- base::tryCatch({
[17:37:34.119]         base::withCallingHandlers({
[17:37:34.119]             ...future.value <- base::withVisible(base::local({
[17:37:34.119]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.119]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.119]                   ...future.globals.maxSize)) {
[17:37:34.119]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.119]                   on.exit(options(oopts), add = TRUE)
[17:37:34.119]                 }
[17:37:34.119]                 {
[17:37:34.119]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.119]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.119]                     USE.NAMES = FALSE)
[17:37:34.119]                   do.call(mapply, args = args)
[17:37:34.119]                 }
[17:37:34.119]             }))
[17:37:34.119]             future::FutureResult(value = ...future.value$value, 
[17:37:34.119]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.119]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.119]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.119]                     ...future.globalenv.names))
[17:37:34.119]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.119]         }, condition = base::local({
[17:37:34.119]             c <- base::c
[17:37:34.119]             inherits <- base::inherits
[17:37:34.119]             invokeRestart <- base::invokeRestart
[17:37:34.119]             length <- base::length
[17:37:34.119]             list <- base::list
[17:37:34.119]             seq.int <- base::seq.int
[17:37:34.119]             signalCondition <- base::signalCondition
[17:37:34.119]             sys.calls <- base::sys.calls
[17:37:34.119]             `[[` <- base::`[[`
[17:37:34.119]             `+` <- base::`+`
[17:37:34.119]             `<<-` <- base::`<<-`
[17:37:34.119]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.119]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.119]                   3L)]
[17:37:34.119]             }
[17:37:34.119]             function(cond) {
[17:37:34.119]                 is_error <- inherits(cond, "error")
[17:37:34.119]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.119]                   NULL)
[17:37:34.119]                 if (is_error) {
[17:37:34.119]                   sessionInformation <- function() {
[17:37:34.119]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.119]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.119]                       search = base::search(), system = base::Sys.info())
[17:37:34.119]                   }
[17:37:34.119]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.119]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.119]                     cond$call), session = sessionInformation(), 
[17:37:34.119]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.119]                   signalCondition(cond)
[17:37:34.119]                 }
[17:37:34.119]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.119]                 "immediateCondition"))) {
[17:37:34.119]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.119]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.119]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.119]                   if (TRUE && !signal) {
[17:37:34.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.119]                     {
[17:37:34.119]                       inherits <- base::inherits
[17:37:34.119]                       invokeRestart <- base::invokeRestart
[17:37:34.119]                       is.null <- base::is.null
[17:37:34.119]                       muffled <- FALSE
[17:37:34.119]                       if (inherits(cond, "message")) {
[17:37:34.119]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.119]                         if (muffled) 
[17:37:34.119]                           invokeRestart("muffleMessage")
[17:37:34.119]                       }
[17:37:34.119]                       else if (inherits(cond, "warning")) {
[17:37:34.119]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.119]                         if (muffled) 
[17:37:34.119]                           invokeRestart("muffleWarning")
[17:37:34.119]                       }
[17:37:34.119]                       else if (inherits(cond, "condition")) {
[17:37:34.119]                         if (!is.null(pattern)) {
[17:37:34.119]                           computeRestarts <- base::computeRestarts
[17:37:34.119]                           grepl <- base::grepl
[17:37:34.119]                           restarts <- computeRestarts(cond)
[17:37:34.119]                           for (restart in restarts) {
[17:37:34.119]                             name <- restart$name
[17:37:34.119]                             if (is.null(name)) 
[17:37:34.119]                               next
[17:37:34.119]                             if (!grepl(pattern, name)) 
[17:37:34.119]                               next
[17:37:34.119]                             invokeRestart(restart)
[17:37:34.119]                             muffled <- TRUE
[17:37:34.119]                             break
[17:37:34.119]                           }
[17:37:34.119]                         }
[17:37:34.119]                       }
[17:37:34.119]                       invisible(muffled)
[17:37:34.119]                     }
[17:37:34.119]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.119]                   }
[17:37:34.119]                 }
[17:37:34.119]                 else {
[17:37:34.119]                   if (TRUE) {
[17:37:34.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.119]                     {
[17:37:34.119]                       inherits <- base::inherits
[17:37:34.119]                       invokeRestart <- base::invokeRestart
[17:37:34.119]                       is.null <- base::is.null
[17:37:34.119]                       muffled <- FALSE
[17:37:34.119]                       if (inherits(cond, "message")) {
[17:37:34.119]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.119]                         if (muffled) 
[17:37:34.119]                           invokeRestart("muffleMessage")
[17:37:34.119]                       }
[17:37:34.119]                       else if (inherits(cond, "warning")) {
[17:37:34.119]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.119]                         if (muffled) 
[17:37:34.119]                           invokeRestart("muffleWarning")
[17:37:34.119]                       }
[17:37:34.119]                       else if (inherits(cond, "condition")) {
[17:37:34.119]                         if (!is.null(pattern)) {
[17:37:34.119]                           computeRestarts <- base::computeRestarts
[17:37:34.119]                           grepl <- base::grepl
[17:37:34.119]                           restarts <- computeRestarts(cond)
[17:37:34.119]                           for (restart in restarts) {
[17:37:34.119]                             name <- restart$name
[17:37:34.119]                             if (is.null(name)) 
[17:37:34.119]                               next
[17:37:34.119]                             if (!grepl(pattern, name)) 
[17:37:34.119]                               next
[17:37:34.119]                             invokeRestart(restart)
[17:37:34.119]                             muffled <- TRUE
[17:37:34.119]                             break
[17:37:34.119]                           }
[17:37:34.119]                         }
[17:37:34.119]                       }
[17:37:34.119]                       invisible(muffled)
[17:37:34.119]                     }
[17:37:34.119]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.119]                   }
[17:37:34.119]                 }
[17:37:34.119]             }
[17:37:34.119]         }))
[17:37:34.119]     }, error = function(ex) {
[17:37:34.119]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.119]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.119]                 ...future.rng), started = ...future.startTime, 
[17:37:34.119]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.119]             version = "1.8"), class = "FutureResult")
[17:37:34.119]     }, finally = {
[17:37:34.119]         if (!identical(...future.workdir, getwd())) 
[17:37:34.119]             setwd(...future.workdir)
[17:37:34.119]         {
[17:37:34.119]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.119]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.119]             }
[17:37:34.119]             base::options(...future.oldOptions)
[17:37:34.119]             if (.Platform$OS.type == "windows") {
[17:37:34.119]                 old_names <- names(...future.oldEnvVars)
[17:37:34.119]                 envs <- base::Sys.getenv()
[17:37:34.119]                 names <- names(envs)
[17:37:34.119]                 common <- intersect(names, old_names)
[17:37:34.119]                 added <- setdiff(names, old_names)
[17:37:34.119]                 removed <- setdiff(old_names, names)
[17:37:34.119]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.119]                   envs[common]]
[17:37:34.119]                 NAMES <- toupper(changed)
[17:37:34.119]                 args <- list()
[17:37:34.119]                 for (kk in seq_along(NAMES)) {
[17:37:34.119]                   name <- changed[[kk]]
[17:37:34.119]                   NAME <- NAMES[[kk]]
[17:37:34.119]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.119]                     next
[17:37:34.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.119]                 }
[17:37:34.119]                 NAMES <- toupper(added)
[17:37:34.119]                 for (kk in seq_along(NAMES)) {
[17:37:34.119]                   name <- added[[kk]]
[17:37:34.119]                   NAME <- NAMES[[kk]]
[17:37:34.119]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.119]                     next
[17:37:34.119]                   args[[name]] <- ""
[17:37:34.119]                 }
[17:37:34.119]                 NAMES <- toupper(removed)
[17:37:34.119]                 for (kk in seq_along(NAMES)) {
[17:37:34.119]                   name <- removed[[kk]]
[17:37:34.119]                   NAME <- NAMES[[kk]]
[17:37:34.119]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.119]                     next
[17:37:34.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.119]                 }
[17:37:34.119]                 if (length(args) > 0) 
[17:37:34.119]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.119]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.119]             }
[17:37:34.119]             else {
[17:37:34.119]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.119]             }
[17:37:34.119]             {
[17:37:34.119]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.119]                   0L) {
[17:37:34.119]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.119]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.119]                   base::options(opts)
[17:37:34.119]                 }
[17:37:34.119]                 {
[17:37:34.119]                   {
[17:37:34.119]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:34.119]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:34.119]                     -1786728155L), envir = base::globalenv(), 
[17:37:34.119]                       inherits = FALSE)
[17:37:34.119]                     NULL
[17:37:34.119]                   }
[17:37:34.119]                   options(future.plan = NULL)
[17:37:34.119]                   if (is.na(NA_character_)) 
[17:37:34.119]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.119]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.119]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.119]                     .init = FALSE)
[17:37:34.119]                 }
[17:37:34.119]             }
[17:37:34.119]         }
[17:37:34.119]     })
[17:37:34.119]     if (TRUE) {
[17:37:34.119]         base::sink(type = "output", split = FALSE)
[17:37:34.119]         if (TRUE) {
[17:37:34.119]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.119]         }
[17:37:34.119]         else {
[17:37:34.119]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.119]         }
[17:37:34.119]         base::close(...future.stdout)
[17:37:34.119]         ...future.stdout <- NULL
[17:37:34.119]     }
[17:37:34.119]     ...future.result$conditions <- ...future.conditions
[17:37:34.119]     ...future.result$finished <- base::Sys.time()
[17:37:34.119]     ...future.result
[17:37:34.119] }
[17:37:34.121] assign_globals() ...
[17:37:34.121] List of 5
[17:37:34.121]  $ ...future.FUN            :function (C, k)  
[17:37:34.121]  $ MoreArgs                 : NULL
[17:37:34.121]  $ ...future.elements_ii    :List of 2
[17:37:34.121]   ..$ :List of 1
[17:37:34.121]   .. ..$ : chr "E"
[17:37:34.121]   ..$ :List of 1
[17:37:34.121]   .. ..$ : int 1
[17:37:34.121]  $ ...future.seeds_ii       : NULL
[17:37:34.121]  $ ...future.globals.maxSize: NULL
[17:37:34.121]  - attr(*, "where")=List of 5
[17:37:34.121]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.121]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.121]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.121]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.121]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.121]  - attr(*, "resolved")= logi FALSE
[17:37:34.121]  - attr(*, "total_size")= num 3488
[17:37:34.121]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.121]  - attr(*, "already-done")= logi TRUE
[17:37:34.126] - reassign environment for ‘...future.FUN’
[17:37:34.126] - copied ‘...future.FUN’ to environment
[17:37:34.126] - copied ‘MoreArgs’ to environment
[17:37:34.126] - copied ‘...future.elements_ii’ to environment
[17:37:34.126] - copied ‘...future.seeds_ii’ to environment
[17:37:34.126] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.126] assign_globals() ... done
[17:37:34.127] plan(): Setting new future strategy stack:
[17:37:34.127] List of future strategies:
[17:37:34.127] 1. sequential:
[17:37:34.127]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.127]    - tweaked: FALSE
[17:37:34.127]    - call: NULL
[17:37:34.127] plan(): nbrOfWorkers() = 1
[17:37:34.128] plan(): Setting new future strategy stack:
[17:37:34.128] List of future strategies:
[17:37:34.128] 1. sequential:
[17:37:34.128]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.128]    - tweaked: FALSE
[17:37:34.128]    - call: plan(strategy)
[17:37:34.129] plan(): nbrOfWorkers() = 1
[17:37:34.129] SequentialFuture started (and completed)
[17:37:34.129] - Launch lazy future ... done
[17:37:34.129] run() for ‘SequentialFuture’ ... done
[17:37:34.129] Created future:
[17:37:34.129] SequentialFuture:
[17:37:34.129] Label: ‘future_mapply-5’
[17:37:34.129] Expression:
[17:37:34.129] {
[17:37:34.129]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.129]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.129]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.129]         on.exit(options(oopts), add = TRUE)
[17:37:34.129]     }
[17:37:34.129]     {
[17:37:34.129]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.129]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.129]         do.call(mapply, args = args)
[17:37:34.129]     }
[17:37:34.129] }
[17:37:34.129] Lazy evaluation: FALSE
[17:37:34.129] Asynchronous evaluation: FALSE
[17:37:34.129] Local evaluation: TRUE
[17:37:34.129] Environment: R_GlobalEnv
[17:37:34.129] Capture standard output: TRUE
[17:37:34.129] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.129] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.129] Packages: <none>
[17:37:34.129] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.129] Resolved: TRUE
[17:37:34.129] Value: 112 bytes of class ‘list’
[17:37:34.129] Early signaling: FALSE
[17:37:34.129] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.129] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.130] Chunk #5 of 5 ... DONE
[17:37:34.130] Launching 5 futures (chunks) ... DONE
[17:37:34.130] Resolving 5 futures (chunks) ...
[17:37:34.130] resolve() on list ...
[17:37:34.130]  recursive: 0
[17:37:34.130]  length: 5
[17:37:34.131] 
[17:37:34.131] resolved() for ‘SequentialFuture’ ...
[17:37:34.131] - state: ‘finished’
[17:37:34.131] - run: TRUE
[17:37:34.131] - result: ‘FutureResult’
[17:37:34.131] resolved() for ‘SequentialFuture’ ... done
[17:37:34.131] Future #1
[17:37:34.131] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:34.131] - nx: 5
[17:37:34.131] - relay: TRUE
[17:37:34.132] - stdout: TRUE
[17:37:34.132] - signal: TRUE
[17:37:34.132] - resignal: FALSE
[17:37:34.132] - force: TRUE
[17:37:34.132] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[17:37:34.132] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[17:37:34.132]  - until=1
[17:37:34.132]  - relaying element #1
[17:37:34.132] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:37:34.132] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:37:34.133] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:34.133]  length: 4 (resolved future 1)
[17:37:34.133] resolved() for ‘SequentialFuture’ ...
[17:37:34.133] - state: ‘finished’
[17:37:34.133] - run: TRUE
[17:37:34.133] - result: ‘FutureResult’
[17:37:34.133] resolved() for ‘SequentialFuture’ ... done
[17:37:34.133] Future #2
[17:37:34.133] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:37:34.133] - nx: 5
[17:37:34.134] - relay: TRUE
[17:37:34.134] - stdout: TRUE
[17:37:34.134] - signal: TRUE
[17:37:34.134] - resignal: FALSE
[17:37:34.134] - force: TRUE
[17:37:34.134] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:37:34.134] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:37:34.134]  - until=2
[17:37:34.134]  - relaying element #2
[17:37:34.134] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:37:34.135] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:37:34.135] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:37:34.135]  length: 3 (resolved future 2)
[17:37:34.135] resolved() for ‘SequentialFuture’ ...
[17:37:34.135] - state: ‘finished’
[17:37:34.135] - run: TRUE
[17:37:34.135] - result: ‘FutureResult’
[17:37:34.135] resolved() for ‘SequentialFuture’ ... done
[17:37:34.135] Future #3
[17:37:34.135] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:37:34.135] - nx: 5
[17:37:34.136] - relay: TRUE
[17:37:34.136] - stdout: TRUE
[17:37:34.136] - signal: TRUE
[17:37:34.136] - resignal: FALSE
[17:37:34.136] - force: TRUE
[17:37:34.136] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:37:34.136] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:37:34.136]  - until=3
[17:37:34.136]  - relaying element #3
[17:37:34.136] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:37:34.137] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:37:34.137] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:37:34.137]  length: 2 (resolved future 3)
[17:37:34.137] resolved() for ‘SequentialFuture’ ...
[17:37:34.137] - state: ‘finished’
[17:37:34.137] - run: TRUE
[17:37:34.137] - result: ‘FutureResult’
[17:37:34.137] resolved() for ‘SequentialFuture’ ... done
[17:37:34.137] Future #4
[17:37:34.138] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:37:34.138] - nx: 5
[17:37:34.138] - relay: TRUE
[17:37:34.138] - stdout: TRUE
[17:37:34.138] - signal: TRUE
[17:37:34.138] - resignal: FALSE
[17:37:34.138] - force: TRUE
[17:37:34.138] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:37:34.138] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:37:34.138]  - until=4
[17:37:34.138]  - relaying element #4
[17:37:34.139] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:37:34.139] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:37:34.139] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:37:34.139]  length: 1 (resolved future 4)
[17:37:34.139] resolved() for ‘SequentialFuture’ ...
[17:37:34.139] - state: ‘finished’
[17:37:34.139] - run: TRUE
[17:37:34.139] - result: ‘FutureResult’
[17:37:34.139] resolved() for ‘SequentialFuture’ ... done
[17:37:34.139] Future #5
[17:37:34.140] signalConditionsASAP(SequentialFuture, pos=5) ...
[17:37:34.140] - nx: 5
[17:37:34.140] - relay: TRUE
[17:37:34.140] - stdout: TRUE
[17:37:34.140] - signal: TRUE
[17:37:34.140] - resignal: FALSE
[17:37:34.140] - force: TRUE
[17:37:34.140] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:37:34.140] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:37:34.140]  - until=5
[17:37:34.140]  - relaying element #5
[17:37:34.141] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:37:34.141] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:37:34.142] signalConditionsASAP(SequentialFuture, pos=5) ... done
[17:37:34.142]  length: 0 (resolved future 5)
[17:37:34.142] Relaying remaining futures
[17:37:34.142] signalConditionsASAP(NULL, pos=0) ...
[17:37:34.142] - nx: 5
[17:37:34.142] - relay: TRUE
[17:37:34.142] - stdout: TRUE
[17:37:34.143] - signal: TRUE
[17:37:34.143] - resignal: FALSE
[17:37:34.143] - force: TRUE
[17:37:34.143] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:37:34.143] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[17:37:34.143] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:37:34.143] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:37:34.143] signalConditionsASAP(NULL, pos=0) ... done
[17:37:34.143] resolve() on list ... DONE
[17:37:34.144]  - Number of value chunks collected: 5
[17:37:34.144] Resolving 5 futures (chunks) ... DONE
[17:37:34.144] Reducing values from 5 chunks ...
[17:37:34.144]  - Number of values collected after concatenation: 5
[17:37:34.144]  - Number of values expected: 5
[17:37:34.144] Reducing values from 5 chunks ... DONE
[17:37:34.144] future_mapply() ... DONE
[17:37:34.145] future_mapply() ...
[17:37:34.145] Number of chunks: 1
[17:37:34.145] getGlobalsAndPackagesXApply() ...
[17:37:34.145]  - future.globals: TRUE
[17:37:34.145] getGlobalsAndPackages() ...
[17:37:34.145] Searching for globals...
[17:37:34.146] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:37:34.146] Searching for globals ... DONE
[17:37:34.147] Resolving globals: FALSE
[17:37:34.147] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:37:34.147] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:37:34.147] - globals: [1] ‘FUN’
[17:37:34.148] 
[17:37:34.148] getGlobalsAndPackages() ... DONE
[17:37:34.148]  - globals found/used: [n=1] ‘FUN’
[17:37:34.148]  - needed namespaces: [n=0] 
[17:37:34.148] Finding globals ... DONE
[17:37:34.148] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:34.148] List of 2
[17:37:34.148]  $ ...future.FUN:function (C, k)  
[17:37:34.148]  $ MoreArgs     : list()
[17:37:34.148]  - attr(*, "where")=List of 2
[17:37:34.148]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:34.148]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:34.148]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.148]  - attr(*, "resolved")= logi FALSE
[17:37:34.148]  - attr(*, "total_size")= num NA
[17:37:34.151] Packages to be attached in all futures: [n=0] 
[17:37:34.151] getGlobalsAndPackagesXApply() ... DONE
[17:37:34.151] Number of futures (= number of chunks): 1
[17:37:34.151] Launching 1 futures (chunks) ...
[17:37:34.151] Chunk #1 of 1 ...
[17:37:34.151]  - Finding globals in '...' for chunk #1 ...
[17:37:34.151] getGlobalsAndPackages() ...
[17:37:34.151] Searching for globals...
[17:37:34.152] 
[17:37:34.152] Searching for globals ... DONE
[17:37:34.152] - globals: [0] <none>
[17:37:34.152] getGlobalsAndPackages() ... DONE
[17:37:34.152]    + additional globals found: [n=0] 
[17:37:34.152]    + additional namespaces needed: [n=0] 
[17:37:34.152]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:34.152]  - seeds: <none>
[17:37:34.152]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.153] getGlobalsAndPackages() ...
[17:37:34.153] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.153] Resolving globals: FALSE
[17:37:34.153] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[17:37:34.154] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:34.154] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.154] 
[17:37:34.154] getGlobalsAndPackages() ... DONE
[17:37:34.154] run() for ‘Future’ ...
[17:37:34.154] - state: ‘created’
[17:37:34.154] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.155] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.155] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.155]   - Field: ‘label’
[17:37:34.155]   - Field: ‘local’
[17:37:34.155]   - Field: ‘owner’
[17:37:34.155]   - Field: ‘envir’
[17:37:34.155]   - Field: ‘packages’
[17:37:34.155]   - Field: ‘gc’
[17:37:34.155]   - Field: ‘conditions’
[17:37:34.156]   - Field: ‘expr’
[17:37:34.156]   - Field: ‘uuid’
[17:37:34.156]   - Field: ‘seed’
[17:37:34.156]   - Field: ‘version’
[17:37:34.156]   - Field: ‘result’
[17:37:34.156]   - Field: ‘asynchronous’
[17:37:34.156]   - Field: ‘calls’
[17:37:34.156]   - Field: ‘globals’
[17:37:34.156]   - Field: ‘stdout’
[17:37:34.156]   - Field: ‘earlySignal’
[17:37:34.157]   - Field: ‘lazy’
[17:37:34.157]   - Field: ‘state’
[17:37:34.157] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.157] - Launch lazy future ...
[17:37:34.157] Packages needed by the future expression (n = 0): <none>
[17:37:34.157] Packages needed by future strategies (n = 0): <none>
[17:37:34.158] {
[17:37:34.158]     {
[17:37:34.158]         {
[17:37:34.158]             ...future.startTime <- base::Sys.time()
[17:37:34.158]             {
[17:37:34.158]                 {
[17:37:34.158]                   {
[17:37:34.158]                     base::local({
[17:37:34.158]                       has_future <- base::requireNamespace("future", 
[17:37:34.158]                         quietly = TRUE)
[17:37:34.158]                       if (has_future) {
[17:37:34.158]                         ns <- base::getNamespace("future")
[17:37:34.158]                         version <- ns[[".package"]][["version"]]
[17:37:34.158]                         if (is.null(version)) 
[17:37:34.158]                           version <- utils::packageVersion("future")
[17:37:34.158]                       }
[17:37:34.158]                       else {
[17:37:34.158]                         version <- NULL
[17:37:34.158]                       }
[17:37:34.158]                       if (!has_future || version < "1.8.0") {
[17:37:34.158]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.158]                           "", base::R.version$version.string), 
[17:37:34.158]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:34.158]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.158]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.158]                             "release", "version")], collapse = " "), 
[17:37:34.158]                           hostname = base::Sys.info()[["nodename"]])
[17:37:34.158]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.158]                           info)
[17:37:34.158]                         info <- base::paste(info, collapse = "; ")
[17:37:34.158]                         if (!has_future) {
[17:37:34.158]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.158]                             info)
[17:37:34.158]                         }
[17:37:34.158]                         else {
[17:37:34.158]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.158]                             info, version)
[17:37:34.158]                         }
[17:37:34.158]                         base::stop(msg)
[17:37:34.158]                       }
[17:37:34.158]                     })
[17:37:34.158]                   }
[17:37:34.158]                   ...future.strategy.old <- future::plan("list")
[17:37:34.158]                   options(future.plan = NULL)
[17:37:34.158]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.158]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.158]                 }
[17:37:34.158]                 ...future.workdir <- getwd()
[17:37:34.158]             }
[17:37:34.158]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.158]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.158]         }
[17:37:34.158]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.158]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:34.158]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.158]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.158]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.158]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.158]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.158]             base::names(...future.oldOptions))
[17:37:34.158]     }
[17:37:34.158]     if (FALSE) {
[17:37:34.158]     }
[17:37:34.158]     else {
[17:37:34.158]         if (TRUE) {
[17:37:34.158]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.158]                 open = "w")
[17:37:34.158]         }
[17:37:34.158]         else {
[17:37:34.158]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.158]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.158]         }
[17:37:34.158]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.158]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.158]             base::sink(type = "output", split = FALSE)
[17:37:34.158]             base::close(...future.stdout)
[17:37:34.158]         }, add = TRUE)
[17:37:34.158]     }
[17:37:34.158]     ...future.frame <- base::sys.nframe()
[17:37:34.158]     ...future.conditions <- base::list()
[17:37:34.158]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.158]     if (FALSE) {
[17:37:34.158]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.158]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.158]     }
[17:37:34.158]     ...future.result <- base::tryCatch({
[17:37:34.158]         base::withCallingHandlers({
[17:37:34.158]             ...future.value <- base::withVisible(base::local({
[17:37:34.158]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.158]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.158]                   ...future.globals.maxSize)) {
[17:37:34.158]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.158]                   on.exit(options(oopts), add = TRUE)
[17:37:34.158]                 }
[17:37:34.158]                 {
[17:37:34.158]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.158]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.158]                     USE.NAMES = FALSE)
[17:37:34.158]                   do.call(mapply, args = args)
[17:37:34.158]                 }
[17:37:34.158]             }))
[17:37:34.158]             future::FutureResult(value = ...future.value$value, 
[17:37:34.158]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.158]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.158]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.158]                     ...future.globalenv.names))
[17:37:34.158]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.158]         }, condition = base::local({
[17:37:34.158]             c <- base::c
[17:37:34.158]             inherits <- base::inherits
[17:37:34.158]             invokeRestart <- base::invokeRestart
[17:37:34.158]             length <- base::length
[17:37:34.158]             list <- base::list
[17:37:34.158]             seq.int <- base::seq.int
[17:37:34.158]             signalCondition <- base::signalCondition
[17:37:34.158]             sys.calls <- base::sys.calls
[17:37:34.158]             `[[` <- base::`[[`
[17:37:34.158]             `+` <- base::`+`
[17:37:34.158]             `<<-` <- base::`<<-`
[17:37:34.158]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.158]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.158]                   3L)]
[17:37:34.158]             }
[17:37:34.158]             function(cond) {
[17:37:34.158]                 is_error <- inherits(cond, "error")
[17:37:34.158]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.158]                   NULL)
[17:37:34.158]                 if (is_error) {
[17:37:34.158]                   sessionInformation <- function() {
[17:37:34.158]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.158]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.158]                       search = base::search(), system = base::Sys.info())
[17:37:34.158]                   }
[17:37:34.158]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.158]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.158]                     cond$call), session = sessionInformation(), 
[17:37:34.158]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.158]                   signalCondition(cond)
[17:37:34.158]                 }
[17:37:34.158]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.158]                 "immediateCondition"))) {
[17:37:34.158]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.158]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.158]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.158]                   if (TRUE && !signal) {
[17:37:34.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.158]                     {
[17:37:34.158]                       inherits <- base::inherits
[17:37:34.158]                       invokeRestart <- base::invokeRestart
[17:37:34.158]                       is.null <- base::is.null
[17:37:34.158]                       muffled <- FALSE
[17:37:34.158]                       if (inherits(cond, "message")) {
[17:37:34.158]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.158]                         if (muffled) 
[17:37:34.158]                           invokeRestart("muffleMessage")
[17:37:34.158]                       }
[17:37:34.158]                       else if (inherits(cond, "warning")) {
[17:37:34.158]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.158]                         if (muffled) 
[17:37:34.158]                           invokeRestart("muffleWarning")
[17:37:34.158]                       }
[17:37:34.158]                       else if (inherits(cond, "condition")) {
[17:37:34.158]                         if (!is.null(pattern)) {
[17:37:34.158]                           computeRestarts <- base::computeRestarts
[17:37:34.158]                           grepl <- base::grepl
[17:37:34.158]                           restarts <- computeRestarts(cond)
[17:37:34.158]                           for (restart in restarts) {
[17:37:34.158]                             name <- restart$name
[17:37:34.158]                             if (is.null(name)) 
[17:37:34.158]                               next
[17:37:34.158]                             if (!grepl(pattern, name)) 
[17:37:34.158]                               next
[17:37:34.158]                             invokeRestart(restart)
[17:37:34.158]                             muffled <- TRUE
[17:37:34.158]                             break
[17:37:34.158]                           }
[17:37:34.158]                         }
[17:37:34.158]                       }
[17:37:34.158]                       invisible(muffled)
[17:37:34.158]                     }
[17:37:34.158]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.158]                   }
[17:37:34.158]                 }
[17:37:34.158]                 else {
[17:37:34.158]                   if (TRUE) {
[17:37:34.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.158]                     {
[17:37:34.158]                       inherits <- base::inherits
[17:37:34.158]                       invokeRestart <- base::invokeRestart
[17:37:34.158]                       is.null <- base::is.null
[17:37:34.158]                       muffled <- FALSE
[17:37:34.158]                       if (inherits(cond, "message")) {
[17:37:34.158]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.158]                         if (muffled) 
[17:37:34.158]                           invokeRestart("muffleMessage")
[17:37:34.158]                       }
[17:37:34.158]                       else if (inherits(cond, "warning")) {
[17:37:34.158]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.158]                         if (muffled) 
[17:37:34.158]                           invokeRestart("muffleWarning")
[17:37:34.158]                       }
[17:37:34.158]                       else if (inherits(cond, "condition")) {
[17:37:34.158]                         if (!is.null(pattern)) {
[17:37:34.158]                           computeRestarts <- base::computeRestarts
[17:37:34.158]                           grepl <- base::grepl
[17:37:34.158]                           restarts <- computeRestarts(cond)
[17:37:34.158]                           for (restart in restarts) {
[17:37:34.158]                             name <- restart$name
[17:37:34.158]                             if (is.null(name)) 
[17:37:34.158]                               next
[17:37:34.158]                             if (!grepl(pattern, name)) 
[17:37:34.158]                               next
[17:37:34.158]                             invokeRestart(restart)
[17:37:34.158]                             muffled <- TRUE
[17:37:34.158]                             break
[17:37:34.158]                           }
[17:37:34.158]                         }
[17:37:34.158]                       }
[17:37:34.158]                       invisible(muffled)
[17:37:34.158]                     }
[17:37:34.158]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.158]                   }
[17:37:34.158]                 }
[17:37:34.158]             }
[17:37:34.158]         }))
[17:37:34.158]     }, error = function(ex) {
[17:37:34.158]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.158]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.158]                 ...future.rng), started = ...future.startTime, 
[17:37:34.158]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.158]             version = "1.8"), class = "FutureResult")
[17:37:34.158]     }, finally = {
[17:37:34.158]         if (!identical(...future.workdir, getwd())) 
[17:37:34.158]             setwd(...future.workdir)
[17:37:34.158]         {
[17:37:34.158]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.158]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.158]             }
[17:37:34.158]             base::options(...future.oldOptions)
[17:37:34.158]             if (.Platform$OS.type == "windows") {
[17:37:34.158]                 old_names <- names(...future.oldEnvVars)
[17:37:34.158]                 envs <- base::Sys.getenv()
[17:37:34.158]                 names <- names(envs)
[17:37:34.158]                 common <- intersect(names, old_names)
[17:37:34.158]                 added <- setdiff(names, old_names)
[17:37:34.158]                 removed <- setdiff(old_names, names)
[17:37:34.158]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.158]                   envs[common]]
[17:37:34.158]                 NAMES <- toupper(changed)
[17:37:34.158]                 args <- list()
[17:37:34.158]                 for (kk in seq_along(NAMES)) {
[17:37:34.158]                   name <- changed[[kk]]
[17:37:34.158]                   NAME <- NAMES[[kk]]
[17:37:34.158]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.158]                     next
[17:37:34.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.158]                 }
[17:37:34.158]                 NAMES <- toupper(added)
[17:37:34.158]                 for (kk in seq_along(NAMES)) {
[17:37:34.158]                   name <- added[[kk]]
[17:37:34.158]                   NAME <- NAMES[[kk]]
[17:37:34.158]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.158]                     next
[17:37:34.158]                   args[[name]] <- ""
[17:37:34.158]                 }
[17:37:34.158]                 NAMES <- toupper(removed)
[17:37:34.158]                 for (kk in seq_along(NAMES)) {
[17:37:34.158]                   name <- removed[[kk]]
[17:37:34.158]                   NAME <- NAMES[[kk]]
[17:37:34.158]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.158]                     next
[17:37:34.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.158]                 }
[17:37:34.158]                 if (length(args) > 0) 
[17:37:34.158]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.158]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.158]             }
[17:37:34.158]             else {
[17:37:34.158]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.158]             }
[17:37:34.158]             {
[17:37:34.158]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.158]                   0L) {
[17:37:34.158]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.158]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.158]                   base::options(opts)
[17:37:34.158]                 }
[17:37:34.158]                 {
[17:37:34.158]                   {
[17:37:34.158]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:34.158]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:34.158]                     -1786728155L), envir = base::globalenv(), 
[17:37:34.158]                       inherits = FALSE)
[17:37:34.158]                     NULL
[17:37:34.158]                   }
[17:37:34.158]                   options(future.plan = NULL)
[17:37:34.158]                   if (is.na(NA_character_)) 
[17:37:34.158]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.158]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.158]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.158]                     .init = FALSE)
[17:37:34.158]                 }
[17:37:34.158]             }
[17:37:34.158]         }
[17:37:34.158]     })
[17:37:34.158]     if (TRUE) {
[17:37:34.158]         base::sink(type = "output", split = FALSE)
[17:37:34.158]         if (TRUE) {
[17:37:34.158]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.158]         }
[17:37:34.158]         else {
[17:37:34.158]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.158]         }
[17:37:34.158]         base::close(...future.stdout)
[17:37:34.158]         ...future.stdout <- NULL
[17:37:34.158]     }
[17:37:34.158]     ...future.result$conditions <- ...future.conditions
[17:37:34.158]     ...future.result$finished <- base::Sys.time()
[17:37:34.158]     ...future.result
[17:37:34.158] }
[17:37:34.159] assign_globals() ...
[17:37:34.159] List of 5
[17:37:34.159]  $ ...future.FUN            :function (C, k)  
[17:37:34.159]  $ MoreArgs                 : list()
[17:37:34.159]  $ ...future.elements_ii    :List of 2
[17:37:34.159]   ..$ :List of 5
[17:37:34.159]   .. ..$ : chr "A"
[17:37:34.159]   .. ..$ : chr "B"
[17:37:34.159]   .. ..$ : chr "C"
[17:37:34.159]   .. ..$ : chr "D"
[17:37:34.159]   .. ..$ : chr "E"
[17:37:34.159]   ..$ :List of 5
[17:37:34.159]   .. ..$ : int 5
[17:37:34.159]   .. ..$ : int 4
[17:37:34.159]   .. ..$ : int 3
[17:37:34.159]   .. ..$ : int 2
[17:37:34.159]   .. ..$ : int 1
[17:37:34.159]  $ ...future.seeds_ii       : NULL
[17:37:34.159]  $ ...future.globals.maxSize: NULL
[17:37:34.159]  - attr(*, "where")=List of 5
[17:37:34.159]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.159]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.159]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.159]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.159]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.159]  - attr(*, "resolved")= logi FALSE
[17:37:34.159]  - attr(*, "total_size")= num 4160
[17:37:34.159]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.159]  - attr(*, "already-done")= logi TRUE
[17:37:34.166] - reassign environment for ‘...future.FUN’
[17:37:34.166] - copied ‘...future.FUN’ to environment
[17:37:34.166] - copied ‘MoreArgs’ to environment
[17:37:34.167] - copied ‘...future.elements_ii’ to environment
[17:37:34.168] - copied ‘...future.seeds_ii’ to environment
[17:37:34.168] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.168] assign_globals() ... done
[17:37:34.169] plan(): Setting new future strategy stack:
[17:37:34.169] List of future strategies:
[17:37:34.169] 1. sequential:
[17:37:34.169]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.169]    - tweaked: FALSE
[17:37:34.169]    - call: NULL
[17:37:34.169] plan(): nbrOfWorkers() = 1
[17:37:34.170] plan(): Setting new future strategy stack:
[17:37:34.170] List of future strategies:
[17:37:34.170] 1. sequential:
[17:37:34.170]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.170]    - tweaked: FALSE
[17:37:34.170]    - call: plan(strategy)
[17:37:34.171] plan(): nbrOfWorkers() = 1
[17:37:34.171] SequentialFuture started (and completed)
[17:37:34.171] - Launch lazy future ... done
[17:37:34.171] run() for ‘SequentialFuture’ ... done
[17:37:34.171] Created future:
[17:37:34.171] SequentialFuture:
[17:37:34.171] Label: ‘future_.mapply-1’
[17:37:34.171] Expression:
[17:37:34.171] {
[17:37:34.171]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.171]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.171]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.171]         on.exit(options(oopts), add = TRUE)
[17:37:34.171]     }
[17:37:34.171]     {
[17:37:34.171]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.171]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.171]         do.call(mapply, args = args)
[17:37:34.171]     }
[17:37:34.171] }
[17:37:34.171] Lazy evaluation: FALSE
[17:37:34.171] Asynchronous evaluation: FALSE
[17:37:34.171] Local evaluation: TRUE
[17:37:34.171] Environment: R_GlobalEnv
[17:37:34.171] Capture standard output: TRUE
[17:37:34.171] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.171] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.171] Packages: <none>
[17:37:34.171] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.171] Resolved: TRUE
[17:37:34.171] Value: 560 bytes of class ‘list’
[17:37:34.171] Early signaling: FALSE
[17:37:34.171] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.171] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.172] Chunk #1 of 1 ... DONE
[17:37:34.172] Launching 1 futures (chunks) ... DONE
[17:37:34.173] Resolving 1 futures (chunks) ...
[17:37:34.173] resolve() on list ...
[17:37:34.173]  recursive: 0
[17:37:34.173]  length: 1
[17:37:34.173] 
[17:37:34.173] resolved() for ‘SequentialFuture’ ...
[17:37:34.173] - state: ‘finished’
[17:37:34.173] - run: TRUE
[17:37:34.173] - result: ‘FutureResult’
[17:37:34.173] resolved() for ‘SequentialFuture’ ... done
[17:37:34.173] Future #1
[17:37:34.174] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:34.174] - nx: 1
[17:37:34.174] - relay: TRUE
[17:37:34.174] - stdout: TRUE
[17:37:34.174] - signal: TRUE
[17:37:34.174] - resignal: FALSE
[17:37:34.174] - force: TRUE
[17:37:34.174] - relayed: [n=1] FALSE
[17:37:34.174] - queued futures: [n=1] FALSE
[17:37:34.174]  - until=1
[17:37:34.174]  - relaying element #1
[17:37:34.175] - relayed: [n=1] TRUE
[17:37:34.175] - queued futures: [n=1] TRUE
[17:37:34.175] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:34.175]  length: 0 (resolved future 1)
[17:37:34.175] Relaying remaining futures
[17:37:34.175] signalConditionsASAP(NULL, pos=0) ...
[17:37:34.175] - nx: 1
[17:37:34.175] - relay: TRUE
[17:37:34.175] - stdout: TRUE
[17:37:34.175] - signal: TRUE
[17:37:34.176] - resignal: FALSE
[17:37:34.176] - force: TRUE
[17:37:34.176] - relayed: [n=1] TRUE
[17:37:34.176] - queued futures: [n=1] TRUE
 - flush all
[17:37:34.176] - relayed: [n=1] TRUE
[17:37:34.176] - queued futures: [n=1] TRUE
[17:37:34.176] signalConditionsASAP(NULL, pos=0) ... done
[17:37:34.176] resolve() on list ... DONE
[17:37:34.176]  - Number of value chunks collected: 1
[17:37:34.176] Resolving 1 futures (chunks) ... DONE
[17:37:34.177] Reducing values from 1 chunks ...
[17:37:34.177]  - Number of values collected after concatenation: 5
[17:37:34.177]  - Number of values expected: 5
[17:37:34.177] Reducing values from 1 chunks ... DONE
[17:37:34.177] future_mapply() ... DONE
[17:37:34.177] future_mapply() ...
[17:37:34.178] Number of chunks: 3
[17:37:34.178] Index remapping (attribute 'ordering'): [n = 5] 3, 4, 5, 1, 2
[17:37:34.178] getGlobalsAndPackagesXApply() ...
[17:37:34.178]  - future.globals: TRUE
[17:37:34.178] getGlobalsAndPackages() ...
[17:37:34.178] Searching for globals...
[17:37:34.179] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:37:34.179] Searching for globals ... DONE
[17:37:34.179] Resolving globals: FALSE
[17:37:34.180] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:37:34.180] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:37:34.180] - globals: [1] ‘FUN’
[17:37:34.180] 
[17:37:34.180] getGlobalsAndPackages() ... DONE
[17:37:34.181]  - globals found/used: [n=1] ‘FUN’
[17:37:34.181]  - needed namespaces: [n=0] 
[17:37:34.181] Finding globals ... DONE
[17:37:34.181] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:34.181] List of 2
[17:37:34.181]  $ ...future.FUN:function (C, k)  
[17:37:34.181]  $ MoreArgs     : NULL
[17:37:34.181]  - attr(*, "where")=List of 2
[17:37:34.181]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:34.181]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:34.181]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.181]  - attr(*, "resolved")= logi FALSE
[17:37:34.181]  - attr(*, "total_size")= num NA
[17:37:34.183] Packages to be attached in all futures: [n=0] 
[17:37:34.183] getGlobalsAndPackagesXApply() ... DONE
[17:37:34.184] Number of futures (= number of chunks): 3
[17:37:34.184] Launching 3 futures (chunks) ...
[17:37:34.184] Chunk #1 of 3 ...
[17:37:34.184]  - Finding globals in '...' for chunk #1 ...
[17:37:34.184] getGlobalsAndPackages() ...
[17:37:34.184] Searching for globals...
[17:37:34.184] 
[17:37:34.185] Searching for globals ... DONE
[17:37:34.185] - globals: [0] <none>
[17:37:34.185] getGlobalsAndPackages() ... DONE
[17:37:34.185]    + additional globals found: [n=0] 
[17:37:34.185]    + additional namespaces needed: [n=0] 
[17:37:34.185]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:34.185]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:37:34.185]  - seeds: <none>
[17:37:34.185]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.185] getGlobalsAndPackages() ...
[17:37:34.185] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.186] Resolving globals: FALSE
[17:37:34.186] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:37:34.186] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:34.187] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.187] 
[17:37:34.187] getGlobalsAndPackages() ... DONE
[17:37:34.187] run() for ‘Future’ ...
[17:37:34.187] - state: ‘created’
[17:37:34.187] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.188] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.188] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.188]   - Field: ‘label’
[17:37:34.188]   - Field: ‘local’
[17:37:34.188]   - Field: ‘owner’
[17:37:34.188]   - Field: ‘envir’
[17:37:34.188]   - Field: ‘packages’
[17:37:34.188]   - Field: ‘gc’
[17:37:34.188]   - Field: ‘conditions’
[17:37:34.188]   - Field: ‘expr’
[17:37:34.189]   - Field: ‘uuid’
[17:37:34.189]   - Field: ‘seed’
[17:37:34.189]   - Field: ‘version’
[17:37:34.189]   - Field: ‘result’
[17:37:34.189]   - Field: ‘asynchronous’
[17:37:34.189]   - Field: ‘calls’
[17:37:34.189]   - Field: ‘globals’
[17:37:34.189]   - Field: ‘stdout’
[17:37:34.189]   - Field: ‘earlySignal’
[17:37:34.189]   - Field: ‘lazy’
[17:37:34.189]   - Field: ‘state’
[17:37:34.190] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.190] - Launch lazy future ...
[17:37:34.190] Packages needed by the future expression (n = 0): <none>
[17:37:34.190] Packages needed by future strategies (n = 0): <none>
[17:37:34.190] {
[17:37:34.190]     {
[17:37:34.190]         {
[17:37:34.190]             ...future.startTime <- base::Sys.time()
[17:37:34.190]             {
[17:37:34.190]                 {
[17:37:34.190]                   {
[17:37:34.190]                     base::local({
[17:37:34.190]                       has_future <- base::requireNamespace("future", 
[17:37:34.190]                         quietly = TRUE)
[17:37:34.190]                       if (has_future) {
[17:37:34.190]                         ns <- base::getNamespace("future")
[17:37:34.190]                         version <- ns[[".package"]][["version"]]
[17:37:34.190]                         if (is.null(version)) 
[17:37:34.190]                           version <- utils::packageVersion("future")
[17:37:34.190]                       }
[17:37:34.190]                       else {
[17:37:34.190]                         version <- NULL
[17:37:34.190]                       }
[17:37:34.190]                       if (!has_future || version < "1.8.0") {
[17:37:34.190]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.190]                           "", base::R.version$version.string), 
[17:37:34.190]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:34.190]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.190]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.190]                             "release", "version")], collapse = " "), 
[17:37:34.190]                           hostname = base::Sys.info()[["nodename"]])
[17:37:34.190]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.190]                           info)
[17:37:34.190]                         info <- base::paste(info, collapse = "; ")
[17:37:34.190]                         if (!has_future) {
[17:37:34.190]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.190]                             info)
[17:37:34.190]                         }
[17:37:34.190]                         else {
[17:37:34.190]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.190]                             info, version)
[17:37:34.190]                         }
[17:37:34.190]                         base::stop(msg)
[17:37:34.190]                       }
[17:37:34.190]                     })
[17:37:34.190]                   }
[17:37:34.190]                   ...future.strategy.old <- future::plan("list")
[17:37:34.190]                   options(future.plan = NULL)
[17:37:34.190]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.190]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.190]                 }
[17:37:34.190]                 ...future.workdir <- getwd()
[17:37:34.190]             }
[17:37:34.190]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.190]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.190]         }
[17:37:34.190]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.190]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:37:34.190]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.190]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.190]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.190]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.190]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.190]             base::names(...future.oldOptions))
[17:37:34.190]     }
[17:37:34.190]     if (FALSE) {
[17:37:34.190]     }
[17:37:34.190]     else {
[17:37:34.190]         if (TRUE) {
[17:37:34.190]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.190]                 open = "w")
[17:37:34.190]         }
[17:37:34.190]         else {
[17:37:34.190]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.190]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.190]         }
[17:37:34.190]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.190]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.190]             base::sink(type = "output", split = FALSE)
[17:37:34.190]             base::close(...future.stdout)
[17:37:34.190]         }, add = TRUE)
[17:37:34.190]     }
[17:37:34.190]     ...future.frame <- base::sys.nframe()
[17:37:34.190]     ...future.conditions <- base::list()
[17:37:34.190]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.190]     if (FALSE) {
[17:37:34.190]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.190]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.190]     }
[17:37:34.190]     ...future.result <- base::tryCatch({
[17:37:34.190]         base::withCallingHandlers({
[17:37:34.190]             ...future.value <- base::withVisible(base::local({
[17:37:34.190]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.190]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.190]                   ...future.globals.maxSize)) {
[17:37:34.190]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.190]                   on.exit(options(oopts), add = TRUE)
[17:37:34.190]                 }
[17:37:34.190]                 {
[17:37:34.190]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.190]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.190]                     USE.NAMES = FALSE)
[17:37:34.190]                   do.call(mapply, args = args)
[17:37:34.190]                 }
[17:37:34.190]             }))
[17:37:34.190]             future::FutureResult(value = ...future.value$value, 
[17:37:34.190]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.190]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.190]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.190]                     ...future.globalenv.names))
[17:37:34.190]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.190]         }, condition = base::local({
[17:37:34.190]             c <- base::c
[17:37:34.190]             inherits <- base::inherits
[17:37:34.190]             invokeRestart <- base::invokeRestart
[17:37:34.190]             length <- base::length
[17:37:34.190]             list <- base::list
[17:37:34.190]             seq.int <- base::seq.int
[17:37:34.190]             signalCondition <- base::signalCondition
[17:37:34.190]             sys.calls <- base::sys.calls
[17:37:34.190]             `[[` <- base::`[[`
[17:37:34.190]             `+` <- base::`+`
[17:37:34.190]             `<<-` <- base::`<<-`
[17:37:34.190]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.190]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.190]                   3L)]
[17:37:34.190]             }
[17:37:34.190]             function(cond) {
[17:37:34.190]                 is_error <- inherits(cond, "error")
[17:37:34.190]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.190]                   NULL)
[17:37:34.190]                 if (is_error) {
[17:37:34.190]                   sessionInformation <- function() {
[17:37:34.190]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.190]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.190]                       search = base::search(), system = base::Sys.info())
[17:37:34.190]                   }
[17:37:34.190]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.190]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.190]                     cond$call), session = sessionInformation(), 
[17:37:34.190]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.190]                   signalCondition(cond)
[17:37:34.190]                 }
[17:37:34.190]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.190]                 "immediateCondition"))) {
[17:37:34.190]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.190]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.190]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.190]                   if (TRUE && !signal) {
[17:37:34.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.190]                     {
[17:37:34.190]                       inherits <- base::inherits
[17:37:34.190]                       invokeRestart <- base::invokeRestart
[17:37:34.190]                       is.null <- base::is.null
[17:37:34.190]                       muffled <- FALSE
[17:37:34.190]                       if (inherits(cond, "message")) {
[17:37:34.190]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.190]                         if (muffled) 
[17:37:34.190]                           invokeRestart("muffleMessage")
[17:37:34.190]                       }
[17:37:34.190]                       else if (inherits(cond, "warning")) {
[17:37:34.190]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.190]                         if (muffled) 
[17:37:34.190]                           invokeRestart("muffleWarning")
[17:37:34.190]                       }
[17:37:34.190]                       else if (inherits(cond, "condition")) {
[17:37:34.190]                         if (!is.null(pattern)) {
[17:37:34.190]                           computeRestarts <- base::computeRestarts
[17:37:34.190]                           grepl <- base::grepl
[17:37:34.190]                           restarts <- computeRestarts(cond)
[17:37:34.190]                           for (restart in restarts) {
[17:37:34.190]                             name <- restart$name
[17:37:34.190]                             if (is.null(name)) 
[17:37:34.190]                               next
[17:37:34.190]                             if (!grepl(pattern, name)) 
[17:37:34.190]                               next
[17:37:34.190]                             invokeRestart(restart)
[17:37:34.190]                             muffled <- TRUE
[17:37:34.190]                             break
[17:37:34.190]                           }
[17:37:34.190]                         }
[17:37:34.190]                       }
[17:37:34.190]                       invisible(muffled)
[17:37:34.190]                     }
[17:37:34.190]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.190]                   }
[17:37:34.190]                 }
[17:37:34.190]                 else {
[17:37:34.190]                   if (TRUE) {
[17:37:34.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.190]                     {
[17:37:34.190]                       inherits <- base::inherits
[17:37:34.190]                       invokeRestart <- base::invokeRestart
[17:37:34.190]                       is.null <- base::is.null
[17:37:34.190]                       muffled <- FALSE
[17:37:34.190]                       if (inherits(cond, "message")) {
[17:37:34.190]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.190]                         if (muffled) 
[17:37:34.190]                           invokeRestart("muffleMessage")
[17:37:34.190]                       }
[17:37:34.190]                       else if (inherits(cond, "warning")) {
[17:37:34.190]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.190]                         if (muffled) 
[17:37:34.190]                           invokeRestart("muffleWarning")
[17:37:34.190]                       }
[17:37:34.190]                       else if (inherits(cond, "condition")) {
[17:37:34.190]                         if (!is.null(pattern)) {
[17:37:34.190]                           computeRestarts <- base::computeRestarts
[17:37:34.190]                           grepl <- base::grepl
[17:37:34.190]                           restarts <- computeRestarts(cond)
[17:37:34.190]                           for (restart in restarts) {
[17:37:34.190]                             name <- restart$name
[17:37:34.190]                             if (is.null(name)) 
[17:37:34.190]                               next
[17:37:34.190]                             if (!grepl(pattern, name)) 
[17:37:34.190]                               next
[17:37:34.190]                             invokeRestart(restart)
[17:37:34.190]                             muffled <- TRUE
[17:37:34.190]                             break
[17:37:34.190]                           }
[17:37:34.190]                         }
[17:37:34.190]                       }
[17:37:34.190]                       invisible(muffled)
[17:37:34.190]                     }
[17:37:34.190]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.190]                   }
[17:37:34.190]                 }
[17:37:34.190]             }
[17:37:34.190]         }))
[17:37:34.190]     }, error = function(ex) {
[17:37:34.190]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.190]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.190]                 ...future.rng), started = ...future.startTime, 
[17:37:34.190]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.190]             version = "1.8"), class = "FutureResult")
[17:37:34.190]     }, finally = {
[17:37:34.190]         if (!identical(...future.workdir, getwd())) 
[17:37:34.190]             setwd(...future.workdir)
[17:37:34.190]         {
[17:37:34.190]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.190]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.190]             }
[17:37:34.190]             base::options(...future.oldOptions)
[17:37:34.190]             if (.Platform$OS.type == "windows") {
[17:37:34.190]                 old_names <- names(...future.oldEnvVars)
[17:37:34.190]                 envs <- base::Sys.getenv()
[17:37:34.190]                 names <- names(envs)
[17:37:34.190]                 common <- intersect(names, old_names)
[17:37:34.190]                 added <- setdiff(names, old_names)
[17:37:34.190]                 removed <- setdiff(old_names, names)
[17:37:34.190]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.190]                   envs[common]]
[17:37:34.190]                 NAMES <- toupper(changed)
[17:37:34.190]                 args <- list()
[17:37:34.190]                 for (kk in seq_along(NAMES)) {
[17:37:34.190]                   name <- changed[[kk]]
[17:37:34.190]                   NAME <- NAMES[[kk]]
[17:37:34.190]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.190]                     next
[17:37:34.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.190]                 }
[17:37:34.190]                 NAMES <- toupper(added)
[17:37:34.190]                 for (kk in seq_along(NAMES)) {
[17:37:34.190]                   name <- added[[kk]]
[17:37:34.190]                   NAME <- NAMES[[kk]]
[17:37:34.190]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.190]                     next
[17:37:34.190]                   args[[name]] <- ""
[17:37:34.190]                 }
[17:37:34.190]                 NAMES <- toupper(removed)
[17:37:34.190]                 for (kk in seq_along(NAMES)) {
[17:37:34.190]                   name <- removed[[kk]]
[17:37:34.190]                   NAME <- NAMES[[kk]]
[17:37:34.190]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.190]                     next
[17:37:34.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.190]                 }
[17:37:34.190]                 if (length(args) > 0) 
[17:37:34.190]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.190]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.190]             }
[17:37:34.190]             else {
[17:37:34.190]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.190]             }
[17:37:34.190]             {
[17:37:34.190]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.190]                   0L) {
[17:37:34.190]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.190]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.190]                   base::options(opts)
[17:37:34.190]                 }
[17:37:34.190]                 {
[17:37:34.190]                   {
[17:37:34.190]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:34.190]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:34.190]                     -1786728155L), envir = base::globalenv(), 
[17:37:34.190]                       inherits = FALSE)
[17:37:34.190]                     NULL
[17:37:34.190]                   }
[17:37:34.190]                   options(future.plan = NULL)
[17:37:34.190]                   if (is.na(NA_character_)) 
[17:37:34.190]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.190]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.190]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.190]                     .init = FALSE)
[17:37:34.190]                 }
[17:37:34.190]             }
[17:37:34.190]         }
[17:37:34.190]     })
[17:37:34.190]     if (TRUE) {
[17:37:34.190]         base::sink(type = "output", split = FALSE)
[17:37:34.190]         if (TRUE) {
[17:37:34.190]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.190]         }
[17:37:34.190]         else {
[17:37:34.190]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.190]         }
[17:37:34.190]         base::close(...future.stdout)
[17:37:34.190]         ...future.stdout <- NULL
[17:37:34.190]     }
[17:37:34.190]     ...future.result$conditions <- ...future.conditions
[17:37:34.190]     ...future.result$finished <- base::Sys.time()
[17:37:34.190]     ...future.result
[17:37:34.190] }
[17:37:34.192] assign_globals() ...
[17:37:34.192] List of 5
[17:37:34.192]  $ ...future.FUN            :function (C, k)  
[17:37:34.192]  $ MoreArgs                 : NULL
[17:37:34.192]  $ ...future.elements_ii    :List of 2
[17:37:34.192]   ..$ :List of 2
[17:37:34.192]   .. ..$ : chr "C"
[17:37:34.192]   .. ..$ : chr "D"
[17:37:34.192]   ..$ :List of 2
[17:37:34.192]   .. ..$ : int 3
[17:37:34.192]   .. ..$ : int 2
[17:37:34.192]  $ ...future.seeds_ii       : NULL
[17:37:34.192]  $ ...future.globals.maxSize: NULL
[17:37:34.192]  - attr(*, "where")=List of 5
[17:37:34.192]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.192]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.192]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.192]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.192]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.192]  - attr(*, "resolved")= logi FALSE
[17:37:34.192]  - attr(*, "total_size")= num 3656
[17:37:34.192]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.192]  - attr(*, "already-done")= logi TRUE
[17:37:34.199] - reassign environment for ‘...future.FUN’
[17:37:34.199] - copied ‘...future.FUN’ to environment
[17:37:34.199] - copied ‘MoreArgs’ to environment
[17:37:34.199] - copied ‘...future.elements_ii’ to environment
[17:37:34.200] - copied ‘...future.seeds_ii’ to environment
[17:37:34.200] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.200] assign_globals() ... done
[17:37:34.200] plan(): Setting new future strategy stack:
[17:37:34.200] List of future strategies:
[17:37:34.200] 1. sequential:
[17:37:34.200]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.200]    - tweaked: FALSE
[17:37:34.200]    - call: NULL
[17:37:34.201] plan(): nbrOfWorkers() = 1
[17:37:34.201] plan(): Setting new future strategy stack:
[17:37:34.201] List of future strategies:
[17:37:34.201] 1. sequential:
[17:37:34.201]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.201]    - tweaked: FALSE
[17:37:34.201]    - call: plan(strategy)
[17:37:34.202] plan(): nbrOfWorkers() = 1
[17:37:34.202] SequentialFuture started (and completed)
[17:37:34.202] - Launch lazy future ... done
[17:37:34.202] run() for ‘SequentialFuture’ ... done
[17:37:34.202] Created future:
[17:37:34.202] SequentialFuture:
[17:37:34.202] Label: ‘future_mapply-1’
[17:37:34.202] Expression:
[17:37:34.202] {
[17:37:34.202]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.202]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.202]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.202]         on.exit(options(oopts), add = TRUE)
[17:37:34.202]     }
[17:37:34.202]     {
[17:37:34.202]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.202]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.202]         do.call(mapply, args = args)
[17:37:34.202]     }
[17:37:34.202] }
[17:37:34.202] Lazy evaluation: FALSE
[17:37:34.202] Asynchronous evaluation: FALSE
[17:37:34.202] Local evaluation: TRUE
[17:37:34.202] Environment: R_GlobalEnv
[17:37:34.202] Capture standard output: TRUE
[17:37:34.202] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.202] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.202] Packages: <none>
[17:37:34.202] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.202] Resolved: TRUE
[17:37:34.202] Value: 224 bytes of class ‘list’
[17:37:34.202] Early signaling: FALSE
[17:37:34.202] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.202] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.203] Chunk #1 of 3 ... DONE
[17:37:34.203] Chunk #2 of 3 ...
[17:37:34.204]  - Finding globals in '...' for chunk #2 ...
[17:37:34.204] getGlobalsAndPackages() ...
[17:37:34.204] Searching for globals...
[17:37:34.204] 
[17:37:34.204] Searching for globals ... DONE
[17:37:34.204] - globals: [0] <none>
[17:37:34.204] getGlobalsAndPackages() ... DONE
[17:37:34.204]    + additional globals found: [n=0] 
[17:37:34.205]    + additional namespaces needed: [n=0] 
[17:37:34.205]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:34.205]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:37:34.205]  - seeds: <none>
[17:37:34.205]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.205] getGlobalsAndPackages() ...
[17:37:34.205] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.205] Resolving globals: FALSE
[17:37:34.206] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:37:34.206] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:34.206] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.206] 
[17:37:34.206] getGlobalsAndPackages() ... DONE
[17:37:34.207] run() for ‘Future’ ...
[17:37:34.207] - state: ‘created’
[17:37:34.207] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.207] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.207] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.207]   - Field: ‘label’
[17:37:34.208]   - Field: ‘local’
[17:37:34.208]   - Field: ‘owner’
[17:37:34.208]   - Field: ‘envir’
[17:37:34.208]   - Field: ‘packages’
[17:37:34.208]   - Field: ‘gc’
[17:37:34.208]   - Field: ‘conditions’
[17:37:34.208]   - Field: ‘expr’
[17:37:34.208]   - Field: ‘uuid’
[17:37:34.208]   - Field: ‘seed’
[17:37:34.208]   - Field: ‘version’
[17:37:34.209]   - Field: ‘result’
[17:37:34.209]   - Field: ‘asynchronous’
[17:37:34.209]   - Field: ‘calls’
[17:37:34.209]   - Field: ‘globals’
[17:37:34.209]   - Field: ‘stdout’
[17:37:34.209]   - Field: ‘earlySignal’
[17:37:34.209]   - Field: ‘lazy’
[17:37:34.209]   - Field: ‘state’
[17:37:34.209] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.209] - Launch lazy future ...
[17:37:34.209] Packages needed by the future expression (n = 0): <none>
[17:37:34.210] Packages needed by future strategies (n = 0): <none>
[17:37:34.210] {
[17:37:34.210]     {
[17:37:34.210]         {
[17:37:34.210]             ...future.startTime <- base::Sys.time()
[17:37:34.210]             {
[17:37:34.210]                 {
[17:37:34.210]                   {
[17:37:34.210]                     base::local({
[17:37:34.210]                       has_future <- base::requireNamespace("future", 
[17:37:34.210]                         quietly = TRUE)
[17:37:34.210]                       if (has_future) {
[17:37:34.210]                         ns <- base::getNamespace("future")
[17:37:34.210]                         version <- ns[[".package"]][["version"]]
[17:37:34.210]                         if (is.null(version)) 
[17:37:34.210]                           version <- utils::packageVersion("future")
[17:37:34.210]                       }
[17:37:34.210]                       else {
[17:37:34.210]                         version <- NULL
[17:37:34.210]                       }
[17:37:34.210]                       if (!has_future || version < "1.8.0") {
[17:37:34.210]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.210]                           "", base::R.version$version.string), 
[17:37:34.210]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:34.210]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.210]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.210]                             "release", "version")], collapse = " "), 
[17:37:34.210]                           hostname = base::Sys.info()[["nodename"]])
[17:37:34.210]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.210]                           info)
[17:37:34.210]                         info <- base::paste(info, collapse = "; ")
[17:37:34.210]                         if (!has_future) {
[17:37:34.210]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.210]                             info)
[17:37:34.210]                         }
[17:37:34.210]                         else {
[17:37:34.210]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.210]                             info, version)
[17:37:34.210]                         }
[17:37:34.210]                         base::stop(msg)
[17:37:34.210]                       }
[17:37:34.210]                     })
[17:37:34.210]                   }
[17:37:34.210]                   ...future.strategy.old <- future::plan("list")
[17:37:34.210]                   options(future.plan = NULL)
[17:37:34.210]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.210]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.210]                 }
[17:37:34.210]                 ...future.workdir <- getwd()
[17:37:34.210]             }
[17:37:34.210]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.210]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.210]         }
[17:37:34.210]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.210]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:37:34.210]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.210]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.210]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.210]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.210]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.210]             base::names(...future.oldOptions))
[17:37:34.210]     }
[17:37:34.210]     if (FALSE) {
[17:37:34.210]     }
[17:37:34.210]     else {
[17:37:34.210]         if (TRUE) {
[17:37:34.210]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.210]                 open = "w")
[17:37:34.210]         }
[17:37:34.210]         else {
[17:37:34.210]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.210]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.210]         }
[17:37:34.210]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.210]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.210]             base::sink(type = "output", split = FALSE)
[17:37:34.210]             base::close(...future.stdout)
[17:37:34.210]         }, add = TRUE)
[17:37:34.210]     }
[17:37:34.210]     ...future.frame <- base::sys.nframe()
[17:37:34.210]     ...future.conditions <- base::list()
[17:37:34.210]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.210]     if (FALSE) {
[17:37:34.210]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.210]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.210]     }
[17:37:34.210]     ...future.result <- base::tryCatch({
[17:37:34.210]         base::withCallingHandlers({
[17:37:34.210]             ...future.value <- base::withVisible(base::local({
[17:37:34.210]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.210]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.210]                   ...future.globals.maxSize)) {
[17:37:34.210]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.210]                   on.exit(options(oopts), add = TRUE)
[17:37:34.210]                 }
[17:37:34.210]                 {
[17:37:34.210]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.210]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.210]                     USE.NAMES = FALSE)
[17:37:34.210]                   do.call(mapply, args = args)
[17:37:34.210]                 }
[17:37:34.210]             }))
[17:37:34.210]             future::FutureResult(value = ...future.value$value, 
[17:37:34.210]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.210]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.210]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.210]                     ...future.globalenv.names))
[17:37:34.210]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.210]         }, condition = base::local({
[17:37:34.210]             c <- base::c
[17:37:34.210]             inherits <- base::inherits
[17:37:34.210]             invokeRestart <- base::invokeRestart
[17:37:34.210]             length <- base::length
[17:37:34.210]             list <- base::list
[17:37:34.210]             seq.int <- base::seq.int
[17:37:34.210]             signalCondition <- base::signalCondition
[17:37:34.210]             sys.calls <- base::sys.calls
[17:37:34.210]             `[[` <- base::`[[`
[17:37:34.210]             `+` <- base::`+`
[17:37:34.210]             `<<-` <- base::`<<-`
[17:37:34.210]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.210]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.210]                   3L)]
[17:37:34.210]             }
[17:37:34.210]             function(cond) {
[17:37:34.210]                 is_error <- inherits(cond, "error")
[17:37:34.210]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.210]                   NULL)
[17:37:34.210]                 if (is_error) {
[17:37:34.210]                   sessionInformation <- function() {
[17:37:34.210]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.210]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.210]                       search = base::search(), system = base::Sys.info())
[17:37:34.210]                   }
[17:37:34.210]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.210]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.210]                     cond$call), session = sessionInformation(), 
[17:37:34.210]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.210]                   signalCondition(cond)
[17:37:34.210]                 }
[17:37:34.210]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.210]                 "immediateCondition"))) {
[17:37:34.210]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.210]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.210]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.210]                   if (TRUE && !signal) {
[17:37:34.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.210]                     {
[17:37:34.210]                       inherits <- base::inherits
[17:37:34.210]                       invokeRestart <- base::invokeRestart
[17:37:34.210]                       is.null <- base::is.null
[17:37:34.210]                       muffled <- FALSE
[17:37:34.210]                       if (inherits(cond, "message")) {
[17:37:34.210]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.210]                         if (muffled) 
[17:37:34.210]                           invokeRestart("muffleMessage")
[17:37:34.210]                       }
[17:37:34.210]                       else if (inherits(cond, "warning")) {
[17:37:34.210]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.210]                         if (muffled) 
[17:37:34.210]                           invokeRestart("muffleWarning")
[17:37:34.210]                       }
[17:37:34.210]                       else if (inherits(cond, "condition")) {
[17:37:34.210]                         if (!is.null(pattern)) {
[17:37:34.210]                           computeRestarts <- base::computeRestarts
[17:37:34.210]                           grepl <- base::grepl
[17:37:34.210]                           restarts <- computeRestarts(cond)
[17:37:34.210]                           for (restart in restarts) {
[17:37:34.210]                             name <- restart$name
[17:37:34.210]                             if (is.null(name)) 
[17:37:34.210]                               next
[17:37:34.210]                             if (!grepl(pattern, name)) 
[17:37:34.210]                               next
[17:37:34.210]                             invokeRestart(restart)
[17:37:34.210]                             muffled <- TRUE
[17:37:34.210]                             break
[17:37:34.210]                           }
[17:37:34.210]                         }
[17:37:34.210]                       }
[17:37:34.210]                       invisible(muffled)
[17:37:34.210]                     }
[17:37:34.210]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.210]                   }
[17:37:34.210]                 }
[17:37:34.210]                 else {
[17:37:34.210]                   if (TRUE) {
[17:37:34.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.210]                     {
[17:37:34.210]                       inherits <- base::inherits
[17:37:34.210]                       invokeRestart <- base::invokeRestart
[17:37:34.210]                       is.null <- base::is.null
[17:37:34.210]                       muffled <- FALSE
[17:37:34.210]                       if (inherits(cond, "message")) {
[17:37:34.210]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.210]                         if (muffled) 
[17:37:34.210]                           invokeRestart("muffleMessage")
[17:37:34.210]                       }
[17:37:34.210]                       else if (inherits(cond, "warning")) {
[17:37:34.210]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.210]                         if (muffled) 
[17:37:34.210]                           invokeRestart("muffleWarning")
[17:37:34.210]                       }
[17:37:34.210]                       else if (inherits(cond, "condition")) {
[17:37:34.210]                         if (!is.null(pattern)) {
[17:37:34.210]                           computeRestarts <- base::computeRestarts
[17:37:34.210]                           grepl <- base::grepl
[17:37:34.210]                           restarts <- computeRestarts(cond)
[17:37:34.210]                           for (restart in restarts) {
[17:37:34.210]                             name <- restart$name
[17:37:34.210]                             if (is.null(name)) 
[17:37:34.210]                               next
[17:37:34.210]                             if (!grepl(pattern, name)) 
[17:37:34.210]                               next
[17:37:34.210]                             invokeRestart(restart)
[17:37:34.210]                             muffled <- TRUE
[17:37:34.210]                             break
[17:37:34.210]                           }
[17:37:34.210]                         }
[17:37:34.210]                       }
[17:37:34.210]                       invisible(muffled)
[17:37:34.210]                     }
[17:37:34.210]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.210]                   }
[17:37:34.210]                 }
[17:37:34.210]             }
[17:37:34.210]         }))
[17:37:34.210]     }, error = function(ex) {
[17:37:34.210]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.210]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.210]                 ...future.rng), started = ...future.startTime, 
[17:37:34.210]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.210]             version = "1.8"), class = "FutureResult")
[17:37:34.210]     }, finally = {
[17:37:34.210]         if (!identical(...future.workdir, getwd())) 
[17:37:34.210]             setwd(...future.workdir)
[17:37:34.210]         {
[17:37:34.210]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.210]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.210]             }
[17:37:34.210]             base::options(...future.oldOptions)
[17:37:34.210]             if (.Platform$OS.type == "windows") {
[17:37:34.210]                 old_names <- names(...future.oldEnvVars)
[17:37:34.210]                 envs <- base::Sys.getenv()
[17:37:34.210]                 names <- names(envs)
[17:37:34.210]                 common <- intersect(names, old_names)
[17:37:34.210]                 added <- setdiff(names, old_names)
[17:37:34.210]                 removed <- setdiff(old_names, names)
[17:37:34.210]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.210]                   envs[common]]
[17:37:34.210]                 NAMES <- toupper(changed)
[17:37:34.210]                 args <- list()
[17:37:34.210]                 for (kk in seq_along(NAMES)) {
[17:37:34.210]                   name <- changed[[kk]]
[17:37:34.210]                   NAME <- NAMES[[kk]]
[17:37:34.210]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.210]                     next
[17:37:34.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.210]                 }
[17:37:34.210]                 NAMES <- toupper(added)
[17:37:34.210]                 for (kk in seq_along(NAMES)) {
[17:37:34.210]                   name <- added[[kk]]
[17:37:34.210]                   NAME <- NAMES[[kk]]
[17:37:34.210]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.210]                     next
[17:37:34.210]                   args[[name]] <- ""
[17:37:34.210]                 }
[17:37:34.210]                 NAMES <- toupper(removed)
[17:37:34.210]                 for (kk in seq_along(NAMES)) {
[17:37:34.210]                   name <- removed[[kk]]
[17:37:34.210]                   NAME <- NAMES[[kk]]
[17:37:34.210]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.210]                     next
[17:37:34.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.210]                 }
[17:37:34.210]                 if (length(args) > 0) 
[17:37:34.210]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.210]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.210]             }
[17:37:34.210]             else {
[17:37:34.210]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.210]             }
[17:37:34.210]             {
[17:37:34.210]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.210]                   0L) {
[17:37:34.210]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.210]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.210]                   base::options(opts)
[17:37:34.210]                 }
[17:37:34.210]                 {
[17:37:34.210]                   {
[17:37:34.210]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:34.210]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:34.210]                     -1786728155L), envir = base::globalenv(), 
[17:37:34.210]                       inherits = FALSE)
[17:37:34.210]                     NULL
[17:37:34.210]                   }
[17:37:34.210]                   options(future.plan = NULL)
[17:37:34.210]                   if (is.na(NA_character_)) 
[17:37:34.210]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.210]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.210]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.210]                     .init = FALSE)
[17:37:34.210]                 }
[17:37:34.210]             }
[17:37:34.210]         }
[17:37:34.210]     })
[17:37:34.210]     if (TRUE) {
[17:37:34.210]         base::sink(type = "output", split = FALSE)
[17:37:34.210]         if (TRUE) {
[17:37:34.210]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.210]         }
[17:37:34.210]         else {
[17:37:34.210]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.210]         }
[17:37:34.210]         base::close(...future.stdout)
[17:37:34.210]         ...future.stdout <- NULL
[17:37:34.210]     }
[17:37:34.210]     ...future.result$conditions <- ...future.conditions
[17:37:34.210]     ...future.result$finished <- base::Sys.time()
[17:37:34.210]     ...future.result
[17:37:34.210] }
[17:37:34.212] assign_globals() ...
[17:37:34.212] List of 5
[17:37:34.212]  $ ...future.FUN            :function (C, k)  
[17:37:34.212]  $ MoreArgs                 : NULL
[17:37:34.212]  $ ...future.elements_ii    :List of 2
[17:37:34.212]   ..$ :List of 1
[17:37:34.212]   .. ..$ : chr "E"
[17:37:34.212]   ..$ :List of 1
[17:37:34.212]   .. ..$ : int 1
[17:37:34.212]  $ ...future.seeds_ii       : NULL
[17:37:34.212]  $ ...future.globals.maxSize: NULL
[17:37:34.212]  - attr(*, "where")=List of 5
[17:37:34.212]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.212]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.212]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.212]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.212]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.212]  - attr(*, "resolved")= logi FALSE
[17:37:34.212]  - attr(*, "total_size")= num 3488
[17:37:34.212]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.212]  - attr(*, "already-done")= logi TRUE
[17:37:34.217] - reassign environment for ‘...future.FUN’
[17:37:34.217] - copied ‘...future.FUN’ to environment
[17:37:34.217] - copied ‘MoreArgs’ to environment
[17:37:34.217] - copied ‘...future.elements_ii’ to environment
[17:37:34.217] - copied ‘...future.seeds_ii’ to environment
[17:37:34.217] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.217] assign_globals() ... done
[17:37:34.218] plan(): Setting new future strategy stack:
[17:37:34.218] List of future strategies:
[17:37:34.218] 1. sequential:
[17:37:34.218]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.218]    - tweaked: FALSE
[17:37:34.218]    - call: NULL
[17:37:34.218] plan(): nbrOfWorkers() = 1
[17:37:34.219] plan(): Setting new future strategy stack:
[17:37:34.219] List of future strategies:
[17:37:34.219] 1. sequential:
[17:37:34.219]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.219]    - tweaked: FALSE
[17:37:34.219]    - call: plan(strategy)
[17:37:34.219] plan(): nbrOfWorkers() = 1
[17:37:34.219] SequentialFuture started (and completed)
[17:37:34.220] - Launch lazy future ... done
[17:37:34.220] run() for ‘SequentialFuture’ ... done
[17:37:34.220] Created future:
[17:37:34.220] SequentialFuture:
[17:37:34.220] Label: ‘future_mapply-2’
[17:37:34.220] Expression:
[17:37:34.220] {
[17:37:34.220]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.220]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.220]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.220]         on.exit(options(oopts), add = TRUE)
[17:37:34.220]     }
[17:37:34.220]     {
[17:37:34.220]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.220]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.220]         do.call(mapply, args = args)
[17:37:34.220]     }
[17:37:34.220] }
[17:37:34.220] Lazy evaluation: FALSE
[17:37:34.220] Asynchronous evaluation: FALSE
[17:37:34.220] Local evaluation: TRUE
[17:37:34.220] Environment: R_GlobalEnv
[17:37:34.220] Capture standard output: TRUE
[17:37:34.220] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.220] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.220] Packages: <none>
[17:37:34.220] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.220] Resolved: TRUE
[17:37:34.220] Value: 112 bytes of class ‘list’
[17:37:34.220] Early signaling: FALSE
[17:37:34.220] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.220] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.221] Chunk #2 of 3 ... DONE
[17:37:34.221] Chunk #3 of 3 ...
[17:37:34.222]  - Finding globals in '...' for chunk #3 ...
[17:37:34.223] getGlobalsAndPackages() ...
[17:37:34.223] Searching for globals...
[17:37:34.223] 
[17:37:34.223] Searching for globals ... DONE
[17:37:34.223] - globals: [0] <none>
[17:37:34.223] getGlobalsAndPackages() ... DONE
[17:37:34.224]    + additional globals found: [n=0] 
[17:37:34.224]    + additional namespaces needed: [n=0] 
[17:37:34.224]  - Finding globals in '...' for chunk #3 ... DONE
[17:37:34.224]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:37:34.224]  - seeds: <none>
[17:37:34.224]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.224] getGlobalsAndPackages() ...
[17:37:34.224] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.224] Resolving globals: FALSE
[17:37:34.225] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:37:34.225] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:34.225] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.226] 
[17:37:34.226] getGlobalsAndPackages() ... DONE
[17:37:34.226] run() for ‘Future’ ...
[17:37:34.226] - state: ‘created’
[17:37:34.226] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.226] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.227] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.227]   - Field: ‘label’
[17:37:34.227]   - Field: ‘local’
[17:37:34.227]   - Field: ‘owner’
[17:37:34.227]   - Field: ‘envir’
[17:37:34.227]   - Field: ‘packages’
[17:37:34.227]   - Field: ‘gc’
[17:37:34.227]   - Field: ‘conditions’
[17:37:34.227]   - Field: ‘expr’
[17:37:34.227]   - Field: ‘uuid’
[17:37:34.227]   - Field: ‘seed’
[17:37:34.228]   - Field: ‘version’
[17:37:34.228]   - Field: ‘result’
[17:37:34.228]   - Field: ‘asynchronous’
[17:37:34.228]   - Field: ‘calls’
[17:37:34.228]   - Field: ‘globals’
[17:37:34.228]   - Field: ‘stdout’
[17:37:34.228]   - Field: ‘earlySignal’
[17:37:34.228]   - Field: ‘lazy’
[17:37:34.228]   - Field: ‘state’
[17:37:34.228] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.229] - Launch lazy future ...
[17:37:34.229] Packages needed by the future expression (n = 0): <none>
[17:37:34.229] Packages needed by future strategies (n = 0): <none>
[17:37:34.229] {
[17:37:34.229]     {
[17:37:34.229]         {
[17:37:34.229]             ...future.startTime <- base::Sys.time()
[17:37:34.229]             {
[17:37:34.229]                 {
[17:37:34.229]                   {
[17:37:34.229]                     base::local({
[17:37:34.229]                       has_future <- base::requireNamespace("future", 
[17:37:34.229]                         quietly = TRUE)
[17:37:34.229]                       if (has_future) {
[17:37:34.229]                         ns <- base::getNamespace("future")
[17:37:34.229]                         version <- ns[[".package"]][["version"]]
[17:37:34.229]                         if (is.null(version)) 
[17:37:34.229]                           version <- utils::packageVersion("future")
[17:37:34.229]                       }
[17:37:34.229]                       else {
[17:37:34.229]                         version <- NULL
[17:37:34.229]                       }
[17:37:34.229]                       if (!has_future || version < "1.8.0") {
[17:37:34.229]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.229]                           "", base::R.version$version.string), 
[17:37:34.229]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:34.229]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.229]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.229]                             "release", "version")], collapse = " "), 
[17:37:34.229]                           hostname = base::Sys.info()[["nodename"]])
[17:37:34.229]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.229]                           info)
[17:37:34.229]                         info <- base::paste(info, collapse = "; ")
[17:37:34.229]                         if (!has_future) {
[17:37:34.229]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.229]                             info)
[17:37:34.229]                         }
[17:37:34.229]                         else {
[17:37:34.229]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.229]                             info, version)
[17:37:34.229]                         }
[17:37:34.229]                         base::stop(msg)
[17:37:34.229]                       }
[17:37:34.229]                     })
[17:37:34.229]                   }
[17:37:34.229]                   ...future.strategy.old <- future::plan("list")
[17:37:34.229]                   options(future.plan = NULL)
[17:37:34.229]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.229]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.229]                 }
[17:37:34.229]                 ...future.workdir <- getwd()
[17:37:34.229]             }
[17:37:34.229]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.229]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.229]         }
[17:37:34.229]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.229]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:37:34.229]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.229]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.229]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.229]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.229]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.229]             base::names(...future.oldOptions))
[17:37:34.229]     }
[17:37:34.229]     if (FALSE) {
[17:37:34.229]     }
[17:37:34.229]     else {
[17:37:34.229]         if (TRUE) {
[17:37:34.229]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.229]                 open = "w")
[17:37:34.229]         }
[17:37:34.229]         else {
[17:37:34.229]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.229]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.229]         }
[17:37:34.229]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.229]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.229]             base::sink(type = "output", split = FALSE)
[17:37:34.229]             base::close(...future.stdout)
[17:37:34.229]         }, add = TRUE)
[17:37:34.229]     }
[17:37:34.229]     ...future.frame <- base::sys.nframe()
[17:37:34.229]     ...future.conditions <- base::list()
[17:37:34.229]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.229]     if (FALSE) {
[17:37:34.229]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.229]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.229]     }
[17:37:34.229]     ...future.result <- base::tryCatch({
[17:37:34.229]         base::withCallingHandlers({
[17:37:34.229]             ...future.value <- base::withVisible(base::local({
[17:37:34.229]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.229]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.229]                   ...future.globals.maxSize)) {
[17:37:34.229]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.229]                   on.exit(options(oopts), add = TRUE)
[17:37:34.229]                 }
[17:37:34.229]                 {
[17:37:34.229]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.229]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.229]                     USE.NAMES = FALSE)
[17:37:34.229]                   do.call(mapply, args = args)
[17:37:34.229]                 }
[17:37:34.229]             }))
[17:37:34.229]             future::FutureResult(value = ...future.value$value, 
[17:37:34.229]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.229]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.229]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.229]                     ...future.globalenv.names))
[17:37:34.229]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.229]         }, condition = base::local({
[17:37:34.229]             c <- base::c
[17:37:34.229]             inherits <- base::inherits
[17:37:34.229]             invokeRestart <- base::invokeRestart
[17:37:34.229]             length <- base::length
[17:37:34.229]             list <- base::list
[17:37:34.229]             seq.int <- base::seq.int
[17:37:34.229]             signalCondition <- base::signalCondition
[17:37:34.229]             sys.calls <- base::sys.calls
[17:37:34.229]             `[[` <- base::`[[`
[17:37:34.229]             `+` <- base::`+`
[17:37:34.229]             `<<-` <- base::`<<-`
[17:37:34.229]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.229]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.229]                   3L)]
[17:37:34.229]             }
[17:37:34.229]             function(cond) {
[17:37:34.229]                 is_error <- inherits(cond, "error")
[17:37:34.229]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.229]                   NULL)
[17:37:34.229]                 if (is_error) {
[17:37:34.229]                   sessionInformation <- function() {
[17:37:34.229]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.229]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.229]                       search = base::search(), system = base::Sys.info())
[17:37:34.229]                   }
[17:37:34.229]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.229]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.229]                     cond$call), session = sessionInformation(), 
[17:37:34.229]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.229]                   signalCondition(cond)
[17:37:34.229]                 }
[17:37:34.229]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.229]                 "immediateCondition"))) {
[17:37:34.229]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.229]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.229]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.229]                   if (TRUE && !signal) {
[17:37:34.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.229]                     {
[17:37:34.229]                       inherits <- base::inherits
[17:37:34.229]                       invokeRestart <- base::invokeRestart
[17:37:34.229]                       is.null <- base::is.null
[17:37:34.229]                       muffled <- FALSE
[17:37:34.229]                       if (inherits(cond, "message")) {
[17:37:34.229]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.229]                         if (muffled) 
[17:37:34.229]                           invokeRestart("muffleMessage")
[17:37:34.229]                       }
[17:37:34.229]                       else if (inherits(cond, "warning")) {
[17:37:34.229]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.229]                         if (muffled) 
[17:37:34.229]                           invokeRestart("muffleWarning")
[17:37:34.229]                       }
[17:37:34.229]                       else if (inherits(cond, "condition")) {
[17:37:34.229]                         if (!is.null(pattern)) {
[17:37:34.229]                           computeRestarts <- base::computeRestarts
[17:37:34.229]                           grepl <- base::grepl
[17:37:34.229]                           restarts <- computeRestarts(cond)
[17:37:34.229]                           for (restart in restarts) {
[17:37:34.229]                             name <- restart$name
[17:37:34.229]                             if (is.null(name)) 
[17:37:34.229]                               next
[17:37:34.229]                             if (!grepl(pattern, name)) 
[17:37:34.229]                               next
[17:37:34.229]                             invokeRestart(restart)
[17:37:34.229]                             muffled <- TRUE
[17:37:34.229]                             break
[17:37:34.229]                           }
[17:37:34.229]                         }
[17:37:34.229]                       }
[17:37:34.229]                       invisible(muffled)
[17:37:34.229]                     }
[17:37:34.229]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.229]                   }
[17:37:34.229]                 }
[17:37:34.229]                 else {
[17:37:34.229]                   if (TRUE) {
[17:37:34.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.229]                     {
[17:37:34.229]                       inherits <- base::inherits
[17:37:34.229]                       invokeRestart <- base::invokeRestart
[17:37:34.229]                       is.null <- base::is.null
[17:37:34.229]                       muffled <- FALSE
[17:37:34.229]                       if (inherits(cond, "message")) {
[17:37:34.229]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.229]                         if (muffled) 
[17:37:34.229]                           invokeRestart("muffleMessage")
[17:37:34.229]                       }
[17:37:34.229]                       else if (inherits(cond, "warning")) {
[17:37:34.229]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.229]                         if (muffled) 
[17:37:34.229]                           invokeRestart("muffleWarning")
[17:37:34.229]                       }
[17:37:34.229]                       else if (inherits(cond, "condition")) {
[17:37:34.229]                         if (!is.null(pattern)) {
[17:37:34.229]                           computeRestarts <- base::computeRestarts
[17:37:34.229]                           grepl <- base::grepl
[17:37:34.229]                           restarts <- computeRestarts(cond)
[17:37:34.229]                           for (restart in restarts) {
[17:37:34.229]                             name <- restart$name
[17:37:34.229]                             if (is.null(name)) 
[17:37:34.229]                               next
[17:37:34.229]                             if (!grepl(pattern, name)) 
[17:37:34.229]                               next
[17:37:34.229]                             invokeRestart(restart)
[17:37:34.229]                             muffled <- TRUE
[17:37:34.229]                             break
[17:37:34.229]                           }
[17:37:34.229]                         }
[17:37:34.229]                       }
[17:37:34.229]                       invisible(muffled)
[17:37:34.229]                     }
[17:37:34.229]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.229]                   }
[17:37:34.229]                 }
[17:37:34.229]             }
[17:37:34.229]         }))
[17:37:34.229]     }, error = function(ex) {
[17:37:34.229]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.229]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.229]                 ...future.rng), started = ...future.startTime, 
[17:37:34.229]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.229]             version = "1.8"), class = "FutureResult")
[17:37:34.229]     }, finally = {
[17:37:34.229]         if (!identical(...future.workdir, getwd())) 
[17:37:34.229]             setwd(...future.workdir)
[17:37:34.229]         {
[17:37:34.229]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.229]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.229]             }
[17:37:34.229]             base::options(...future.oldOptions)
[17:37:34.229]             if (.Platform$OS.type == "windows") {
[17:37:34.229]                 old_names <- names(...future.oldEnvVars)
[17:37:34.229]                 envs <- base::Sys.getenv()
[17:37:34.229]                 names <- names(envs)
[17:37:34.229]                 common <- intersect(names, old_names)
[17:37:34.229]                 added <- setdiff(names, old_names)
[17:37:34.229]                 removed <- setdiff(old_names, names)
[17:37:34.229]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.229]                   envs[common]]
[17:37:34.229]                 NAMES <- toupper(changed)
[17:37:34.229]                 args <- list()
[17:37:34.229]                 for (kk in seq_along(NAMES)) {
[17:37:34.229]                   name <- changed[[kk]]
[17:37:34.229]                   NAME <- NAMES[[kk]]
[17:37:34.229]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.229]                     next
[17:37:34.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.229]                 }
[17:37:34.229]                 NAMES <- toupper(added)
[17:37:34.229]                 for (kk in seq_along(NAMES)) {
[17:37:34.229]                   name <- added[[kk]]
[17:37:34.229]                   NAME <- NAMES[[kk]]
[17:37:34.229]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.229]                     next
[17:37:34.229]                   args[[name]] <- ""
[17:37:34.229]                 }
[17:37:34.229]                 NAMES <- toupper(removed)
[17:37:34.229]                 for (kk in seq_along(NAMES)) {
[17:37:34.229]                   name <- removed[[kk]]
[17:37:34.229]                   NAME <- NAMES[[kk]]
[17:37:34.229]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.229]                     next
[17:37:34.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.229]                 }
[17:37:34.229]                 if (length(args) > 0) 
[17:37:34.229]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.229]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.229]             }
[17:37:34.229]             else {
[17:37:34.229]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.229]             }
[17:37:34.229]             {
[17:37:34.229]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.229]                   0L) {
[17:37:34.229]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.229]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.229]                   base::options(opts)
[17:37:34.229]                 }
[17:37:34.229]                 {
[17:37:34.229]                   {
[17:37:34.229]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:34.229]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:34.229]                     -1786728155L), envir = base::globalenv(), 
[17:37:34.229]                       inherits = FALSE)
[17:37:34.229]                     NULL
[17:37:34.229]                   }
[17:37:34.229]                   options(future.plan = NULL)
[17:37:34.229]                   if (is.na(NA_character_)) 
[17:37:34.229]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.229]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.229]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.229]                     .init = FALSE)
[17:37:34.229]                 }
[17:37:34.229]             }
[17:37:34.229]         }
[17:37:34.229]     })
[17:37:34.229]     if (TRUE) {
[17:37:34.229]         base::sink(type = "output", split = FALSE)
[17:37:34.229]         if (TRUE) {
[17:37:34.229]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.229]         }
[17:37:34.229]         else {
[17:37:34.229]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.229]         }
[17:37:34.229]         base::close(...future.stdout)
[17:37:34.229]         ...future.stdout <- NULL
[17:37:34.229]     }
[17:37:34.229]     ...future.result$conditions <- ...future.conditions
[17:37:34.229]     ...future.result$finished <- base::Sys.time()
[17:37:34.229]     ...future.result
[17:37:34.229] }
[17:37:34.231] assign_globals() ...
[17:37:34.231] List of 5
[17:37:34.231]  $ ...future.FUN            :function (C, k)  
[17:37:34.231]  $ MoreArgs                 : NULL
[17:37:34.231]  $ ...future.elements_ii    :List of 2
[17:37:34.231]   ..$ :List of 2
[17:37:34.231]   .. ..$ : chr "A"
[17:37:34.231]   .. ..$ : chr "B"
[17:37:34.231]   ..$ :List of 2
[17:37:34.231]   .. ..$ : int 5
[17:37:34.231]   .. ..$ : int 4
[17:37:34.231]  $ ...future.seeds_ii       : NULL
[17:37:34.231]  $ ...future.globals.maxSize: NULL
[17:37:34.231]  - attr(*, "where")=List of 5
[17:37:34.231]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.231]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.231]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.231]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.231]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.231]  - attr(*, "resolved")= logi FALSE
[17:37:34.231]  - attr(*, "total_size")= num 3656
[17:37:34.231]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.231]  - attr(*, "already-done")= logi TRUE
[17:37:34.236] - reassign environment for ‘...future.FUN’
[17:37:34.236] - copied ‘...future.FUN’ to environment
[17:37:34.236] - copied ‘MoreArgs’ to environment
[17:37:34.237] - copied ‘...future.elements_ii’ to environment
[17:37:34.237] - copied ‘...future.seeds_ii’ to environment
[17:37:34.237] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.237] assign_globals() ... done
[17:37:34.237] plan(): Setting new future strategy stack:
[17:37:34.237] List of future strategies:
[17:37:34.237] 1. sequential:
[17:37:34.237]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.237]    - tweaked: FALSE
[17:37:34.237]    - call: NULL
[17:37:34.238] plan(): nbrOfWorkers() = 1
[17:37:34.238] plan(): Setting new future strategy stack:
[17:37:34.238] List of future strategies:
[17:37:34.238] 1. sequential:
[17:37:34.238]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.238]    - tweaked: FALSE
[17:37:34.238]    - call: plan(strategy)
[17:37:34.239] plan(): nbrOfWorkers() = 1
[17:37:34.239] SequentialFuture started (and completed)
[17:37:34.239] - Launch lazy future ... done
[17:37:34.239] run() for ‘SequentialFuture’ ... done
[17:37:34.239] Created future:
[17:37:34.239] SequentialFuture:
[17:37:34.239] Label: ‘future_mapply-3’
[17:37:34.239] Expression:
[17:37:34.239] {
[17:37:34.239]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.239]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.239]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.239]         on.exit(options(oopts), add = TRUE)
[17:37:34.239]     }
[17:37:34.239]     {
[17:37:34.239]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.239]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.239]         do.call(mapply, args = args)
[17:37:34.239]     }
[17:37:34.239] }
[17:37:34.239] Lazy evaluation: FALSE
[17:37:34.239] Asynchronous evaluation: FALSE
[17:37:34.239] Local evaluation: TRUE
[17:37:34.239] Environment: R_GlobalEnv
[17:37:34.239] Capture standard output: TRUE
[17:37:34.239] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.239] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.239] Packages: <none>
[17:37:34.239] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.239] Resolved: TRUE
[17:37:34.239] Value: 224 bytes of class ‘list’
[17:37:34.239] Early signaling: FALSE
[17:37:34.239] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.239] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.240] Chunk #3 of 3 ... DONE
[17:37:34.240] Launching 3 futures (chunks) ... DONE
[17:37:34.240] Resolving 3 futures (chunks) ...
[17:37:34.241] resolve() on list ...
[17:37:34.241]  recursive: 0
[17:37:34.241]  length: 3
[17:37:34.241] 
[17:37:34.241] resolved() for ‘SequentialFuture’ ...
[17:37:34.241] - state: ‘finished’
[17:37:34.241] - run: TRUE
[17:37:34.241] - result: ‘FutureResult’
[17:37:34.241] resolved() for ‘SequentialFuture’ ... done
[17:37:34.241] Future #1
[17:37:34.242] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:34.242] - nx: 3
[17:37:34.242] - relay: TRUE
[17:37:34.242] - stdout: TRUE
[17:37:34.242] - signal: TRUE
[17:37:34.242] - resignal: FALSE
[17:37:34.242] - force: TRUE
[17:37:34.242] - relayed: [n=3] FALSE, FALSE, FALSE
[17:37:34.242] - queued futures: [n=3] FALSE, FALSE, FALSE
[17:37:34.242]  - until=1
[17:37:34.242]  - relaying element #1
[17:37:34.243] - relayed: [n=3] TRUE, FALSE, FALSE
[17:37:34.243] - queued futures: [n=3] TRUE, FALSE, FALSE
[17:37:34.243] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:34.243]  length: 2 (resolved future 1)
[17:37:34.243] resolved() for ‘SequentialFuture’ ...
[17:37:34.243] - state: ‘finished’
[17:37:34.243] - run: TRUE
[17:37:34.243] - result: ‘FutureResult’
[17:37:34.243] resolved() for ‘SequentialFuture’ ... done
[17:37:34.243] Future #2
[17:37:34.244] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:37:34.244] - nx: 3
[17:37:34.244] - relay: TRUE
[17:37:34.244] - stdout: TRUE
[17:37:34.244] - signal: TRUE
[17:37:34.244] - resignal: FALSE
[17:37:34.244] - force: TRUE
[17:37:34.244] - relayed: [n=3] TRUE, FALSE, FALSE
[17:37:34.244] - queued futures: [n=3] TRUE, FALSE, FALSE
[17:37:34.244]  - until=2
[17:37:34.244]  - relaying element #2
[17:37:34.245] - relayed: [n=3] TRUE, TRUE, FALSE
[17:37:34.245] - queued futures: [n=3] TRUE, TRUE, FALSE
[17:37:34.245] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:37:34.245]  length: 1 (resolved future 2)
[17:37:34.245] resolved() for ‘SequentialFuture’ ...
[17:37:34.245] - state: ‘finished’
[17:37:34.245] - run: TRUE
[17:37:34.245] - result: ‘FutureResult’
[17:37:34.245] resolved() for ‘SequentialFuture’ ... done
[17:37:34.245] Future #3
[17:37:34.246] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:37:34.246] - nx: 3
[17:37:34.246] - relay: TRUE
[17:37:34.246] - stdout: TRUE
[17:37:34.246] - signal: TRUE
[17:37:34.246] - resignal: FALSE
[17:37:34.246] - force: TRUE
[17:37:34.246] - relayed: [n=3] TRUE, TRUE, FALSE
[17:37:34.246] - queued futures: [n=3] TRUE, TRUE, FALSE
[17:37:34.247]  - until=3
[17:37:34.247]  - relaying element #3
[17:37:34.247] - relayed: [n=3] TRUE, TRUE, TRUE
[17:37:34.247] - queued futures: [n=3] TRUE, TRUE, TRUE
[17:37:34.248] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:37:34.248]  length: 0 (resolved future 3)
[17:37:34.248] Relaying remaining futures
[17:37:34.250] signalConditionsASAP(NULL, pos=0) ...
[17:37:34.250] - nx: 3
[17:37:34.250] - relay: TRUE
[17:37:34.250] - stdout: TRUE
[17:37:34.251] - signal: TRUE
[17:37:34.251] - resignal: FALSE
[17:37:34.251] - force: TRUE
[17:37:34.251] - relayed: [n=3] TRUE, TRUE, TRUE
[17:37:34.251] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[17:37:34.251] - relayed: [n=3] TRUE, TRUE, TRUE
[17:37:34.252] - queued futures: [n=3] TRUE, TRUE, TRUE
[17:37:34.252] signalConditionsASAP(NULL, pos=0) ... done
[17:37:34.252] resolve() on list ... DONE
[17:37:34.252]  - Number of value chunks collected: 3
[17:37:34.252] Resolving 3 futures (chunks) ... DONE
[17:37:34.252] Reducing values from 3 chunks ...
[17:37:34.253]  - Number of values collected after concatenation: 5
[17:37:34.253]  - Number of values expected: 5
[17:37:34.253] Reverse index remapping (attribute 'ordering'): [n = 5] 4, 5, 1, 2, 3
[17:37:34.253] Reducing values from 3 chunks ... DONE
[17:37:34.253] future_mapply() ... DONE
[17:37:34.254] future_mapply() ...
[17:37:34.254] Number of chunks: 1
[17:37:34.254] getGlobalsAndPackagesXApply() ...
[17:37:34.254]  - future.globals: TRUE
[17:37:34.254] getGlobalsAndPackages() ...
[17:37:34.254] Searching for globals...
[17:37:34.256] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:37:34.256] Searching for globals ... DONE
[17:37:34.256] Resolving globals: FALSE
[17:37:34.256] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:37:34.257] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:37:34.257] - globals: [1] ‘FUN’
[17:37:34.257] 
[17:37:34.257] getGlobalsAndPackages() ... DONE
[17:37:34.257]  - globals found/used: [n=1] ‘FUN’
[17:37:34.257]  - needed namespaces: [n=0] 
[17:37:34.257] Finding globals ... DONE
[17:37:34.257] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:34.257] List of 2
[17:37:34.257]  $ ...future.FUN:function (C, k)  
[17:37:34.257]  $ MoreArgs     : list()
[17:37:34.257]  - attr(*, "where")=List of 2
[17:37:34.257]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:34.257]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:34.257]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.257]  - attr(*, "resolved")= logi FALSE
[17:37:34.257]  - attr(*, "total_size")= num NA
[17:37:34.260] Packages to be attached in all futures: [n=0] 
[17:37:34.260] getGlobalsAndPackagesXApply() ... DONE
[17:37:34.260] Number of futures (= number of chunks): 1
[17:37:34.260] Launching 1 futures (chunks) ...
[17:37:34.260] Chunk #1 of 1 ...
[17:37:34.261]  - Finding globals in '...' for chunk #1 ...
[17:37:34.261] getGlobalsAndPackages() ...
[17:37:34.261] Searching for globals...
[17:37:34.261] 
[17:37:34.261] Searching for globals ... DONE
[17:37:34.261] - globals: [0] <none>
[17:37:34.261] getGlobalsAndPackages() ... DONE
[17:37:34.261]    + additional globals found: [n=0] 
[17:37:34.262]    + additional namespaces needed: [n=0] 
[17:37:34.262]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:34.262]  - seeds: <none>
[17:37:34.262]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.262] getGlobalsAndPackages() ...
[17:37:34.262] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.262] Resolving globals: FALSE
[17:37:34.263] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[17:37:34.263] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:34.263] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.263] 
[17:37:34.263] getGlobalsAndPackages() ... DONE
[17:37:34.264] run() for ‘Future’ ...
[17:37:34.264] - state: ‘created’
[17:37:34.264] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.264] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.264] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.264]   - Field: ‘label’
[17:37:34.264]   - Field: ‘local’
[17:37:34.265]   - Field: ‘owner’
[17:37:34.265]   - Field: ‘envir’
[17:37:34.265]   - Field: ‘packages’
[17:37:34.265]   - Field: ‘gc’
[17:37:34.265]   - Field: ‘conditions’
[17:37:34.265]   - Field: ‘expr’
[17:37:34.265]   - Field: ‘uuid’
[17:37:34.265]   - Field: ‘seed’
[17:37:34.265]   - Field: ‘version’
[17:37:34.265]   - Field: ‘result’
[17:37:34.265]   - Field: ‘asynchronous’
[17:37:34.266]   - Field: ‘calls’
[17:37:34.266]   - Field: ‘globals’
[17:37:34.266]   - Field: ‘stdout’
[17:37:34.266]   - Field: ‘earlySignal’
[17:37:34.266]   - Field: ‘lazy’
[17:37:34.266]   - Field: ‘state’
[17:37:34.266] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.266] - Launch lazy future ...
[17:37:34.266] Packages needed by the future expression (n = 0): <none>
[17:37:34.266] Packages needed by future strategies (n = 0): <none>
[17:37:34.267] {
[17:37:34.267]     {
[17:37:34.267]         {
[17:37:34.267]             ...future.startTime <- base::Sys.time()
[17:37:34.267]             {
[17:37:34.267]                 {
[17:37:34.267]                   {
[17:37:34.267]                     base::local({
[17:37:34.267]                       has_future <- base::requireNamespace("future", 
[17:37:34.267]                         quietly = TRUE)
[17:37:34.267]                       if (has_future) {
[17:37:34.267]                         ns <- base::getNamespace("future")
[17:37:34.267]                         version <- ns[[".package"]][["version"]]
[17:37:34.267]                         if (is.null(version)) 
[17:37:34.267]                           version <- utils::packageVersion("future")
[17:37:34.267]                       }
[17:37:34.267]                       else {
[17:37:34.267]                         version <- NULL
[17:37:34.267]                       }
[17:37:34.267]                       if (!has_future || version < "1.8.0") {
[17:37:34.267]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.267]                           "", base::R.version$version.string), 
[17:37:34.267]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:34.267]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.267]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.267]                             "release", "version")], collapse = " "), 
[17:37:34.267]                           hostname = base::Sys.info()[["nodename"]])
[17:37:34.267]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.267]                           info)
[17:37:34.267]                         info <- base::paste(info, collapse = "; ")
[17:37:34.267]                         if (!has_future) {
[17:37:34.267]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.267]                             info)
[17:37:34.267]                         }
[17:37:34.267]                         else {
[17:37:34.267]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.267]                             info, version)
[17:37:34.267]                         }
[17:37:34.267]                         base::stop(msg)
[17:37:34.267]                       }
[17:37:34.267]                     })
[17:37:34.267]                   }
[17:37:34.267]                   ...future.strategy.old <- future::plan("list")
[17:37:34.267]                   options(future.plan = NULL)
[17:37:34.267]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.267]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.267]                 }
[17:37:34.267]                 ...future.workdir <- getwd()
[17:37:34.267]             }
[17:37:34.267]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.267]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.267]         }
[17:37:34.267]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.267]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:34.267]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.267]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.267]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.267]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.267]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.267]             base::names(...future.oldOptions))
[17:37:34.267]     }
[17:37:34.267]     if (FALSE) {
[17:37:34.267]     }
[17:37:34.267]     else {
[17:37:34.267]         if (TRUE) {
[17:37:34.267]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.267]                 open = "w")
[17:37:34.267]         }
[17:37:34.267]         else {
[17:37:34.267]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.267]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.267]         }
[17:37:34.267]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.267]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.267]             base::sink(type = "output", split = FALSE)
[17:37:34.267]             base::close(...future.stdout)
[17:37:34.267]         }, add = TRUE)
[17:37:34.267]     }
[17:37:34.267]     ...future.frame <- base::sys.nframe()
[17:37:34.267]     ...future.conditions <- base::list()
[17:37:34.267]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.267]     if (FALSE) {
[17:37:34.267]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.267]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.267]     }
[17:37:34.267]     ...future.result <- base::tryCatch({
[17:37:34.267]         base::withCallingHandlers({
[17:37:34.267]             ...future.value <- base::withVisible(base::local({
[17:37:34.267]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.267]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.267]                   ...future.globals.maxSize)) {
[17:37:34.267]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.267]                   on.exit(options(oopts), add = TRUE)
[17:37:34.267]                 }
[17:37:34.267]                 {
[17:37:34.267]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.267]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.267]                     USE.NAMES = FALSE)
[17:37:34.267]                   do.call(mapply, args = args)
[17:37:34.267]                 }
[17:37:34.267]             }))
[17:37:34.267]             future::FutureResult(value = ...future.value$value, 
[17:37:34.267]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.267]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.267]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.267]                     ...future.globalenv.names))
[17:37:34.267]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.267]         }, condition = base::local({
[17:37:34.267]             c <- base::c
[17:37:34.267]             inherits <- base::inherits
[17:37:34.267]             invokeRestart <- base::invokeRestart
[17:37:34.267]             length <- base::length
[17:37:34.267]             list <- base::list
[17:37:34.267]             seq.int <- base::seq.int
[17:37:34.267]             signalCondition <- base::signalCondition
[17:37:34.267]             sys.calls <- base::sys.calls
[17:37:34.267]             `[[` <- base::`[[`
[17:37:34.267]             `+` <- base::`+`
[17:37:34.267]             `<<-` <- base::`<<-`
[17:37:34.267]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.267]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.267]                   3L)]
[17:37:34.267]             }
[17:37:34.267]             function(cond) {
[17:37:34.267]                 is_error <- inherits(cond, "error")
[17:37:34.267]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.267]                   NULL)
[17:37:34.267]                 if (is_error) {
[17:37:34.267]                   sessionInformation <- function() {
[17:37:34.267]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.267]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.267]                       search = base::search(), system = base::Sys.info())
[17:37:34.267]                   }
[17:37:34.267]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.267]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.267]                     cond$call), session = sessionInformation(), 
[17:37:34.267]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.267]                   signalCondition(cond)
[17:37:34.267]                 }
[17:37:34.267]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.267]                 "immediateCondition"))) {
[17:37:34.267]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.267]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.267]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.267]                   if (TRUE && !signal) {
[17:37:34.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.267]                     {
[17:37:34.267]                       inherits <- base::inherits
[17:37:34.267]                       invokeRestart <- base::invokeRestart
[17:37:34.267]                       is.null <- base::is.null
[17:37:34.267]                       muffled <- FALSE
[17:37:34.267]                       if (inherits(cond, "message")) {
[17:37:34.267]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.267]                         if (muffled) 
[17:37:34.267]                           invokeRestart("muffleMessage")
[17:37:34.267]                       }
[17:37:34.267]                       else if (inherits(cond, "warning")) {
[17:37:34.267]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.267]                         if (muffled) 
[17:37:34.267]                           invokeRestart("muffleWarning")
[17:37:34.267]                       }
[17:37:34.267]                       else if (inherits(cond, "condition")) {
[17:37:34.267]                         if (!is.null(pattern)) {
[17:37:34.267]                           computeRestarts <- base::computeRestarts
[17:37:34.267]                           grepl <- base::grepl
[17:37:34.267]                           restarts <- computeRestarts(cond)
[17:37:34.267]                           for (restart in restarts) {
[17:37:34.267]                             name <- restart$name
[17:37:34.267]                             if (is.null(name)) 
[17:37:34.267]                               next
[17:37:34.267]                             if (!grepl(pattern, name)) 
[17:37:34.267]                               next
[17:37:34.267]                             invokeRestart(restart)
[17:37:34.267]                             muffled <- TRUE
[17:37:34.267]                             break
[17:37:34.267]                           }
[17:37:34.267]                         }
[17:37:34.267]                       }
[17:37:34.267]                       invisible(muffled)
[17:37:34.267]                     }
[17:37:34.267]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.267]                   }
[17:37:34.267]                 }
[17:37:34.267]                 else {
[17:37:34.267]                   if (TRUE) {
[17:37:34.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.267]                     {
[17:37:34.267]                       inherits <- base::inherits
[17:37:34.267]                       invokeRestart <- base::invokeRestart
[17:37:34.267]                       is.null <- base::is.null
[17:37:34.267]                       muffled <- FALSE
[17:37:34.267]                       if (inherits(cond, "message")) {
[17:37:34.267]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.267]                         if (muffled) 
[17:37:34.267]                           invokeRestart("muffleMessage")
[17:37:34.267]                       }
[17:37:34.267]                       else if (inherits(cond, "warning")) {
[17:37:34.267]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.267]                         if (muffled) 
[17:37:34.267]                           invokeRestart("muffleWarning")
[17:37:34.267]                       }
[17:37:34.267]                       else if (inherits(cond, "condition")) {
[17:37:34.267]                         if (!is.null(pattern)) {
[17:37:34.267]                           computeRestarts <- base::computeRestarts
[17:37:34.267]                           grepl <- base::grepl
[17:37:34.267]                           restarts <- computeRestarts(cond)
[17:37:34.267]                           for (restart in restarts) {
[17:37:34.267]                             name <- restart$name
[17:37:34.267]                             if (is.null(name)) 
[17:37:34.267]                               next
[17:37:34.267]                             if (!grepl(pattern, name)) 
[17:37:34.267]                               next
[17:37:34.267]                             invokeRestart(restart)
[17:37:34.267]                             muffled <- TRUE
[17:37:34.267]                             break
[17:37:34.267]                           }
[17:37:34.267]                         }
[17:37:34.267]                       }
[17:37:34.267]                       invisible(muffled)
[17:37:34.267]                     }
[17:37:34.267]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.267]                   }
[17:37:34.267]                 }
[17:37:34.267]             }
[17:37:34.267]         }))
[17:37:34.267]     }, error = function(ex) {
[17:37:34.267]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.267]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.267]                 ...future.rng), started = ...future.startTime, 
[17:37:34.267]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.267]             version = "1.8"), class = "FutureResult")
[17:37:34.267]     }, finally = {
[17:37:34.267]         if (!identical(...future.workdir, getwd())) 
[17:37:34.267]             setwd(...future.workdir)
[17:37:34.267]         {
[17:37:34.267]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.267]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.267]             }
[17:37:34.267]             base::options(...future.oldOptions)
[17:37:34.267]             if (.Platform$OS.type == "windows") {
[17:37:34.267]                 old_names <- names(...future.oldEnvVars)
[17:37:34.267]                 envs <- base::Sys.getenv()
[17:37:34.267]                 names <- names(envs)
[17:37:34.267]                 common <- intersect(names, old_names)
[17:37:34.267]                 added <- setdiff(names, old_names)
[17:37:34.267]                 removed <- setdiff(old_names, names)
[17:37:34.267]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.267]                   envs[common]]
[17:37:34.267]                 NAMES <- toupper(changed)
[17:37:34.267]                 args <- list()
[17:37:34.267]                 for (kk in seq_along(NAMES)) {
[17:37:34.267]                   name <- changed[[kk]]
[17:37:34.267]                   NAME <- NAMES[[kk]]
[17:37:34.267]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.267]                     next
[17:37:34.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.267]                 }
[17:37:34.267]                 NAMES <- toupper(added)
[17:37:34.267]                 for (kk in seq_along(NAMES)) {
[17:37:34.267]                   name <- added[[kk]]
[17:37:34.267]                   NAME <- NAMES[[kk]]
[17:37:34.267]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.267]                     next
[17:37:34.267]                   args[[name]] <- ""
[17:37:34.267]                 }
[17:37:34.267]                 NAMES <- toupper(removed)
[17:37:34.267]                 for (kk in seq_along(NAMES)) {
[17:37:34.267]                   name <- removed[[kk]]
[17:37:34.267]                   NAME <- NAMES[[kk]]
[17:37:34.267]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.267]                     next
[17:37:34.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.267]                 }
[17:37:34.267]                 if (length(args) > 0) 
[17:37:34.267]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.267]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.267]             }
[17:37:34.267]             else {
[17:37:34.267]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.267]             }
[17:37:34.267]             {
[17:37:34.267]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.267]                   0L) {
[17:37:34.267]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.267]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.267]                   base::options(opts)
[17:37:34.267]                 }
[17:37:34.267]                 {
[17:37:34.267]                   {
[17:37:34.267]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:34.267]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:34.267]                     -1786728155L), envir = base::globalenv(), 
[17:37:34.267]                       inherits = FALSE)
[17:37:34.267]                     NULL
[17:37:34.267]                   }
[17:37:34.267]                   options(future.plan = NULL)
[17:37:34.267]                   if (is.na(NA_character_)) 
[17:37:34.267]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.267]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.267]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.267]                     .init = FALSE)
[17:37:34.267]                 }
[17:37:34.267]             }
[17:37:34.267]         }
[17:37:34.267]     })
[17:37:34.267]     if (TRUE) {
[17:37:34.267]         base::sink(type = "output", split = FALSE)
[17:37:34.267]         if (TRUE) {
[17:37:34.267]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.267]         }
[17:37:34.267]         else {
[17:37:34.267]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.267]         }
[17:37:34.267]         base::close(...future.stdout)
[17:37:34.267]         ...future.stdout <- NULL
[17:37:34.267]     }
[17:37:34.267]     ...future.result$conditions <- ...future.conditions
[17:37:34.267]     ...future.result$finished <- base::Sys.time()
[17:37:34.267]     ...future.result
[17:37:34.267] }
[17:37:34.269] assign_globals() ...
[17:37:34.269] List of 5
[17:37:34.269]  $ ...future.FUN            :function (C, k)  
[17:37:34.269]  $ MoreArgs                 : list()
[17:37:34.269]  $ ...future.elements_ii    :List of 2
[17:37:34.269]   ..$ :List of 5
[17:37:34.269]   .. ..$ : chr "A"
[17:37:34.269]   .. ..$ : chr "B"
[17:37:34.269]   .. ..$ : chr "C"
[17:37:34.269]   .. ..$ : chr "D"
[17:37:34.269]   .. ..$ : chr "E"
[17:37:34.269]   ..$ :List of 5
[17:37:34.269]   .. ..$ : int 5
[17:37:34.269]   .. ..$ : int 4
[17:37:34.269]   .. ..$ : int 3
[17:37:34.269]   .. ..$ : int 2
[17:37:34.269]   .. ..$ : int 1
[17:37:34.269]  $ ...future.seeds_ii       : NULL
[17:37:34.269]  $ ...future.globals.maxSize: NULL
[17:37:34.269]  - attr(*, "where")=List of 5
[17:37:34.269]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.269]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.269]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.269]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.269]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.269]  - attr(*, "resolved")= logi FALSE
[17:37:34.269]  - attr(*, "total_size")= num 4160
[17:37:34.269]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.269]  - attr(*, "already-done")= logi TRUE
[17:37:34.277] - reassign environment for ‘...future.FUN’
[17:37:34.277] - copied ‘...future.FUN’ to environment
[17:37:34.277] - copied ‘MoreArgs’ to environment
[17:37:34.277] - copied ‘...future.elements_ii’ to environment
[17:37:34.277] - copied ‘...future.seeds_ii’ to environment
[17:37:34.277] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.277] assign_globals() ... done
[17:37:34.278] plan(): Setting new future strategy stack:
[17:37:34.278] List of future strategies:
[17:37:34.278] 1. sequential:
[17:37:34.278]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.278]    - tweaked: FALSE
[17:37:34.278]    - call: NULL
[17:37:34.278] plan(): nbrOfWorkers() = 1
[17:37:34.279] plan(): Setting new future strategy stack:
[17:37:34.279] List of future strategies:
[17:37:34.279] 1. sequential:
[17:37:34.279]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.279]    - tweaked: FALSE
[17:37:34.279]    - call: plan(strategy)
[17:37:34.280] plan(): nbrOfWorkers() = 1
[17:37:34.280] SequentialFuture started (and completed)
[17:37:34.280] - Launch lazy future ... done
[17:37:34.280] run() for ‘SequentialFuture’ ... done
[17:37:34.280] Created future:
[17:37:34.280] SequentialFuture:
[17:37:34.280] Label: ‘future_.mapply-1’
[17:37:34.280] Expression:
[17:37:34.280] {
[17:37:34.280]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.280]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.280]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.280]         on.exit(options(oopts), add = TRUE)
[17:37:34.280]     }
[17:37:34.280]     {
[17:37:34.280]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.280]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.280]         do.call(mapply, args = args)
[17:37:34.280]     }
[17:37:34.280] }
[17:37:34.280] Lazy evaluation: FALSE
[17:37:34.280] Asynchronous evaluation: FALSE
[17:37:34.280] Local evaluation: TRUE
[17:37:34.280] Environment: R_GlobalEnv
[17:37:34.280] Capture standard output: TRUE
[17:37:34.280] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.280] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.280] Packages: <none>
[17:37:34.280] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.280] Resolved: TRUE
[17:37:34.280] Value: 560 bytes of class ‘list’
[17:37:34.280] Early signaling: FALSE
[17:37:34.280] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.280] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.281] Chunk #1 of 1 ... DONE
[17:37:34.281] Launching 1 futures (chunks) ... DONE
[17:37:34.281] Resolving 1 futures (chunks) ...
[17:37:34.281] resolve() on list ...
[17:37:34.281]  recursive: 0
[17:37:34.282]  length: 1
[17:37:34.282] 
[17:37:34.282] resolved() for ‘SequentialFuture’ ...
[17:37:34.282] - state: ‘finished’
[17:37:34.282] - run: TRUE
[17:37:34.282] - result: ‘FutureResult’
[17:37:34.282] resolved() for ‘SequentialFuture’ ... done
[17:37:34.282] Future #1
[17:37:34.282] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:34.282] - nx: 1
[17:37:34.283] - relay: TRUE
[17:37:34.283] - stdout: TRUE
[17:37:34.283] - signal: TRUE
[17:37:34.283] - resignal: FALSE
[17:37:34.283] - force: TRUE
[17:37:34.283] - relayed: [n=1] FALSE
[17:37:34.283] - queued futures: [n=1] FALSE
[17:37:34.283]  - until=1
[17:37:34.283]  - relaying element #1
[17:37:34.283] - relayed: [n=1] TRUE
[17:37:34.283] - queued futures: [n=1] TRUE
[17:37:34.284] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:34.284]  length: 0 (resolved future 1)
[17:37:34.284] Relaying remaining futures
[17:37:34.284] signalConditionsASAP(NULL, pos=0) ...
[17:37:34.284] - nx: 1
[17:37:34.284] - relay: TRUE
[17:37:34.284] - stdout: TRUE
[17:37:34.284] - signal: TRUE
[17:37:34.284] - resignal: FALSE
[17:37:34.284] - force: TRUE
[17:37:34.284] - relayed: [n=1] TRUE
[17:37:34.285] - queued futures: [n=1] TRUE
 - flush all
[17:37:34.285] - relayed: [n=1] TRUE
[17:37:34.285] - queued futures: [n=1] TRUE
[17:37:34.285] signalConditionsASAP(NULL, pos=0) ... done
[17:37:34.285] resolve() on list ... DONE
[17:37:34.285]  - Number of value chunks collected: 1
[17:37:34.285] Resolving 1 futures (chunks) ... DONE
[17:37:34.285] Reducing values from 1 chunks ...
[17:37:34.285]  - Number of values collected after concatenation: 5
[17:37:34.285]  - Number of values expected: 5
[17:37:34.286] Reducing values from 1 chunks ... DONE
[17:37:34.286] future_mapply() ... DONE
[17:37:34.286] future_mapply() ...
[17:37:34.286] Number of chunks: 2
[17:37:34.286] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[17:37:34.286] getGlobalsAndPackagesXApply() ...
[17:37:34.286]  - future.globals: TRUE
[17:37:34.287] getGlobalsAndPackages() ...
[17:37:34.287] Searching for globals...
[17:37:34.288] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:37:34.288] Searching for globals ... DONE
[17:37:34.288] Resolving globals: FALSE
[17:37:34.288] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:37:34.289] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:37:34.289] - globals: [1] ‘FUN’
[17:37:34.289] 
[17:37:34.289] getGlobalsAndPackages() ... DONE
[17:37:34.289]  - globals found/used: [n=1] ‘FUN’
[17:37:34.289]  - needed namespaces: [n=0] 
[17:37:34.289] Finding globals ... DONE
[17:37:34.289] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:34.290] List of 2
[17:37:34.290]  $ ...future.FUN:function (C, k)  
[17:37:34.290]  $ MoreArgs     : NULL
[17:37:34.290]  - attr(*, "where")=List of 2
[17:37:34.290]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:34.290]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:34.290]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.290]  - attr(*, "resolved")= logi FALSE
[17:37:34.290]  - attr(*, "total_size")= num NA
[17:37:34.292] Packages to be attached in all futures: [n=0] 
[17:37:34.292] getGlobalsAndPackagesXApply() ... DONE
[17:37:34.292] Number of futures (= number of chunks): 2
[17:37:34.292] Launching 2 futures (chunks) ...
[17:37:34.292] Chunk #1 of 2 ...
[17:37:34.293]  - Finding globals in '...' for chunk #1 ...
[17:37:34.293] getGlobalsAndPackages() ...
[17:37:34.293] Searching for globals...
[17:37:34.293] 
[17:37:34.293] Searching for globals ... DONE
[17:37:34.293] - globals: [0] <none>
[17:37:34.293] getGlobalsAndPackages() ... DONE
[17:37:34.293]    + additional globals found: [n=0] 
[17:37:34.293]    + additional namespaces needed: [n=0] 
[17:37:34.294]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:34.294]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:34.294]  - seeds: <none>
[17:37:34.294]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.294] getGlobalsAndPackages() ...
[17:37:34.294] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.294] Resolving globals: FALSE
[17:37:34.295] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:37:34.295] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:34.295] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.295] 
[17:37:34.295] getGlobalsAndPackages() ... DONE
[17:37:34.296] run() for ‘Future’ ...
[17:37:34.296] - state: ‘created’
[17:37:34.296] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.296] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.296] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.296]   - Field: ‘label’
[17:37:34.296]   - Field: ‘local’
[17:37:34.296]   - Field: ‘owner’
[17:37:34.297]   - Field: ‘envir’
[17:37:34.297]   - Field: ‘packages’
[17:37:34.297]   - Field: ‘gc’
[17:37:34.297]   - Field: ‘conditions’
[17:37:34.297]   - Field: ‘expr’
[17:37:34.297]   - Field: ‘uuid’
[17:37:34.297]   - Field: ‘seed’
[17:37:34.297]   - Field: ‘version’
[17:37:34.297]   - Field: ‘result’
[17:37:34.297]   - Field: ‘asynchronous’
[17:37:34.297]   - Field: ‘calls’
[17:37:34.298]   - Field: ‘globals’
[17:37:34.298]   - Field: ‘stdout’
[17:37:34.298]   - Field: ‘earlySignal’
[17:37:34.298]   - Field: ‘lazy’
[17:37:34.298]   - Field: ‘state’
[17:37:34.298] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.298] - Launch lazy future ...
[17:37:34.298] Packages needed by the future expression (n = 0): <none>
[17:37:34.298] Packages needed by future strategies (n = 0): <none>
[17:37:34.299] {
[17:37:34.299]     {
[17:37:34.299]         {
[17:37:34.299]             ...future.startTime <- base::Sys.time()
[17:37:34.299]             {
[17:37:34.299]                 {
[17:37:34.299]                   {
[17:37:34.299]                     base::local({
[17:37:34.299]                       has_future <- base::requireNamespace("future", 
[17:37:34.299]                         quietly = TRUE)
[17:37:34.299]                       if (has_future) {
[17:37:34.299]                         ns <- base::getNamespace("future")
[17:37:34.299]                         version <- ns[[".package"]][["version"]]
[17:37:34.299]                         if (is.null(version)) 
[17:37:34.299]                           version <- utils::packageVersion("future")
[17:37:34.299]                       }
[17:37:34.299]                       else {
[17:37:34.299]                         version <- NULL
[17:37:34.299]                       }
[17:37:34.299]                       if (!has_future || version < "1.8.0") {
[17:37:34.299]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.299]                           "", base::R.version$version.string), 
[17:37:34.299]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:34.299]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.299]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.299]                             "release", "version")], collapse = " "), 
[17:37:34.299]                           hostname = base::Sys.info()[["nodename"]])
[17:37:34.299]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.299]                           info)
[17:37:34.299]                         info <- base::paste(info, collapse = "; ")
[17:37:34.299]                         if (!has_future) {
[17:37:34.299]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.299]                             info)
[17:37:34.299]                         }
[17:37:34.299]                         else {
[17:37:34.299]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.299]                             info, version)
[17:37:34.299]                         }
[17:37:34.299]                         base::stop(msg)
[17:37:34.299]                       }
[17:37:34.299]                     })
[17:37:34.299]                   }
[17:37:34.299]                   ...future.strategy.old <- future::plan("list")
[17:37:34.299]                   options(future.plan = NULL)
[17:37:34.299]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.299]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.299]                 }
[17:37:34.299]                 ...future.workdir <- getwd()
[17:37:34.299]             }
[17:37:34.299]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.299]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.299]         }
[17:37:34.299]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.299]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:34.299]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.299]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.299]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.299]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.299]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.299]             base::names(...future.oldOptions))
[17:37:34.299]     }
[17:37:34.299]     if (FALSE) {
[17:37:34.299]     }
[17:37:34.299]     else {
[17:37:34.299]         if (TRUE) {
[17:37:34.299]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.299]                 open = "w")
[17:37:34.299]         }
[17:37:34.299]         else {
[17:37:34.299]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.299]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.299]         }
[17:37:34.299]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.299]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.299]             base::sink(type = "output", split = FALSE)
[17:37:34.299]             base::close(...future.stdout)
[17:37:34.299]         }, add = TRUE)
[17:37:34.299]     }
[17:37:34.299]     ...future.frame <- base::sys.nframe()
[17:37:34.299]     ...future.conditions <- base::list()
[17:37:34.299]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.299]     if (FALSE) {
[17:37:34.299]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.299]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.299]     }
[17:37:34.299]     ...future.result <- base::tryCatch({
[17:37:34.299]         base::withCallingHandlers({
[17:37:34.299]             ...future.value <- base::withVisible(base::local({
[17:37:34.299]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.299]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.299]                   ...future.globals.maxSize)) {
[17:37:34.299]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.299]                   on.exit(options(oopts), add = TRUE)
[17:37:34.299]                 }
[17:37:34.299]                 {
[17:37:34.299]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.299]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.299]                     USE.NAMES = FALSE)
[17:37:34.299]                   do.call(mapply, args = args)
[17:37:34.299]                 }
[17:37:34.299]             }))
[17:37:34.299]             future::FutureResult(value = ...future.value$value, 
[17:37:34.299]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.299]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.299]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.299]                     ...future.globalenv.names))
[17:37:34.299]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.299]         }, condition = base::local({
[17:37:34.299]             c <- base::c
[17:37:34.299]             inherits <- base::inherits
[17:37:34.299]             invokeRestart <- base::invokeRestart
[17:37:34.299]             length <- base::length
[17:37:34.299]             list <- base::list
[17:37:34.299]             seq.int <- base::seq.int
[17:37:34.299]             signalCondition <- base::signalCondition
[17:37:34.299]             sys.calls <- base::sys.calls
[17:37:34.299]             `[[` <- base::`[[`
[17:37:34.299]             `+` <- base::`+`
[17:37:34.299]             `<<-` <- base::`<<-`
[17:37:34.299]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.299]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.299]                   3L)]
[17:37:34.299]             }
[17:37:34.299]             function(cond) {
[17:37:34.299]                 is_error <- inherits(cond, "error")
[17:37:34.299]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.299]                   NULL)
[17:37:34.299]                 if (is_error) {
[17:37:34.299]                   sessionInformation <- function() {
[17:37:34.299]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.299]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.299]                       search = base::search(), system = base::Sys.info())
[17:37:34.299]                   }
[17:37:34.299]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.299]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.299]                     cond$call), session = sessionInformation(), 
[17:37:34.299]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.299]                   signalCondition(cond)
[17:37:34.299]                 }
[17:37:34.299]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.299]                 "immediateCondition"))) {
[17:37:34.299]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.299]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.299]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.299]                   if (TRUE && !signal) {
[17:37:34.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.299]                     {
[17:37:34.299]                       inherits <- base::inherits
[17:37:34.299]                       invokeRestart <- base::invokeRestart
[17:37:34.299]                       is.null <- base::is.null
[17:37:34.299]                       muffled <- FALSE
[17:37:34.299]                       if (inherits(cond, "message")) {
[17:37:34.299]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.299]                         if (muffled) 
[17:37:34.299]                           invokeRestart("muffleMessage")
[17:37:34.299]                       }
[17:37:34.299]                       else if (inherits(cond, "warning")) {
[17:37:34.299]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.299]                         if (muffled) 
[17:37:34.299]                           invokeRestart("muffleWarning")
[17:37:34.299]                       }
[17:37:34.299]                       else if (inherits(cond, "condition")) {
[17:37:34.299]                         if (!is.null(pattern)) {
[17:37:34.299]                           computeRestarts <- base::computeRestarts
[17:37:34.299]                           grepl <- base::grepl
[17:37:34.299]                           restarts <- computeRestarts(cond)
[17:37:34.299]                           for (restart in restarts) {
[17:37:34.299]                             name <- restart$name
[17:37:34.299]                             if (is.null(name)) 
[17:37:34.299]                               next
[17:37:34.299]                             if (!grepl(pattern, name)) 
[17:37:34.299]                               next
[17:37:34.299]                             invokeRestart(restart)
[17:37:34.299]                             muffled <- TRUE
[17:37:34.299]                             break
[17:37:34.299]                           }
[17:37:34.299]                         }
[17:37:34.299]                       }
[17:37:34.299]                       invisible(muffled)
[17:37:34.299]                     }
[17:37:34.299]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.299]                   }
[17:37:34.299]                 }
[17:37:34.299]                 else {
[17:37:34.299]                   if (TRUE) {
[17:37:34.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.299]                     {
[17:37:34.299]                       inherits <- base::inherits
[17:37:34.299]                       invokeRestart <- base::invokeRestart
[17:37:34.299]                       is.null <- base::is.null
[17:37:34.299]                       muffled <- FALSE
[17:37:34.299]                       if (inherits(cond, "message")) {
[17:37:34.299]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.299]                         if (muffled) 
[17:37:34.299]                           invokeRestart("muffleMessage")
[17:37:34.299]                       }
[17:37:34.299]                       else if (inherits(cond, "warning")) {
[17:37:34.299]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.299]                         if (muffled) 
[17:37:34.299]                           invokeRestart("muffleWarning")
[17:37:34.299]                       }
[17:37:34.299]                       else if (inherits(cond, "condition")) {
[17:37:34.299]                         if (!is.null(pattern)) {
[17:37:34.299]                           computeRestarts <- base::computeRestarts
[17:37:34.299]                           grepl <- base::grepl
[17:37:34.299]                           restarts <- computeRestarts(cond)
[17:37:34.299]                           for (restart in restarts) {
[17:37:34.299]                             name <- restart$name
[17:37:34.299]                             if (is.null(name)) 
[17:37:34.299]                               next
[17:37:34.299]                             if (!grepl(pattern, name)) 
[17:37:34.299]                               next
[17:37:34.299]                             invokeRestart(restart)
[17:37:34.299]                             muffled <- TRUE
[17:37:34.299]                             break
[17:37:34.299]                           }
[17:37:34.299]                         }
[17:37:34.299]                       }
[17:37:34.299]                       invisible(muffled)
[17:37:34.299]                     }
[17:37:34.299]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.299]                   }
[17:37:34.299]                 }
[17:37:34.299]             }
[17:37:34.299]         }))
[17:37:34.299]     }, error = function(ex) {
[17:37:34.299]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.299]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.299]                 ...future.rng), started = ...future.startTime, 
[17:37:34.299]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.299]             version = "1.8"), class = "FutureResult")
[17:37:34.299]     }, finally = {
[17:37:34.299]         if (!identical(...future.workdir, getwd())) 
[17:37:34.299]             setwd(...future.workdir)
[17:37:34.299]         {
[17:37:34.299]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.299]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.299]             }
[17:37:34.299]             base::options(...future.oldOptions)
[17:37:34.299]             if (.Platform$OS.type == "windows") {
[17:37:34.299]                 old_names <- names(...future.oldEnvVars)
[17:37:34.299]                 envs <- base::Sys.getenv()
[17:37:34.299]                 names <- names(envs)
[17:37:34.299]                 common <- intersect(names, old_names)
[17:37:34.299]                 added <- setdiff(names, old_names)
[17:37:34.299]                 removed <- setdiff(old_names, names)
[17:37:34.299]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.299]                   envs[common]]
[17:37:34.299]                 NAMES <- toupper(changed)
[17:37:34.299]                 args <- list()
[17:37:34.299]                 for (kk in seq_along(NAMES)) {
[17:37:34.299]                   name <- changed[[kk]]
[17:37:34.299]                   NAME <- NAMES[[kk]]
[17:37:34.299]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.299]                     next
[17:37:34.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.299]                 }
[17:37:34.299]                 NAMES <- toupper(added)
[17:37:34.299]                 for (kk in seq_along(NAMES)) {
[17:37:34.299]                   name <- added[[kk]]
[17:37:34.299]                   NAME <- NAMES[[kk]]
[17:37:34.299]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.299]                     next
[17:37:34.299]                   args[[name]] <- ""
[17:37:34.299]                 }
[17:37:34.299]                 NAMES <- toupper(removed)
[17:37:34.299]                 for (kk in seq_along(NAMES)) {
[17:37:34.299]                   name <- removed[[kk]]
[17:37:34.299]                   NAME <- NAMES[[kk]]
[17:37:34.299]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.299]                     next
[17:37:34.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.299]                 }
[17:37:34.299]                 if (length(args) > 0) 
[17:37:34.299]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.299]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.299]             }
[17:37:34.299]             else {
[17:37:34.299]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.299]             }
[17:37:34.299]             {
[17:37:34.299]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.299]                   0L) {
[17:37:34.299]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.299]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.299]                   base::options(opts)
[17:37:34.299]                 }
[17:37:34.299]                 {
[17:37:34.299]                   {
[17:37:34.299]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:34.299]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:34.299]                     -1786728155L), envir = base::globalenv(), 
[17:37:34.299]                       inherits = FALSE)
[17:37:34.299]                     NULL
[17:37:34.299]                   }
[17:37:34.299]                   options(future.plan = NULL)
[17:37:34.299]                   if (is.na(NA_character_)) 
[17:37:34.299]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.299]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.299]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.299]                     .init = FALSE)
[17:37:34.299]                 }
[17:37:34.299]             }
[17:37:34.299]         }
[17:37:34.299]     })
[17:37:34.299]     if (TRUE) {
[17:37:34.299]         base::sink(type = "output", split = FALSE)
[17:37:34.299]         if (TRUE) {
[17:37:34.299]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.299]         }
[17:37:34.299]         else {
[17:37:34.299]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.299]         }
[17:37:34.299]         base::close(...future.stdout)
[17:37:34.299]         ...future.stdout <- NULL
[17:37:34.299]     }
[17:37:34.299]     ...future.result$conditions <- ...future.conditions
[17:37:34.299]     ...future.result$finished <- base::Sys.time()
[17:37:34.299]     ...future.result
[17:37:34.299] }
[17:37:34.301] assign_globals() ...
[17:37:34.301] List of 5
[17:37:34.301]  $ ...future.FUN            :function (C, k)  
[17:37:34.301]  $ MoreArgs                 : NULL
[17:37:34.301]  $ ...future.elements_ii    :List of 2
[17:37:34.301]   ..$ :List of 2
[17:37:34.301]   .. ..$ : chr "E"
[17:37:34.301]   .. ..$ : chr "D"
[17:37:34.301]   ..$ :List of 2
[17:37:34.301]   .. ..$ : int 1
[17:37:34.301]   .. ..$ : int 2
[17:37:34.301]  $ ...future.seeds_ii       : NULL
[17:37:34.301]  $ ...future.globals.maxSize: NULL
[17:37:34.301]  - attr(*, "where")=List of 5
[17:37:34.301]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.301]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.301]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.301]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.301]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.301]  - attr(*, "resolved")= logi FALSE
[17:37:34.301]  - attr(*, "total_size")= num 3656
[17:37:34.301]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.301]  - attr(*, "already-done")= logi TRUE
[17:37:34.308] - reassign environment for ‘...future.FUN’
[17:37:34.308] - copied ‘...future.FUN’ to environment
[17:37:34.308] - copied ‘MoreArgs’ to environment
[17:37:34.308] - copied ‘...future.elements_ii’ to environment
[17:37:34.308] - copied ‘...future.seeds_ii’ to environment
[17:37:34.308] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.309] assign_globals() ... done
[17:37:34.309] plan(): Setting new future strategy stack:
[17:37:34.309] List of future strategies:
[17:37:34.309] 1. sequential:
[17:37:34.309]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.309]    - tweaked: FALSE
[17:37:34.309]    - call: NULL
[17:37:34.309] plan(): nbrOfWorkers() = 1
[17:37:34.310] plan(): Setting new future strategy stack:
[17:37:34.310] List of future strategies:
[17:37:34.310] 1. sequential:
[17:37:34.310]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.310]    - tweaked: FALSE
[17:37:34.310]    - call: plan(strategy)
[17:37:34.311] plan(): nbrOfWorkers() = 1
[17:37:34.311] SequentialFuture started (and completed)
[17:37:34.311] - Launch lazy future ... done
[17:37:34.311] run() for ‘SequentialFuture’ ... done
[17:37:34.311] Created future:
[17:37:34.311] SequentialFuture:
[17:37:34.311] Label: ‘future_mapply-1’
[17:37:34.311] Expression:
[17:37:34.311] {
[17:37:34.311]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.311]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.311]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.311]         on.exit(options(oopts), add = TRUE)
[17:37:34.311]     }
[17:37:34.311]     {
[17:37:34.311]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.311]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.311]         do.call(mapply, args = args)
[17:37:34.311]     }
[17:37:34.311] }
[17:37:34.311] Lazy evaluation: FALSE
[17:37:34.311] Asynchronous evaluation: FALSE
[17:37:34.311] Local evaluation: TRUE
[17:37:34.311] Environment: R_GlobalEnv
[17:37:34.311] Capture standard output: TRUE
[17:37:34.311] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.311] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.311] Packages: <none>
[17:37:34.311] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.311] Resolved: TRUE
[17:37:34.311] Value: 224 bytes of class ‘list’
[17:37:34.311] Early signaling: FALSE
[17:37:34.311] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.311] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.312] Chunk #1 of 2 ... DONE
[17:37:34.312] Chunk #2 of 2 ...
[17:37:34.312]  - Finding globals in '...' for chunk #2 ...
[17:37:34.312] getGlobalsAndPackages() ...
[17:37:34.312] Searching for globals...
[17:37:34.313] 
[17:37:34.313] Searching for globals ... DONE
[17:37:34.313] - globals: [0] <none>
[17:37:34.313] getGlobalsAndPackages() ... DONE
[17:37:34.313]    + additional globals found: [n=0] 
[17:37:34.313]    + additional namespaces needed: [n=0] 
[17:37:34.313]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:34.313]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:34.314]  - seeds: <none>
[17:37:34.314]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.314] getGlobalsAndPackages() ...
[17:37:34.314] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.314] Resolving globals: FALSE
[17:37:34.314] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:37:34.315] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:34.315] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.315] 
[17:37:34.315] getGlobalsAndPackages() ... DONE
[17:37:34.315] run() for ‘Future’ ...
[17:37:34.315] - state: ‘created’
[17:37:34.316] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.316] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.316] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.316]   - Field: ‘label’
[17:37:34.316]   - Field: ‘local’
[17:37:34.316]   - Field: ‘owner’
[17:37:34.316]   - Field: ‘envir’
[17:37:34.316]   - Field: ‘packages’
[17:37:34.317]   - Field: ‘gc’
[17:37:34.317]   - Field: ‘conditions’
[17:37:34.317]   - Field: ‘expr’
[17:37:34.317]   - Field: ‘uuid’
[17:37:34.317]   - Field: ‘seed’
[17:37:34.317]   - Field: ‘version’
[17:37:34.317]   - Field: ‘result’
[17:37:34.317]   - Field: ‘asynchronous’
[17:37:34.317]   - Field: ‘calls’
[17:37:34.317]   - Field: ‘globals’
[17:37:34.317]   - Field: ‘stdout’
[17:37:34.318]   - Field: ‘earlySignal’
[17:37:34.318]   - Field: ‘lazy’
[17:37:34.318]   - Field: ‘state’
[17:37:34.318] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.318] - Launch lazy future ...
[17:37:34.318] Packages needed by the future expression (n = 0): <none>
[17:37:34.318] Packages needed by future strategies (n = 0): <none>
[17:37:34.319] {
[17:37:34.319]     {
[17:37:34.319]         {
[17:37:34.319]             ...future.startTime <- base::Sys.time()
[17:37:34.319]             {
[17:37:34.319]                 {
[17:37:34.319]                   {
[17:37:34.319]                     base::local({
[17:37:34.319]                       has_future <- base::requireNamespace("future", 
[17:37:34.319]                         quietly = TRUE)
[17:37:34.319]                       if (has_future) {
[17:37:34.319]                         ns <- base::getNamespace("future")
[17:37:34.319]                         version <- ns[[".package"]][["version"]]
[17:37:34.319]                         if (is.null(version)) 
[17:37:34.319]                           version <- utils::packageVersion("future")
[17:37:34.319]                       }
[17:37:34.319]                       else {
[17:37:34.319]                         version <- NULL
[17:37:34.319]                       }
[17:37:34.319]                       if (!has_future || version < "1.8.0") {
[17:37:34.319]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.319]                           "", base::R.version$version.string), 
[17:37:34.319]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:34.319]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.319]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.319]                             "release", "version")], collapse = " "), 
[17:37:34.319]                           hostname = base::Sys.info()[["nodename"]])
[17:37:34.319]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.319]                           info)
[17:37:34.319]                         info <- base::paste(info, collapse = "; ")
[17:37:34.319]                         if (!has_future) {
[17:37:34.319]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.319]                             info)
[17:37:34.319]                         }
[17:37:34.319]                         else {
[17:37:34.319]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.319]                             info, version)
[17:37:34.319]                         }
[17:37:34.319]                         base::stop(msg)
[17:37:34.319]                       }
[17:37:34.319]                     })
[17:37:34.319]                   }
[17:37:34.319]                   ...future.strategy.old <- future::plan("list")
[17:37:34.319]                   options(future.plan = NULL)
[17:37:34.319]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.319]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.319]                 }
[17:37:34.319]                 ...future.workdir <- getwd()
[17:37:34.319]             }
[17:37:34.319]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.319]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.319]         }
[17:37:34.319]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.319]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:34.319]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.319]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.319]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.319]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.319]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.319]             base::names(...future.oldOptions))
[17:37:34.319]     }
[17:37:34.319]     if (FALSE) {
[17:37:34.319]     }
[17:37:34.319]     else {
[17:37:34.319]         if (TRUE) {
[17:37:34.319]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.319]                 open = "w")
[17:37:34.319]         }
[17:37:34.319]         else {
[17:37:34.319]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.319]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.319]         }
[17:37:34.319]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.319]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.319]             base::sink(type = "output", split = FALSE)
[17:37:34.319]             base::close(...future.stdout)
[17:37:34.319]         }, add = TRUE)
[17:37:34.319]     }
[17:37:34.319]     ...future.frame <- base::sys.nframe()
[17:37:34.319]     ...future.conditions <- base::list()
[17:37:34.319]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.319]     if (FALSE) {
[17:37:34.319]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.319]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.319]     }
[17:37:34.319]     ...future.result <- base::tryCatch({
[17:37:34.319]         base::withCallingHandlers({
[17:37:34.319]             ...future.value <- base::withVisible(base::local({
[17:37:34.319]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.319]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.319]                   ...future.globals.maxSize)) {
[17:37:34.319]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.319]                   on.exit(options(oopts), add = TRUE)
[17:37:34.319]                 }
[17:37:34.319]                 {
[17:37:34.319]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.319]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.319]                     USE.NAMES = FALSE)
[17:37:34.319]                   do.call(mapply, args = args)
[17:37:34.319]                 }
[17:37:34.319]             }))
[17:37:34.319]             future::FutureResult(value = ...future.value$value, 
[17:37:34.319]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.319]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.319]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.319]                     ...future.globalenv.names))
[17:37:34.319]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.319]         }, condition = base::local({
[17:37:34.319]             c <- base::c
[17:37:34.319]             inherits <- base::inherits
[17:37:34.319]             invokeRestart <- base::invokeRestart
[17:37:34.319]             length <- base::length
[17:37:34.319]             list <- base::list
[17:37:34.319]             seq.int <- base::seq.int
[17:37:34.319]             signalCondition <- base::signalCondition
[17:37:34.319]             sys.calls <- base::sys.calls
[17:37:34.319]             `[[` <- base::`[[`
[17:37:34.319]             `+` <- base::`+`
[17:37:34.319]             `<<-` <- base::`<<-`
[17:37:34.319]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.319]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.319]                   3L)]
[17:37:34.319]             }
[17:37:34.319]             function(cond) {
[17:37:34.319]                 is_error <- inherits(cond, "error")
[17:37:34.319]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.319]                   NULL)
[17:37:34.319]                 if (is_error) {
[17:37:34.319]                   sessionInformation <- function() {
[17:37:34.319]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.319]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.319]                       search = base::search(), system = base::Sys.info())
[17:37:34.319]                   }
[17:37:34.319]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.319]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.319]                     cond$call), session = sessionInformation(), 
[17:37:34.319]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.319]                   signalCondition(cond)
[17:37:34.319]                 }
[17:37:34.319]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.319]                 "immediateCondition"))) {
[17:37:34.319]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.319]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.319]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.319]                   if (TRUE && !signal) {
[17:37:34.319]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.319]                     {
[17:37:34.319]                       inherits <- base::inherits
[17:37:34.319]                       invokeRestart <- base::invokeRestart
[17:37:34.319]                       is.null <- base::is.null
[17:37:34.319]                       muffled <- FALSE
[17:37:34.319]                       if (inherits(cond, "message")) {
[17:37:34.319]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.319]                         if (muffled) 
[17:37:34.319]                           invokeRestart("muffleMessage")
[17:37:34.319]                       }
[17:37:34.319]                       else if (inherits(cond, "warning")) {
[17:37:34.319]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.319]                         if (muffled) 
[17:37:34.319]                           invokeRestart("muffleWarning")
[17:37:34.319]                       }
[17:37:34.319]                       else if (inherits(cond, "condition")) {
[17:37:34.319]                         if (!is.null(pattern)) {
[17:37:34.319]                           computeRestarts <- base::computeRestarts
[17:37:34.319]                           grepl <- base::grepl
[17:37:34.319]                           restarts <- computeRestarts(cond)
[17:37:34.319]                           for (restart in restarts) {
[17:37:34.319]                             name <- restart$name
[17:37:34.319]                             if (is.null(name)) 
[17:37:34.319]                               next
[17:37:34.319]                             if (!grepl(pattern, name)) 
[17:37:34.319]                               next
[17:37:34.319]                             invokeRestart(restart)
[17:37:34.319]                             muffled <- TRUE
[17:37:34.319]                             break
[17:37:34.319]                           }
[17:37:34.319]                         }
[17:37:34.319]                       }
[17:37:34.319]                       invisible(muffled)
[17:37:34.319]                     }
[17:37:34.319]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.319]                   }
[17:37:34.319]                 }
[17:37:34.319]                 else {
[17:37:34.319]                   if (TRUE) {
[17:37:34.319]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.319]                     {
[17:37:34.319]                       inherits <- base::inherits
[17:37:34.319]                       invokeRestart <- base::invokeRestart
[17:37:34.319]                       is.null <- base::is.null
[17:37:34.319]                       muffled <- FALSE
[17:37:34.319]                       if (inherits(cond, "message")) {
[17:37:34.319]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.319]                         if (muffled) 
[17:37:34.319]                           invokeRestart("muffleMessage")
[17:37:34.319]                       }
[17:37:34.319]                       else if (inherits(cond, "warning")) {
[17:37:34.319]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.319]                         if (muffled) 
[17:37:34.319]                           invokeRestart("muffleWarning")
[17:37:34.319]                       }
[17:37:34.319]                       else if (inherits(cond, "condition")) {
[17:37:34.319]                         if (!is.null(pattern)) {
[17:37:34.319]                           computeRestarts <- base::computeRestarts
[17:37:34.319]                           grepl <- base::grepl
[17:37:34.319]                           restarts <- computeRestarts(cond)
[17:37:34.319]                           for (restart in restarts) {
[17:37:34.319]                             name <- restart$name
[17:37:34.319]                             if (is.null(name)) 
[17:37:34.319]                               next
[17:37:34.319]                             if (!grepl(pattern, name)) 
[17:37:34.319]                               next
[17:37:34.319]                             invokeRestart(restart)
[17:37:34.319]                             muffled <- TRUE
[17:37:34.319]                             break
[17:37:34.319]                           }
[17:37:34.319]                         }
[17:37:34.319]                       }
[17:37:34.319]                       invisible(muffled)
[17:37:34.319]                     }
[17:37:34.319]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.319]                   }
[17:37:34.319]                 }
[17:37:34.319]             }
[17:37:34.319]         }))
[17:37:34.319]     }, error = function(ex) {
[17:37:34.319]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.319]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.319]                 ...future.rng), started = ...future.startTime, 
[17:37:34.319]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.319]             version = "1.8"), class = "FutureResult")
[17:37:34.319]     }, finally = {
[17:37:34.319]         if (!identical(...future.workdir, getwd())) 
[17:37:34.319]             setwd(...future.workdir)
[17:37:34.319]         {
[17:37:34.319]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.319]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.319]             }
[17:37:34.319]             base::options(...future.oldOptions)
[17:37:34.319]             if (.Platform$OS.type == "windows") {
[17:37:34.319]                 old_names <- names(...future.oldEnvVars)
[17:37:34.319]                 envs <- base::Sys.getenv()
[17:37:34.319]                 names <- names(envs)
[17:37:34.319]                 common <- intersect(names, old_names)
[17:37:34.319]                 added <- setdiff(names, old_names)
[17:37:34.319]                 removed <- setdiff(old_names, names)
[17:37:34.319]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.319]                   envs[common]]
[17:37:34.319]                 NAMES <- toupper(changed)
[17:37:34.319]                 args <- list()
[17:37:34.319]                 for (kk in seq_along(NAMES)) {
[17:37:34.319]                   name <- changed[[kk]]
[17:37:34.319]                   NAME <- NAMES[[kk]]
[17:37:34.319]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.319]                     next
[17:37:34.319]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.319]                 }
[17:37:34.319]                 NAMES <- toupper(added)
[17:37:34.319]                 for (kk in seq_along(NAMES)) {
[17:37:34.319]                   name <- added[[kk]]
[17:37:34.319]                   NAME <- NAMES[[kk]]
[17:37:34.319]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.319]                     next
[17:37:34.319]                   args[[name]] <- ""
[17:37:34.319]                 }
[17:37:34.319]                 NAMES <- toupper(removed)
[17:37:34.319]                 for (kk in seq_along(NAMES)) {
[17:37:34.319]                   name <- removed[[kk]]
[17:37:34.319]                   NAME <- NAMES[[kk]]
[17:37:34.319]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.319]                     next
[17:37:34.319]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.319]                 }
[17:37:34.319]                 if (length(args) > 0) 
[17:37:34.319]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.319]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.319]             }
[17:37:34.319]             else {
[17:37:34.319]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.319]             }
[17:37:34.319]             {
[17:37:34.319]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.319]                   0L) {
[17:37:34.319]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.319]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.319]                   base::options(opts)
[17:37:34.319]                 }
[17:37:34.319]                 {
[17:37:34.319]                   {
[17:37:34.319]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:34.319]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:34.319]                     -1786728155L), envir = base::globalenv(), 
[17:37:34.319]                       inherits = FALSE)
[17:37:34.319]                     NULL
[17:37:34.319]                   }
[17:37:34.319]                   options(future.plan = NULL)
[17:37:34.319]                   if (is.na(NA_character_)) 
[17:37:34.319]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.319]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.319]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.319]                     .init = FALSE)
[17:37:34.319]                 }
[17:37:34.319]             }
[17:37:34.319]         }
[17:37:34.319]     })
[17:37:34.319]     if (TRUE) {
[17:37:34.319]         base::sink(type = "output", split = FALSE)
[17:37:34.319]         if (TRUE) {
[17:37:34.319]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.319]         }
[17:37:34.319]         else {
[17:37:34.319]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.319]         }
[17:37:34.319]         base::close(...future.stdout)
[17:37:34.319]         ...future.stdout <- NULL
[17:37:34.319]     }
[17:37:34.319]     ...future.result$conditions <- ...future.conditions
[17:37:34.319]     ...future.result$finished <- base::Sys.time()
[17:37:34.319]     ...future.result
[17:37:34.319] }
[17:37:34.320] assign_globals() ...
[17:37:34.320] List of 5
[17:37:34.320]  $ ...future.FUN            :function (C, k)  
[17:37:34.320]  $ MoreArgs                 : NULL
[17:37:34.320]  $ ...future.elements_ii    :List of 2
[17:37:34.320]   ..$ :List of 3
[17:37:34.320]   .. ..$ : chr "C"
[17:37:34.320]   .. ..$ : chr "B"
[17:37:34.320]   .. ..$ : chr "A"
[17:37:34.320]   ..$ :List of 3
[17:37:34.320]   .. ..$ : int 3
[17:37:34.320]   .. ..$ : int 4
[17:37:34.320]   .. ..$ : int 5
[17:37:34.320]  $ ...future.seeds_ii       : NULL
[17:37:34.320]  $ ...future.globals.maxSize: NULL
[17:37:34.320]  - attr(*, "where")=List of 5
[17:37:34.320]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.320]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.320]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.320]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.320]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.320]  - attr(*, "resolved")= logi FALSE
[17:37:34.320]  - attr(*, "total_size")= num 3824
[17:37:34.320]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.320]  - attr(*, "already-done")= logi TRUE
[17:37:34.326] - reassign environment for ‘...future.FUN’
[17:37:34.326] - copied ‘...future.FUN’ to environment
[17:37:34.326] - copied ‘MoreArgs’ to environment
[17:37:34.326] - copied ‘...future.elements_ii’ to environment
[17:37:34.327] - copied ‘...future.seeds_ii’ to environment
[17:37:34.327] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.327] assign_globals() ... done
[17:37:34.327] plan(): Setting new future strategy stack:
[17:37:34.329] List of future strategies:
[17:37:34.329] 1. sequential:
[17:37:34.329]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.329]    - tweaked: FALSE
[17:37:34.329]    - call: NULL
[17:37:34.329] plan(): nbrOfWorkers() = 1
[17:37:34.330] plan(): Setting new future strategy stack:
[17:37:34.330] List of future strategies:
[17:37:34.330] 1. sequential:
[17:37:34.330]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.330]    - tweaked: FALSE
[17:37:34.330]    - call: plan(strategy)
[17:37:34.330] plan(): nbrOfWorkers() = 1
[17:37:34.331] SequentialFuture started (and completed)
[17:37:34.331] - Launch lazy future ... done
[17:37:34.331] run() for ‘SequentialFuture’ ... done
[17:37:34.331] Created future:
[17:37:34.331] SequentialFuture:
[17:37:34.331] Label: ‘future_mapply-2’
[17:37:34.331] Expression:
[17:37:34.331] {
[17:37:34.331]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.331]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.331]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.331]         on.exit(options(oopts), add = TRUE)
[17:37:34.331]     }
[17:37:34.331]     {
[17:37:34.331]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.331]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.331]         do.call(mapply, args = args)
[17:37:34.331]     }
[17:37:34.331] }
[17:37:34.331] Lazy evaluation: FALSE
[17:37:34.331] Asynchronous evaluation: FALSE
[17:37:34.331] Local evaluation: TRUE
[17:37:34.331] Environment: R_GlobalEnv
[17:37:34.331] Capture standard output: TRUE
[17:37:34.331] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.331] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.331] Packages: <none>
[17:37:34.331] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.331] Resolved: TRUE
[17:37:34.331] Value: 336 bytes of class ‘list’
[17:37:34.331] Early signaling: FALSE
[17:37:34.331] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.331] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.332] Chunk #2 of 2 ... DONE
[17:37:34.332] Launching 2 futures (chunks) ... DONE
[17:37:34.332] Resolving 2 futures (chunks) ...
[17:37:34.332] resolve() on list ...
[17:37:34.332]  recursive: 0
[17:37:34.332]  length: 2
[17:37:34.332] 
[17:37:34.333] resolved() for ‘SequentialFuture’ ...
[17:37:34.333] - state: ‘finished’
[17:37:34.333] - run: TRUE
[17:37:34.333] - result: ‘FutureResult’
[17:37:34.333] resolved() for ‘SequentialFuture’ ... done
[17:37:34.333] Future #1
[17:37:34.333] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:34.333] - nx: 2
[17:37:34.333] - relay: TRUE
[17:37:34.333] - stdout: TRUE
[17:37:34.334] - signal: TRUE
[17:37:34.334] - resignal: FALSE
[17:37:34.334] - force: TRUE
[17:37:34.334] - relayed: [n=2] FALSE, FALSE
[17:37:34.334] - queued futures: [n=2] FALSE, FALSE
[17:37:34.334]  - until=1
[17:37:34.334]  - relaying element #1
[17:37:34.334] - relayed: [n=2] TRUE, FALSE
[17:37:34.334] - queued futures: [n=2] TRUE, FALSE
[17:37:34.334] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:34.335]  length: 1 (resolved future 1)
[17:37:34.335] resolved() for ‘SequentialFuture’ ...
[17:37:34.335] - state: ‘finished’
[17:37:34.335] - run: TRUE
[17:37:34.335] - result: ‘FutureResult’
[17:37:34.335] resolved() for ‘SequentialFuture’ ... done
[17:37:34.335] Future #2
[17:37:34.335] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:37:34.335] - nx: 2
[17:37:34.335] - relay: TRUE
[17:37:34.335] - stdout: TRUE
[17:37:34.336] - signal: TRUE
[17:37:34.336] - resignal: FALSE
[17:37:34.336] - force: TRUE
[17:37:34.336] - relayed: [n=2] TRUE, FALSE
[17:37:34.336] - queued futures: [n=2] TRUE, FALSE
[17:37:34.336]  - until=2
[17:37:34.336]  - relaying element #2
[17:37:34.336] - relayed: [n=2] TRUE, TRUE
[17:37:34.336] - queued futures: [n=2] TRUE, TRUE
[17:37:34.336] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:37:34.337]  length: 0 (resolved future 2)
[17:37:34.337] Relaying remaining futures
[17:37:34.337] signalConditionsASAP(NULL, pos=0) ...
[17:37:34.337] - nx: 2
[17:37:34.337] - relay: TRUE
[17:37:34.337] - stdout: TRUE
[17:37:34.337] - signal: TRUE
[17:37:34.337] - resignal: FALSE
[17:37:34.337] - force: TRUE
[17:37:34.337] - relayed: [n=2] TRUE, TRUE
[17:37:34.337] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:34.337] - relayed: [n=2] TRUE, TRUE
[17:37:34.338] - queued futures: [n=2] TRUE, TRUE
[17:37:34.338] signalConditionsASAP(NULL, pos=0) ... done
[17:37:34.338] resolve() on list ... DONE
[17:37:34.338]  - Number of value chunks collected: 2
[17:37:34.338] Resolving 2 futures (chunks) ... DONE
[17:37:34.338] Reducing values from 2 chunks ...
[17:37:34.338]  - Number of values collected after concatenation: 5
[17:37:34.338]  - Number of values expected: 5
[17:37:34.338] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[17:37:34.338] Reducing values from 2 chunks ... DONE
[17:37:34.339] future_mapply() ... DONE
[17:37:34.339] future_mapply() ...
[17:37:34.339] Number of chunks: 1
[17:37:34.339] getGlobalsAndPackagesXApply() ...
[17:37:34.339]  - future.globals: TRUE
[17:37:34.339] getGlobalsAndPackages() ...
[17:37:34.339] Searching for globals...
[17:37:34.341] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:37:34.341] Searching for globals ... DONE
[17:37:34.341] Resolving globals: FALSE
[17:37:34.341] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:37:34.341] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:37:34.342] - globals: [1] ‘FUN’
[17:37:34.342] 
[17:37:34.342] getGlobalsAndPackages() ... DONE
[17:37:34.342]  - globals found/used: [n=1] ‘FUN’
[17:37:34.342]  - needed namespaces: [n=0] 
[17:37:34.342] Finding globals ... DONE
[17:37:34.342] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:34.342] List of 2
[17:37:34.342]  $ ...future.FUN:function (C, k)  
[17:37:34.342]  $ MoreArgs     : list()
[17:37:34.342]  - attr(*, "where")=List of 2
[17:37:34.342]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:34.342]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:34.342]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.342]  - attr(*, "resolved")= logi FALSE
[17:37:34.342]  - attr(*, "total_size")= num NA
[17:37:34.345] Packages to be attached in all futures: [n=0] 
[17:37:34.345] getGlobalsAndPackagesXApply() ... DONE
[17:37:34.345] Number of futures (= number of chunks): 1
[17:37:34.345] Launching 1 futures (chunks) ...
[17:37:34.345] Chunk #1 of 1 ...
[17:37:34.345]  - Finding globals in '...' for chunk #1 ...
[17:37:34.345] getGlobalsAndPackages() ...
[17:37:34.346] Searching for globals...
[17:37:34.346] 
[17:37:34.346] Searching for globals ... DONE
[17:37:34.346] - globals: [0] <none>
[17:37:34.346] getGlobalsAndPackages() ... DONE
[17:37:34.346]    + additional globals found: [n=0] 
[17:37:34.346]    + additional namespaces needed: [n=0] 
[17:37:34.346]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:34.346]  - seeds: <none>
[17:37:34.347]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.347] getGlobalsAndPackages() ...
[17:37:34.347] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.347] Resolving globals: FALSE
[17:37:34.347] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[17:37:34.348] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:34.348] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.348] 
[17:37:34.348] getGlobalsAndPackages() ... DONE
[17:37:34.348] run() for ‘Future’ ...
[17:37:34.349] - state: ‘created’
[17:37:34.349] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.349] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.349] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.349]   - Field: ‘label’
[17:37:34.349]   - Field: ‘local’
[17:37:34.349]   - Field: ‘owner’
[17:37:34.349]   - Field: ‘envir’
[17:37:34.350]   - Field: ‘packages’
[17:37:34.350]   - Field: ‘gc’
[17:37:34.350]   - Field: ‘conditions’
[17:37:34.350]   - Field: ‘expr’
[17:37:34.350]   - Field: ‘uuid’
[17:37:34.350]   - Field: ‘seed’
[17:37:34.350]   - Field: ‘version’
[17:37:34.350]   - Field: ‘result’
[17:37:34.350]   - Field: ‘asynchronous’
[17:37:34.350]   - Field: ‘calls’
[17:37:34.350]   - Field: ‘globals’
[17:37:34.351]   - Field: ‘stdout’
[17:37:34.351]   - Field: ‘earlySignal’
[17:37:34.351]   - Field: ‘lazy’
[17:37:34.351]   - Field: ‘state’
[17:37:34.351] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.351] - Launch lazy future ...
[17:37:34.351] Packages needed by the future expression (n = 0): <none>
[17:37:34.351] Packages needed by future strategies (n = 0): <none>
[17:37:34.353] {
[17:37:34.353]     {
[17:37:34.353]         {
[17:37:34.353]             ...future.startTime <- base::Sys.time()
[17:37:34.353]             {
[17:37:34.353]                 {
[17:37:34.353]                   {
[17:37:34.353]                     base::local({
[17:37:34.353]                       has_future <- base::requireNamespace("future", 
[17:37:34.353]                         quietly = TRUE)
[17:37:34.353]                       if (has_future) {
[17:37:34.353]                         ns <- base::getNamespace("future")
[17:37:34.353]                         version <- ns[[".package"]][["version"]]
[17:37:34.353]                         if (is.null(version)) 
[17:37:34.353]                           version <- utils::packageVersion("future")
[17:37:34.353]                       }
[17:37:34.353]                       else {
[17:37:34.353]                         version <- NULL
[17:37:34.353]                       }
[17:37:34.353]                       if (!has_future || version < "1.8.0") {
[17:37:34.353]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.353]                           "", base::R.version$version.string), 
[17:37:34.353]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:34.353]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.353]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.353]                             "release", "version")], collapse = " "), 
[17:37:34.353]                           hostname = base::Sys.info()[["nodename"]])
[17:37:34.353]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.353]                           info)
[17:37:34.353]                         info <- base::paste(info, collapse = "; ")
[17:37:34.353]                         if (!has_future) {
[17:37:34.353]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.353]                             info)
[17:37:34.353]                         }
[17:37:34.353]                         else {
[17:37:34.353]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.353]                             info, version)
[17:37:34.353]                         }
[17:37:34.353]                         base::stop(msg)
[17:37:34.353]                       }
[17:37:34.353]                     })
[17:37:34.353]                   }
[17:37:34.353]                   ...future.strategy.old <- future::plan("list")
[17:37:34.353]                   options(future.plan = NULL)
[17:37:34.353]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.353]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.353]                 }
[17:37:34.353]                 ...future.workdir <- getwd()
[17:37:34.353]             }
[17:37:34.353]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.353]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.353]         }
[17:37:34.353]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.353]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:34.353]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.353]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.353]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.353]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.353]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.353]             base::names(...future.oldOptions))
[17:37:34.353]     }
[17:37:34.353]     if (FALSE) {
[17:37:34.353]     }
[17:37:34.353]     else {
[17:37:34.353]         if (TRUE) {
[17:37:34.353]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.353]                 open = "w")
[17:37:34.353]         }
[17:37:34.353]         else {
[17:37:34.353]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.353]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.353]         }
[17:37:34.353]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.353]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.353]             base::sink(type = "output", split = FALSE)
[17:37:34.353]             base::close(...future.stdout)
[17:37:34.353]         }, add = TRUE)
[17:37:34.353]     }
[17:37:34.353]     ...future.frame <- base::sys.nframe()
[17:37:34.353]     ...future.conditions <- base::list()
[17:37:34.353]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.353]     if (FALSE) {
[17:37:34.353]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.353]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.353]     }
[17:37:34.353]     ...future.result <- base::tryCatch({
[17:37:34.353]         base::withCallingHandlers({
[17:37:34.353]             ...future.value <- base::withVisible(base::local({
[17:37:34.353]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.353]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.353]                   ...future.globals.maxSize)) {
[17:37:34.353]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.353]                   on.exit(options(oopts), add = TRUE)
[17:37:34.353]                 }
[17:37:34.353]                 {
[17:37:34.353]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.353]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.353]                     USE.NAMES = FALSE)
[17:37:34.353]                   do.call(mapply, args = args)
[17:37:34.353]                 }
[17:37:34.353]             }))
[17:37:34.353]             future::FutureResult(value = ...future.value$value, 
[17:37:34.353]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.353]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.353]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.353]                     ...future.globalenv.names))
[17:37:34.353]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.353]         }, condition = base::local({
[17:37:34.353]             c <- base::c
[17:37:34.353]             inherits <- base::inherits
[17:37:34.353]             invokeRestart <- base::invokeRestart
[17:37:34.353]             length <- base::length
[17:37:34.353]             list <- base::list
[17:37:34.353]             seq.int <- base::seq.int
[17:37:34.353]             signalCondition <- base::signalCondition
[17:37:34.353]             sys.calls <- base::sys.calls
[17:37:34.353]             `[[` <- base::`[[`
[17:37:34.353]             `+` <- base::`+`
[17:37:34.353]             `<<-` <- base::`<<-`
[17:37:34.353]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.353]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.353]                   3L)]
[17:37:34.353]             }
[17:37:34.353]             function(cond) {
[17:37:34.353]                 is_error <- inherits(cond, "error")
[17:37:34.353]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.353]                   NULL)
[17:37:34.353]                 if (is_error) {
[17:37:34.353]                   sessionInformation <- function() {
[17:37:34.353]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.353]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.353]                       search = base::search(), system = base::Sys.info())
[17:37:34.353]                   }
[17:37:34.353]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.353]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.353]                     cond$call), session = sessionInformation(), 
[17:37:34.353]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.353]                   signalCondition(cond)
[17:37:34.353]                 }
[17:37:34.353]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.353]                 "immediateCondition"))) {
[17:37:34.353]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.353]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.353]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.353]                   if (TRUE && !signal) {
[17:37:34.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.353]                     {
[17:37:34.353]                       inherits <- base::inherits
[17:37:34.353]                       invokeRestart <- base::invokeRestart
[17:37:34.353]                       is.null <- base::is.null
[17:37:34.353]                       muffled <- FALSE
[17:37:34.353]                       if (inherits(cond, "message")) {
[17:37:34.353]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.353]                         if (muffled) 
[17:37:34.353]                           invokeRestart("muffleMessage")
[17:37:34.353]                       }
[17:37:34.353]                       else if (inherits(cond, "warning")) {
[17:37:34.353]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.353]                         if (muffled) 
[17:37:34.353]                           invokeRestart("muffleWarning")
[17:37:34.353]                       }
[17:37:34.353]                       else if (inherits(cond, "condition")) {
[17:37:34.353]                         if (!is.null(pattern)) {
[17:37:34.353]                           computeRestarts <- base::computeRestarts
[17:37:34.353]                           grepl <- base::grepl
[17:37:34.353]                           restarts <- computeRestarts(cond)
[17:37:34.353]                           for (restart in restarts) {
[17:37:34.353]                             name <- restart$name
[17:37:34.353]                             if (is.null(name)) 
[17:37:34.353]                               next
[17:37:34.353]                             if (!grepl(pattern, name)) 
[17:37:34.353]                               next
[17:37:34.353]                             invokeRestart(restart)
[17:37:34.353]                             muffled <- TRUE
[17:37:34.353]                             break
[17:37:34.353]                           }
[17:37:34.353]                         }
[17:37:34.353]                       }
[17:37:34.353]                       invisible(muffled)
[17:37:34.353]                     }
[17:37:34.353]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.353]                   }
[17:37:34.353]                 }
[17:37:34.353]                 else {
[17:37:34.353]                   if (TRUE) {
[17:37:34.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.353]                     {
[17:37:34.353]                       inherits <- base::inherits
[17:37:34.353]                       invokeRestart <- base::invokeRestart
[17:37:34.353]                       is.null <- base::is.null
[17:37:34.353]                       muffled <- FALSE
[17:37:34.353]                       if (inherits(cond, "message")) {
[17:37:34.353]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.353]                         if (muffled) 
[17:37:34.353]                           invokeRestart("muffleMessage")
[17:37:34.353]                       }
[17:37:34.353]                       else if (inherits(cond, "warning")) {
[17:37:34.353]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.353]                         if (muffled) 
[17:37:34.353]                           invokeRestart("muffleWarning")
[17:37:34.353]                       }
[17:37:34.353]                       else if (inherits(cond, "condition")) {
[17:37:34.353]                         if (!is.null(pattern)) {
[17:37:34.353]                           computeRestarts <- base::computeRestarts
[17:37:34.353]                           grepl <- base::grepl
[17:37:34.353]                           restarts <- computeRestarts(cond)
[17:37:34.353]                           for (restart in restarts) {
[17:37:34.353]                             name <- restart$name
[17:37:34.353]                             if (is.null(name)) 
[17:37:34.353]                               next
[17:37:34.353]                             if (!grepl(pattern, name)) 
[17:37:34.353]                               next
[17:37:34.353]                             invokeRestart(restart)
[17:37:34.353]                             muffled <- TRUE
[17:37:34.353]                             break
[17:37:34.353]                           }
[17:37:34.353]                         }
[17:37:34.353]                       }
[17:37:34.353]                       invisible(muffled)
[17:37:34.353]                     }
[17:37:34.353]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.353]                   }
[17:37:34.353]                 }
[17:37:34.353]             }
[17:37:34.353]         }))
[17:37:34.353]     }, error = function(ex) {
[17:37:34.353]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.353]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.353]                 ...future.rng), started = ...future.startTime, 
[17:37:34.353]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.353]             version = "1.8"), class = "FutureResult")
[17:37:34.353]     }, finally = {
[17:37:34.353]         if (!identical(...future.workdir, getwd())) 
[17:37:34.353]             setwd(...future.workdir)
[17:37:34.353]         {
[17:37:34.353]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.353]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.353]             }
[17:37:34.353]             base::options(...future.oldOptions)
[17:37:34.353]             if (.Platform$OS.type == "windows") {
[17:37:34.353]                 old_names <- names(...future.oldEnvVars)
[17:37:34.353]                 envs <- base::Sys.getenv()
[17:37:34.353]                 names <- names(envs)
[17:37:34.353]                 common <- intersect(names, old_names)
[17:37:34.353]                 added <- setdiff(names, old_names)
[17:37:34.353]                 removed <- setdiff(old_names, names)
[17:37:34.353]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.353]                   envs[common]]
[17:37:34.353]                 NAMES <- toupper(changed)
[17:37:34.353]                 args <- list()
[17:37:34.353]                 for (kk in seq_along(NAMES)) {
[17:37:34.353]                   name <- changed[[kk]]
[17:37:34.353]                   NAME <- NAMES[[kk]]
[17:37:34.353]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.353]                     next
[17:37:34.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.353]                 }
[17:37:34.353]                 NAMES <- toupper(added)
[17:37:34.353]                 for (kk in seq_along(NAMES)) {
[17:37:34.353]                   name <- added[[kk]]
[17:37:34.353]                   NAME <- NAMES[[kk]]
[17:37:34.353]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.353]                     next
[17:37:34.353]                   args[[name]] <- ""
[17:37:34.353]                 }
[17:37:34.353]                 NAMES <- toupper(removed)
[17:37:34.353]                 for (kk in seq_along(NAMES)) {
[17:37:34.353]                   name <- removed[[kk]]
[17:37:34.353]                   NAME <- NAMES[[kk]]
[17:37:34.353]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.353]                     next
[17:37:34.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.353]                 }
[17:37:34.353]                 if (length(args) > 0) 
[17:37:34.353]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.353]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.353]             }
[17:37:34.353]             else {
[17:37:34.353]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.353]             }
[17:37:34.353]             {
[17:37:34.353]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.353]                   0L) {
[17:37:34.353]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.353]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.353]                   base::options(opts)
[17:37:34.353]                 }
[17:37:34.353]                 {
[17:37:34.353]                   {
[17:37:34.353]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:34.353]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:34.353]                     -1786728155L), envir = base::globalenv(), 
[17:37:34.353]                       inherits = FALSE)
[17:37:34.353]                     NULL
[17:37:34.353]                   }
[17:37:34.353]                   options(future.plan = NULL)
[17:37:34.353]                   if (is.na(NA_character_)) 
[17:37:34.353]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.353]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.353]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.353]                     .init = FALSE)
[17:37:34.353]                 }
[17:37:34.353]             }
[17:37:34.353]         }
[17:37:34.353]     })
[17:37:34.353]     if (TRUE) {
[17:37:34.353]         base::sink(type = "output", split = FALSE)
[17:37:34.353]         if (TRUE) {
[17:37:34.353]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.353]         }
[17:37:34.353]         else {
[17:37:34.353]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.353]         }
[17:37:34.353]         base::close(...future.stdout)
[17:37:34.353]         ...future.stdout <- NULL
[17:37:34.353]     }
[17:37:34.353]     ...future.result$conditions <- ...future.conditions
[17:37:34.353]     ...future.result$finished <- base::Sys.time()
[17:37:34.353]     ...future.result
[17:37:34.353] }
[17:37:34.355] assign_globals() ...
[17:37:34.355] List of 5
[17:37:34.355]  $ ...future.FUN            :function (C, k)  
[17:37:34.355]  $ MoreArgs                 : list()
[17:37:34.355]  $ ...future.elements_ii    :List of 2
[17:37:34.355]   ..$ :List of 5
[17:37:34.355]   .. ..$ : chr "A"
[17:37:34.355]   .. ..$ : chr "B"
[17:37:34.355]   .. ..$ : chr "C"
[17:37:34.355]   .. ..$ : chr "D"
[17:37:34.355]   .. ..$ : chr "E"
[17:37:34.355]   ..$ :List of 5
[17:37:34.355]   .. ..$ : int 5
[17:37:34.355]   .. ..$ : int 4
[17:37:34.355]   .. ..$ : int 3
[17:37:34.355]   .. ..$ : int 2
[17:37:34.355]   .. ..$ : int 1
[17:37:34.355]  $ ...future.seeds_ii       : NULL
[17:37:34.355]  $ ...future.globals.maxSize: NULL
[17:37:34.355]  - attr(*, "where")=List of 5
[17:37:34.355]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.355]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.355]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.355]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.355]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.355]  - attr(*, "resolved")= logi FALSE
[17:37:34.355]  - attr(*, "total_size")= num 4160
[17:37:34.355]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.355]  - attr(*, "already-done")= logi TRUE
[17:37:34.362] - reassign environment for ‘...future.FUN’
[17:37:34.362] - copied ‘...future.FUN’ to environment
[17:37:34.363] - copied ‘MoreArgs’ to environment
[17:37:34.363] - copied ‘...future.elements_ii’ to environment
[17:37:34.363] - copied ‘...future.seeds_ii’ to environment
[17:37:34.363] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.363] assign_globals() ... done
[17:37:34.363] plan(): Setting new future strategy stack:
[17:37:34.363] List of future strategies:
[17:37:34.363] 1. sequential:
[17:37:34.363]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.363]    - tweaked: FALSE
[17:37:34.363]    - call: NULL
[17:37:34.364] plan(): nbrOfWorkers() = 1
[17:37:34.364] plan(): Setting new future strategy stack:
[17:37:34.365] List of future strategies:
[17:37:34.365] 1. sequential:
[17:37:34.365]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.365]    - tweaked: FALSE
[17:37:34.365]    - call: plan(strategy)
[17:37:34.365] plan(): nbrOfWorkers() = 1
[17:37:34.365] SequentialFuture started (and completed)
[17:37:34.365] - Launch lazy future ... done
[17:37:34.365] run() for ‘SequentialFuture’ ... done
[17:37:34.366] Created future:
[17:37:34.366] SequentialFuture:
[17:37:34.366] Label: ‘future_.mapply-1’
[17:37:34.366] Expression:
[17:37:34.366] {
[17:37:34.366]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.366]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.366]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.366]         on.exit(options(oopts), add = TRUE)
[17:37:34.366]     }
[17:37:34.366]     {
[17:37:34.366]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.366]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.366]         do.call(mapply, args = args)
[17:37:34.366]     }
[17:37:34.366] }
[17:37:34.366] Lazy evaluation: FALSE
[17:37:34.366] Asynchronous evaluation: FALSE
[17:37:34.366] Local evaluation: TRUE
[17:37:34.366] Environment: R_GlobalEnv
[17:37:34.366] Capture standard output: TRUE
[17:37:34.366] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.366] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.366] Packages: <none>
[17:37:34.366] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.366] Resolved: TRUE
[17:37:34.366] Value: 560 bytes of class ‘list’
[17:37:34.366] Early signaling: FALSE
[17:37:34.366] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.366] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.367] Chunk #1 of 1 ... DONE
[17:37:34.367] Launching 1 futures (chunks) ... DONE
[17:37:34.367] Resolving 1 futures (chunks) ...
[17:37:34.367] resolve() on list ...
[17:37:34.367]  recursive: 0
[17:37:34.367]  length: 1
[17:37:34.367] 
[17:37:34.367] resolved() for ‘SequentialFuture’ ...
[17:37:34.367] - state: ‘finished’
[17:37:34.367] - run: TRUE
[17:37:34.368] - result: ‘FutureResult’
[17:37:34.368] resolved() for ‘SequentialFuture’ ... done
[17:37:34.368] Future #1
[17:37:34.368] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:34.368] - nx: 1
[17:37:34.368] - relay: TRUE
[17:37:34.368] - stdout: TRUE
[17:37:34.368] - signal: TRUE
[17:37:34.368] - resignal: FALSE
[17:37:34.369] - force: TRUE
[17:37:34.369] - relayed: [n=1] FALSE
[17:37:34.369] - queued futures: [n=1] FALSE
[17:37:34.369]  - until=1
[17:37:34.369]  - relaying element #1
[17:37:34.369] - relayed: [n=1] TRUE
[17:37:34.369] - queued futures: [n=1] TRUE
[17:37:34.369] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:34.369]  length: 0 (resolved future 1)
[17:37:34.369] Relaying remaining futures
[17:37:34.370] signalConditionsASAP(NULL, pos=0) ...
[17:37:34.370] - nx: 1
[17:37:34.370] - relay: TRUE
[17:37:34.370] - stdout: TRUE
[17:37:34.370] - signal: TRUE
[17:37:34.370] - resignal: FALSE
[17:37:34.370] - force: TRUE
[17:37:34.370] - relayed: [n=1] TRUE
[17:37:34.370] - queued futures: [n=1] TRUE
 - flush all
[17:37:34.370] - relayed: [n=1] TRUE
[17:37:34.370] - queued futures: [n=1] TRUE
[17:37:34.371] signalConditionsASAP(NULL, pos=0) ... done
[17:37:34.371] resolve() on list ... DONE
[17:37:34.371]  - Number of value chunks collected: 1
[17:37:34.371] Resolving 1 futures (chunks) ... DONE
[17:37:34.371] Reducing values from 1 chunks ...
[17:37:34.371]  - Number of values collected after concatenation: 5
[17:37:34.371]  - Number of values expected: 5
[17:37:34.371] Reducing values from 1 chunks ... DONE
[17:37:34.371] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[17:37:34.372] future_mapply() ...
[17:37:34.372] Number of chunks: 1
[17:37:34.372] getGlobalsAndPackagesXApply() ...
[17:37:34.372]  - future.globals: TRUE
[17:37:34.372] getGlobalsAndPackages() ...
[17:37:34.372] Searching for globals...
[17:37:34.373] - globals found: [1] ‘FUN’
[17:37:34.374] Searching for globals ... DONE
[17:37:34.374] Resolving globals: FALSE
[17:37:34.374] The total size of the 1 globals is 848 bytes (848 bytes)
[17:37:34.374] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:37:34.374] - globals: [1] ‘FUN’
[17:37:34.375] 
[17:37:34.375] getGlobalsAndPackages() ... DONE
[17:37:34.375]  - globals found/used: [n=1] ‘FUN’
[17:37:34.375]  - needed namespaces: [n=0] 
[17:37:34.375] Finding globals ... DONE
[17:37:34.375] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:34.375] List of 2
[17:37:34.375]  $ ...future.FUN:function (x)  
[17:37:34.375]  $ MoreArgs     : NULL
[17:37:34.375]  - attr(*, "where")=List of 2
[17:37:34.375]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:34.375]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:34.375]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.375]  - attr(*, "resolved")= logi FALSE
[17:37:34.375]  - attr(*, "total_size")= num NA
[17:37:34.379] Packages to be attached in all futures: [n=0] 
[17:37:34.379] getGlobalsAndPackagesXApply() ... DONE
[17:37:34.380] Number of futures (= number of chunks): 1
[17:37:34.380] Launching 1 futures (chunks) ...
[17:37:34.380] Chunk #1 of 1 ...
[17:37:34.380]  - Finding globals in '...' for chunk #1 ...
[17:37:34.380] getGlobalsAndPackages() ...
[17:37:34.380] Searching for globals...
[17:37:34.381] 
[17:37:34.381] Searching for globals ... DONE
[17:37:34.381] - globals: [0] <none>
[17:37:34.381] getGlobalsAndPackages() ... DONE
[17:37:34.381]    + additional globals found: [n=0] 
[17:37:34.381]    + additional namespaces needed: [n=0] 
[17:37:34.381]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:34.381]  - seeds: <none>
[17:37:34.381]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.381] getGlobalsAndPackages() ...
[17:37:34.382] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.382] Resolving globals: FALSE
[17:37:34.382] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[17:37:34.383] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:34.383] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.383] 
[17:37:34.383] getGlobalsAndPackages() ... DONE
[17:37:34.383] run() for ‘Future’ ...
[17:37:34.383] - state: ‘created’
[17:37:34.383] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.384] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.384] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.384]   - Field: ‘label’
[17:37:34.384]   - Field: ‘local’
[17:37:34.384]   - Field: ‘owner’
[17:37:34.384]   - Field: ‘envir’
[17:37:34.384]   - Field: ‘packages’
[17:37:34.384]   - Field: ‘gc’
[17:37:34.384]   - Field: ‘conditions’
[17:37:34.385]   - Field: ‘expr’
[17:37:34.385]   - Field: ‘uuid’
[17:37:34.385]   - Field: ‘seed’
[17:37:34.385]   - Field: ‘version’
[17:37:34.385]   - Field: ‘result’
[17:37:34.385]   - Field: ‘asynchronous’
[17:37:34.385]   - Field: ‘calls’
[17:37:34.385]   - Field: ‘globals’
[17:37:34.385]   - Field: ‘stdout’
[17:37:34.385]   - Field: ‘earlySignal’
[17:37:34.385]   - Field: ‘lazy’
[17:37:34.386]   - Field: ‘state’
[17:37:34.386] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.386] - Launch lazy future ...
[17:37:34.386] Packages needed by the future expression (n = 0): <none>
[17:37:34.386] Packages needed by future strategies (n = 0): <none>
[17:37:34.386] {
[17:37:34.386]     {
[17:37:34.386]         {
[17:37:34.386]             ...future.startTime <- base::Sys.time()
[17:37:34.386]             {
[17:37:34.386]                 {
[17:37:34.386]                   {
[17:37:34.386]                     base::local({
[17:37:34.386]                       has_future <- base::requireNamespace("future", 
[17:37:34.386]                         quietly = TRUE)
[17:37:34.386]                       if (has_future) {
[17:37:34.386]                         ns <- base::getNamespace("future")
[17:37:34.386]                         version <- ns[[".package"]][["version"]]
[17:37:34.386]                         if (is.null(version)) 
[17:37:34.386]                           version <- utils::packageVersion("future")
[17:37:34.386]                       }
[17:37:34.386]                       else {
[17:37:34.386]                         version <- NULL
[17:37:34.386]                       }
[17:37:34.386]                       if (!has_future || version < "1.8.0") {
[17:37:34.386]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.386]                           "", base::R.version$version.string), 
[17:37:34.386]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:34.386]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.386]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.386]                             "release", "version")], collapse = " "), 
[17:37:34.386]                           hostname = base::Sys.info()[["nodename"]])
[17:37:34.386]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.386]                           info)
[17:37:34.386]                         info <- base::paste(info, collapse = "; ")
[17:37:34.386]                         if (!has_future) {
[17:37:34.386]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.386]                             info)
[17:37:34.386]                         }
[17:37:34.386]                         else {
[17:37:34.386]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.386]                             info, version)
[17:37:34.386]                         }
[17:37:34.386]                         base::stop(msg)
[17:37:34.386]                       }
[17:37:34.386]                     })
[17:37:34.386]                   }
[17:37:34.386]                   ...future.strategy.old <- future::plan("list")
[17:37:34.386]                   options(future.plan = NULL)
[17:37:34.386]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.386]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.386]                 }
[17:37:34.386]                 ...future.workdir <- getwd()
[17:37:34.386]             }
[17:37:34.386]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.386]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.386]         }
[17:37:34.386]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.386]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:34.386]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.386]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.386]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.386]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.386]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.386]             base::names(...future.oldOptions))
[17:37:34.386]     }
[17:37:34.386]     if (FALSE) {
[17:37:34.386]     }
[17:37:34.386]     else {
[17:37:34.386]         if (TRUE) {
[17:37:34.386]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.386]                 open = "w")
[17:37:34.386]         }
[17:37:34.386]         else {
[17:37:34.386]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.386]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.386]         }
[17:37:34.386]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.386]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.386]             base::sink(type = "output", split = FALSE)
[17:37:34.386]             base::close(...future.stdout)
[17:37:34.386]         }, add = TRUE)
[17:37:34.386]     }
[17:37:34.386]     ...future.frame <- base::sys.nframe()
[17:37:34.386]     ...future.conditions <- base::list()
[17:37:34.386]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.386]     if (FALSE) {
[17:37:34.386]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.386]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.386]     }
[17:37:34.386]     ...future.result <- base::tryCatch({
[17:37:34.386]         base::withCallingHandlers({
[17:37:34.386]             ...future.value <- base::withVisible(base::local({
[17:37:34.386]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.386]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.386]                   ...future.globals.maxSize)) {
[17:37:34.386]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.386]                   on.exit(options(oopts), add = TRUE)
[17:37:34.386]                 }
[17:37:34.386]                 {
[17:37:34.386]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.386]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.386]                     USE.NAMES = FALSE)
[17:37:34.386]                   do.call(mapply, args = args)
[17:37:34.386]                 }
[17:37:34.386]             }))
[17:37:34.386]             future::FutureResult(value = ...future.value$value, 
[17:37:34.386]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.386]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.386]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.386]                     ...future.globalenv.names))
[17:37:34.386]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.386]         }, condition = base::local({
[17:37:34.386]             c <- base::c
[17:37:34.386]             inherits <- base::inherits
[17:37:34.386]             invokeRestart <- base::invokeRestart
[17:37:34.386]             length <- base::length
[17:37:34.386]             list <- base::list
[17:37:34.386]             seq.int <- base::seq.int
[17:37:34.386]             signalCondition <- base::signalCondition
[17:37:34.386]             sys.calls <- base::sys.calls
[17:37:34.386]             `[[` <- base::`[[`
[17:37:34.386]             `+` <- base::`+`
[17:37:34.386]             `<<-` <- base::`<<-`
[17:37:34.386]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.386]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.386]                   3L)]
[17:37:34.386]             }
[17:37:34.386]             function(cond) {
[17:37:34.386]                 is_error <- inherits(cond, "error")
[17:37:34.386]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.386]                   NULL)
[17:37:34.386]                 if (is_error) {
[17:37:34.386]                   sessionInformation <- function() {
[17:37:34.386]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.386]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.386]                       search = base::search(), system = base::Sys.info())
[17:37:34.386]                   }
[17:37:34.386]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.386]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.386]                     cond$call), session = sessionInformation(), 
[17:37:34.386]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.386]                   signalCondition(cond)
[17:37:34.386]                 }
[17:37:34.386]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.386]                 "immediateCondition"))) {
[17:37:34.386]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.386]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.386]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.386]                   if (TRUE && !signal) {
[17:37:34.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.386]                     {
[17:37:34.386]                       inherits <- base::inherits
[17:37:34.386]                       invokeRestart <- base::invokeRestart
[17:37:34.386]                       is.null <- base::is.null
[17:37:34.386]                       muffled <- FALSE
[17:37:34.386]                       if (inherits(cond, "message")) {
[17:37:34.386]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.386]                         if (muffled) 
[17:37:34.386]                           invokeRestart("muffleMessage")
[17:37:34.386]                       }
[17:37:34.386]                       else if (inherits(cond, "warning")) {
[17:37:34.386]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.386]                         if (muffled) 
[17:37:34.386]                           invokeRestart("muffleWarning")
[17:37:34.386]                       }
[17:37:34.386]                       else if (inherits(cond, "condition")) {
[17:37:34.386]                         if (!is.null(pattern)) {
[17:37:34.386]                           computeRestarts <- base::computeRestarts
[17:37:34.386]                           grepl <- base::grepl
[17:37:34.386]                           restarts <- computeRestarts(cond)
[17:37:34.386]                           for (restart in restarts) {
[17:37:34.386]                             name <- restart$name
[17:37:34.386]                             if (is.null(name)) 
[17:37:34.386]                               next
[17:37:34.386]                             if (!grepl(pattern, name)) 
[17:37:34.386]                               next
[17:37:34.386]                             invokeRestart(restart)
[17:37:34.386]                             muffled <- TRUE
[17:37:34.386]                             break
[17:37:34.386]                           }
[17:37:34.386]                         }
[17:37:34.386]                       }
[17:37:34.386]                       invisible(muffled)
[17:37:34.386]                     }
[17:37:34.386]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.386]                   }
[17:37:34.386]                 }
[17:37:34.386]                 else {
[17:37:34.386]                   if (TRUE) {
[17:37:34.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.386]                     {
[17:37:34.386]                       inherits <- base::inherits
[17:37:34.386]                       invokeRestart <- base::invokeRestart
[17:37:34.386]                       is.null <- base::is.null
[17:37:34.386]                       muffled <- FALSE
[17:37:34.386]                       if (inherits(cond, "message")) {
[17:37:34.386]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.386]                         if (muffled) 
[17:37:34.386]                           invokeRestart("muffleMessage")
[17:37:34.386]                       }
[17:37:34.386]                       else if (inherits(cond, "warning")) {
[17:37:34.386]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.386]                         if (muffled) 
[17:37:34.386]                           invokeRestart("muffleWarning")
[17:37:34.386]                       }
[17:37:34.386]                       else if (inherits(cond, "condition")) {
[17:37:34.386]                         if (!is.null(pattern)) {
[17:37:34.386]                           computeRestarts <- base::computeRestarts
[17:37:34.386]                           grepl <- base::grepl
[17:37:34.386]                           restarts <- computeRestarts(cond)
[17:37:34.386]                           for (restart in restarts) {
[17:37:34.386]                             name <- restart$name
[17:37:34.386]                             if (is.null(name)) 
[17:37:34.386]                               next
[17:37:34.386]                             if (!grepl(pattern, name)) 
[17:37:34.386]                               next
[17:37:34.386]                             invokeRestart(restart)
[17:37:34.386]                             muffled <- TRUE
[17:37:34.386]                             break
[17:37:34.386]                           }
[17:37:34.386]                         }
[17:37:34.386]                       }
[17:37:34.386]                       invisible(muffled)
[17:37:34.386]                     }
[17:37:34.386]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.386]                   }
[17:37:34.386]                 }
[17:37:34.386]             }
[17:37:34.386]         }))
[17:37:34.386]     }, error = function(ex) {
[17:37:34.386]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.386]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.386]                 ...future.rng), started = ...future.startTime, 
[17:37:34.386]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.386]             version = "1.8"), class = "FutureResult")
[17:37:34.386]     }, finally = {
[17:37:34.386]         if (!identical(...future.workdir, getwd())) 
[17:37:34.386]             setwd(...future.workdir)
[17:37:34.386]         {
[17:37:34.386]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.386]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.386]             }
[17:37:34.386]             base::options(...future.oldOptions)
[17:37:34.386]             if (.Platform$OS.type == "windows") {
[17:37:34.386]                 old_names <- names(...future.oldEnvVars)
[17:37:34.386]                 envs <- base::Sys.getenv()
[17:37:34.386]                 names <- names(envs)
[17:37:34.386]                 common <- intersect(names, old_names)
[17:37:34.386]                 added <- setdiff(names, old_names)
[17:37:34.386]                 removed <- setdiff(old_names, names)
[17:37:34.386]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.386]                   envs[common]]
[17:37:34.386]                 NAMES <- toupper(changed)
[17:37:34.386]                 args <- list()
[17:37:34.386]                 for (kk in seq_along(NAMES)) {
[17:37:34.386]                   name <- changed[[kk]]
[17:37:34.386]                   NAME <- NAMES[[kk]]
[17:37:34.386]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.386]                     next
[17:37:34.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.386]                 }
[17:37:34.386]                 NAMES <- toupper(added)
[17:37:34.386]                 for (kk in seq_along(NAMES)) {
[17:37:34.386]                   name <- added[[kk]]
[17:37:34.386]                   NAME <- NAMES[[kk]]
[17:37:34.386]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.386]                     next
[17:37:34.386]                   args[[name]] <- ""
[17:37:34.386]                 }
[17:37:34.386]                 NAMES <- toupper(removed)
[17:37:34.386]                 for (kk in seq_along(NAMES)) {
[17:37:34.386]                   name <- removed[[kk]]
[17:37:34.386]                   NAME <- NAMES[[kk]]
[17:37:34.386]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.386]                     next
[17:37:34.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.386]                 }
[17:37:34.386]                 if (length(args) > 0) 
[17:37:34.386]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.386]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.386]             }
[17:37:34.386]             else {
[17:37:34.386]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.386]             }
[17:37:34.386]             {
[17:37:34.386]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.386]                   0L) {
[17:37:34.386]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.386]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.386]                   base::options(opts)
[17:37:34.386]                 }
[17:37:34.386]                 {
[17:37:34.386]                   {
[17:37:34.386]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:34.386]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:34.386]                     -1786728155L), envir = base::globalenv(), 
[17:37:34.386]                       inherits = FALSE)
[17:37:34.386]                     NULL
[17:37:34.386]                   }
[17:37:34.386]                   options(future.plan = NULL)
[17:37:34.386]                   if (is.na(NA_character_)) 
[17:37:34.386]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.386]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.386]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.386]                     .init = FALSE)
[17:37:34.386]                 }
[17:37:34.386]             }
[17:37:34.386]         }
[17:37:34.386]     })
[17:37:34.386]     if (TRUE) {
[17:37:34.386]         base::sink(type = "output", split = FALSE)
[17:37:34.386]         if (TRUE) {
[17:37:34.386]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.386]         }
[17:37:34.386]         else {
[17:37:34.386]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.386]         }
[17:37:34.386]         base::close(...future.stdout)
[17:37:34.386]         ...future.stdout <- NULL
[17:37:34.386]     }
[17:37:34.386]     ...future.result$conditions <- ...future.conditions
[17:37:34.386]     ...future.result$finished <- base::Sys.time()
[17:37:34.386]     ...future.result
[17:37:34.386] }
[17:37:34.388] assign_globals() ...
[17:37:34.388] List of 5
[17:37:34.388]  $ ...future.FUN            :function (x)  
[17:37:34.388]  $ MoreArgs                 : NULL
[17:37:34.388]  $ ...future.elements_ii    :List of 1
[17:37:34.388]   ..$ :List of 1
[17:37:34.388]   .. ..$ : Date[1:1], format: "2018-06-01"
[17:37:34.388]  $ ...future.seeds_ii       : NULL
[17:37:34.388]  $ ...future.globals.maxSize: NULL
[17:37:34.388]  - attr(*, "where")=List of 5
[17:37:34.388]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.388]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.388]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.388]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.388]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.388]  - attr(*, "resolved")= logi FALSE
[17:37:34.388]  - attr(*, "total_size")= num 1128
[17:37:34.388]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.388]  - attr(*, "already-done")= logi TRUE
[17:37:34.393] - copied ‘...future.FUN’ to environment
[17:37:34.393] - copied ‘MoreArgs’ to environment
[17:37:34.393] - copied ‘...future.elements_ii’ to environment
[17:37:34.393] - copied ‘...future.seeds_ii’ to environment
[17:37:34.393] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.393] assign_globals() ... done
[17:37:34.394] plan(): Setting new future strategy stack:
[17:37:34.394] List of future strategies:
[17:37:34.394] 1. sequential:
[17:37:34.394]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.394]    - tweaked: FALSE
[17:37:34.394]    - call: NULL
[17:37:34.394] plan(): nbrOfWorkers() = 1
[17:37:34.395] plan(): Setting new future strategy stack:
[17:37:34.395] List of future strategies:
[17:37:34.395] 1. sequential:
[17:37:34.395]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.395]    - tweaked: FALSE
[17:37:34.395]    - call: plan(strategy)
[17:37:34.395] plan(): nbrOfWorkers() = 1
[17:37:34.395] SequentialFuture started (and completed)
[17:37:34.396] - Launch lazy future ... done
[17:37:34.396] run() for ‘SequentialFuture’ ... done
[17:37:34.396] Created future:
[17:37:34.396] SequentialFuture:
[17:37:34.396] Label: ‘future_mapply-1’
[17:37:34.396] Expression:
[17:37:34.396] {
[17:37:34.396]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.396]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.396]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.396]         on.exit(options(oopts), add = TRUE)
[17:37:34.396]     }
[17:37:34.396]     {
[17:37:34.396]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.396]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.396]         do.call(mapply, args = args)
[17:37:34.396]     }
[17:37:34.396] }
[17:37:34.396] Lazy evaluation: FALSE
[17:37:34.396] Asynchronous evaluation: FALSE
[17:37:34.396] Local evaluation: TRUE
[17:37:34.396] Environment: R_GlobalEnv
[17:37:34.396] Capture standard output: TRUE
[17:37:34.396] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.396] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.396] Packages: <none>
[17:37:34.396] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.396] Resolved: TRUE
[17:37:34.396] Value: 280 bytes of class ‘list’
[17:37:34.396] Early signaling: FALSE
[17:37:34.396] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.396] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.397] Chunk #1 of 1 ... DONE
[17:37:34.397] Launching 1 futures (chunks) ... DONE
[17:37:34.397] Resolving 1 futures (chunks) ...
[17:37:34.397] resolve() on list ...
[17:37:34.397]  recursive: 0
[17:37:34.397]  length: 1
[17:37:34.398] 
[17:37:34.398] resolved() for ‘SequentialFuture’ ...
[17:37:34.398] - state: ‘finished’
[17:37:34.398] - run: TRUE
[17:37:34.398] - result: ‘FutureResult’
[17:37:34.398] resolved() for ‘SequentialFuture’ ... done
[17:37:34.398] Future #1
[17:37:34.398] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:34.398] - nx: 1
[17:37:34.398] - relay: TRUE
[17:37:34.399] - stdout: TRUE
[17:37:34.399] - signal: TRUE
[17:37:34.399] - resignal: FALSE
[17:37:34.399] - force: TRUE
[17:37:34.399] - relayed: [n=1] FALSE
[17:37:34.399] - queued futures: [n=1] FALSE
[17:37:34.399]  - until=1
[17:37:34.399]  - relaying element #1
[17:37:34.399] - relayed: [n=1] TRUE
[17:37:34.399] - queued futures: [n=1] TRUE
[17:37:34.399] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:34.400]  length: 0 (resolved future 1)
[17:37:34.400] Relaying remaining futures
[17:37:34.400] signalConditionsASAP(NULL, pos=0) ...
[17:37:34.400] - nx: 1
[17:37:34.400] - relay: TRUE
[17:37:34.400] - stdout: TRUE
[17:37:34.400] - signal: TRUE
[17:37:34.400] - resignal: FALSE
[17:37:34.400] - force: TRUE
[17:37:34.400] - relayed: [n=1] TRUE
[17:37:34.400] - queued futures: [n=1] TRUE
 - flush all
[17:37:34.401] - relayed: [n=1] TRUE
[17:37:34.401] - queued futures: [n=1] TRUE
[17:37:34.401] signalConditionsASAP(NULL, pos=0) ... done
[17:37:34.401] resolve() on list ... DONE
[17:37:34.401]  - Number of value chunks collected: 1
[17:37:34.401] Resolving 1 futures (chunks) ... DONE
[17:37:34.401] Reducing values from 1 chunks ...
[17:37:34.401]  - Number of values collected after concatenation: 1
[17:37:34.401]  - Number of values expected: 1
[17:37:34.402] Reducing values from 1 chunks ... DONE
[17:37:34.402] future_mapply() ... DONE
[17:37:34.402] future_mapply() ...
[17:37:34.402] Number of chunks: 1
[17:37:34.402] getGlobalsAndPackagesXApply() ...
[17:37:34.402]  - future.globals: TRUE
[17:37:34.402] getGlobalsAndPackages() ...
[17:37:34.402] Searching for globals...
[17:37:34.403] - globals found: [1] ‘FUN’
[17:37:34.403] Searching for globals ... DONE
[17:37:34.404] Resolving globals: FALSE
[17:37:34.405] The total size of the 1 globals is 848 bytes (848 bytes)
[17:37:34.406] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:37:34.406] - globals: [1] ‘FUN’
[17:37:34.406] 
[17:37:34.406] getGlobalsAndPackages() ... DONE
[17:37:34.406]  - globals found/used: [n=1] ‘FUN’
[17:37:34.406]  - needed namespaces: [n=0] 
[17:37:34.406] Finding globals ... DONE
[17:37:34.407] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:34.407] List of 2
[17:37:34.407]  $ ...future.FUN:function (x)  
[17:37:34.407]  $ MoreArgs     : list()
[17:37:34.407]  - attr(*, "where")=List of 2
[17:37:34.407]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:34.407]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:34.407]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.407]  - attr(*, "resolved")= logi FALSE
[17:37:34.407]  - attr(*, "total_size")= num NA
[17:37:34.409] Packages to be attached in all futures: [n=0] 
[17:37:34.409] getGlobalsAndPackagesXApply() ... DONE
[17:37:34.409] Number of futures (= number of chunks): 1
[17:37:34.409] Launching 1 futures (chunks) ...
[17:37:34.410] Chunk #1 of 1 ...
[17:37:34.410]  - Finding globals in '...' for chunk #1 ...
[17:37:34.410] getGlobalsAndPackages() ...
[17:37:34.410] Searching for globals...
[17:37:34.410] 
[17:37:34.410] Searching for globals ... DONE
[17:37:34.410] - globals: [0] <none>
[17:37:34.410] getGlobalsAndPackages() ... DONE
[17:37:34.411]    + additional globals found: [n=0] 
[17:37:34.411]    + additional namespaces needed: [n=0] 
[17:37:34.411]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:34.411]  - seeds: <none>
[17:37:34.411]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.411] getGlobalsAndPackages() ...
[17:37:34.411] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.411] Resolving globals: FALSE
[17:37:34.412] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[17:37:34.412] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:34.412] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.412] 
[17:37:34.412] getGlobalsAndPackages() ... DONE
[17:37:34.413] run() for ‘Future’ ...
[17:37:34.413] - state: ‘created’
[17:37:34.413] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.413] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.413] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.413]   - Field: ‘label’
[17:37:34.413]   - Field: ‘local’
[17:37:34.414]   - Field: ‘owner’
[17:37:34.414]   - Field: ‘envir’
[17:37:34.414]   - Field: ‘packages’
[17:37:34.414]   - Field: ‘gc’
[17:37:34.414]   - Field: ‘conditions’
[17:37:34.414]   - Field: ‘expr’
[17:37:34.414]   - Field: ‘uuid’
[17:37:34.414]   - Field: ‘seed’
[17:37:34.414]   - Field: ‘version’
[17:37:34.414]   - Field: ‘result’
[17:37:34.414]   - Field: ‘asynchronous’
[17:37:34.415]   - Field: ‘calls’
[17:37:34.415]   - Field: ‘globals’
[17:37:34.415]   - Field: ‘stdout’
[17:37:34.415]   - Field: ‘earlySignal’
[17:37:34.415]   - Field: ‘lazy’
[17:37:34.415]   - Field: ‘state’
[17:37:34.415] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.415] - Launch lazy future ...
[17:37:34.415] Packages needed by the future expression (n = 0): <none>
[17:37:34.415] Packages needed by future strategies (n = 0): <none>
[17:37:34.416] {
[17:37:34.416]     {
[17:37:34.416]         {
[17:37:34.416]             ...future.startTime <- base::Sys.time()
[17:37:34.416]             {
[17:37:34.416]                 {
[17:37:34.416]                   {
[17:37:34.416]                     base::local({
[17:37:34.416]                       has_future <- base::requireNamespace("future", 
[17:37:34.416]                         quietly = TRUE)
[17:37:34.416]                       if (has_future) {
[17:37:34.416]                         ns <- base::getNamespace("future")
[17:37:34.416]                         version <- ns[[".package"]][["version"]]
[17:37:34.416]                         if (is.null(version)) 
[17:37:34.416]                           version <- utils::packageVersion("future")
[17:37:34.416]                       }
[17:37:34.416]                       else {
[17:37:34.416]                         version <- NULL
[17:37:34.416]                       }
[17:37:34.416]                       if (!has_future || version < "1.8.0") {
[17:37:34.416]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.416]                           "", base::R.version$version.string), 
[17:37:34.416]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:34.416]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.416]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.416]                             "release", "version")], collapse = " "), 
[17:37:34.416]                           hostname = base::Sys.info()[["nodename"]])
[17:37:34.416]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.416]                           info)
[17:37:34.416]                         info <- base::paste(info, collapse = "; ")
[17:37:34.416]                         if (!has_future) {
[17:37:34.416]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.416]                             info)
[17:37:34.416]                         }
[17:37:34.416]                         else {
[17:37:34.416]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.416]                             info, version)
[17:37:34.416]                         }
[17:37:34.416]                         base::stop(msg)
[17:37:34.416]                       }
[17:37:34.416]                     })
[17:37:34.416]                   }
[17:37:34.416]                   ...future.strategy.old <- future::plan("list")
[17:37:34.416]                   options(future.plan = NULL)
[17:37:34.416]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.416]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.416]                 }
[17:37:34.416]                 ...future.workdir <- getwd()
[17:37:34.416]             }
[17:37:34.416]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.416]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.416]         }
[17:37:34.416]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.416]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:34.416]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.416]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.416]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.416]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.416]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.416]             base::names(...future.oldOptions))
[17:37:34.416]     }
[17:37:34.416]     if (FALSE) {
[17:37:34.416]     }
[17:37:34.416]     else {
[17:37:34.416]         if (TRUE) {
[17:37:34.416]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.416]                 open = "w")
[17:37:34.416]         }
[17:37:34.416]         else {
[17:37:34.416]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.416]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.416]         }
[17:37:34.416]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.416]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.416]             base::sink(type = "output", split = FALSE)
[17:37:34.416]             base::close(...future.stdout)
[17:37:34.416]         }, add = TRUE)
[17:37:34.416]     }
[17:37:34.416]     ...future.frame <- base::sys.nframe()
[17:37:34.416]     ...future.conditions <- base::list()
[17:37:34.416]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.416]     if (FALSE) {
[17:37:34.416]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.416]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.416]     }
[17:37:34.416]     ...future.result <- base::tryCatch({
[17:37:34.416]         base::withCallingHandlers({
[17:37:34.416]             ...future.value <- base::withVisible(base::local({
[17:37:34.416]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.416]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.416]                   ...future.globals.maxSize)) {
[17:37:34.416]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.416]                   on.exit(options(oopts), add = TRUE)
[17:37:34.416]                 }
[17:37:34.416]                 {
[17:37:34.416]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.416]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.416]                     USE.NAMES = FALSE)
[17:37:34.416]                   do.call(mapply, args = args)
[17:37:34.416]                 }
[17:37:34.416]             }))
[17:37:34.416]             future::FutureResult(value = ...future.value$value, 
[17:37:34.416]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.416]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.416]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.416]                     ...future.globalenv.names))
[17:37:34.416]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.416]         }, condition = base::local({
[17:37:34.416]             c <- base::c
[17:37:34.416]             inherits <- base::inherits
[17:37:34.416]             invokeRestart <- base::invokeRestart
[17:37:34.416]             length <- base::length
[17:37:34.416]             list <- base::list
[17:37:34.416]             seq.int <- base::seq.int
[17:37:34.416]             signalCondition <- base::signalCondition
[17:37:34.416]             sys.calls <- base::sys.calls
[17:37:34.416]             `[[` <- base::`[[`
[17:37:34.416]             `+` <- base::`+`
[17:37:34.416]             `<<-` <- base::`<<-`
[17:37:34.416]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.416]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.416]                   3L)]
[17:37:34.416]             }
[17:37:34.416]             function(cond) {
[17:37:34.416]                 is_error <- inherits(cond, "error")
[17:37:34.416]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.416]                   NULL)
[17:37:34.416]                 if (is_error) {
[17:37:34.416]                   sessionInformation <- function() {
[17:37:34.416]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.416]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.416]                       search = base::search(), system = base::Sys.info())
[17:37:34.416]                   }
[17:37:34.416]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.416]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.416]                     cond$call), session = sessionInformation(), 
[17:37:34.416]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.416]                   signalCondition(cond)
[17:37:34.416]                 }
[17:37:34.416]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.416]                 "immediateCondition"))) {
[17:37:34.416]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.416]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.416]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.416]                   if (TRUE && !signal) {
[17:37:34.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.416]                     {
[17:37:34.416]                       inherits <- base::inherits
[17:37:34.416]                       invokeRestart <- base::invokeRestart
[17:37:34.416]                       is.null <- base::is.null
[17:37:34.416]                       muffled <- FALSE
[17:37:34.416]                       if (inherits(cond, "message")) {
[17:37:34.416]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.416]                         if (muffled) 
[17:37:34.416]                           invokeRestart("muffleMessage")
[17:37:34.416]                       }
[17:37:34.416]                       else if (inherits(cond, "warning")) {
[17:37:34.416]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.416]                         if (muffled) 
[17:37:34.416]                           invokeRestart("muffleWarning")
[17:37:34.416]                       }
[17:37:34.416]                       else if (inherits(cond, "condition")) {
[17:37:34.416]                         if (!is.null(pattern)) {
[17:37:34.416]                           computeRestarts <- base::computeRestarts
[17:37:34.416]                           grepl <- base::grepl
[17:37:34.416]                           restarts <- computeRestarts(cond)
[17:37:34.416]                           for (restart in restarts) {
[17:37:34.416]                             name <- restart$name
[17:37:34.416]                             if (is.null(name)) 
[17:37:34.416]                               next
[17:37:34.416]                             if (!grepl(pattern, name)) 
[17:37:34.416]                               next
[17:37:34.416]                             invokeRestart(restart)
[17:37:34.416]                             muffled <- TRUE
[17:37:34.416]                             break
[17:37:34.416]                           }
[17:37:34.416]                         }
[17:37:34.416]                       }
[17:37:34.416]                       invisible(muffled)
[17:37:34.416]                     }
[17:37:34.416]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.416]                   }
[17:37:34.416]                 }
[17:37:34.416]                 else {
[17:37:34.416]                   if (TRUE) {
[17:37:34.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.416]                     {
[17:37:34.416]                       inherits <- base::inherits
[17:37:34.416]                       invokeRestart <- base::invokeRestart
[17:37:34.416]                       is.null <- base::is.null
[17:37:34.416]                       muffled <- FALSE
[17:37:34.416]                       if (inherits(cond, "message")) {
[17:37:34.416]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.416]                         if (muffled) 
[17:37:34.416]                           invokeRestart("muffleMessage")
[17:37:34.416]                       }
[17:37:34.416]                       else if (inherits(cond, "warning")) {
[17:37:34.416]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.416]                         if (muffled) 
[17:37:34.416]                           invokeRestart("muffleWarning")
[17:37:34.416]                       }
[17:37:34.416]                       else if (inherits(cond, "condition")) {
[17:37:34.416]                         if (!is.null(pattern)) {
[17:37:34.416]                           computeRestarts <- base::computeRestarts
[17:37:34.416]                           grepl <- base::grepl
[17:37:34.416]                           restarts <- computeRestarts(cond)
[17:37:34.416]                           for (restart in restarts) {
[17:37:34.416]                             name <- restart$name
[17:37:34.416]                             if (is.null(name)) 
[17:37:34.416]                               next
[17:37:34.416]                             if (!grepl(pattern, name)) 
[17:37:34.416]                               next
[17:37:34.416]                             invokeRestart(restart)
[17:37:34.416]                             muffled <- TRUE
[17:37:34.416]                             break
[17:37:34.416]                           }
[17:37:34.416]                         }
[17:37:34.416]                       }
[17:37:34.416]                       invisible(muffled)
[17:37:34.416]                     }
[17:37:34.416]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.416]                   }
[17:37:34.416]                 }
[17:37:34.416]             }
[17:37:34.416]         }))
[17:37:34.416]     }, error = function(ex) {
[17:37:34.416]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.416]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.416]                 ...future.rng), started = ...future.startTime, 
[17:37:34.416]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.416]             version = "1.8"), class = "FutureResult")
[17:37:34.416]     }, finally = {
[17:37:34.416]         if (!identical(...future.workdir, getwd())) 
[17:37:34.416]             setwd(...future.workdir)
[17:37:34.416]         {
[17:37:34.416]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.416]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.416]             }
[17:37:34.416]             base::options(...future.oldOptions)
[17:37:34.416]             if (.Platform$OS.type == "windows") {
[17:37:34.416]                 old_names <- names(...future.oldEnvVars)
[17:37:34.416]                 envs <- base::Sys.getenv()
[17:37:34.416]                 names <- names(envs)
[17:37:34.416]                 common <- intersect(names, old_names)
[17:37:34.416]                 added <- setdiff(names, old_names)
[17:37:34.416]                 removed <- setdiff(old_names, names)
[17:37:34.416]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.416]                   envs[common]]
[17:37:34.416]                 NAMES <- toupper(changed)
[17:37:34.416]                 args <- list()
[17:37:34.416]                 for (kk in seq_along(NAMES)) {
[17:37:34.416]                   name <- changed[[kk]]
[17:37:34.416]                   NAME <- NAMES[[kk]]
[17:37:34.416]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.416]                     next
[17:37:34.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.416]                 }
[17:37:34.416]                 NAMES <- toupper(added)
[17:37:34.416]                 for (kk in seq_along(NAMES)) {
[17:37:34.416]                   name <- added[[kk]]
[17:37:34.416]                   NAME <- NAMES[[kk]]
[17:37:34.416]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.416]                     next
[17:37:34.416]                   args[[name]] <- ""
[17:37:34.416]                 }
[17:37:34.416]                 NAMES <- toupper(removed)
[17:37:34.416]                 for (kk in seq_along(NAMES)) {
[17:37:34.416]                   name <- removed[[kk]]
[17:37:34.416]                   NAME <- NAMES[[kk]]
[17:37:34.416]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.416]                     next
[17:37:34.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.416]                 }
[17:37:34.416]                 if (length(args) > 0) 
[17:37:34.416]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.416]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.416]             }
[17:37:34.416]             else {
[17:37:34.416]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.416]             }
[17:37:34.416]             {
[17:37:34.416]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.416]                   0L) {
[17:37:34.416]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.416]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.416]                   base::options(opts)
[17:37:34.416]                 }
[17:37:34.416]                 {
[17:37:34.416]                   {
[17:37:34.416]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:34.416]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:34.416]                     -1786728155L), envir = base::globalenv(), 
[17:37:34.416]                       inherits = FALSE)
[17:37:34.416]                     NULL
[17:37:34.416]                   }
[17:37:34.416]                   options(future.plan = NULL)
[17:37:34.416]                   if (is.na(NA_character_)) 
[17:37:34.416]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.416]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.416]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.416]                     .init = FALSE)
[17:37:34.416]                 }
[17:37:34.416]             }
[17:37:34.416]         }
[17:37:34.416]     })
[17:37:34.416]     if (TRUE) {
[17:37:34.416]         base::sink(type = "output", split = FALSE)
[17:37:34.416]         if (TRUE) {
[17:37:34.416]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.416]         }
[17:37:34.416]         else {
[17:37:34.416]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.416]         }
[17:37:34.416]         base::close(...future.stdout)
[17:37:34.416]         ...future.stdout <- NULL
[17:37:34.416]     }
[17:37:34.416]     ...future.result$conditions <- ...future.conditions
[17:37:34.416]     ...future.result$finished <- base::Sys.time()
[17:37:34.416]     ...future.result
[17:37:34.416] }
[17:37:34.418] assign_globals() ...
[17:37:34.418] List of 5
[17:37:34.418]  $ ...future.FUN            :function (x)  
[17:37:34.418]  $ MoreArgs                 : list()
[17:37:34.418]  $ ...future.elements_ii    :List of 1
[17:37:34.418]   ..$ :List of 1
[17:37:34.418]   .. ..$ : Date[1:1], format: "2018-06-01"
[17:37:34.418]  $ ...future.seeds_ii       : NULL
[17:37:34.418]  $ ...future.globals.maxSize: NULL
[17:37:34.418]  - attr(*, "where")=List of 5
[17:37:34.418]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.418]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.418]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.418]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.418]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.418]  - attr(*, "resolved")= logi FALSE
[17:37:34.418]  - attr(*, "total_size")= num 1128
[17:37:34.418]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.418]  - attr(*, "already-done")= logi TRUE
[17:37:34.422] - copied ‘...future.FUN’ to environment
[17:37:34.422] - copied ‘MoreArgs’ to environment
[17:37:34.422] - copied ‘...future.elements_ii’ to environment
[17:37:34.422] - copied ‘...future.seeds_ii’ to environment
[17:37:34.422] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.422] assign_globals() ... done
[17:37:34.423] plan(): Setting new future strategy stack:
[17:37:34.423] List of future strategies:
[17:37:34.423] 1. sequential:
[17:37:34.423]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.423]    - tweaked: FALSE
[17:37:34.423]    - call: NULL
[17:37:34.423] plan(): nbrOfWorkers() = 1
[17:37:34.424] plan(): Setting new future strategy stack:
[17:37:34.424] List of future strategies:
[17:37:34.424] 1. sequential:
[17:37:34.424]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.424]    - tweaked: FALSE
[17:37:34.424]    - call: plan(strategy)
[17:37:34.425] plan(): nbrOfWorkers() = 1
[17:37:34.425] SequentialFuture started (and completed)
[17:37:34.425] - Launch lazy future ... done
[17:37:34.425] run() for ‘SequentialFuture’ ... done
[17:37:34.425] Created future:
[17:37:34.425] SequentialFuture:
[17:37:34.425] Label: ‘future_.mapply-1’
[17:37:34.425] Expression:
[17:37:34.425] {
[17:37:34.425]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.425]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.425]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.425]         on.exit(options(oopts), add = TRUE)
[17:37:34.425]     }
[17:37:34.425]     {
[17:37:34.425]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.425]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.425]         do.call(mapply, args = args)
[17:37:34.425]     }
[17:37:34.425] }
[17:37:34.425] Lazy evaluation: FALSE
[17:37:34.425] Asynchronous evaluation: FALSE
[17:37:34.425] Local evaluation: TRUE
[17:37:34.425] Environment: R_GlobalEnv
[17:37:34.425] Capture standard output: TRUE
[17:37:34.425] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.425] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.425] Packages: <none>
[17:37:34.425] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.425] Resolved: TRUE
[17:37:34.425] Value: 280 bytes of class ‘list’
[17:37:34.425] Early signaling: FALSE
[17:37:34.425] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.425] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.426] Chunk #1 of 1 ... DONE
[17:37:34.426] Launching 1 futures (chunks) ... DONE
[17:37:34.426] Resolving 1 futures (chunks) ...
[17:37:34.426] resolve() on list ...
[17:37:34.426]  recursive: 0
[17:37:34.426]  length: 1
[17:37:34.427] 
[17:37:34.427] resolved() for ‘SequentialFuture’ ...
[17:37:34.427] - state: ‘finished’
[17:37:34.427] - run: TRUE
[17:37:34.427] - result: ‘FutureResult’
[17:37:34.427] resolved() for ‘SequentialFuture’ ... done
[17:37:34.427] Future #1
[17:37:34.427] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:34.427] - nx: 1
[17:37:34.427] - relay: TRUE
[17:37:34.427] - stdout: TRUE
[17:37:34.428] - signal: TRUE
[17:37:34.428] - resignal: FALSE
[17:37:34.428] - force: TRUE
[17:37:34.428] - relayed: [n=1] FALSE
[17:37:34.428] - queued futures: [n=1] FALSE
[17:37:34.428]  - until=1
[17:37:34.428]  - relaying element #1
[17:37:34.428] - relayed: [n=1] TRUE
[17:37:34.428] - queued futures: [n=1] TRUE
[17:37:34.428] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:34.429]  length: 0 (resolved future 1)
[17:37:34.429] Relaying remaining futures
[17:37:34.430] signalConditionsASAP(NULL, pos=0) ...
[17:37:34.430] - nx: 1
[17:37:34.430] - relay: TRUE
[17:37:34.431] - stdout: TRUE
[17:37:34.431] - signal: TRUE
[17:37:34.431] - resignal: FALSE
[17:37:34.431] - force: TRUE
[17:37:34.431] - relayed: [n=1] TRUE
[17:37:34.431] - queued futures: [n=1] TRUE
 - flush all
[17:37:34.431] - relayed: [n=1] TRUE
[17:37:34.431] - queued futures: [n=1] TRUE
[17:37:34.431] signalConditionsASAP(NULL, pos=0) ... done
[17:37:34.431] resolve() on list ... DONE
[17:37:34.432]  - Number of value chunks collected: 1
[17:37:34.432] Resolving 1 futures (chunks) ... DONE
[17:37:34.432] Reducing values from 1 chunks ...
[17:37:34.432]  - Number of values collected after concatenation: 1
[17:37:34.432]  - Number of values expected: 1
[17:37:34.432] Reducing values from 1 chunks ... DONE
[17:37:34.432] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[17:37:34.433] future_mapply() ...
[17:37:34.433] Number of chunks: 1
[17:37:34.433] getGlobalsAndPackagesXApply() ...
[17:37:34.433]  - future.globals: TRUE
[17:37:34.433] getGlobalsAndPackages() ...
[17:37:34.433] Searching for globals...
[17:37:34.434] - globals found: [1] ‘FUN’
[17:37:34.434] Searching for globals ... DONE
[17:37:34.434] Resolving globals: FALSE
[17:37:34.435] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:37:34.435] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:37:34.435] - globals: [1] ‘FUN’
[17:37:34.435] 
[17:37:34.435] getGlobalsAndPackages() ... DONE
[17:37:34.435]  - globals found/used: [n=1] ‘FUN’
[17:37:34.435]  - needed namespaces: [n=0] 
[17:37:34.435] Finding globals ... DONE
[17:37:34.436] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:34.436] List of 2
[17:37:34.436]  $ ...future.FUN:function (x, y)  
[17:37:34.436]  $ MoreArgs     :List of 1
[17:37:34.436]   ..$ y: int [1:2] 3 4
[17:37:34.436]  - attr(*, "where")=List of 2
[17:37:34.436]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:34.436]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:34.436]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.436]  - attr(*, "resolved")= logi FALSE
[17:37:34.436]  - attr(*, "total_size")= num NA
[17:37:34.438] Packages to be attached in all futures: [n=0] 
[17:37:34.439] getGlobalsAndPackagesXApply() ... DONE
[17:37:34.439] Number of futures (= number of chunks): 1
[17:37:34.439] Launching 1 futures (chunks) ...
[17:37:34.439] Chunk #1 of 1 ...
[17:37:34.439]  - Finding globals in '...' for chunk #1 ...
[17:37:34.439] getGlobalsAndPackages() ...
[17:37:34.439] Searching for globals...
[17:37:34.440] 
[17:37:34.440] Searching for globals ... DONE
[17:37:34.440] - globals: [0] <none>
[17:37:34.440] getGlobalsAndPackages() ... DONE
[17:37:34.440]    + additional globals found: [n=0] 
[17:37:34.440]    + additional namespaces needed: [n=0] 
[17:37:34.440]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:34.440]  - seeds: <none>
[17:37:34.440]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.440] getGlobalsAndPackages() ...
[17:37:34.440] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.441] Resolving globals: FALSE
[17:37:34.441] The total size of the 5 globals is 1.83 KiB (1872 bytes)
[17:37:34.441] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:37:34.442] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.442] 
[17:37:34.442] getGlobalsAndPackages() ... DONE
[17:37:34.442] run() for ‘Future’ ...
[17:37:34.442] - state: ‘created’
[17:37:34.442] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.442] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.443] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.443]   - Field: ‘label’
[17:37:34.443]   - Field: ‘local’
[17:37:34.443]   - Field: ‘owner’
[17:37:34.443]   - Field: ‘envir’
[17:37:34.443]   - Field: ‘packages’
[17:37:34.443]   - Field: ‘gc’
[17:37:34.443]   - Field: ‘conditions’
[17:37:34.443]   - Field: ‘expr’
[17:37:34.443]   - Field: ‘uuid’
[17:37:34.444]   - Field: ‘seed’
[17:37:34.444]   - Field: ‘version’
[17:37:34.444]   - Field: ‘result’
[17:37:34.444]   - Field: ‘asynchronous’
[17:37:34.444]   - Field: ‘calls’
[17:37:34.444]   - Field: ‘globals’
[17:37:34.444]   - Field: ‘stdout’
[17:37:34.444]   - Field: ‘earlySignal’
[17:37:34.444]   - Field: ‘lazy’
[17:37:34.444]   - Field: ‘state’
[17:37:34.444] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.445] - Launch lazy future ...
[17:37:34.445] Packages needed by the future expression (n = 0): <none>
[17:37:34.445] Packages needed by future strategies (n = 0): <none>
[17:37:34.445] {
[17:37:34.445]     {
[17:37:34.445]         {
[17:37:34.445]             ...future.startTime <- base::Sys.time()
[17:37:34.445]             {
[17:37:34.445]                 {
[17:37:34.445]                   {
[17:37:34.445]                     base::local({
[17:37:34.445]                       has_future <- base::requireNamespace("future", 
[17:37:34.445]                         quietly = TRUE)
[17:37:34.445]                       if (has_future) {
[17:37:34.445]                         ns <- base::getNamespace("future")
[17:37:34.445]                         version <- ns[[".package"]][["version"]]
[17:37:34.445]                         if (is.null(version)) 
[17:37:34.445]                           version <- utils::packageVersion("future")
[17:37:34.445]                       }
[17:37:34.445]                       else {
[17:37:34.445]                         version <- NULL
[17:37:34.445]                       }
[17:37:34.445]                       if (!has_future || version < "1.8.0") {
[17:37:34.445]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.445]                           "", base::R.version$version.string), 
[17:37:34.445]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:34.445]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.445]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.445]                             "release", "version")], collapse = " "), 
[17:37:34.445]                           hostname = base::Sys.info()[["nodename"]])
[17:37:34.445]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.445]                           info)
[17:37:34.445]                         info <- base::paste(info, collapse = "; ")
[17:37:34.445]                         if (!has_future) {
[17:37:34.445]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.445]                             info)
[17:37:34.445]                         }
[17:37:34.445]                         else {
[17:37:34.445]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.445]                             info, version)
[17:37:34.445]                         }
[17:37:34.445]                         base::stop(msg)
[17:37:34.445]                       }
[17:37:34.445]                     })
[17:37:34.445]                   }
[17:37:34.445]                   ...future.strategy.old <- future::plan("list")
[17:37:34.445]                   options(future.plan = NULL)
[17:37:34.445]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.445]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.445]                 }
[17:37:34.445]                 ...future.workdir <- getwd()
[17:37:34.445]             }
[17:37:34.445]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.445]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.445]         }
[17:37:34.445]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.445]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:34.445]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.445]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.445]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.445]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.445]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.445]             base::names(...future.oldOptions))
[17:37:34.445]     }
[17:37:34.445]     if (FALSE) {
[17:37:34.445]     }
[17:37:34.445]     else {
[17:37:34.445]         if (TRUE) {
[17:37:34.445]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.445]                 open = "w")
[17:37:34.445]         }
[17:37:34.445]         else {
[17:37:34.445]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.445]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.445]         }
[17:37:34.445]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.445]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.445]             base::sink(type = "output", split = FALSE)
[17:37:34.445]             base::close(...future.stdout)
[17:37:34.445]         }, add = TRUE)
[17:37:34.445]     }
[17:37:34.445]     ...future.frame <- base::sys.nframe()
[17:37:34.445]     ...future.conditions <- base::list()
[17:37:34.445]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.445]     if (FALSE) {
[17:37:34.445]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.445]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.445]     }
[17:37:34.445]     ...future.result <- base::tryCatch({
[17:37:34.445]         base::withCallingHandlers({
[17:37:34.445]             ...future.value <- base::withVisible(base::local({
[17:37:34.445]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.445]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.445]                   ...future.globals.maxSize)) {
[17:37:34.445]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.445]                   on.exit(options(oopts), add = TRUE)
[17:37:34.445]                 }
[17:37:34.445]                 {
[17:37:34.445]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.445]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.445]                     USE.NAMES = FALSE)
[17:37:34.445]                   do.call(mapply, args = args)
[17:37:34.445]                 }
[17:37:34.445]             }))
[17:37:34.445]             future::FutureResult(value = ...future.value$value, 
[17:37:34.445]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.445]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.445]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.445]                     ...future.globalenv.names))
[17:37:34.445]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.445]         }, condition = base::local({
[17:37:34.445]             c <- base::c
[17:37:34.445]             inherits <- base::inherits
[17:37:34.445]             invokeRestart <- base::invokeRestart
[17:37:34.445]             length <- base::length
[17:37:34.445]             list <- base::list
[17:37:34.445]             seq.int <- base::seq.int
[17:37:34.445]             signalCondition <- base::signalCondition
[17:37:34.445]             sys.calls <- base::sys.calls
[17:37:34.445]             `[[` <- base::`[[`
[17:37:34.445]             `+` <- base::`+`
[17:37:34.445]             `<<-` <- base::`<<-`
[17:37:34.445]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.445]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.445]                   3L)]
[17:37:34.445]             }
[17:37:34.445]             function(cond) {
[17:37:34.445]                 is_error <- inherits(cond, "error")
[17:37:34.445]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.445]                   NULL)
[17:37:34.445]                 if (is_error) {
[17:37:34.445]                   sessionInformation <- function() {
[17:37:34.445]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.445]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.445]                       search = base::search(), system = base::Sys.info())
[17:37:34.445]                   }
[17:37:34.445]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.445]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.445]                     cond$call), session = sessionInformation(), 
[17:37:34.445]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.445]                   signalCondition(cond)
[17:37:34.445]                 }
[17:37:34.445]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.445]                 "immediateCondition"))) {
[17:37:34.445]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.445]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.445]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.445]                   if (TRUE && !signal) {
[17:37:34.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.445]                     {
[17:37:34.445]                       inherits <- base::inherits
[17:37:34.445]                       invokeRestart <- base::invokeRestart
[17:37:34.445]                       is.null <- base::is.null
[17:37:34.445]                       muffled <- FALSE
[17:37:34.445]                       if (inherits(cond, "message")) {
[17:37:34.445]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.445]                         if (muffled) 
[17:37:34.445]                           invokeRestart("muffleMessage")
[17:37:34.445]                       }
[17:37:34.445]                       else if (inherits(cond, "warning")) {
[17:37:34.445]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.445]                         if (muffled) 
[17:37:34.445]                           invokeRestart("muffleWarning")
[17:37:34.445]                       }
[17:37:34.445]                       else if (inherits(cond, "condition")) {
[17:37:34.445]                         if (!is.null(pattern)) {
[17:37:34.445]                           computeRestarts <- base::computeRestarts
[17:37:34.445]                           grepl <- base::grepl
[17:37:34.445]                           restarts <- computeRestarts(cond)
[17:37:34.445]                           for (restart in restarts) {
[17:37:34.445]                             name <- restart$name
[17:37:34.445]                             if (is.null(name)) 
[17:37:34.445]                               next
[17:37:34.445]                             if (!grepl(pattern, name)) 
[17:37:34.445]                               next
[17:37:34.445]                             invokeRestart(restart)
[17:37:34.445]                             muffled <- TRUE
[17:37:34.445]                             break
[17:37:34.445]                           }
[17:37:34.445]                         }
[17:37:34.445]                       }
[17:37:34.445]                       invisible(muffled)
[17:37:34.445]                     }
[17:37:34.445]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.445]                   }
[17:37:34.445]                 }
[17:37:34.445]                 else {
[17:37:34.445]                   if (TRUE) {
[17:37:34.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.445]                     {
[17:37:34.445]                       inherits <- base::inherits
[17:37:34.445]                       invokeRestart <- base::invokeRestart
[17:37:34.445]                       is.null <- base::is.null
[17:37:34.445]                       muffled <- FALSE
[17:37:34.445]                       if (inherits(cond, "message")) {
[17:37:34.445]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.445]                         if (muffled) 
[17:37:34.445]                           invokeRestart("muffleMessage")
[17:37:34.445]                       }
[17:37:34.445]                       else if (inherits(cond, "warning")) {
[17:37:34.445]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.445]                         if (muffled) 
[17:37:34.445]                           invokeRestart("muffleWarning")
[17:37:34.445]                       }
[17:37:34.445]                       else if (inherits(cond, "condition")) {
[17:37:34.445]                         if (!is.null(pattern)) {
[17:37:34.445]                           computeRestarts <- base::computeRestarts
[17:37:34.445]                           grepl <- base::grepl
[17:37:34.445]                           restarts <- computeRestarts(cond)
[17:37:34.445]                           for (restart in restarts) {
[17:37:34.445]                             name <- restart$name
[17:37:34.445]                             if (is.null(name)) 
[17:37:34.445]                               next
[17:37:34.445]                             if (!grepl(pattern, name)) 
[17:37:34.445]                               next
[17:37:34.445]                             invokeRestart(restart)
[17:37:34.445]                             muffled <- TRUE
[17:37:34.445]                             break
[17:37:34.445]                           }
[17:37:34.445]                         }
[17:37:34.445]                       }
[17:37:34.445]                       invisible(muffled)
[17:37:34.445]                     }
[17:37:34.445]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.445]                   }
[17:37:34.445]                 }
[17:37:34.445]             }
[17:37:34.445]         }))
[17:37:34.445]     }, error = function(ex) {
[17:37:34.445]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.445]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.445]                 ...future.rng), started = ...future.startTime, 
[17:37:34.445]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.445]             version = "1.8"), class = "FutureResult")
[17:37:34.445]     }, finally = {
[17:37:34.445]         if (!identical(...future.workdir, getwd())) 
[17:37:34.445]             setwd(...future.workdir)
[17:37:34.445]         {
[17:37:34.445]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.445]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.445]             }
[17:37:34.445]             base::options(...future.oldOptions)
[17:37:34.445]             if (.Platform$OS.type == "windows") {
[17:37:34.445]                 old_names <- names(...future.oldEnvVars)
[17:37:34.445]                 envs <- base::Sys.getenv()
[17:37:34.445]                 names <- names(envs)
[17:37:34.445]                 common <- intersect(names, old_names)
[17:37:34.445]                 added <- setdiff(names, old_names)
[17:37:34.445]                 removed <- setdiff(old_names, names)
[17:37:34.445]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.445]                   envs[common]]
[17:37:34.445]                 NAMES <- toupper(changed)
[17:37:34.445]                 args <- list()
[17:37:34.445]                 for (kk in seq_along(NAMES)) {
[17:37:34.445]                   name <- changed[[kk]]
[17:37:34.445]                   NAME <- NAMES[[kk]]
[17:37:34.445]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.445]                     next
[17:37:34.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.445]                 }
[17:37:34.445]                 NAMES <- toupper(added)
[17:37:34.445]                 for (kk in seq_along(NAMES)) {
[17:37:34.445]                   name <- added[[kk]]
[17:37:34.445]                   NAME <- NAMES[[kk]]
[17:37:34.445]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.445]                     next
[17:37:34.445]                   args[[name]] <- ""
[17:37:34.445]                 }
[17:37:34.445]                 NAMES <- toupper(removed)
[17:37:34.445]                 for (kk in seq_along(NAMES)) {
[17:37:34.445]                   name <- removed[[kk]]
[17:37:34.445]                   NAME <- NAMES[[kk]]
[17:37:34.445]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.445]                     next
[17:37:34.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.445]                 }
[17:37:34.445]                 if (length(args) > 0) 
[17:37:34.445]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.445]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.445]             }
[17:37:34.445]             else {
[17:37:34.445]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.445]             }
[17:37:34.445]             {
[17:37:34.445]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.445]                   0L) {
[17:37:34.445]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.445]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.445]                   base::options(opts)
[17:37:34.445]                 }
[17:37:34.445]                 {
[17:37:34.445]                   {
[17:37:34.445]                     base::assign(".Random.seed", c(10407L, 159827702L, 
[17:37:34.445]                     59078765L, -156231338L, -106622811L, 1431714870L, 
[17:37:34.445]                     -1786728155L), envir = base::globalenv(), 
[17:37:34.445]                       inherits = FALSE)
[17:37:34.445]                     NULL
[17:37:34.445]                   }
[17:37:34.445]                   options(future.plan = NULL)
[17:37:34.445]                   if (is.na(NA_character_)) 
[17:37:34.445]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.445]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.445]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.445]                     .init = FALSE)
[17:37:34.445]                 }
[17:37:34.445]             }
[17:37:34.445]         }
[17:37:34.445]     })
[17:37:34.445]     if (TRUE) {
[17:37:34.445]         base::sink(type = "output", split = FALSE)
[17:37:34.445]         if (TRUE) {
[17:37:34.445]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.445]         }
[17:37:34.445]         else {
[17:37:34.445]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.445]         }
[17:37:34.445]         base::close(...future.stdout)
[17:37:34.445]         ...future.stdout <- NULL
[17:37:34.445]     }
[17:37:34.445]     ...future.result$conditions <- ...future.conditions
[17:37:34.445]     ...future.result$finished <- base::Sys.time()
[17:37:34.445]     ...future.result
[17:37:34.445] }
[17:37:34.447] assign_globals() ...
[17:37:34.447] List of 5
[17:37:34.447]  $ ...future.FUN            :function (x, y)  
[17:37:34.447]  $ MoreArgs                 :List of 1
[17:37:34.447]   ..$ y: int [1:2] 3 4
[17:37:34.447]  $ ...future.elements_ii    :List of 1
[17:37:34.447]   ..$ x:List of 2
[17:37:34.447]   .. ..$ : int 1
[17:37:34.447]   .. ..$ : int 2
[17:37:34.447]  $ ...future.seeds_ii       : NULL
[17:37:34.447]  $ ...future.globals.maxSize: NULL
[17:37:34.447]  - attr(*, "where")=List of 5
[17:37:34.447]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.447]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.447]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.447]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.447]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.447]  - attr(*, "resolved")= logi FALSE
[17:37:34.447]  - attr(*, "total_size")= num 1872
[17:37:34.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.447]  - attr(*, "already-done")= logi TRUE
[17:37:34.452] - reassign environment for ‘...future.FUN’
[17:37:34.452] - copied ‘...future.FUN’ to environment
[17:37:34.452] - copied ‘MoreArgs’ to environment
[17:37:34.452] - copied ‘...future.elements_ii’ to environment
[17:37:34.452] - copied ‘...future.seeds_ii’ to environment
[17:37:34.453] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.453] assign_globals() ... done
[17:37:34.453] plan(): Setting new future strategy stack:
[17:37:34.453] List of future strategies:
[17:37:34.453] 1. sequential:
[17:37:34.453]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.453]    - tweaked: FALSE
[17:37:34.453]    - call: NULL
[17:37:34.455] plan(): nbrOfWorkers() = 1
[17:37:34.456] plan(): Setting new future strategy stack:
[17:37:34.456] List of future strategies:
[17:37:34.456] 1. sequential:
[17:37:34.456]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.456]    - tweaked: FALSE
[17:37:34.456]    - call: plan(strategy)
[17:37:34.456] plan(): nbrOfWorkers() = 1
[17:37:34.456] SequentialFuture started (and completed)
[17:37:34.457] - Launch lazy future ... done
[17:37:34.457] run() for ‘SequentialFuture’ ... done
[17:37:34.457] Created future:
[17:37:34.457] SequentialFuture:
[17:37:34.457] Label: ‘future_mapply-1’
[17:37:34.457] Expression:
[17:37:34.457] {
[17:37:34.457]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.457]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.457]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.457]         on.exit(options(oopts), add = TRUE)
[17:37:34.457]     }
[17:37:34.457]     {
[17:37:34.457]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.457]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.457]         do.call(mapply, args = args)
[17:37:34.457]     }
[17:37:34.457] }
[17:37:34.457] Lazy evaluation: FALSE
[17:37:34.457] Asynchronous evaluation: FALSE
[17:37:34.457] Local evaluation: TRUE
[17:37:34.457] Environment: R_GlobalEnv
[17:37:34.457] Capture standard output: TRUE
[17:37:34.457] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.457] Globals: 5 objects totaling 1.83 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.457] Packages: <none>
[17:37:34.457] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.457] Resolved: TRUE
[17:37:34.457] Value: 112 bytes of class ‘list’
[17:37:34.457] Early signaling: FALSE
[17:37:34.457] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.457] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.458] Chunk #1 of 1 ... DONE
[17:37:34.458] Launching 1 futures (chunks) ... DONE
[17:37:34.458] Resolving 1 futures (chunks) ...
[17:37:34.458] resolve() on list ...
[17:37:34.458]  recursive: 0
[17:37:34.458]  length: 1
[17:37:34.458] 
[17:37:34.458] resolved() for ‘SequentialFuture’ ...
[17:37:34.458] - state: ‘finished’
[17:37:34.459] - run: TRUE
[17:37:34.459] - result: ‘FutureResult’
[17:37:34.459] resolved() for ‘SequentialFuture’ ... done
[17:37:34.459] Future #1
[17:37:34.459] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:34.459] - nx: 1
[17:37:34.459] - relay: TRUE
[17:37:34.459] - stdout: TRUE
[17:37:34.459] - signal: TRUE
[17:37:34.459] - resignal: FALSE
[17:37:34.459] - force: TRUE
[17:37:34.460] - relayed: [n=1] FALSE
[17:37:34.460] - queued futures: [n=1] FALSE
[17:37:34.460]  - until=1
[17:37:34.460]  - relaying element #1
[17:37:34.460] - relayed: [n=1] TRUE
[17:37:34.460] - queued futures: [n=1] TRUE
[17:37:34.460] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:34.460]  length: 0 (resolved future 1)
[17:37:34.460] Relaying remaining futures
[17:37:34.461] signalConditionsASAP(NULL, pos=0) ...
[17:37:34.461] - nx: 1
[17:37:34.461] - relay: TRUE
[17:37:34.461] - stdout: TRUE
[17:37:34.461] - signal: TRUE
[17:37:34.461] - resignal: FALSE
[17:37:34.461] - force: TRUE
[17:37:34.461] - relayed: [n=1] TRUE
[17:37:34.461] - queued futures: [n=1] TRUE
 - flush all
[17:37:34.461] - relayed: [n=1] TRUE
[17:37:34.461] - queued futures: [n=1] TRUE
[17:37:34.462] signalConditionsASAP(NULL, pos=0) ... done
[17:37:34.462] resolve() on list ... DONE
[17:37:34.462]  - Number of value chunks collected: 1
[17:37:34.462] Resolving 1 futures (chunks) ... DONE
[17:37:34.462] Reducing values from 1 chunks ...
[17:37:34.462]  - Number of values collected after concatenation: 2
[17:37:34.462]  - Number of values expected: 2
[17:37:34.462] Reducing values from 1 chunks ... DONE
[17:37:34.462] future_mapply() ... DONE
[17:37:34.462] future_mapply() ...
[17:37:34.463] Generating random seeds ...
[17:37:34.463] Generating random seed streams for 2 elements ...
[17:37:34.463] Generating random seed streams for 2 elements ... DONE
[17:37:34.463] Generating random seeds ... DONE
[17:37:34.463] Will set RNG state on exit: 10407, -156231338, 1207257725, 1615515356, -1786728155, 917879648, -1988804446
[17:37:34.463] Number of chunks: 1
[17:37:34.463] getGlobalsAndPackagesXApply() ...
[17:37:34.463]  - future.globals: TRUE
[17:37:34.463] getGlobalsAndPackages() ...
[17:37:34.463] Searching for globals...
[17:37:34.464] - globals found: [1] ‘FUN’
[17:37:34.465] Searching for globals ... DONE
[17:37:34.465] Resolving globals: FALSE
[17:37:34.465] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:37:34.465] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:37:34.465] - globals: [1] ‘FUN’
[17:37:34.465] 
[17:37:34.465] getGlobalsAndPackages() ... DONE
[17:37:34.466]  - globals found/used: [n=1] ‘FUN’
[17:37:34.466]  - needed namespaces: [n=0] 
[17:37:34.466] Finding globals ... DONE
[17:37:34.466] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:34.466] List of 2
[17:37:34.466]  $ ...future.FUN:function (x, y)  
[17:37:34.466]  $ MoreArgs     :List of 1
[17:37:34.466]   ..$ y: int [1:2] 3 4
[17:37:34.466]  - attr(*, "where")=List of 2
[17:37:34.466]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:34.466]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:34.466]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.466]  - attr(*, "resolved")= logi FALSE
[17:37:34.466]  - attr(*, "total_size")= num NA
[17:37:34.469] Packages to be attached in all futures: [n=0] 
[17:37:34.469] getGlobalsAndPackagesXApply() ... DONE
[17:37:34.469] Number of futures (= number of chunks): 1
[17:37:34.469] Launching 1 futures (chunks) ...
[17:37:34.469] Chunk #1 of 1 ...
[17:37:34.469]  - Finding globals in '...' for chunk #1 ...
[17:37:34.470] getGlobalsAndPackages() ...
[17:37:34.470] Searching for globals...
[17:37:34.470] 
[17:37:34.470] Searching for globals ... DONE
[17:37:34.470] - globals: [0] <none>
[17:37:34.470] getGlobalsAndPackages() ... DONE
[17:37:34.470]    + additional globals found: [n=0] 
[17:37:34.470]    + additional namespaces needed: [n=0] 
[17:37:34.471]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:34.471]  - seeds: [2] <seeds>
[17:37:34.471]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.471] getGlobalsAndPackages() ...
[17:37:34.471] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.471] Resolving globals: FALSE
[17:37:34.472] The total size of the 5 globals is 1.98 KiB (2032 bytes)
[17:37:34.472] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.98 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (160 bytes of class ‘list’) and ‘...future.elements_ii’ (112 bytes of class ‘list’)
[17:37:34.472] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.472] 
[17:37:34.472] getGlobalsAndPackages() ... DONE
[17:37:34.473] run() for ‘Future’ ...
[17:37:34.473] - state: ‘created’
[17:37:34.473] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.473] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.473] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.473]   - Field: ‘label’
[17:37:34.473]   - Field: ‘local’
[17:37:34.474]   - Field: ‘owner’
[17:37:34.474]   - Field: ‘envir’
[17:37:34.474]   - Field: ‘packages’
[17:37:34.474]   - Field: ‘gc’
[17:37:34.474]   - Field: ‘conditions’
[17:37:34.474]   - Field: ‘expr’
[17:37:34.474]   - Field: ‘uuid’
[17:37:34.474]   - Field: ‘seed’
[17:37:34.474]   - Field: ‘version’
[17:37:34.474]   - Field: ‘result’
[17:37:34.474]   - Field: ‘asynchronous’
[17:37:34.475]   - Field: ‘calls’
[17:37:34.475]   - Field: ‘globals’
[17:37:34.475]   - Field: ‘stdout’
[17:37:34.475]   - Field: ‘earlySignal’
[17:37:34.475]   - Field: ‘lazy’
[17:37:34.475]   - Field: ‘state’
[17:37:34.475] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.475] - Launch lazy future ...
[17:37:34.475] Packages needed by the future expression (n = 0): <none>
[17:37:34.475] Packages needed by future strategies (n = 0): <none>
[17:37:34.476] {
[17:37:34.476]     {
[17:37:34.476]         {
[17:37:34.476]             ...future.startTime <- base::Sys.time()
[17:37:34.476]             {
[17:37:34.476]                 {
[17:37:34.476]                   {
[17:37:34.476]                     base::local({
[17:37:34.476]                       has_future <- base::requireNamespace("future", 
[17:37:34.476]                         quietly = TRUE)
[17:37:34.476]                       if (has_future) {
[17:37:34.476]                         ns <- base::getNamespace("future")
[17:37:34.476]                         version <- ns[[".package"]][["version"]]
[17:37:34.476]                         if (is.null(version)) 
[17:37:34.476]                           version <- utils::packageVersion("future")
[17:37:34.476]                       }
[17:37:34.476]                       else {
[17:37:34.476]                         version <- NULL
[17:37:34.476]                       }
[17:37:34.476]                       if (!has_future || version < "1.8.0") {
[17:37:34.476]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.476]                           "", base::R.version$version.string), 
[17:37:34.476]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:34.476]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.476]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.476]                             "release", "version")], collapse = " "), 
[17:37:34.476]                           hostname = base::Sys.info()[["nodename"]])
[17:37:34.476]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.476]                           info)
[17:37:34.476]                         info <- base::paste(info, collapse = "; ")
[17:37:34.476]                         if (!has_future) {
[17:37:34.476]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.476]                             info)
[17:37:34.476]                         }
[17:37:34.476]                         else {
[17:37:34.476]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.476]                             info, version)
[17:37:34.476]                         }
[17:37:34.476]                         base::stop(msg)
[17:37:34.476]                       }
[17:37:34.476]                     })
[17:37:34.476]                   }
[17:37:34.476]                   ...future.strategy.old <- future::plan("list")
[17:37:34.476]                   options(future.plan = NULL)
[17:37:34.476]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.476]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.476]                 }
[17:37:34.476]                 ...future.workdir <- getwd()
[17:37:34.476]             }
[17:37:34.476]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.476]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.476]         }
[17:37:34.476]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.476]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:34.476]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.476]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.476]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.476]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.476]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.476]             base::names(...future.oldOptions))
[17:37:34.476]     }
[17:37:34.476]     if (FALSE) {
[17:37:34.476]     }
[17:37:34.476]     else {
[17:37:34.476]         if (TRUE) {
[17:37:34.476]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.476]                 open = "w")
[17:37:34.476]         }
[17:37:34.476]         else {
[17:37:34.476]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.476]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.476]         }
[17:37:34.476]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.476]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.476]             base::sink(type = "output", split = FALSE)
[17:37:34.476]             base::close(...future.stdout)
[17:37:34.476]         }, add = TRUE)
[17:37:34.476]     }
[17:37:34.476]     ...future.frame <- base::sys.nframe()
[17:37:34.476]     ...future.conditions <- base::list()
[17:37:34.476]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.476]     if (FALSE) {
[17:37:34.476]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.476]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.476]     }
[17:37:34.476]     ...future.result <- base::tryCatch({
[17:37:34.476]         base::withCallingHandlers({
[17:37:34.476]             ...future.value <- base::withVisible(base::local({
[17:37:34.476]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.476]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.476]                   ...future.globals.maxSize)) {
[17:37:34.476]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.476]                   on.exit(options(oopts), add = TRUE)
[17:37:34.476]                 }
[17:37:34.476]                 {
[17:37:34.476]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:37:34.476]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[17:37:34.476]                       envir = globalenv(), inherits = FALSE)
[17:37:34.476]                     ...future.FUN(...)
[17:37:34.476]                   }
[17:37:34.476]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:37:34.476]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:37:34.476]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.476]                     USE.NAMES = FALSE)
[17:37:34.476]                   do.call(mapply, args = args)
[17:37:34.476]                 }
[17:37:34.476]             }))
[17:37:34.476]             future::FutureResult(value = ...future.value$value, 
[17:37:34.476]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.476]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.476]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.476]                     ...future.globalenv.names))
[17:37:34.476]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.476]         }, condition = base::local({
[17:37:34.476]             c <- base::c
[17:37:34.476]             inherits <- base::inherits
[17:37:34.476]             invokeRestart <- base::invokeRestart
[17:37:34.476]             length <- base::length
[17:37:34.476]             list <- base::list
[17:37:34.476]             seq.int <- base::seq.int
[17:37:34.476]             signalCondition <- base::signalCondition
[17:37:34.476]             sys.calls <- base::sys.calls
[17:37:34.476]             `[[` <- base::`[[`
[17:37:34.476]             `+` <- base::`+`
[17:37:34.476]             `<<-` <- base::`<<-`
[17:37:34.476]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.476]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.476]                   3L)]
[17:37:34.476]             }
[17:37:34.476]             function(cond) {
[17:37:34.476]                 is_error <- inherits(cond, "error")
[17:37:34.476]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.476]                   NULL)
[17:37:34.476]                 if (is_error) {
[17:37:34.476]                   sessionInformation <- function() {
[17:37:34.476]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.476]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.476]                       search = base::search(), system = base::Sys.info())
[17:37:34.476]                   }
[17:37:34.476]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.476]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.476]                     cond$call), session = sessionInformation(), 
[17:37:34.476]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.476]                   signalCondition(cond)
[17:37:34.476]                 }
[17:37:34.476]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.476]                 "immediateCondition"))) {
[17:37:34.476]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.476]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.476]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.476]                   if (TRUE && !signal) {
[17:37:34.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.476]                     {
[17:37:34.476]                       inherits <- base::inherits
[17:37:34.476]                       invokeRestart <- base::invokeRestart
[17:37:34.476]                       is.null <- base::is.null
[17:37:34.476]                       muffled <- FALSE
[17:37:34.476]                       if (inherits(cond, "message")) {
[17:37:34.476]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.476]                         if (muffled) 
[17:37:34.476]                           invokeRestart("muffleMessage")
[17:37:34.476]                       }
[17:37:34.476]                       else if (inherits(cond, "warning")) {
[17:37:34.476]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.476]                         if (muffled) 
[17:37:34.476]                           invokeRestart("muffleWarning")
[17:37:34.476]                       }
[17:37:34.476]                       else if (inherits(cond, "condition")) {
[17:37:34.476]                         if (!is.null(pattern)) {
[17:37:34.476]                           computeRestarts <- base::computeRestarts
[17:37:34.476]                           grepl <- base::grepl
[17:37:34.476]                           restarts <- computeRestarts(cond)
[17:37:34.476]                           for (restart in restarts) {
[17:37:34.476]                             name <- restart$name
[17:37:34.476]                             if (is.null(name)) 
[17:37:34.476]                               next
[17:37:34.476]                             if (!grepl(pattern, name)) 
[17:37:34.476]                               next
[17:37:34.476]                             invokeRestart(restart)
[17:37:34.476]                             muffled <- TRUE
[17:37:34.476]                             break
[17:37:34.476]                           }
[17:37:34.476]                         }
[17:37:34.476]                       }
[17:37:34.476]                       invisible(muffled)
[17:37:34.476]                     }
[17:37:34.476]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.476]                   }
[17:37:34.476]                 }
[17:37:34.476]                 else {
[17:37:34.476]                   if (TRUE) {
[17:37:34.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.476]                     {
[17:37:34.476]                       inherits <- base::inherits
[17:37:34.476]                       invokeRestart <- base::invokeRestart
[17:37:34.476]                       is.null <- base::is.null
[17:37:34.476]                       muffled <- FALSE
[17:37:34.476]                       if (inherits(cond, "message")) {
[17:37:34.476]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.476]                         if (muffled) 
[17:37:34.476]                           invokeRestart("muffleMessage")
[17:37:34.476]                       }
[17:37:34.476]                       else if (inherits(cond, "warning")) {
[17:37:34.476]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.476]                         if (muffled) 
[17:37:34.476]                           invokeRestart("muffleWarning")
[17:37:34.476]                       }
[17:37:34.476]                       else if (inherits(cond, "condition")) {
[17:37:34.476]                         if (!is.null(pattern)) {
[17:37:34.476]                           computeRestarts <- base::computeRestarts
[17:37:34.476]                           grepl <- base::grepl
[17:37:34.476]                           restarts <- computeRestarts(cond)
[17:37:34.476]                           for (restart in restarts) {
[17:37:34.476]                             name <- restart$name
[17:37:34.476]                             if (is.null(name)) 
[17:37:34.476]                               next
[17:37:34.476]                             if (!grepl(pattern, name)) 
[17:37:34.476]                               next
[17:37:34.476]                             invokeRestart(restart)
[17:37:34.476]                             muffled <- TRUE
[17:37:34.476]                             break
[17:37:34.476]                           }
[17:37:34.476]                         }
[17:37:34.476]                       }
[17:37:34.476]                       invisible(muffled)
[17:37:34.476]                     }
[17:37:34.476]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.476]                   }
[17:37:34.476]                 }
[17:37:34.476]             }
[17:37:34.476]         }))
[17:37:34.476]     }, error = function(ex) {
[17:37:34.476]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.476]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.476]                 ...future.rng), started = ...future.startTime, 
[17:37:34.476]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.476]             version = "1.8"), class = "FutureResult")
[17:37:34.476]     }, finally = {
[17:37:34.476]         if (!identical(...future.workdir, getwd())) 
[17:37:34.476]             setwd(...future.workdir)
[17:37:34.476]         {
[17:37:34.476]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.476]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.476]             }
[17:37:34.476]             base::options(...future.oldOptions)
[17:37:34.476]             if (.Platform$OS.type == "windows") {
[17:37:34.476]                 old_names <- names(...future.oldEnvVars)
[17:37:34.476]                 envs <- base::Sys.getenv()
[17:37:34.476]                 names <- names(envs)
[17:37:34.476]                 common <- intersect(names, old_names)
[17:37:34.476]                 added <- setdiff(names, old_names)
[17:37:34.476]                 removed <- setdiff(old_names, names)
[17:37:34.476]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.476]                   envs[common]]
[17:37:34.476]                 NAMES <- toupper(changed)
[17:37:34.476]                 args <- list()
[17:37:34.476]                 for (kk in seq_along(NAMES)) {
[17:37:34.476]                   name <- changed[[kk]]
[17:37:34.476]                   NAME <- NAMES[[kk]]
[17:37:34.476]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.476]                     next
[17:37:34.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.476]                 }
[17:37:34.476]                 NAMES <- toupper(added)
[17:37:34.476]                 for (kk in seq_along(NAMES)) {
[17:37:34.476]                   name <- added[[kk]]
[17:37:34.476]                   NAME <- NAMES[[kk]]
[17:37:34.476]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.476]                     next
[17:37:34.476]                   args[[name]] <- ""
[17:37:34.476]                 }
[17:37:34.476]                 NAMES <- toupper(removed)
[17:37:34.476]                 for (kk in seq_along(NAMES)) {
[17:37:34.476]                   name <- removed[[kk]]
[17:37:34.476]                   NAME <- NAMES[[kk]]
[17:37:34.476]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.476]                     next
[17:37:34.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.476]                 }
[17:37:34.476]                 if (length(args) > 0) 
[17:37:34.476]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.476]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.476]             }
[17:37:34.476]             else {
[17:37:34.476]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.476]             }
[17:37:34.476]             {
[17:37:34.476]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.476]                   0L) {
[17:37:34.476]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.476]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.476]                   base::options(opts)
[17:37:34.476]                 }
[17:37:34.476]                 {
[17:37:34.476]                   {
[17:37:34.476]                     base::assign(".Random.seed", c(10407L, -156231338L, 
[17:37:34.476]                     1207257725L, 1615515356L, -1786728155L, 917879648L, 
[17:37:34.476]                     -1988804446L), envir = base::globalenv(), 
[17:37:34.476]                       inherits = FALSE)
[17:37:34.476]                     NULL
[17:37:34.476]                   }
[17:37:34.476]                   options(future.plan = NULL)
[17:37:34.476]                   if (is.na(NA_character_)) 
[17:37:34.476]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.476]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.476]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.476]                     .init = FALSE)
[17:37:34.476]                 }
[17:37:34.476]             }
[17:37:34.476]         }
[17:37:34.476]     })
[17:37:34.476]     if (TRUE) {
[17:37:34.476]         base::sink(type = "output", split = FALSE)
[17:37:34.476]         if (TRUE) {
[17:37:34.476]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.476]         }
[17:37:34.476]         else {
[17:37:34.476]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.476]         }
[17:37:34.476]         base::close(...future.stdout)
[17:37:34.476]         ...future.stdout <- NULL
[17:37:34.476]     }
[17:37:34.476]     ...future.result$conditions <- ...future.conditions
[17:37:34.476]     ...future.result$finished <- base::Sys.time()
[17:37:34.476]     ...future.result
[17:37:34.476] }
[17:37:34.478] assign_globals() ...
[17:37:34.478] List of 5
[17:37:34.478]  $ ...future.FUN            :function (x, y)  
[17:37:34.478]  $ MoreArgs                 :List of 1
[17:37:34.478]   ..$ y: int [1:2] 3 4
[17:37:34.478]  $ ...future.elements_ii    :List of 1
[17:37:34.478]   ..$ x:List of 2
[17:37:34.478]   .. ..$ : int 1
[17:37:34.478]   .. ..$ : int 2
[17:37:34.478]  $ ...future.seeds_ii       :List of 2
[17:37:34.478]   ..$ : int [1:7] 10407 1113385059 714016398 -1199412940 1218353611 1224592553 2044580672
[17:37:34.478]   ..$ : int [1:7] 10407 987350888 -1692308441 -1343773698 281160706 -1446360102 -958547766
[17:37:34.478]  $ ...future.globals.maxSize: NULL
[17:37:34.478]  - attr(*, "where")=List of 5
[17:37:34.478]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.478]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.478]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.478]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.478]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.478]  - attr(*, "resolved")= logi FALSE
[17:37:34.478]  - attr(*, "total_size")= num 2032
[17:37:34.478]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.478]  - attr(*, "already-done")= logi TRUE
[17:37:34.486] - reassign environment for ‘...future.FUN’
[17:37:34.486] - copied ‘...future.FUN’ to environment
[17:37:34.486] - copied ‘MoreArgs’ to environment
[17:37:34.486] - copied ‘...future.elements_ii’ to environment
[17:37:34.486] - copied ‘...future.seeds_ii’ to environment
[17:37:34.486] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.486] assign_globals() ... done
[17:37:34.486] plan(): Setting new future strategy stack:
[17:37:34.486] List of future strategies:
[17:37:34.486] 1. sequential:
[17:37:34.486]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.486]    - tweaked: FALSE
[17:37:34.486]    - call: NULL
[17:37:34.487] plan(): nbrOfWorkers() = 1
[17:37:34.488] plan(): Setting new future strategy stack:
[17:37:34.488] List of future strategies:
[17:37:34.488] 1. sequential:
[17:37:34.488]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.488]    - tweaked: FALSE
[17:37:34.488]    - call: plan(strategy)
[17:37:34.488] plan(): nbrOfWorkers() = 1
[17:37:34.488] SequentialFuture started (and completed)
[17:37:34.488] - Launch lazy future ... done
[17:37:34.489] run() for ‘SequentialFuture’ ... done
[17:37:34.489] Created future:
[17:37:34.489] SequentialFuture:
[17:37:34.489] Label: ‘future_mapply-1’
[17:37:34.489] Expression:
[17:37:34.489] {
[17:37:34.489]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.489]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.489]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.489]         on.exit(options(oopts), add = TRUE)
[17:37:34.489]     }
[17:37:34.489]     {
[17:37:34.489]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:37:34.489]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:37:34.489]                 inherits = FALSE)
[17:37:34.489]             ...future.FUN(...)
[17:37:34.489]         }
[17:37:34.489]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:37:34.489]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:37:34.489]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.489]         do.call(mapply, args = args)
[17:37:34.489]     }
[17:37:34.489] }
[17:37:34.489] Lazy evaluation: FALSE
[17:37:34.489] Asynchronous evaluation: FALSE
[17:37:34.489] Local evaluation: TRUE
[17:37:34.489] Environment: R_GlobalEnv
[17:37:34.489] Capture standard output: TRUE
[17:37:34.489] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.489] Globals: 5 objects totaling 1.98 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.489] Packages: <none>
[17:37:34.489] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:37:34.489] Resolved: TRUE
[17:37:34.489] Value: 112 bytes of class ‘list’
[17:37:34.489] Early signaling: FALSE
[17:37:34.489] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.489] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.490] Chunk #1 of 1 ... DONE
[17:37:34.490] Launching 1 futures (chunks) ... DONE
[17:37:34.490] Resolving 1 futures (chunks) ...
[17:37:34.490] resolve() on list ...
[17:37:34.490]  recursive: 0
[17:37:34.490]  length: 1
[17:37:34.490] 
[17:37:34.490] resolved() for ‘SequentialFuture’ ...
[17:37:34.490] - state: ‘finished’
[17:37:34.491] - run: TRUE
[17:37:34.491] - result: ‘FutureResult’
[17:37:34.491] resolved() for ‘SequentialFuture’ ... done
[17:37:34.491] Future #1
[17:37:34.491] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:34.491] - nx: 1
[17:37:34.491] - relay: TRUE
[17:37:34.491] - stdout: TRUE
[17:37:34.491] - signal: TRUE
[17:37:34.491] - resignal: FALSE
[17:37:34.492] - force: TRUE
[17:37:34.492] - relayed: [n=1] FALSE
[17:37:34.492] - queued futures: [n=1] FALSE
[17:37:34.492]  - until=1
[17:37:34.492]  - relaying element #1
[17:37:34.492] - relayed: [n=1] TRUE
[17:37:34.492] - queued futures: [n=1] TRUE
[17:37:34.492] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:34.492]  length: 0 (resolved future 1)
[17:37:34.492] Relaying remaining futures
[17:37:34.493] signalConditionsASAP(NULL, pos=0) ...
[17:37:34.493] - nx: 1
[17:37:34.493] - relay: TRUE
[17:37:34.493] - stdout: TRUE
[17:37:34.493] - signal: TRUE
[17:37:34.493] - resignal: FALSE
[17:37:34.493] - force: TRUE
[17:37:34.493] - relayed: [n=1] TRUE
[17:37:34.493] - queued futures: [n=1] TRUE
 - flush all
[17:37:34.493] - relayed: [n=1] TRUE
[17:37:34.493] - queued futures: [n=1] TRUE
[17:37:34.494] signalConditionsASAP(NULL, pos=0) ... done
[17:37:34.494] resolve() on list ... DONE
[17:37:34.494]  - Number of value chunks collected: 1
[17:37:34.494] Resolving 1 futures (chunks) ... DONE
[17:37:34.494] Reducing values from 1 chunks ...
[17:37:34.494]  - Number of values collected after concatenation: 2
[17:37:34.494]  - Number of values expected: 2
[17:37:34.494] Reducing values from 1 chunks ... DONE
[17:37:34.494] future_mapply() ... DONE
[17:37:34.494] future_mapply() ...
[17:37:34.495] Number of chunks: 1
[17:37:34.495] getGlobalsAndPackagesXApply() ...
[17:37:34.495]  - future.globals: TRUE
[17:37:34.495] getGlobalsAndPackages() ...
[17:37:34.495] Searching for globals...
[17:37:34.496] - globals found: [1] ‘FUN’
[17:37:34.496] Searching for globals ... DONE
[17:37:34.496] Resolving globals: FALSE
[17:37:34.497] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:37:34.497] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:37:34.497] - globals: [1] ‘FUN’
[17:37:34.497] 
[17:37:34.497] getGlobalsAndPackages() ... DONE
[17:37:34.497]  - globals found/used: [n=1] ‘FUN’
[17:37:34.497]  - needed namespaces: [n=0] 
[17:37:34.498] Finding globals ... DONE
[17:37:34.498] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:34.498] List of 2
[17:37:34.498]  $ ...future.FUN:function (x, y)  
[17:37:34.498]  $ MoreArgs     :List of 1
[17:37:34.498]   ..$ y: int [1:2] 3 4
[17:37:34.498]  - attr(*, "where")=List of 2
[17:37:34.498]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:34.498]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:34.498]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.498]  - attr(*, "resolved")= logi FALSE
[17:37:34.498]  - attr(*, "total_size")= num NA
[17:37:34.501] Packages to be attached in all futures: [n=0] 
[17:37:34.501] getGlobalsAndPackagesXApply() ... DONE
[17:37:34.501] Number of futures (= number of chunks): 1
[17:37:34.501] Launching 1 futures (chunks) ...
[17:37:34.501] Chunk #1 of 1 ...
[17:37:34.501]  - Finding globals in '...' for chunk #1 ...
[17:37:34.501] getGlobalsAndPackages() ...
[17:37:34.502] Searching for globals...
[17:37:34.502] 
[17:37:34.502] Searching for globals ... DONE
[17:37:34.502] - globals: [0] <none>
[17:37:34.502] getGlobalsAndPackages() ... DONE
[17:37:34.502]    + additional globals found: [n=0] 
[17:37:34.502]    + additional namespaces needed: [n=0] 
[17:37:34.502]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:34.502]  - seeds: <none>
[17:37:34.504]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.505] getGlobalsAndPackages() ...
[17:37:34.505] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.505] Resolving globals: FALSE
[17:37:34.505] The total size of the 5 globals is 1.83 KiB (1872 bytes)
[17:37:34.506] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:37:34.506] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.506] 
[17:37:34.506] getGlobalsAndPackages() ... DONE
[17:37:34.507] run() for ‘Future’ ...
[17:37:34.507] - state: ‘created’
[17:37:34.507] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.507] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.507] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.508]   - Field: ‘label’
[17:37:34.508]   - Field: ‘local’
[17:37:34.508]   - Field: ‘owner’
[17:37:34.508]   - Field: ‘envir’
[17:37:34.508]   - Field: ‘packages’
[17:37:34.508]   - Field: ‘gc’
[17:37:34.508]   - Field: ‘conditions’
[17:37:34.508]   - Field: ‘expr’
[17:37:34.508]   - Field: ‘uuid’
[17:37:34.508]   - Field: ‘seed’
[17:37:34.509]   - Field: ‘version’
[17:37:34.509]   - Field: ‘result’
[17:37:34.509]   - Field: ‘asynchronous’
[17:37:34.509]   - Field: ‘calls’
[17:37:34.509]   - Field: ‘globals’
[17:37:34.509]   - Field: ‘stdout’
[17:37:34.509]   - Field: ‘earlySignal’
[17:37:34.509]   - Field: ‘lazy’
[17:37:34.509]   - Field: ‘state’
[17:37:34.509] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.510] - Launch lazy future ...
[17:37:34.510] Packages needed by the future expression (n = 0): <none>
[17:37:34.510] Packages needed by future strategies (n = 0): <none>
[17:37:34.510] {
[17:37:34.510]     {
[17:37:34.510]         {
[17:37:34.510]             ...future.startTime <- base::Sys.time()
[17:37:34.510]             {
[17:37:34.510]                 {
[17:37:34.510]                   {
[17:37:34.510]                     base::local({
[17:37:34.510]                       has_future <- base::requireNamespace("future", 
[17:37:34.510]                         quietly = TRUE)
[17:37:34.510]                       if (has_future) {
[17:37:34.510]                         ns <- base::getNamespace("future")
[17:37:34.510]                         version <- ns[[".package"]][["version"]]
[17:37:34.510]                         if (is.null(version)) 
[17:37:34.510]                           version <- utils::packageVersion("future")
[17:37:34.510]                       }
[17:37:34.510]                       else {
[17:37:34.510]                         version <- NULL
[17:37:34.510]                       }
[17:37:34.510]                       if (!has_future || version < "1.8.0") {
[17:37:34.510]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.510]                           "", base::R.version$version.string), 
[17:37:34.510]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:34.510]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.510]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.510]                             "release", "version")], collapse = " "), 
[17:37:34.510]                           hostname = base::Sys.info()[["nodename"]])
[17:37:34.510]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.510]                           info)
[17:37:34.510]                         info <- base::paste(info, collapse = "; ")
[17:37:34.510]                         if (!has_future) {
[17:37:34.510]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.510]                             info)
[17:37:34.510]                         }
[17:37:34.510]                         else {
[17:37:34.510]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.510]                             info, version)
[17:37:34.510]                         }
[17:37:34.510]                         base::stop(msg)
[17:37:34.510]                       }
[17:37:34.510]                     })
[17:37:34.510]                   }
[17:37:34.510]                   ...future.strategy.old <- future::plan("list")
[17:37:34.510]                   options(future.plan = NULL)
[17:37:34.510]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.510]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.510]                 }
[17:37:34.510]                 ...future.workdir <- getwd()
[17:37:34.510]             }
[17:37:34.510]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.510]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.510]         }
[17:37:34.510]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.510]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:34.510]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.510]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.510]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.510]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.510]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.510]             base::names(...future.oldOptions))
[17:37:34.510]     }
[17:37:34.510]     if (FALSE) {
[17:37:34.510]     }
[17:37:34.510]     else {
[17:37:34.510]         if (TRUE) {
[17:37:34.510]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.510]                 open = "w")
[17:37:34.510]         }
[17:37:34.510]         else {
[17:37:34.510]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.510]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.510]         }
[17:37:34.510]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.510]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.510]             base::sink(type = "output", split = FALSE)
[17:37:34.510]             base::close(...future.stdout)
[17:37:34.510]         }, add = TRUE)
[17:37:34.510]     }
[17:37:34.510]     ...future.frame <- base::sys.nframe()
[17:37:34.510]     ...future.conditions <- base::list()
[17:37:34.510]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.510]     if (FALSE) {
[17:37:34.510]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.510]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.510]     }
[17:37:34.510]     ...future.result <- base::tryCatch({
[17:37:34.510]         base::withCallingHandlers({
[17:37:34.510]             ...future.value <- base::withVisible(base::local({
[17:37:34.510]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.510]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.510]                   ...future.globals.maxSize)) {
[17:37:34.510]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.510]                   on.exit(options(oopts), add = TRUE)
[17:37:34.510]                 }
[17:37:34.510]                 {
[17:37:34.510]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.510]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.510]                     USE.NAMES = FALSE)
[17:37:34.510]                   do.call(mapply, args = args)
[17:37:34.510]                 }
[17:37:34.510]             }))
[17:37:34.510]             future::FutureResult(value = ...future.value$value, 
[17:37:34.510]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.510]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.510]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.510]                     ...future.globalenv.names))
[17:37:34.510]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.510]         }, condition = base::local({
[17:37:34.510]             c <- base::c
[17:37:34.510]             inherits <- base::inherits
[17:37:34.510]             invokeRestart <- base::invokeRestart
[17:37:34.510]             length <- base::length
[17:37:34.510]             list <- base::list
[17:37:34.510]             seq.int <- base::seq.int
[17:37:34.510]             signalCondition <- base::signalCondition
[17:37:34.510]             sys.calls <- base::sys.calls
[17:37:34.510]             `[[` <- base::`[[`
[17:37:34.510]             `+` <- base::`+`
[17:37:34.510]             `<<-` <- base::`<<-`
[17:37:34.510]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.510]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.510]                   3L)]
[17:37:34.510]             }
[17:37:34.510]             function(cond) {
[17:37:34.510]                 is_error <- inherits(cond, "error")
[17:37:34.510]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.510]                   NULL)
[17:37:34.510]                 if (is_error) {
[17:37:34.510]                   sessionInformation <- function() {
[17:37:34.510]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.510]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.510]                       search = base::search(), system = base::Sys.info())
[17:37:34.510]                   }
[17:37:34.510]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.510]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.510]                     cond$call), session = sessionInformation(), 
[17:37:34.510]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.510]                   signalCondition(cond)
[17:37:34.510]                 }
[17:37:34.510]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.510]                 "immediateCondition"))) {
[17:37:34.510]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.510]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.510]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.510]                   if (TRUE && !signal) {
[17:37:34.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.510]                     {
[17:37:34.510]                       inherits <- base::inherits
[17:37:34.510]                       invokeRestart <- base::invokeRestart
[17:37:34.510]                       is.null <- base::is.null
[17:37:34.510]                       muffled <- FALSE
[17:37:34.510]                       if (inherits(cond, "message")) {
[17:37:34.510]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.510]                         if (muffled) 
[17:37:34.510]                           invokeRestart("muffleMessage")
[17:37:34.510]                       }
[17:37:34.510]                       else if (inherits(cond, "warning")) {
[17:37:34.510]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.510]                         if (muffled) 
[17:37:34.510]                           invokeRestart("muffleWarning")
[17:37:34.510]                       }
[17:37:34.510]                       else if (inherits(cond, "condition")) {
[17:37:34.510]                         if (!is.null(pattern)) {
[17:37:34.510]                           computeRestarts <- base::computeRestarts
[17:37:34.510]                           grepl <- base::grepl
[17:37:34.510]                           restarts <- computeRestarts(cond)
[17:37:34.510]                           for (restart in restarts) {
[17:37:34.510]                             name <- restart$name
[17:37:34.510]                             if (is.null(name)) 
[17:37:34.510]                               next
[17:37:34.510]                             if (!grepl(pattern, name)) 
[17:37:34.510]                               next
[17:37:34.510]                             invokeRestart(restart)
[17:37:34.510]                             muffled <- TRUE
[17:37:34.510]                             break
[17:37:34.510]                           }
[17:37:34.510]                         }
[17:37:34.510]                       }
[17:37:34.510]                       invisible(muffled)
[17:37:34.510]                     }
[17:37:34.510]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.510]                   }
[17:37:34.510]                 }
[17:37:34.510]                 else {
[17:37:34.510]                   if (TRUE) {
[17:37:34.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.510]                     {
[17:37:34.510]                       inherits <- base::inherits
[17:37:34.510]                       invokeRestart <- base::invokeRestart
[17:37:34.510]                       is.null <- base::is.null
[17:37:34.510]                       muffled <- FALSE
[17:37:34.510]                       if (inherits(cond, "message")) {
[17:37:34.510]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.510]                         if (muffled) 
[17:37:34.510]                           invokeRestart("muffleMessage")
[17:37:34.510]                       }
[17:37:34.510]                       else if (inherits(cond, "warning")) {
[17:37:34.510]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.510]                         if (muffled) 
[17:37:34.510]                           invokeRestart("muffleWarning")
[17:37:34.510]                       }
[17:37:34.510]                       else if (inherits(cond, "condition")) {
[17:37:34.510]                         if (!is.null(pattern)) {
[17:37:34.510]                           computeRestarts <- base::computeRestarts
[17:37:34.510]                           grepl <- base::grepl
[17:37:34.510]                           restarts <- computeRestarts(cond)
[17:37:34.510]                           for (restart in restarts) {
[17:37:34.510]                             name <- restart$name
[17:37:34.510]                             if (is.null(name)) 
[17:37:34.510]                               next
[17:37:34.510]                             if (!grepl(pattern, name)) 
[17:37:34.510]                               next
[17:37:34.510]                             invokeRestart(restart)
[17:37:34.510]                             muffled <- TRUE
[17:37:34.510]                             break
[17:37:34.510]                           }
[17:37:34.510]                         }
[17:37:34.510]                       }
[17:37:34.510]                       invisible(muffled)
[17:37:34.510]                     }
[17:37:34.510]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.510]                   }
[17:37:34.510]                 }
[17:37:34.510]             }
[17:37:34.510]         }))
[17:37:34.510]     }, error = function(ex) {
[17:37:34.510]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.510]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.510]                 ...future.rng), started = ...future.startTime, 
[17:37:34.510]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.510]             version = "1.8"), class = "FutureResult")
[17:37:34.510]     }, finally = {
[17:37:34.510]         if (!identical(...future.workdir, getwd())) 
[17:37:34.510]             setwd(...future.workdir)
[17:37:34.510]         {
[17:37:34.510]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.510]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.510]             }
[17:37:34.510]             base::options(...future.oldOptions)
[17:37:34.510]             if (.Platform$OS.type == "windows") {
[17:37:34.510]                 old_names <- names(...future.oldEnvVars)
[17:37:34.510]                 envs <- base::Sys.getenv()
[17:37:34.510]                 names <- names(envs)
[17:37:34.510]                 common <- intersect(names, old_names)
[17:37:34.510]                 added <- setdiff(names, old_names)
[17:37:34.510]                 removed <- setdiff(old_names, names)
[17:37:34.510]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.510]                   envs[common]]
[17:37:34.510]                 NAMES <- toupper(changed)
[17:37:34.510]                 args <- list()
[17:37:34.510]                 for (kk in seq_along(NAMES)) {
[17:37:34.510]                   name <- changed[[kk]]
[17:37:34.510]                   NAME <- NAMES[[kk]]
[17:37:34.510]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.510]                     next
[17:37:34.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.510]                 }
[17:37:34.510]                 NAMES <- toupper(added)
[17:37:34.510]                 for (kk in seq_along(NAMES)) {
[17:37:34.510]                   name <- added[[kk]]
[17:37:34.510]                   NAME <- NAMES[[kk]]
[17:37:34.510]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.510]                     next
[17:37:34.510]                   args[[name]] <- ""
[17:37:34.510]                 }
[17:37:34.510]                 NAMES <- toupper(removed)
[17:37:34.510]                 for (kk in seq_along(NAMES)) {
[17:37:34.510]                   name <- removed[[kk]]
[17:37:34.510]                   NAME <- NAMES[[kk]]
[17:37:34.510]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.510]                     next
[17:37:34.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.510]                 }
[17:37:34.510]                 if (length(args) > 0) 
[17:37:34.510]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.510]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.510]             }
[17:37:34.510]             else {
[17:37:34.510]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.510]             }
[17:37:34.510]             {
[17:37:34.510]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.510]                   0L) {
[17:37:34.510]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.510]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.510]                   base::options(opts)
[17:37:34.510]                 }
[17:37:34.510]                 {
[17:37:34.510]                   {
[17:37:34.510]                     base::assign(".Random.seed", c(10407L, -156231338L, 
[17:37:34.510]                     1207257725L, 1615515356L, -1786728155L, 917879648L, 
[17:37:34.510]                     -1988804446L), envir = base::globalenv(), 
[17:37:34.510]                       inherits = FALSE)
[17:37:34.510]                     NULL
[17:37:34.510]                   }
[17:37:34.510]                   options(future.plan = NULL)
[17:37:34.510]                   if (is.na(NA_character_)) 
[17:37:34.510]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.510]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.510]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.510]                     .init = FALSE)
[17:37:34.510]                 }
[17:37:34.510]             }
[17:37:34.510]         }
[17:37:34.510]     })
[17:37:34.510]     if (TRUE) {
[17:37:34.510]         base::sink(type = "output", split = FALSE)
[17:37:34.510]         if (TRUE) {
[17:37:34.510]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.510]         }
[17:37:34.510]         else {
[17:37:34.510]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.510]         }
[17:37:34.510]         base::close(...future.stdout)
[17:37:34.510]         ...future.stdout <- NULL
[17:37:34.510]     }
[17:37:34.510]     ...future.result$conditions <- ...future.conditions
[17:37:34.510]     ...future.result$finished <- base::Sys.time()
[17:37:34.510]     ...future.result
[17:37:34.510] }
[17:37:34.512] assign_globals() ...
[17:37:34.512] List of 5
[17:37:34.512]  $ ...future.FUN            :function (x, y)  
[17:37:34.512]  $ MoreArgs                 :List of 1
[17:37:34.512]   ..$ y: int [1:2] 3 4
[17:37:34.512]  $ ...future.elements_ii    :List of 1
[17:37:34.512]   ..$ x:List of 2
[17:37:34.512]   .. ..$ : int 1
[17:37:34.512]   .. ..$ : int 2
[17:37:34.512]  $ ...future.seeds_ii       : NULL
[17:37:34.512]  $ ...future.globals.maxSize: NULL
[17:37:34.512]  - attr(*, "where")=List of 5
[17:37:34.512]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.512]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.512]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.512]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.512]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.512]  - attr(*, "resolved")= logi FALSE
[17:37:34.512]  - attr(*, "total_size")= num 1872
[17:37:34.512]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.512]  - attr(*, "already-done")= logi TRUE
[17:37:34.517] - reassign environment for ‘...future.FUN’
[17:37:34.518] - copied ‘...future.FUN’ to environment
[17:37:34.518] - copied ‘MoreArgs’ to environment
[17:37:34.518] - copied ‘...future.elements_ii’ to environment
[17:37:34.518] - copied ‘...future.seeds_ii’ to environment
[17:37:34.518] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.518] assign_globals() ... done
[17:37:34.518] plan(): Setting new future strategy stack:
[17:37:34.518] List of future strategies:
[17:37:34.518] 1. sequential:
[17:37:34.518]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.518]    - tweaked: FALSE
[17:37:34.518]    - call: NULL
[17:37:34.519] plan(): nbrOfWorkers() = 1
[17:37:34.520] plan(): Setting new future strategy stack:
[17:37:34.520] List of future strategies:
[17:37:34.520] 1. sequential:
[17:37:34.520]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.520]    - tweaked: FALSE
[17:37:34.520]    - call: plan(strategy)
[17:37:34.520] plan(): nbrOfWorkers() = 1
[17:37:34.520] SequentialFuture started (and completed)
[17:37:34.521] - Launch lazy future ... done
[17:37:34.521] run() for ‘SequentialFuture’ ... done
[17:37:34.521] Created future:
[17:37:34.521] SequentialFuture:
[17:37:34.521] Label: ‘future_.mapply-1’
[17:37:34.521] Expression:
[17:37:34.521] {
[17:37:34.521]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.521]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.521]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.521]         on.exit(options(oopts), add = TRUE)
[17:37:34.521]     }
[17:37:34.521]     {
[17:37:34.521]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.521]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.521]         do.call(mapply, args = args)
[17:37:34.521]     }
[17:37:34.521] }
[17:37:34.521] Lazy evaluation: FALSE
[17:37:34.521] Asynchronous evaluation: FALSE
[17:37:34.521] Local evaluation: TRUE
[17:37:34.521] Environment: R_GlobalEnv
[17:37:34.521] Capture standard output: TRUE
[17:37:34.521] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.521] Globals: 5 objects totaling 1.83 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.521] Packages: <none>
[17:37:34.521] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.521] Resolved: TRUE
[17:37:34.521] Value: 112 bytes of class ‘list’
[17:37:34.521] Early signaling: FALSE
[17:37:34.521] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.521] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.522] Chunk #1 of 1 ... DONE
[17:37:34.522] Launching 1 futures (chunks) ... DONE
[17:37:34.522] Resolving 1 futures (chunks) ...
[17:37:34.522] resolve() on list ...
[17:37:34.522]  recursive: 0
[17:37:34.522]  length: 1
[17:37:34.522] 
[17:37:34.523] resolved() for ‘SequentialFuture’ ...
[17:37:34.523] - state: ‘finished’
[17:37:34.523] - run: TRUE
[17:37:34.523] - result: ‘FutureResult’
[17:37:34.523] resolved() for ‘SequentialFuture’ ... done
[17:37:34.523] Future #1
[17:37:34.523] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:34.523] - nx: 1
[17:37:34.523] - relay: TRUE
[17:37:34.523] - stdout: TRUE
[17:37:34.524] - signal: TRUE
[17:37:34.524] - resignal: FALSE
[17:37:34.524] - force: TRUE
[17:37:34.524] - relayed: [n=1] FALSE
[17:37:34.524] - queued futures: [n=1] FALSE
[17:37:34.524]  - until=1
[17:37:34.524]  - relaying element #1
[17:37:34.524] - relayed: [n=1] TRUE
[17:37:34.524] - queued futures: [n=1] TRUE
[17:37:34.524] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:34.525]  length: 0 (resolved future 1)
[17:37:34.525] Relaying remaining futures
[17:37:34.525] signalConditionsASAP(NULL, pos=0) ...
[17:37:34.525] - nx: 1
[17:37:34.525] - relay: TRUE
[17:37:34.525] - stdout: TRUE
[17:37:34.525] - signal: TRUE
[17:37:34.525] - resignal: FALSE
[17:37:34.525] - force: TRUE
[17:37:34.525] - relayed: [n=1] TRUE
[17:37:34.525] - queued futures: [n=1] TRUE
 - flush all
[17:37:34.526] - relayed: [n=1] TRUE
[17:37:34.526] - queued futures: [n=1] TRUE
[17:37:34.526] signalConditionsASAP(NULL, pos=0) ... done
[17:37:34.526] resolve() on list ... DONE
[17:37:34.526]  - Number of value chunks collected: 1
[17:37:34.526] Resolving 1 futures (chunks) ... DONE
[17:37:34.526] Reducing values from 1 chunks ...
[17:37:34.526]  - Number of values collected after concatenation: 2
[17:37:34.526]  - Number of values expected: 2
[17:37:34.526] Reducing values from 1 chunks ... DONE
[17:37:34.526] future_mapply() ... DONE
- Recycle arguments to same length ...
[17:37:34.527] future_mapply() ...
[17:37:34.527] Number of chunks: 1
[17:37:34.527] getGlobalsAndPackagesXApply() ...
[17:37:34.527]  - future.globals: TRUE
[17:37:34.527] getGlobalsAndPackages() ...
[17:37:34.527] Searching for globals...
[17:37:34.528] - globals found: [1] ‘FUN’
[17:37:34.528] Searching for globals ... DONE
[17:37:34.528] Resolving globals: FALSE
[17:37:34.528] The total size of the 1 globals is 56 bytes (56 bytes)
[17:37:34.529] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:37:34.529] - globals: [1] ‘FUN’
[17:37:34.529] 
[17:37:34.531] getGlobalsAndPackages() ... DONE
[17:37:34.531]  - globals found/used: [n=1] ‘FUN’
[17:37:34.531]  - needed namespaces: [n=0] 
[17:37:34.531] Finding globals ... DONE
[17:37:34.531] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:34.531] List of 2
[17:37:34.531]  $ ...future.FUN:function (x, ...)  
[17:37:34.531]  $ MoreArgs     : NULL
[17:37:34.531]  - attr(*, "where")=List of 2
[17:37:34.531]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:34.531]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:34.531]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.531]  - attr(*, "resolved")= logi FALSE
[17:37:34.531]  - attr(*, "total_size")= num NA
[17:37:34.534] Packages to be attached in all futures: [n=0] 
[17:37:34.534] getGlobalsAndPackagesXApply() ... DONE
[17:37:34.534] Number of futures (= number of chunks): 1
[17:37:34.534] Launching 1 futures (chunks) ...
[17:37:34.535] Chunk #1 of 1 ...
[17:37:34.535]  - Finding globals in '...' for chunk #1 ...
[17:37:34.535] getGlobalsAndPackages() ...
[17:37:34.535] Searching for globals...
[17:37:34.535] 
[17:37:34.535] Searching for globals ... DONE
[17:37:34.535] - globals: [0] <none>
[17:37:34.535] getGlobalsAndPackages() ... DONE
[17:37:34.536]    + additional globals found: [n=0] 
[17:37:34.536]    + additional namespaces needed: [n=0] 
[17:37:34.536]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:34.536]  - seeds: <none>
[17:37:34.536]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.536] getGlobalsAndPackages() ...
[17:37:34.536] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.536] Resolving globals: FALSE
[17:37:34.537] The total size of the 5 globals is 504 bytes (504 bytes)
[17:37:34.537] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:34.537] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.537] 
[17:37:34.537] getGlobalsAndPackages() ... DONE
[17:37:34.538] run() for ‘Future’ ...
[17:37:34.538] - state: ‘created’
[17:37:34.538] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.538] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.538] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.538]   - Field: ‘label’
[17:37:34.539]   - Field: ‘local’
[17:37:34.539]   - Field: ‘owner’
[17:37:34.539]   - Field: ‘envir’
[17:37:34.539]   - Field: ‘packages’
[17:37:34.539]   - Field: ‘gc’
[17:37:34.539]   - Field: ‘conditions’
[17:37:34.539]   - Field: ‘expr’
[17:37:34.539]   - Field: ‘uuid’
[17:37:34.539]   - Field: ‘seed’
[17:37:34.539]   - Field: ‘version’
[17:37:34.540]   - Field: ‘result’
[17:37:34.540]   - Field: ‘asynchronous’
[17:37:34.540]   - Field: ‘calls’
[17:37:34.540]   - Field: ‘globals’
[17:37:34.540]   - Field: ‘stdout’
[17:37:34.540]   - Field: ‘earlySignal’
[17:37:34.540]   - Field: ‘lazy’
[17:37:34.540]   - Field: ‘state’
[17:37:34.540] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.540] - Launch lazy future ...
[17:37:34.541] Packages needed by the future expression (n = 0): <none>
[17:37:34.541] Packages needed by future strategies (n = 0): <none>
[17:37:34.541] {
[17:37:34.541]     {
[17:37:34.541]         {
[17:37:34.541]             ...future.startTime <- base::Sys.time()
[17:37:34.541]             {
[17:37:34.541]                 {
[17:37:34.541]                   {
[17:37:34.541]                     base::local({
[17:37:34.541]                       has_future <- base::requireNamespace("future", 
[17:37:34.541]                         quietly = TRUE)
[17:37:34.541]                       if (has_future) {
[17:37:34.541]                         ns <- base::getNamespace("future")
[17:37:34.541]                         version <- ns[[".package"]][["version"]]
[17:37:34.541]                         if (is.null(version)) 
[17:37:34.541]                           version <- utils::packageVersion("future")
[17:37:34.541]                       }
[17:37:34.541]                       else {
[17:37:34.541]                         version <- NULL
[17:37:34.541]                       }
[17:37:34.541]                       if (!has_future || version < "1.8.0") {
[17:37:34.541]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.541]                           "", base::R.version$version.string), 
[17:37:34.541]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:34.541]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.541]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.541]                             "release", "version")], collapse = " "), 
[17:37:34.541]                           hostname = base::Sys.info()[["nodename"]])
[17:37:34.541]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.541]                           info)
[17:37:34.541]                         info <- base::paste(info, collapse = "; ")
[17:37:34.541]                         if (!has_future) {
[17:37:34.541]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.541]                             info)
[17:37:34.541]                         }
[17:37:34.541]                         else {
[17:37:34.541]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.541]                             info, version)
[17:37:34.541]                         }
[17:37:34.541]                         base::stop(msg)
[17:37:34.541]                       }
[17:37:34.541]                     })
[17:37:34.541]                   }
[17:37:34.541]                   ...future.strategy.old <- future::plan("list")
[17:37:34.541]                   options(future.plan = NULL)
[17:37:34.541]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.541]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.541]                 }
[17:37:34.541]                 ...future.workdir <- getwd()
[17:37:34.541]             }
[17:37:34.541]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.541]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.541]         }
[17:37:34.541]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.541]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:34.541]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.541]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.541]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.541]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.541]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.541]             base::names(...future.oldOptions))
[17:37:34.541]     }
[17:37:34.541]     if (FALSE) {
[17:37:34.541]     }
[17:37:34.541]     else {
[17:37:34.541]         if (TRUE) {
[17:37:34.541]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.541]                 open = "w")
[17:37:34.541]         }
[17:37:34.541]         else {
[17:37:34.541]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.541]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.541]         }
[17:37:34.541]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.541]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.541]             base::sink(type = "output", split = FALSE)
[17:37:34.541]             base::close(...future.stdout)
[17:37:34.541]         }, add = TRUE)
[17:37:34.541]     }
[17:37:34.541]     ...future.frame <- base::sys.nframe()
[17:37:34.541]     ...future.conditions <- base::list()
[17:37:34.541]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.541]     if (FALSE) {
[17:37:34.541]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.541]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.541]     }
[17:37:34.541]     ...future.result <- base::tryCatch({
[17:37:34.541]         base::withCallingHandlers({
[17:37:34.541]             ...future.value <- base::withVisible(base::local({
[17:37:34.541]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.541]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.541]                   ...future.globals.maxSize)) {
[17:37:34.541]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.541]                   on.exit(options(oopts), add = TRUE)
[17:37:34.541]                 }
[17:37:34.541]                 {
[17:37:34.541]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.541]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.541]                     USE.NAMES = FALSE)
[17:37:34.541]                   do.call(mapply, args = args)
[17:37:34.541]                 }
[17:37:34.541]             }))
[17:37:34.541]             future::FutureResult(value = ...future.value$value, 
[17:37:34.541]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.541]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.541]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.541]                     ...future.globalenv.names))
[17:37:34.541]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.541]         }, condition = base::local({
[17:37:34.541]             c <- base::c
[17:37:34.541]             inherits <- base::inherits
[17:37:34.541]             invokeRestart <- base::invokeRestart
[17:37:34.541]             length <- base::length
[17:37:34.541]             list <- base::list
[17:37:34.541]             seq.int <- base::seq.int
[17:37:34.541]             signalCondition <- base::signalCondition
[17:37:34.541]             sys.calls <- base::sys.calls
[17:37:34.541]             `[[` <- base::`[[`
[17:37:34.541]             `+` <- base::`+`
[17:37:34.541]             `<<-` <- base::`<<-`
[17:37:34.541]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.541]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.541]                   3L)]
[17:37:34.541]             }
[17:37:34.541]             function(cond) {
[17:37:34.541]                 is_error <- inherits(cond, "error")
[17:37:34.541]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.541]                   NULL)
[17:37:34.541]                 if (is_error) {
[17:37:34.541]                   sessionInformation <- function() {
[17:37:34.541]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.541]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.541]                       search = base::search(), system = base::Sys.info())
[17:37:34.541]                   }
[17:37:34.541]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.541]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.541]                     cond$call), session = sessionInformation(), 
[17:37:34.541]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.541]                   signalCondition(cond)
[17:37:34.541]                 }
[17:37:34.541]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.541]                 "immediateCondition"))) {
[17:37:34.541]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.541]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.541]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.541]                   if (TRUE && !signal) {
[17:37:34.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.541]                     {
[17:37:34.541]                       inherits <- base::inherits
[17:37:34.541]                       invokeRestart <- base::invokeRestart
[17:37:34.541]                       is.null <- base::is.null
[17:37:34.541]                       muffled <- FALSE
[17:37:34.541]                       if (inherits(cond, "message")) {
[17:37:34.541]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.541]                         if (muffled) 
[17:37:34.541]                           invokeRestart("muffleMessage")
[17:37:34.541]                       }
[17:37:34.541]                       else if (inherits(cond, "warning")) {
[17:37:34.541]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.541]                         if (muffled) 
[17:37:34.541]                           invokeRestart("muffleWarning")
[17:37:34.541]                       }
[17:37:34.541]                       else if (inherits(cond, "condition")) {
[17:37:34.541]                         if (!is.null(pattern)) {
[17:37:34.541]                           computeRestarts <- base::computeRestarts
[17:37:34.541]                           grepl <- base::grepl
[17:37:34.541]                           restarts <- computeRestarts(cond)
[17:37:34.541]                           for (restart in restarts) {
[17:37:34.541]                             name <- restart$name
[17:37:34.541]                             if (is.null(name)) 
[17:37:34.541]                               next
[17:37:34.541]                             if (!grepl(pattern, name)) 
[17:37:34.541]                               next
[17:37:34.541]                             invokeRestart(restart)
[17:37:34.541]                             muffled <- TRUE
[17:37:34.541]                             break
[17:37:34.541]                           }
[17:37:34.541]                         }
[17:37:34.541]                       }
[17:37:34.541]                       invisible(muffled)
[17:37:34.541]                     }
[17:37:34.541]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.541]                   }
[17:37:34.541]                 }
[17:37:34.541]                 else {
[17:37:34.541]                   if (TRUE) {
[17:37:34.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.541]                     {
[17:37:34.541]                       inherits <- base::inherits
[17:37:34.541]                       invokeRestart <- base::invokeRestart
[17:37:34.541]                       is.null <- base::is.null
[17:37:34.541]                       muffled <- FALSE
[17:37:34.541]                       if (inherits(cond, "message")) {
[17:37:34.541]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.541]                         if (muffled) 
[17:37:34.541]                           invokeRestart("muffleMessage")
[17:37:34.541]                       }
[17:37:34.541]                       else if (inherits(cond, "warning")) {
[17:37:34.541]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.541]                         if (muffled) 
[17:37:34.541]                           invokeRestart("muffleWarning")
[17:37:34.541]                       }
[17:37:34.541]                       else if (inherits(cond, "condition")) {
[17:37:34.541]                         if (!is.null(pattern)) {
[17:37:34.541]                           computeRestarts <- base::computeRestarts
[17:37:34.541]                           grepl <- base::grepl
[17:37:34.541]                           restarts <- computeRestarts(cond)
[17:37:34.541]                           for (restart in restarts) {
[17:37:34.541]                             name <- restart$name
[17:37:34.541]                             if (is.null(name)) 
[17:37:34.541]                               next
[17:37:34.541]                             if (!grepl(pattern, name)) 
[17:37:34.541]                               next
[17:37:34.541]                             invokeRestart(restart)
[17:37:34.541]                             muffled <- TRUE
[17:37:34.541]                             break
[17:37:34.541]                           }
[17:37:34.541]                         }
[17:37:34.541]                       }
[17:37:34.541]                       invisible(muffled)
[17:37:34.541]                     }
[17:37:34.541]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.541]                   }
[17:37:34.541]                 }
[17:37:34.541]             }
[17:37:34.541]         }))
[17:37:34.541]     }, error = function(ex) {
[17:37:34.541]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.541]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.541]                 ...future.rng), started = ...future.startTime, 
[17:37:34.541]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.541]             version = "1.8"), class = "FutureResult")
[17:37:34.541]     }, finally = {
[17:37:34.541]         if (!identical(...future.workdir, getwd())) 
[17:37:34.541]             setwd(...future.workdir)
[17:37:34.541]         {
[17:37:34.541]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.541]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.541]             }
[17:37:34.541]             base::options(...future.oldOptions)
[17:37:34.541]             if (.Platform$OS.type == "windows") {
[17:37:34.541]                 old_names <- names(...future.oldEnvVars)
[17:37:34.541]                 envs <- base::Sys.getenv()
[17:37:34.541]                 names <- names(envs)
[17:37:34.541]                 common <- intersect(names, old_names)
[17:37:34.541]                 added <- setdiff(names, old_names)
[17:37:34.541]                 removed <- setdiff(old_names, names)
[17:37:34.541]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.541]                   envs[common]]
[17:37:34.541]                 NAMES <- toupper(changed)
[17:37:34.541]                 args <- list()
[17:37:34.541]                 for (kk in seq_along(NAMES)) {
[17:37:34.541]                   name <- changed[[kk]]
[17:37:34.541]                   NAME <- NAMES[[kk]]
[17:37:34.541]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.541]                     next
[17:37:34.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.541]                 }
[17:37:34.541]                 NAMES <- toupper(added)
[17:37:34.541]                 for (kk in seq_along(NAMES)) {
[17:37:34.541]                   name <- added[[kk]]
[17:37:34.541]                   NAME <- NAMES[[kk]]
[17:37:34.541]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.541]                     next
[17:37:34.541]                   args[[name]] <- ""
[17:37:34.541]                 }
[17:37:34.541]                 NAMES <- toupper(removed)
[17:37:34.541]                 for (kk in seq_along(NAMES)) {
[17:37:34.541]                   name <- removed[[kk]]
[17:37:34.541]                   NAME <- NAMES[[kk]]
[17:37:34.541]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.541]                     next
[17:37:34.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.541]                 }
[17:37:34.541]                 if (length(args) > 0) 
[17:37:34.541]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.541]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.541]             }
[17:37:34.541]             else {
[17:37:34.541]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.541]             }
[17:37:34.541]             {
[17:37:34.541]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.541]                   0L) {
[17:37:34.541]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.541]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.541]                   base::options(opts)
[17:37:34.541]                 }
[17:37:34.541]                 {
[17:37:34.541]                   {
[17:37:34.541]                     base::assign(".Random.seed", c(10407L, -156231338L, 
[17:37:34.541]                     1207257725L, 1615515356L, -1786728155L, 917879648L, 
[17:37:34.541]                     -1988804446L), envir = base::globalenv(), 
[17:37:34.541]                       inherits = FALSE)
[17:37:34.541]                     NULL
[17:37:34.541]                   }
[17:37:34.541]                   options(future.plan = NULL)
[17:37:34.541]                   if (is.na(NA_character_)) 
[17:37:34.541]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.541]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.541]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.541]                     .init = FALSE)
[17:37:34.541]                 }
[17:37:34.541]             }
[17:37:34.541]         }
[17:37:34.541]     })
[17:37:34.541]     if (TRUE) {
[17:37:34.541]         base::sink(type = "output", split = FALSE)
[17:37:34.541]         if (TRUE) {
[17:37:34.541]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.541]         }
[17:37:34.541]         else {
[17:37:34.541]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.541]         }
[17:37:34.541]         base::close(...future.stdout)
[17:37:34.541]         ...future.stdout <- NULL
[17:37:34.541]     }
[17:37:34.541]     ...future.result$conditions <- ...future.conditions
[17:37:34.541]     ...future.result$finished <- base::Sys.time()
[17:37:34.541]     ...future.result
[17:37:34.541] }
[17:37:34.543] assign_globals() ...
[17:37:34.543] List of 5
[17:37:34.543]  $ ...future.FUN            :function (x, ...)  
[17:37:34.543]  $ MoreArgs                 : NULL
[17:37:34.543]  $ ...future.elements_ii    :List of 2
[17:37:34.543]   ..$ :List of 4
[17:37:34.543]   .. ..$ : int 1
[17:37:34.543]   .. ..$ : int 2
[17:37:34.543]   .. ..$ : int 3
[17:37:34.543]   .. ..$ : int 4
[17:37:34.543]   ..$ :List of 4
[17:37:34.543]   .. ..$ : int 2
[17:37:34.543]   .. ..$ : int 1
[17:37:34.543]   .. ..$ : int 2
[17:37:34.543]   .. ..$ : int 1
[17:37:34.543]  $ ...future.seeds_ii       : NULL
[17:37:34.543]  $ ...future.globals.maxSize: NULL
[17:37:34.543]  - attr(*, "where")=List of 5
[17:37:34.543]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.543]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.543]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.543]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.543]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.543]  - attr(*, "resolved")= logi FALSE
[17:37:34.543]  - attr(*, "total_size")= num 504
[17:37:34.543]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.543]  - attr(*, "already-done")= logi TRUE
[17:37:34.549] - copied ‘...future.FUN’ to environment
[17:37:34.549] - copied ‘MoreArgs’ to environment
[17:37:34.549] - copied ‘...future.elements_ii’ to environment
[17:37:34.549] - copied ‘...future.seeds_ii’ to environment
[17:37:34.550] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.550] assign_globals() ... done
[17:37:34.550] plan(): Setting new future strategy stack:
[17:37:34.550] List of future strategies:
[17:37:34.550] 1. sequential:
[17:37:34.550]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.550]    - tweaked: FALSE
[17:37:34.550]    - call: NULL
[17:37:34.550] plan(): nbrOfWorkers() = 1
[17:37:34.551] plan(): Setting new future strategy stack:
[17:37:34.551] List of future strategies:
[17:37:34.551] 1. sequential:
[17:37:34.551]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.551]    - tweaked: FALSE
[17:37:34.551]    - call: plan(strategy)
[17:37:34.552] plan(): nbrOfWorkers() = 1
[17:37:34.552] SequentialFuture started (and completed)
[17:37:34.552] - Launch lazy future ... done
[17:37:34.552] run() for ‘SequentialFuture’ ... done
[17:37:34.552] Created future:
[17:37:34.552] SequentialFuture:
[17:37:34.552] Label: ‘future_mapply-1’
[17:37:34.552] Expression:
[17:37:34.552] {
[17:37:34.552]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.552]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.552]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.552]         on.exit(options(oopts), add = TRUE)
[17:37:34.552]     }
[17:37:34.552]     {
[17:37:34.552]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.552]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.552]         do.call(mapply, args = args)
[17:37:34.552]     }
[17:37:34.552] }
[17:37:34.552] Lazy evaluation: FALSE
[17:37:34.552] Asynchronous evaluation: FALSE
[17:37:34.552] Local evaluation: TRUE
[17:37:34.552] Environment: R_GlobalEnv
[17:37:34.552] Capture standard output: TRUE
[17:37:34.552] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.552] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.552] Packages: <none>
[17:37:34.552] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.552] Resolved: TRUE
[17:37:34.552] Value: 224 bytes of class ‘list’
[17:37:34.552] Early signaling: FALSE
[17:37:34.552] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.552] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.555] Chunk #1 of 1 ... DONE
[17:37:34.555] Launching 1 futures (chunks) ... DONE
[17:37:34.555] Resolving 1 futures (chunks) ...
[17:37:34.555] resolve() on list ...
[17:37:34.555]  recursive: 0
[17:37:34.556]  length: 1
[17:37:34.556] 
[17:37:34.556] resolved() for ‘SequentialFuture’ ...
[17:37:34.556] - state: ‘finished’
[17:37:34.556] - run: TRUE
[17:37:34.556] - result: ‘FutureResult’
[17:37:34.556] resolved() for ‘SequentialFuture’ ... done
[17:37:34.556] Future #1
[17:37:34.557] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:34.557] - nx: 1
[17:37:34.557] - relay: TRUE
[17:37:34.557] - stdout: TRUE
[17:37:34.557] - signal: TRUE
[17:37:34.557] - resignal: FALSE
[17:37:34.557] - force: TRUE
[17:37:34.557] - relayed: [n=1] FALSE
[17:37:34.557] - queued futures: [n=1] FALSE
[17:37:34.557]  - until=1
[17:37:34.558]  - relaying element #1
[17:37:34.558] - relayed: [n=1] TRUE
[17:37:34.558] - queued futures: [n=1] TRUE
[17:37:34.558] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:34.558]  length: 0 (resolved future 1)
[17:37:34.558] Relaying remaining futures
[17:37:34.558] signalConditionsASAP(NULL, pos=0) ...
[17:37:34.558] - nx: 1
[17:37:34.558] - relay: TRUE
[17:37:34.558] - stdout: TRUE
[17:37:34.559] - signal: TRUE
[17:37:34.559] - resignal: FALSE
[17:37:34.559] - force: TRUE
[17:37:34.559] - relayed: [n=1] TRUE
[17:37:34.559] - queued futures: [n=1] TRUE
 - flush all
[17:37:34.559] - relayed: [n=1] TRUE
[17:37:34.559] - queued futures: [n=1] TRUE
[17:37:34.559] signalConditionsASAP(NULL, pos=0) ... done
[17:37:34.559] resolve() on list ... DONE
[17:37:34.559]  - Number of value chunks collected: 1
[17:37:34.559] Resolving 1 futures (chunks) ... DONE
[17:37:34.560] Reducing values from 1 chunks ...
[17:37:34.560]  - Number of values collected after concatenation: 4
[17:37:34.560]  - Number of values expected: 4
[17:37:34.560] Reducing values from 1 chunks ... DONE
[17:37:34.560] future_mapply() ... DONE
- Parallel RNG ...
[17:37:34.560] future_mapply() ...
[17:37:34.560] Generating random seeds ...
[17:37:34.560] Generating random seed streams for 4 elements ...
[17:37:34.560] Generating random seed streams for 4 elements ... DONE
[17:37:34.561] Generating random seeds ... DONE
[17:37:34.561] Will set RNG state on exit: 10407, 1615515356, 394111846, -421624749, -1988804446, 182898754, 1488521025
[17:37:34.561] Number of chunks: 1
[17:37:34.561] getGlobalsAndPackagesXApply() ...
[17:37:34.561]  - future.globals: TRUE
[17:37:34.561] getGlobalsAndPackages() ...
[17:37:34.561] Searching for globals...
[17:37:34.562] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[17:37:34.563] Searching for globals ... DONE
[17:37:34.563] Resolving globals: FALSE
[17:37:34.563] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[17:37:34.563] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[17:37:34.564] - globals: [1] ‘FUN’
[17:37:34.564] - packages: [1] ‘stats’
[17:37:34.564] getGlobalsAndPackages() ... DONE
[17:37:34.564]  - globals found/used: [n=1] ‘FUN’
[17:37:34.564]  - needed namespaces: [n=1] ‘stats’
[17:37:34.564] Finding globals ... DONE
[17:37:34.564] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:34.564] List of 2
[17:37:34.564]  $ ...future.FUN:function (n, min = 0, max = 1)  
[17:37:34.564]  $ MoreArgs     :List of 1
[17:37:34.564]   ..$ min: num 1
[17:37:34.564]  - attr(*, "where")=List of 2
[17:37:34.564]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:34.564]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:34.564]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.564]  - attr(*, "resolved")= logi FALSE
[17:37:34.564]  - attr(*, "total_size")= num NA
[17:37:34.567] Packages to be attached in all futures: [n=1] ‘stats’
[17:37:34.567] getGlobalsAndPackagesXApply() ... DONE
[17:37:34.567] Number of futures (= number of chunks): 1
[17:37:34.567] Launching 1 futures (chunks) ...
[17:37:34.568] Chunk #1 of 1 ...
[17:37:34.568]  - Finding globals in '...' for chunk #1 ...
[17:37:34.568] getGlobalsAndPackages() ...
[17:37:34.568] Searching for globals...
[17:37:34.568] 
[17:37:34.568] Searching for globals ... DONE
[17:37:34.568] - globals: [0] <none>
[17:37:34.569] getGlobalsAndPackages() ... DONE
[17:37:34.569]    + additional globals found: [n=0] 
[17:37:34.569]    + additional namespaces needed: [n=0] 
[17:37:34.569]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:34.569]  - seeds: [4] <seeds>
[17:37:34.569]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.569] getGlobalsAndPackages() ...
[17:37:34.569] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.569] Resolving globals: FALSE
[17:37:34.570] The total size of the 5 globals is 2.84 KiB (2912 bytes)
[17:37:34.570] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (448 bytes of class ‘list’) and ‘...future.seeds_ii’ (320 bytes of class ‘list’)
[17:37:34.570] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.571] - packages: [1] ‘stats’
[17:37:34.571] getGlobalsAndPackages() ... DONE
[17:37:34.571] run() for ‘Future’ ...
[17:37:34.571] - state: ‘created’
[17:37:34.571] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.571] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.572] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.572]   - Field: ‘label’
[17:37:34.572]   - Field: ‘local’
[17:37:34.572]   - Field: ‘owner’
[17:37:34.572]   - Field: ‘envir’
[17:37:34.572]   - Field: ‘packages’
[17:37:34.572]   - Field: ‘gc’
[17:37:34.572]   - Field: ‘conditions’
[17:37:34.572]   - Field: ‘expr’
[17:37:34.572]   - Field: ‘uuid’
[17:37:34.573]   - Field: ‘seed’
[17:37:34.573]   - Field: ‘version’
[17:37:34.573]   - Field: ‘result’
[17:37:34.573]   - Field: ‘asynchronous’
[17:37:34.573]   - Field: ‘calls’
[17:37:34.573]   - Field: ‘globals’
[17:37:34.573]   - Field: ‘stdout’
[17:37:34.573]   - Field: ‘earlySignal’
[17:37:34.573]   - Field: ‘lazy’
[17:37:34.573]   - Field: ‘state’
[17:37:34.573] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.574] - Launch lazy future ...
[17:37:34.574] Packages needed by the future expression (n = 1): ‘stats’
[17:37:34.574] Packages needed by future strategies (n = 0): <none>
[17:37:34.574] {
[17:37:34.574]     {
[17:37:34.574]         {
[17:37:34.574]             ...future.startTime <- base::Sys.time()
[17:37:34.574]             {
[17:37:34.574]                 {
[17:37:34.574]                   {
[17:37:34.574]                     {
[17:37:34.574]                       base::local({
[17:37:34.574]                         has_future <- base::requireNamespace("future", 
[17:37:34.574]                           quietly = TRUE)
[17:37:34.574]                         if (has_future) {
[17:37:34.574]                           ns <- base::getNamespace("future")
[17:37:34.574]                           version <- ns[[".package"]][["version"]]
[17:37:34.574]                           if (is.null(version)) 
[17:37:34.574]                             version <- utils::packageVersion("future")
[17:37:34.574]                         }
[17:37:34.574]                         else {
[17:37:34.574]                           version <- NULL
[17:37:34.574]                         }
[17:37:34.574]                         if (!has_future || version < "1.8.0") {
[17:37:34.574]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.574]                             "", base::R.version$version.string), 
[17:37:34.574]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:34.574]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.574]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.574]                               "release", "version")], collapse = " "), 
[17:37:34.574]                             hostname = base::Sys.info()[["nodename"]])
[17:37:34.574]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.574]                             info)
[17:37:34.574]                           info <- base::paste(info, collapse = "; ")
[17:37:34.574]                           if (!has_future) {
[17:37:34.574]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.574]                               info)
[17:37:34.574]                           }
[17:37:34.574]                           else {
[17:37:34.574]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.574]                               info, version)
[17:37:34.574]                           }
[17:37:34.574]                           base::stop(msg)
[17:37:34.574]                         }
[17:37:34.574]                       })
[17:37:34.574]                     }
[17:37:34.574]                     base::local({
[17:37:34.574]                       for (pkg in "stats") {
[17:37:34.574]                         base::loadNamespace(pkg)
[17:37:34.574]                         base::library(pkg, character.only = TRUE)
[17:37:34.574]                       }
[17:37:34.574]                     })
[17:37:34.574]                   }
[17:37:34.574]                   ...future.strategy.old <- future::plan("list")
[17:37:34.574]                   options(future.plan = NULL)
[17:37:34.574]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.574]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.574]                 }
[17:37:34.574]                 ...future.workdir <- getwd()
[17:37:34.574]             }
[17:37:34.574]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.574]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.574]         }
[17:37:34.574]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.574]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:34.574]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.574]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.574]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.574]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.574]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.574]             base::names(...future.oldOptions))
[17:37:34.574]     }
[17:37:34.574]     if (FALSE) {
[17:37:34.574]     }
[17:37:34.574]     else {
[17:37:34.574]         if (TRUE) {
[17:37:34.574]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.574]                 open = "w")
[17:37:34.574]         }
[17:37:34.574]         else {
[17:37:34.574]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.574]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.574]         }
[17:37:34.574]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.574]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.574]             base::sink(type = "output", split = FALSE)
[17:37:34.574]             base::close(...future.stdout)
[17:37:34.574]         }, add = TRUE)
[17:37:34.574]     }
[17:37:34.574]     ...future.frame <- base::sys.nframe()
[17:37:34.574]     ...future.conditions <- base::list()
[17:37:34.574]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.574]     if (FALSE) {
[17:37:34.574]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.574]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.574]     }
[17:37:34.574]     ...future.result <- base::tryCatch({
[17:37:34.574]         base::withCallingHandlers({
[17:37:34.574]             ...future.value <- base::withVisible(base::local({
[17:37:34.574]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.574]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.574]                   ...future.globals.maxSize)) {
[17:37:34.574]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.574]                   on.exit(options(oopts), add = TRUE)
[17:37:34.574]                 }
[17:37:34.574]                 {
[17:37:34.574]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:37:34.574]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[17:37:34.574]                       envir = globalenv(), inherits = FALSE)
[17:37:34.574]                     ...future.FUN(...)
[17:37:34.574]                   }
[17:37:34.574]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:37:34.574]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:37:34.574]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.574]                     USE.NAMES = FALSE)
[17:37:34.574]                   do.call(mapply, args = args)
[17:37:34.574]                 }
[17:37:34.574]             }))
[17:37:34.574]             future::FutureResult(value = ...future.value$value, 
[17:37:34.574]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.574]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.574]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.574]                     ...future.globalenv.names))
[17:37:34.574]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.574]         }, condition = base::local({
[17:37:34.574]             c <- base::c
[17:37:34.574]             inherits <- base::inherits
[17:37:34.574]             invokeRestart <- base::invokeRestart
[17:37:34.574]             length <- base::length
[17:37:34.574]             list <- base::list
[17:37:34.574]             seq.int <- base::seq.int
[17:37:34.574]             signalCondition <- base::signalCondition
[17:37:34.574]             sys.calls <- base::sys.calls
[17:37:34.574]             `[[` <- base::`[[`
[17:37:34.574]             `+` <- base::`+`
[17:37:34.574]             `<<-` <- base::`<<-`
[17:37:34.574]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.574]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.574]                   3L)]
[17:37:34.574]             }
[17:37:34.574]             function(cond) {
[17:37:34.574]                 is_error <- inherits(cond, "error")
[17:37:34.574]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.574]                   NULL)
[17:37:34.574]                 if (is_error) {
[17:37:34.574]                   sessionInformation <- function() {
[17:37:34.574]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.574]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.574]                       search = base::search(), system = base::Sys.info())
[17:37:34.574]                   }
[17:37:34.574]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.574]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.574]                     cond$call), session = sessionInformation(), 
[17:37:34.574]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.574]                   signalCondition(cond)
[17:37:34.574]                 }
[17:37:34.574]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.574]                 "immediateCondition"))) {
[17:37:34.574]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.574]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.574]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.574]                   if (TRUE && !signal) {
[17:37:34.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.574]                     {
[17:37:34.574]                       inherits <- base::inherits
[17:37:34.574]                       invokeRestart <- base::invokeRestart
[17:37:34.574]                       is.null <- base::is.null
[17:37:34.574]                       muffled <- FALSE
[17:37:34.574]                       if (inherits(cond, "message")) {
[17:37:34.574]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.574]                         if (muffled) 
[17:37:34.574]                           invokeRestart("muffleMessage")
[17:37:34.574]                       }
[17:37:34.574]                       else if (inherits(cond, "warning")) {
[17:37:34.574]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.574]                         if (muffled) 
[17:37:34.574]                           invokeRestart("muffleWarning")
[17:37:34.574]                       }
[17:37:34.574]                       else if (inherits(cond, "condition")) {
[17:37:34.574]                         if (!is.null(pattern)) {
[17:37:34.574]                           computeRestarts <- base::computeRestarts
[17:37:34.574]                           grepl <- base::grepl
[17:37:34.574]                           restarts <- computeRestarts(cond)
[17:37:34.574]                           for (restart in restarts) {
[17:37:34.574]                             name <- restart$name
[17:37:34.574]                             if (is.null(name)) 
[17:37:34.574]                               next
[17:37:34.574]                             if (!grepl(pattern, name)) 
[17:37:34.574]                               next
[17:37:34.574]                             invokeRestart(restart)
[17:37:34.574]                             muffled <- TRUE
[17:37:34.574]                             break
[17:37:34.574]                           }
[17:37:34.574]                         }
[17:37:34.574]                       }
[17:37:34.574]                       invisible(muffled)
[17:37:34.574]                     }
[17:37:34.574]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.574]                   }
[17:37:34.574]                 }
[17:37:34.574]                 else {
[17:37:34.574]                   if (TRUE) {
[17:37:34.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.574]                     {
[17:37:34.574]                       inherits <- base::inherits
[17:37:34.574]                       invokeRestart <- base::invokeRestart
[17:37:34.574]                       is.null <- base::is.null
[17:37:34.574]                       muffled <- FALSE
[17:37:34.574]                       if (inherits(cond, "message")) {
[17:37:34.574]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.574]                         if (muffled) 
[17:37:34.574]                           invokeRestart("muffleMessage")
[17:37:34.574]                       }
[17:37:34.574]                       else if (inherits(cond, "warning")) {
[17:37:34.574]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.574]                         if (muffled) 
[17:37:34.574]                           invokeRestart("muffleWarning")
[17:37:34.574]                       }
[17:37:34.574]                       else if (inherits(cond, "condition")) {
[17:37:34.574]                         if (!is.null(pattern)) {
[17:37:34.574]                           computeRestarts <- base::computeRestarts
[17:37:34.574]                           grepl <- base::grepl
[17:37:34.574]                           restarts <- computeRestarts(cond)
[17:37:34.574]                           for (restart in restarts) {
[17:37:34.574]                             name <- restart$name
[17:37:34.574]                             if (is.null(name)) 
[17:37:34.574]                               next
[17:37:34.574]                             if (!grepl(pattern, name)) 
[17:37:34.574]                               next
[17:37:34.574]                             invokeRestart(restart)
[17:37:34.574]                             muffled <- TRUE
[17:37:34.574]                             break
[17:37:34.574]                           }
[17:37:34.574]                         }
[17:37:34.574]                       }
[17:37:34.574]                       invisible(muffled)
[17:37:34.574]                     }
[17:37:34.574]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.574]                   }
[17:37:34.574]                 }
[17:37:34.574]             }
[17:37:34.574]         }))
[17:37:34.574]     }, error = function(ex) {
[17:37:34.574]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.574]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.574]                 ...future.rng), started = ...future.startTime, 
[17:37:34.574]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.574]             version = "1.8"), class = "FutureResult")
[17:37:34.574]     }, finally = {
[17:37:34.574]         if (!identical(...future.workdir, getwd())) 
[17:37:34.574]             setwd(...future.workdir)
[17:37:34.574]         {
[17:37:34.574]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.574]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.574]             }
[17:37:34.574]             base::options(...future.oldOptions)
[17:37:34.574]             if (.Platform$OS.type == "windows") {
[17:37:34.574]                 old_names <- names(...future.oldEnvVars)
[17:37:34.574]                 envs <- base::Sys.getenv()
[17:37:34.574]                 names <- names(envs)
[17:37:34.574]                 common <- intersect(names, old_names)
[17:37:34.574]                 added <- setdiff(names, old_names)
[17:37:34.574]                 removed <- setdiff(old_names, names)
[17:37:34.574]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.574]                   envs[common]]
[17:37:34.574]                 NAMES <- toupper(changed)
[17:37:34.574]                 args <- list()
[17:37:34.574]                 for (kk in seq_along(NAMES)) {
[17:37:34.574]                   name <- changed[[kk]]
[17:37:34.574]                   NAME <- NAMES[[kk]]
[17:37:34.574]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.574]                     next
[17:37:34.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.574]                 }
[17:37:34.574]                 NAMES <- toupper(added)
[17:37:34.574]                 for (kk in seq_along(NAMES)) {
[17:37:34.574]                   name <- added[[kk]]
[17:37:34.574]                   NAME <- NAMES[[kk]]
[17:37:34.574]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.574]                     next
[17:37:34.574]                   args[[name]] <- ""
[17:37:34.574]                 }
[17:37:34.574]                 NAMES <- toupper(removed)
[17:37:34.574]                 for (kk in seq_along(NAMES)) {
[17:37:34.574]                   name <- removed[[kk]]
[17:37:34.574]                   NAME <- NAMES[[kk]]
[17:37:34.574]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.574]                     next
[17:37:34.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.574]                 }
[17:37:34.574]                 if (length(args) > 0) 
[17:37:34.574]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.574]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.574]             }
[17:37:34.574]             else {
[17:37:34.574]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.574]             }
[17:37:34.574]             {
[17:37:34.574]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.574]                   0L) {
[17:37:34.574]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.574]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.574]                   base::options(opts)
[17:37:34.574]                 }
[17:37:34.574]                 {
[17:37:34.574]                   {
[17:37:34.574]                     base::assign(".Random.seed", c(10407L, 1615515356L, 
[17:37:34.574]                     394111846L, -421624749L, -1988804446L, 182898754L, 
[17:37:34.574]                     1488521025L), envir = base::globalenv(), 
[17:37:34.574]                       inherits = FALSE)
[17:37:34.574]                     NULL
[17:37:34.574]                   }
[17:37:34.574]                   options(future.plan = NULL)
[17:37:34.574]                   if (is.na(NA_character_)) 
[17:37:34.574]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.574]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.574]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.574]                     .init = FALSE)
[17:37:34.574]                 }
[17:37:34.574]             }
[17:37:34.574]         }
[17:37:34.574]     })
[17:37:34.574]     if (TRUE) {
[17:37:34.574]         base::sink(type = "output", split = FALSE)
[17:37:34.574]         if (TRUE) {
[17:37:34.574]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.574]         }
[17:37:34.574]         else {
[17:37:34.574]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.574]         }
[17:37:34.574]         base::close(...future.stdout)
[17:37:34.574]         ...future.stdout <- NULL
[17:37:34.574]     }
[17:37:34.574]     ...future.result$conditions <- ...future.conditions
[17:37:34.574]     ...future.result$finished <- base::Sys.time()
[17:37:34.574]     ...future.result
[17:37:34.574] }
[17:37:34.576] assign_globals() ...
[17:37:34.576] List of 5
[17:37:34.576]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[17:37:34.576]  $ MoreArgs                 :List of 1
[17:37:34.576]   ..$ min: num 1
[17:37:34.576]  $ ...future.elements_ii    :List of 2
[17:37:34.576]   ..$ n  :List of 4
[17:37:34.576]   .. ..$ : int 1
[17:37:34.576]   .. ..$ : int 2
[17:37:34.576]   .. ..$ : int 3
[17:37:34.576]   .. ..$ : int 4
[17:37:34.576]   ..$ max:List of 4
[17:37:34.576]   .. ..$ : int 2
[17:37:34.576]   .. ..$ : int 3
[17:37:34.576]   .. ..$ : int 4
[17:37:34.576]   .. ..$ : int 5
[17:37:34.576]  $ ...future.seeds_ii       :List of 4
[17:37:34.576]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[17:37:34.576]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[17:37:34.576]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[17:37:34.576]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[17:37:34.576]  $ ...future.globals.maxSize: NULL
[17:37:34.576]  - attr(*, "where")=List of 5
[17:37:34.576]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.576]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.576]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.576]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.576]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.576]  - attr(*, "resolved")= logi FALSE
[17:37:34.576]  - attr(*, "total_size")= num 2912
[17:37:34.576]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.576]  - attr(*, "already-done")= logi TRUE
[17:37:34.586] - copied ‘...future.FUN’ to environment
[17:37:34.586] - copied ‘MoreArgs’ to environment
[17:37:34.586] - copied ‘...future.elements_ii’ to environment
[17:37:34.587] - copied ‘...future.seeds_ii’ to environment
[17:37:34.587] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.587] assign_globals() ... done
[17:37:34.587] plan(): Setting new future strategy stack:
[17:37:34.587] List of future strategies:
[17:37:34.587] 1. sequential:
[17:37:34.587]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.587]    - tweaked: FALSE
[17:37:34.587]    - call: NULL
[17:37:34.588] plan(): nbrOfWorkers() = 1
[17:37:34.588] plan(): Setting new future strategy stack:
[17:37:34.589] List of future strategies:
[17:37:34.589] 1. sequential:
[17:37:34.589]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.589]    - tweaked: FALSE
[17:37:34.589]    - call: plan(strategy)
[17:37:34.589] plan(): nbrOfWorkers() = 1
[17:37:34.589] SequentialFuture started (and completed)
[17:37:34.589] - Launch lazy future ... done
[17:37:34.589] run() for ‘SequentialFuture’ ... done
[17:37:34.589] Created future:
[17:37:34.590] SequentialFuture:
[17:37:34.590] Label: ‘future_mapply-1’
[17:37:34.590] Expression:
[17:37:34.590] {
[17:37:34.590]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.590]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.590]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.590]         on.exit(options(oopts), add = TRUE)
[17:37:34.590]     }
[17:37:34.590]     {
[17:37:34.590]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:37:34.590]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:37:34.590]                 inherits = FALSE)
[17:37:34.590]             ...future.FUN(...)
[17:37:34.590]         }
[17:37:34.590]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:37:34.590]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:37:34.590]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.590]         do.call(mapply, args = args)
[17:37:34.590]     }
[17:37:34.590] }
[17:37:34.590] Lazy evaluation: FALSE
[17:37:34.590] Asynchronous evaluation: FALSE
[17:37:34.590] Local evaluation: TRUE
[17:37:34.590] Environment: R_GlobalEnv
[17:37:34.590] Capture standard output: TRUE
[17:37:34.590] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.590] Globals: 5 objects totaling 2.84 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 448 bytes, list ‘...future.seeds_ii’ of 320 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.590] Packages: 1 packages (‘stats’)
[17:37:34.590] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:37:34.590] Resolved: TRUE
[17:37:34.590] Value: 280 bytes of class ‘list’
[17:37:34.590] Early signaling: FALSE
[17:37:34.590] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.590] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.591] Chunk #1 of 1 ... DONE
[17:37:34.591] Launching 1 futures (chunks) ... DONE
[17:37:34.591] Resolving 1 futures (chunks) ...
[17:37:34.591] resolve() on list ...
[17:37:34.591]  recursive: 0
[17:37:34.591]  length: 1
[17:37:34.591] 
[17:37:34.591] resolved() for ‘SequentialFuture’ ...
[17:37:34.591] - state: ‘finished’
[17:37:34.591] - run: TRUE
[17:37:34.591] - result: ‘FutureResult’
[17:37:34.592] resolved() for ‘SequentialFuture’ ... done
[17:37:34.592] Future #1
[17:37:34.592] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:34.592] - nx: 1
[17:37:34.592] - relay: TRUE
[17:37:34.592] - stdout: TRUE
[17:37:34.592] - signal: TRUE
[17:37:34.592] - resignal: FALSE
[17:37:34.592] - force: TRUE
[17:37:34.592] - relayed: [n=1] FALSE
[17:37:34.592] - queued futures: [n=1] FALSE
[17:37:34.593]  - until=1
[17:37:34.593]  - relaying element #1
[17:37:34.593] - relayed: [n=1] TRUE
[17:37:34.593] - queued futures: [n=1] TRUE
[17:37:34.593] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:34.593]  length: 0 (resolved future 1)
[17:37:34.593] Relaying remaining futures
[17:37:34.593] signalConditionsASAP(NULL, pos=0) ...
[17:37:34.593] - nx: 1
[17:37:34.593] - relay: TRUE
[17:37:34.594] - stdout: TRUE
[17:37:34.594] - signal: TRUE
[17:37:34.594] - resignal: FALSE
[17:37:34.594] - force: TRUE
[17:37:34.594] - relayed: [n=1] TRUE
[17:37:34.594] - queued futures: [n=1] TRUE
 - flush all
[17:37:34.594] - relayed: [n=1] TRUE
[17:37:34.594] - queued futures: [n=1] TRUE
[17:37:34.594] signalConditionsASAP(NULL, pos=0) ... done
[17:37:34.594] resolve() on list ... DONE
[17:37:34.594]  - Number of value chunks collected: 1
[17:37:34.595] Resolving 1 futures (chunks) ... DONE
[17:37:34.595] Reducing values from 1 chunks ...
[17:37:34.595]  - Number of values collected after concatenation: 4
[17:37:34.595]  - Number of values expected: 4
[17:37:34.595] Reducing values from 1 chunks ... DONE
[17:37:34.595] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[17:37:34.597] future_mapply() ...
[17:37:34.597] Number of chunks: 1
[17:37:34.598] getGlobalsAndPackagesXApply() ...
[17:37:34.598]  - future.globals: TRUE
[17:37:34.598] getGlobalsAndPackages() ...
[17:37:34.598] Searching for globals...
[17:37:34.599] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:37:34.599] Searching for globals ... DONE
[17:37:34.599] Resolving globals: FALSE
[17:37:34.599] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[17:37:34.600] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[17:37:34.600] - globals: [1] ‘FUN’
[17:37:34.600] - packages: [1] ‘stats’
[17:37:34.602] getGlobalsAndPackages() ... DONE
[17:37:34.602]  - globals found/used: [n=1] ‘FUN’
[17:37:34.602]  - needed namespaces: [n=1] ‘stats’
[17:37:34.602] Finding globals ... DONE
[17:37:34.602] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:34.602] List of 2
[17:37:34.602]  $ ...future.FUN:function (x, w, ...)  
[17:37:34.602]  $ MoreArgs     : NULL
[17:37:34.602]  - attr(*, "where")=List of 2
[17:37:34.602]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:34.602]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:34.602]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.602]  - attr(*, "resolved")= logi FALSE
[17:37:34.602]  - attr(*, "total_size")= num NA
[17:37:34.605] Packages to be attached in all futures: [n=1] ‘stats’
[17:37:34.605] getGlobalsAndPackagesXApply() ... DONE
[17:37:34.605] Number of futures (= number of chunks): 1
[17:37:34.606] Launching 1 futures (chunks) ...
[17:37:34.606] Chunk #1 of 1 ...
[17:37:34.606]  - Finding globals in '...' for chunk #1 ...
[17:37:34.606] getGlobalsAndPackages() ...
[17:37:34.606] Searching for globals...
[17:37:34.606] 
[17:37:34.606] Searching for globals ... DONE
[17:37:34.606] - globals: [0] <none>
[17:37:34.607] getGlobalsAndPackages() ... DONE
[17:37:34.607]    + additional globals found: [n=0] 
[17:37:34.607]    + additional namespaces needed: [n=0] 
[17:37:34.607]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:34.607]  - seeds: <none>
[17:37:34.607]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.607] getGlobalsAndPackages() ...
[17:37:34.607] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.607] Resolving globals: FALSE
[17:37:34.608] The total size of the 5 globals is 3.10 KiB (3176 bytes)
[17:37:34.608] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (1.72 KiB of class ‘list’), ‘...future.FUN’ (1.38 KiB of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:34.608] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.609] - packages: [1] ‘stats’
[17:37:34.609] getGlobalsAndPackages() ... DONE
[17:37:34.609] run() for ‘Future’ ...
[17:37:34.609] - state: ‘created’
[17:37:34.609] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.609] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.610] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.610]   - Field: ‘label’
[17:37:34.610]   - Field: ‘local’
[17:37:34.610]   - Field: ‘owner’
[17:37:34.610]   - Field: ‘envir’
[17:37:34.610]   - Field: ‘packages’
[17:37:34.610]   - Field: ‘gc’
[17:37:34.610]   - Field: ‘conditions’
[17:37:34.610]   - Field: ‘expr’
[17:37:34.610]   - Field: ‘uuid’
[17:37:34.611]   - Field: ‘seed’
[17:37:34.611]   - Field: ‘version’
[17:37:34.611]   - Field: ‘result’
[17:37:34.611]   - Field: ‘asynchronous’
[17:37:34.611]   - Field: ‘calls’
[17:37:34.611]   - Field: ‘globals’
[17:37:34.611]   - Field: ‘stdout’
[17:37:34.611]   - Field: ‘earlySignal’
[17:37:34.611]   - Field: ‘lazy’
[17:37:34.611]   - Field: ‘state’
[17:37:34.611] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.612] - Launch lazy future ...
[17:37:34.612] Packages needed by the future expression (n = 1): ‘stats’
[17:37:34.612] Packages needed by future strategies (n = 0): <none>
[17:37:34.612] {
[17:37:34.612]     {
[17:37:34.612]         {
[17:37:34.612]             ...future.startTime <- base::Sys.time()
[17:37:34.612]             {
[17:37:34.612]                 {
[17:37:34.612]                   {
[17:37:34.612]                     {
[17:37:34.612]                       base::local({
[17:37:34.612]                         has_future <- base::requireNamespace("future", 
[17:37:34.612]                           quietly = TRUE)
[17:37:34.612]                         if (has_future) {
[17:37:34.612]                           ns <- base::getNamespace("future")
[17:37:34.612]                           version <- ns[[".package"]][["version"]]
[17:37:34.612]                           if (is.null(version)) 
[17:37:34.612]                             version <- utils::packageVersion("future")
[17:37:34.612]                         }
[17:37:34.612]                         else {
[17:37:34.612]                           version <- NULL
[17:37:34.612]                         }
[17:37:34.612]                         if (!has_future || version < "1.8.0") {
[17:37:34.612]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.612]                             "", base::R.version$version.string), 
[17:37:34.612]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:34.612]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.612]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.612]                               "release", "version")], collapse = " "), 
[17:37:34.612]                             hostname = base::Sys.info()[["nodename"]])
[17:37:34.612]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.612]                             info)
[17:37:34.612]                           info <- base::paste(info, collapse = "; ")
[17:37:34.612]                           if (!has_future) {
[17:37:34.612]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.612]                               info)
[17:37:34.612]                           }
[17:37:34.612]                           else {
[17:37:34.612]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.612]                               info, version)
[17:37:34.612]                           }
[17:37:34.612]                           base::stop(msg)
[17:37:34.612]                         }
[17:37:34.612]                       })
[17:37:34.612]                     }
[17:37:34.612]                     base::local({
[17:37:34.612]                       for (pkg in "stats") {
[17:37:34.612]                         base::loadNamespace(pkg)
[17:37:34.612]                         base::library(pkg, character.only = TRUE)
[17:37:34.612]                       }
[17:37:34.612]                     })
[17:37:34.612]                   }
[17:37:34.612]                   ...future.strategy.old <- future::plan("list")
[17:37:34.612]                   options(future.plan = NULL)
[17:37:34.612]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.612]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.612]                 }
[17:37:34.612]                 ...future.workdir <- getwd()
[17:37:34.612]             }
[17:37:34.612]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.612]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.612]         }
[17:37:34.612]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.612]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:34.612]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.612]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.612]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.612]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.612]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.612]             base::names(...future.oldOptions))
[17:37:34.612]     }
[17:37:34.612]     if (FALSE) {
[17:37:34.612]     }
[17:37:34.612]     else {
[17:37:34.612]         if (TRUE) {
[17:37:34.612]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.612]                 open = "w")
[17:37:34.612]         }
[17:37:34.612]         else {
[17:37:34.612]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.612]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.612]         }
[17:37:34.612]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.612]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.612]             base::sink(type = "output", split = FALSE)
[17:37:34.612]             base::close(...future.stdout)
[17:37:34.612]         }, add = TRUE)
[17:37:34.612]     }
[17:37:34.612]     ...future.frame <- base::sys.nframe()
[17:37:34.612]     ...future.conditions <- base::list()
[17:37:34.612]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.612]     if (FALSE) {
[17:37:34.612]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.612]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.612]     }
[17:37:34.612]     ...future.result <- base::tryCatch({
[17:37:34.612]         base::withCallingHandlers({
[17:37:34.612]             ...future.value <- base::withVisible(base::local({
[17:37:34.612]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.612]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.612]                   ...future.globals.maxSize)) {
[17:37:34.612]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.612]                   on.exit(options(oopts), add = TRUE)
[17:37:34.612]                 }
[17:37:34.612]                 {
[17:37:34.612]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.612]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.612]                     USE.NAMES = FALSE)
[17:37:34.612]                   do.call(mapply, args = args)
[17:37:34.612]                 }
[17:37:34.612]             }))
[17:37:34.612]             future::FutureResult(value = ...future.value$value, 
[17:37:34.612]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.612]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.612]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.612]                     ...future.globalenv.names))
[17:37:34.612]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.612]         }, condition = base::local({
[17:37:34.612]             c <- base::c
[17:37:34.612]             inherits <- base::inherits
[17:37:34.612]             invokeRestart <- base::invokeRestart
[17:37:34.612]             length <- base::length
[17:37:34.612]             list <- base::list
[17:37:34.612]             seq.int <- base::seq.int
[17:37:34.612]             signalCondition <- base::signalCondition
[17:37:34.612]             sys.calls <- base::sys.calls
[17:37:34.612]             `[[` <- base::`[[`
[17:37:34.612]             `+` <- base::`+`
[17:37:34.612]             `<<-` <- base::`<<-`
[17:37:34.612]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.612]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.612]                   3L)]
[17:37:34.612]             }
[17:37:34.612]             function(cond) {
[17:37:34.612]                 is_error <- inherits(cond, "error")
[17:37:34.612]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.612]                   NULL)
[17:37:34.612]                 if (is_error) {
[17:37:34.612]                   sessionInformation <- function() {
[17:37:34.612]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.612]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.612]                       search = base::search(), system = base::Sys.info())
[17:37:34.612]                   }
[17:37:34.612]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.612]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.612]                     cond$call), session = sessionInformation(), 
[17:37:34.612]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.612]                   signalCondition(cond)
[17:37:34.612]                 }
[17:37:34.612]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.612]                 "immediateCondition"))) {
[17:37:34.612]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.612]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.612]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.612]                   if (TRUE && !signal) {
[17:37:34.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.612]                     {
[17:37:34.612]                       inherits <- base::inherits
[17:37:34.612]                       invokeRestart <- base::invokeRestart
[17:37:34.612]                       is.null <- base::is.null
[17:37:34.612]                       muffled <- FALSE
[17:37:34.612]                       if (inherits(cond, "message")) {
[17:37:34.612]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.612]                         if (muffled) 
[17:37:34.612]                           invokeRestart("muffleMessage")
[17:37:34.612]                       }
[17:37:34.612]                       else if (inherits(cond, "warning")) {
[17:37:34.612]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.612]                         if (muffled) 
[17:37:34.612]                           invokeRestart("muffleWarning")
[17:37:34.612]                       }
[17:37:34.612]                       else if (inherits(cond, "condition")) {
[17:37:34.612]                         if (!is.null(pattern)) {
[17:37:34.612]                           computeRestarts <- base::computeRestarts
[17:37:34.612]                           grepl <- base::grepl
[17:37:34.612]                           restarts <- computeRestarts(cond)
[17:37:34.612]                           for (restart in restarts) {
[17:37:34.612]                             name <- restart$name
[17:37:34.612]                             if (is.null(name)) 
[17:37:34.612]                               next
[17:37:34.612]                             if (!grepl(pattern, name)) 
[17:37:34.612]                               next
[17:37:34.612]                             invokeRestart(restart)
[17:37:34.612]                             muffled <- TRUE
[17:37:34.612]                             break
[17:37:34.612]                           }
[17:37:34.612]                         }
[17:37:34.612]                       }
[17:37:34.612]                       invisible(muffled)
[17:37:34.612]                     }
[17:37:34.612]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.612]                   }
[17:37:34.612]                 }
[17:37:34.612]                 else {
[17:37:34.612]                   if (TRUE) {
[17:37:34.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.612]                     {
[17:37:34.612]                       inherits <- base::inherits
[17:37:34.612]                       invokeRestart <- base::invokeRestart
[17:37:34.612]                       is.null <- base::is.null
[17:37:34.612]                       muffled <- FALSE
[17:37:34.612]                       if (inherits(cond, "message")) {
[17:37:34.612]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.612]                         if (muffled) 
[17:37:34.612]                           invokeRestart("muffleMessage")
[17:37:34.612]                       }
[17:37:34.612]                       else if (inherits(cond, "warning")) {
[17:37:34.612]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.612]                         if (muffled) 
[17:37:34.612]                           invokeRestart("muffleWarning")
[17:37:34.612]                       }
[17:37:34.612]                       else if (inherits(cond, "condition")) {
[17:37:34.612]                         if (!is.null(pattern)) {
[17:37:34.612]                           computeRestarts <- base::computeRestarts
[17:37:34.612]                           grepl <- base::grepl
[17:37:34.612]                           restarts <- computeRestarts(cond)
[17:37:34.612]                           for (restart in restarts) {
[17:37:34.612]                             name <- restart$name
[17:37:34.612]                             if (is.null(name)) 
[17:37:34.612]                               next
[17:37:34.612]                             if (!grepl(pattern, name)) 
[17:37:34.612]                               next
[17:37:34.612]                             invokeRestart(restart)
[17:37:34.612]                             muffled <- TRUE
[17:37:34.612]                             break
[17:37:34.612]                           }
[17:37:34.612]                         }
[17:37:34.612]                       }
[17:37:34.612]                       invisible(muffled)
[17:37:34.612]                     }
[17:37:34.612]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.612]                   }
[17:37:34.612]                 }
[17:37:34.612]             }
[17:37:34.612]         }))
[17:37:34.612]     }, error = function(ex) {
[17:37:34.612]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.612]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.612]                 ...future.rng), started = ...future.startTime, 
[17:37:34.612]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.612]             version = "1.8"), class = "FutureResult")
[17:37:34.612]     }, finally = {
[17:37:34.612]         if (!identical(...future.workdir, getwd())) 
[17:37:34.612]             setwd(...future.workdir)
[17:37:34.612]         {
[17:37:34.612]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.612]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.612]             }
[17:37:34.612]             base::options(...future.oldOptions)
[17:37:34.612]             if (.Platform$OS.type == "windows") {
[17:37:34.612]                 old_names <- names(...future.oldEnvVars)
[17:37:34.612]                 envs <- base::Sys.getenv()
[17:37:34.612]                 names <- names(envs)
[17:37:34.612]                 common <- intersect(names, old_names)
[17:37:34.612]                 added <- setdiff(names, old_names)
[17:37:34.612]                 removed <- setdiff(old_names, names)
[17:37:34.612]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.612]                   envs[common]]
[17:37:34.612]                 NAMES <- toupper(changed)
[17:37:34.612]                 args <- list()
[17:37:34.612]                 for (kk in seq_along(NAMES)) {
[17:37:34.612]                   name <- changed[[kk]]
[17:37:34.612]                   NAME <- NAMES[[kk]]
[17:37:34.612]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.612]                     next
[17:37:34.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.612]                 }
[17:37:34.612]                 NAMES <- toupper(added)
[17:37:34.612]                 for (kk in seq_along(NAMES)) {
[17:37:34.612]                   name <- added[[kk]]
[17:37:34.612]                   NAME <- NAMES[[kk]]
[17:37:34.612]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.612]                     next
[17:37:34.612]                   args[[name]] <- ""
[17:37:34.612]                 }
[17:37:34.612]                 NAMES <- toupper(removed)
[17:37:34.612]                 for (kk in seq_along(NAMES)) {
[17:37:34.612]                   name <- removed[[kk]]
[17:37:34.612]                   NAME <- NAMES[[kk]]
[17:37:34.612]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.612]                     next
[17:37:34.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.612]                 }
[17:37:34.612]                 if (length(args) > 0) 
[17:37:34.612]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.612]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.612]             }
[17:37:34.612]             else {
[17:37:34.612]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.612]             }
[17:37:34.612]             {
[17:37:34.612]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.612]                   0L) {
[17:37:34.612]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.612]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.612]                   base::options(opts)
[17:37:34.612]                 }
[17:37:34.612]                 {
[17:37:34.612]                   {
[17:37:34.612]                     base::assign(".Random.seed", c(10407L, 922393460L, 
[17:37:34.612]                     -1763300862L, -790978071L, -1874471625L, 
[17:37:34.612]                     -1277687904L, -753596510L), envir = base::globalenv(), 
[17:37:34.612]                       inherits = FALSE)
[17:37:34.612]                     NULL
[17:37:34.612]                   }
[17:37:34.612]                   options(future.plan = NULL)
[17:37:34.612]                   if (is.na(NA_character_)) 
[17:37:34.612]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.612]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.612]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.612]                     .init = FALSE)
[17:37:34.612]                 }
[17:37:34.612]             }
[17:37:34.612]         }
[17:37:34.612]     })
[17:37:34.612]     if (TRUE) {
[17:37:34.612]         base::sink(type = "output", split = FALSE)
[17:37:34.612]         if (TRUE) {
[17:37:34.612]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.612]         }
[17:37:34.612]         else {
[17:37:34.612]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.612]         }
[17:37:34.612]         base::close(...future.stdout)
[17:37:34.612]         ...future.stdout <- NULL
[17:37:34.612]     }
[17:37:34.612]     ...future.result$conditions <- ...future.conditions
[17:37:34.612]     ...future.result$finished <- base::Sys.time()
[17:37:34.612]     ...future.result
[17:37:34.612] }
[17:37:34.614] assign_globals() ...
[17:37:34.614] List of 5
[17:37:34.614]  $ ...future.FUN            :function (x, w, ...)  
[17:37:34.614]  $ MoreArgs                 : NULL
[17:37:34.614]  $ ...future.elements_ii    :List of 2
[17:37:34.614]   ..$ :List of 5
[17:37:34.614]   .. ..$ : num [1:10] 0.0466 0.5263 0.386 0.8926 0.3952 ...
[17:37:34.614]   .. ..$ : num [1:10] 0.97534 0.87566 0.24837 0.00562 0.90677 ...
[17:37:34.614]   .. ..$ : num [1:10] 0.1493 0.2054 0.0637 0.7429 0.3691 ...
[17:37:34.614]   .. ..$ : num [1:10] 0.9794 0.308 0.9542 0.0151 0.9389 ...
[17:37:34.614]   .. ..$ : num [1:10] 0.964 0.9568 0.0284 0.9896 0.2965 ...
[17:37:34.614]   ..$ :List of 5
[17:37:34.614]   .. ..$ : num [1:10] 7 8 5 5 5 7 7 6 4 6
[17:37:34.614]   .. ..$ : num [1:10] 3 7 3 4 4 13 7 9 6 5
[17:37:34.614]   .. ..$ : num [1:10] 5 6 3 7 6 4 7 5 8 5
[17:37:34.614]   .. ..$ : num [1:10] 8 8 9 3 8 4 7 6 8 6
[17:37:34.614]   .. ..$ : num [1:10] 5 7 4 3 7 3 3 7 9 12
[17:37:34.614]  $ ...future.seeds_ii       : NULL
[17:37:34.614]  $ ...future.globals.maxSize: NULL
[17:37:34.614]  - attr(*, "where")=List of 5
[17:37:34.614]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.614]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.614]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.614]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.614]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.614]  - attr(*, "resolved")= logi FALSE
[17:37:34.614]  - attr(*, "total_size")= num 3176
[17:37:34.614]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.614]  - attr(*, "already-done")= logi TRUE
[17:37:34.622] - copied ‘...future.FUN’ to environment
[17:37:34.622] - copied ‘MoreArgs’ to environment
[17:37:34.622] - copied ‘...future.elements_ii’ to environment
[17:37:34.622] - copied ‘...future.seeds_ii’ to environment
[17:37:34.622] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.622] assign_globals() ... done
[17:37:34.623] plan(): Setting new future strategy stack:
[17:37:34.623] List of future strategies:
[17:37:34.623] 1. sequential:
[17:37:34.623]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.623]    - tweaked: FALSE
[17:37:34.623]    - call: NULL
[17:37:34.623] plan(): nbrOfWorkers() = 1
[17:37:34.624] plan(): Setting new future strategy stack:
[17:37:34.624] List of future strategies:
[17:37:34.624] 1. sequential:
[17:37:34.624]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.624]    - tweaked: FALSE
[17:37:34.624]    - call: plan(strategy)
[17:37:34.626] plan(): nbrOfWorkers() = 1
[17:37:34.627] SequentialFuture started (and completed)
[17:37:34.627] - Launch lazy future ... done
[17:37:34.627] run() for ‘SequentialFuture’ ... done
[17:37:34.627] Created future:
[17:37:34.627] SequentialFuture:
[17:37:34.627] Label: ‘future_Map-1’
[17:37:34.627] Expression:
[17:37:34.627] {
[17:37:34.627]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.627]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.627]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.627]         on.exit(options(oopts), add = TRUE)
[17:37:34.627]     }
[17:37:34.627]     {
[17:37:34.627]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.627]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.627]         do.call(mapply, args = args)
[17:37:34.627]     }
[17:37:34.627] }
[17:37:34.627] Lazy evaluation: FALSE
[17:37:34.627] Asynchronous evaluation: FALSE
[17:37:34.627] Local evaluation: TRUE
[17:37:34.627] Environment: R_GlobalEnv
[17:37:34.627] Capture standard output: TRUE
[17:37:34.627] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.627] Globals: 5 objects totaling 3.10 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.627] Packages: 1 packages (‘stats’)
[17:37:34.627] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.627] Resolved: TRUE
[17:37:34.627] Value: 280 bytes of class ‘list’
[17:37:34.627] Early signaling: FALSE
[17:37:34.627] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.627] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.628] Chunk #1 of 1 ... DONE
[17:37:34.628] Launching 1 futures (chunks) ... DONE
[17:37:34.628] Resolving 1 futures (chunks) ...
[17:37:34.629] resolve() on list ...
[17:37:34.629]  recursive: 0
[17:37:34.629]  length: 1
[17:37:34.629] 
[17:37:34.629] resolved() for ‘SequentialFuture’ ...
[17:37:34.629] - state: ‘finished’
[17:37:34.629] - run: TRUE
[17:37:34.629] - result: ‘FutureResult’
[17:37:34.629] resolved() for ‘SequentialFuture’ ... done
[17:37:34.629] Future #1
[17:37:34.630] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:34.630] - nx: 1
[17:37:34.630] - relay: TRUE
[17:37:34.630] - stdout: TRUE
[17:37:34.630] - signal: TRUE
[17:37:34.630] - resignal: FALSE
[17:37:34.630] - force: TRUE
[17:37:34.630] - relayed: [n=1] FALSE
[17:37:34.630] - queued futures: [n=1] FALSE
[17:37:34.630]  - until=1
[17:37:34.630]  - relaying element #1
[17:37:34.631] - relayed: [n=1] TRUE
[17:37:34.631] - queued futures: [n=1] TRUE
[17:37:34.631] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:34.631]  length: 0 (resolved future 1)
[17:37:34.631] Relaying remaining futures
[17:37:34.631] signalConditionsASAP(NULL, pos=0) ...
[17:37:34.631] - nx: 1
[17:37:34.631] - relay: TRUE
[17:37:34.631] - stdout: TRUE
[17:37:34.631] - signal: TRUE
[17:37:34.632] - resignal: FALSE
[17:37:34.632] - force: TRUE
[17:37:34.632] - relayed: [n=1] TRUE
[17:37:34.632] - queued futures: [n=1] TRUE
 - flush all
[17:37:34.632] - relayed: [n=1] TRUE
[17:37:34.632] - queued futures: [n=1] TRUE
[17:37:34.632] signalConditionsASAP(NULL, pos=0) ... done
[17:37:34.632] resolve() on list ... DONE
[17:37:34.632]  - Number of value chunks collected: 1
[17:37:34.632] Resolving 1 futures (chunks) ... DONE
[17:37:34.633] Reducing values from 1 chunks ...
[17:37:34.633]  - Number of values collected after concatenation: 5
[17:37:34.633]  - Number of values expected: 5
[17:37:34.633] Reducing values from 1 chunks ... DONE
[17:37:34.633] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[17:37:34.635] future_mapply() ...
[17:37:34.635] Number of chunks: 1
[17:37:34.635] getGlobalsAndPackagesXApply() ...
[17:37:34.635]  - future.globals: TRUE
[17:37:34.635] getGlobalsAndPackages() ...
[17:37:34.635] Searching for globals...
[17:37:34.636] - globals found: [1] ‘FUN’
[17:37:34.636] Searching for globals ... DONE
[17:37:34.636] Resolving globals: FALSE
[17:37:34.636] The total size of the 1 globals is 56 bytes (56 bytes)
[17:37:34.637] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:37:34.637] - globals: [1] ‘FUN’
[17:37:34.637] 
[17:37:34.637] getGlobalsAndPackages() ... DONE
[17:37:34.637]  - globals found/used: [n=1] ‘FUN’
[17:37:34.637]  - needed namespaces: [n=0] 
[17:37:34.637] Finding globals ... DONE
[17:37:34.637] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:34.637] List of 2
[17:37:34.637]  $ ...future.FUN:function (e1, e2)  
[17:37:34.637]  $ MoreArgs     : NULL
[17:37:34.637]  - attr(*, "where")=List of 2
[17:37:34.637]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:34.637]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:34.637]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.637]  - attr(*, "resolved")= logi FALSE
[17:37:34.637]  - attr(*, "total_size")= num NA
[17:37:34.640] Packages to be attached in all futures: [n=0] 
[17:37:34.640] getGlobalsAndPackagesXApply() ... DONE
[17:37:34.640] Number of futures (= number of chunks): 1
[17:37:34.640] Launching 1 futures (chunks) ...
[17:37:34.640] Chunk #1 of 1 ...
[17:37:34.641]  - Finding globals in '...' for chunk #1 ...
[17:37:34.641] getGlobalsAndPackages() ...
[17:37:34.641] Searching for globals...
[17:37:34.641] 
[17:37:34.641] Searching for globals ... DONE
[17:37:34.641] - globals: [0] <none>
[17:37:34.641] getGlobalsAndPackages() ... DONE
[17:37:34.641]    + additional globals found: [n=0] 
[17:37:34.641]    + additional namespaces needed: [n=0] 
[17:37:34.642]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:34.642]  - seeds: <none>
[17:37:34.642]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.642] getGlobalsAndPackages() ...
[17:37:34.642] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.642] Resolving globals: FALSE
[17:37:34.643] The total size of the 5 globals is 392 bytes (392 bytes)
[17:37:34.643] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 392 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (336 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:34.643] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.643] 
[17:37:34.643] getGlobalsAndPackages() ... DONE
[17:37:34.644] run() for ‘Future’ ...
[17:37:34.644] - state: ‘created’
[17:37:34.644] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.644] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.644] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.644]   - Field: ‘label’
[17:37:34.644]   - Field: ‘local’
[17:37:34.645]   - Field: ‘owner’
[17:37:34.645]   - Field: ‘envir’
[17:37:34.645]   - Field: ‘packages’
[17:37:34.645]   - Field: ‘gc’
[17:37:34.645]   - Field: ‘conditions’
[17:37:34.645]   - Field: ‘expr’
[17:37:34.645]   - Field: ‘uuid’
[17:37:34.645]   - Field: ‘seed’
[17:37:34.645]   - Field: ‘version’
[17:37:34.645]   - Field: ‘result’
[17:37:34.645]   - Field: ‘asynchronous’
[17:37:34.646]   - Field: ‘calls’
[17:37:34.646]   - Field: ‘globals’
[17:37:34.646]   - Field: ‘stdout’
[17:37:34.646]   - Field: ‘earlySignal’
[17:37:34.646]   - Field: ‘lazy’
[17:37:34.646]   - Field: ‘state’
[17:37:34.646] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.646] - Launch lazy future ...
[17:37:34.646] Packages needed by the future expression (n = 0): <none>
[17:37:34.647] Packages needed by future strategies (n = 0): <none>
[17:37:34.647] {
[17:37:34.647]     {
[17:37:34.647]         {
[17:37:34.647]             ...future.startTime <- base::Sys.time()
[17:37:34.647]             {
[17:37:34.647]                 {
[17:37:34.647]                   {
[17:37:34.647]                     base::local({
[17:37:34.647]                       has_future <- base::requireNamespace("future", 
[17:37:34.647]                         quietly = TRUE)
[17:37:34.647]                       if (has_future) {
[17:37:34.647]                         ns <- base::getNamespace("future")
[17:37:34.647]                         version <- ns[[".package"]][["version"]]
[17:37:34.647]                         if (is.null(version)) 
[17:37:34.647]                           version <- utils::packageVersion("future")
[17:37:34.647]                       }
[17:37:34.647]                       else {
[17:37:34.647]                         version <- NULL
[17:37:34.647]                       }
[17:37:34.647]                       if (!has_future || version < "1.8.0") {
[17:37:34.647]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.647]                           "", base::R.version$version.string), 
[17:37:34.647]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:34.647]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.647]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.647]                             "release", "version")], collapse = " "), 
[17:37:34.647]                           hostname = base::Sys.info()[["nodename"]])
[17:37:34.647]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.647]                           info)
[17:37:34.647]                         info <- base::paste(info, collapse = "; ")
[17:37:34.647]                         if (!has_future) {
[17:37:34.647]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.647]                             info)
[17:37:34.647]                         }
[17:37:34.647]                         else {
[17:37:34.647]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.647]                             info, version)
[17:37:34.647]                         }
[17:37:34.647]                         base::stop(msg)
[17:37:34.647]                       }
[17:37:34.647]                     })
[17:37:34.647]                   }
[17:37:34.647]                   ...future.strategy.old <- future::plan("list")
[17:37:34.647]                   options(future.plan = NULL)
[17:37:34.647]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.647]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.647]                 }
[17:37:34.647]                 ...future.workdir <- getwd()
[17:37:34.647]             }
[17:37:34.647]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.647]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.647]         }
[17:37:34.647]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.647]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:34.647]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.647]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.647]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.647]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.647]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.647]             base::names(...future.oldOptions))
[17:37:34.647]     }
[17:37:34.647]     if (FALSE) {
[17:37:34.647]     }
[17:37:34.647]     else {
[17:37:34.647]         if (TRUE) {
[17:37:34.647]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.647]                 open = "w")
[17:37:34.647]         }
[17:37:34.647]         else {
[17:37:34.647]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.647]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.647]         }
[17:37:34.647]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.647]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.647]             base::sink(type = "output", split = FALSE)
[17:37:34.647]             base::close(...future.stdout)
[17:37:34.647]         }, add = TRUE)
[17:37:34.647]     }
[17:37:34.647]     ...future.frame <- base::sys.nframe()
[17:37:34.647]     ...future.conditions <- base::list()
[17:37:34.647]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.647]     if (FALSE) {
[17:37:34.647]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.647]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.647]     }
[17:37:34.647]     ...future.result <- base::tryCatch({
[17:37:34.647]         base::withCallingHandlers({
[17:37:34.647]             ...future.value <- base::withVisible(base::local({
[17:37:34.647]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.647]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.647]                   ...future.globals.maxSize)) {
[17:37:34.647]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.647]                   on.exit(options(oopts), add = TRUE)
[17:37:34.647]                 }
[17:37:34.647]                 {
[17:37:34.647]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.647]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.647]                     USE.NAMES = FALSE)
[17:37:34.647]                   do.call(mapply, args = args)
[17:37:34.647]                 }
[17:37:34.647]             }))
[17:37:34.647]             future::FutureResult(value = ...future.value$value, 
[17:37:34.647]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.647]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.647]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.647]                     ...future.globalenv.names))
[17:37:34.647]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.647]         }, condition = base::local({
[17:37:34.647]             c <- base::c
[17:37:34.647]             inherits <- base::inherits
[17:37:34.647]             invokeRestart <- base::invokeRestart
[17:37:34.647]             length <- base::length
[17:37:34.647]             list <- base::list
[17:37:34.647]             seq.int <- base::seq.int
[17:37:34.647]             signalCondition <- base::signalCondition
[17:37:34.647]             sys.calls <- base::sys.calls
[17:37:34.647]             `[[` <- base::`[[`
[17:37:34.647]             `+` <- base::`+`
[17:37:34.647]             `<<-` <- base::`<<-`
[17:37:34.647]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.647]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.647]                   3L)]
[17:37:34.647]             }
[17:37:34.647]             function(cond) {
[17:37:34.647]                 is_error <- inherits(cond, "error")
[17:37:34.647]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.647]                   NULL)
[17:37:34.647]                 if (is_error) {
[17:37:34.647]                   sessionInformation <- function() {
[17:37:34.647]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.647]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.647]                       search = base::search(), system = base::Sys.info())
[17:37:34.647]                   }
[17:37:34.647]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.647]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.647]                     cond$call), session = sessionInformation(), 
[17:37:34.647]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.647]                   signalCondition(cond)
[17:37:34.647]                 }
[17:37:34.647]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.647]                 "immediateCondition"))) {
[17:37:34.647]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.647]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.647]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.647]                   if (TRUE && !signal) {
[17:37:34.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.647]                     {
[17:37:34.647]                       inherits <- base::inherits
[17:37:34.647]                       invokeRestart <- base::invokeRestart
[17:37:34.647]                       is.null <- base::is.null
[17:37:34.647]                       muffled <- FALSE
[17:37:34.647]                       if (inherits(cond, "message")) {
[17:37:34.647]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.647]                         if (muffled) 
[17:37:34.647]                           invokeRestart("muffleMessage")
[17:37:34.647]                       }
[17:37:34.647]                       else if (inherits(cond, "warning")) {
[17:37:34.647]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.647]                         if (muffled) 
[17:37:34.647]                           invokeRestart("muffleWarning")
[17:37:34.647]                       }
[17:37:34.647]                       else if (inherits(cond, "condition")) {
[17:37:34.647]                         if (!is.null(pattern)) {
[17:37:34.647]                           computeRestarts <- base::computeRestarts
[17:37:34.647]                           grepl <- base::grepl
[17:37:34.647]                           restarts <- computeRestarts(cond)
[17:37:34.647]                           for (restart in restarts) {
[17:37:34.647]                             name <- restart$name
[17:37:34.647]                             if (is.null(name)) 
[17:37:34.647]                               next
[17:37:34.647]                             if (!grepl(pattern, name)) 
[17:37:34.647]                               next
[17:37:34.647]                             invokeRestart(restart)
[17:37:34.647]                             muffled <- TRUE
[17:37:34.647]                             break
[17:37:34.647]                           }
[17:37:34.647]                         }
[17:37:34.647]                       }
[17:37:34.647]                       invisible(muffled)
[17:37:34.647]                     }
[17:37:34.647]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.647]                   }
[17:37:34.647]                 }
[17:37:34.647]                 else {
[17:37:34.647]                   if (TRUE) {
[17:37:34.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.647]                     {
[17:37:34.647]                       inherits <- base::inherits
[17:37:34.647]                       invokeRestart <- base::invokeRestart
[17:37:34.647]                       is.null <- base::is.null
[17:37:34.647]                       muffled <- FALSE
[17:37:34.647]                       if (inherits(cond, "message")) {
[17:37:34.647]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.647]                         if (muffled) 
[17:37:34.647]                           invokeRestart("muffleMessage")
[17:37:34.647]                       }
[17:37:34.647]                       else if (inherits(cond, "warning")) {
[17:37:34.647]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.647]                         if (muffled) 
[17:37:34.647]                           invokeRestart("muffleWarning")
[17:37:34.647]                       }
[17:37:34.647]                       else if (inherits(cond, "condition")) {
[17:37:34.647]                         if (!is.null(pattern)) {
[17:37:34.647]                           computeRestarts <- base::computeRestarts
[17:37:34.647]                           grepl <- base::grepl
[17:37:34.647]                           restarts <- computeRestarts(cond)
[17:37:34.647]                           for (restart in restarts) {
[17:37:34.647]                             name <- restart$name
[17:37:34.647]                             if (is.null(name)) 
[17:37:34.647]                               next
[17:37:34.647]                             if (!grepl(pattern, name)) 
[17:37:34.647]                               next
[17:37:34.647]                             invokeRestart(restart)
[17:37:34.647]                             muffled <- TRUE
[17:37:34.647]                             break
[17:37:34.647]                           }
[17:37:34.647]                         }
[17:37:34.647]                       }
[17:37:34.647]                       invisible(muffled)
[17:37:34.647]                     }
[17:37:34.647]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.647]                   }
[17:37:34.647]                 }
[17:37:34.647]             }
[17:37:34.647]         }))
[17:37:34.647]     }, error = function(ex) {
[17:37:34.647]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.647]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.647]                 ...future.rng), started = ...future.startTime, 
[17:37:34.647]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.647]             version = "1.8"), class = "FutureResult")
[17:37:34.647]     }, finally = {
[17:37:34.647]         if (!identical(...future.workdir, getwd())) 
[17:37:34.647]             setwd(...future.workdir)
[17:37:34.647]         {
[17:37:34.647]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.647]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.647]             }
[17:37:34.647]             base::options(...future.oldOptions)
[17:37:34.647]             if (.Platform$OS.type == "windows") {
[17:37:34.647]                 old_names <- names(...future.oldEnvVars)
[17:37:34.647]                 envs <- base::Sys.getenv()
[17:37:34.647]                 names <- names(envs)
[17:37:34.647]                 common <- intersect(names, old_names)
[17:37:34.647]                 added <- setdiff(names, old_names)
[17:37:34.647]                 removed <- setdiff(old_names, names)
[17:37:34.647]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.647]                   envs[common]]
[17:37:34.647]                 NAMES <- toupper(changed)
[17:37:34.647]                 args <- list()
[17:37:34.647]                 for (kk in seq_along(NAMES)) {
[17:37:34.647]                   name <- changed[[kk]]
[17:37:34.647]                   NAME <- NAMES[[kk]]
[17:37:34.647]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.647]                     next
[17:37:34.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.647]                 }
[17:37:34.647]                 NAMES <- toupper(added)
[17:37:34.647]                 for (kk in seq_along(NAMES)) {
[17:37:34.647]                   name <- added[[kk]]
[17:37:34.647]                   NAME <- NAMES[[kk]]
[17:37:34.647]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.647]                     next
[17:37:34.647]                   args[[name]] <- ""
[17:37:34.647]                 }
[17:37:34.647]                 NAMES <- toupper(removed)
[17:37:34.647]                 for (kk in seq_along(NAMES)) {
[17:37:34.647]                   name <- removed[[kk]]
[17:37:34.647]                   NAME <- NAMES[[kk]]
[17:37:34.647]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.647]                     next
[17:37:34.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.647]                 }
[17:37:34.647]                 if (length(args) > 0) 
[17:37:34.647]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.647]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.647]             }
[17:37:34.647]             else {
[17:37:34.647]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.647]             }
[17:37:34.647]             {
[17:37:34.647]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.647]                   0L) {
[17:37:34.647]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.647]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.647]                   base::options(opts)
[17:37:34.647]                 }
[17:37:34.647]                 {
[17:37:34.647]                   {
[17:37:34.647]                     base::assign(".Random.seed", c(10407L, 922393460L, 
[17:37:34.647]                     -1763300862L, -790978071L, -1874471625L, 
[17:37:34.647]                     -1277687904L, -753596510L), envir = base::globalenv(), 
[17:37:34.647]                       inherits = FALSE)
[17:37:34.647]                     NULL
[17:37:34.647]                   }
[17:37:34.647]                   options(future.plan = NULL)
[17:37:34.647]                   if (is.na(NA_character_)) 
[17:37:34.647]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.647]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.647]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.647]                     .init = FALSE)
[17:37:34.647]                 }
[17:37:34.647]             }
[17:37:34.647]         }
[17:37:34.647]     })
[17:37:34.647]     if (TRUE) {
[17:37:34.647]         base::sink(type = "output", split = FALSE)
[17:37:34.647]         if (TRUE) {
[17:37:34.647]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.647]         }
[17:37:34.647]         else {
[17:37:34.647]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.647]         }
[17:37:34.647]         base::close(...future.stdout)
[17:37:34.647]         ...future.stdout <- NULL
[17:37:34.647]     }
[17:37:34.647]     ...future.result$conditions <- ...future.conditions
[17:37:34.647]     ...future.result$finished <- base::Sys.time()
[17:37:34.647]     ...future.result
[17:37:34.647] }
[17:37:34.649] assign_globals() ...
[17:37:34.649] List of 5
[17:37:34.649]  $ ...future.FUN            :function (e1, e2)  
[17:37:34.649]  $ MoreArgs                 : NULL
[17:37:34.649]  $ ...future.elements_ii    :List of 2
[17:37:34.649]   ..$ :List of 3
[17:37:34.649]   .. ..$ : num 1
[17:37:34.649]   .. ..$ : num 1
[17:37:34.649]   .. ..$ : num 1
[17:37:34.649]   ..$ :List of 3
[17:37:34.649]   .. ..$ : int 1
[17:37:34.649]   .. ..$ : int 2
[17:37:34.649]   .. ..$ : int 3
[17:37:34.649]  $ ...future.seeds_ii       : NULL
[17:37:34.649]  $ ...future.globals.maxSize: NULL
[17:37:34.649]  - attr(*, "where")=List of 5
[17:37:34.649]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.649]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.649]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.649]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.649]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.649]  - attr(*, "resolved")= logi FALSE
[17:37:34.649]  - attr(*, "total_size")= num 392
[17:37:34.649]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.649]  - attr(*, "already-done")= logi TRUE
[17:37:34.659] - copied ‘...future.FUN’ to environment
[17:37:34.659] - copied ‘MoreArgs’ to environment
[17:37:34.659] - copied ‘...future.elements_ii’ to environment
[17:37:34.659] - copied ‘...future.seeds_ii’ to environment
[17:37:34.660] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.660] assign_globals() ... done
[17:37:34.660] plan(): Setting new future strategy stack:
[17:37:34.660] List of future strategies:
[17:37:34.660] 1. sequential:
[17:37:34.660]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.660]    - tweaked: FALSE
[17:37:34.660]    - call: NULL
[17:37:34.660] plan(): nbrOfWorkers() = 1
[17:37:34.661] plan(): Setting new future strategy stack:
[17:37:34.661] List of future strategies:
[17:37:34.661] 1. sequential:
[17:37:34.661]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.661]    - tweaked: FALSE
[17:37:34.661]    - call: plan(strategy)
[17:37:34.662] plan(): nbrOfWorkers() = 1
[17:37:34.662] SequentialFuture started (and completed)
[17:37:34.662] - Launch lazy future ... done
[17:37:34.662] run() for ‘SequentialFuture’ ... done
[17:37:34.662] Created future:
[17:37:34.662] SequentialFuture:
[17:37:34.662] Label: ‘future_Map-1’
[17:37:34.662] Expression:
[17:37:34.662] {
[17:37:34.662]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.662]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.662]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.662]         on.exit(options(oopts), add = TRUE)
[17:37:34.662]     }
[17:37:34.662]     {
[17:37:34.662]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.662]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.662]         do.call(mapply, args = args)
[17:37:34.662]     }
[17:37:34.662] }
[17:37:34.662] Lazy evaluation: FALSE
[17:37:34.662] Asynchronous evaluation: FALSE
[17:37:34.662] Local evaluation: TRUE
[17:37:34.662] Environment: R_GlobalEnv
[17:37:34.662] Capture standard output: TRUE
[17:37:34.662] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.662] Globals: 5 objects totaling 392 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.662] Packages: <none>
[17:37:34.662] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.662] Resolved: TRUE
[17:37:34.662] Value: 168 bytes of class ‘list’
[17:37:34.662] Early signaling: FALSE
[17:37:34.662] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.662] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.663] Chunk #1 of 1 ... DONE
[17:37:34.663] Launching 1 futures (chunks) ... DONE
[17:37:34.663] Resolving 1 futures (chunks) ...
[17:37:34.664] resolve() on list ...
[17:37:34.664]  recursive: 0
[17:37:34.664]  length: 1
[17:37:34.664] 
[17:37:34.664] resolved() for ‘SequentialFuture’ ...
[17:37:34.664] - state: ‘finished’
[17:37:34.664] - run: TRUE
[17:37:34.664] - result: ‘FutureResult’
[17:37:34.664] resolved() for ‘SequentialFuture’ ... done
[17:37:34.664] Future #1
[17:37:34.665] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:34.665] - nx: 1
[17:37:34.665] - relay: TRUE
[17:37:34.665] - stdout: TRUE
[17:37:34.665] - signal: TRUE
[17:37:34.665] - resignal: FALSE
[17:37:34.665] - force: TRUE
[17:37:34.665] - relayed: [n=1] FALSE
[17:37:34.665] - queued futures: [n=1] FALSE
[17:37:34.665]  - until=1
[17:37:34.665]  - relaying element #1
[17:37:34.666] - relayed: [n=1] TRUE
[17:37:34.666] - queued futures: [n=1] TRUE
[17:37:34.666] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:34.666]  length: 0 (resolved future 1)
[17:37:34.666] Relaying remaining futures
[17:37:34.666] signalConditionsASAP(NULL, pos=0) ...
[17:37:34.666] - nx: 1
[17:37:34.666] - relay: TRUE
[17:37:34.666] - stdout: TRUE
[17:37:34.666] - signal: TRUE
[17:37:34.667] - resignal: FALSE
[17:37:34.667] - force: TRUE
[17:37:34.667] - relayed: [n=1] TRUE
[17:37:34.667] - queued futures: [n=1] TRUE
 - flush all
[17:37:34.667] - relayed: [n=1] TRUE
[17:37:34.667] - queued futures: [n=1] TRUE
[17:37:34.667] signalConditionsASAP(NULL, pos=0) ... done
[17:37:34.667] resolve() on list ... DONE
[17:37:34.667]  - Number of value chunks collected: 1
[17:37:34.667] Resolving 1 futures (chunks) ... DONE
[17:37:34.667] Reducing values from 1 chunks ...
[17:37:34.668]  - Number of values collected after concatenation: 3
[17:37:34.668]  - Number of values expected: 3
[17:37:34.668] Reducing values from 1 chunks ... DONE
[17:37:34.668] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[17:37:34.668] future_mapply() ...
[17:37:34.668] Number of chunks: 1
[17:37:34.669] getGlobalsAndPackagesXApply() ...
[17:37:34.669]  - future.globals: TRUE
[17:37:34.669] getGlobalsAndPackages() ...
[17:37:34.669] Searching for globals...
[17:37:34.670] - globals found: [1] ‘FUN’
[17:37:34.670] Searching for globals ... DONE
[17:37:34.670] Resolving globals: FALSE
[17:37:34.670] The total size of the 1 globals is 848 bytes (848 bytes)
[17:37:34.671] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:37:34.671] - globals: [1] ‘FUN’
[17:37:34.671] 
[17:37:34.671] getGlobalsAndPackages() ... DONE
[17:37:34.671]  - globals found/used: [n=1] ‘FUN’
[17:37:34.671]  - needed namespaces: [n=0] 
[17:37:34.671] Finding globals ... DONE
[17:37:34.671] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:34.672] List of 2
[17:37:34.672]  $ ...future.FUN:function (x)  
[17:37:34.672]  $ MoreArgs     : NULL
[17:37:34.672]  - attr(*, "where")=List of 2
[17:37:34.672]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:34.672]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:34.672]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.672]  - attr(*, "resolved")= logi FALSE
[17:37:34.672]  - attr(*, "total_size")= num NA
[17:37:34.674] Packages to be attached in all futures: [n=0] 
[17:37:34.674] getGlobalsAndPackagesXApply() ... DONE
[17:37:34.674] Number of futures (= number of chunks): 1
[17:37:34.674] Launching 1 futures (chunks) ...
[17:37:34.674] Chunk #1 of 1 ...
[17:37:34.674]  - Finding globals in '...' for chunk #1 ...
[17:37:34.675] getGlobalsAndPackages() ...
[17:37:34.675] Searching for globals...
[17:37:34.675] 
[17:37:34.675] Searching for globals ... DONE
[17:37:34.675] - globals: [0] <none>
[17:37:34.675] getGlobalsAndPackages() ... DONE
[17:37:34.675]    + additional globals found: [n=0] 
[17:37:34.675]    + additional namespaces needed: [n=0] 
[17:37:34.676]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:34.676]  - seeds: <none>
[17:37:34.677]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.677] getGlobalsAndPackages() ...
[17:37:34.677] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.678] Resolving globals: FALSE
[17:37:34.678] The total size of the 5 globals is 960 bytes (960 bytes)
[17:37:34.678] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 960 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:34.679] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.679] 
[17:37:34.679] getGlobalsAndPackages() ... DONE
[17:37:34.679] run() for ‘Future’ ...
[17:37:34.679] - state: ‘created’
[17:37:34.679] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:37:34.680] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.680] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:37:34.680]   - Field: ‘label’
[17:37:34.680]   - Field: ‘local’
[17:37:34.680]   - Field: ‘owner’
[17:37:34.680]   - Field: ‘envir’
[17:37:34.680]   - Field: ‘packages’
[17:37:34.680]   - Field: ‘gc’
[17:37:34.680]   - Field: ‘conditions’
[17:37:34.681]   - Field: ‘expr’
[17:37:34.681]   - Field: ‘uuid’
[17:37:34.681]   - Field: ‘seed’
[17:37:34.681]   - Field: ‘version’
[17:37:34.681]   - Field: ‘result’
[17:37:34.681]   - Field: ‘asynchronous’
[17:37:34.681]   - Field: ‘calls’
[17:37:34.681]   - Field: ‘globals’
[17:37:34.681]   - Field: ‘stdout’
[17:37:34.681]   - Field: ‘earlySignal’
[17:37:34.682]   - Field: ‘lazy’
[17:37:34.682]   - Field: ‘state’
[17:37:34.682] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:37:34.682] - Launch lazy future ...
[17:37:34.682] Packages needed by the future expression (n = 0): <none>
[17:37:34.682] Packages needed by future strategies (n = 0): <none>
[17:37:34.682] {
[17:37:34.682]     {
[17:37:34.682]         {
[17:37:34.682]             ...future.startTime <- base::Sys.time()
[17:37:34.682]             {
[17:37:34.682]                 {
[17:37:34.682]                   {
[17:37:34.682]                     base::local({
[17:37:34.682]                       has_future <- base::requireNamespace("future", 
[17:37:34.682]                         quietly = TRUE)
[17:37:34.682]                       if (has_future) {
[17:37:34.682]                         ns <- base::getNamespace("future")
[17:37:34.682]                         version <- ns[[".package"]][["version"]]
[17:37:34.682]                         if (is.null(version)) 
[17:37:34.682]                           version <- utils::packageVersion("future")
[17:37:34.682]                       }
[17:37:34.682]                       else {
[17:37:34.682]                         version <- NULL
[17:37:34.682]                       }
[17:37:34.682]                       if (!has_future || version < "1.8.0") {
[17:37:34.682]                         info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.682]                           "", base::R.version$version.string), 
[17:37:34.682]                           platform = base::sprintf("%s (%s-bit)", 
[17:37:34.682]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.682]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.682]                             "release", "version")], collapse = " "), 
[17:37:34.682]                           hostname = base::Sys.info()[["nodename"]])
[17:37:34.682]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.682]                           info)
[17:37:34.682]                         info <- base::paste(info, collapse = "; ")
[17:37:34.682]                         if (!has_future) {
[17:37:34.682]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.682]                             info)
[17:37:34.682]                         }
[17:37:34.682]                         else {
[17:37:34.682]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.682]                             info, version)
[17:37:34.682]                         }
[17:37:34.682]                         base::stop(msg)
[17:37:34.682]                       }
[17:37:34.682]                     })
[17:37:34.682]                   }
[17:37:34.682]                   ...future.strategy.old <- future::plan("list")
[17:37:34.682]                   options(future.plan = NULL)
[17:37:34.682]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.682]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.682]                 }
[17:37:34.682]                 ...future.workdir <- getwd()
[17:37:34.682]             }
[17:37:34.682]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.682]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.682]         }
[17:37:34.682]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.682]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:34.682]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.682]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.682]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.682]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.682]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.682]             base::names(...future.oldOptions))
[17:37:34.682]     }
[17:37:34.682]     if (FALSE) {
[17:37:34.682]     }
[17:37:34.682]     else {
[17:37:34.682]         if (TRUE) {
[17:37:34.682]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.682]                 open = "w")
[17:37:34.682]         }
[17:37:34.682]         else {
[17:37:34.682]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.682]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.682]         }
[17:37:34.682]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.682]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.682]             base::sink(type = "output", split = FALSE)
[17:37:34.682]             base::close(...future.stdout)
[17:37:34.682]         }, add = TRUE)
[17:37:34.682]     }
[17:37:34.682]     ...future.frame <- base::sys.nframe()
[17:37:34.682]     ...future.conditions <- base::list()
[17:37:34.682]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.682]     if (FALSE) {
[17:37:34.682]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.682]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.682]     }
[17:37:34.682]     ...future.result <- base::tryCatch({
[17:37:34.682]         base::withCallingHandlers({
[17:37:34.682]             ...future.value <- base::withVisible(base::local({
[17:37:34.682]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.682]                 if (!identical(...future.globals.maxSize.org, 
[17:37:34.682]                   ...future.globals.maxSize)) {
[17:37:34.682]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.682]                   on.exit(options(oopts), add = TRUE)
[17:37:34.682]                 }
[17:37:34.682]                 {
[17:37:34.682]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.682]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.682]                     USE.NAMES = FALSE)
[17:37:34.682]                   do.call(mapply, args = args)
[17:37:34.682]                 }
[17:37:34.682]             }))
[17:37:34.682]             future::FutureResult(value = ...future.value$value, 
[17:37:34.682]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.682]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.682]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.682]                     ...future.globalenv.names))
[17:37:34.682]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.682]         }, condition = base::local({
[17:37:34.682]             c <- base::c
[17:37:34.682]             inherits <- base::inherits
[17:37:34.682]             invokeRestart <- base::invokeRestart
[17:37:34.682]             length <- base::length
[17:37:34.682]             list <- base::list
[17:37:34.682]             seq.int <- base::seq.int
[17:37:34.682]             signalCondition <- base::signalCondition
[17:37:34.682]             sys.calls <- base::sys.calls
[17:37:34.682]             `[[` <- base::`[[`
[17:37:34.682]             `+` <- base::`+`
[17:37:34.682]             `<<-` <- base::`<<-`
[17:37:34.682]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.682]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.682]                   3L)]
[17:37:34.682]             }
[17:37:34.682]             function(cond) {
[17:37:34.682]                 is_error <- inherits(cond, "error")
[17:37:34.682]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.682]                   NULL)
[17:37:34.682]                 if (is_error) {
[17:37:34.682]                   sessionInformation <- function() {
[17:37:34.682]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.682]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.682]                       search = base::search(), system = base::Sys.info())
[17:37:34.682]                   }
[17:37:34.682]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.682]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.682]                     cond$call), session = sessionInformation(), 
[17:37:34.682]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.682]                   signalCondition(cond)
[17:37:34.682]                 }
[17:37:34.682]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.682]                 "immediateCondition"))) {
[17:37:34.682]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.682]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.682]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.682]                   if (TRUE && !signal) {
[17:37:34.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.682]                     {
[17:37:34.682]                       inherits <- base::inherits
[17:37:34.682]                       invokeRestart <- base::invokeRestart
[17:37:34.682]                       is.null <- base::is.null
[17:37:34.682]                       muffled <- FALSE
[17:37:34.682]                       if (inherits(cond, "message")) {
[17:37:34.682]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.682]                         if (muffled) 
[17:37:34.682]                           invokeRestart("muffleMessage")
[17:37:34.682]                       }
[17:37:34.682]                       else if (inherits(cond, "warning")) {
[17:37:34.682]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.682]                         if (muffled) 
[17:37:34.682]                           invokeRestart("muffleWarning")
[17:37:34.682]                       }
[17:37:34.682]                       else if (inherits(cond, "condition")) {
[17:37:34.682]                         if (!is.null(pattern)) {
[17:37:34.682]                           computeRestarts <- base::computeRestarts
[17:37:34.682]                           grepl <- base::grepl
[17:37:34.682]                           restarts <- computeRestarts(cond)
[17:37:34.682]                           for (restart in restarts) {
[17:37:34.682]                             name <- restart$name
[17:37:34.682]                             if (is.null(name)) 
[17:37:34.682]                               next
[17:37:34.682]                             if (!grepl(pattern, name)) 
[17:37:34.682]                               next
[17:37:34.682]                             invokeRestart(restart)
[17:37:34.682]                             muffled <- TRUE
[17:37:34.682]                             break
[17:37:34.682]                           }
[17:37:34.682]                         }
[17:37:34.682]                       }
[17:37:34.682]                       invisible(muffled)
[17:37:34.682]                     }
[17:37:34.682]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.682]                   }
[17:37:34.682]                 }
[17:37:34.682]                 else {
[17:37:34.682]                   if (TRUE) {
[17:37:34.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.682]                     {
[17:37:34.682]                       inherits <- base::inherits
[17:37:34.682]                       invokeRestart <- base::invokeRestart
[17:37:34.682]                       is.null <- base::is.null
[17:37:34.682]                       muffled <- FALSE
[17:37:34.682]                       if (inherits(cond, "message")) {
[17:37:34.682]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.682]                         if (muffled) 
[17:37:34.682]                           invokeRestart("muffleMessage")
[17:37:34.682]                       }
[17:37:34.682]                       else if (inherits(cond, "warning")) {
[17:37:34.682]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.682]                         if (muffled) 
[17:37:34.682]                           invokeRestart("muffleWarning")
[17:37:34.682]                       }
[17:37:34.682]                       else if (inherits(cond, "condition")) {
[17:37:34.682]                         if (!is.null(pattern)) {
[17:37:34.682]                           computeRestarts <- base::computeRestarts
[17:37:34.682]                           grepl <- base::grepl
[17:37:34.682]                           restarts <- computeRestarts(cond)
[17:37:34.682]                           for (restart in restarts) {
[17:37:34.682]                             name <- restart$name
[17:37:34.682]                             if (is.null(name)) 
[17:37:34.682]                               next
[17:37:34.682]                             if (!grepl(pattern, name)) 
[17:37:34.682]                               next
[17:37:34.682]                             invokeRestart(restart)
[17:37:34.682]                             muffled <- TRUE
[17:37:34.682]                             break
[17:37:34.682]                           }
[17:37:34.682]                         }
[17:37:34.682]                       }
[17:37:34.682]                       invisible(muffled)
[17:37:34.682]                     }
[17:37:34.682]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.682]                   }
[17:37:34.682]                 }
[17:37:34.682]             }
[17:37:34.682]         }))
[17:37:34.682]     }, error = function(ex) {
[17:37:34.682]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.682]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.682]                 ...future.rng), started = ...future.startTime, 
[17:37:34.682]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.682]             version = "1.8"), class = "FutureResult")
[17:37:34.682]     }, finally = {
[17:37:34.682]         if (!identical(...future.workdir, getwd())) 
[17:37:34.682]             setwd(...future.workdir)
[17:37:34.682]         {
[17:37:34.682]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.682]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.682]             }
[17:37:34.682]             base::options(...future.oldOptions)
[17:37:34.682]             if (.Platform$OS.type == "windows") {
[17:37:34.682]                 old_names <- names(...future.oldEnvVars)
[17:37:34.682]                 envs <- base::Sys.getenv()
[17:37:34.682]                 names <- names(envs)
[17:37:34.682]                 common <- intersect(names, old_names)
[17:37:34.682]                 added <- setdiff(names, old_names)
[17:37:34.682]                 removed <- setdiff(old_names, names)
[17:37:34.682]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.682]                   envs[common]]
[17:37:34.682]                 NAMES <- toupper(changed)
[17:37:34.682]                 args <- list()
[17:37:34.682]                 for (kk in seq_along(NAMES)) {
[17:37:34.682]                   name <- changed[[kk]]
[17:37:34.682]                   NAME <- NAMES[[kk]]
[17:37:34.682]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.682]                     next
[17:37:34.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.682]                 }
[17:37:34.682]                 NAMES <- toupper(added)
[17:37:34.682]                 for (kk in seq_along(NAMES)) {
[17:37:34.682]                   name <- added[[kk]]
[17:37:34.682]                   NAME <- NAMES[[kk]]
[17:37:34.682]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.682]                     next
[17:37:34.682]                   args[[name]] <- ""
[17:37:34.682]                 }
[17:37:34.682]                 NAMES <- toupper(removed)
[17:37:34.682]                 for (kk in seq_along(NAMES)) {
[17:37:34.682]                   name <- removed[[kk]]
[17:37:34.682]                   NAME <- NAMES[[kk]]
[17:37:34.682]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.682]                     next
[17:37:34.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.682]                 }
[17:37:34.682]                 if (length(args) > 0) 
[17:37:34.682]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.682]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.682]             }
[17:37:34.682]             else {
[17:37:34.682]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.682]             }
[17:37:34.682]             {
[17:37:34.682]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.682]                   0L) {
[17:37:34.682]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.682]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.682]                   base::options(opts)
[17:37:34.682]                 }
[17:37:34.682]                 {
[17:37:34.682]                   {
[17:37:34.682]                     base::assign(".Random.seed", c(10407L, 922393460L, 
[17:37:34.682]                     -1763300862L, -790978071L, -1874471625L, 
[17:37:34.682]                     -1277687904L, -753596510L), envir = base::globalenv(), 
[17:37:34.682]                       inherits = FALSE)
[17:37:34.682]                     NULL
[17:37:34.682]                   }
[17:37:34.682]                   options(future.plan = NULL)
[17:37:34.682]                   if (is.na(NA_character_)) 
[17:37:34.682]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.682]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.682]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.682]                     .init = FALSE)
[17:37:34.682]                 }
[17:37:34.682]             }
[17:37:34.682]         }
[17:37:34.682]     })
[17:37:34.682]     if (TRUE) {
[17:37:34.682]         base::sink(type = "output", split = FALSE)
[17:37:34.682]         if (TRUE) {
[17:37:34.682]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.682]         }
[17:37:34.682]         else {
[17:37:34.682]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.682]         }
[17:37:34.682]         base::close(...future.stdout)
[17:37:34.682]         ...future.stdout <- NULL
[17:37:34.682]     }
[17:37:34.682]     ...future.result$conditions <- ...future.conditions
[17:37:34.682]     ...future.result$finished <- base::Sys.time()
[17:37:34.682]     ...future.result
[17:37:34.682] }
[17:37:34.684] assign_globals() ...
[17:37:34.684] List of 5
[17:37:34.684]  $ ...future.FUN            :function (x)  
[17:37:34.684]  $ MoreArgs                 : NULL
[17:37:34.684]  $ ...future.elements_ii    :List of 1
[17:37:34.684]   ..$ :List of 2
[17:37:34.684]   .. ..$ a: num 0
[17:37:34.684]   .. ..$ b: num 0
[17:37:34.684]  $ ...future.seeds_ii       : NULL
[17:37:34.684]  $ ...future.globals.maxSize: NULL
[17:37:34.684]  - attr(*, "where")=List of 5
[17:37:34.684]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.684]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.684]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.684]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.684]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.684]  - attr(*, "resolved")= logi FALSE
[17:37:34.684]  - attr(*, "total_size")= num 960
[17:37:34.684]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.684]  - attr(*, "already-done")= logi TRUE
[17:37:34.689] - copied ‘...future.FUN’ to environment
[17:37:34.689] - copied ‘MoreArgs’ to environment
[17:37:34.689] - copied ‘...future.elements_ii’ to environment
[17:37:34.689] - copied ‘...future.seeds_ii’ to environment
[17:37:34.689] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.689] assign_globals() ... done
[17:37:34.690] plan(): Setting new future strategy stack:
[17:37:34.690] List of future strategies:
[17:37:34.690] 1. sequential:
[17:37:34.690]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.690]    - tweaked: FALSE
[17:37:34.690]    - call: NULL
[17:37:34.690] plan(): nbrOfWorkers() = 1
[17:37:34.691] plan(): Setting new future strategy stack:
[17:37:34.691] List of future strategies:
[17:37:34.691] 1. sequential:
[17:37:34.691]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.691]    - tweaked: FALSE
[17:37:34.691]    - call: plan(strategy)
[17:37:34.691] plan(): nbrOfWorkers() = 1
[17:37:34.692] SequentialFuture started (and completed)
[17:37:34.692] - Launch lazy future ... done
[17:37:34.692] run() for ‘SequentialFuture’ ... done
[17:37:34.692] Created future:
[17:37:34.692] SequentialFuture:
[17:37:34.692] Label: ‘future_mapply-1’
[17:37:34.692] Expression:
[17:37:34.692] {
[17:37:34.692]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.692]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.692]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.692]         on.exit(options(oopts), add = TRUE)
[17:37:34.692]     }
[17:37:34.692]     {
[17:37:34.692]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.692]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.692]         do.call(mapply, args = args)
[17:37:34.692]     }
[17:37:34.692] }
[17:37:34.692] Lazy evaluation: FALSE
[17:37:34.692] Asynchronous evaluation: FALSE
[17:37:34.692] Local evaluation: TRUE
[17:37:34.692] Environment: R_GlobalEnv
[17:37:34.692] Capture standard output: TRUE
[17:37:34.692] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.692] Globals: 5 objects totaling 960 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.692] Packages: <none>
[17:37:34.692] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.692] Resolved: TRUE
[17:37:34.692] Value: 112 bytes of class ‘list’
[17:37:34.692] Early signaling: FALSE
[17:37:34.692] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.692] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:37:34.693] Chunk #1 of 1 ... DONE
[17:37:34.693] Launching 1 futures (chunks) ... DONE
[17:37:34.693] Resolving 1 futures (chunks) ...
[17:37:34.693] resolve() on list ...
[17:37:34.693]  recursive: 0
[17:37:34.693]  length: 1
[17:37:34.693] 
[17:37:34.693] resolved() for ‘SequentialFuture’ ...
[17:37:34.694] - state: ‘finished’
[17:37:34.694] - run: TRUE
[17:37:34.694] - result: ‘FutureResult’
[17:37:34.694] resolved() for ‘SequentialFuture’ ... done
[17:37:34.694] Future #1
[17:37:34.694] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:37:34.694] - nx: 1
[17:37:34.694] - relay: TRUE
[17:37:34.694] - stdout: TRUE
[17:37:34.694] - signal: TRUE
[17:37:34.695] - resignal: FALSE
[17:37:34.695] - force: TRUE
[17:37:34.695] - relayed: [n=1] FALSE
[17:37:34.695] - queued futures: [n=1] FALSE
[17:37:34.695]  - until=1
[17:37:34.695]  - relaying element #1
[17:37:34.695] - relayed: [n=1] TRUE
[17:37:34.695] - queued futures: [n=1] TRUE
[17:37:34.695] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:37:34.695]  length: 0 (resolved future 1)
[17:37:34.696] Relaying remaining futures
[17:37:34.696] signalConditionsASAP(NULL, pos=0) ...
[17:37:34.696] - nx: 1
[17:37:34.696] - relay: TRUE
[17:37:34.696] - stdout: TRUE
[17:37:34.696] - signal: TRUE
[17:37:34.696] - resignal: FALSE
[17:37:34.696] - force: TRUE
[17:37:34.696] - relayed: [n=1] TRUE
[17:37:34.696] - queued futures: [n=1] TRUE
 - flush all
[17:37:34.696] - relayed: [n=1] TRUE
[17:37:34.697] - queued futures: [n=1] TRUE
[17:37:34.697] signalConditionsASAP(NULL, pos=0) ... done
[17:37:34.697] resolve() on list ... DONE
[17:37:34.697]  - Number of value chunks collected: 1
[17:37:34.697] Resolving 1 futures (chunks) ... DONE
[17:37:34.697] Reducing values from 1 chunks ...
[17:37:34.697]  - Number of values collected after concatenation: 2
[17:37:34.697]  - Number of values expected: 2
[17:37:34.697] Reducing values from 1 chunks ... DONE
[17:37:34.697] future_mapply() ... DONE
[17:37:34.698] plan(): Setting new future strategy stack:
[17:37:34.698] List of future strategies:
[17:37:34.698] 1. sequential:
[17:37:34.698]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.698]    - tweaked: FALSE
[17:37:34.698]    - call: plan(sequential)
[17:37:34.698] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[17:37:34.699] plan(): Setting new future strategy stack:
[17:37:34.699] List of future strategies:
[17:37:34.699] 1. multicore:
[17:37:34.699]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:34.699]    - tweaked: FALSE
[17:37:34.699]    - call: plan(strategy)
[17:37:34.703] plan(): nbrOfWorkers() = 2
- From example(mapply) ...
[17:37:34.703] future_mapply() ...
[17:37:34.708] Number of chunks: 2
[17:37:34.708] getGlobalsAndPackagesXApply() ...
[17:37:34.708]  - future.globals: TRUE
[17:37:34.708] getGlobalsAndPackages() ...
[17:37:34.708] Searching for globals...
[17:37:34.709] - globals found: [1] ‘FUN’
[17:37:34.709] Searching for globals ... DONE
[17:37:34.709] Resolving globals: FALSE
[17:37:34.710] The total size of the 1 globals is 56 bytes (56 bytes)
[17:37:34.710] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:37:34.710] - globals: [1] ‘FUN’
[17:37:34.710] 
[17:37:34.710] getGlobalsAndPackages() ... DONE
[17:37:34.710]  - globals found/used: [n=1] ‘FUN’
[17:37:34.711]  - needed namespaces: [n=0] 
[17:37:34.711] Finding globals ... DONE
[17:37:34.711] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:34.711] List of 2
[17:37:34.711]  $ ...future.FUN:function (x, ...)  
[17:37:34.711]  $ MoreArgs     : NULL
[17:37:34.711]  - attr(*, "where")=List of 2
[17:37:34.711]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:34.711]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:34.711]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.711]  - attr(*, "resolved")= logi FALSE
[17:37:34.711]  - attr(*, "total_size")= num NA
[17:37:34.714] Packages to be attached in all futures: [n=0] 
[17:37:34.714] getGlobalsAndPackagesXApply() ... DONE
[17:37:34.714] Number of futures (= number of chunks): 2
[17:37:34.714] Launching 2 futures (chunks) ...
[17:37:34.714] Chunk #1 of 2 ...
[17:37:34.714]  - Finding globals in '...' for chunk #1 ...
[17:37:34.714] getGlobalsAndPackages() ...
[17:37:34.714] Searching for globals...
[17:37:34.715] 
[17:37:34.715] Searching for globals ... DONE
[17:37:34.715] - globals: [0] <none>
[17:37:34.715] getGlobalsAndPackages() ... DONE
[17:37:34.715]    + additional globals found: [n=0] 
[17:37:34.715]    + additional namespaces needed: [n=0] 
[17:37:34.715]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:34.715]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:34.715]  - seeds: <none>
[17:37:34.715]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.716] getGlobalsAndPackages() ...
[17:37:34.716] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.716] Resolving globals: FALSE
[17:37:34.716] The total size of the 5 globals is 280 bytes (280 bytes)
[17:37:34.717] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:34.717] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.717] 
[17:37:34.717] getGlobalsAndPackages() ... DONE
[17:37:34.717] run() for ‘Future’ ...
[17:37:34.717] - state: ‘created’
[17:37:34.718] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:34.721] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:34.721] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:34.721]   - Field: ‘label’
[17:37:34.722]   - Field: ‘local’
[17:37:34.722]   - Field: ‘owner’
[17:37:34.722]   - Field: ‘envir’
[17:37:34.722]   - Field: ‘workers’
[17:37:34.722]   - Field: ‘packages’
[17:37:34.722]   - Field: ‘gc’
[17:37:34.722]   - Field: ‘job’
[17:37:34.722]   - Field: ‘conditions’
[17:37:34.722]   - Field: ‘expr’
[17:37:34.722]   - Field: ‘uuid’
[17:37:34.722]   - Field: ‘seed’
[17:37:34.723]   - Field: ‘version’
[17:37:34.723]   - Field: ‘result’
[17:37:34.723]   - Field: ‘asynchronous’
[17:37:34.723]   - Field: ‘calls’
[17:37:34.723]   - Field: ‘globals’
[17:37:34.723]   - Field: ‘stdout’
[17:37:34.723]   - Field: ‘earlySignal’
[17:37:34.723]   - Field: ‘lazy’
[17:37:34.723]   - Field: ‘state’
[17:37:34.723] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:34.723] - Launch lazy future ...
[17:37:34.725] Packages needed by the future expression (n = 0): <none>
[17:37:34.725] Packages needed by future strategies (n = 0): <none>
[17:37:34.725] {
[17:37:34.725]     {
[17:37:34.725]         {
[17:37:34.725]             ...future.startTime <- base::Sys.time()
[17:37:34.725]             {
[17:37:34.725]                 {
[17:37:34.725]                   {
[17:37:34.725]                     {
[17:37:34.725]                       base::local({
[17:37:34.725]                         has_future <- base::requireNamespace("future", 
[17:37:34.725]                           quietly = TRUE)
[17:37:34.725]                         if (has_future) {
[17:37:34.725]                           ns <- base::getNamespace("future")
[17:37:34.725]                           version <- ns[[".package"]][["version"]]
[17:37:34.725]                           if (is.null(version)) 
[17:37:34.725]                             version <- utils::packageVersion("future")
[17:37:34.725]                         }
[17:37:34.725]                         else {
[17:37:34.725]                           version <- NULL
[17:37:34.725]                         }
[17:37:34.725]                         if (!has_future || version < "1.8.0") {
[17:37:34.725]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.725]                             "", base::R.version$version.string), 
[17:37:34.725]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:34.725]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.725]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.725]                               "release", "version")], collapse = " "), 
[17:37:34.725]                             hostname = base::Sys.info()[["nodename"]])
[17:37:34.725]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.725]                             info)
[17:37:34.725]                           info <- base::paste(info, collapse = "; ")
[17:37:34.725]                           if (!has_future) {
[17:37:34.725]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.725]                               info)
[17:37:34.725]                           }
[17:37:34.725]                           else {
[17:37:34.725]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.725]                               info, version)
[17:37:34.725]                           }
[17:37:34.725]                           base::stop(msg)
[17:37:34.725]                         }
[17:37:34.725]                       })
[17:37:34.725]                     }
[17:37:34.725]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:34.725]                     base::options(mc.cores = 1L)
[17:37:34.725]                   }
[17:37:34.725]                   ...future.strategy.old <- future::plan("list")
[17:37:34.725]                   options(future.plan = NULL)
[17:37:34.725]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.725]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.725]                 }
[17:37:34.725]                 ...future.workdir <- getwd()
[17:37:34.725]             }
[17:37:34.725]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.725]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.725]         }
[17:37:34.725]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.725]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:34.725]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.725]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.725]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.725]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.725]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.725]             base::names(...future.oldOptions))
[17:37:34.725]     }
[17:37:34.725]     if (FALSE) {
[17:37:34.725]     }
[17:37:34.725]     else {
[17:37:34.725]         if (TRUE) {
[17:37:34.725]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.725]                 open = "w")
[17:37:34.725]         }
[17:37:34.725]         else {
[17:37:34.725]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.725]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.725]         }
[17:37:34.725]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.725]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.725]             base::sink(type = "output", split = FALSE)
[17:37:34.725]             base::close(...future.stdout)
[17:37:34.725]         }, add = TRUE)
[17:37:34.725]     }
[17:37:34.725]     ...future.frame <- base::sys.nframe()
[17:37:34.725]     ...future.conditions <- base::list()
[17:37:34.725]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.725]     if (FALSE) {
[17:37:34.725]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.725]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.725]     }
[17:37:34.725]     ...future.result <- base::tryCatch({
[17:37:34.725]         base::withCallingHandlers({
[17:37:34.725]             ...future.value <- base::withVisible(base::local({
[17:37:34.725]                 withCallingHandlers({
[17:37:34.725]                   {
[17:37:34.725]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.725]                     if (!identical(...future.globals.maxSize.org, 
[17:37:34.725]                       ...future.globals.maxSize)) {
[17:37:34.725]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.725]                       on.exit(options(oopts), add = TRUE)
[17:37:34.725]                     }
[17:37:34.725]                     {
[17:37:34.725]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.725]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.725]                         USE.NAMES = FALSE)
[17:37:34.725]                       do.call(mapply, args = args)
[17:37:34.725]                     }
[17:37:34.725]                   }
[17:37:34.725]                 }, immediateCondition = function(cond) {
[17:37:34.725]                   save_rds <- function (object, pathname, ...) 
[17:37:34.725]                   {
[17:37:34.725]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:34.725]                     if (file_test("-f", pathname_tmp)) {
[17:37:34.725]                       fi_tmp <- file.info(pathname_tmp)
[17:37:34.725]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:34.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:34.725]                         fi_tmp[["mtime"]])
[17:37:34.725]                     }
[17:37:34.725]                     tryCatch({
[17:37:34.725]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:34.725]                     }, error = function(ex) {
[17:37:34.725]                       msg <- conditionMessage(ex)
[17:37:34.725]                       fi_tmp <- file.info(pathname_tmp)
[17:37:34.725]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:34.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:34.725]                         fi_tmp[["mtime"]], msg)
[17:37:34.725]                       ex$message <- msg
[17:37:34.725]                       stop(ex)
[17:37:34.725]                     })
[17:37:34.725]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:34.725]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:34.725]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:34.725]                       fi_tmp <- file.info(pathname_tmp)
[17:37:34.725]                       fi <- file.info(pathname)
[17:37:34.725]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:34.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:34.725]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:34.725]                         fi[["size"]], fi[["mtime"]])
[17:37:34.725]                       stop(msg)
[17:37:34.725]                     }
[17:37:34.725]                     invisible(pathname)
[17:37:34.725]                   }
[17:37:34.725]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:34.725]                     rootPath = tempdir()) 
[17:37:34.725]                   {
[17:37:34.725]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:34.725]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:34.725]                       tmpdir = path, fileext = ".rds")
[17:37:34.725]                     save_rds(obj, file)
[17:37:34.725]                   }
[17:37:34.725]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:34.725]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.725]                   {
[17:37:34.725]                     inherits <- base::inherits
[17:37:34.725]                     invokeRestart <- base::invokeRestart
[17:37:34.725]                     is.null <- base::is.null
[17:37:34.725]                     muffled <- FALSE
[17:37:34.725]                     if (inherits(cond, "message")) {
[17:37:34.725]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:34.725]                       if (muffled) 
[17:37:34.725]                         invokeRestart("muffleMessage")
[17:37:34.725]                     }
[17:37:34.725]                     else if (inherits(cond, "warning")) {
[17:37:34.725]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:34.725]                       if (muffled) 
[17:37:34.725]                         invokeRestart("muffleWarning")
[17:37:34.725]                     }
[17:37:34.725]                     else if (inherits(cond, "condition")) {
[17:37:34.725]                       if (!is.null(pattern)) {
[17:37:34.725]                         computeRestarts <- base::computeRestarts
[17:37:34.725]                         grepl <- base::grepl
[17:37:34.725]                         restarts <- computeRestarts(cond)
[17:37:34.725]                         for (restart in restarts) {
[17:37:34.725]                           name <- restart$name
[17:37:34.725]                           if (is.null(name)) 
[17:37:34.725]                             next
[17:37:34.725]                           if (!grepl(pattern, name)) 
[17:37:34.725]                             next
[17:37:34.725]                           invokeRestart(restart)
[17:37:34.725]                           muffled <- TRUE
[17:37:34.725]                           break
[17:37:34.725]                         }
[17:37:34.725]                       }
[17:37:34.725]                     }
[17:37:34.725]                     invisible(muffled)
[17:37:34.725]                   }
[17:37:34.725]                   muffleCondition(cond)
[17:37:34.725]                 })
[17:37:34.725]             }))
[17:37:34.725]             future::FutureResult(value = ...future.value$value, 
[17:37:34.725]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.725]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.725]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.725]                     ...future.globalenv.names))
[17:37:34.725]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.725]         }, condition = base::local({
[17:37:34.725]             c <- base::c
[17:37:34.725]             inherits <- base::inherits
[17:37:34.725]             invokeRestart <- base::invokeRestart
[17:37:34.725]             length <- base::length
[17:37:34.725]             list <- base::list
[17:37:34.725]             seq.int <- base::seq.int
[17:37:34.725]             signalCondition <- base::signalCondition
[17:37:34.725]             sys.calls <- base::sys.calls
[17:37:34.725]             `[[` <- base::`[[`
[17:37:34.725]             `+` <- base::`+`
[17:37:34.725]             `<<-` <- base::`<<-`
[17:37:34.725]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.725]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.725]                   3L)]
[17:37:34.725]             }
[17:37:34.725]             function(cond) {
[17:37:34.725]                 is_error <- inherits(cond, "error")
[17:37:34.725]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.725]                   NULL)
[17:37:34.725]                 if (is_error) {
[17:37:34.725]                   sessionInformation <- function() {
[17:37:34.725]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.725]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.725]                       search = base::search(), system = base::Sys.info())
[17:37:34.725]                   }
[17:37:34.725]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.725]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.725]                     cond$call), session = sessionInformation(), 
[17:37:34.725]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.725]                   signalCondition(cond)
[17:37:34.725]                 }
[17:37:34.725]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.725]                 "immediateCondition"))) {
[17:37:34.725]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.725]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.725]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.725]                   if (TRUE && !signal) {
[17:37:34.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.725]                     {
[17:37:34.725]                       inherits <- base::inherits
[17:37:34.725]                       invokeRestart <- base::invokeRestart
[17:37:34.725]                       is.null <- base::is.null
[17:37:34.725]                       muffled <- FALSE
[17:37:34.725]                       if (inherits(cond, "message")) {
[17:37:34.725]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.725]                         if (muffled) 
[17:37:34.725]                           invokeRestart("muffleMessage")
[17:37:34.725]                       }
[17:37:34.725]                       else if (inherits(cond, "warning")) {
[17:37:34.725]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.725]                         if (muffled) 
[17:37:34.725]                           invokeRestart("muffleWarning")
[17:37:34.725]                       }
[17:37:34.725]                       else if (inherits(cond, "condition")) {
[17:37:34.725]                         if (!is.null(pattern)) {
[17:37:34.725]                           computeRestarts <- base::computeRestarts
[17:37:34.725]                           grepl <- base::grepl
[17:37:34.725]                           restarts <- computeRestarts(cond)
[17:37:34.725]                           for (restart in restarts) {
[17:37:34.725]                             name <- restart$name
[17:37:34.725]                             if (is.null(name)) 
[17:37:34.725]                               next
[17:37:34.725]                             if (!grepl(pattern, name)) 
[17:37:34.725]                               next
[17:37:34.725]                             invokeRestart(restart)
[17:37:34.725]                             muffled <- TRUE
[17:37:34.725]                             break
[17:37:34.725]                           }
[17:37:34.725]                         }
[17:37:34.725]                       }
[17:37:34.725]                       invisible(muffled)
[17:37:34.725]                     }
[17:37:34.725]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.725]                   }
[17:37:34.725]                 }
[17:37:34.725]                 else {
[17:37:34.725]                   if (TRUE) {
[17:37:34.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.725]                     {
[17:37:34.725]                       inherits <- base::inherits
[17:37:34.725]                       invokeRestart <- base::invokeRestart
[17:37:34.725]                       is.null <- base::is.null
[17:37:34.725]                       muffled <- FALSE
[17:37:34.725]                       if (inherits(cond, "message")) {
[17:37:34.725]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.725]                         if (muffled) 
[17:37:34.725]                           invokeRestart("muffleMessage")
[17:37:34.725]                       }
[17:37:34.725]                       else if (inherits(cond, "warning")) {
[17:37:34.725]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.725]                         if (muffled) 
[17:37:34.725]                           invokeRestart("muffleWarning")
[17:37:34.725]                       }
[17:37:34.725]                       else if (inherits(cond, "condition")) {
[17:37:34.725]                         if (!is.null(pattern)) {
[17:37:34.725]                           computeRestarts <- base::computeRestarts
[17:37:34.725]                           grepl <- base::grepl
[17:37:34.725]                           restarts <- computeRestarts(cond)
[17:37:34.725]                           for (restart in restarts) {
[17:37:34.725]                             name <- restart$name
[17:37:34.725]                             if (is.null(name)) 
[17:37:34.725]                               next
[17:37:34.725]                             if (!grepl(pattern, name)) 
[17:37:34.725]                               next
[17:37:34.725]                             invokeRestart(restart)
[17:37:34.725]                             muffled <- TRUE
[17:37:34.725]                             break
[17:37:34.725]                           }
[17:37:34.725]                         }
[17:37:34.725]                       }
[17:37:34.725]                       invisible(muffled)
[17:37:34.725]                     }
[17:37:34.725]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.725]                   }
[17:37:34.725]                 }
[17:37:34.725]             }
[17:37:34.725]         }))
[17:37:34.725]     }, error = function(ex) {
[17:37:34.725]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.725]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.725]                 ...future.rng), started = ...future.startTime, 
[17:37:34.725]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.725]             version = "1.8"), class = "FutureResult")
[17:37:34.725]     }, finally = {
[17:37:34.725]         if (!identical(...future.workdir, getwd())) 
[17:37:34.725]             setwd(...future.workdir)
[17:37:34.725]         {
[17:37:34.725]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.725]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.725]             }
[17:37:34.725]             base::options(...future.oldOptions)
[17:37:34.725]             if (.Platform$OS.type == "windows") {
[17:37:34.725]                 old_names <- names(...future.oldEnvVars)
[17:37:34.725]                 envs <- base::Sys.getenv()
[17:37:34.725]                 names <- names(envs)
[17:37:34.725]                 common <- intersect(names, old_names)
[17:37:34.725]                 added <- setdiff(names, old_names)
[17:37:34.725]                 removed <- setdiff(old_names, names)
[17:37:34.725]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.725]                   envs[common]]
[17:37:34.725]                 NAMES <- toupper(changed)
[17:37:34.725]                 args <- list()
[17:37:34.725]                 for (kk in seq_along(NAMES)) {
[17:37:34.725]                   name <- changed[[kk]]
[17:37:34.725]                   NAME <- NAMES[[kk]]
[17:37:34.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.725]                     next
[17:37:34.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.725]                 }
[17:37:34.725]                 NAMES <- toupper(added)
[17:37:34.725]                 for (kk in seq_along(NAMES)) {
[17:37:34.725]                   name <- added[[kk]]
[17:37:34.725]                   NAME <- NAMES[[kk]]
[17:37:34.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.725]                     next
[17:37:34.725]                   args[[name]] <- ""
[17:37:34.725]                 }
[17:37:34.725]                 NAMES <- toupper(removed)
[17:37:34.725]                 for (kk in seq_along(NAMES)) {
[17:37:34.725]                   name <- removed[[kk]]
[17:37:34.725]                   NAME <- NAMES[[kk]]
[17:37:34.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.725]                     next
[17:37:34.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.725]                 }
[17:37:34.725]                 if (length(args) > 0) 
[17:37:34.725]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.725]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.725]             }
[17:37:34.725]             else {
[17:37:34.725]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.725]             }
[17:37:34.725]             {
[17:37:34.725]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.725]                   0L) {
[17:37:34.725]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.725]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.725]                   base::options(opts)
[17:37:34.725]                 }
[17:37:34.725]                 {
[17:37:34.725]                   {
[17:37:34.725]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:34.725]                     NULL
[17:37:34.725]                   }
[17:37:34.725]                   options(future.plan = NULL)
[17:37:34.725]                   if (is.na(NA_character_)) 
[17:37:34.725]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.725]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.725]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.725]                     .init = FALSE)
[17:37:34.725]                 }
[17:37:34.725]             }
[17:37:34.725]         }
[17:37:34.725]     })
[17:37:34.725]     if (TRUE) {
[17:37:34.725]         base::sink(type = "output", split = FALSE)
[17:37:34.725]         if (TRUE) {
[17:37:34.725]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.725]         }
[17:37:34.725]         else {
[17:37:34.725]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.725]         }
[17:37:34.725]         base::close(...future.stdout)
[17:37:34.725]         ...future.stdout <- NULL
[17:37:34.725]     }
[17:37:34.725]     ...future.result$conditions <- ...future.conditions
[17:37:34.725]     ...future.result$finished <- base::Sys.time()
[17:37:34.725]     ...future.result
[17:37:34.725] }
[17:37:34.727] assign_globals() ...
[17:37:34.727] List of 5
[17:37:34.727]  $ ...future.FUN            :function (x, ...)  
[17:37:34.727]  $ MoreArgs                 : NULL
[17:37:34.727]  $ ...future.elements_ii    :List of 2
[17:37:34.727]   ..$ :List of 2
[17:37:34.727]   .. ..$ : int 1
[17:37:34.727]   .. ..$ : int 2
[17:37:34.727]   ..$ :List of 2
[17:37:34.727]   .. ..$ : int 4
[17:37:34.727]   .. ..$ : int 3
[17:37:34.727]  $ ...future.seeds_ii       : NULL
[17:37:34.727]  $ ...future.globals.maxSize: NULL
[17:37:34.727]  - attr(*, "where")=List of 5
[17:37:34.727]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.727]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.727]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.727]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.727]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.727]  - attr(*, "resolved")= logi FALSE
[17:37:34.727]  - attr(*, "total_size")= num 280
[17:37:34.727]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.727]  - attr(*, "already-done")= logi TRUE
[17:37:34.733] - copied ‘...future.FUN’ to environment
[17:37:34.733] - copied ‘MoreArgs’ to environment
[17:37:34.733] - copied ‘...future.elements_ii’ to environment
[17:37:34.733] - copied ‘...future.seeds_ii’ to environment
[17:37:34.734] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.734] assign_globals() ... done
[17:37:34.734] requestCore(): workers = 2
[17:37:34.737] MulticoreFuture started
[17:37:34.737] - Launch lazy future ... done
[17:37:34.738] plan(): Setting new future strategy stack:
[17:37:34.738] run() for ‘MulticoreFuture’ ... done
[17:37:34.738] Created future:
[17:37:34.738] List of future strategies:
[17:37:34.738] 1. sequential:
[17:37:34.738]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.738]    - tweaked: FALSE
[17:37:34.738]    - call: NULL
[17:37:34.739] plan(): nbrOfWorkers() = 1
[17:37:34.746] plan(): Setting new future strategy stack:
[17:37:34.746] List of future strategies:
[17:37:34.746] 1. multicore:
[17:37:34.746]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:34.746]    - tweaked: FALSE
[17:37:34.746]    - call: plan(strategy)
[17:37:34.753] plan(): nbrOfWorkers() = 2
[17:37:34.738] MulticoreFuture:
[17:37:34.738] Label: ‘future_mapply-1’
[17:37:34.738] Expression:
[17:37:34.738] {
[17:37:34.738]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.738]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.738]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.738]         on.exit(options(oopts), add = TRUE)
[17:37:34.738]     }
[17:37:34.738]     {
[17:37:34.738]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.738]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.738]         do.call(mapply, args = args)
[17:37:34.738]     }
[17:37:34.738] }
[17:37:34.738] Lazy evaluation: FALSE
[17:37:34.738] Asynchronous evaluation: TRUE
[17:37:34.738] Local evaluation: TRUE
[17:37:34.738] Environment: R_GlobalEnv
[17:37:34.738] Capture standard output: TRUE
[17:37:34.738] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.738] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.738] Packages: <none>
[17:37:34.738] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.738] Resolved: TRUE
[17:37:34.738] Value: <not collected>
[17:37:34.738] Conditions captured: <none>
[17:37:34.738] Early signaling: FALSE
[17:37:34.738] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.738] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:34.755] Chunk #1 of 2 ... DONE
[17:37:34.756] Chunk #2 of 2 ...
[17:37:34.756]  - Finding globals in '...' for chunk #2 ...
[17:37:34.756] getGlobalsAndPackages() ...
[17:37:34.756] Searching for globals...
[17:37:34.757] 
[17:37:34.757] Searching for globals ... DONE
[17:37:34.758] - globals: [0] <none>
[17:37:34.758] getGlobalsAndPackages() ... DONE
[17:37:34.758]    + additional globals found: [n=0] 
[17:37:34.758]    + additional namespaces needed: [n=0] 
[17:37:34.758]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:34.759]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:34.759]  - seeds: <none>
[17:37:34.759]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.760] getGlobalsAndPackages() ...
[17:37:34.760] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.760] Resolving globals: FALSE
[17:37:34.761] The total size of the 5 globals is 280 bytes (280 bytes)
[17:37:34.762] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:34.762] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.763] 
[17:37:34.763] getGlobalsAndPackages() ... DONE
[17:37:34.763] run() for ‘Future’ ...
[17:37:34.763] - state: ‘created’
[17:37:34.764] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:34.768] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:34.768] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:34.768]   - Field: ‘label’
[17:37:34.769]   - Field: ‘local’
[17:37:34.769]   - Field: ‘owner’
[17:37:34.769]   - Field: ‘envir’
[17:37:34.769]   - Field: ‘workers’
[17:37:34.769]   - Field: ‘packages’
[17:37:34.769]   - Field: ‘gc’
[17:37:34.769]   - Field: ‘job’
[17:37:34.770]   - Field: ‘conditions’
[17:37:34.770]   - Field: ‘expr’
[17:37:34.770]   - Field: ‘uuid’
[17:37:34.770]   - Field: ‘seed’
[17:37:34.770]   - Field: ‘version’
[17:37:34.770]   - Field: ‘result’
[17:37:34.771]   - Field: ‘asynchronous’
[17:37:34.771]   - Field: ‘calls’
[17:37:34.771]   - Field: ‘globals’
[17:37:34.771]   - Field: ‘stdout’
[17:37:34.771]   - Field: ‘earlySignal’
[17:37:34.771]   - Field: ‘lazy’
[17:37:34.771]   - Field: ‘state’
[17:37:34.771] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:34.772] - Launch lazy future ...
[17:37:34.772] Packages needed by the future expression (n = 0): <none>
[17:37:34.772] Packages needed by future strategies (n = 0): <none>
[17:37:34.773] {
[17:37:34.773]     {
[17:37:34.773]         {
[17:37:34.773]             ...future.startTime <- base::Sys.time()
[17:37:34.773]             {
[17:37:34.773]                 {
[17:37:34.773]                   {
[17:37:34.773]                     {
[17:37:34.773]                       base::local({
[17:37:34.773]                         has_future <- base::requireNamespace("future", 
[17:37:34.773]                           quietly = TRUE)
[17:37:34.773]                         if (has_future) {
[17:37:34.773]                           ns <- base::getNamespace("future")
[17:37:34.773]                           version <- ns[[".package"]][["version"]]
[17:37:34.773]                           if (is.null(version)) 
[17:37:34.773]                             version <- utils::packageVersion("future")
[17:37:34.773]                         }
[17:37:34.773]                         else {
[17:37:34.773]                           version <- NULL
[17:37:34.773]                         }
[17:37:34.773]                         if (!has_future || version < "1.8.0") {
[17:37:34.773]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.773]                             "", base::R.version$version.string), 
[17:37:34.773]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:34.773]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.773]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.773]                               "release", "version")], collapse = " "), 
[17:37:34.773]                             hostname = base::Sys.info()[["nodename"]])
[17:37:34.773]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.773]                             info)
[17:37:34.773]                           info <- base::paste(info, collapse = "; ")
[17:37:34.773]                           if (!has_future) {
[17:37:34.773]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.773]                               info)
[17:37:34.773]                           }
[17:37:34.773]                           else {
[17:37:34.773]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.773]                               info, version)
[17:37:34.773]                           }
[17:37:34.773]                           base::stop(msg)
[17:37:34.773]                         }
[17:37:34.773]                       })
[17:37:34.773]                     }
[17:37:34.773]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:34.773]                     base::options(mc.cores = 1L)
[17:37:34.773]                   }
[17:37:34.773]                   ...future.strategy.old <- future::plan("list")
[17:37:34.773]                   options(future.plan = NULL)
[17:37:34.773]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.773]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.773]                 }
[17:37:34.773]                 ...future.workdir <- getwd()
[17:37:34.773]             }
[17:37:34.773]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.773]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.773]         }
[17:37:34.773]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.773]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:34.773]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.773]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.773]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.773]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.773]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.773]             base::names(...future.oldOptions))
[17:37:34.773]     }
[17:37:34.773]     if (FALSE) {
[17:37:34.773]     }
[17:37:34.773]     else {
[17:37:34.773]         if (TRUE) {
[17:37:34.773]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.773]                 open = "w")
[17:37:34.773]         }
[17:37:34.773]         else {
[17:37:34.773]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.773]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.773]         }
[17:37:34.773]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.773]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.773]             base::sink(type = "output", split = FALSE)
[17:37:34.773]             base::close(...future.stdout)
[17:37:34.773]         }, add = TRUE)
[17:37:34.773]     }
[17:37:34.773]     ...future.frame <- base::sys.nframe()
[17:37:34.773]     ...future.conditions <- base::list()
[17:37:34.773]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.773]     if (FALSE) {
[17:37:34.773]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.773]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.773]     }
[17:37:34.773]     ...future.result <- base::tryCatch({
[17:37:34.773]         base::withCallingHandlers({
[17:37:34.773]             ...future.value <- base::withVisible(base::local({
[17:37:34.773]                 withCallingHandlers({
[17:37:34.773]                   {
[17:37:34.773]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.773]                     if (!identical(...future.globals.maxSize.org, 
[17:37:34.773]                       ...future.globals.maxSize)) {
[17:37:34.773]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.773]                       on.exit(options(oopts), add = TRUE)
[17:37:34.773]                     }
[17:37:34.773]                     {
[17:37:34.773]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.773]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.773]                         USE.NAMES = FALSE)
[17:37:34.773]                       do.call(mapply, args = args)
[17:37:34.773]                     }
[17:37:34.773]                   }
[17:37:34.773]                 }, immediateCondition = function(cond) {
[17:37:34.773]                   save_rds <- function (object, pathname, ...) 
[17:37:34.773]                   {
[17:37:34.773]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:34.773]                     if (file_test("-f", pathname_tmp)) {
[17:37:34.773]                       fi_tmp <- file.info(pathname_tmp)
[17:37:34.773]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:34.773]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:34.773]                         fi_tmp[["mtime"]])
[17:37:34.773]                     }
[17:37:34.773]                     tryCatch({
[17:37:34.773]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:34.773]                     }, error = function(ex) {
[17:37:34.773]                       msg <- conditionMessage(ex)
[17:37:34.773]                       fi_tmp <- file.info(pathname_tmp)
[17:37:34.773]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:34.773]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:34.773]                         fi_tmp[["mtime"]], msg)
[17:37:34.773]                       ex$message <- msg
[17:37:34.773]                       stop(ex)
[17:37:34.773]                     })
[17:37:34.773]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:34.773]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:34.773]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:34.773]                       fi_tmp <- file.info(pathname_tmp)
[17:37:34.773]                       fi <- file.info(pathname)
[17:37:34.773]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:34.773]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:34.773]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:34.773]                         fi[["size"]], fi[["mtime"]])
[17:37:34.773]                       stop(msg)
[17:37:34.773]                     }
[17:37:34.773]                     invisible(pathname)
[17:37:34.773]                   }
[17:37:34.773]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:34.773]                     rootPath = tempdir()) 
[17:37:34.773]                   {
[17:37:34.773]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:34.773]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:34.773]                       tmpdir = path, fileext = ".rds")
[17:37:34.773]                     save_rds(obj, file)
[17:37:34.773]                   }
[17:37:34.773]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:34.773]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.773]                   {
[17:37:34.773]                     inherits <- base::inherits
[17:37:34.773]                     invokeRestart <- base::invokeRestart
[17:37:34.773]                     is.null <- base::is.null
[17:37:34.773]                     muffled <- FALSE
[17:37:34.773]                     if (inherits(cond, "message")) {
[17:37:34.773]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:34.773]                       if (muffled) 
[17:37:34.773]                         invokeRestart("muffleMessage")
[17:37:34.773]                     }
[17:37:34.773]                     else if (inherits(cond, "warning")) {
[17:37:34.773]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:34.773]                       if (muffled) 
[17:37:34.773]                         invokeRestart("muffleWarning")
[17:37:34.773]                     }
[17:37:34.773]                     else if (inherits(cond, "condition")) {
[17:37:34.773]                       if (!is.null(pattern)) {
[17:37:34.773]                         computeRestarts <- base::computeRestarts
[17:37:34.773]                         grepl <- base::grepl
[17:37:34.773]                         restarts <- computeRestarts(cond)
[17:37:34.773]                         for (restart in restarts) {
[17:37:34.773]                           name <- restart$name
[17:37:34.773]                           if (is.null(name)) 
[17:37:34.773]                             next
[17:37:34.773]                           if (!grepl(pattern, name)) 
[17:37:34.773]                             next
[17:37:34.773]                           invokeRestart(restart)
[17:37:34.773]                           muffled <- TRUE
[17:37:34.773]                           break
[17:37:34.773]                         }
[17:37:34.773]                       }
[17:37:34.773]                     }
[17:37:34.773]                     invisible(muffled)
[17:37:34.773]                   }
[17:37:34.773]                   muffleCondition(cond)
[17:37:34.773]                 })
[17:37:34.773]             }))
[17:37:34.773]             future::FutureResult(value = ...future.value$value, 
[17:37:34.773]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.773]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.773]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.773]                     ...future.globalenv.names))
[17:37:34.773]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.773]         }, condition = base::local({
[17:37:34.773]             c <- base::c
[17:37:34.773]             inherits <- base::inherits
[17:37:34.773]             invokeRestart <- base::invokeRestart
[17:37:34.773]             length <- base::length
[17:37:34.773]             list <- base::list
[17:37:34.773]             seq.int <- base::seq.int
[17:37:34.773]             signalCondition <- base::signalCondition
[17:37:34.773]             sys.calls <- base::sys.calls
[17:37:34.773]             `[[` <- base::`[[`
[17:37:34.773]             `+` <- base::`+`
[17:37:34.773]             `<<-` <- base::`<<-`
[17:37:34.773]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.773]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.773]                   3L)]
[17:37:34.773]             }
[17:37:34.773]             function(cond) {
[17:37:34.773]                 is_error <- inherits(cond, "error")
[17:37:34.773]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.773]                   NULL)
[17:37:34.773]                 if (is_error) {
[17:37:34.773]                   sessionInformation <- function() {
[17:37:34.773]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.773]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.773]                       search = base::search(), system = base::Sys.info())
[17:37:34.773]                   }
[17:37:34.773]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.773]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.773]                     cond$call), session = sessionInformation(), 
[17:37:34.773]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.773]                   signalCondition(cond)
[17:37:34.773]                 }
[17:37:34.773]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.773]                 "immediateCondition"))) {
[17:37:34.773]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.773]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.773]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.773]                   if (TRUE && !signal) {
[17:37:34.773]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.773]                     {
[17:37:34.773]                       inherits <- base::inherits
[17:37:34.773]                       invokeRestart <- base::invokeRestart
[17:37:34.773]                       is.null <- base::is.null
[17:37:34.773]                       muffled <- FALSE
[17:37:34.773]                       if (inherits(cond, "message")) {
[17:37:34.773]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.773]                         if (muffled) 
[17:37:34.773]                           invokeRestart("muffleMessage")
[17:37:34.773]                       }
[17:37:34.773]                       else if (inherits(cond, "warning")) {
[17:37:34.773]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.773]                         if (muffled) 
[17:37:34.773]                           invokeRestart("muffleWarning")
[17:37:34.773]                       }
[17:37:34.773]                       else if (inherits(cond, "condition")) {
[17:37:34.773]                         if (!is.null(pattern)) {
[17:37:34.773]                           computeRestarts <- base::computeRestarts
[17:37:34.773]                           grepl <- base::grepl
[17:37:34.773]                           restarts <- computeRestarts(cond)
[17:37:34.773]                           for (restart in restarts) {
[17:37:34.773]                             name <- restart$name
[17:37:34.773]                             if (is.null(name)) 
[17:37:34.773]                               next
[17:37:34.773]                             if (!grepl(pattern, name)) 
[17:37:34.773]                               next
[17:37:34.773]                             invokeRestart(restart)
[17:37:34.773]                             muffled <- TRUE
[17:37:34.773]                             break
[17:37:34.773]                           }
[17:37:34.773]                         }
[17:37:34.773]                       }
[17:37:34.773]                       invisible(muffled)
[17:37:34.773]                     }
[17:37:34.773]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.773]                   }
[17:37:34.773]                 }
[17:37:34.773]                 else {
[17:37:34.773]                   if (TRUE) {
[17:37:34.773]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.773]                     {
[17:37:34.773]                       inherits <- base::inherits
[17:37:34.773]                       invokeRestart <- base::invokeRestart
[17:37:34.773]                       is.null <- base::is.null
[17:37:34.773]                       muffled <- FALSE
[17:37:34.773]                       if (inherits(cond, "message")) {
[17:37:34.773]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.773]                         if (muffled) 
[17:37:34.773]                           invokeRestart("muffleMessage")
[17:37:34.773]                       }
[17:37:34.773]                       else if (inherits(cond, "warning")) {
[17:37:34.773]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.773]                         if (muffled) 
[17:37:34.773]                           invokeRestart("muffleWarning")
[17:37:34.773]                       }
[17:37:34.773]                       else if (inherits(cond, "condition")) {
[17:37:34.773]                         if (!is.null(pattern)) {
[17:37:34.773]                           computeRestarts <- base::computeRestarts
[17:37:34.773]                           grepl <- base::grepl
[17:37:34.773]                           restarts <- computeRestarts(cond)
[17:37:34.773]                           for (restart in restarts) {
[17:37:34.773]                             name <- restart$name
[17:37:34.773]                             if (is.null(name)) 
[17:37:34.773]                               next
[17:37:34.773]                             if (!grepl(pattern, name)) 
[17:37:34.773]                               next
[17:37:34.773]                             invokeRestart(restart)
[17:37:34.773]                             muffled <- TRUE
[17:37:34.773]                             break
[17:37:34.773]                           }
[17:37:34.773]                         }
[17:37:34.773]                       }
[17:37:34.773]                       invisible(muffled)
[17:37:34.773]                     }
[17:37:34.773]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.773]                   }
[17:37:34.773]                 }
[17:37:34.773]             }
[17:37:34.773]         }))
[17:37:34.773]     }, error = function(ex) {
[17:37:34.773]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.773]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.773]                 ...future.rng), started = ...future.startTime, 
[17:37:34.773]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.773]             version = "1.8"), class = "FutureResult")
[17:37:34.773]     }, finally = {
[17:37:34.773]         if (!identical(...future.workdir, getwd())) 
[17:37:34.773]             setwd(...future.workdir)
[17:37:34.773]         {
[17:37:34.773]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.773]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.773]             }
[17:37:34.773]             base::options(...future.oldOptions)
[17:37:34.773]             if (.Platform$OS.type == "windows") {
[17:37:34.773]                 old_names <- names(...future.oldEnvVars)
[17:37:34.773]                 envs <- base::Sys.getenv()
[17:37:34.773]                 names <- names(envs)
[17:37:34.773]                 common <- intersect(names, old_names)
[17:37:34.773]                 added <- setdiff(names, old_names)
[17:37:34.773]                 removed <- setdiff(old_names, names)
[17:37:34.773]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.773]                   envs[common]]
[17:37:34.773]                 NAMES <- toupper(changed)
[17:37:34.773]                 args <- list()
[17:37:34.773]                 for (kk in seq_along(NAMES)) {
[17:37:34.773]                   name <- changed[[kk]]
[17:37:34.773]                   NAME <- NAMES[[kk]]
[17:37:34.773]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.773]                     next
[17:37:34.773]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.773]                 }
[17:37:34.773]                 NAMES <- toupper(added)
[17:37:34.773]                 for (kk in seq_along(NAMES)) {
[17:37:34.773]                   name <- added[[kk]]
[17:37:34.773]                   NAME <- NAMES[[kk]]
[17:37:34.773]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.773]                     next
[17:37:34.773]                   args[[name]] <- ""
[17:37:34.773]                 }
[17:37:34.773]                 NAMES <- toupper(removed)
[17:37:34.773]                 for (kk in seq_along(NAMES)) {
[17:37:34.773]                   name <- removed[[kk]]
[17:37:34.773]                   NAME <- NAMES[[kk]]
[17:37:34.773]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.773]                     next
[17:37:34.773]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.773]                 }
[17:37:34.773]                 if (length(args) > 0) 
[17:37:34.773]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.773]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.773]             }
[17:37:34.773]             else {
[17:37:34.773]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.773]             }
[17:37:34.773]             {
[17:37:34.773]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.773]                   0L) {
[17:37:34.773]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.773]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.773]                   base::options(opts)
[17:37:34.773]                 }
[17:37:34.773]                 {
[17:37:34.773]                   {
[17:37:34.773]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:34.773]                     NULL
[17:37:34.773]                   }
[17:37:34.773]                   options(future.plan = NULL)
[17:37:34.773]                   if (is.na(NA_character_)) 
[17:37:34.773]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.773]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.773]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.773]                     .init = FALSE)
[17:37:34.773]                 }
[17:37:34.773]             }
[17:37:34.773]         }
[17:37:34.773]     })
[17:37:34.773]     if (TRUE) {
[17:37:34.773]         base::sink(type = "output", split = FALSE)
[17:37:34.773]         if (TRUE) {
[17:37:34.773]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.773]         }
[17:37:34.773]         else {
[17:37:34.773]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.773]         }
[17:37:34.773]         base::close(...future.stdout)
[17:37:34.773]         ...future.stdout <- NULL
[17:37:34.773]     }
[17:37:34.773]     ...future.result$conditions <- ...future.conditions
[17:37:34.773]     ...future.result$finished <- base::Sys.time()
[17:37:34.773]     ...future.result
[17:37:34.773] }
[17:37:34.775] assign_globals() ...
[17:37:34.776] List of 5
[17:37:34.776]  $ ...future.FUN            :function (x, ...)  
[17:37:34.776]  $ MoreArgs                 : NULL
[17:37:34.776]  $ ...future.elements_ii    :List of 2
[17:37:34.776]   ..$ :List of 2
[17:37:34.776]   .. ..$ : int 3
[17:37:34.776]   .. ..$ : int 4
[17:37:34.776]   ..$ :List of 2
[17:37:34.776]   .. ..$ : int 2
[17:37:34.776]   .. ..$ : int 1
[17:37:34.776]  $ ...future.seeds_ii       : NULL
[17:37:34.776]  $ ...future.globals.maxSize: NULL
[17:37:34.776]  - attr(*, "where")=List of 5
[17:37:34.776]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.776]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.776]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.776]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.776]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.776]  - attr(*, "resolved")= logi FALSE
[17:37:34.776]  - attr(*, "total_size")= num 280
[17:37:34.776]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.776]  - attr(*, "already-done")= logi TRUE
[17:37:34.782] - copied ‘...future.FUN’ to environment
[17:37:34.783] - copied ‘MoreArgs’ to environment
[17:37:34.783] - copied ‘...future.elements_ii’ to environment
[17:37:34.783] - copied ‘...future.seeds_ii’ to environment
[17:37:34.783] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.783] assign_globals() ... done
[17:37:34.783] requestCore(): workers = 2
[17:37:34.788] MulticoreFuture started
[17:37:34.789] - Launch lazy future ... done
[17:37:34.789] run() for ‘MulticoreFuture’ ... done
[17:37:34.789] Created future:
[17:37:34.790] plan(): Setting new future strategy stack:
[17:37:34.790] List of future strategies:
[17:37:34.790] 1. sequential:
[17:37:34.790]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.790]    - tweaked: FALSE
[17:37:34.790]    - call: NULL
[17:37:34.791] plan(): nbrOfWorkers() = 1
[17:37:34.793] plan(): Setting new future strategy stack:
[17:37:34.793] List of future strategies:
[17:37:34.793] 1. multicore:
[17:37:34.793]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:34.793]    - tweaked: FALSE
[17:37:34.793]    - call: plan(strategy)
[17:37:34.798] plan(): nbrOfWorkers() = 2
[17:37:34.790] MulticoreFuture:
[17:37:34.790] Label: ‘future_mapply-2’
[17:37:34.790] Expression:
[17:37:34.790] {
[17:37:34.790]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.790]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.790]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.790]         on.exit(options(oopts), add = TRUE)
[17:37:34.790]     }
[17:37:34.790]     {
[17:37:34.790]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.790]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.790]         do.call(mapply, args = args)
[17:37:34.790]     }
[17:37:34.790] }
[17:37:34.790] Lazy evaluation: FALSE
[17:37:34.790] Asynchronous evaluation: TRUE
[17:37:34.790] Local evaluation: TRUE
[17:37:34.790] Environment: R_GlobalEnv
[17:37:34.790] Capture standard output: TRUE
[17:37:34.790] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.790] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.790] Packages: <none>
[17:37:34.790] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.790] Resolved: TRUE
[17:37:34.790] Value: <not collected>
[17:37:34.790] Conditions captured: <none>
[17:37:34.790] Early signaling: FALSE
[17:37:34.790] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.790] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:34.799] Chunk #2 of 2 ... DONE
[17:37:34.799] Launching 2 futures (chunks) ... DONE
[17:37:34.800] Resolving 2 futures (chunks) ...
[17:37:34.800] resolve() on list ...
[17:37:34.800]  recursive: 0
[17:37:34.800]  length: 2
[17:37:34.800] 
[17:37:34.801] Future #1
[17:37:34.801] result() for MulticoreFuture ...
[17:37:34.803] result() for MulticoreFuture ...
[17:37:34.803] result() for MulticoreFuture ... done
[17:37:34.803] result() for MulticoreFuture ... done
[17:37:34.803] result() for MulticoreFuture ...
[17:37:34.804] result() for MulticoreFuture ... done
[17:37:34.804] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:37:34.804] - nx: 2
[17:37:34.804] - relay: TRUE
[17:37:34.804] - stdout: TRUE
[17:37:34.804] - signal: TRUE
[17:37:34.809] - resignal: FALSE
[17:37:34.809] - force: TRUE
[17:37:34.809] - relayed: [n=2] FALSE, FALSE
[17:37:34.810] - queued futures: [n=2] FALSE, FALSE
[17:37:34.810]  - until=1
[17:37:34.810]  - relaying element #1
[17:37:34.811] result() for MulticoreFuture ...
[17:37:34.811] result() for MulticoreFuture ... done
[17:37:34.811] result() for MulticoreFuture ...
[17:37:34.811] result() for MulticoreFuture ... done
[17:37:34.812] result() for MulticoreFuture ...
[17:37:34.812] result() for MulticoreFuture ... done
[17:37:34.812] result() for MulticoreFuture ...
[17:37:34.813] result() for MulticoreFuture ... done
[17:37:34.813] - relayed: [n=2] TRUE, FALSE
[17:37:34.813] - queued futures: [n=2] TRUE, FALSE
[17:37:34.813] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:37:34.814]  length: 1 (resolved future 1)
[17:37:34.814] Future #2
[17:37:34.814] result() for MulticoreFuture ...
[17:37:34.815] result() for MulticoreFuture ...
[17:37:34.815] result() for MulticoreFuture ... done
[17:37:34.816] result() for MulticoreFuture ... done
[17:37:34.816] result() for MulticoreFuture ...
[17:37:34.816] result() for MulticoreFuture ... done
[17:37:34.817] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:37:34.817] - nx: 2
[17:37:34.817] - relay: TRUE
[17:37:34.817] - stdout: TRUE
[17:37:34.817] - signal: TRUE
[17:37:34.817] - resignal: FALSE
[17:37:34.817] - force: TRUE
[17:37:34.817] - relayed: [n=2] TRUE, FALSE
[17:37:34.818] - queued futures: [n=2] TRUE, FALSE
[17:37:34.818]  - until=2
[17:37:34.818]  - relaying element #2
[17:37:34.818] result() for MulticoreFuture ...
[17:37:34.818] result() for MulticoreFuture ... done
[17:37:34.818] result() for MulticoreFuture ...
[17:37:34.818] result() for MulticoreFuture ... done
[17:37:34.818] result() for MulticoreFuture ...
[17:37:34.819] result() for MulticoreFuture ... done
[17:37:34.819] result() for MulticoreFuture ...
[17:37:34.819] result() for MulticoreFuture ... done
[17:37:34.819] - relayed: [n=2] TRUE, TRUE
[17:37:34.819] - queued futures: [n=2] TRUE, TRUE
[17:37:34.819] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:37:34.819]  length: 0 (resolved future 2)
[17:37:34.819] Relaying remaining futures
[17:37:34.819] signalConditionsASAP(NULL, pos=0) ...
[17:37:34.820] - nx: 2
[17:37:34.820] - relay: TRUE
[17:37:34.820] - stdout: TRUE
[17:37:34.820] - signal: TRUE
[17:37:34.820] - resignal: FALSE
[17:37:34.820] - force: TRUE
[17:37:34.820] - relayed: [n=2] TRUE, TRUE
[17:37:34.820] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:34.821] - relayed: [n=2] TRUE, TRUE
[17:37:34.821] - queued futures: [n=2] TRUE, TRUE
[17:37:34.821] signalConditionsASAP(NULL, pos=0) ... done
[17:37:34.821] resolve() on list ... DONE
[17:37:34.821] result() for MulticoreFuture ...
[17:37:34.821] result() for MulticoreFuture ... done
[17:37:34.821] result() for MulticoreFuture ...
[17:37:34.821] result() for MulticoreFuture ... done
[17:37:34.821] result() for MulticoreFuture ...
[17:37:34.822] result() for MulticoreFuture ... done
[17:37:34.822] result() for MulticoreFuture ...
[17:37:34.822] result() for MulticoreFuture ... done
[17:37:34.822]  - Number of value chunks collected: 2
[17:37:34.822] Resolving 2 futures (chunks) ... DONE
[17:37:34.822] Reducing values from 2 chunks ...
[17:37:34.822]  - Number of values collected after concatenation: 4
[17:37:34.822]  - Number of values expected: 4
[17:37:34.822] Reducing values from 2 chunks ... DONE
[17:37:34.822] future_mapply() ... DONE
[17:37:34.823] future_mapply() ...
[17:37:34.827] Number of chunks: 2
[17:37:34.827] getGlobalsAndPackagesXApply() ...
[17:37:34.827]  - future.globals: TRUE
[17:37:34.827] getGlobalsAndPackages() ...
[17:37:34.827] Searching for globals...
[17:37:34.828] - globals found: [1] ‘FUN’
[17:37:34.828] Searching for globals ... DONE
[17:37:34.828] Resolving globals: FALSE
[17:37:34.829] The total size of the 1 globals is 56 bytes (56 bytes)
[17:37:34.829] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:37:34.829] - globals: [1] ‘FUN’
[17:37:34.829] 
[17:37:34.829] getGlobalsAndPackages() ... DONE
[17:37:34.829]  - globals found/used: [n=1] ‘FUN’
[17:37:34.830]  - needed namespaces: [n=0] 
[17:37:34.830] Finding globals ... DONE
[17:37:34.830] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:34.830] List of 2
[17:37:34.830]  $ ...future.FUN:function (x, ...)  
[17:37:34.830]  $ MoreArgs     : NULL
[17:37:34.830]  - attr(*, "where")=List of 2
[17:37:34.830]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:34.830]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:34.830]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.830]  - attr(*, "resolved")= logi FALSE
[17:37:34.830]  - attr(*, "total_size")= num NA
[17:37:34.833] Packages to be attached in all futures: [n=0] 
[17:37:34.833] getGlobalsAndPackagesXApply() ... DONE
[17:37:34.833] Number of futures (= number of chunks): 2
[17:37:34.833] Launching 2 futures (chunks) ...
[17:37:34.833] Chunk #1 of 2 ...
[17:37:34.833]  - Finding globals in '...' for chunk #1 ...
[17:37:34.833] getGlobalsAndPackages() ...
[17:37:34.834] Searching for globals...
[17:37:34.834] 
[17:37:34.834] Searching for globals ... DONE
[17:37:34.834] - globals: [0] <none>
[17:37:34.834] getGlobalsAndPackages() ... DONE
[17:37:34.834]    + additional globals found: [n=0] 
[17:37:34.834]    + additional namespaces needed: [n=0] 
[17:37:34.835]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:34.835]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:34.835]  - seeds: <none>
[17:37:34.835]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.835] getGlobalsAndPackages() ...
[17:37:34.835] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.835] Resolving globals: FALSE
[17:37:34.836] The total size of the 5 globals is 280 bytes (280 bytes)
[17:37:34.836] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:34.836] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.836] 
[17:37:34.836] getGlobalsAndPackages() ... DONE
[17:37:34.837] run() for ‘Future’ ...
[17:37:34.837] - state: ‘created’
[17:37:34.837] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:34.841] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:34.841] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:34.841]   - Field: ‘label’
[17:37:34.841]   - Field: ‘local’
[17:37:34.841]   - Field: ‘owner’
[17:37:34.841]   - Field: ‘envir’
[17:37:34.841]   - Field: ‘workers’
[17:37:34.841]   - Field: ‘packages’
[17:37:34.842]   - Field: ‘gc’
[17:37:34.842]   - Field: ‘job’
[17:37:34.842]   - Field: ‘conditions’
[17:37:34.842]   - Field: ‘expr’
[17:37:34.842]   - Field: ‘uuid’
[17:37:34.842]   - Field: ‘seed’
[17:37:34.842]   - Field: ‘version’
[17:37:34.842]   - Field: ‘result’
[17:37:34.842]   - Field: ‘asynchronous’
[17:37:34.842]   - Field: ‘calls’
[17:37:34.842]   - Field: ‘globals’
[17:37:34.843]   - Field: ‘stdout’
[17:37:34.843]   - Field: ‘earlySignal’
[17:37:34.843]   - Field: ‘lazy’
[17:37:34.845]   - Field: ‘state’
[17:37:34.845] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:34.845] - Launch lazy future ...
[17:37:34.845] Packages needed by the future expression (n = 0): <none>
[17:37:34.845] Packages needed by future strategies (n = 0): <none>
[17:37:34.846] {
[17:37:34.846]     {
[17:37:34.846]         {
[17:37:34.846]             ...future.startTime <- base::Sys.time()
[17:37:34.846]             {
[17:37:34.846]                 {
[17:37:34.846]                   {
[17:37:34.846]                     {
[17:37:34.846]                       base::local({
[17:37:34.846]                         has_future <- base::requireNamespace("future", 
[17:37:34.846]                           quietly = TRUE)
[17:37:34.846]                         if (has_future) {
[17:37:34.846]                           ns <- base::getNamespace("future")
[17:37:34.846]                           version <- ns[[".package"]][["version"]]
[17:37:34.846]                           if (is.null(version)) 
[17:37:34.846]                             version <- utils::packageVersion("future")
[17:37:34.846]                         }
[17:37:34.846]                         else {
[17:37:34.846]                           version <- NULL
[17:37:34.846]                         }
[17:37:34.846]                         if (!has_future || version < "1.8.0") {
[17:37:34.846]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.846]                             "", base::R.version$version.string), 
[17:37:34.846]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:34.846]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.846]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.846]                               "release", "version")], collapse = " "), 
[17:37:34.846]                             hostname = base::Sys.info()[["nodename"]])
[17:37:34.846]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.846]                             info)
[17:37:34.846]                           info <- base::paste(info, collapse = "; ")
[17:37:34.846]                           if (!has_future) {
[17:37:34.846]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.846]                               info)
[17:37:34.846]                           }
[17:37:34.846]                           else {
[17:37:34.846]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.846]                               info, version)
[17:37:34.846]                           }
[17:37:34.846]                           base::stop(msg)
[17:37:34.846]                         }
[17:37:34.846]                       })
[17:37:34.846]                     }
[17:37:34.846]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:34.846]                     base::options(mc.cores = 1L)
[17:37:34.846]                   }
[17:37:34.846]                   ...future.strategy.old <- future::plan("list")
[17:37:34.846]                   options(future.plan = NULL)
[17:37:34.846]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.846]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.846]                 }
[17:37:34.846]                 ...future.workdir <- getwd()
[17:37:34.846]             }
[17:37:34.846]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.846]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.846]         }
[17:37:34.846]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.846]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:34.846]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.846]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.846]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.846]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.846]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.846]             base::names(...future.oldOptions))
[17:37:34.846]     }
[17:37:34.846]     if (FALSE) {
[17:37:34.846]     }
[17:37:34.846]     else {
[17:37:34.846]         if (TRUE) {
[17:37:34.846]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.846]                 open = "w")
[17:37:34.846]         }
[17:37:34.846]         else {
[17:37:34.846]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.846]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.846]         }
[17:37:34.846]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.846]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.846]             base::sink(type = "output", split = FALSE)
[17:37:34.846]             base::close(...future.stdout)
[17:37:34.846]         }, add = TRUE)
[17:37:34.846]     }
[17:37:34.846]     ...future.frame <- base::sys.nframe()
[17:37:34.846]     ...future.conditions <- base::list()
[17:37:34.846]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.846]     if (FALSE) {
[17:37:34.846]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.846]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.846]     }
[17:37:34.846]     ...future.result <- base::tryCatch({
[17:37:34.846]         base::withCallingHandlers({
[17:37:34.846]             ...future.value <- base::withVisible(base::local({
[17:37:34.846]                 withCallingHandlers({
[17:37:34.846]                   {
[17:37:34.846]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.846]                     if (!identical(...future.globals.maxSize.org, 
[17:37:34.846]                       ...future.globals.maxSize)) {
[17:37:34.846]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.846]                       on.exit(options(oopts), add = TRUE)
[17:37:34.846]                     }
[17:37:34.846]                     {
[17:37:34.846]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.846]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.846]                         USE.NAMES = FALSE)
[17:37:34.846]                       do.call(mapply, args = args)
[17:37:34.846]                     }
[17:37:34.846]                   }
[17:37:34.846]                 }, immediateCondition = function(cond) {
[17:37:34.846]                   save_rds <- function (object, pathname, ...) 
[17:37:34.846]                   {
[17:37:34.846]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:34.846]                     if (file_test("-f", pathname_tmp)) {
[17:37:34.846]                       fi_tmp <- file.info(pathname_tmp)
[17:37:34.846]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:34.846]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:34.846]                         fi_tmp[["mtime"]])
[17:37:34.846]                     }
[17:37:34.846]                     tryCatch({
[17:37:34.846]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:34.846]                     }, error = function(ex) {
[17:37:34.846]                       msg <- conditionMessage(ex)
[17:37:34.846]                       fi_tmp <- file.info(pathname_tmp)
[17:37:34.846]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:34.846]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:34.846]                         fi_tmp[["mtime"]], msg)
[17:37:34.846]                       ex$message <- msg
[17:37:34.846]                       stop(ex)
[17:37:34.846]                     })
[17:37:34.846]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:34.846]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:34.846]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:34.846]                       fi_tmp <- file.info(pathname_tmp)
[17:37:34.846]                       fi <- file.info(pathname)
[17:37:34.846]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:34.846]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:34.846]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:34.846]                         fi[["size"]], fi[["mtime"]])
[17:37:34.846]                       stop(msg)
[17:37:34.846]                     }
[17:37:34.846]                     invisible(pathname)
[17:37:34.846]                   }
[17:37:34.846]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:34.846]                     rootPath = tempdir()) 
[17:37:34.846]                   {
[17:37:34.846]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:34.846]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:34.846]                       tmpdir = path, fileext = ".rds")
[17:37:34.846]                     save_rds(obj, file)
[17:37:34.846]                   }
[17:37:34.846]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:34.846]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.846]                   {
[17:37:34.846]                     inherits <- base::inherits
[17:37:34.846]                     invokeRestart <- base::invokeRestart
[17:37:34.846]                     is.null <- base::is.null
[17:37:34.846]                     muffled <- FALSE
[17:37:34.846]                     if (inherits(cond, "message")) {
[17:37:34.846]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:34.846]                       if (muffled) 
[17:37:34.846]                         invokeRestart("muffleMessage")
[17:37:34.846]                     }
[17:37:34.846]                     else if (inherits(cond, "warning")) {
[17:37:34.846]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:34.846]                       if (muffled) 
[17:37:34.846]                         invokeRestart("muffleWarning")
[17:37:34.846]                     }
[17:37:34.846]                     else if (inherits(cond, "condition")) {
[17:37:34.846]                       if (!is.null(pattern)) {
[17:37:34.846]                         computeRestarts <- base::computeRestarts
[17:37:34.846]                         grepl <- base::grepl
[17:37:34.846]                         restarts <- computeRestarts(cond)
[17:37:34.846]                         for (restart in restarts) {
[17:37:34.846]                           name <- restart$name
[17:37:34.846]                           if (is.null(name)) 
[17:37:34.846]                             next
[17:37:34.846]                           if (!grepl(pattern, name)) 
[17:37:34.846]                             next
[17:37:34.846]                           invokeRestart(restart)
[17:37:34.846]                           muffled <- TRUE
[17:37:34.846]                           break
[17:37:34.846]                         }
[17:37:34.846]                       }
[17:37:34.846]                     }
[17:37:34.846]                     invisible(muffled)
[17:37:34.846]                   }
[17:37:34.846]                   muffleCondition(cond)
[17:37:34.846]                 })
[17:37:34.846]             }))
[17:37:34.846]             future::FutureResult(value = ...future.value$value, 
[17:37:34.846]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.846]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.846]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.846]                     ...future.globalenv.names))
[17:37:34.846]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.846]         }, condition = base::local({
[17:37:34.846]             c <- base::c
[17:37:34.846]             inherits <- base::inherits
[17:37:34.846]             invokeRestart <- base::invokeRestart
[17:37:34.846]             length <- base::length
[17:37:34.846]             list <- base::list
[17:37:34.846]             seq.int <- base::seq.int
[17:37:34.846]             signalCondition <- base::signalCondition
[17:37:34.846]             sys.calls <- base::sys.calls
[17:37:34.846]             `[[` <- base::`[[`
[17:37:34.846]             `+` <- base::`+`
[17:37:34.846]             `<<-` <- base::`<<-`
[17:37:34.846]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.846]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.846]                   3L)]
[17:37:34.846]             }
[17:37:34.846]             function(cond) {
[17:37:34.846]                 is_error <- inherits(cond, "error")
[17:37:34.846]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.846]                   NULL)
[17:37:34.846]                 if (is_error) {
[17:37:34.846]                   sessionInformation <- function() {
[17:37:34.846]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.846]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.846]                       search = base::search(), system = base::Sys.info())
[17:37:34.846]                   }
[17:37:34.846]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.846]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.846]                     cond$call), session = sessionInformation(), 
[17:37:34.846]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.846]                   signalCondition(cond)
[17:37:34.846]                 }
[17:37:34.846]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.846]                 "immediateCondition"))) {
[17:37:34.846]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.846]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.846]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.846]                   if (TRUE && !signal) {
[17:37:34.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.846]                     {
[17:37:34.846]                       inherits <- base::inherits
[17:37:34.846]                       invokeRestart <- base::invokeRestart
[17:37:34.846]                       is.null <- base::is.null
[17:37:34.846]                       muffled <- FALSE
[17:37:34.846]                       if (inherits(cond, "message")) {
[17:37:34.846]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.846]                         if (muffled) 
[17:37:34.846]                           invokeRestart("muffleMessage")
[17:37:34.846]                       }
[17:37:34.846]                       else if (inherits(cond, "warning")) {
[17:37:34.846]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.846]                         if (muffled) 
[17:37:34.846]                           invokeRestart("muffleWarning")
[17:37:34.846]                       }
[17:37:34.846]                       else if (inherits(cond, "condition")) {
[17:37:34.846]                         if (!is.null(pattern)) {
[17:37:34.846]                           computeRestarts <- base::computeRestarts
[17:37:34.846]                           grepl <- base::grepl
[17:37:34.846]                           restarts <- computeRestarts(cond)
[17:37:34.846]                           for (restart in restarts) {
[17:37:34.846]                             name <- restart$name
[17:37:34.846]                             if (is.null(name)) 
[17:37:34.846]                               next
[17:37:34.846]                             if (!grepl(pattern, name)) 
[17:37:34.846]                               next
[17:37:34.846]                             invokeRestart(restart)
[17:37:34.846]                             muffled <- TRUE
[17:37:34.846]                             break
[17:37:34.846]                           }
[17:37:34.846]                         }
[17:37:34.846]                       }
[17:37:34.846]                       invisible(muffled)
[17:37:34.846]                     }
[17:37:34.846]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.846]                   }
[17:37:34.846]                 }
[17:37:34.846]                 else {
[17:37:34.846]                   if (TRUE) {
[17:37:34.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.846]                     {
[17:37:34.846]                       inherits <- base::inherits
[17:37:34.846]                       invokeRestart <- base::invokeRestart
[17:37:34.846]                       is.null <- base::is.null
[17:37:34.846]                       muffled <- FALSE
[17:37:34.846]                       if (inherits(cond, "message")) {
[17:37:34.846]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.846]                         if (muffled) 
[17:37:34.846]                           invokeRestart("muffleMessage")
[17:37:34.846]                       }
[17:37:34.846]                       else if (inherits(cond, "warning")) {
[17:37:34.846]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.846]                         if (muffled) 
[17:37:34.846]                           invokeRestart("muffleWarning")
[17:37:34.846]                       }
[17:37:34.846]                       else if (inherits(cond, "condition")) {
[17:37:34.846]                         if (!is.null(pattern)) {
[17:37:34.846]                           computeRestarts <- base::computeRestarts
[17:37:34.846]                           grepl <- base::grepl
[17:37:34.846]                           restarts <- computeRestarts(cond)
[17:37:34.846]                           for (restart in restarts) {
[17:37:34.846]                             name <- restart$name
[17:37:34.846]                             if (is.null(name)) 
[17:37:34.846]                               next
[17:37:34.846]                             if (!grepl(pattern, name)) 
[17:37:34.846]                               next
[17:37:34.846]                             invokeRestart(restart)
[17:37:34.846]                             muffled <- TRUE
[17:37:34.846]                             break
[17:37:34.846]                           }
[17:37:34.846]                         }
[17:37:34.846]                       }
[17:37:34.846]                       invisible(muffled)
[17:37:34.846]                     }
[17:37:34.846]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.846]                   }
[17:37:34.846]                 }
[17:37:34.846]             }
[17:37:34.846]         }))
[17:37:34.846]     }, error = function(ex) {
[17:37:34.846]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.846]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.846]                 ...future.rng), started = ...future.startTime, 
[17:37:34.846]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.846]             version = "1.8"), class = "FutureResult")
[17:37:34.846]     }, finally = {
[17:37:34.846]         if (!identical(...future.workdir, getwd())) 
[17:37:34.846]             setwd(...future.workdir)
[17:37:34.846]         {
[17:37:34.846]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.846]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.846]             }
[17:37:34.846]             base::options(...future.oldOptions)
[17:37:34.846]             if (.Platform$OS.type == "windows") {
[17:37:34.846]                 old_names <- names(...future.oldEnvVars)
[17:37:34.846]                 envs <- base::Sys.getenv()
[17:37:34.846]                 names <- names(envs)
[17:37:34.846]                 common <- intersect(names, old_names)
[17:37:34.846]                 added <- setdiff(names, old_names)
[17:37:34.846]                 removed <- setdiff(old_names, names)
[17:37:34.846]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.846]                   envs[common]]
[17:37:34.846]                 NAMES <- toupper(changed)
[17:37:34.846]                 args <- list()
[17:37:34.846]                 for (kk in seq_along(NAMES)) {
[17:37:34.846]                   name <- changed[[kk]]
[17:37:34.846]                   NAME <- NAMES[[kk]]
[17:37:34.846]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.846]                     next
[17:37:34.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.846]                 }
[17:37:34.846]                 NAMES <- toupper(added)
[17:37:34.846]                 for (kk in seq_along(NAMES)) {
[17:37:34.846]                   name <- added[[kk]]
[17:37:34.846]                   NAME <- NAMES[[kk]]
[17:37:34.846]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.846]                     next
[17:37:34.846]                   args[[name]] <- ""
[17:37:34.846]                 }
[17:37:34.846]                 NAMES <- toupper(removed)
[17:37:34.846]                 for (kk in seq_along(NAMES)) {
[17:37:34.846]                   name <- removed[[kk]]
[17:37:34.846]                   NAME <- NAMES[[kk]]
[17:37:34.846]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.846]                     next
[17:37:34.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.846]                 }
[17:37:34.846]                 if (length(args) > 0) 
[17:37:34.846]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.846]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.846]             }
[17:37:34.846]             else {
[17:37:34.846]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.846]             }
[17:37:34.846]             {
[17:37:34.846]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.846]                   0L) {
[17:37:34.846]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.846]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.846]                   base::options(opts)
[17:37:34.846]                 }
[17:37:34.846]                 {
[17:37:34.846]                   {
[17:37:34.846]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:34.846]                     NULL
[17:37:34.846]                   }
[17:37:34.846]                   options(future.plan = NULL)
[17:37:34.846]                   if (is.na(NA_character_)) 
[17:37:34.846]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.846]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.846]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.846]                     .init = FALSE)
[17:37:34.846]                 }
[17:37:34.846]             }
[17:37:34.846]         }
[17:37:34.846]     })
[17:37:34.846]     if (TRUE) {
[17:37:34.846]         base::sink(type = "output", split = FALSE)
[17:37:34.846]         if (TRUE) {
[17:37:34.846]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.846]         }
[17:37:34.846]         else {
[17:37:34.846]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.846]         }
[17:37:34.846]         base::close(...future.stdout)
[17:37:34.846]         ...future.stdout <- NULL
[17:37:34.846]     }
[17:37:34.846]     ...future.result$conditions <- ...future.conditions
[17:37:34.846]     ...future.result$finished <- base::Sys.time()
[17:37:34.846]     ...future.result
[17:37:34.846] }
[17:37:34.848] assign_globals() ...
[17:37:34.848] List of 5
[17:37:34.848]  $ ...future.FUN            :function (x, ...)  
[17:37:34.848]  $ MoreArgs                 : NULL
[17:37:34.848]  $ ...future.elements_ii    :List of 2
[17:37:34.848]   ..$ :List of 2
[17:37:34.848]   .. ..$ : int 1
[17:37:34.848]   .. ..$ : int 2
[17:37:34.848]   ..$ :List of 2
[17:37:34.848]   .. ..$ : int 4
[17:37:34.848]   .. ..$ : int 3
[17:37:34.848]  $ ...future.seeds_ii       : NULL
[17:37:34.848]  $ ...future.globals.maxSize: NULL
[17:37:34.848]  - attr(*, "where")=List of 5
[17:37:34.848]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.848]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.848]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.848]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.848]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.848]  - attr(*, "resolved")= logi FALSE
[17:37:34.848]  - attr(*, "total_size")= num 280
[17:37:34.848]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.848]  - attr(*, "already-done")= logi TRUE
[17:37:34.854] - copied ‘...future.FUN’ to environment
[17:37:34.854] - copied ‘MoreArgs’ to environment
[17:37:34.854] - copied ‘...future.elements_ii’ to environment
[17:37:34.854] - copied ‘...future.seeds_ii’ to environment
[17:37:34.854] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.855] assign_globals() ... done
[17:37:34.855] requestCore(): workers = 2
[17:37:34.857] MulticoreFuture started
[17:37:34.857] - Launch lazy future ... done
[17:37:34.857] run() for ‘MulticoreFuture’ ... done
[17:37:34.858] Created future:
[17:37:34.858] plan(): Setting new future strategy stack:
[17:37:34.858] List of future strategies:
[17:37:34.858] 1. sequential:
[17:37:34.858]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.858]    - tweaked: FALSE
[17:37:34.858]    - call: NULL
[17:37:34.859] plan(): nbrOfWorkers() = 1
[17:37:34.861] plan(): Setting new future strategy stack:
[17:37:34.861] List of future strategies:
[17:37:34.861] 1. multicore:
[17:37:34.861]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:34.861]    - tweaked: FALSE
[17:37:34.861]    - call: plan(strategy)
[17:37:34.867] plan(): nbrOfWorkers() = 2
[17:37:34.858] MulticoreFuture:
[17:37:34.858] Label: ‘future_mapply-1’
[17:37:34.858] Expression:
[17:37:34.858] {
[17:37:34.858]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.858]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.858]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.858]         on.exit(options(oopts), add = TRUE)
[17:37:34.858]     }
[17:37:34.858]     {
[17:37:34.858]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.858]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.858]         do.call(mapply, args = args)
[17:37:34.858]     }
[17:37:34.858] }
[17:37:34.858] Lazy evaluation: FALSE
[17:37:34.858] Asynchronous evaluation: TRUE
[17:37:34.858] Local evaluation: TRUE
[17:37:34.858] Environment: R_GlobalEnv
[17:37:34.858] Capture standard output: TRUE
[17:37:34.858] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.858] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.858] Packages: <none>
[17:37:34.858] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.858] Resolved: TRUE
[17:37:34.858] Value: <not collected>
[17:37:34.858] Conditions captured: <none>
[17:37:34.858] Early signaling: FALSE
[17:37:34.858] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.858] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:34.868] Chunk #1 of 2 ... DONE
[17:37:34.868] Chunk #2 of 2 ...
[17:37:34.869]  - Finding globals in '...' for chunk #2 ...
[17:37:34.869] getGlobalsAndPackages() ...
[17:37:34.869] Searching for globals...
[17:37:34.869] 
[17:37:34.870] Searching for globals ... DONE
[17:37:34.870] - globals: [0] <none>
[17:37:34.870] getGlobalsAndPackages() ... DONE
[17:37:34.870]    + additional globals found: [n=0] 
[17:37:34.870]    + additional namespaces needed: [n=0] 
[17:37:34.870]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:34.870]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:34.870]  - seeds: <none>
[17:37:34.871]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.871] getGlobalsAndPackages() ...
[17:37:34.871] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.871] Resolving globals: FALSE
[17:37:34.872] The total size of the 5 globals is 280 bytes (280 bytes)
[17:37:34.873] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:34.873] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.873] 
[17:37:34.873] getGlobalsAndPackages() ... DONE
[17:37:34.874] run() for ‘Future’ ...
[17:37:34.874] - state: ‘created’
[17:37:34.874] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:34.879] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:34.879] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:34.879]   - Field: ‘label’
[17:37:34.879]   - Field: ‘local’
[17:37:34.879]   - Field: ‘owner’
[17:37:34.880]   - Field: ‘envir’
[17:37:34.880]   - Field: ‘workers’
[17:37:34.880]   - Field: ‘packages’
[17:37:34.880]   - Field: ‘gc’
[17:37:34.880]   - Field: ‘job’
[17:37:34.880]   - Field: ‘conditions’
[17:37:34.881]   - Field: ‘expr’
[17:37:34.881]   - Field: ‘uuid’
[17:37:34.881]   - Field: ‘seed’
[17:37:34.881]   - Field: ‘version’
[17:37:34.881]   - Field: ‘result’
[17:37:34.881]   - Field: ‘asynchronous’
[17:37:34.881]   - Field: ‘calls’
[17:37:34.882]   - Field: ‘globals’
[17:37:34.882]   - Field: ‘stdout’
[17:37:34.882]   - Field: ‘earlySignal’
[17:37:34.882]   - Field: ‘lazy’
[17:37:34.882]   - Field: ‘state’
[17:37:34.882] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:34.882] - Launch lazy future ...
[17:37:34.883] Packages needed by the future expression (n = 0): <none>
[17:37:34.883] Packages needed by future strategies (n = 0): <none>
[17:37:34.884] {
[17:37:34.884]     {
[17:37:34.884]         {
[17:37:34.884]             ...future.startTime <- base::Sys.time()
[17:37:34.884]             {
[17:37:34.884]                 {
[17:37:34.884]                   {
[17:37:34.884]                     {
[17:37:34.884]                       base::local({
[17:37:34.884]                         has_future <- base::requireNamespace("future", 
[17:37:34.884]                           quietly = TRUE)
[17:37:34.884]                         if (has_future) {
[17:37:34.884]                           ns <- base::getNamespace("future")
[17:37:34.884]                           version <- ns[[".package"]][["version"]]
[17:37:34.884]                           if (is.null(version)) 
[17:37:34.884]                             version <- utils::packageVersion("future")
[17:37:34.884]                         }
[17:37:34.884]                         else {
[17:37:34.884]                           version <- NULL
[17:37:34.884]                         }
[17:37:34.884]                         if (!has_future || version < "1.8.0") {
[17:37:34.884]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.884]                             "", base::R.version$version.string), 
[17:37:34.884]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:34.884]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.884]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.884]                               "release", "version")], collapse = " "), 
[17:37:34.884]                             hostname = base::Sys.info()[["nodename"]])
[17:37:34.884]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.884]                             info)
[17:37:34.884]                           info <- base::paste(info, collapse = "; ")
[17:37:34.884]                           if (!has_future) {
[17:37:34.884]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.884]                               info)
[17:37:34.884]                           }
[17:37:34.884]                           else {
[17:37:34.884]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.884]                               info, version)
[17:37:34.884]                           }
[17:37:34.884]                           base::stop(msg)
[17:37:34.884]                         }
[17:37:34.884]                       })
[17:37:34.884]                     }
[17:37:34.884]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:34.884]                     base::options(mc.cores = 1L)
[17:37:34.884]                   }
[17:37:34.884]                   ...future.strategy.old <- future::plan("list")
[17:37:34.884]                   options(future.plan = NULL)
[17:37:34.884]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.884]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.884]                 }
[17:37:34.884]                 ...future.workdir <- getwd()
[17:37:34.884]             }
[17:37:34.884]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.884]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.884]         }
[17:37:34.884]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.884]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:34.884]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.884]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.884]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.884]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.884]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.884]             base::names(...future.oldOptions))
[17:37:34.884]     }
[17:37:34.884]     if (FALSE) {
[17:37:34.884]     }
[17:37:34.884]     else {
[17:37:34.884]         if (TRUE) {
[17:37:34.884]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.884]                 open = "w")
[17:37:34.884]         }
[17:37:34.884]         else {
[17:37:34.884]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.884]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.884]         }
[17:37:34.884]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.884]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.884]             base::sink(type = "output", split = FALSE)
[17:37:34.884]             base::close(...future.stdout)
[17:37:34.884]         }, add = TRUE)
[17:37:34.884]     }
[17:37:34.884]     ...future.frame <- base::sys.nframe()
[17:37:34.884]     ...future.conditions <- base::list()
[17:37:34.884]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.884]     if (FALSE) {
[17:37:34.884]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.884]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.884]     }
[17:37:34.884]     ...future.result <- base::tryCatch({
[17:37:34.884]         base::withCallingHandlers({
[17:37:34.884]             ...future.value <- base::withVisible(base::local({
[17:37:34.884]                 withCallingHandlers({
[17:37:34.884]                   {
[17:37:34.884]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.884]                     if (!identical(...future.globals.maxSize.org, 
[17:37:34.884]                       ...future.globals.maxSize)) {
[17:37:34.884]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.884]                       on.exit(options(oopts), add = TRUE)
[17:37:34.884]                     }
[17:37:34.884]                     {
[17:37:34.884]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.884]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.884]                         USE.NAMES = FALSE)
[17:37:34.884]                       do.call(mapply, args = args)
[17:37:34.884]                     }
[17:37:34.884]                   }
[17:37:34.884]                 }, immediateCondition = function(cond) {
[17:37:34.884]                   save_rds <- function (object, pathname, ...) 
[17:37:34.884]                   {
[17:37:34.884]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:34.884]                     if (file_test("-f", pathname_tmp)) {
[17:37:34.884]                       fi_tmp <- file.info(pathname_tmp)
[17:37:34.884]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:34.884]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:34.884]                         fi_tmp[["mtime"]])
[17:37:34.884]                     }
[17:37:34.884]                     tryCatch({
[17:37:34.884]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:34.884]                     }, error = function(ex) {
[17:37:34.884]                       msg <- conditionMessage(ex)
[17:37:34.884]                       fi_tmp <- file.info(pathname_tmp)
[17:37:34.884]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:34.884]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:34.884]                         fi_tmp[["mtime"]], msg)
[17:37:34.884]                       ex$message <- msg
[17:37:34.884]                       stop(ex)
[17:37:34.884]                     })
[17:37:34.884]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:34.884]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:34.884]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:34.884]                       fi_tmp <- file.info(pathname_tmp)
[17:37:34.884]                       fi <- file.info(pathname)
[17:37:34.884]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:34.884]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:34.884]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:34.884]                         fi[["size"]], fi[["mtime"]])
[17:37:34.884]                       stop(msg)
[17:37:34.884]                     }
[17:37:34.884]                     invisible(pathname)
[17:37:34.884]                   }
[17:37:34.884]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:34.884]                     rootPath = tempdir()) 
[17:37:34.884]                   {
[17:37:34.884]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:34.884]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:34.884]                       tmpdir = path, fileext = ".rds")
[17:37:34.884]                     save_rds(obj, file)
[17:37:34.884]                   }
[17:37:34.884]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:34.884]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.884]                   {
[17:37:34.884]                     inherits <- base::inherits
[17:37:34.884]                     invokeRestart <- base::invokeRestart
[17:37:34.884]                     is.null <- base::is.null
[17:37:34.884]                     muffled <- FALSE
[17:37:34.884]                     if (inherits(cond, "message")) {
[17:37:34.884]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:34.884]                       if (muffled) 
[17:37:34.884]                         invokeRestart("muffleMessage")
[17:37:34.884]                     }
[17:37:34.884]                     else if (inherits(cond, "warning")) {
[17:37:34.884]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:34.884]                       if (muffled) 
[17:37:34.884]                         invokeRestart("muffleWarning")
[17:37:34.884]                     }
[17:37:34.884]                     else if (inherits(cond, "condition")) {
[17:37:34.884]                       if (!is.null(pattern)) {
[17:37:34.884]                         computeRestarts <- base::computeRestarts
[17:37:34.884]                         grepl <- base::grepl
[17:37:34.884]                         restarts <- computeRestarts(cond)
[17:37:34.884]                         for (restart in restarts) {
[17:37:34.884]                           name <- restart$name
[17:37:34.884]                           if (is.null(name)) 
[17:37:34.884]                             next
[17:37:34.884]                           if (!grepl(pattern, name)) 
[17:37:34.884]                             next
[17:37:34.884]                           invokeRestart(restart)
[17:37:34.884]                           muffled <- TRUE
[17:37:34.884]                           break
[17:37:34.884]                         }
[17:37:34.884]                       }
[17:37:34.884]                     }
[17:37:34.884]                     invisible(muffled)
[17:37:34.884]                   }
[17:37:34.884]                   muffleCondition(cond)
[17:37:34.884]                 })
[17:37:34.884]             }))
[17:37:34.884]             future::FutureResult(value = ...future.value$value, 
[17:37:34.884]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.884]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.884]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.884]                     ...future.globalenv.names))
[17:37:34.884]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.884]         }, condition = base::local({
[17:37:34.884]             c <- base::c
[17:37:34.884]             inherits <- base::inherits
[17:37:34.884]             invokeRestart <- base::invokeRestart
[17:37:34.884]             length <- base::length
[17:37:34.884]             list <- base::list
[17:37:34.884]             seq.int <- base::seq.int
[17:37:34.884]             signalCondition <- base::signalCondition
[17:37:34.884]             sys.calls <- base::sys.calls
[17:37:34.884]             `[[` <- base::`[[`
[17:37:34.884]             `+` <- base::`+`
[17:37:34.884]             `<<-` <- base::`<<-`
[17:37:34.884]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.884]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.884]                   3L)]
[17:37:34.884]             }
[17:37:34.884]             function(cond) {
[17:37:34.884]                 is_error <- inherits(cond, "error")
[17:37:34.884]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.884]                   NULL)
[17:37:34.884]                 if (is_error) {
[17:37:34.884]                   sessionInformation <- function() {
[17:37:34.884]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.884]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.884]                       search = base::search(), system = base::Sys.info())
[17:37:34.884]                   }
[17:37:34.884]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.884]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.884]                     cond$call), session = sessionInformation(), 
[17:37:34.884]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.884]                   signalCondition(cond)
[17:37:34.884]                 }
[17:37:34.884]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.884]                 "immediateCondition"))) {
[17:37:34.884]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.884]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.884]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.884]                   if (TRUE && !signal) {
[17:37:34.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.884]                     {
[17:37:34.884]                       inherits <- base::inherits
[17:37:34.884]                       invokeRestart <- base::invokeRestart
[17:37:34.884]                       is.null <- base::is.null
[17:37:34.884]                       muffled <- FALSE
[17:37:34.884]                       if (inherits(cond, "message")) {
[17:37:34.884]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.884]                         if (muffled) 
[17:37:34.884]                           invokeRestart("muffleMessage")
[17:37:34.884]                       }
[17:37:34.884]                       else if (inherits(cond, "warning")) {
[17:37:34.884]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.884]                         if (muffled) 
[17:37:34.884]                           invokeRestart("muffleWarning")
[17:37:34.884]                       }
[17:37:34.884]                       else if (inherits(cond, "condition")) {
[17:37:34.884]                         if (!is.null(pattern)) {
[17:37:34.884]                           computeRestarts <- base::computeRestarts
[17:37:34.884]                           grepl <- base::grepl
[17:37:34.884]                           restarts <- computeRestarts(cond)
[17:37:34.884]                           for (restart in restarts) {
[17:37:34.884]                             name <- restart$name
[17:37:34.884]                             if (is.null(name)) 
[17:37:34.884]                               next
[17:37:34.884]                             if (!grepl(pattern, name)) 
[17:37:34.884]                               next
[17:37:34.884]                             invokeRestart(restart)
[17:37:34.884]                             muffled <- TRUE
[17:37:34.884]                             break
[17:37:34.884]                           }
[17:37:34.884]                         }
[17:37:34.884]                       }
[17:37:34.884]                       invisible(muffled)
[17:37:34.884]                     }
[17:37:34.884]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.884]                   }
[17:37:34.884]                 }
[17:37:34.884]                 else {
[17:37:34.884]                   if (TRUE) {
[17:37:34.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.884]                     {
[17:37:34.884]                       inherits <- base::inherits
[17:37:34.884]                       invokeRestart <- base::invokeRestart
[17:37:34.884]                       is.null <- base::is.null
[17:37:34.884]                       muffled <- FALSE
[17:37:34.884]                       if (inherits(cond, "message")) {
[17:37:34.884]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.884]                         if (muffled) 
[17:37:34.884]                           invokeRestart("muffleMessage")
[17:37:34.884]                       }
[17:37:34.884]                       else if (inherits(cond, "warning")) {
[17:37:34.884]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.884]                         if (muffled) 
[17:37:34.884]                           invokeRestart("muffleWarning")
[17:37:34.884]                       }
[17:37:34.884]                       else if (inherits(cond, "condition")) {
[17:37:34.884]                         if (!is.null(pattern)) {
[17:37:34.884]                           computeRestarts <- base::computeRestarts
[17:37:34.884]                           grepl <- base::grepl
[17:37:34.884]                           restarts <- computeRestarts(cond)
[17:37:34.884]                           for (restart in restarts) {
[17:37:34.884]                             name <- restart$name
[17:37:34.884]                             if (is.null(name)) 
[17:37:34.884]                               next
[17:37:34.884]                             if (!grepl(pattern, name)) 
[17:37:34.884]                               next
[17:37:34.884]                             invokeRestart(restart)
[17:37:34.884]                             muffled <- TRUE
[17:37:34.884]                             break
[17:37:34.884]                           }
[17:37:34.884]                         }
[17:37:34.884]                       }
[17:37:34.884]                       invisible(muffled)
[17:37:34.884]                     }
[17:37:34.884]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.884]                   }
[17:37:34.884]                 }
[17:37:34.884]             }
[17:37:34.884]         }))
[17:37:34.884]     }, error = function(ex) {
[17:37:34.884]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.884]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.884]                 ...future.rng), started = ...future.startTime, 
[17:37:34.884]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.884]             version = "1.8"), class = "FutureResult")
[17:37:34.884]     }, finally = {
[17:37:34.884]         if (!identical(...future.workdir, getwd())) 
[17:37:34.884]             setwd(...future.workdir)
[17:37:34.884]         {
[17:37:34.884]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.884]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.884]             }
[17:37:34.884]             base::options(...future.oldOptions)
[17:37:34.884]             if (.Platform$OS.type == "windows") {
[17:37:34.884]                 old_names <- names(...future.oldEnvVars)
[17:37:34.884]                 envs <- base::Sys.getenv()
[17:37:34.884]                 names <- names(envs)
[17:37:34.884]                 common <- intersect(names, old_names)
[17:37:34.884]                 added <- setdiff(names, old_names)
[17:37:34.884]                 removed <- setdiff(old_names, names)
[17:37:34.884]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.884]                   envs[common]]
[17:37:34.884]                 NAMES <- toupper(changed)
[17:37:34.884]                 args <- list()
[17:37:34.884]                 for (kk in seq_along(NAMES)) {
[17:37:34.884]                   name <- changed[[kk]]
[17:37:34.884]                   NAME <- NAMES[[kk]]
[17:37:34.884]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.884]                     next
[17:37:34.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.884]                 }
[17:37:34.884]                 NAMES <- toupper(added)
[17:37:34.884]                 for (kk in seq_along(NAMES)) {
[17:37:34.884]                   name <- added[[kk]]
[17:37:34.884]                   NAME <- NAMES[[kk]]
[17:37:34.884]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.884]                     next
[17:37:34.884]                   args[[name]] <- ""
[17:37:34.884]                 }
[17:37:34.884]                 NAMES <- toupper(removed)
[17:37:34.884]                 for (kk in seq_along(NAMES)) {
[17:37:34.884]                   name <- removed[[kk]]
[17:37:34.884]                   NAME <- NAMES[[kk]]
[17:37:34.884]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.884]                     next
[17:37:34.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.884]                 }
[17:37:34.884]                 if (length(args) > 0) 
[17:37:34.884]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.884]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.884]             }
[17:37:34.884]             else {
[17:37:34.884]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.884]             }
[17:37:34.884]             {
[17:37:34.884]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.884]                   0L) {
[17:37:34.884]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.884]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.884]                   base::options(opts)
[17:37:34.884]                 }
[17:37:34.884]                 {
[17:37:34.884]                   {
[17:37:34.884]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:34.884]                     NULL
[17:37:34.884]                   }
[17:37:34.884]                   options(future.plan = NULL)
[17:37:34.884]                   if (is.na(NA_character_)) 
[17:37:34.884]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.884]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.884]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.884]                     .init = FALSE)
[17:37:34.884]                 }
[17:37:34.884]             }
[17:37:34.884]         }
[17:37:34.884]     })
[17:37:34.884]     if (TRUE) {
[17:37:34.884]         base::sink(type = "output", split = FALSE)
[17:37:34.884]         if (TRUE) {
[17:37:34.884]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.884]         }
[17:37:34.884]         else {
[17:37:34.884]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.884]         }
[17:37:34.884]         base::close(...future.stdout)
[17:37:34.884]         ...future.stdout <- NULL
[17:37:34.884]     }
[17:37:34.884]     ...future.result$conditions <- ...future.conditions
[17:37:34.884]     ...future.result$finished <- base::Sys.time()
[17:37:34.884]     ...future.result
[17:37:34.884] }
[17:37:34.887] assign_globals() ...
[17:37:34.887] List of 5
[17:37:34.887]  $ ...future.FUN            :function (x, ...)  
[17:37:34.887]  $ MoreArgs                 : NULL
[17:37:34.887]  $ ...future.elements_ii    :List of 2
[17:37:34.887]   ..$ :List of 2
[17:37:34.887]   .. ..$ : int 3
[17:37:34.887]   .. ..$ : int 4
[17:37:34.887]   ..$ :List of 2
[17:37:34.887]   .. ..$ : int 2
[17:37:34.887]   .. ..$ : int 1
[17:37:34.887]  $ ...future.seeds_ii       : NULL
[17:37:34.887]  $ ...future.globals.maxSize: NULL
[17:37:34.887]  - attr(*, "where")=List of 5
[17:37:34.887]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.887]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.887]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.887]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.887]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.887]  - attr(*, "resolved")= logi FALSE
[17:37:34.887]  - attr(*, "total_size")= num 280
[17:37:34.887]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.887]  - attr(*, "already-done")= logi TRUE
[17:37:34.901] - copied ‘...future.FUN’ to environment
[17:37:34.901] - copied ‘MoreArgs’ to environment
[17:37:34.901] - copied ‘...future.elements_ii’ to environment
[17:37:34.901] - copied ‘...future.seeds_ii’ to environment
[17:37:34.901] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.902] assign_globals() ... done
[17:37:34.902] requestCore(): workers = 2
[17:37:34.904] MulticoreFuture started
[17:37:34.905] - Launch lazy future ... done
[17:37:34.905] run() for ‘MulticoreFuture’ ... done
[17:37:34.905] Created future:
[17:37:34.905] plan(): Setting new future strategy stack:
[17:37:34.906] List of future strategies:
[17:37:34.906] 1. sequential:
[17:37:34.906]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.906]    - tweaked: FALSE
[17:37:34.906]    - call: NULL
[17:37:34.907] plan(): nbrOfWorkers() = 1
[17:37:34.909] plan(): Setting new future strategy stack:
[17:37:34.910] List of future strategies:
[17:37:34.910] 1. multicore:
[17:37:34.910]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:34.910]    - tweaked: FALSE
[17:37:34.910]    - call: plan(strategy)
[17:37:34.915] plan(): nbrOfWorkers() = 2
[17:37:34.906] MulticoreFuture:
[17:37:34.906] Label: ‘future_mapply-2’
[17:37:34.906] Expression:
[17:37:34.906] {
[17:37:34.906]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.906]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.906]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.906]         on.exit(options(oopts), add = TRUE)
[17:37:34.906]     }
[17:37:34.906]     {
[17:37:34.906]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.906]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.906]         do.call(mapply, args = args)
[17:37:34.906]     }
[17:37:34.906] }
[17:37:34.906] Lazy evaluation: FALSE
[17:37:34.906] Asynchronous evaluation: TRUE
[17:37:34.906] Local evaluation: TRUE
[17:37:34.906] Environment: R_GlobalEnv
[17:37:34.906] Capture standard output: TRUE
[17:37:34.906] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.906] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.906] Packages: <none>
[17:37:34.906] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.906] Resolved: TRUE
[17:37:34.906] Value: <not collected>
[17:37:34.906] Conditions captured: <none>
[17:37:34.906] Early signaling: FALSE
[17:37:34.906] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.906] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:34.916] Chunk #2 of 2 ... DONE
[17:37:34.916] Launching 2 futures (chunks) ... DONE
[17:37:34.916] Resolving 2 futures (chunks) ...
[17:37:34.917] resolve() on list ...
[17:37:34.917]  recursive: 0
[17:37:34.917]  length: 2
[17:37:34.917] 
[17:37:34.918] Future #1
[17:37:34.918] result() for MulticoreFuture ...
[17:37:34.919] result() for MulticoreFuture ...
[17:37:34.919] result() for MulticoreFuture ... done
[17:37:34.919] result() for MulticoreFuture ... done
[17:37:34.919] result() for MulticoreFuture ...
[17:37:34.919] result() for MulticoreFuture ... done
[17:37:34.919] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:37:34.920] - nx: 2
[17:37:34.920] - relay: TRUE
[17:37:34.920] - stdout: TRUE
[17:37:34.920] - signal: TRUE
[17:37:34.920] - resignal: FALSE
[17:37:34.920] - force: TRUE
[17:37:34.921] - relayed: [n=2] FALSE, FALSE
[17:37:34.921] - queued futures: [n=2] FALSE, FALSE
[17:37:34.921]  - until=1
[17:37:34.921]  - relaying element #1
[17:37:34.921] result() for MulticoreFuture ...
[17:37:34.921] result() for MulticoreFuture ... done
[17:37:34.922] result() for MulticoreFuture ...
[17:37:34.922] result() for MulticoreFuture ... done
[17:37:34.922] result() for MulticoreFuture ...
[17:37:34.922] result() for MulticoreFuture ... done
[17:37:34.922] result() for MulticoreFuture ...
[17:37:34.922] result() for MulticoreFuture ... done
[17:37:34.922] - relayed: [n=2] TRUE, FALSE
[17:37:34.923] - queued futures: [n=2] TRUE, FALSE
[17:37:34.923] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:37:34.923]  length: 1 (resolved future 1)
[17:37:34.923] Future #2
[17:37:34.923] result() for MulticoreFuture ...
[17:37:34.924] result() for MulticoreFuture ...
[17:37:34.924] result() for MulticoreFuture ... done
[17:37:34.924] result() for MulticoreFuture ... done
[17:37:34.925] result() for MulticoreFuture ...
[17:37:34.925] result() for MulticoreFuture ... done
[17:37:34.925] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:37:34.925] - nx: 2
[17:37:34.925] - relay: TRUE
[17:37:34.925] - stdout: TRUE
[17:37:34.925] - signal: TRUE
[17:37:34.926] - resignal: FALSE
[17:37:34.926] - force: TRUE
[17:37:34.926] - relayed: [n=2] TRUE, FALSE
[17:37:34.926] - queued futures: [n=2] TRUE, FALSE
[17:37:34.926]  - until=2
[17:37:34.926]  - relaying element #2
[17:37:34.926] result() for MulticoreFuture ...
[17:37:34.926] result() for MulticoreFuture ... done
[17:37:34.926] result() for MulticoreFuture ...
[17:37:34.927] result() for MulticoreFuture ... done
[17:37:34.927] result() for MulticoreFuture ...
[17:37:34.927] result() for MulticoreFuture ... done
[17:37:34.927] result() for MulticoreFuture ...
[17:37:34.927] result() for MulticoreFuture ... done
[17:37:34.927] - relayed: [n=2] TRUE, TRUE
[17:37:34.927] - queued futures: [n=2] TRUE, TRUE
[17:37:34.927] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:37:34.927]  length: 0 (resolved future 2)
[17:37:34.928] Relaying remaining futures
[17:37:34.928] signalConditionsASAP(NULL, pos=0) ...
[17:37:34.928] - nx: 2
[17:37:34.928] - relay: TRUE
[17:37:34.928] - stdout: TRUE
[17:37:34.928] - signal: TRUE
[17:37:34.928] - resignal: FALSE
[17:37:34.928] - force: TRUE
[17:37:34.928] - relayed: [n=2] TRUE, TRUE
[17:37:34.929] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:34.929] - relayed: [n=2] TRUE, TRUE
[17:37:34.929] - queued futures: [n=2] TRUE, TRUE
[17:37:34.929] signalConditionsASAP(NULL, pos=0) ... done
[17:37:34.929] resolve() on list ... DONE
[17:37:34.929] result() for MulticoreFuture ...
[17:37:34.929] result() for MulticoreFuture ... done
[17:37:34.929] result() for MulticoreFuture ...
[17:37:34.929] result() for MulticoreFuture ... done
[17:37:34.930] result() for MulticoreFuture ...
[17:37:34.930] result() for MulticoreFuture ... done
[17:37:34.930] result() for MulticoreFuture ...
[17:37:34.930] result() for MulticoreFuture ... done
[17:37:34.930]  - Number of value chunks collected: 2
[17:37:34.930] Resolving 2 futures (chunks) ... DONE
[17:37:34.930] Reducing values from 2 chunks ...
[17:37:34.930]  - Number of values collected after concatenation: 4
[17:37:34.930]  - Number of values expected: 4
[17:37:34.931] Reducing values from 2 chunks ... DONE
[17:37:34.931] future_mapply() ... DONE
[17:37:34.931] future_mapply() ...
[17:37:34.935] Number of chunks: 2
[17:37:34.935] getGlobalsAndPackagesXApply() ...
[17:37:34.936]  - future.globals: TRUE
[17:37:34.936] getGlobalsAndPackages() ...
[17:37:34.936] Searching for globals...
[17:37:34.937] - globals found: [1] ‘FUN’
[17:37:34.937] Searching for globals ... DONE
[17:37:34.937] Resolving globals: FALSE
[17:37:34.937] The total size of the 1 globals is 56 bytes (56 bytes)
[17:37:34.938] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:37:34.938] - globals: [1] ‘FUN’
[17:37:34.938] 
[17:37:34.938] getGlobalsAndPackages() ... DONE
[17:37:34.938]  - globals found/used: [n=1] ‘FUN’
[17:37:34.938]  - needed namespaces: [n=0] 
[17:37:34.938] Finding globals ... DONE
[17:37:34.939] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:34.939] List of 2
[17:37:34.939]  $ ...future.FUN:function (x, ...)  
[17:37:34.939]  $ MoreArgs     : NULL
[17:37:34.939]  - attr(*, "where")=List of 2
[17:37:34.939]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:34.939]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:34.939]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.939]  - attr(*, "resolved")= logi FALSE
[17:37:34.939]  - attr(*, "total_size")= num NA
[17:37:34.942] Packages to be attached in all futures: [n=0] 
[17:37:34.942] getGlobalsAndPackagesXApply() ... DONE
[17:37:34.944] Number of futures (= number of chunks): 2
[17:37:34.945] Launching 2 futures (chunks) ...
[17:37:34.945] Chunk #1 of 2 ...
[17:37:34.945]  - Finding globals in '...' for chunk #1 ...
[17:37:34.945] getGlobalsAndPackages() ...
[17:37:34.945] Searching for globals...
[17:37:34.946] 
[17:37:34.946] Searching for globals ... DONE
[17:37:34.946] - globals: [0] <none>
[17:37:34.946] getGlobalsAndPackages() ... DONE
[17:37:34.946]    + additional globals found: [n=0] 
[17:37:34.946]    + additional namespaces needed: [n=0] 
[17:37:34.946]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:34.946]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:34.947]  - seeds: <none>
[17:37:34.947]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.947] getGlobalsAndPackages() ...
[17:37:34.947] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.947] Resolving globals: FALSE
[17:37:34.948] The total size of the 5 globals is 280 bytes (280 bytes)
[17:37:34.948] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:34.949] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.949] 
[17:37:34.949] getGlobalsAndPackages() ... DONE
[17:37:34.949] run() for ‘Future’ ...
[17:37:34.949] - state: ‘created’
[17:37:34.950] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:34.953] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:34.953] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:34.954]   - Field: ‘label’
[17:37:34.954]   - Field: ‘local’
[17:37:34.954]   - Field: ‘owner’
[17:37:34.954]   - Field: ‘envir’
[17:37:34.954]   - Field: ‘workers’
[17:37:34.954]   - Field: ‘packages’
[17:37:34.954]   - Field: ‘gc’
[17:37:34.954]   - Field: ‘job’
[17:37:34.954]   - Field: ‘conditions’
[17:37:34.954]   - Field: ‘expr’
[17:37:34.954]   - Field: ‘uuid’
[17:37:34.955]   - Field: ‘seed’
[17:37:34.955]   - Field: ‘version’
[17:37:34.955]   - Field: ‘result’
[17:37:34.955]   - Field: ‘asynchronous’
[17:37:34.955]   - Field: ‘calls’
[17:37:34.955]   - Field: ‘globals’
[17:37:34.955]   - Field: ‘stdout’
[17:37:34.955]   - Field: ‘earlySignal’
[17:37:34.955]   - Field: ‘lazy’
[17:37:34.955]   - Field: ‘state’
[17:37:34.955] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:34.956] - Launch lazy future ...
[17:37:34.956] Packages needed by the future expression (n = 0): <none>
[17:37:34.956] Packages needed by future strategies (n = 0): <none>
[17:37:34.956] {
[17:37:34.956]     {
[17:37:34.956]         {
[17:37:34.956]             ...future.startTime <- base::Sys.time()
[17:37:34.956]             {
[17:37:34.956]                 {
[17:37:34.956]                   {
[17:37:34.956]                     {
[17:37:34.956]                       base::local({
[17:37:34.956]                         has_future <- base::requireNamespace("future", 
[17:37:34.956]                           quietly = TRUE)
[17:37:34.956]                         if (has_future) {
[17:37:34.956]                           ns <- base::getNamespace("future")
[17:37:34.956]                           version <- ns[[".package"]][["version"]]
[17:37:34.956]                           if (is.null(version)) 
[17:37:34.956]                             version <- utils::packageVersion("future")
[17:37:34.956]                         }
[17:37:34.956]                         else {
[17:37:34.956]                           version <- NULL
[17:37:34.956]                         }
[17:37:34.956]                         if (!has_future || version < "1.8.0") {
[17:37:34.956]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:34.956]                             "", base::R.version$version.string), 
[17:37:34.956]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:34.956]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:34.956]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:34.956]                               "release", "version")], collapse = " "), 
[17:37:34.956]                             hostname = base::Sys.info()[["nodename"]])
[17:37:34.956]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:34.956]                             info)
[17:37:34.956]                           info <- base::paste(info, collapse = "; ")
[17:37:34.956]                           if (!has_future) {
[17:37:34.956]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:34.956]                               info)
[17:37:34.956]                           }
[17:37:34.956]                           else {
[17:37:34.956]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:34.956]                               info, version)
[17:37:34.956]                           }
[17:37:34.956]                           base::stop(msg)
[17:37:34.956]                         }
[17:37:34.956]                       })
[17:37:34.956]                     }
[17:37:34.956]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:34.956]                     base::options(mc.cores = 1L)
[17:37:34.956]                   }
[17:37:34.956]                   ...future.strategy.old <- future::plan("list")
[17:37:34.956]                   options(future.plan = NULL)
[17:37:34.956]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.956]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:34.956]                 }
[17:37:34.956]                 ...future.workdir <- getwd()
[17:37:34.956]             }
[17:37:34.956]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:34.956]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:34.956]         }
[17:37:34.956]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:34.956]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:34.956]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:34.956]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:34.956]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:34.956]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:34.956]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:34.956]             base::names(...future.oldOptions))
[17:37:34.956]     }
[17:37:34.956]     if (FALSE) {
[17:37:34.956]     }
[17:37:34.956]     else {
[17:37:34.956]         if (TRUE) {
[17:37:34.956]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:34.956]                 open = "w")
[17:37:34.956]         }
[17:37:34.956]         else {
[17:37:34.956]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:34.956]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:34.956]         }
[17:37:34.956]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:34.956]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:34.956]             base::sink(type = "output", split = FALSE)
[17:37:34.956]             base::close(...future.stdout)
[17:37:34.956]         }, add = TRUE)
[17:37:34.956]     }
[17:37:34.956]     ...future.frame <- base::sys.nframe()
[17:37:34.956]     ...future.conditions <- base::list()
[17:37:34.956]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:34.956]     if (FALSE) {
[17:37:34.956]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:34.956]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:34.956]     }
[17:37:34.956]     ...future.result <- base::tryCatch({
[17:37:34.956]         base::withCallingHandlers({
[17:37:34.956]             ...future.value <- base::withVisible(base::local({
[17:37:34.956]                 withCallingHandlers({
[17:37:34.956]                   {
[17:37:34.956]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.956]                     if (!identical(...future.globals.maxSize.org, 
[17:37:34.956]                       ...future.globals.maxSize)) {
[17:37:34.956]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.956]                       on.exit(options(oopts), add = TRUE)
[17:37:34.956]                     }
[17:37:34.956]                     {
[17:37:34.956]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.956]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:34.956]                         USE.NAMES = FALSE)
[17:37:34.956]                       do.call(mapply, args = args)
[17:37:34.956]                     }
[17:37:34.956]                   }
[17:37:34.956]                 }, immediateCondition = function(cond) {
[17:37:34.956]                   save_rds <- function (object, pathname, ...) 
[17:37:34.956]                   {
[17:37:34.956]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:34.956]                     if (file_test("-f", pathname_tmp)) {
[17:37:34.956]                       fi_tmp <- file.info(pathname_tmp)
[17:37:34.956]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:34.956]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:34.956]                         fi_tmp[["mtime"]])
[17:37:34.956]                     }
[17:37:34.956]                     tryCatch({
[17:37:34.956]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:34.956]                     }, error = function(ex) {
[17:37:34.956]                       msg <- conditionMessage(ex)
[17:37:34.956]                       fi_tmp <- file.info(pathname_tmp)
[17:37:34.956]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:34.956]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:34.956]                         fi_tmp[["mtime"]], msg)
[17:37:34.956]                       ex$message <- msg
[17:37:34.956]                       stop(ex)
[17:37:34.956]                     })
[17:37:34.956]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:34.956]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:34.956]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:34.956]                       fi_tmp <- file.info(pathname_tmp)
[17:37:34.956]                       fi <- file.info(pathname)
[17:37:34.956]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:34.956]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:34.956]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:34.956]                         fi[["size"]], fi[["mtime"]])
[17:37:34.956]                       stop(msg)
[17:37:34.956]                     }
[17:37:34.956]                     invisible(pathname)
[17:37:34.956]                   }
[17:37:34.956]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:34.956]                     rootPath = tempdir()) 
[17:37:34.956]                   {
[17:37:34.956]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:34.956]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:34.956]                       tmpdir = path, fileext = ".rds")
[17:37:34.956]                     save_rds(obj, file)
[17:37:34.956]                   }
[17:37:34.956]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:34.956]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.956]                   {
[17:37:34.956]                     inherits <- base::inherits
[17:37:34.956]                     invokeRestart <- base::invokeRestart
[17:37:34.956]                     is.null <- base::is.null
[17:37:34.956]                     muffled <- FALSE
[17:37:34.956]                     if (inherits(cond, "message")) {
[17:37:34.956]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:34.956]                       if (muffled) 
[17:37:34.956]                         invokeRestart("muffleMessage")
[17:37:34.956]                     }
[17:37:34.956]                     else if (inherits(cond, "warning")) {
[17:37:34.956]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:34.956]                       if (muffled) 
[17:37:34.956]                         invokeRestart("muffleWarning")
[17:37:34.956]                     }
[17:37:34.956]                     else if (inherits(cond, "condition")) {
[17:37:34.956]                       if (!is.null(pattern)) {
[17:37:34.956]                         computeRestarts <- base::computeRestarts
[17:37:34.956]                         grepl <- base::grepl
[17:37:34.956]                         restarts <- computeRestarts(cond)
[17:37:34.956]                         for (restart in restarts) {
[17:37:34.956]                           name <- restart$name
[17:37:34.956]                           if (is.null(name)) 
[17:37:34.956]                             next
[17:37:34.956]                           if (!grepl(pattern, name)) 
[17:37:34.956]                             next
[17:37:34.956]                           invokeRestart(restart)
[17:37:34.956]                           muffled <- TRUE
[17:37:34.956]                           break
[17:37:34.956]                         }
[17:37:34.956]                       }
[17:37:34.956]                     }
[17:37:34.956]                     invisible(muffled)
[17:37:34.956]                   }
[17:37:34.956]                   muffleCondition(cond)
[17:37:34.956]                 })
[17:37:34.956]             }))
[17:37:34.956]             future::FutureResult(value = ...future.value$value, 
[17:37:34.956]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.956]                   ...future.rng), globalenv = if (FALSE) 
[17:37:34.956]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:34.956]                     ...future.globalenv.names))
[17:37:34.956]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:34.956]         }, condition = base::local({
[17:37:34.956]             c <- base::c
[17:37:34.956]             inherits <- base::inherits
[17:37:34.956]             invokeRestart <- base::invokeRestart
[17:37:34.956]             length <- base::length
[17:37:34.956]             list <- base::list
[17:37:34.956]             seq.int <- base::seq.int
[17:37:34.956]             signalCondition <- base::signalCondition
[17:37:34.956]             sys.calls <- base::sys.calls
[17:37:34.956]             `[[` <- base::`[[`
[17:37:34.956]             `+` <- base::`+`
[17:37:34.956]             `<<-` <- base::`<<-`
[17:37:34.956]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:34.956]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:34.956]                   3L)]
[17:37:34.956]             }
[17:37:34.956]             function(cond) {
[17:37:34.956]                 is_error <- inherits(cond, "error")
[17:37:34.956]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:34.956]                   NULL)
[17:37:34.956]                 if (is_error) {
[17:37:34.956]                   sessionInformation <- function() {
[17:37:34.956]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:34.956]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:34.956]                       search = base::search(), system = base::Sys.info())
[17:37:34.956]                   }
[17:37:34.956]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.956]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:34.956]                     cond$call), session = sessionInformation(), 
[17:37:34.956]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:34.956]                   signalCondition(cond)
[17:37:34.956]                 }
[17:37:34.956]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:34.956]                 "immediateCondition"))) {
[17:37:34.956]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:34.956]                   ...future.conditions[[length(...future.conditions) + 
[17:37:34.956]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:34.956]                   if (TRUE && !signal) {
[17:37:34.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.956]                     {
[17:37:34.956]                       inherits <- base::inherits
[17:37:34.956]                       invokeRestart <- base::invokeRestart
[17:37:34.956]                       is.null <- base::is.null
[17:37:34.956]                       muffled <- FALSE
[17:37:34.956]                       if (inherits(cond, "message")) {
[17:37:34.956]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.956]                         if (muffled) 
[17:37:34.956]                           invokeRestart("muffleMessage")
[17:37:34.956]                       }
[17:37:34.956]                       else if (inherits(cond, "warning")) {
[17:37:34.956]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.956]                         if (muffled) 
[17:37:34.956]                           invokeRestart("muffleWarning")
[17:37:34.956]                       }
[17:37:34.956]                       else if (inherits(cond, "condition")) {
[17:37:34.956]                         if (!is.null(pattern)) {
[17:37:34.956]                           computeRestarts <- base::computeRestarts
[17:37:34.956]                           grepl <- base::grepl
[17:37:34.956]                           restarts <- computeRestarts(cond)
[17:37:34.956]                           for (restart in restarts) {
[17:37:34.956]                             name <- restart$name
[17:37:34.956]                             if (is.null(name)) 
[17:37:34.956]                               next
[17:37:34.956]                             if (!grepl(pattern, name)) 
[17:37:34.956]                               next
[17:37:34.956]                             invokeRestart(restart)
[17:37:34.956]                             muffled <- TRUE
[17:37:34.956]                             break
[17:37:34.956]                           }
[17:37:34.956]                         }
[17:37:34.956]                       }
[17:37:34.956]                       invisible(muffled)
[17:37:34.956]                     }
[17:37:34.956]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.956]                   }
[17:37:34.956]                 }
[17:37:34.956]                 else {
[17:37:34.956]                   if (TRUE) {
[17:37:34.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:34.956]                     {
[17:37:34.956]                       inherits <- base::inherits
[17:37:34.956]                       invokeRestart <- base::invokeRestart
[17:37:34.956]                       is.null <- base::is.null
[17:37:34.956]                       muffled <- FALSE
[17:37:34.956]                       if (inherits(cond, "message")) {
[17:37:34.956]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:34.956]                         if (muffled) 
[17:37:34.956]                           invokeRestart("muffleMessage")
[17:37:34.956]                       }
[17:37:34.956]                       else if (inherits(cond, "warning")) {
[17:37:34.956]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:34.956]                         if (muffled) 
[17:37:34.956]                           invokeRestart("muffleWarning")
[17:37:34.956]                       }
[17:37:34.956]                       else if (inherits(cond, "condition")) {
[17:37:34.956]                         if (!is.null(pattern)) {
[17:37:34.956]                           computeRestarts <- base::computeRestarts
[17:37:34.956]                           grepl <- base::grepl
[17:37:34.956]                           restarts <- computeRestarts(cond)
[17:37:34.956]                           for (restart in restarts) {
[17:37:34.956]                             name <- restart$name
[17:37:34.956]                             if (is.null(name)) 
[17:37:34.956]                               next
[17:37:34.956]                             if (!grepl(pattern, name)) 
[17:37:34.956]                               next
[17:37:34.956]                             invokeRestart(restart)
[17:37:34.956]                             muffled <- TRUE
[17:37:34.956]                             break
[17:37:34.956]                           }
[17:37:34.956]                         }
[17:37:34.956]                       }
[17:37:34.956]                       invisible(muffled)
[17:37:34.956]                     }
[17:37:34.956]                     muffleCondition(cond, pattern = "^muffle")
[17:37:34.956]                   }
[17:37:34.956]                 }
[17:37:34.956]             }
[17:37:34.956]         }))
[17:37:34.956]     }, error = function(ex) {
[17:37:34.956]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:34.956]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:34.956]                 ...future.rng), started = ...future.startTime, 
[17:37:34.956]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:34.956]             version = "1.8"), class = "FutureResult")
[17:37:34.956]     }, finally = {
[17:37:34.956]         if (!identical(...future.workdir, getwd())) 
[17:37:34.956]             setwd(...future.workdir)
[17:37:34.956]         {
[17:37:34.956]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:34.956]                 ...future.oldOptions$nwarnings <- NULL
[17:37:34.956]             }
[17:37:34.956]             base::options(...future.oldOptions)
[17:37:34.956]             if (.Platform$OS.type == "windows") {
[17:37:34.956]                 old_names <- names(...future.oldEnvVars)
[17:37:34.956]                 envs <- base::Sys.getenv()
[17:37:34.956]                 names <- names(envs)
[17:37:34.956]                 common <- intersect(names, old_names)
[17:37:34.956]                 added <- setdiff(names, old_names)
[17:37:34.956]                 removed <- setdiff(old_names, names)
[17:37:34.956]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:34.956]                   envs[common]]
[17:37:34.956]                 NAMES <- toupper(changed)
[17:37:34.956]                 args <- list()
[17:37:34.956]                 for (kk in seq_along(NAMES)) {
[17:37:34.956]                   name <- changed[[kk]]
[17:37:34.956]                   NAME <- NAMES[[kk]]
[17:37:34.956]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.956]                     next
[17:37:34.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.956]                 }
[17:37:34.956]                 NAMES <- toupper(added)
[17:37:34.956]                 for (kk in seq_along(NAMES)) {
[17:37:34.956]                   name <- added[[kk]]
[17:37:34.956]                   NAME <- NAMES[[kk]]
[17:37:34.956]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.956]                     next
[17:37:34.956]                   args[[name]] <- ""
[17:37:34.956]                 }
[17:37:34.956]                 NAMES <- toupper(removed)
[17:37:34.956]                 for (kk in seq_along(NAMES)) {
[17:37:34.956]                   name <- removed[[kk]]
[17:37:34.956]                   NAME <- NAMES[[kk]]
[17:37:34.956]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:34.956]                     next
[17:37:34.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:34.956]                 }
[17:37:34.956]                 if (length(args) > 0) 
[17:37:34.956]                   base::do.call(base::Sys.setenv, args = args)
[17:37:34.956]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:34.956]             }
[17:37:34.956]             else {
[17:37:34.956]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:34.956]             }
[17:37:34.956]             {
[17:37:34.956]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:34.956]                   0L) {
[17:37:34.956]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:34.956]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:34.956]                   base::options(opts)
[17:37:34.956]                 }
[17:37:34.956]                 {
[17:37:34.956]                   {
[17:37:34.956]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:34.956]                     NULL
[17:37:34.956]                   }
[17:37:34.956]                   options(future.plan = NULL)
[17:37:34.956]                   if (is.na(NA_character_)) 
[17:37:34.956]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:34.956]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:34.956]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:34.956]                     .init = FALSE)
[17:37:34.956]                 }
[17:37:34.956]             }
[17:37:34.956]         }
[17:37:34.956]     })
[17:37:34.956]     if (TRUE) {
[17:37:34.956]         base::sink(type = "output", split = FALSE)
[17:37:34.956]         if (TRUE) {
[17:37:34.956]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:34.956]         }
[17:37:34.956]         else {
[17:37:34.956]             ...future.result["stdout"] <- base::list(NULL)
[17:37:34.956]         }
[17:37:34.956]         base::close(...future.stdout)
[17:37:34.956]         ...future.stdout <- NULL
[17:37:34.956]     }
[17:37:34.956]     ...future.result$conditions <- ...future.conditions
[17:37:34.956]     ...future.result$finished <- base::Sys.time()
[17:37:34.956]     ...future.result
[17:37:34.956] }
[17:37:34.959] assign_globals() ...
[17:37:34.959] List of 5
[17:37:34.959]  $ ...future.FUN            :function (x, ...)  
[17:37:34.959]  $ MoreArgs                 : NULL
[17:37:34.959]  $ ...future.elements_ii    :List of 2
[17:37:34.959]   ..$ times:List of 2
[17:37:34.959]   .. ..$ : int 1
[17:37:34.959]   .. ..$ : int 2
[17:37:34.959]   ..$ x    :List of 2
[17:37:34.959]   .. ..$ : int 4
[17:37:34.959]   .. ..$ : int 3
[17:37:34.959]  $ ...future.seeds_ii       : NULL
[17:37:34.959]  $ ...future.globals.maxSize: NULL
[17:37:34.959]  - attr(*, "where")=List of 5
[17:37:34.959]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:34.959]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:34.959]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:34.959]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:34.959]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:34.959]  - attr(*, "resolved")= logi FALSE
[17:37:34.959]  - attr(*, "total_size")= num 280
[17:37:34.959]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:34.959]  - attr(*, "already-done")= logi TRUE
[17:37:34.965] - copied ‘...future.FUN’ to environment
[17:37:34.965] - copied ‘MoreArgs’ to environment
[17:37:34.965] - copied ‘...future.elements_ii’ to environment
[17:37:34.965] - copied ‘...future.seeds_ii’ to environment
[17:37:34.965] - copied ‘...future.globals.maxSize’ to environment
[17:37:34.965] assign_globals() ... done
[17:37:34.965] requestCore(): workers = 2
[17:37:34.967] MulticoreFuture started
[17:37:34.968] - Launch lazy future ... done
[17:37:34.968] run() for ‘MulticoreFuture’ ... done
[17:37:34.968] Created future:
[17:37:34.969] plan(): Setting new future strategy stack:
[17:37:34.969] List of future strategies:
[17:37:34.969] 1. sequential:
[17:37:34.969]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:34.969]    - tweaked: FALSE
[17:37:34.969]    - call: NULL
[17:37:34.970] plan(): nbrOfWorkers() = 1
[17:37:34.972] plan(): Setting new future strategy stack:
[17:37:34.972] List of future strategies:
[17:37:34.972] 1. multicore:
[17:37:34.972]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:34.972]    - tweaked: FALSE
[17:37:34.972]    - call: plan(strategy)
[17:37:34.977] plan(): nbrOfWorkers() = 2
[17:37:34.969] MulticoreFuture:
[17:37:34.969] Label: ‘future_mapply-1’
[17:37:34.969] Expression:
[17:37:34.969] {
[17:37:34.969]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:34.969]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:34.969]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:34.969]         on.exit(options(oopts), add = TRUE)
[17:37:34.969]     }
[17:37:34.969]     {
[17:37:34.969]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:34.969]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:34.969]         do.call(mapply, args = args)
[17:37:34.969]     }
[17:37:34.969] }
[17:37:34.969] Lazy evaluation: FALSE
[17:37:34.969] Asynchronous evaluation: TRUE
[17:37:34.969] Local evaluation: TRUE
[17:37:34.969] Environment: R_GlobalEnv
[17:37:34.969] Capture standard output: TRUE
[17:37:34.969] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:34.969] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:34.969] Packages: <none>
[17:37:34.969] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:34.969] Resolved: TRUE
[17:37:34.969] Value: <not collected>
[17:37:34.969] Conditions captured: <none>
[17:37:34.969] Early signaling: FALSE
[17:37:34.969] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:34.969] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:34.978] Chunk #1 of 2 ... DONE
[17:37:34.979] Chunk #2 of 2 ...
[17:37:34.979]  - Finding globals in '...' for chunk #2 ...
[17:37:34.979] getGlobalsAndPackages() ...
[17:37:34.979] Searching for globals...
[17:37:34.980] 
[17:37:34.980] Searching for globals ... DONE
[17:37:34.980] - globals: [0] <none>
[17:37:34.980] getGlobalsAndPackages() ... DONE
[17:37:34.980]    + additional globals found: [n=0] 
[17:37:34.980]    + additional namespaces needed: [n=0] 
[17:37:34.981]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:34.981]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:34.981]  - seeds: <none>
[17:37:34.981]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.981] getGlobalsAndPackages() ...
[17:37:34.981] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.982] Resolving globals: FALSE
[17:37:34.982] The total size of the 5 globals is 280 bytes (280 bytes)
[17:37:34.983] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:34.984] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:34.984] 
[17:37:34.984] getGlobalsAndPackages() ... DONE
[17:37:34.984] run() for ‘Future’ ...
[17:37:34.985] - state: ‘created’
[17:37:34.985] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:34.994] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:34.994] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:34.994]   - Field: ‘label’
[17:37:34.995]   - Field: ‘local’
[17:37:34.995]   - Field: ‘owner’
[17:37:34.995]   - Field: ‘envir’
[17:37:34.996]   - Field: ‘workers’
[17:37:34.996]   - Field: ‘packages’
[17:37:34.996]   - Field: ‘gc’
[17:37:34.996]   - Field: ‘job’
[17:37:34.997]   - Field: ‘conditions’
[17:37:34.997]   - Field: ‘expr’
[17:37:34.997]   - Field: ‘uuid’
[17:37:34.997]   - Field: ‘seed’
[17:37:34.998]   - Field: ‘version’
[17:37:34.998]   - Field: ‘result’
[17:37:34.998]   - Field: ‘asynchronous’
[17:37:34.999]   - Field: ‘calls’
[17:37:34.999]   - Field: ‘globals’
[17:37:34.999]   - Field: ‘stdout’
[17:37:34.999]   - Field: ‘earlySignal’
[17:37:34.999]   - Field: ‘lazy’
[17:37:35.000]   - Field: ‘state’
[17:37:35.000] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:35.000] - Launch lazy future ...
[17:37:35.001] Packages needed by the future expression (n = 0): <none>
[17:37:35.001] Packages needed by future strategies (n = 0): <none>
[17:37:35.002] {
[17:37:35.002]     {
[17:37:35.002]         {
[17:37:35.002]             ...future.startTime <- base::Sys.time()
[17:37:35.002]             {
[17:37:35.002]                 {
[17:37:35.002]                   {
[17:37:35.002]                     {
[17:37:35.002]                       base::local({
[17:37:35.002]                         has_future <- base::requireNamespace("future", 
[17:37:35.002]                           quietly = TRUE)
[17:37:35.002]                         if (has_future) {
[17:37:35.002]                           ns <- base::getNamespace("future")
[17:37:35.002]                           version <- ns[[".package"]][["version"]]
[17:37:35.002]                           if (is.null(version)) 
[17:37:35.002]                             version <- utils::packageVersion("future")
[17:37:35.002]                         }
[17:37:35.002]                         else {
[17:37:35.002]                           version <- NULL
[17:37:35.002]                         }
[17:37:35.002]                         if (!has_future || version < "1.8.0") {
[17:37:35.002]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:35.002]                             "", base::R.version$version.string), 
[17:37:35.002]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:35.002]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:35.002]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:35.002]                               "release", "version")], collapse = " "), 
[17:37:35.002]                             hostname = base::Sys.info()[["nodename"]])
[17:37:35.002]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:35.002]                             info)
[17:37:35.002]                           info <- base::paste(info, collapse = "; ")
[17:37:35.002]                           if (!has_future) {
[17:37:35.002]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:35.002]                               info)
[17:37:35.002]                           }
[17:37:35.002]                           else {
[17:37:35.002]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:35.002]                               info, version)
[17:37:35.002]                           }
[17:37:35.002]                           base::stop(msg)
[17:37:35.002]                         }
[17:37:35.002]                       })
[17:37:35.002]                     }
[17:37:35.002]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:35.002]                     base::options(mc.cores = 1L)
[17:37:35.002]                   }
[17:37:35.002]                   ...future.strategy.old <- future::plan("list")
[17:37:35.002]                   options(future.plan = NULL)
[17:37:35.002]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.002]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:35.002]                 }
[17:37:35.002]                 ...future.workdir <- getwd()
[17:37:35.002]             }
[17:37:35.002]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:35.002]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:35.002]         }
[17:37:35.002]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:35.002]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:35.002]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:35.002]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:35.002]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:35.002]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:35.002]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:35.002]             base::names(...future.oldOptions))
[17:37:35.002]     }
[17:37:35.002]     if (FALSE) {
[17:37:35.002]     }
[17:37:35.002]     else {
[17:37:35.002]         if (TRUE) {
[17:37:35.002]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:35.002]                 open = "w")
[17:37:35.002]         }
[17:37:35.002]         else {
[17:37:35.002]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:35.002]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:35.002]         }
[17:37:35.002]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:35.002]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:35.002]             base::sink(type = "output", split = FALSE)
[17:37:35.002]             base::close(...future.stdout)
[17:37:35.002]         }, add = TRUE)
[17:37:35.002]     }
[17:37:35.002]     ...future.frame <- base::sys.nframe()
[17:37:35.002]     ...future.conditions <- base::list()
[17:37:35.002]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:35.002]     if (FALSE) {
[17:37:35.002]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:35.002]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:35.002]     }
[17:37:35.002]     ...future.result <- base::tryCatch({
[17:37:35.002]         base::withCallingHandlers({
[17:37:35.002]             ...future.value <- base::withVisible(base::local({
[17:37:35.002]                 withCallingHandlers({
[17:37:35.002]                   {
[17:37:35.002]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.002]                     if (!identical(...future.globals.maxSize.org, 
[17:37:35.002]                       ...future.globals.maxSize)) {
[17:37:35.002]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.002]                       on.exit(options(oopts), add = TRUE)
[17:37:35.002]                     }
[17:37:35.002]                     {
[17:37:35.002]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.002]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:35.002]                         USE.NAMES = FALSE)
[17:37:35.002]                       do.call(mapply, args = args)
[17:37:35.002]                     }
[17:37:35.002]                   }
[17:37:35.002]                 }, immediateCondition = function(cond) {
[17:37:35.002]                   save_rds <- function (object, pathname, ...) 
[17:37:35.002]                   {
[17:37:35.002]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:35.002]                     if (file_test("-f", pathname_tmp)) {
[17:37:35.002]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.002]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:35.002]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.002]                         fi_tmp[["mtime"]])
[17:37:35.002]                     }
[17:37:35.002]                     tryCatch({
[17:37:35.002]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:35.002]                     }, error = function(ex) {
[17:37:35.002]                       msg <- conditionMessage(ex)
[17:37:35.002]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.002]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:35.002]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.002]                         fi_tmp[["mtime"]], msg)
[17:37:35.002]                       ex$message <- msg
[17:37:35.002]                       stop(ex)
[17:37:35.002]                     })
[17:37:35.002]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:35.002]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:35.002]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:35.002]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.002]                       fi <- file.info(pathname)
[17:37:35.002]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:35.002]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.002]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:35.002]                         fi[["size"]], fi[["mtime"]])
[17:37:35.002]                       stop(msg)
[17:37:35.002]                     }
[17:37:35.002]                     invisible(pathname)
[17:37:35.002]                   }
[17:37:35.002]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:35.002]                     rootPath = tempdir()) 
[17:37:35.002]                   {
[17:37:35.002]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:35.002]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:35.002]                       tmpdir = path, fileext = ".rds")
[17:37:35.002]                     save_rds(obj, file)
[17:37:35.002]                   }
[17:37:35.002]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:35.002]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.002]                   {
[17:37:35.002]                     inherits <- base::inherits
[17:37:35.002]                     invokeRestart <- base::invokeRestart
[17:37:35.002]                     is.null <- base::is.null
[17:37:35.002]                     muffled <- FALSE
[17:37:35.002]                     if (inherits(cond, "message")) {
[17:37:35.002]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:35.002]                       if (muffled) 
[17:37:35.002]                         invokeRestart("muffleMessage")
[17:37:35.002]                     }
[17:37:35.002]                     else if (inherits(cond, "warning")) {
[17:37:35.002]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:35.002]                       if (muffled) 
[17:37:35.002]                         invokeRestart("muffleWarning")
[17:37:35.002]                     }
[17:37:35.002]                     else if (inherits(cond, "condition")) {
[17:37:35.002]                       if (!is.null(pattern)) {
[17:37:35.002]                         computeRestarts <- base::computeRestarts
[17:37:35.002]                         grepl <- base::grepl
[17:37:35.002]                         restarts <- computeRestarts(cond)
[17:37:35.002]                         for (restart in restarts) {
[17:37:35.002]                           name <- restart$name
[17:37:35.002]                           if (is.null(name)) 
[17:37:35.002]                             next
[17:37:35.002]                           if (!grepl(pattern, name)) 
[17:37:35.002]                             next
[17:37:35.002]                           invokeRestart(restart)
[17:37:35.002]                           muffled <- TRUE
[17:37:35.002]                           break
[17:37:35.002]                         }
[17:37:35.002]                       }
[17:37:35.002]                     }
[17:37:35.002]                     invisible(muffled)
[17:37:35.002]                   }
[17:37:35.002]                   muffleCondition(cond)
[17:37:35.002]                 })
[17:37:35.002]             }))
[17:37:35.002]             future::FutureResult(value = ...future.value$value, 
[17:37:35.002]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.002]                   ...future.rng), globalenv = if (FALSE) 
[17:37:35.002]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:35.002]                     ...future.globalenv.names))
[17:37:35.002]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:35.002]         }, condition = base::local({
[17:37:35.002]             c <- base::c
[17:37:35.002]             inherits <- base::inherits
[17:37:35.002]             invokeRestart <- base::invokeRestart
[17:37:35.002]             length <- base::length
[17:37:35.002]             list <- base::list
[17:37:35.002]             seq.int <- base::seq.int
[17:37:35.002]             signalCondition <- base::signalCondition
[17:37:35.002]             sys.calls <- base::sys.calls
[17:37:35.002]             `[[` <- base::`[[`
[17:37:35.002]             `+` <- base::`+`
[17:37:35.002]             `<<-` <- base::`<<-`
[17:37:35.002]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:35.002]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:35.002]                   3L)]
[17:37:35.002]             }
[17:37:35.002]             function(cond) {
[17:37:35.002]                 is_error <- inherits(cond, "error")
[17:37:35.002]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:35.002]                   NULL)
[17:37:35.002]                 if (is_error) {
[17:37:35.002]                   sessionInformation <- function() {
[17:37:35.002]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:35.002]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:35.002]                       search = base::search(), system = base::Sys.info())
[17:37:35.002]                   }
[17:37:35.002]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.002]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:35.002]                     cond$call), session = sessionInformation(), 
[17:37:35.002]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:35.002]                   signalCondition(cond)
[17:37:35.002]                 }
[17:37:35.002]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:35.002]                 "immediateCondition"))) {
[17:37:35.002]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:35.002]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.002]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:35.002]                   if (TRUE && !signal) {
[17:37:35.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.002]                     {
[17:37:35.002]                       inherits <- base::inherits
[17:37:35.002]                       invokeRestart <- base::invokeRestart
[17:37:35.002]                       is.null <- base::is.null
[17:37:35.002]                       muffled <- FALSE
[17:37:35.002]                       if (inherits(cond, "message")) {
[17:37:35.002]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.002]                         if (muffled) 
[17:37:35.002]                           invokeRestart("muffleMessage")
[17:37:35.002]                       }
[17:37:35.002]                       else if (inherits(cond, "warning")) {
[17:37:35.002]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.002]                         if (muffled) 
[17:37:35.002]                           invokeRestart("muffleWarning")
[17:37:35.002]                       }
[17:37:35.002]                       else if (inherits(cond, "condition")) {
[17:37:35.002]                         if (!is.null(pattern)) {
[17:37:35.002]                           computeRestarts <- base::computeRestarts
[17:37:35.002]                           grepl <- base::grepl
[17:37:35.002]                           restarts <- computeRestarts(cond)
[17:37:35.002]                           for (restart in restarts) {
[17:37:35.002]                             name <- restart$name
[17:37:35.002]                             if (is.null(name)) 
[17:37:35.002]                               next
[17:37:35.002]                             if (!grepl(pattern, name)) 
[17:37:35.002]                               next
[17:37:35.002]                             invokeRestart(restart)
[17:37:35.002]                             muffled <- TRUE
[17:37:35.002]                             break
[17:37:35.002]                           }
[17:37:35.002]                         }
[17:37:35.002]                       }
[17:37:35.002]                       invisible(muffled)
[17:37:35.002]                     }
[17:37:35.002]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.002]                   }
[17:37:35.002]                 }
[17:37:35.002]                 else {
[17:37:35.002]                   if (TRUE) {
[17:37:35.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.002]                     {
[17:37:35.002]                       inherits <- base::inherits
[17:37:35.002]                       invokeRestart <- base::invokeRestart
[17:37:35.002]                       is.null <- base::is.null
[17:37:35.002]                       muffled <- FALSE
[17:37:35.002]                       if (inherits(cond, "message")) {
[17:37:35.002]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.002]                         if (muffled) 
[17:37:35.002]                           invokeRestart("muffleMessage")
[17:37:35.002]                       }
[17:37:35.002]                       else if (inherits(cond, "warning")) {
[17:37:35.002]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.002]                         if (muffled) 
[17:37:35.002]                           invokeRestart("muffleWarning")
[17:37:35.002]                       }
[17:37:35.002]                       else if (inherits(cond, "condition")) {
[17:37:35.002]                         if (!is.null(pattern)) {
[17:37:35.002]                           computeRestarts <- base::computeRestarts
[17:37:35.002]                           grepl <- base::grepl
[17:37:35.002]                           restarts <- computeRestarts(cond)
[17:37:35.002]                           for (restart in restarts) {
[17:37:35.002]                             name <- restart$name
[17:37:35.002]                             if (is.null(name)) 
[17:37:35.002]                               next
[17:37:35.002]                             if (!grepl(pattern, name)) 
[17:37:35.002]                               next
[17:37:35.002]                             invokeRestart(restart)
[17:37:35.002]                             muffled <- TRUE
[17:37:35.002]                             break
[17:37:35.002]                           }
[17:37:35.002]                         }
[17:37:35.002]                       }
[17:37:35.002]                       invisible(muffled)
[17:37:35.002]                     }
[17:37:35.002]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.002]                   }
[17:37:35.002]                 }
[17:37:35.002]             }
[17:37:35.002]         }))
[17:37:35.002]     }, error = function(ex) {
[17:37:35.002]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:35.002]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.002]                 ...future.rng), started = ...future.startTime, 
[17:37:35.002]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:35.002]             version = "1.8"), class = "FutureResult")
[17:37:35.002]     }, finally = {
[17:37:35.002]         if (!identical(...future.workdir, getwd())) 
[17:37:35.002]             setwd(...future.workdir)
[17:37:35.002]         {
[17:37:35.002]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:35.002]                 ...future.oldOptions$nwarnings <- NULL
[17:37:35.002]             }
[17:37:35.002]             base::options(...future.oldOptions)
[17:37:35.002]             if (.Platform$OS.type == "windows") {
[17:37:35.002]                 old_names <- names(...future.oldEnvVars)
[17:37:35.002]                 envs <- base::Sys.getenv()
[17:37:35.002]                 names <- names(envs)
[17:37:35.002]                 common <- intersect(names, old_names)
[17:37:35.002]                 added <- setdiff(names, old_names)
[17:37:35.002]                 removed <- setdiff(old_names, names)
[17:37:35.002]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:35.002]                   envs[common]]
[17:37:35.002]                 NAMES <- toupper(changed)
[17:37:35.002]                 args <- list()
[17:37:35.002]                 for (kk in seq_along(NAMES)) {
[17:37:35.002]                   name <- changed[[kk]]
[17:37:35.002]                   NAME <- NAMES[[kk]]
[17:37:35.002]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.002]                     next
[17:37:35.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.002]                 }
[17:37:35.002]                 NAMES <- toupper(added)
[17:37:35.002]                 for (kk in seq_along(NAMES)) {
[17:37:35.002]                   name <- added[[kk]]
[17:37:35.002]                   NAME <- NAMES[[kk]]
[17:37:35.002]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.002]                     next
[17:37:35.002]                   args[[name]] <- ""
[17:37:35.002]                 }
[17:37:35.002]                 NAMES <- toupper(removed)
[17:37:35.002]                 for (kk in seq_along(NAMES)) {
[17:37:35.002]                   name <- removed[[kk]]
[17:37:35.002]                   NAME <- NAMES[[kk]]
[17:37:35.002]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.002]                     next
[17:37:35.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.002]                 }
[17:37:35.002]                 if (length(args) > 0) 
[17:37:35.002]                   base::do.call(base::Sys.setenv, args = args)
[17:37:35.002]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:35.002]             }
[17:37:35.002]             else {
[17:37:35.002]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:35.002]             }
[17:37:35.002]             {
[17:37:35.002]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:35.002]                   0L) {
[17:37:35.002]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:35.002]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:35.002]                   base::options(opts)
[17:37:35.002]                 }
[17:37:35.002]                 {
[17:37:35.002]                   {
[17:37:35.002]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:35.002]                     NULL
[17:37:35.002]                   }
[17:37:35.002]                   options(future.plan = NULL)
[17:37:35.002]                   if (is.na(NA_character_)) 
[17:37:35.002]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.002]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:35.002]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:35.002]                     .init = FALSE)
[17:37:35.002]                 }
[17:37:35.002]             }
[17:37:35.002]         }
[17:37:35.002]     })
[17:37:35.002]     if (TRUE) {
[17:37:35.002]         base::sink(type = "output", split = FALSE)
[17:37:35.002]         if (TRUE) {
[17:37:35.002]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:35.002]         }
[17:37:35.002]         else {
[17:37:35.002]             ...future.result["stdout"] <- base::list(NULL)
[17:37:35.002]         }
[17:37:35.002]         base::close(...future.stdout)
[17:37:35.002]         ...future.stdout <- NULL
[17:37:35.002]     }
[17:37:35.002]     ...future.result$conditions <- ...future.conditions
[17:37:35.002]     ...future.result$finished <- base::Sys.time()
[17:37:35.002]     ...future.result
[17:37:35.002] }
[17:37:35.005] assign_globals() ...
[17:37:35.005] List of 5
[17:37:35.005]  $ ...future.FUN            :function (x, ...)  
[17:37:35.005]  $ MoreArgs                 : NULL
[17:37:35.005]  $ ...future.elements_ii    :List of 2
[17:37:35.005]   ..$ times:List of 2
[17:37:35.005]   .. ..$ : int 3
[17:37:35.005]   .. ..$ : int 4
[17:37:35.005]   ..$ x    :List of 2
[17:37:35.005]   .. ..$ : int 2
[17:37:35.005]   .. ..$ : int 1
[17:37:35.005]  $ ...future.seeds_ii       : NULL
[17:37:35.005]  $ ...future.globals.maxSize: NULL
[17:37:35.005]  - attr(*, "where")=List of 5
[17:37:35.005]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:35.005]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:35.005]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:35.005]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:35.005]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:35.005]  - attr(*, "resolved")= logi FALSE
[17:37:35.005]  - attr(*, "total_size")= num 280
[17:37:35.005]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.005]  - attr(*, "already-done")= logi TRUE
[17:37:35.014] - copied ‘...future.FUN’ to environment
[17:37:35.014] - copied ‘MoreArgs’ to environment
[17:37:35.014] - copied ‘...future.elements_ii’ to environment
[17:37:35.014] - copied ‘...future.seeds_ii’ to environment
[17:37:35.014] - copied ‘...future.globals.maxSize’ to environment
[17:37:35.014] assign_globals() ... done
[17:37:35.014] requestCore(): workers = 2
[17:37:35.017] MulticoreFuture started
[17:37:35.017] - Launch lazy future ... done
[17:37:35.017] run() for ‘MulticoreFuture’ ... done
[17:37:35.018] Created future:
[17:37:35.018] plan(): Setting new future strategy stack:
[17:37:35.018] List of future strategies:
[17:37:35.018] 1. sequential:
[17:37:35.018]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:35.018]    - tweaked: FALSE
[17:37:35.018]    - call: NULL
[17:37:35.019] plan(): nbrOfWorkers() = 1
[17:37:35.021] plan(): Setting new future strategy stack:
[17:37:35.021] List of future strategies:
[17:37:35.021] 1. multicore:
[17:37:35.021]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:35.021]    - tweaked: FALSE
[17:37:35.021]    - call: plan(strategy)
[17:37:35.027] plan(): nbrOfWorkers() = 2
[17:37:35.018] MulticoreFuture:
[17:37:35.018] Label: ‘future_mapply-2’
[17:37:35.018] Expression:
[17:37:35.018] {
[17:37:35.018]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.018]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:35.018]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.018]         on.exit(options(oopts), add = TRUE)
[17:37:35.018]     }
[17:37:35.018]     {
[17:37:35.018]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.018]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:35.018]         do.call(mapply, args = args)
[17:37:35.018]     }
[17:37:35.018] }
[17:37:35.018] Lazy evaluation: FALSE
[17:37:35.018] Asynchronous evaluation: TRUE
[17:37:35.018] Local evaluation: TRUE
[17:37:35.018] Environment: R_GlobalEnv
[17:37:35.018] Capture standard output: TRUE
[17:37:35.018] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:35.018] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:35.018] Packages: <none>
[17:37:35.018] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:35.018] Resolved: TRUE
[17:37:35.018] Value: <not collected>
[17:37:35.018] Conditions captured: <none>
[17:37:35.018] Early signaling: FALSE
[17:37:35.018] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:35.018] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.028] Chunk #2 of 2 ... DONE
[17:37:35.028] Launching 2 futures (chunks) ... DONE
[17:37:35.028] Resolving 2 futures (chunks) ...
[17:37:35.029] resolve() on list ...
[17:37:35.029]  recursive: 0
[17:37:35.029]  length: 2
[17:37:35.029] 
[17:37:35.030] Future #1
[17:37:35.030] result() for MulticoreFuture ...
[17:37:35.031] result() for MulticoreFuture ...
[17:37:35.031] result() for MulticoreFuture ... done
[17:37:35.031] result() for MulticoreFuture ... done
[17:37:35.031] result() for MulticoreFuture ...
[17:37:35.031] result() for MulticoreFuture ... done
[17:37:35.032] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:37:35.032] - nx: 2
[17:37:35.032] - relay: TRUE
[17:37:35.032] - stdout: TRUE
[17:37:35.032] - signal: TRUE
[17:37:35.032] - resignal: FALSE
[17:37:35.032] - force: TRUE
[17:37:35.032] - relayed: [n=2] FALSE, FALSE
[17:37:35.033] - queued futures: [n=2] FALSE, FALSE
[17:37:35.033]  - until=1
[17:37:35.033]  - relaying element #1
[17:37:35.033] result() for MulticoreFuture ...
[17:37:35.033] result() for MulticoreFuture ... done
[17:37:35.033] result() for MulticoreFuture ...
[17:37:35.034] result() for MulticoreFuture ... done
[17:37:35.034] result() for MulticoreFuture ...
[17:37:35.034] result() for MulticoreFuture ... done
[17:37:35.034] result() for MulticoreFuture ...
[17:37:35.034] result() for MulticoreFuture ... done
[17:37:35.034] - relayed: [n=2] TRUE, FALSE
[17:37:35.035] - queued futures: [n=2] TRUE, FALSE
[17:37:35.035] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:37:35.035]  length: 1 (resolved future 1)
[17:37:35.035] Future #2
[17:37:35.036] result() for MulticoreFuture ...
[17:37:35.036] result() for MulticoreFuture ...
[17:37:35.036] result() for MulticoreFuture ... done
[17:37:35.037] result() for MulticoreFuture ... done
[17:37:35.037] result() for MulticoreFuture ...
[17:37:35.037] result() for MulticoreFuture ... done
[17:37:35.037] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:37:35.037] - nx: 2
[17:37:35.037] - relay: TRUE
[17:37:35.038] - stdout: TRUE
[17:37:35.038] - signal: TRUE
[17:37:35.038] - resignal: FALSE
[17:37:35.038] - force: TRUE
[17:37:35.038] - relayed: [n=2] TRUE, FALSE
[17:37:35.038] - queued futures: [n=2] TRUE, FALSE
[17:37:35.038]  - until=2
[17:37:35.038]  - relaying element #2
[17:37:35.039] result() for MulticoreFuture ...
[17:37:35.039] result() for MulticoreFuture ... done
[17:37:35.039] result() for MulticoreFuture ...
[17:37:35.039] result() for MulticoreFuture ... done
[17:37:35.039] result() for MulticoreFuture ...
[17:37:35.039] result() for MulticoreFuture ... done
[17:37:35.039] result() for MulticoreFuture ...
[17:37:35.039] result() for MulticoreFuture ... done
[17:37:35.040] - relayed: [n=2] TRUE, TRUE
[17:37:35.040] - queued futures: [n=2] TRUE, TRUE
[17:37:35.040] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:37:35.040]  length: 0 (resolved future 2)
[17:37:35.040] Relaying remaining futures
[17:37:35.040] signalConditionsASAP(NULL, pos=0) ...
[17:37:35.040] - nx: 2
[17:37:35.040] - relay: TRUE
[17:37:35.041] - stdout: TRUE
[17:37:35.041] - signal: TRUE
[17:37:35.041] - resignal: FALSE
[17:37:35.041] - force: TRUE
[17:37:35.041] - relayed: [n=2] TRUE, TRUE
[17:37:35.041] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:35.041] - relayed: [n=2] TRUE, TRUE
[17:37:35.041] - queued futures: [n=2] TRUE, TRUE
[17:37:35.042] signalConditionsASAP(NULL, pos=0) ... done
[17:37:35.042] resolve() on list ... DONE
[17:37:35.042] result() for MulticoreFuture ...
[17:37:35.042] result() for MulticoreFuture ... done
[17:37:35.042] result() for MulticoreFuture ...
[17:37:35.042] result() for MulticoreFuture ... done
[17:37:35.045] result() for MulticoreFuture ...
[17:37:35.045] result() for MulticoreFuture ... done
[17:37:35.045] result() for MulticoreFuture ...
[17:37:35.045] result() for MulticoreFuture ... done
[17:37:35.046]  - Number of value chunks collected: 2
[17:37:35.046] Resolving 2 futures (chunks) ... DONE
[17:37:35.046] Reducing values from 2 chunks ...
[17:37:35.046]  - Number of values collected after concatenation: 4
[17:37:35.046]  - Number of values expected: 4
[17:37:35.046] Reducing values from 2 chunks ... DONE
[17:37:35.047] future_mapply() ... DONE
[17:37:35.047] future_mapply() ...
[17:37:35.052] Number of chunks: 2
[17:37:35.052] getGlobalsAndPackagesXApply() ...
[17:37:35.053]  - future.globals: TRUE
[17:37:35.053] getGlobalsAndPackages() ...
[17:37:35.053] Searching for globals...
[17:37:35.054] - globals found: [1] ‘FUN’
[17:37:35.054] Searching for globals ... DONE
[17:37:35.054] Resolving globals: FALSE
[17:37:35.054] The total size of the 1 globals is 56 bytes (56 bytes)
[17:37:35.055] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:37:35.055] - globals: [1] ‘FUN’
[17:37:35.055] 
[17:37:35.055] getGlobalsAndPackages() ... DONE
[17:37:35.055]  - globals found/used: [n=1] ‘FUN’
[17:37:35.055]  - needed namespaces: [n=0] 
[17:37:35.056] Finding globals ... DONE
[17:37:35.056] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:35.056] List of 2
[17:37:35.056]  $ ...future.FUN:function (x, ...)  
[17:37:35.056]  $ MoreArgs     :List of 1
[17:37:35.056]   ..$ x: num 42
[17:37:35.056]  - attr(*, "where")=List of 2
[17:37:35.056]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:35.056]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:35.056]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.056]  - attr(*, "resolved")= logi FALSE
[17:37:35.056]  - attr(*, "total_size")= num NA
[17:37:35.059] Packages to be attached in all futures: [n=0] 
[17:37:35.060] getGlobalsAndPackagesXApply() ... DONE
[17:37:35.060] Number of futures (= number of chunks): 2
[17:37:35.060] Launching 2 futures (chunks) ...
[17:37:35.060] Chunk #1 of 2 ...
[17:37:35.060]  - Finding globals in '...' for chunk #1 ...
[17:37:35.060] getGlobalsAndPackages() ...
[17:37:35.060] Searching for globals...
[17:37:35.061] 
[17:37:35.061] Searching for globals ... DONE
[17:37:35.061] - globals: [0] <none>
[17:37:35.061] getGlobalsAndPackages() ... DONE
[17:37:35.061]    + additional globals found: [n=0] 
[17:37:35.061]    + additional namespaces needed: [n=0] 
[17:37:35.061]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:35.061]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:35.062]  - seeds: <none>
[17:37:35.062]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.062] getGlobalsAndPackages() ...
[17:37:35.062] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.062] Resolving globals: FALSE
[17:37:35.062] The total size of the 5 globals is 224 bytes (224 bytes)
[17:37:35.063] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:37:35.063] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.063] 
[17:37:35.063] getGlobalsAndPackages() ... DONE
[17:37:35.064] run() for ‘Future’ ...
[17:37:35.064] - state: ‘created’
[17:37:35.064] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:35.068] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.068] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:35.068]   - Field: ‘label’
[17:37:35.068]   - Field: ‘local’
[17:37:35.068]   - Field: ‘owner’
[17:37:35.068]   - Field: ‘envir’
[17:37:35.068]   - Field: ‘workers’
[17:37:35.068]   - Field: ‘packages’
[17:37:35.069]   - Field: ‘gc’
[17:37:35.069]   - Field: ‘job’
[17:37:35.069]   - Field: ‘conditions’
[17:37:35.069]   - Field: ‘expr’
[17:37:35.069]   - Field: ‘uuid’
[17:37:35.069]   - Field: ‘seed’
[17:37:35.069]   - Field: ‘version’
[17:37:35.069]   - Field: ‘result’
[17:37:35.069]   - Field: ‘asynchronous’
[17:37:35.069]   - Field: ‘calls’
[17:37:35.070]   - Field: ‘globals’
[17:37:35.070]   - Field: ‘stdout’
[17:37:35.070]   - Field: ‘earlySignal’
[17:37:35.070]   - Field: ‘lazy’
[17:37:35.070]   - Field: ‘state’
[17:37:35.070] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:35.070] - Launch lazy future ...
[17:37:35.070] Packages needed by the future expression (n = 0): <none>
[17:37:35.070] Packages needed by future strategies (n = 0): <none>
[17:37:35.071] {
[17:37:35.071]     {
[17:37:35.071]         {
[17:37:35.071]             ...future.startTime <- base::Sys.time()
[17:37:35.071]             {
[17:37:35.071]                 {
[17:37:35.071]                   {
[17:37:35.071]                     {
[17:37:35.071]                       base::local({
[17:37:35.071]                         has_future <- base::requireNamespace("future", 
[17:37:35.071]                           quietly = TRUE)
[17:37:35.071]                         if (has_future) {
[17:37:35.071]                           ns <- base::getNamespace("future")
[17:37:35.071]                           version <- ns[[".package"]][["version"]]
[17:37:35.071]                           if (is.null(version)) 
[17:37:35.071]                             version <- utils::packageVersion("future")
[17:37:35.071]                         }
[17:37:35.071]                         else {
[17:37:35.071]                           version <- NULL
[17:37:35.071]                         }
[17:37:35.071]                         if (!has_future || version < "1.8.0") {
[17:37:35.071]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:35.071]                             "", base::R.version$version.string), 
[17:37:35.071]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:35.071]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:35.071]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:35.071]                               "release", "version")], collapse = " "), 
[17:37:35.071]                             hostname = base::Sys.info()[["nodename"]])
[17:37:35.071]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:35.071]                             info)
[17:37:35.071]                           info <- base::paste(info, collapse = "; ")
[17:37:35.071]                           if (!has_future) {
[17:37:35.071]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:35.071]                               info)
[17:37:35.071]                           }
[17:37:35.071]                           else {
[17:37:35.071]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:35.071]                               info, version)
[17:37:35.071]                           }
[17:37:35.071]                           base::stop(msg)
[17:37:35.071]                         }
[17:37:35.071]                       })
[17:37:35.071]                     }
[17:37:35.071]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:35.071]                     base::options(mc.cores = 1L)
[17:37:35.071]                   }
[17:37:35.071]                   ...future.strategy.old <- future::plan("list")
[17:37:35.071]                   options(future.plan = NULL)
[17:37:35.071]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.071]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:35.071]                 }
[17:37:35.071]                 ...future.workdir <- getwd()
[17:37:35.071]             }
[17:37:35.071]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:35.071]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:35.071]         }
[17:37:35.071]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:35.071]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:35.071]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:35.071]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:35.071]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:35.071]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:35.071]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:35.071]             base::names(...future.oldOptions))
[17:37:35.071]     }
[17:37:35.071]     if (FALSE) {
[17:37:35.071]     }
[17:37:35.071]     else {
[17:37:35.071]         if (TRUE) {
[17:37:35.071]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:35.071]                 open = "w")
[17:37:35.071]         }
[17:37:35.071]         else {
[17:37:35.071]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:35.071]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:35.071]         }
[17:37:35.071]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:35.071]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:35.071]             base::sink(type = "output", split = FALSE)
[17:37:35.071]             base::close(...future.stdout)
[17:37:35.071]         }, add = TRUE)
[17:37:35.071]     }
[17:37:35.071]     ...future.frame <- base::sys.nframe()
[17:37:35.071]     ...future.conditions <- base::list()
[17:37:35.071]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:35.071]     if (FALSE) {
[17:37:35.071]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:35.071]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:35.071]     }
[17:37:35.071]     ...future.result <- base::tryCatch({
[17:37:35.071]         base::withCallingHandlers({
[17:37:35.071]             ...future.value <- base::withVisible(base::local({
[17:37:35.071]                 withCallingHandlers({
[17:37:35.071]                   {
[17:37:35.071]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.071]                     if (!identical(...future.globals.maxSize.org, 
[17:37:35.071]                       ...future.globals.maxSize)) {
[17:37:35.071]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.071]                       on.exit(options(oopts), add = TRUE)
[17:37:35.071]                     }
[17:37:35.071]                     {
[17:37:35.071]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.071]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:35.071]                         USE.NAMES = FALSE)
[17:37:35.071]                       do.call(mapply, args = args)
[17:37:35.071]                     }
[17:37:35.071]                   }
[17:37:35.071]                 }, immediateCondition = function(cond) {
[17:37:35.071]                   save_rds <- function (object, pathname, ...) 
[17:37:35.071]                   {
[17:37:35.071]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:35.071]                     if (file_test("-f", pathname_tmp)) {
[17:37:35.071]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.071]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:35.071]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.071]                         fi_tmp[["mtime"]])
[17:37:35.071]                     }
[17:37:35.071]                     tryCatch({
[17:37:35.071]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:35.071]                     }, error = function(ex) {
[17:37:35.071]                       msg <- conditionMessage(ex)
[17:37:35.071]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.071]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:35.071]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.071]                         fi_tmp[["mtime"]], msg)
[17:37:35.071]                       ex$message <- msg
[17:37:35.071]                       stop(ex)
[17:37:35.071]                     })
[17:37:35.071]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:35.071]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:35.071]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:35.071]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.071]                       fi <- file.info(pathname)
[17:37:35.071]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:35.071]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.071]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:35.071]                         fi[["size"]], fi[["mtime"]])
[17:37:35.071]                       stop(msg)
[17:37:35.071]                     }
[17:37:35.071]                     invisible(pathname)
[17:37:35.071]                   }
[17:37:35.071]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:35.071]                     rootPath = tempdir()) 
[17:37:35.071]                   {
[17:37:35.071]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:35.071]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:35.071]                       tmpdir = path, fileext = ".rds")
[17:37:35.071]                     save_rds(obj, file)
[17:37:35.071]                   }
[17:37:35.071]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:35.071]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.071]                   {
[17:37:35.071]                     inherits <- base::inherits
[17:37:35.071]                     invokeRestart <- base::invokeRestart
[17:37:35.071]                     is.null <- base::is.null
[17:37:35.071]                     muffled <- FALSE
[17:37:35.071]                     if (inherits(cond, "message")) {
[17:37:35.071]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:35.071]                       if (muffled) 
[17:37:35.071]                         invokeRestart("muffleMessage")
[17:37:35.071]                     }
[17:37:35.071]                     else if (inherits(cond, "warning")) {
[17:37:35.071]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:35.071]                       if (muffled) 
[17:37:35.071]                         invokeRestart("muffleWarning")
[17:37:35.071]                     }
[17:37:35.071]                     else if (inherits(cond, "condition")) {
[17:37:35.071]                       if (!is.null(pattern)) {
[17:37:35.071]                         computeRestarts <- base::computeRestarts
[17:37:35.071]                         grepl <- base::grepl
[17:37:35.071]                         restarts <- computeRestarts(cond)
[17:37:35.071]                         for (restart in restarts) {
[17:37:35.071]                           name <- restart$name
[17:37:35.071]                           if (is.null(name)) 
[17:37:35.071]                             next
[17:37:35.071]                           if (!grepl(pattern, name)) 
[17:37:35.071]                             next
[17:37:35.071]                           invokeRestart(restart)
[17:37:35.071]                           muffled <- TRUE
[17:37:35.071]                           break
[17:37:35.071]                         }
[17:37:35.071]                       }
[17:37:35.071]                     }
[17:37:35.071]                     invisible(muffled)
[17:37:35.071]                   }
[17:37:35.071]                   muffleCondition(cond)
[17:37:35.071]                 })
[17:37:35.071]             }))
[17:37:35.071]             future::FutureResult(value = ...future.value$value, 
[17:37:35.071]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.071]                   ...future.rng), globalenv = if (FALSE) 
[17:37:35.071]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:35.071]                     ...future.globalenv.names))
[17:37:35.071]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:35.071]         }, condition = base::local({
[17:37:35.071]             c <- base::c
[17:37:35.071]             inherits <- base::inherits
[17:37:35.071]             invokeRestart <- base::invokeRestart
[17:37:35.071]             length <- base::length
[17:37:35.071]             list <- base::list
[17:37:35.071]             seq.int <- base::seq.int
[17:37:35.071]             signalCondition <- base::signalCondition
[17:37:35.071]             sys.calls <- base::sys.calls
[17:37:35.071]             `[[` <- base::`[[`
[17:37:35.071]             `+` <- base::`+`
[17:37:35.071]             `<<-` <- base::`<<-`
[17:37:35.071]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:35.071]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:35.071]                   3L)]
[17:37:35.071]             }
[17:37:35.071]             function(cond) {
[17:37:35.071]                 is_error <- inherits(cond, "error")
[17:37:35.071]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:35.071]                   NULL)
[17:37:35.071]                 if (is_error) {
[17:37:35.071]                   sessionInformation <- function() {
[17:37:35.071]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:35.071]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:35.071]                       search = base::search(), system = base::Sys.info())
[17:37:35.071]                   }
[17:37:35.071]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.071]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:35.071]                     cond$call), session = sessionInformation(), 
[17:37:35.071]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:35.071]                   signalCondition(cond)
[17:37:35.071]                 }
[17:37:35.071]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:35.071]                 "immediateCondition"))) {
[17:37:35.071]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:35.071]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.071]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:35.071]                   if (TRUE && !signal) {
[17:37:35.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.071]                     {
[17:37:35.071]                       inherits <- base::inherits
[17:37:35.071]                       invokeRestart <- base::invokeRestart
[17:37:35.071]                       is.null <- base::is.null
[17:37:35.071]                       muffled <- FALSE
[17:37:35.071]                       if (inherits(cond, "message")) {
[17:37:35.071]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.071]                         if (muffled) 
[17:37:35.071]                           invokeRestart("muffleMessage")
[17:37:35.071]                       }
[17:37:35.071]                       else if (inherits(cond, "warning")) {
[17:37:35.071]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.071]                         if (muffled) 
[17:37:35.071]                           invokeRestart("muffleWarning")
[17:37:35.071]                       }
[17:37:35.071]                       else if (inherits(cond, "condition")) {
[17:37:35.071]                         if (!is.null(pattern)) {
[17:37:35.071]                           computeRestarts <- base::computeRestarts
[17:37:35.071]                           grepl <- base::grepl
[17:37:35.071]                           restarts <- computeRestarts(cond)
[17:37:35.071]                           for (restart in restarts) {
[17:37:35.071]                             name <- restart$name
[17:37:35.071]                             if (is.null(name)) 
[17:37:35.071]                               next
[17:37:35.071]                             if (!grepl(pattern, name)) 
[17:37:35.071]                               next
[17:37:35.071]                             invokeRestart(restart)
[17:37:35.071]                             muffled <- TRUE
[17:37:35.071]                             break
[17:37:35.071]                           }
[17:37:35.071]                         }
[17:37:35.071]                       }
[17:37:35.071]                       invisible(muffled)
[17:37:35.071]                     }
[17:37:35.071]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.071]                   }
[17:37:35.071]                 }
[17:37:35.071]                 else {
[17:37:35.071]                   if (TRUE) {
[17:37:35.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.071]                     {
[17:37:35.071]                       inherits <- base::inherits
[17:37:35.071]                       invokeRestart <- base::invokeRestart
[17:37:35.071]                       is.null <- base::is.null
[17:37:35.071]                       muffled <- FALSE
[17:37:35.071]                       if (inherits(cond, "message")) {
[17:37:35.071]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.071]                         if (muffled) 
[17:37:35.071]                           invokeRestart("muffleMessage")
[17:37:35.071]                       }
[17:37:35.071]                       else if (inherits(cond, "warning")) {
[17:37:35.071]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.071]                         if (muffled) 
[17:37:35.071]                           invokeRestart("muffleWarning")
[17:37:35.071]                       }
[17:37:35.071]                       else if (inherits(cond, "condition")) {
[17:37:35.071]                         if (!is.null(pattern)) {
[17:37:35.071]                           computeRestarts <- base::computeRestarts
[17:37:35.071]                           grepl <- base::grepl
[17:37:35.071]                           restarts <- computeRestarts(cond)
[17:37:35.071]                           for (restart in restarts) {
[17:37:35.071]                             name <- restart$name
[17:37:35.071]                             if (is.null(name)) 
[17:37:35.071]                               next
[17:37:35.071]                             if (!grepl(pattern, name)) 
[17:37:35.071]                               next
[17:37:35.071]                             invokeRestart(restart)
[17:37:35.071]                             muffled <- TRUE
[17:37:35.071]                             break
[17:37:35.071]                           }
[17:37:35.071]                         }
[17:37:35.071]                       }
[17:37:35.071]                       invisible(muffled)
[17:37:35.071]                     }
[17:37:35.071]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.071]                   }
[17:37:35.071]                 }
[17:37:35.071]             }
[17:37:35.071]         }))
[17:37:35.071]     }, error = function(ex) {
[17:37:35.071]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:35.071]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.071]                 ...future.rng), started = ...future.startTime, 
[17:37:35.071]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:35.071]             version = "1.8"), class = "FutureResult")
[17:37:35.071]     }, finally = {
[17:37:35.071]         if (!identical(...future.workdir, getwd())) 
[17:37:35.071]             setwd(...future.workdir)
[17:37:35.071]         {
[17:37:35.071]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:35.071]                 ...future.oldOptions$nwarnings <- NULL
[17:37:35.071]             }
[17:37:35.071]             base::options(...future.oldOptions)
[17:37:35.071]             if (.Platform$OS.type == "windows") {
[17:37:35.071]                 old_names <- names(...future.oldEnvVars)
[17:37:35.071]                 envs <- base::Sys.getenv()
[17:37:35.071]                 names <- names(envs)
[17:37:35.071]                 common <- intersect(names, old_names)
[17:37:35.071]                 added <- setdiff(names, old_names)
[17:37:35.071]                 removed <- setdiff(old_names, names)
[17:37:35.071]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:35.071]                   envs[common]]
[17:37:35.071]                 NAMES <- toupper(changed)
[17:37:35.071]                 args <- list()
[17:37:35.071]                 for (kk in seq_along(NAMES)) {
[17:37:35.071]                   name <- changed[[kk]]
[17:37:35.071]                   NAME <- NAMES[[kk]]
[17:37:35.071]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.071]                     next
[17:37:35.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.071]                 }
[17:37:35.071]                 NAMES <- toupper(added)
[17:37:35.071]                 for (kk in seq_along(NAMES)) {
[17:37:35.071]                   name <- added[[kk]]
[17:37:35.071]                   NAME <- NAMES[[kk]]
[17:37:35.071]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.071]                     next
[17:37:35.071]                   args[[name]] <- ""
[17:37:35.071]                 }
[17:37:35.071]                 NAMES <- toupper(removed)
[17:37:35.071]                 for (kk in seq_along(NAMES)) {
[17:37:35.071]                   name <- removed[[kk]]
[17:37:35.071]                   NAME <- NAMES[[kk]]
[17:37:35.071]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.071]                     next
[17:37:35.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.071]                 }
[17:37:35.071]                 if (length(args) > 0) 
[17:37:35.071]                   base::do.call(base::Sys.setenv, args = args)
[17:37:35.071]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:35.071]             }
[17:37:35.071]             else {
[17:37:35.071]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:35.071]             }
[17:37:35.071]             {
[17:37:35.071]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:35.071]                   0L) {
[17:37:35.071]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:35.071]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:35.071]                   base::options(opts)
[17:37:35.071]                 }
[17:37:35.071]                 {
[17:37:35.071]                   {
[17:37:35.071]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:35.071]                     NULL
[17:37:35.071]                   }
[17:37:35.071]                   options(future.plan = NULL)
[17:37:35.071]                   if (is.na(NA_character_)) 
[17:37:35.071]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.071]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:35.071]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:35.071]                     .init = FALSE)
[17:37:35.071]                 }
[17:37:35.071]             }
[17:37:35.071]         }
[17:37:35.071]     })
[17:37:35.071]     if (TRUE) {
[17:37:35.071]         base::sink(type = "output", split = FALSE)
[17:37:35.071]         if (TRUE) {
[17:37:35.071]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:35.071]         }
[17:37:35.071]         else {
[17:37:35.071]             ...future.result["stdout"] <- base::list(NULL)
[17:37:35.071]         }
[17:37:35.071]         base::close(...future.stdout)
[17:37:35.071]         ...future.stdout <- NULL
[17:37:35.071]     }
[17:37:35.071]     ...future.result$conditions <- ...future.conditions
[17:37:35.071]     ...future.result$finished <- base::Sys.time()
[17:37:35.071]     ...future.result
[17:37:35.071] }
[17:37:35.073] assign_globals() ...
[17:37:35.073] List of 5
[17:37:35.073]  $ ...future.FUN            :function (x, ...)  
[17:37:35.073]  $ MoreArgs                 :List of 1
[17:37:35.073]   ..$ x: num 42
[17:37:35.073]  $ ...future.elements_ii    :List of 1
[17:37:35.073]   ..$ times:List of 2
[17:37:35.073]   .. ..$ : int 1
[17:37:35.073]   .. ..$ : int 2
[17:37:35.073]  $ ...future.seeds_ii       : NULL
[17:37:35.073]  $ ...future.globals.maxSize: NULL
[17:37:35.073]  - attr(*, "where")=List of 5
[17:37:35.073]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:35.073]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:35.073]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:35.073]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:35.073]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:35.073]  - attr(*, "resolved")= logi FALSE
[17:37:35.073]  - attr(*, "total_size")= num 224
[17:37:35.073]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.073]  - attr(*, "already-done")= logi TRUE
[17:37:35.081] - copied ‘...future.FUN’ to environment
[17:37:35.081] - copied ‘MoreArgs’ to environment
[17:37:35.081] - copied ‘...future.elements_ii’ to environment
[17:37:35.081] - copied ‘...future.seeds_ii’ to environment
[17:37:35.082] - copied ‘...future.globals.maxSize’ to environment
[17:37:35.082] assign_globals() ... done
[17:37:35.082] requestCore(): workers = 2
[17:37:35.084] MulticoreFuture started
[17:37:35.085] - Launch lazy future ... done
[17:37:35.086] plan(): Setting new future strategy stack:
[17:37:35.085] run() for ‘MulticoreFuture’ ... done
[17:37:35.086] Created future:
[17:37:35.086] List of future strategies:
[17:37:35.086] 1. sequential:
[17:37:35.086]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:35.086]    - tweaked: FALSE
[17:37:35.086]    - call: NULL
[17:37:35.088] plan(): nbrOfWorkers() = 1
[17:37:35.090] plan(): Setting new future strategy stack:
[17:37:35.091] List of future strategies:
[17:37:35.091] 1. multicore:
[17:37:35.091]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:35.091]    - tweaked: FALSE
[17:37:35.091]    - call: plan(strategy)
[17:37:35.096] plan(): nbrOfWorkers() = 2
[17:37:35.086] MulticoreFuture:
[17:37:35.086] Label: ‘future_mapply-1’
[17:37:35.086] Expression:
[17:37:35.086] {
[17:37:35.086]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.086]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:35.086]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.086]         on.exit(options(oopts), add = TRUE)
[17:37:35.086]     }
[17:37:35.086]     {
[17:37:35.086]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.086]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:35.086]         do.call(mapply, args = args)
[17:37:35.086]     }
[17:37:35.086] }
[17:37:35.086] Lazy evaluation: FALSE
[17:37:35.086] Asynchronous evaluation: TRUE
[17:37:35.086] Local evaluation: TRUE
[17:37:35.086] Environment: R_GlobalEnv
[17:37:35.086] Capture standard output: TRUE
[17:37:35.086] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:35.086] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:35.086] Packages: <none>
[17:37:35.086] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:35.086] Resolved: TRUE
[17:37:35.086] Value: <not collected>
[17:37:35.086] Conditions captured: <none>
[17:37:35.086] Early signaling: FALSE
[17:37:35.086] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:35.086] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.097] Chunk #1 of 2 ... DONE
[17:37:35.098] Chunk #2 of 2 ...
[17:37:35.098]  - Finding globals in '...' for chunk #2 ...
[17:37:35.098] getGlobalsAndPackages() ...
[17:37:35.098] Searching for globals...
[17:37:35.099] 
[17:37:35.099] Searching for globals ... DONE
[17:37:35.099] - globals: [0] <none>
[17:37:35.099] getGlobalsAndPackages() ... DONE
[17:37:35.099]    + additional globals found: [n=0] 
[17:37:35.100]    + additional namespaces needed: [n=0] 
[17:37:35.100]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:35.100]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:35.100]  - seeds: <none>
[17:37:35.100]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.100] getGlobalsAndPackages() ...
[17:37:35.100] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.101] Resolving globals: FALSE
[17:37:35.102] The total size of the 5 globals is 224 bytes (224 bytes)
[17:37:35.102] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:37:35.103] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.103] 
[17:37:35.103] getGlobalsAndPackages() ... DONE
[17:37:35.104] run() for ‘Future’ ...
[17:37:35.104] - state: ‘created’
[17:37:35.104] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:35.109] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.109] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:35.109]   - Field: ‘label’
[17:37:35.109]   - Field: ‘local’
[17:37:35.109]   - Field: ‘owner’
[17:37:35.110]   - Field: ‘envir’
[17:37:35.110]   - Field: ‘workers’
[17:37:35.110]   - Field: ‘packages’
[17:37:35.110]   - Field: ‘gc’
[17:37:35.110]   - Field: ‘job’
[17:37:35.110]   - Field: ‘conditions’
[17:37:35.110]   - Field: ‘expr’
[17:37:35.111]   - Field: ‘uuid’
[17:37:35.111]   - Field: ‘seed’
[17:37:35.111]   - Field: ‘version’
[17:37:35.111]   - Field: ‘result’
[17:37:35.111]   - Field: ‘asynchronous’
[17:37:35.111]   - Field: ‘calls’
[17:37:35.111]   - Field: ‘globals’
[17:37:35.111]   - Field: ‘stdout’
[17:37:35.112]   - Field: ‘earlySignal’
[17:37:35.112]   - Field: ‘lazy’
[17:37:35.112]   - Field: ‘state’
[17:37:35.112] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:35.112] - Launch lazy future ...
[17:37:35.112] Packages needed by the future expression (n = 0): <none>
[17:37:35.113] Packages needed by future strategies (n = 0): <none>
[17:37:35.113] {
[17:37:35.113]     {
[17:37:35.113]         {
[17:37:35.113]             ...future.startTime <- base::Sys.time()
[17:37:35.113]             {
[17:37:35.113]                 {
[17:37:35.113]                   {
[17:37:35.113]                     {
[17:37:35.113]                       base::local({
[17:37:35.113]                         has_future <- base::requireNamespace("future", 
[17:37:35.113]                           quietly = TRUE)
[17:37:35.113]                         if (has_future) {
[17:37:35.113]                           ns <- base::getNamespace("future")
[17:37:35.113]                           version <- ns[[".package"]][["version"]]
[17:37:35.113]                           if (is.null(version)) 
[17:37:35.113]                             version <- utils::packageVersion("future")
[17:37:35.113]                         }
[17:37:35.113]                         else {
[17:37:35.113]                           version <- NULL
[17:37:35.113]                         }
[17:37:35.113]                         if (!has_future || version < "1.8.0") {
[17:37:35.113]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:35.113]                             "", base::R.version$version.string), 
[17:37:35.113]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:35.113]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:35.113]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:35.113]                               "release", "version")], collapse = " "), 
[17:37:35.113]                             hostname = base::Sys.info()[["nodename"]])
[17:37:35.113]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:35.113]                             info)
[17:37:35.113]                           info <- base::paste(info, collapse = "; ")
[17:37:35.113]                           if (!has_future) {
[17:37:35.113]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:35.113]                               info)
[17:37:35.113]                           }
[17:37:35.113]                           else {
[17:37:35.113]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:35.113]                               info, version)
[17:37:35.113]                           }
[17:37:35.113]                           base::stop(msg)
[17:37:35.113]                         }
[17:37:35.113]                       })
[17:37:35.113]                     }
[17:37:35.113]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:35.113]                     base::options(mc.cores = 1L)
[17:37:35.113]                   }
[17:37:35.113]                   ...future.strategy.old <- future::plan("list")
[17:37:35.113]                   options(future.plan = NULL)
[17:37:35.113]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.113]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:35.113]                 }
[17:37:35.113]                 ...future.workdir <- getwd()
[17:37:35.113]             }
[17:37:35.113]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:35.113]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:35.113]         }
[17:37:35.113]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:35.113]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:35.113]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:35.113]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:35.113]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:35.113]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:35.113]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:35.113]             base::names(...future.oldOptions))
[17:37:35.113]     }
[17:37:35.113]     if (FALSE) {
[17:37:35.113]     }
[17:37:35.113]     else {
[17:37:35.113]         if (TRUE) {
[17:37:35.113]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:35.113]                 open = "w")
[17:37:35.113]         }
[17:37:35.113]         else {
[17:37:35.113]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:35.113]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:35.113]         }
[17:37:35.113]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:35.113]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:35.113]             base::sink(type = "output", split = FALSE)
[17:37:35.113]             base::close(...future.stdout)
[17:37:35.113]         }, add = TRUE)
[17:37:35.113]     }
[17:37:35.113]     ...future.frame <- base::sys.nframe()
[17:37:35.113]     ...future.conditions <- base::list()
[17:37:35.113]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:35.113]     if (FALSE) {
[17:37:35.113]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:35.113]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:35.113]     }
[17:37:35.113]     ...future.result <- base::tryCatch({
[17:37:35.113]         base::withCallingHandlers({
[17:37:35.113]             ...future.value <- base::withVisible(base::local({
[17:37:35.113]                 withCallingHandlers({
[17:37:35.113]                   {
[17:37:35.113]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.113]                     if (!identical(...future.globals.maxSize.org, 
[17:37:35.113]                       ...future.globals.maxSize)) {
[17:37:35.113]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.113]                       on.exit(options(oopts), add = TRUE)
[17:37:35.113]                     }
[17:37:35.113]                     {
[17:37:35.113]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.113]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:35.113]                         USE.NAMES = FALSE)
[17:37:35.113]                       do.call(mapply, args = args)
[17:37:35.113]                     }
[17:37:35.113]                   }
[17:37:35.113]                 }, immediateCondition = function(cond) {
[17:37:35.113]                   save_rds <- function (object, pathname, ...) 
[17:37:35.113]                   {
[17:37:35.113]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:35.113]                     if (file_test("-f", pathname_tmp)) {
[17:37:35.113]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.113]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:35.113]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.113]                         fi_tmp[["mtime"]])
[17:37:35.113]                     }
[17:37:35.113]                     tryCatch({
[17:37:35.113]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:35.113]                     }, error = function(ex) {
[17:37:35.113]                       msg <- conditionMessage(ex)
[17:37:35.113]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.113]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:35.113]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.113]                         fi_tmp[["mtime"]], msg)
[17:37:35.113]                       ex$message <- msg
[17:37:35.113]                       stop(ex)
[17:37:35.113]                     })
[17:37:35.113]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:35.113]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:35.113]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:35.113]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.113]                       fi <- file.info(pathname)
[17:37:35.113]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:35.113]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.113]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:35.113]                         fi[["size"]], fi[["mtime"]])
[17:37:35.113]                       stop(msg)
[17:37:35.113]                     }
[17:37:35.113]                     invisible(pathname)
[17:37:35.113]                   }
[17:37:35.113]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:35.113]                     rootPath = tempdir()) 
[17:37:35.113]                   {
[17:37:35.113]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:35.113]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:35.113]                       tmpdir = path, fileext = ".rds")
[17:37:35.113]                     save_rds(obj, file)
[17:37:35.113]                   }
[17:37:35.113]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:35.113]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.113]                   {
[17:37:35.113]                     inherits <- base::inherits
[17:37:35.113]                     invokeRestart <- base::invokeRestart
[17:37:35.113]                     is.null <- base::is.null
[17:37:35.113]                     muffled <- FALSE
[17:37:35.113]                     if (inherits(cond, "message")) {
[17:37:35.113]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:35.113]                       if (muffled) 
[17:37:35.113]                         invokeRestart("muffleMessage")
[17:37:35.113]                     }
[17:37:35.113]                     else if (inherits(cond, "warning")) {
[17:37:35.113]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:35.113]                       if (muffled) 
[17:37:35.113]                         invokeRestart("muffleWarning")
[17:37:35.113]                     }
[17:37:35.113]                     else if (inherits(cond, "condition")) {
[17:37:35.113]                       if (!is.null(pattern)) {
[17:37:35.113]                         computeRestarts <- base::computeRestarts
[17:37:35.113]                         grepl <- base::grepl
[17:37:35.113]                         restarts <- computeRestarts(cond)
[17:37:35.113]                         for (restart in restarts) {
[17:37:35.113]                           name <- restart$name
[17:37:35.113]                           if (is.null(name)) 
[17:37:35.113]                             next
[17:37:35.113]                           if (!grepl(pattern, name)) 
[17:37:35.113]                             next
[17:37:35.113]                           invokeRestart(restart)
[17:37:35.113]                           muffled <- TRUE
[17:37:35.113]                           break
[17:37:35.113]                         }
[17:37:35.113]                       }
[17:37:35.113]                     }
[17:37:35.113]                     invisible(muffled)
[17:37:35.113]                   }
[17:37:35.113]                   muffleCondition(cond)
[17:37:35.113]                 })
[17:37:35.113]             }))
[17:37:35.113]             future::FutureResult(value = ...future.value$value, 
[17:37:35.113]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.113]                   ...future.rng), globalenv = if (FALSE) 
[17:37:35.113]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:35.113]                     ...future.globalenv.names))
[17:37:35.113]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:35.113]         }, condition = base::local({
[17:37:35.113]             c <- base::c
[17:37:35.113]             inherits <- base::inherits
[17:37:35.113]             invokeRestart <- base::invokeRestart
[17:37:35.113]             length <- base::length
[17:37:35.113]             list <- base::list
[17:37:35.113]             seq.int <- base::seq.int
[17:37:35.113]             signalCondition <- base::signalCondition
[17:37:35.113]             sys.calls <- base::sys.calls
[17:37:35.113]             `[[` <- base::`[[`
[17:37:35.113]             `+` <- base::`+`
[17:37:35.113]             `<<-` <- base::`<<-`
[17:37:35.113]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:35.113]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:35.113]                   3L)]
[17:37:35.113]             }
[17:37:35.113]             function(cond) {
[17:37:35.113]                 is_error <- inherits(cond, "error")
[17:37:35.113]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:35.113]                   NULL)
[17:37:35.113]                 if (is_error) {
[17:37:35.113]                   sessionInformation <- function() {
[17:37:35.113]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:35.113]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:35.113]                       search = base::search(), system = base::Sys.info())
[17:37:35.113]                   }
[17:37:35.113]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.113]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:35.113]                     cond$call), session = sessionInformation(), 
[17:37:35.113]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:35.113]                   signalCondition(cond)
[17:37:35.113]                 }
[17:37:35.113]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:35.113]                 "immediateCondition"))) {
[17:37:35.113]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:35.113]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.113]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:35.113]                   if (TRUE && !signal) {
[17:37:35.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.113]                     {
[17:37:35.113]                       inherits <- base::inherits
[17:37:35.113]                       invokeRestart <- base::invokeRestart
[17:37:35.113]                       is.null <- base::is.null
[17:37:35.113]                       muffled <- FALSE
[17:37:35.113]                       if (inherits(cond, "message")) {
[17:37:35.113]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.113]                         if (muffled) 
[17:37:35.113]                           invokeRestart("muffleMessage")
[17:37:35.113]                       }
[17:37:35.113]                       else if (inherits(cond, "warning")) {
[17:37:35.113]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.113]                         if (muffled) 
[17:37:35.113]                           invokeRestart("muffleWarning")
[17:37:35.113]                       }
[17:37:35.113]                       else if (inherits(cond, "condition")) {
[17:37:35.113]                         if (!is.null(pattern)) {
[17:37:35.113]                           computeRestarts <- base::computeRestarts
[17:37:35.113]                           grepl <- base::grepl
[17:37:35.113]                           restarts <- computeRestarts(cond)
[17:37:35.113]                           for (restart in restarts) {
[17:37:35.113]                             name <- restart$name
[17:37:35.113]                             if (is.null(name)) 
[17:37:35.113]                               next
[17:37:35.113]                             if (!grepl(pattern, name)) 
[17:37:35.113]                               next
[17:37:35.113]                             invokeRestart(restart)
[17:37:35.113]                             muffled <- TRUE
[17:37:35.113]                             break
[17:37:35.113]                           }
[17:37:35.113]                         }
[17:37:35.113]                       }
[17:37:35.113]                       invisible(muffled)
[17:37:35.113]                     }
[17:37:35.113]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.113]                   }
[17:37:35.113]                 }
[17:37:35.113]                 else {
[17:37:35.113]                   if (TRUE) {
[17:37:35.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.113]                     {
[17:37:35.113]                       inherits <- base::inherits
[17:37:35.113]                       invokeRestart <- base::invokeRestart
[17:37:35.113]                       is.null <- base::is.null
[17:37:35.113]                       muffled <- FALSE
[17:37:35.113]                       if (inherits(cond, "message")) {
[17:37:35.113]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.113]                         if (muffled) 
[17:37:35.113]                           invokeRestart("muffleMessage")
[17:37:35.113]                       }
[17:37:35.113]                       else if (inherits(cond, "warning")) {
[17:37:35.113]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.113]                         if (muffled) 
[17:37:35.113]                           invokeRestart("muffleWarning")
[17:37:35.113]                       }
[17:37:35.113]                       else if (inherits(cond, "condition")) {
[17:37:35.113]                         if (!is.null(pattern)) {
[17:37:35.113]                           computeRestarts <- base::computeRestarts
[17:37:35.113]                           grepl <- base::grepl
[17:37:35.113]                           restarts <- computeRestarts(cond)
[17:37:35.113]                           for (restart in restarts) {
[17:37:35.113]                             name <- restart$name
[17:37:35.113]                             if (is.null(name)) 
[17:37:35.113]                               next
[17:37:35.113]                             if (!grepl(pattern, name)) 
[17:37:35.113]                               next
[17:37:35.113]                             invokeRestart(restart)
[17:37:35.113]                             muffled <- TRUE
[17:37:35.113]                             break
[17:37:35.113]                           }
[17:37:35.113]                         }
[17:37:35.113]                       }
[17:37:35.113]                       invisible(muffled)
[17:37:35.113]                     }
[17:37:35.113]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.113]                   }
[17:37:35.113]                 }
[17:37:35.113]             }
[17:37:35.113]         }))
[17:37:35.113]     }, error = function(ex) {
[17:37:35.113]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:35.113]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.113]                 ...future.rng), started = ...future.startTime, 
[17:37:35.113]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:35.113]             version = "1.8"), class = "FutureResult")
[17:37:35.113]     }, finally = {
[17:37:35.113]         if (!identical(...future.workdir, getwd())) 
[17:37:35.113]             setwd(...future.workdir)
[17:37:35.113]         {
[17:37:35.113]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:35.113]                 ...future.oldOptions$nwarnings <- NULL
[17:37:35.113]             }
[17:37:35.113]             base::options(...future.oldOptions)
[17:37:35.113]             if (.Platform$OS.type == "windows") {
[17:37:35.113]                 old_names <- names(...future.oldEnvVars)
[17:37:35.113]                 envs <- base::Sys.getenv()
[17:37:35.113]                 names <- names(envs)
[17:37:35.113]                 common <- intersect(names, old_names)
[17:37:35.113]                 added <- setdiff(names, old_names)
[17:37:35.113]                 removed <- setdiff(old_names, names)
[17:37:35.113]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:35.113]                   envs[common]]
[17:37:35.113]                 NAMES <- toupper(changed)
[17:37:35.113]                 args <- list()
[17:37:35.113]                 for (kk in seq_along(NAMES)) {
[17:37:35.113]                   name <- changed[[kk]]
[17:37:35.113]                   NAME <- NAMES[[kk]]
[17:37:35.113]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.113]                     next
[17:37:35.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.113]                 }
[17:37:35.113]                 NAMES <- toupper(added)
[17:37:35.113]                 for (kk in seq_along(NAMES)) {
[17:37:35.113]                   name <- added[[kk]]
[17:37:35.113]                   NAME <- NAMES[[kk]]
[17:37:35.113]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.113]                     next
[17:37:35.113]                   args[[name]] <- ""
[17:37:35.113]                 }
[17:37:35.113]                 NAMES <- toupper(removed)
[17:37:35.113]                 for (kk in seq_along(NAMES)) {
[17:37:35.113]                   name <- removed[[kk]]
[17:37:35.113]                   NAME <- NAMES[[kk]]
[17:37:35.113]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.113]                     next
[17:37:35.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.113]                 }
[17:37:35.113]                 if (length(args) > 0) 
[17:37:35.113]                   base::do.call(base::Sys.setenv, args = args)
[17:37:35.113]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:35.113]             }
[17:37:35.113]             else {
[17:37:35.113]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:35.113]             }
[17:37:35.113]             {
[17:37:35.113]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:35.113]                   0L) {
[17:37:35.113]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:35.113]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:35.113]                   base::options(opts)
[17:37:35.113]                 }
[17:37:35.113]                 {
[17:37:35.113]                   {
[17:37:35.113]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:35.113]                     NULL
[17:37:35.113]                   }
[17:37:35.113]                   options(future.plan = NULL)
[17:37:35.113]                   if (is.na(NA_character_)) 
[17:37:35.113]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.113]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:35.113]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:35.113]                     .init = FALSE)
[17:37:35.113]                 }
[17:37:35.113]             }
[17:37:35.113]         }
[17:37:35.113]     })
[17:37:35.113]     if (TRUE) {
[17:37:35.113]         base::sink(type = "output", split = FALSE)
[17:37:35.113]         if (TRUE) {
[17:37:35.113]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:35.113]         }
[17:37:35.113]         else {
[17:37:35.113]             ...future.result["stdout"] <- base::list(NULL)
[17:37:35.113]         }
[17:37:35.113]         base::close(...future.stdout)
[17:37:35.113]         ...future.stdout <- NULL
[17:37:35.113]     }
[17:37:35.113]     ...future.result$conditions <- ...future.conditions
[17:37:35.113]     ...future.result$finished <- base::Sys.time()
[17:37:35.113]     ...future.result
[17:37:35.113] }
[17:37:35.117] assign_globals() ...
[17:37:35.117] List of 5
[17:37:35.117]  $ ...future.FUN            :function (x, ...)  
[17:37:35.117]  $ MoreArgs                 :List of 1
[17:37:35.117]   ..$ x: num 42
[17:37:35.117]  $ ...future.elements_ii    :List of 1
[17:37:35.117]   ..$ times:List of 2
[17:37:35.117]   .. ..$ : int 3
[17:37:35.117]   .. ..$ : int 4
[17:37:35.117]  $ ...future.seeds_ii       : NULL
[17:37:35.117]  $ ...future.globals.maxSize: NULL
[17:37:35.117]  - attr(*, "where")=List of 5
[17:37:35.117]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:35.117]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:35.117]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:35.117]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:35.117]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:35.117]  - attr(*, "resolved")= logi FALSE
[17:37:35.117]  - attr(*, "total_size")= num 224
[17:37:35.117]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.117]  - attr(*, "already-done")= logi TRUE
[17:37:35.124] - copied ‘...future.FUN’ to environment
[17:37:35.125] - copied ‘MoreArgs’ to environment
[17:37:35.125] - copied ‘...future.elements_ii’ to environment
[17:37:35.125] - copied ‘...future.seeds_ii’ to environment
[17:37:35.125] - copied ‘...future.globals.maxSize’ to environment
[17:37:35.125] assign_globals() ... done
[17:37:35.125] requestCore(): workers = 2
[17:37:35.128] MulticoreFuture started
[17:37:35.128] - Launch lazy future ... done
[17:37:35.128] run() for ‘MulticoreFuture’ ... done
[17:37:35.129] Created future:
[17:37:35.129] plan(): Setting new future strategy stack:
[17:37:35.129] List of future strategies:
[17:37:35.129] 1. sequential:
[17:37:35.129]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:35.129]    - tweaked: FALSE
[17:37:35.129]    - call: NULL
[17:37:35.130] plan(): nbrOfWorkers() = 1
[17:37:35.132] plan(): Setting new future strategy stack:
[17:37:35.133] List of future strategies:
[17:37:35.133] 1. multicore:
[17:37:35.133]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:35.133]    - tweaked: FALSE
[17:37:35.133]    - call: plan(strategy)
[17:37:35.129] MulticoreFuture:
[17:37:35.129] Label: ‘future_mapply-2’
[17:37:35.129] Expression:
[17:37:35.129] {
[17:37:35.129]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.129]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:35.129]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.129]         on.exit(options(oopts), add = TRUE)
[17:37:35.129]     }
[17:37:35.129]     {
[17:37:35.129]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.129]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:35.129]         do.call(mapply, args = args)
[17:37:35.129]     }
[17:37:35.129] }
[17:37:35.129] Lazy evaluation: FALSE
[17:37:35.129] Asynchronous evaluation: TRUE
[17:37:35.129] Local evaluation: TRUE
[17:37:35.129] Environment: R_GlobalEnv
[17:37:35.129] Capture standard output: TRUE
[17:37:35.129] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:35.129] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:35.129] Packages: <none>
[17:37:35.129] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:35.129] Resolved: FALSE
[17:37:35.129] Value: <not collected>
[17:37:35.129] Conditions captured: <none>
[17:37:35.129] Early signaling: FALSE
[17:37:35.129] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:35.129] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.141] Chunk #2 of 2 ... DONE
[17:37:35.142] Launching 2 futures (chunks) ... DONE
[17:37:35.142] Resolving 2 futures (chunks) ...
[17:37:35.142] resolve() on list ...
[17:37:35.142]  recursive: 0
[17:37:35.142]  length: 2
[17:37:35.143] 
[17:37:35.142] plan(): nbrOfWorkers() = 2
[17:37:35.143] Future #1
[17:37:35.143] result() for MulticoreFuture ...
[17:37:35.144] result() for MulticoreFuture ...
[17:37:35.144] result() for MulticoreFuture ... done
[17:37:35.144] result() for MulticoreFuture ... done
[17:37:35.147] result() for MulticoreFuture ...
[17:37:35.147] result() for MulticoreFuture ... done
[17:37:35.148] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:37:35.148] - nx: 2
[17:37:35.149] - relay: TRUE
[17:37:35.149] - stdout: TRUE
[17:37:35.149] - signal: TRUE
[17:37:35.150] - resignal: FALSE
[17:37:35.150] - force: TRUE
[17:37:35.150] - relayed: [n=2] FALSE, FALSE
[17:37:35.151] - queued futures: [n=2] FALSE, FALSE
[17:37:35.151]  - until=1
[17:37:35.151]  - relaying element #1
[17:37:35.151] result() for MulticoreFuture ...
[17:37:35.152] result() for MulticoreFuture ... done
[17:37:35.152] result() for MulticoreFuture ...
[17:37:35.152] result() for MulticoreFuture ... done
[17:37:35.152] result() for MulticoreFuture ...
[17:37:35.153] result() for MulticoreFuture ... done
[17:37:35.153] result() for MulticoreFuture ...
[17:37:35.153] result() for MulticoreFuture ... done
[17:37:35.153] - relayed: [n=2] TRUE, FALSE
[17:37:35.154] - queued futures: [n=2] TRUE, FALSE
[17:37:35.154] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:37:35.154]  length: 1 (resolved future 1)
[17:37:35.155] Future #2
[17:37:35.155] result() for MulticoreFuture ...
[17:37:35.156] result() for MulticoreFuture ...
[17:37:35.156] result() for MulticoreFuture ... done
[17:37:35.156] result() for MulticoreFuture ... done
[17:37:35.156] result() for MulticoreFuture ...
[17:37:35.156] result() for MulticoreFuture ... done
[17:37:35.157] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:37:35.157] - nx: 2
[17:37:35.157] - relay: TRUE
[17:37:35.157] - stdout: TRUE
[17:37:35.157] - signal: TRUE
[17:37:35.157] - resignal: FALSE
[17:37:35.157] - force: TRUE
[17:37:35.157] - relayed: [n=2] TRUE, FALSE
[17:37:35.158] - queued futures: [n=2] TRUE, FALSE
[17:37:35.158]  - until=2
[17:37:35.158]  - relaying element #2
[17:37:35.158] result() for MulticoreFuture ...
[17:37:35.158] result() for MulticoreFuture ... done
[17:37:35.158] result() for MulticoreFuture ...
[17:37:35.158] result() for MulticoreFuture ... done
[17:37:35.158] result() for MulticoreFuture ...
[17:37:35.158] result() for MulticoreFuture ... done
[17:37:35.159] result() for MulticoreFuture ...
[17:37:35.159] result() for MulticoreFuture ... done
[17:37:35.159] - relayed: [n=2] TRUE, TRUE
[17:37:35.159] - queued futures: [n=2] TRUE, TRUE
[17:37:35.159] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:37:35.159]  length: 0 (resolved future 2)
[17:37:35.159] Relaying remaining futures
[17:37:35.159] signalConditionsASAP(NULL, pos=0) ...
[17:37:35.160] - nx: 2
[17:37:35.160] - relay: TRUE
[17:37:35.160] - stdout: TRUE
[17:37:35.160] - signal: TRUE
[17:37:35.160] - resignal: FALSE
[17:37:35.160] - force: TRUE
[17:37:35.160] - relayed: [n=2] TRUE, TRUE
[17:37:35.160] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:35.160] - relayed: [n=2] TRUE, TRUE
[17:37:35.161] - queued futures: [n=2] TRUE, TRUE
[17:37:35.161] signalConditionsASAP(NULL, pos=0) ... done
[17:37:35.161] resolve() on list ... DONE
[17:37:35.161] result() for MulticoreFuture ...
[17:37:35.161] result() for MulticoreFuture ... done
[17:37:35.161] result() for MulticoreFuture ...
[17:37:35.161] result() for MulticoreFuture ... done
[17:37:35.161] result() for MulticoreFuture ...
[17:37:35.161] result() for MulticoreFuture ... done
[17:37:35.161] result() for MulticoreFuture ...
[17:37:35.162] result() for MulticoreFuture ... done
[17:37:35.162]  - Number of value chunks collected: 2
[17:37:35.162] Resolving 2 futures (chunks) ... DONE
[17:37:35.162] Reducing values from 2 chunks ...
[17:37:35.162]  - Number of values collected after concatenation: 4
[17:37:35.162]  - Number of values expected: 4
[17:37:35.162] Reducing values from 2 chunks ... DONE
[17:37:35.162] future_mapply() ... DONE
[17:37:35.163] future_mapply() ...
[17:37:35.167] Number of chunks: 2
[17:37:35.167] getGlobalsAndPackagesXApply() ...
[17:37:35.167]  - future.globals: TRUE
[17:37:35.167] getGlobalsAndPackages() ...
[17:37:35.167] Searching for globals...
[17:37:35.169] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[17:37:35.169] Searching for globals ... DONE
[17:37:35.169] Resolving globals: FALSE
[17:37:35.170] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[17:37:35.170] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[17:37:35.170] - globals: [1] ‘FUN’
[17:37:35.170] 
[17:37:35.170] getGlobalsAndPackages() ... DONE
[17:37:35.171]  - globals found/used: [n=1] ‘FUN’
[17:37:35.171]  - needed namespaces: [n=0] 
[17:37:35.171] Finding globals ... DONE
[17:37:35.171] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:35.171] List of 2
[17:37:35.171]  $ ...future.FUN:function (x, y)  
[17:37:35.171]  $ MoreArgs     : NULL
[17:37:35.171]  - attr(*, "where")=List of 2
[17:37:35.171]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:35.171]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:35.171]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.171]  - attr(*, "resolved")= logi FALSE
[17:37:35.171]  - attr(*, "total_size")= num NA
[17:37:35.174] Packages to be attached in all futures: [n=0] 
[17:37:35.174] getGlobalsAndPackagesXApply() ... DONE
[17:37:35.174] Number of futures (= number of chunks): 2
[17:37:35.174] Launching 2 futures (chunks) ...
[17:37:35.175] Chunk #1 of 2 ...
[17:37:35.175]  - Finding globals in '...' for chunk #1 ...
[17:37:35.175] getGlobalsAndPackages() ...
[17:37:35.175] Searching for globals...
[17:37:35.175] 
[17:37:35.175] Searching for globals ... DONE
[17:37:35.175] - globals: [0] <none>
[17:37:35.176] getGlobalsAndPackages() ... DONE
[17:37:35.176]    + additional globals found: [n=0] 
[17:37:35.176]    + additional namespaces needed: [n=0] 
[17:37:35.176]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:35.176]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:35.176]  - seeds: <none>
[17:37:35.176]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.176] getGlobalsAndPackages() ...
[17:37:35.176] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.177] Resolving globals: FALSE
[17:37:35.177] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[17:37:35.177] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:35.178] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.178] 
[17:37:35.178] getGlobalsAndPackages() ... DONE
[17:37:35.178] run() for ‘Future’ ...
[17:37:35.178] - state: ‘created’
[17:37:35.178] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:35.184] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.184] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:35.185]   - Field: ‘label’
[17:37:35.185]   - Field: ‘local’
[17:37:35.185]   - Field: ‘owner’
[17:37:35.185]   - Field: ‘envir’
[17:37:35.185]   - Field: ‘workers’
[17:37:35.185]   - Field: ‘packages’
[17:37:35.185]   - Field: ‘gc’
[17:37:35.185]   - Field: ‘job’
[17:37:35.185]   - Field: ‘conditions’
[17:37:35.186]   - Field: ‘expr’
[17:37:35.186]   - Field: ‘uuid’
[17:37:35.186]   - Field: ‘seed’
[17:37:35.186]   - Field: ‘version’
[17:37:35.186]   - Field: ‘result’
[17:37:35.186]   - Field: ‘asynchronous’
[17:37:35.186]   - Field: ‘calls’
[17:37:35.186]   - Field: ‘globals’
[17:37:35.186]   - Field: ‘stdout’
[17:37:35.187]   - Field: ‘earlySignal’
[17:37:35.187]   - Field: ‘lazy’
[17:37:35.187]   - Field: ‘state’
[17:37:35.187] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:35.187] - Launch lazy future ...
[17:37:35.187] Packages needed by the future expression (n = 0): <none>
[17:37:35.187] Packages needed by future strategies (n = 0): <none>
[17:37:35.188] {
[17:37:35.188]     {
[17:37:35.188]         {
[17:37:35.188]             ...future.startTime <- base::Sys.time()
[17:37:35.188]             {
[17:37:35.188]                 {
[17:37:35.188]                   {
[17:37:35.188]                     {
[17:37:35.188]                       base::local({
[17:37:35.188]                         has_future <- base::requireNamespace("future", 
[17:37:35.188]                           quietly = TRUE)
[17:37:35.188]                         if (has_future) {
[17:37:35.188]                           ns <- base::getNamespace("future")
[17:37:35.188]                           version <- ns[[".package"]][["version"]]
[17:37:35.188]                           if (is.null(version)) 
[17:37:35.188]                             version <- utils::packageVersion("future")
[17:37:35.188]                         }
[17:37:35.188]                         else {
[17:37:35.188]                           version <- NULL
[17:37:35.188]                         }
[17:37:35.188]                         if (!has_future || version < "1.8.0") {
[17:37:35.188]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:35.188]                             "", base::R.version$version.string), 
[17:37:35.188]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:35.188]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:35.188]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:35.188]                               "release", "version")], collapse = " "), 
[17:37:35.188]                             hostname = base::Sys.info()[["nodename"]])
[17:37:35.188]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:35.188]                             info)
[17:37:35.188]                           info <- base::paste(info, collapse = "; ")
[17:37:35.188]                           if (!has_future) {
[17:37:35.188]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:35.188]                               info)
[17:37:35.188]                           }
[17:37:35.188]                           else {
[17:37:35.188]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:35.188]                               info, version)
[17:37:35.188]                           }
[17:37:35.188]                           base::stop(msg)
[17:37:35.188]                         }
[17:37:35.188]                       })
[17:37:35.188]                     }
[17:37:35.188]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:35.188]                     base::options(mc.cores = 1L)
[17:37:35.188]                   }
[17:37:35.188]                   ...future.strategy.old <- future::plan("list")
[17:37:35.188]                   options(future.plan = NULL)
[17:37:35.188]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.188]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:35.188]                 }
[17:37:35.188]                 ...future.workdir <- getwd()
[17:37:35.188]             }
[17:37:35.188]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:35.188]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:35.188]         }
[17:37:35.188]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:35.188]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:35.188]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:35.188]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:35.188]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:35.188]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:35.188]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:35.188]             base::names(...future.oldOptions))
[17:37:35.188]     }
[17:37:35.188]     if (FALSE) {
[17:37:35.188]     }
[17:37:35.188]     else {
[17:37:35.188]         if (TRUE) {
[17:37:35.188]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:35.188]                 open = "w")
[17:37:35.188]         }
[17:37:35.188]         else {
[17:37:35.188]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:35.188]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:35.188]         }
[17:37:35.188]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:35.188]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:35.188]             base::sink(type = "output", split = FALSE)
[17:37:35.188]             base::close(...future.stdout)
[17:37:35.188]         }, add = TRUE)
[17:37:35.188]     }
[17:37:35.188]     ...future.frame <- base::sys.nframe()
[17:37:35.188]     ...future.conditions <- base::list()
[17:37:35.188]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:35.188]     if (FALSE) {
[17:37:35.188]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:35.188]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:35.188]     }
[17:37:35.188]     ...future.result <- base::tryCatch({
[17:37:35.188]         base::withCallingHandlers({
[17:37:35.188]             ...future.value <- base::withVisible(base::local({
[17:37:35.188]                 withCallingHandlers({
[17:37:35.188]                   {
[17:37:35.188]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.188]                     if (!identical(...future.globals.maxSize.org, 
[17:37:35.188]                       ...future.globals.maxSize)) {
[17:37:35.188]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.188]                       on.exit(options(oopts), add = TRUE)
[17:37:35.188]                     }
[17:37:35.188]                     {
[17:37:35.188]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.188]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:35.188]                         USE.NAMES = FALSE)
[17:37:35.188]                       do.call(mapply, args = args)
[17:37:35.188]                     }
[17:37:35.188]                   }
[17:37:35.188]                 }, immediateCondition = function(cond) {
[17:37:35.188]                   save_rds <- function (object, pathname, ...) 
[17:37:35.188]                   {
[17:37:35.188]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:35.188]                     if (file_test("-f", pathname_tmp)) {
[17:37:35.188]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.188]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:35.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.188]                         fi_tmp[["mtime"]])
[17:37:35.188]                     }
[17:37:35.188]                     tryCatch({
[17:37:35.188]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:35.188]                     }, error = function(ex) {
[17:37:35.188]                       msg <- conditionMessage(ex)
[17:37:35.188]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.188]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:35.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.188]                         fi_tmp[["mtime"]], msg)
[17:37:35.188]                       ex$message <- msg
[17:37:35.188]                       stop(ex)
[17:37:35.188]                     })
[17:37:35.188]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:35.188]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:35.188]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:35.188]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.188]                       fi <- file.info(pathname)
[17:37:35.188]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:35.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.188]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:35.188]                         fi[["size"]], fi[["mtime"]])
[17:37:35.188]                       stop(msg)
[17:37:35.188]                     }
[17:37:35.188]                     invisible(pathname)
[17:37:35.188]                   }
[17:37:35.188]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:35.188]                     rootPath = tempdir()) 
[17:37:35.188]                   {
[17:37:35.188]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:35.188]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:35.188]                       tmpdir = path, fileext = ".rds")
[17:37:35.188]                     save_rds(obj, file)
[17:37:35.188]                   }
[17:37:35.188]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:35.188]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.188]                   {
[17:37:35.188]                     inherits <- base::inherits
[17:37:35.188]                     invokeRestart <- base::invokeRestart
[17:37:35.188]                     is.null <- base::is.null
[17:37:35.188]                     muffled <- FALSE
[17:37:35.188]                     if (inherits(cond, "message")) {
[17:37:35.188]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:35.188]                       if (muffled) 
[17:37:35.188]                         invokeRestart("muffleMessage")
[17:37:35.188]                     }
[17:37:35.188]                     else if (inherits(cond, "warning")) {
[17:37:35.188]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:35.188]                       if (muffled) 
[17:37:35.188]                         invokeRestart("muffleWarning")
[17:37:35.188]                     }
[17:37:35.188]                     else if (inherits(cond, "condition")) {
[17:37:35.188]                       if (!is.null(pattern)) {
[17:37:35.188]                         computeRestarts <- base::computeRestarts
[17:37:35.188]                         grepl <- base::grepl
[17:37:35.188]                         restarts <- computeRestarts(cond)
[17:37:35.188]                         for (restart in restarts) {
[17:37:35.188]                           name <- restart$name
[17:37:35.188]                           if (is.null(name)) 
[17:37:35.188]                             next
[17:37:35.188]                           if (!grepl(pattern, name)) 
[17:37:35.188]                             next
[17:37:35.188]                           invokeRestart(restart)
[17:37:35.188]                           muffled <- TRUE
[17:37:35.188]                           break
[17:37:35.188]                         }
[17:37:35.188]                       }
[17:37:35.188]                     }
[17:37:35.188]                     invisible(muffled)
[17:37:35.188]                   }
[17:37:35.188]                   muffleCondition(cond)
[17:37:35.188]                 })
[17:37:35.188]             }))
[17:37:35.188]             future::FutureResult(value = ...future.value$value, 
[17:37:35.188]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.188]                   ...future.rng), globalenv = if (FALSE) 
[17:37:35.188]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:35.188]                     ...future.globalenv.names))
[17:37:35.188]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:35.188]         }, condition = base::local({
[17:37:35.188]             c <- base::c
[17:37:35.188]             inherits <- base::inherits
[17:37:35.188]             invokeRestart <- base::invokeRestart
[17:37:35.188]             length <- base::length
[17:37:35.188]             list <- base::list
[17:37:35.188]             seq.int <- base::seq.int
[17:37:35.188]             signalCondition <- base::signalCondition
[17:37:35.188]             sys.calls <- base::sys.calls
[17:37:35.188]             `[[` <- base::`[[`
[17:37:35.188]             `+` <- base::`+`
[17:37:35.188]             `<<-` <- base::`<<-`
[17:37:35.188]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:35.188]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:35.188]                   3L)]
[17:37:35.188]             }
[17:37:35.188]             function(cond) {
[17:37:35.188]                 is_error <- inherits(cond, "error")
[17:37:35.188]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:35.188]                   NULL)
[17:37:35.188]                 if (is_error) {
[17:37:35.188]                   sessionInformation <- function() {
[17:37:35.188]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:35.188]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:35.188]                       search = base::search(), system = base::Sys.info())
[17:37:35.188]                   }
[17:37:35.188]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.188]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:35.188]                     cond$call), session = sessionInformation(), 
[17:37:35.188]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:35.188]                   signalCondition(cond)
[17:37:35.188]                 }
[17:37:35.188]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:35.188]                 "immediateCondition"))) {
[17:37:35.188]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:35.188]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.188]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:35.188]                   if (TRUE && !signal) {
[17:37:35.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.188]                     {
[17:37:35.188]                       inherits <- base::inherits
[17:37:35.188]                       invokeRestart <- base::invokeRestart
[17:37:35.188]                       is.null <- base::is.null
[17:37:35.188]                       muffled <- FALSE
[17:37:35.188]                       if (inherits(cond, "message")) {
[17:37:35.188]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.188]                         if (muffled) 
[17:37:35.188]                           invokeRestart("muffleMessage")
[17:37:35.188]                       }
[17:37:35.188]                       else if (inherits(cond, "warning")) {
[17:37:35.188]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.188]                         if (muffled) 
[17:37:35.188]                           invokeRestart("muffleWarning")
[17:37:35.188]                       }
[17:37:35.188]                       else if (inherits(cond, "condition")) {
[17:37:35.188]                         if (!is.null(pattern)) {
[17:37:35.188]                           computeRestarts <- base::computeRestarts
[17:37:35.188]                           grepl <- base::grepl
[17:37:35.188]                           restarts <- computeRestarts(cond)
[17:37:35.188]                           for (restart in restarts) {
[17:37:35.188]                             name <- restart$name
[17:37:35.188]                             if (is.null(name)) 
[17:37:35.188]                               next
[17:37:35.188]                             if (!grepl(pattern, name)) 
[17:37:35.188]                               next
[17:37:35.188]                             invokeRestart(restart)
[17:37:35.188]                             muffled <- TRUE
[17:37:35.188]                             break
[17:37:35.188]                           }
[17:37:35.188]                         }
[17:37:35.188]                       }
[17:37:35.188]                       invisible(muffled)
[17:37:35.188]                     }
[17:37:35.188]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.188]                   }
[17:37:35.188]                 }
[17:37:35.188]                 else {
[17:37:35.188]                   if (TRUE) {
[17:37:35.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.188]                     {
[17:37:35.188]                       inherits <- base::inherits
[17:37:35.188]                       invokeRestart <- base::invokeRestart
[17:37:35.188]                       is.null <- base::is.null
[17:37:35.188]                       muffled <- FALSE
[17:37:35.188]                       if (inherits(cond, "message")) {
[17:37:35.188]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.188]                         if (muffled) 
[17:37:35.188]                           invokeRestart("muffleMessage")
[17:37:35.188]                       }
[17:37:35.188]                       else if (inherits(cond, "warning")) {
[17:37:35.188]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.188]                         if (muffled) 
[17:37:35.188]                           invokeRestart("muffleWarning")
[17:37:35.188]                       }
[17:37:35.188]                       else if (inherits(cond, "condition")) {
[17:37:35.188]                         if (!is.null(pattern)) {
[17:37:35.188]                           computeRestarts <- base::computeRestarts
[17:37:35.188]                           grepl <- base::grepl
[17:37:35.188]                           restarts <- computeRestarts(cond)
[17:37:35.188]                           for (restart in restarts) {
[17:37:35.188]                             name <- restart$name
[17:37:35.188]                             if (is.null(name)) 
[17:37:35.188]                               next
[17:37:35.188]                             if (!grepl(pattern, name)) 
[17:37:35.188]                               next
[17:37:35.188]                             invokeRestart(restart)
[17:37:35.188]                             muffled <- TRUE
[17:37:35.188]                             break
[17:37:35.188]                           }
[17:37:35.188]                         }
[17:37:35.188]                       }
[17:37:35.188]                       invisible(muffled)
[17:37:35.188]                     }
[17:37:35.188]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.188]                   }
[17:37:35.188]                 }
[17:37:35.188]             }
[17:37:35.188]         }))
[17:37:35.188]     }, error = function(ex) {
[17:37:35.188]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:35.188]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.188]                 ...future.rng), started = ...future.startTime, 
[17:37:35.188]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:35.188]             version = "1.8"), class = "FutureResult")
[17:37:35.188]     }, finally = {
[17:37:35.188]         if (!identical(...future.workdir, getwd())) 
[17:37:35.188]             setwd(...future.workdir)
[17:37:35.188]         {
[17:37:35.188]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:35.188]                 ...future.oldOptions$nwarnings <- NULL
[17:37:35.188]             }
[17:37:35.188]             base::options(...future.oldOptions)
[17:37:35.188]             if (.Platform$OS.type == "windows") {
[17:37:35.188]                 old_names <- names(...future.oldEnvVars)
[17:37:35.188]                 envs <- base::Sys.getenv()
[17:37:35.188]                 names <- names(envs)
[17:37:35.188]                 common <- intersect(names, old_names)
[17:37:35.188]                 added <- setdiff(names, old_names)
[17:37:35.188]                 removed <- setdiff(old_names, names)
[17:37:35.188]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:35.188]                   envs[common]]
[17:37:35.188]                 NAMES <- toupper(changed)
[17:37:35.188]                 args <- list()
[17:37:35.188]                 for (kk in seq_along(NAMES)) {
[17:37:35.188]                   name <- changed[[kk]]
[17:37:35.188]                   NAME <- NAMES[[kk]]
[17:37:35.188]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.188]                     next
[17:37:35.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.188]                 }
[17:37:35.188]                 NAMES <- toupper(added)
[17:37:35.188]                 for (kk in seq_along(NAMES)) {
[17:37:35.188]                   name <- added[[kk]]
[17:37:35.188]                   NAME <- NAMES[[kk]]
[17:37:35.188]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.188]                     next
[17:37:35.188]                   args[[name]] <- ""
[17:37:35.188]                 }
[17:37:35.188]                 NAMES <- toupper(removed)
[17:37:35.188]                 for (kk in seq_along(NAMES)) {
[17:37:35.188]                   name <- removed[[kk]]
[17:37:35.188]                   NAME <- NAMES[[kk]]
[17:37:35.188]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.188]                     next
[17:37:35.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.188]                 }
[17:37:35.188]                 if (length(args) > 0) 
[17:37:35.188]                   base::do.call(base::Sys.setenv, args = args)
[17:37:35.188]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:35.188]             }
[17:37:35.188]             else {
[17:37:35.188]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:35.188]             }
[17:37:35.188]             {
[17:37:35.188]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:35.188]                   0L) {
[17:37:35.188]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:35.188]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:35.188]                   base::options(opts)
[17:37:35.188]                 }
[17:37:35.188]                 {
[17:37:35.188]                   {
[17:37:35.188]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:35.188]                     NULL
[17:37:35.188]                   }
[17:37:35.188]                   options(future.plan = NULL)
[17:37:35.188]                   if (is.na(NA_character_)) 
[17:37:35.188]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.188]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:35.188]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:35.188]                     .init = FALSE)
[17:37:35.188]                 }
[17:37:35.188]             }
[17:37:35.188]         }
[17:37:35.188]     })
[17:37:35.188]     if (TRUE) {
[17:37:35.188]         base::sink(type = "output", split = FALSE)
[17:37:35.188]         if (TRUE) {
[17:37:35.188]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:35.188]         }
[17:37:35.188]         else {
[17:37:35.188]             ...future.result["stdout"] <- base::list(NULL)
[17:37:35.188]         }
[17:37:35.188]         base::close(...future.stdout)
[17:37:35.188]         ...future.stdout <- NULL
[17:37:35.188]     }
[17:37:35.188]     ...future.result$conditions <- ...future.conditions
[17:37:35.188]     ...future.result$finished <- base::Sys.time()
[17:37:35.188]     ...future.result
[17:37:35.188] }
[17:37:35.190] assign_globals() ...
[17:37:35.190] List of 5
[17:37:35.190]  $ ...future.FUN            :function (x, y)  
[17:37:35.190]  $ MoreArgs                 : NULL
[17:37:35.190]  $ ...future.elements_ii    :List of 2
[17:37:35.190]   ..$ :List of 1
[17:37:35.190]   .. ..$ a: num 1
[17:37:35.190]   ..$ :List of 1
[17:37:35.190]   .. ..$ A: num 10
[17:37:35.190]  $ ...future.seeds_ii       : NULL
[17:37:35.190]  $ ...future.globals.maxSize: NULL
[17:37:35.190]  - attr(*, "where")=List of 5
[17:37:35.190]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:35.190]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:35.190]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:35.190]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:35.190]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:35.190]  - attr(*, "resolved")= logi FALSE
[17:37:35.190]  - attr(*, "total_size")= num 2088
[17:37:35.190]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.190]  - attr(*, "already-done")= logi TRUE
[17:37:35.195] - reassign environment for ‘...future.FUN’
[17:37:35.196] - copied ‘...future.FUN’ to environment
[17:37:35.196] - copied ‘MoreArgs’ to environment
[17:37:35.196] - copied ‘...future.elements_ii’ to environment
[17:37:35.196] - copied ‘...future.seeds_ii’ to environment
[17:37:35.196] - copied ‘...future.globals.maxSize’ to environment
[17:37:35.196] assign_globals() ... done
[17:37:35.196] requestCore(): workers = 2
[17:37:35.199] MulticoreFuture started
[17:37:35.199] - Launch lazy future ... done
[17:37:35.199] run() for ‘MulticoreFuture’ ... done
[17:37:35.199] Created future:
[17:37:35.199] plan(): Setting new future strategy stack:
[17:37:35.200] List of future strategies:
[17:37:35.200] 1. sequential:
[17:37:35.200]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:35.200]    - tweaked: FALSE
[17:37:35.200]    - call: NULL
[17:37:35.201] plan(): nbrOfWorkers() = 1
[17:37:35.203] plan(): Setting new future strategy stack:
[17:37:35.203] List of future strategies:
[17:37:35.203] 1. multicore:
[17:37:35.203]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:35.203]    - tweaked: FALSE
[17:37:35.203]    - call: plan(strategy)
[17:37:35.208] plan(): nbrOfWorkers() = 2
[17:37:35.200] MulticoreFuture:
[17:37:35.200] Label: ‘future_mapply-1’
[17:37:35.200] Expression:
[17:37:35.200] {
[17:37:35.200]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.200]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:35.200]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.200]         on.exit(options(oopts), add = TRUE)
[17:37:35.200]     }
[17:37:35.200]     {
[17:37:35.200]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.200]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:35.200]         do.call(mapply, args = args)
[17:37:35.200]     }
[17:37:35.200] }
[17:37:35.200] Lazy evaluation: FALSE
[17:37:35.200] Asynchronous evaluation: TRUE
[17:37:35.200] Local evaluation: TRUE
[17:37:35.200] Environment: R_GlobalEnv
[17:37:35.200] Capture standard output: TRUE
[17:37:35.200] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:35.200] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:35.200] Packages: <none>
[17:37:35.200] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:35.200] Resolved: TRUE
[17:37:35.200] Value: <not collected>
[17:37:35.200] Conditions captured: <none>
[17:37:35.200] Early signaling: FALSE
[17:37:35.200] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:35.200] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.209] Chunk #1 of 2 ... DONE
[17:37:35.209] Chunk #2 of 2 ...
[17:37:35.209]  - Finding globals in '...' for chunk #2 ...
[17:37:35.210] getGlobalsAndPackages() ...
[17:37:35.210] Searching for globals...
[17:37:35.210] 
[17:37:35.210] Searching for globals ... DONE
[17:37:35.211] - globals: [0] <none>
[17:37:35.211] getGlobalsAndPackages() ... DONE
[17:37:35.211]    + additional globals found: [n=0] 
[17:37:35.211]    + additional namespaces needed: [n=0] 
[17:37:35.211]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:35.211]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:35.211]  - seeds: <none>
[17:37:35.211]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.212] getGlobalsAndPackages() ...
[17:37:35.212] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.212] Resolving globals: FALSE
[17:37:35.213] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[17:37:35.214] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:35.214] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.214] 
[17:37:35.214] getGlobalsAndPackages() ... DONE
[17:37:35.215] run() for ‘Future’ ...
[17:37:35.215] - state: ‘created’
[17:37:35.215] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:35.220] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.220] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:35.220]   - Field: ‘label’
[17:37:35.220]   - Field: ‘local’
[17:37:35.220]   - Field: ‘owner’
[17:37:35.220]   - Field: ‘envir’
[17:37:35.221]   - Field: ‘workers’
[17:37:35.221]   - Field: ‘packages’
[17:37:35.221]   - Field: ‘gc’
[17:37:35.221]   - Field: ‘job’
[17:37:35.221]   - Field: ‘conditions’
[17:37:35.221]   - Field: ‘expr’
[17:37:35.221]   - Field: ‘uuid’
[17:37:35.222]   - Field: ‘seed’
[17:37:35.222]   - Field: ‘version’
[17:37:35.222]   - Field: ‘result’
[17:37:35.222]   - Field: ‘asynchronous’
[17:37:35.222]   - Field: ‘calls’
[17:37:35.222]   - Field: ‘globals’
[17:37:35.223]   - Field: ‘stdout’
[17:37:35.223]   - Field: ‘earlySignal’
[17:37:35.223]   - Field: ‘lazy’
[17:37:35.223]   - Field: ‘state’
[17:37:35.223] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:35.223] - Launch lazy future ...
[17:37:35.224] Packages needed by the future expression (n = 0): <none>
[17:37:35.224] Packages needed by future strategies (n = 0): <none>
[17:37:35.225] {
[17:37:35.225]     {
[17:37:35.225]         {
[17:37:35.225]             ...future.startTime <- base::Sys.time()
[17:37:35.225]             {
[17:37:35.225]                 {
[17:37:35.225]                   {
[17:37:35.225]                     {
[17:37:35.225]                       base::local({
[17:37:35.225]                         has_future <- base::requireNamespace("future", 
[17:37:35.225]                           quietly = TRUE)
[17:37:35.225]                         if (has_future) {
[17:37:35.225]                           ns <- base::getNamespace("future")
[17:37:35.225]                           version <- ns[[".package"]][["version"]]
[17:37:35.225]                           if (is.null(version)) 
[17:37:35.225]                             version <- utils::packageVersion("future")
[17:37:35.225]                         }
[17:37:35.225]                         else {
[17:37:35.225]                           version <- NULL
[17:37:35.225]                         }
[17:37:35.225]                         if (!has_future || version < "1.8.0") {
[17:37:35.225]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:35.225]                             "", base::R.version$version.string), 
[17:37:35.225]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:35.225]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:35.225]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:35.225]                               "release", "version")], collapse = " "), 
[17:37:35.225]                             hostname = base::Sys.info()[["nodename"]])
[17:37:35.225]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:35.225]                             info)
[17:37:35.225]                           info <- base::paste(info, collapse = "; ")
[17:37:35.225]                           if (!has_future) {
[17:37:35.225]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:35.225]                               info)
[17:37:35.225]                           }
[17:37:35.225]                           else {
[17:37:35.225]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:35.225]                               info, version)
[17:37:35.225]                           }
[17:37:35.225]                           base::stop(msg)
[17:37:35.225]                         }
[17:37:35.225]                       })
[17:37:35.225]                     }
[17:37:35.225]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:35.225]                     base::options(mc.cores = 1L)
[17:37:35.225]                   }
[17:37:35.225]                   ...future.strategy.old <- future::plan("list")
[17:37:35.225]                   options(future.plan = NULL)
[17:37:35.225]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.225]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:35.225]                 }
[17:37:35.225]                 ...future.workdir <- getwd()
[17:37:35.225]             }
[17:37:35.225]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:35.225]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:35.225]         }
[17:37:35.225]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:35.225]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:35.225]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:35.225]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:35.225]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:35.225]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:35.225]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:35.225]             base::names(...future.oldOptions))
[17:37:35.225]     }
[17:37:35.225]     if (FALSE) {
[17:37:35.225]     }
[17:37:35.225]     else {
[17:37:35.225]         if (TRUE) {
[17:37:35.225]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:35.225]                 open = "w")
[17:37:35.225]         }
[17:37:35.225]         else {
[17:37:35.225]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:35.225]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:35.225]         }
[17:37:35.225]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:35.225]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:35.225]             base::sink(type = "output", split = FALSE)
[17:37:35.225]             base::close(...future.stdout)
[17:37:35.225]         }, add = TRUE)
[17:37:35.225]     }
[17:37:35.225]     ...future.frame <- base::sys.nframe()
[17:37:35.225]     ...future.conditions <- base::list()
[17:37:35.225]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:35.225]     if (FALSE) {
[17:37:35.225]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:35.225]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:35.225]     }
[17:37:35.225]     ...future.result <- base::tryCatch({
[17:37:35.225]         base::withCallingHandlers({
[17:37:35.225]             ...future.value <- base::withVisible(base::local({
[17:37:35.225]                 withCallingHandlers({
[17:37:35.225]                   {
[17:37:35.225]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.225]                     if (!identical(...future.globals.maxSize.org, 
[17:37:35.225]                       ...future.globals.maxSize)) {
[17:37:35.225]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.225]                       on.exit(options(oopts), add = TRUE)
[17:37:35.225]                     }
[17:37:35.225]                     {
[17:37:35.225]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.225]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:35.225]                         USE.NAMES = FALSE)
[17:37:35.225]                       do.call(mapply, args = args)
[17:37:35.225]                     }
[17:37:35.225]                   }
[17:37:35.225]                 }, immediateCondition = function(cond) {
[17:37:35.225]                   save_rds <- function (object, pathname, ...) 
[17:37:35.225]                   {
[17:37:35.225]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:35.225]                     if (file_test("-f", pathname_tmp)) {
[17:37:35.225]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.225]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:35.225]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.225]                         fi_tmp[["mtime"]])
[17:37:35.225]                     }
[17:37:35.225]                     tryCatch({
[17:37:35.225]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:35.225]                     }, error = function(ex) {
[17:37:35.225]                       msg <- conditionMessage(ex)
[17:37:35.225]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.225]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:35.225]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.225]                         fi_tmp[["mtime"]], msg)
[17:37:35.225]                       ex$message <- msg
[17:37:35.225]                       stop(ex)
[17:37:35.225]                     })
[17:37:35.225]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:35.225]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:35.225]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:35.225]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.225]                       fi <- file.info(pathname)
[17:37:35.225]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:35.225]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.225]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:35.225]                         fi[["size"]], fi[["mtime"]])
[17:37:35.225]                       stop(msg)
[17:37:35.225]                     }
[17:37:35.225]                     invisible(pathname)
[17:37:35.225]                   }
[17:37:35.225]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:35.225]                     rootPath = tempdir()) 
[17:37:35.225]                   {
[17:37:35.225]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:35.225]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:35.225]                       tmpdir = path, fileext = ".rds")
[17:37:35.225]                     save_rds(obj, file)
[17:37:35.225]                   }
[17:37:35.225]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:35.225]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.225]                   {
[17:37:35.225]                     inherits <- base::inherits
[17:37:35.225]                     invokeRestart <- base::invokeRestart
[17:37:35.225]                     is.null <- base::is.null
[17:37:35.225]                     muffled <- FALSE
[17:37:35.225]                     if (inherits(cond, "message")) {
[17:37:35.225]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:35.225]                       if (muffled) 
[17:37:35.225]                         invokeRestart("muffleMessage")
[17:37:35.225]                     }
[17:37:35.225]                     else if (inherits(cond, "warning")) {
[17:37:35.225]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:35.225]                       if (muffled) 
[17:37:35.225]                         invokeRestart("muffleWarning")
[17:37:35.225]                     }
[17:37:35.225]                     else if (inherits(cond, "condition")) {
[17:37:35.225]                       if (!is.null(pattern)) {
[17:37:35.225]                         computeRestarts <- base::computeRestarts
[17:37:35.225]                         grepl <- base::grepl
[17:37:35.225]                         restarts <- computeRestarts(cond)
[17:37:35.225]                         for (restart in restarts) {
[17:37:35.225]                           name <- restart$name
[17:37:35.225]                           if (is.null(name)) 
[17:37:35.225]                             next
[17:37:35.225]                           if (!grepl(pattern, name)) 
[17:37:35.225]                             next
[17:37:35.225]                           invokeRestart(restart)
[17:37:35.225]                           muffled <- TRUE
[17:37:35.225]                           break
[17:37:35.225]                         }
[17:37:35.225]                       }
[17:37:35.225]                     }
[17:37:35.225]                     invisible(muffled)
[17:37:35.225]                   }
[17:37:35.225]                   muffleCondition(cond)
[17:37:35.225]                 })
[17:37:35.225]             }))
[17:37:35.225]             future::FutureResult(value = ...future.value$value, 
[17:37:35.225]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.225]                   ...future.rng), globalenv = if (FALSE) 
[17:37:35.225]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:35.225]                     ...future.globalenv.names))
[17:37:35.225]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:35.225]         }, condition = base::local({
[17:37:35.225]             c <- base::c
[17:37:35.225]             inherits <- base::inherits
[17:37:35.225]             invokeRestart <- base::invokeRestart
[17:37:35.225]             length <- base::length
[17:37:35.225]             list <- base::list
[17:37:35.225]             seq.int <- base::seq.int
[17:37:35.225]             signalCondition <- base::signalCondition
[17:37:35.225]             sys.calls <- base::sys.calls
[17:37:35.225]             `[[` <- base::`[[`
[17:37:35.225]             `+` <- base::`+`
[17:37:35.225]             `<<-` <- base::`<<-`
[17:37:35.225]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:35.225]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:35.225]                   3L)]
[17:37:35.225]             }
[17:37:35.225]             function(cond) {
[17:37:35.225]                 is_error <- inherits(cond, "error")
[17:37:35.225]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:35.225]                   NULL)
[17:37:35.225]                 if (is_error) {
[17:37:35.225]                   sessionInformation <- function() {
[17:37:35.225]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:35.225]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:35.225]                       search = base::search(), system = base::Sys.info())
[17:37:35.225]                   }
[17:37:35.225]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.225]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:35.225]                     cond$call), session = sessionInformation(), 
[17:37:35.225]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:35.225]                   signalCondition(cond)
[17:37:35.225]                 }
[17:37:35.225]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:35.225]                 "immediateCondition"))) {
[17:37:35.225]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:35.225]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.225]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:35.225]                   if (TRUE && !signal) {
[17:37:35.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.225]                     {
[17:37:35.225]                       inherits <- base::inherits
[17:37:35.225]                       invokeRestart <- base::invokeRestart
[17:37:35.225]                       is.null <- base::is.null
[17:37:35.225]                       muffled <- FALSE
[17:37:35.225]                       if (inherits(cond, "message")) {
[17:37:35.225]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.225]                         if (muffled) 
[17:37:35.225]                           invokeRestart("muffleMessage")
[17:37:35.225]                       }
[17:37:35.225]                       else if (inherits(cond, "warning")) {
[17:37:35.225]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.225]                         if (muffled) 
[17:37:35.225]                           invokeRestart("muffleWarning")
[17:37:35.225]                       }
[17:37:35.225]                       else if (inherits(cond, "condition")) {
[17:37:35.225]                         if (!is.null(pattern)) {
[17:37:35.225]                           computeRestarts <- base::computeRestarts
[17:37:35.225]                           grepl <- base::grepl
[17:37:35.225]                           restarts <- computeRestarts(cond)
[17:37:35.225]                           for (restart in restarts) {
[17:37:35.225]                             name <- restart$name
[17:37:35.225]                             if (is.null(name)) 
[17:37:35.225]                               next
[17:37:35.225]                             if (!grepl(pattern, name)) 
[17:37:35.225]                               next
[17:37:35.225]                             invokeRestart(restart)
[17:37:35.225]                             muffled <- TRUE
[17:37:35.225]                             break
[17:37:35.225]                           }
[17:37:35.225]                         }
[17:37:35.225]                       }
[17:37:35.225]                       invisible(muffled)
[17:37:35.225]                     }
[17:37:35.225]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.225]                   }
[17:37:35.225]                 }
[17:37:35.225]                 else {
[17:37:35.225]                   if (TRUE) {
[17:37:35.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.225]                     {
[17:37:35.225]                       inherits <- base::inherits
[17:37:35.225]                       invokeRestart <- base::invokeRestart
[17:37:35.225]                       is.null <- base::is.null
[17:37:35.225]                       muffled <- FALSE
[17:37:35.225]                       if (inherits(cond, "message")) {
[17:37:35.225]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.225]                         if (muffled) 
[17:37:35.225]                           invokeRestart("muffleMessage")
[17:37:35.225]                       }
[17:37:35.225]                       else if (inherits(cond, "warning")) {
[17:37:35.225]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.225]                         if (muffled) 
[17:37:35.225]                           invokeRestart("muffleWarning")
[17:37:35.225]                       }
[17:37:35.225]                       else if (inherits(cond, "condition")) {
[17:37:35.225]                         if (!is.null(pattern)) {
[17:37:35.225]                           computeRestarts <- base::computeRestarts
[17:37:35.225]                           grepl <- base::grepl
[17:37:35.225]                           restarts <- computeRestarts(cond)
[17:37:35.225]                           for (restart in restarts) {
[17:37:35.225]                             name <- restart$name
[17:37:35.225]                             if (is.null(name)) 
[17:37:35.225]                               next
[17:37:35.225]                             if (!grepl(pattern, name)) 
[17:37:35.225]                               next
[17:37:35.225]                             invokeRestart(restart)
[17:37:35.225]                             muffled <- TRUE
[17:37:35.225]                             break
[17:37:35.225]                           }
[17:37:35.225]                         }
[17:37:35.225]                       }
[17:37:35.225]                       invisible(muffled)
[17:37:35.225]                     }
[17:37:35.225]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.225]                   }
[17:37:35.225]                 }
[17:37:35.225]             }
[17:37:35.225]         }))
[17:37:35.225]     }, error = function(ex) {
[17:37:35.225]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:35.225]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.225]                 ...future.rng), started = ...future.startTime, 
[17:37:35.225]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:35.225]             version = "1.8"), class = "FutureResult")
[17:37:35.225]     }, finally = {
[17:37:35.225]         if (!identical(...future.workdir, getwd())) 
[17:37:35.225]             setwd(...future.workdir)
[17:37:35.225]         {
[17:37:35.225]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:35.225]                 ...future.oldOptions$nwarnings <- NULL
[17:37:35.225]             }
[17:37:35.225]             base::options(...future.oldOptions)
[17:37:35.225]             if (.Platform$OS.type == "windows") {
[17:37:35.225]                 old_names <- names(...future.oldEnvVars)
[17:37:35.225]                 envs <- base::Sys.getenv()
[17:37:35.225]                 names <- names(envs)
[17:37:35.225]                 common <- intersect(names, old_names)
[17:37:35.225]                 added <- setdiff(names, old_names)
[17:37:35.225]                 removed <- setdiff(old_names, names)
[17:37:35.225]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:35.225]                   envs[common]]
[17:37:35.225]                 NAMES <- toupper(changed)
[17:37:35.225]                 args <- list()
[17:37:35.225]                 for (kk in seq_along(NAMES)) {
[17:37:35.225]                   name <- changed[[kk]]
[17:37:35.225]                   NAME <- NAMES[[kk]]
[17:37:35.225]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.225]                     next
[17:37:35.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.225]                 }
[17:37:35.225]                 NAMES <- toupper(added)
[17:37:35.225]                 for (kk in seq_along(NAMES)) {
[17:37:35.225]                   name <- added[[kk]]
[17:37:35.225]                   NAME <- NAMES[[kk]]
[17:37:35.225]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.225]                     next
[17:37:35.225]                   args[[name]] <- ""
[17:37:35.225]                 }
[17:37:35.225]                 NAMES <- toupper(removed)
[17:37:35.225]                 for (kk in seq_along(NAMES)) {
[17:37:35.225]                   name <- removed[[kk]]
[17:37:35.225]                   NAME <- NAMES[[kk]]
[17:37:35.225]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.225]                     next
[17:37:35.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.225]                 }
[17:37:35.225]                 if (length(args) > 0) 
[17:37:35.225]                   base::do.call(base::Sys.setenv, args = args)
[17:37:35.225]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:35.225]             }
[17:37:35.225]             else {
[17:37:35.225]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:35.225]             }
[17:37:35.225]             {
[17:37:35.225]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:35.225]                   0L) {
[17:37:35.225]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:35.225]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:35.225]                   base::options(opts)
[17:37:35.225]                 }
[17:37:35.225]                 {
[17:37:35.225]                   {
[17:37:35.225]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:35.225]                     NULL
[17:37:35.225]                   }
[17:37:35.225]                   options(future.plan = NULL)
[17:37:35.225]                   if (is.na(NA_character_)) 
[17:37:35.225]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.225]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:35.225]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:35.225]                     .init = FALSE)
[17:37:35.225]                 }
[17:37:35.225]             }
[17:37:35.225]         }
[17:37:35.225]     })
[17:37:35.225]     if (TRUE) {
[17:37:35.225]         base::sink(type = "output", split = FALSE)
[17:37:35.225]         if (TRUE) {
[17:37:35.225]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:35.225]         }
[17:37:35.225]         else {
[17:37:35.225]             ...future.result["stdout"] <- base::list(NULL)
[17:37:35.225]         }
[17:37:35.225]         base::close(...future.stdout)
[17:37:35.225]         ...future.stdout <- NULL
[17:37:35.225]     }
[17:37:35.225]     ...future.result$conditions <- ...future.conditions
[17:37:35.225]     ...future.result$finished <- base::Sys.time()
[17:37:35.225]     ...future.result
[17:37:35.225] }
[17:37:35.228] assign_globals() ...
[17:37:35.228] List of 5
[17:37:35.228]  $ ...future.FUN            :function (x, y)  
[17:37:35.228]  $ MoreArgs                 : NULL
[17:37:35.228]  $ ...future.elements_ii    :List of 2
[17:37:35.228]   ..$ :List of 2
[17:37:35.228]   .. ..$ b: num 2
[17:37:35.228]   .. ..$ c: num 3
[17:37:35.228]   ..$ :List of 2
[17:37:35.228]   .. ..$ B: num 0
[17:37:35.228]   .. ..$ C: num -10
[17:37:35.228]  $ ...future.seeds_ii       : NULL
[17:37:35.228]  $ ...future.globals.maxSize: NULL
[17:37:35.228]  - attr(*, "where")=List of 5
[17:37:35.228]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:35.228]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:35.228]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:35.228]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:35.228]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:35.228]  - attr(*, "resolved")= logi FALSE
[17:37:35.228]  - attr(*, "total_size")= num 2200
[17:37:35.228]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.228]  - attr(*, "already-done")= logi TRUE
[17:37:35.243] - reassign environment for ‘...future.FUN’
[17:37:35.243] - copied ‘...future.FUN’ to environment
[17:37:35.243] - copied ‘MoreArgs’ to environment
[17:37:35.243] - copied ‘...future.elements_ii’ to environment
[17:37:35.243] - copied ‘...future.seeds_ii’ to environment
[17:37:35.243] - copied ‘...future.globals.maxSize’ to environment
[17:37:35.243] assign_globals() ... done
[17:37:35.244] requestCore(): workers = 2
[17:37:35.246] MulticoreFuture started
[17:37:35.246] - Launch lazy future ... done
[17:37:35.247] run() for ‘MulticoreFuture’ ... done
[17:37:35.247] Created future:
[17:37:35.247] plan(): Setting new future strategy stack:
[17:37:35.247] List of future strategies:
[17:37:35.247] 1. sequential:
[17:37:35.247]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:35.247]    - tweaked: FALSE
[17:37:35.247]    - call: NULL
[17:37:35.248] plan(): nbrOfWorkers() = 1
[17:37:35.251] plan(): Setting new future strategy stack:
[17:37:35.251] List of future strategies:
[17:37:35.251] 1. multicore:
[17:37:35.251]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:35.251]    - tweaked: FALSE
[17:37:35.251]    - call: plan(strategy)
[17:37:35.257] plan(): nbrOfWorkers() = 2
[17:37:35.247] MulticoreFuture:
[17:37:35.247] Label: ‘future_mapply-2’
[17:37:35.247] Expression:
[17:37:35.247] {
[17:37:35.247]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.247]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:35.247]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.247]         on.exit(options(oopts), add = TRUE)
[17:37:35.247]     }
[17:37:35.247]     {
[17:37:35.247]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.247]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:35.247]         do.call(mapply, args = args)
[17:37:35.247]     }
[17:37:35.247] }
[17:37:35.247] Lazy evaluation: FALSE
[17:37:35.247] Asynchronous evaluation: TRUE
[17:37:35.247] Local evaluation: TRUE
[17:37:35.247] Environment: R_GlobalEnv
[17:37:35.247] Capture standard output: TRUE
[17:37:35.247] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:35.247] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:35.247] Packages: <none>
[17:37:35.247] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:35.247] Resolved: TRUE
[17:37:35.247] Value: <not collected>
[17:37:35.247] Conditions captured: <none>
[17:37:35.247] Early signaling: FALSE
[17:37:35.247] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:35.247] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.258] Chunk #2 of 2 ... DONE
[17:37:35.258] Launching 2 futures (chunks) ... DONE
[17:37:35.258] Resolving 2 futures (chunks) ...
[17:37:35.259] resolve() on list ...
[17:37:35.259]  recursive: 0
[17:37:35.259]  length: 2
[17:37:35.259] 
[17:37:35.260] Future #1
[17:37:35.260] result() for MulticoreFuture ...
[17:37:35.261] result() for MulticoreFuture ...
[17:37:35.261] result() for MulticoreFuture ... done
[17:37:35.262] result() for MulticoreFuture ... done
[17:37:35.262] result() for MulticoreFuture ...
[17:37:35.262] result() for MulticoreFuture ... done
[17:37:35.262] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:37:35.262] - nx: 2
[17:37:35.263] - relay: TRUE
[17:37:35.263] - stdout: TRUE
[17:37:35.263] - signal: TRUE
[17:37:35.263] - resignal: FALSE
[17:37:35.263] - force: TRUE
[17:37:35.264] - relayed: [n=2] FALSE, FALSE
[17:37:35.264] - queued futures: [n=2] FALSE, FALSE
[17:37:35.264]  - until=1
[17:37:35.264]  - relaying element #1
[17:37:35.264] result() for MulticoreFuture ...
[17:37:35.265] result() for MulticoreFuture ... done
[17:37:35.265] result() for MulticoreFuture ...
[17:37:35.265] result() for MulticoreFuture ... done
[17:37:35.265] result() for MulticoreFuture ...
[17:37:35.265] result() for MulticoreFuture ... done
[17:37:35.265] result() for MulticoreFuture ...
[17:37:35.265] result() for MulticoreFuture ... done
[17:37:35.266] - relayed: [n=2] TRUE, FALSE
[17:37:35.266] - queued futures: [n=2] TRUE, FALSE
[17:37:35.266] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:37:35.266]  length: 1 (resolved future 1)
[17:37:35.266] Future #2
[17:37:35.267] result() for MulticoreFuture ...
[17:37:35.267] result() for MulticoreFuture ...
[17:37:35.267] result() for MulticoreFuture ... done
[17:37:35.268] result() for MulticoreFuture ... done
[17:37:35.268] result() for MulticoreFuture ...
[17:37:35.268] result() for MulticoreFuture ... done
[17:37:35.268] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:37:35.268] - nx: 2
[17:37:35.268] - relay: TRUE
[17:37:35.268] - stdout: TRUE
[17:37:35.269] - signal: TRUE
[17:37:35.269] - resignal: FALSE
[17:37:35.269] - force: TRUE
[17:37:35.269] - relayed: [n=2] TRUE, FALSE
[17:37:35.269] - queued futures: [n=2] TRUE, FALSE
[17:37:35.269]  - until=2
[17:37:35.269]  - relaying element #2
[17:37:35.269] result() for MulticoreFuture ...
[17:37:35.269] result() for MulticoreFuture ... done
[17:37:35.270] result() for MulticoreFuture ...
[17:37:35.270] result() for MulticoreFuture ... done
[17:37:35.270] result() for MulticoreFuture ...
[17:37:35.270] result() for MulticoreFuture ... done
[17:37:35.270] result() for MulticoreFuture ...
[17:37:35.270] result() for MulticoreFuture ... done
[17:37:35.270] - relayed: [n=2] TRUE, TRUE
[17:37:35.270] - queued futures: [n=2] TRUE, TRUE
[17:37:35.271] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:37:35.271]  length: 0 (resolved future 2)
[17:37:35.271] Relaying remaining futures
[17:37:35.271] signalConditionsASAP(NULL, pos=0) ...
[17:37:35.271] - nx: 2
[17:37:35.271] - relay: TRUE
[17:37:35.271] - stdout: TRUE
[17:37:35.271] - signal: TRUE
[17:37:35.271] - resignal: FALSE
[17:37:35.271] - force: TRUE
[17:37:35.272] - relayed: [n=2] TRUE, TRUE
[17:37:35.272] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:35.272] - relayed: [n=2] TRUE, TRUE
[17:37:35.272] - queued futures: [n=2] TRUE, TRUE
[17:37:35.272] signalConditionsASAP(NULL, pos=0) ... done
[17:37:35.272] resolve() on list ... DONE
[17:37:35.272] result() for MulticoreFuture ...
[17:37:35.273] result() for MulticoreFuture ... done
[17:37:35.273] result() for MulticoreFuture ...
[17:37:35.273] result() for MulticoreFuture ... done
[17:37:35.273] result() for MulticoreFuture ...
[17:37:35.273] result() for MulticoreFuture ... done
[17:37:35.273] result() for MulticoreFuture ...
[17:37:35.273] result() for MulticoreFuture ... done
[17:37:35.273]  - Number of value chunks collected: 2
[17:37:35.273] Resolving 2 futures (chunks) ... DONE
[17:37:35.274] Reducing values from 2 chunks ...
[17:37:35.274]  - Number of values collected after concatenation: 3
[17:37:35.274]  - Number of values expected: 3
[17:37:35.274] Reducing values from 2 chunks ... DONE
[17:37:35.274] future_mapply() ... DONE
- future_.mapply()
[17:37:35.274] future_mapply() ...
[17:37:35.279] Number of chunks: 2
[17:37:35.279] getGlobalsAndPackagesXApply() ...
[17:37:35.279]  - future.globals: TRUE
[17:37:35.280] getGlobalsAndPackages() ...
[17:37:35.280] Searching for globals...
[17:37:35.284] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[17:37:35.284] Searching for globals ... DONE
[17:37:35.284] Resolving globals: FALSE
[17:37:35.285] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[17:37:35.285] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[17:37:35.285] - globals: [1] ‘FUN’
[17:37:35.286] 
[17:37:35.286] getGlobalsAndPackages() ... DONE
[17:37:35.286]  - globals found/used: [n=1] ‘FUN’
[17:37:35.286]  - needed namespaces: [n=0] 
[17:37:35.286] Finding globals ... DONE
[17:37:35.286] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:35.287] List of 2
[17:37:35.287]  $ ...future.FUN:function (x, y)  
[17:37:35.287]  $ MoreArgs     : list()
[17:37:35.287]  - attr(*, "where")=List of 2
[17:37:35.287]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:35.287]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:35.287]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.287]  - attr(*, "resolved")= logi FALSE
[17:37:35.287]  - attr(*, "total_size")= num NA
[17:37:35.290] Packages to be attached in all futures: [n=0] 
[17:37:35.290] getGlobalsAndPackagesXApply() ... DONE
[17:37:35.290] Number of futures (= number of chunks): 2
[17:37:35.290] Launching 2 futures (chunks) ...
[17:37:35.290] Chunk #1 of 2 ...
[17:37:35.290]  - Finding globals in '...' for chunk #1 ...
[17:37:35.291] getGlobalsAndPackages() ...
[17:37:35.291] Searching for globals...
[17:37:35.291] 
[17:37:35.291] Searching for globals ... DONE
[17:37:35.291] - globals: [0] <none>
[17:37:35.291] getGlobalsAndPackages() ... DONE
[17:37:35.291]    + additional globals found: [n=0] 
[17:37:35.292]    + additional namespaces needed: [n=0] 
[17:37:35.292]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:35.292]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:35.292]  - seeds: <none>
[17:37:35.292]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.292] getGlobalsAndPackages() ...
[17:37:35.292] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.292] Resolving globals: FALSE
[17:37:35.293] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[17:37:35.293] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:35.293] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.294] 
[17:37:35.294] getGlobalsAndPackages() ... DONE
[17:37:35.294] run() for ‘Future’ ...
[17:37:35.294] - state: ‘created’
[17:37:35.294] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:35.298] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.298] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:35.298]   - Field: ‘label’
[17:37:35.298]   - Field: ‘local’
[17:37:35.298]   - Field: ‘owner’
[17:37:35.298]   - Field: ‘envir’
[17:37:35.299]   - Field: ‘workers’
[17:37:35.299]   - Field: ‘packages’
[17:37:35.299]   - Field: ‘gc’
[17:37:35.299]   - Field: ‘job’
[17:37:35.299]   - Field: ‘conditions’
[17:37:35.299]   - Field: ‘expr’
[17:37:35.299]   - Field: ‘uuid’
[17:37:35.299]   - Field: ‘seed’
[17:37:35.299]   - Field: ‘version’
[17:37:35.299]   - Field: ‘result’
[17:37:35.299]   - Field: ‘asynchronous’
[17:37:35.300]   - Field: ‘calls’
[17:37:35.300]   - Field: ‘globals’
[17:37:35.300]   - Field: ‘stdout’
[17:37:35.300]   - Field: ‘earlySignal’
[17:37:35.300]   - Field: ‘lazy’
[17:37:35.300]   - Field: ‘state’
[17:37:35.300] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:35.300] - Launch lazy future ...
[17:37:35.301] Packages needed by the future expression (n = 0): <none>
[17:37:35.301] Packages needed by future strategies (n = 0): <none>
[17:37:35.301] {
[17:37:35.301]     {
[17:37:35.301]         {
[17:37:35.301]             ...future.startTime <- base::Sys.time()
[17:37:35.301]             {
[17:37:35.301]                 {
[17:37:35.301]                   {
[17:37:35.301]                     {
[17:37:35.301]                       base::local({
[17:37:35.301]                         has_future <- base::requireNamespace("future", 
[17:37:35.301]                           quietly = TRUE)
[17:37:35.301]                         if (has_future) {
[17:37:35.301]                           ns <- base::getNamespace("future")
[17:37:35.301]                           version <- ns[[".package"]][["version"]]
[17:37:35.301]                           if (is.null(version)) 
[17:37:35.301]                             version <- utils::packageVersion("future")
[17:37:35.301]                         }
[17:37:35.301]                         else {
[17:37:35.301]                           version <- NULL
[17:37:35.301]                         }
[17:37:35.301]                         if (!has_future || version < "1.8.0") {
[17:37:35.301]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:35.301]                             "", base::R.version$version.string), 
[17:37:35.301]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:35.301]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:35.301]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:35.301]                               "release", "version")], collapse = " "), 
[17:37:35.301]                             hostname = base::Sys.info()[["nodename"]])
[17:37:35.301]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:35.301]                             info)
[17:37:35.301]                           info <- base::paste(info, collapse = "; ")
[17:37:35.301]                           if (!has_future) {
[17:37:35.301]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:35.301]                               info)
[17:37:35.301]                           }
[17:37:35.301]                           else {
[17:37:35.301]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:35.301]                               info, version)
[17:37:35.301]                           }
[17:37:35.301]                           base::stop(msg)
[17:37:35.301]                         }
[17:37:35.301]                       })
[17:37:35.301]                     }
[17:37:35.301]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:35.301]                     base::options(mc.cores = 1L)
[17:37:35.301]                   }
[17:37:35.301]                   ...future.strategy.old <- future::plan("list")
[17:37:35.301]                   options(future.plan = NULL)
[17:37:35.301]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.301]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:35.301]                 }
[17:37:35.301]                 ...future.workdir <- getwd()
[17:37:35.301]             }
[17:37:35.301]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:35.301]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:35.301]         }
[17:37:35.301]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:35.301]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:35.301]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:35.301]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:35.301]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:35.301]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:35.301]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:35.301]             base::names(...future.oldOptions))
[17:37:35.301]     }
[17:37:35.301]     if (FALSE) {
[17:37:35.301]     }
[17:37:35.301]     else {
[17:37:35.301]         if (TRUE) {
[17:37:35.301]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:35.301]                 open = "w")
[17:37:35.301]         }
[17:37:35.301]         else {
[17:37:35.301]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:35.301]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:35.301]         }
[17:37:35.301]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:35.301]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:35.301]             base::sink(type = "output", split = FALSE)
[17:37:35.301]             base::close(...future.stdout)
[17:37:35.301]         }, add = TRUE)
[17:37:35.301]     }
[17:37:35.301]     ...future.frame <- base::sys.nframe()
[17:37:35.301]     ...future.conditions <- base::list()
[17:37:35.301]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:35.301]     if (FALSE) {
[17:37:35.301]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:35.301]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:35.301]     }
[17:37:35.301]     ...future.result <- base::tryCatch({
[17:37:35.301]         base::withCallingHandlers({
[17:37:35.301]             ...future.value <- base::withVisible(base::local({
[17:37:35.301]                 withCallingHandlers({
[17:37:35.301]                   {
[17:37:35.301]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.301]                     if (!identical(...future.globals.maxSize.org, 
[17:37:35.301]                       ...future.globals.maxSize)) {
[17:37:35.301]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.301]                       on.exit(options(oopts), add = TRUE)
[17:37:35.301]                     }
[17:37:35.301]                     {
[17:37:35.301]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.301]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:35.301]                         USE.NAMES = FALSE)
[17:37:35.301]                       do.call(mapply, args = args)
[17:37:35.301]                     }
[17:37:35.301]                   }
[17:37:35.301]                 }, immediateCondition = function(cond) {
[17:37:35.301]                   save_rds <- function (object, pathname, ...) 
[17:37:35.301]                   {
[17:37:35.301]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:35.301]                     if (file_test("-f", pathname_tmp)) {
[17:37:35.301]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.301]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:35.301]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.301]                         fi_tmp[["mtime"]])
[17:37:35.301]                     }
[17:37:35.301]                     tryCatch({
[17:37:35.301]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:35.301]                     }, error = function(ex) {
[17:37:35.301]                       msg <- conditionMessage(ex)
[17:37:35.301]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.301]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:35.301]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.301]                         fi_tmp[["mtime"]], msg)
[17:37:35.301]                       ex$message <- msg
[17:37:35.301]                       stop(ex)
[17:37:35.301]                     })
[17:37:35.301]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:35.301]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:35.301]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:35.301]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.301]                       fi <- file.info(pathname)
[17:37:35.301]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:35.301]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.301]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:35.301]                         fi[["size"]], fi[["mtime"]])
[17:37:35.301]                       stop(msg)
[17:37:35.301]                     }
[17:37:35.301]                     invisible(pathname)
[17:37:35.301]                   }
[17:37:35.301]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:35.301]                     rootPath = tempdir()) 
[17:37:35.301]                   {
[17:37:35.301]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:35.301]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:35.301]                       tmpdir = path, fileext = ".rds")
[17:37:35.301]                     save_rds(obj, file)
[17:37:35.301]                   }
[17:37:35.301]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:35.301]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.301]                   {
[17:37:35.301]                     inherits <- base::inherits
[17:37:35.301]                     invokeRestart <- base::invokeRestart
[17:37:35.301]                     is.null <- base::is.null
[17:37:35.301]                     muffled <- FALSE
[17:37:35.301]                     if (inherits(cond, "message")) {
[17:37:35.301]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:35.301]                       if (muffled) 
[17:37:35.301]                         invokeRestart("muffleMessage")
[17:37:35.301]                     }
[17:37:35.301]                     else if (inherits(cond, "warning")) {
[17:37:35.301]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:35.301]                       if (muffled) 
[17:37:35.301]                         invokeRestart("muffleWarning")
[17:37:35.301]                     }
[17:37:35.301]                     else if (inherits(cond, "condition")) {
[17:37:35.301]                       if (!is.null(pattern)) {
[17:37:35.301]                         computeRestarts <- base::computeRestarts
[17:37:35.301]                         grepl <- base::grepl
[17:37:35.301]                         restarts <- computeRestarts(cond)
[17:37:35.301]                         for (restart in restarts) {
[17:37:35.301]                           name <- restart$name
[17:37:35.301]                           if (is.null(name)) 
[17:37:35.301]                             next
[17:37:35.301]                           if (!grepl(pattern, name)) 
[17:37:35.301]                             next
[17:37:35.301]                           invokeRestart(restart)
[17:37:35.301]                           muffled <- TRUE
[17:37:35.301]                           break
[17:37:35.301]                         }
[17:37:35.301]                       }
[17:37:35.301]                     }
[17:37:35.301]                     invisible(muffled)
[17:37:35.301]                   }
[17:37:35.301]                   muffleCondition(cond)
[17:37:35.301]                 })
[17:37:35.301]             }))
[17:37:35.301]             future::FutureResult(value = ...future.value$value, 
[17:37:35.301]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.301]                   ...future.rng), globalenv = if (FALSE) 
[17:37:35.301]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:35.301]                     ...future.globalenv.names))
[17:37:35.301]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:35.301]         }, condition = base::local({
[17:37:35.301]             c <- base::c
[17:37:35.301]             inherits <- base::inherits
[17:37:35.301]             invokeRestart <- base::invokeRestart
[17:37:35.301]             length <- base::length
[17:37:35.301]             list <- base::list
[17:37:35.301]             seq.int <- base::seq.int
[17:37:35.301]             signalCondition <- base::signalCondition
[17:37:35.301]             sys.calls <- base::sys.calls
[17:37:35.301]             `[[` <- base::`[[`
[17:37:35.301]             `+` <- base::`+`
[17:37:35.301]             `<<-` <- base::`<<-`
[17:37:35.301]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:35.301]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:35.301]                   3L)]
[17:37:35.301]             }
[17:37:35.301]             function(cond) {
[17:37:35.301]                 is_error <- inherits(cond, "error")
[17:37:35.301]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:35.301]                   NULL)
[17:37:35.301]                 if (is_error) {
[17:37:35.301]                   sessionInformation <- function() {
[17:37:35.301]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:35.301]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:35.301]                       search = base::search(), system = base::Sys.info())
[17:37:35.301]                   }
[17:37:35.301]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.301]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:35.301]                     cond$call), session = sessionInformation(), 
[17:37:35.301]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:35.301]                   signalCondition(cond)
[17:37:35.301]                 }
[17:37:35.301]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:35.301]                 "immediateCondition"))) {
[17:37:35.301]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:35.301]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.301]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:35.301]                   if (TRUE && !signal) {
[17:37:35.301]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.301]                     {
[17:37:35.301]                       inherits <- base::inherits
[17:37:35.301]                       invokeRestart <- base::invokeRestart
[17:37:35.301]                       is.null <- base::is.null
[17:37:35.301]                       muffled <- FALSE
[17:37:35.301]                       if (inherits(cond, "message")) {
[17:37:35.301]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.301]                         if (muffled) 
[17:37:35.301]                           invokeRestart("muffleMessage")
[17:37:35.301]                       }
[17:37:35.301]                       else if (inherits(cond, "warning")) {
[17:37:35.301]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.301]                         if (muffled) 
[17:37:35.301]                           invokeRestart("muffleWarning")
[17:37:35.301]                       }
[17:37:35.301]                       else if (inherits(cond, "condition")) {
[17:37:35.301]                         if (!is.null(pattern)) {
[17:37:35.301]                           computeRestarts <- base::computeRestarts
[17:37:35.301]                           grepl <- base::grepl
[17:37:35.301]                           restarts <- computeRestarts(cond)
[17:37:35.301]                           for (restart in restarts) {
[17:37:35.301]                             name <- restart$name
[17:37:35.301]                             if (is.null(name)) 
[17:37:35.301]                               next
[17:37:35.301]                             if (!grepl(pattern, name)) 
[17:37:35.301]                               next
[17:37:35.301]                             invokeRestart(restart)
[17:37:35.301]                             muffled <- TRUE
[17:37:35.301]                             break
[17:37:35.301]                           }
[17:37:35.301]                         }
[17:37:35.301]                       }
[17:37:35.301]                       invisible(muffled)
[17:37:35.301]                     }
[17:37:35.301]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.301]                   }
[17:37:35.301]                 }
[17:37:35.301]                 else {
[17:37:35.301]                   if (TRUE) {
[17:37:35.301]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.301]                     {
[17:37:35.301]                       inherits <- base::inherits
[17:37:35.301]                       invokeRestart <- base::invokeRestart
[17:37:35.301]                       is.null <- base::is.null
[17:37:35.301]                       muffled <- FALSE
[17:37:35.301]                       if (inherits(cond, "message")) {
[17:37:35.301]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.301]                         if (muffled) 
[17:37:35.301]                           invokeRestart("muffleMessage")
[17:37:35.301]                       }
[17:37:35.301]                       else if (inherits(cond, "warning")) {
[17:37:35.301]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.301]                         if (muffled) 
[17:37:35.301]                           invokeRestart("muffleWarning")
[17:37:35.301]                       }
[17:37:35.301]                       else if (inherits(cond, "condition")) {
[17:37:35.301]                         if (!is.null(pattern)) {
[17:37:35.301]                           computeRestarts <- base::computeRestarts
[17:37:35.301]                           grepl <- base::grepl
[17:37:35.301]                           restarts <- computeRestarts(cond)
[17:37:35.301]                           for (restart in restarts) {
[17:37:35.301]                             name <- restart$name
[17:37:35.301]                             if (is.null(name)) 
[17:37:35.301]                               next
[17:37:35.301]                             if (!grepl(pattern, name)) 
[17:37:35.301]                               next
[17:37:35.301]                             invokeRestart(restart)
[17:37:35.301]                             muffled <- TRUE
[17:37:35.301]                             break
[17:37:35.301]                           }
[17:37:35.301]                         }
[17:37:35.301]                       }
[17:37:35.301]                       invisible(muffled)
[17:37:35.301]                     }
[17:37:35.301]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.301]                   }
[17:37:35.301]                 }
[17:37:35.301]             }
[17:37:35.301]         }))
[17:37:35.301]     }, error = function(ex) {
[17:37:35.301]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:35.301]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.301]                 ...future.rng), started = ...future.startTime, 
[17:37:35.301]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:35.301]             version = "1.8"), class = "FutureResult")
[17:37:35.301]     }, finally = {
[17:37:35.301]         if (!identical(...future.workdir, getwd())) 
[17:37:35.301]             setwd(...future.workdir)
[17:37:35.301]         {
[17:37:35.301]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:35.301]                 ...future.oldOptions$nwarnings <- NULL
[17:37:35.301]             }
[17:37:35.301]             base::options(...future.oldOptions)
[17:37:35.301]             if (.Platform$OS.type == "windows") {
[17:37:35.301]                 old_names <- names(...future.oldEnvVars)
[17:37:35.301]                 envs <- base::Sys.getenv()
[17:37:35.301]                 names <- names(envs)
[17:37:35.301]                 common <- intersect(names, old_names)
[17:37:35.301]                 added <- setdiff(names, old_names)
[17:37:35.301]                 removed <- setdiff(old_names, names)
[17:37:35.301]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:35.301]                   envs[common]]
[17:37:35.301]                 NAMES <- toupper(changed)
[17:37:35.301]                 args <- list()
[17:37:35.301]                 for (kk in seq_along(NAMES)) {
[17:37:35.301]                   name <- changed[[kk]]
[17:37:35.301]                   NAME <- NAMES[[kk]]
[17:37:35.301]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.301]                     next
[17:37:35.301]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.301]                 }
[17:37:35.301]                 NAMES <- toupper(added)
[17:37:35.301]                 for (kk in seq_along(NAMES)) {
[17:37:35.301]                   name <- added[[kk]]
[17:37:35.301]                   NAME <- NAMES[[kk]]
[17:37:35.301]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.301]                     next
[17:37:35.301]                   args[[name]] <- ""
[17:37:35.301]                 }
[17:37:35.301]                 NAMES <- toupper(removed)
[17:37:35.301]                 for (kk in seq_along(NAMES)) {
[17:37:35.301]                   name <- removed[[kk]]
[17:37:35.301]                   NAME <- NAMES[[kk]]
[17:37:35.301]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.301]                     next
[17:37:35.301]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.301]                 }
[17:37:35.301]                 if (length(args) > 0) 
[17:37:35.301]                   base::do.call(base::Sys.setenv, args = args)
[17:37:35.301]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:35.301]             }
[17:37:35.301]             else {
[17:37:35.301]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:35.301]             }
[17:37:35.301]             {
[17:37:35.301]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:35.301]                   0L) {
[17:37:35.301]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:35.301]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:35.301]                   base::options(opts)
[17:37:35.301]                 }
[17:37:35.301]                 {
[17:37:35.301]                   {
[17:37:35.301]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:35.301]                     NULL
[17:37:35.301]                   }
[17:37:35.301]                   options(future.plan = NULL)
[17:37:35.301]                   if (is.na(NA_character_)) 
[17:37:35.301]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.301]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:35.301]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:35.301]                     .init = FALSE)
[17:37:35.301]                 }
[17:37:35.301]             }
[17:37:35.301]         }
[17:37:35.301]     })
[17:37:35.301]     if (TRUE) {
[17:37:35.301]         base::sink(type = "output", split = FALSE)
[17:37:35.301]         if (TRUE) {
[17:37:35.301]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:35.301]         }
[17:37:35.301]         else {
[17:37:35.301]             ...future.result["stdout"] <- base::list(NULL)
[17:37:35.301]         }
[17:37:35.301]         base::close(...future.stdout)
[17:37:35.301]         ...future.stdout <- NULL
[17:37:35.301]     }
[17:37:35.301]     ...future.result$conditions <- ...future.conditions
[17:37:35.301]     ...future.result$finished <- base::Sys.time()
[17:37:35.301]     ...future.result
[17:37:35.301] }
[17:37:35.304] assign_globals() ...
[17:37:35.304] List of 5
[17:37:35.304]  $ ...future.FUN            :function (x, y)  
[17:37:35.304]  $ MoreArgs                 : list()
[17:37:35.304]  $ ...future.elements_ii    :List of 2
[17:37:35.304]   ..$ :List of 1
[17:37:35.304]   .. ..$ a: num 1
[17:37:35.304]   ..$ :List of 1
[17:37:35.304]   .. ..$ A: num 10
[17:37:35.304]  $ ...future.seeds_ii       : NULL
[17:37:35.304]  $ ...future.globals.maxSize: NULL
[17:37:35.304]  - attr(*, "where")=List of 5
[17:37:35.304]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:35.304]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:35.304]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:35.304]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:35.304]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:35.304]  - attr(*, "resolved")= logi FALSE
[17:37:35.304]  - attr(*, "total_size")= num 2088
[17:37:35.304]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.304]  - attr(*, "already-done")= logi TRUE
[17:37:35.309] - reassign environment for ‘...future.FUN’
[17:37:35.309] - copied ‘...future.FUN’ to environment
[17:37:35.309] - copied ‘MoreArgs’ to environment
[17:37:35.309] - copied ‘...future.elements_ii’ to environment
[17:37:35.309] - copied ‘...future.seeds_ii’ to environment
[17:37:35.310] - copied ‘...future.globals.maxSize’ to environment
[17:37:35.310] assign_globals() ... done
[17:37:35.310] requestCore(): workers = 2
[17:37:35.314] MulticoreFuture started
[17:37:35.315] - Launch lazy future ... done
[17:37:35.316] run() for ‘MulticoreFuture’ ... done
[17:37:35.316] plan(): Setting new future strategy stack:
[17:37:35.316] Created future:
[17:37:35.317] List of future strategies:
[17:37:35.317] 1. sequential:
[17:37:35.317]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:35.317]    - tweaked: FALSE
[17:37:35.317]    - call: NULL
[17:37:35.318] plan(): nbrOfWorkers() = 1
[17:37:35.321] plan(): Setting new future strategy stack:
[17:37:35.322] List of future strategies:
[17:37:35.322] 1. multicore:
[17:37:35.322]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:35.322]    - tweaked: FALSE
[17:37:35.322]    - call: plan(strategy)
[17:37:35.328] plan(): nbrOfWorkers() = 2
[17:37:35.317] MulticoreFuture:
[17:37:35.317] Label: ‘future_.mapply-1’
[17:37:35.317] Expression:
[17:37:35.317] {
[17:37:35.317]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.317]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:35.317]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.317]         on.exit(options(oopts), add = TRUE)
[17:37:35.317]     }
[17:37:35.317]     {
[17:37:35.317]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.317]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:35.317]         do.call(mapply, args = args)
[17:37:35.317]     }
[17:37:35.317] }
[17:37:35.317] Lazy evaluation: FALSE
[17:37:35.317] Asynchronous evaluation: TRUE
[17:37:35.317] Local evaluation: TRUE
[17:37:35.317] Environment: R_GlobalEnv
[17:37:35.317] Capture standard output: TRUE
[17:37:35.317] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:35.317] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:35.317] Packages: <none>
[17:37:35.317] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:35.317] Resolved: TRUE
[17:37:35.317] Value: <not collected>
[17:37:35.317] Conditions captured: <none>
[17:37:35.317] Early signaling: FALSE
[17:37:35.317] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:35.317] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.330] Chunk #1 of 2 ... DONE
[17:37:35.330] Chunk #2 of 2 ...
[17:37:35.330]  - Finding globals in '...' for chunk #2 ...
[17:37:35.330] getGlobalsAndPackages() ...
[17:37:35.331] Searching for globals...
[17:37:35.331] 
[17:37:35.332] Searching for globals ... DONE
[17:37:35.332] - globals: [0] <none>
[17:37:35.332] getGlobalsAndPackages() ... DONE
[17:37:35.332]    + additional globals found: [n=0] 
[17:37:35.332]    + additional namespaces needed: [n=0] 
[17:37:35.333]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:35.333]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:35.333]  - seeds: <none>
[17:37:35.333]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.333] getGlobalsAndPackages() ...
[17:37:35.334] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.334] Resolving globals: FALSE
[17:37:35.335] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[17:37:35.335] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:35.336] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.336] 
[17:37:35.336] getGlobalsAndPackages() ... DONE
[17:37:35.337] run() for ‘Future’ ...
[17:37:35.337] - state: ‘created’
[17:37:35.337] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:35.342] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.342] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:35.342]   - Field: ‘label’
[17:37:35.342]   - Field: ‘local’
[17:37:35.342]   - Field: ‘owner’
[17:37:35.342]   - Field: ‘envir’
[17:37:35.343]   - Field: ‘workers’
[17:37:35.343]   - Field: ‘packages’
[17:37:35.343]   - Field: ‘gc’
[17:37:35.343]   - Field: ‘job’
[17:37:35.343]   - Field: ‘conditions’
[17:37:35.343]   - Field: ‘expr’
[17:37:35.343]   - Field: ‘uuid’
[17:37:35.343]   - Field: ‘seed’
[17:37:35.344]   - Field: ‘version’
[17:37:35.344]   - Field: ‘result’
[17:37:35.344]   - Field: ‘asynchronous’
[17:37:35.344]   - Field: ‘calls’
[17:37:35.344]   - Field: ‘globals’
[17:37:35.344]   - Field: ‘stdout’
[17:37:35.344]   - Field: ‘earlySignal’
[17:37:35.344]   - Field: ‘lazy’
[17:37:35.345]   - Field: ‘state’
[17:37:35.345] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:35.345] - Launch lazy future ...
[17:37:35.345] Packages needed by the future expression (n = 0): <none>
[17:37:35.345] Packages needed by future strategies (n = 0): <none>
[17:37:35.346] {
[17:37:35.346]     {
[17:37:35.346]         {
[17:37:35.346]             ...future.startTime <- base::Sys.time()
[17:37:35.346]             {
[17:37:35.346]                 {
[17:37:35.346]                   {
[17:37:35.346]                     {
[17:37:35.346]                       base::local({
[17:37:35.346]                         has_future <- base::requireNamespace("future", 
[17:37:35.346]                           quietly = TRUE)
[17:37:35.346]                         if (has_future) {
[17:37:35.346]                           ns <- base::getNamespace("future")
[17:37:35.346]                           version <- ns[[".package"]][["version"]]
[17:37:35.346]                           if (is.null(version)) 
[17:37:35.346]                             version <- utils::packageVersion("future")
[17:37:35.346]                         }
[17:37:35.346]                         else {
[17:37:35.346]                           version <- NULL
[17:37:35.346]                         }
[17:37:35.346]                         if (!has_future || version < "1.8.0") {
[17:37:35.346]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:35.346]                             "", base::R.version$version.string), 
[17:37:35.346]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:35.346]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:35.346]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:35.346]                               "release", "version")], collapse = " "), 
[17:37:35.346]                             hostname = base::Sys.info()[["nodename"]])
[17:37:35.346]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:35.346]                             info)
[17:37:35.346]                           info <- base::paste(info, collapse = "; ")
[17:37:35.346]                           if (!has_future) {
[17:37:35.346]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:35.346]                               info)
[17:37:35.346]                           }
[17:37:35.346]                           else {
[17:37:35.346]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:35.346]                               info, version)
[17:37:35.346]                           }
[17:37:35.346]                           base::stop(msg)
[17:37:35.346]                         }
[17:37:35.346]                       })
[17:37:35.346]                     }
[17:37:35.346]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:35.346]                     base::options(mc.cores = 1L)
[17:37:35.346]                   }
[17:37:35.346]                   ...future.strategy.old <- future::plan("list")
[17:37:35.346]                   options(future.plan = NULL)
[17:37:35.346]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.346]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:35.346]                 }
[17:37:35.346]                 ...future.workdir <- getwd()
[17:37:35.346]             }
[17:37:35.346]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:35.346]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:35.346]         }
[17:37:35.346]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:35.346]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:35.346]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:35.346]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:35.346]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:35.346]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:35.346]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:35.346]             base::names(...future.oldOptions))
[17:37:35.346]     }
[17:37:35.346]     if (FALSE) {
[17:37:35.346]     }
[17:37:35.346]     else {
[17:37:35.346]         if (TRUE) {
[17:37:35.346]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:35.346]                 open = "w")
[17:37:35.346]         }
[17:37:35.346]         else {
[17:37:35.346]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:35.346]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:35.346]         }
[17:37:35.346]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:35.346]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:35.346]             base::sink(type = "output", split = FALSE)
[17:37:35.346]             base::close(...future.stdout)
[17:37:35.346]         }, add = TRUE)
[17:37:35.346]     }
[17:37:35.346]     ...future.frame <- base::sys.nframe()
[17:37:35.346]     ...future.conditions <- base::list()
[17:37:35.346]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:35.346]     if (FALSE) {
[17:37:35.346]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:35.346]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:35.346]     }
[17:37:35.346]     ...future.result <- base::tryCatch({
[17:37:35.346]         base::withCallingHandlers({
[17:37:35.346]             ...future.value <- base::withVisible(base::local({
[17:37:35.346]                 withCallingHandlers({
[17:37:35.346]                   {
[17:37:35.346]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.346]                     if (!identical(...future.globals.maxSize.org, 
[17:37:35.346]                       ...future.globals.maxSize)) {
[17:37:35.346]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.346]                       on.exit(options(oopts), add = TRUE)
[17:37:35.346]                     }
[17:37:35.346]                     {
[17:37:35.346]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.346]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:35.346]                         USE.NAMES = FALSE)
[17:37:35.346]                       do.call(mapply, args = args)
[17:37:35.346]                     }
[17:37:35.346]                   }
[17:37:35.346]                 }, immediateCondition = function(cond) {
[17:37:35.346]                   save_rds <- function (object, pathname, ...) 
[17:37:35.346]                   {
[17:37:35.346]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:35.346]                     if (file_test("-f", pathname_tmp)) {
[17:37:35.346]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.346]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:35.346]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.346]                         fi_tmp[["mtime"]])
[17:37:35.346]                     }
[17:37:35.346]                     tryCatch({
[17:37:35.346]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:35.346]                     }, error = function(ex) {
[17:37:35.346]                       msg <- conditionMessage(ex)
[17:37:35.346]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.346]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:35.346]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.346]                         fi_tmp[["mtime"]], msg)
[17:37:35.346]                       ex$message <- msg
[17:37:35.346]                       stop(ex)
[17:37:35.346]                     })
[17:37:35.346]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:35.346]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:35.346]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:35.346]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.346]                       fi <- file.info(pathname)
[17:37:35.346]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:35.346]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.346]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:35.346]                         fi[["size"]], fi[["mtime"]])
[17:37:35.346]                       stop(msg)
[17:37:35.346]                     }
[17:37:35.346]                     invisible(pathname)
[17:37:35.346]                   }
[17:37:35.346]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:35.346]                     rootPath = tempdir()) 
[17:37:35.346]                   {
[17:37:35.346]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:35.346]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:35.346]                       tmpdir = path, fileext = ".rds")
[17:37:35.346]                     save_rds(obj, file)
[17:37:35.346]                   }
[17:37:35.346]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:35.346]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.346]                   {
[17:37:35.346]                     inherits <- base::inherits
[17:37:35.346]                     invokeRestart <- base::invokeRestart
[17:37:35.346]                     is.null <- base::is.null
[17:37:35.346]                     muffled <- FALSE
[17:37:35.346]                     if (inherits(cond, "message")) {
[17:37:35.346]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:35.346]                       if (muffled) 
[17:37:35.346]                         invokeRestart("muffleMessage")
[17:37:35.346]                     }
[17:37:35.346]                     else if (inherits(cond, "warning")) {
[17:37:35.346]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:35.346]                       if (muffled) 
[17:37:35.346]                         invokeRestart("muffleWarning")
[17:37:35.346]                     }
[17:37:35.346]                     else if (inherits(cond, "condition")) {
[17:37:35.346]                       if (!is.null(pattern)) {
[17:37:35.346]                         computeRestarts <- base::computeRestarts
[17:37:35.346]                         grepl <- base::grepl
[17:37:35.346]                         restarts <- computeRestarts(cond)
[17:37:35.346]                         for (restart in restarts) {
[17:37:35.346]                           name <- restart$name
[17:37:35.346]                           if (is.null(name)) 
[17:37:35.346]                             next
[17:37:35.346]                           if (!grepl(pattern, name)) 
[17:37:35.346]                             next
[17:37:35.346]                           invokeRestart(restart)
[17:37:35.346]                           muffled <- TRUE
[17:37:35.346]                           break
[17:37:35.346]                         }
[17:37:35.346]                       }
[17:37:35.346]                     }
[17:37:35.346]                     invisible(muffled)
[17:37:35.346]                   }
[17:37:35.346]                   muffleCondition(cond)
[17:37:35.346]                 })
[17:37:35.346]             }))
[17:37:35.346]             future::FutureResult(value = ...future.value$value, 
[17:37:35.346]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.346]                   ...future.rng), globalenv = if (FALSE) 
[17:37:35.346]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:35.346]                     ...future.globalenv.names))
[17:37:35.346]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:35.346]         }, condition = base::local({
[17:37:35.346]             c <- base::c
[17:37:35.346]             inherits <- base::inherits
[17:37:35.346]             invokeRestart <- base::invokeRestart
[17:37:35.346]             length <- base::length
[17:37:35.346]             list <- base::list
[17:37:35.346]             seq.int <- base::seq.int
[17:37:35.346]             signalCondition <- base::signalCondition
[17:37:35.346]             sys.calls <- base::sys.calls
[17:37:35.346]             `[[` <- base::`[[`
[17:37:35.346]             `+` <- base::`+`
[17:37:35.346]             `<<-` <- base::`<<-`
[17:37:35.346]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:35.346]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:35.346]                   3L)]
[17:37:35.346]             }
[17:37:35.346]             function(cond) {
[17:37:35.346]                 is_error <- inherits(cond, "error")
[17:37:35.346]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:35.346]                   NULL)
[17:37:35.346]                 if (is_error) {
[17:37:35.346]                   sessionInformation <- function() {
[17:37:35.346]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:35.346]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:35.346]                       search = base::search(), system = base::Sys.info())
[17:37:35.346]                   }
[17:37:35.346]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.346]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:35.346]                     cond$call), session = sessionInformation(), 
[17:37:35.346]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:35.346]                   signalCondition(cond)
[17:37:35.346]                 }
[17:37:35.346]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:35.346]                 "immediateCondition"))) {
[17:37:35.346]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:35.346]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.346]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:35.346]                   if (TRUE && !signal) {
[17:37:35.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.346]                     {
[17:37:35.346]                       inherits <- base::inherits
[17:37:35.346]                       invokeRestart <- base::invokeRestart
[17:37:35.346]                       is.null <- base::is.null
[17:37:35.346]                       muffled <- FALSE
[17:37:35.346]                       if (inherits(cond, "message")) {
[17:37:35.346]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.346]                         if (muffled) 
[17:37:35.346]                           invokeRestart("muffleMessage")
[17:37:35.346]                       }
[17:37:35.346]                       else if (inherits(cond, "warning")) {
[17:37:35.346]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.346]                         if (muffled) 
[17:37:35.346]                           invokeRestart("muffleWarning")
[17:37:35.346]                       }
[17:37:35.346]                       else if (inherits(cond, "condition")) {
[17:37:35.346]                         if (!is.null(pattern)) {
[17:37:35.346]                           computeRestarts <- base::computeRestarts
[17:37:35.346]                           grepl <- base::grepl
[17:37:35.346]                           restarts <- computeRestarts(cond)
[17:37:35.346]                           for (restart in restarts) {
[17:37:35.346]                             name <- restart$name
[17:37:35.346]                             if (is.null(name)) 
[17:37:35.346]                               next
[17:37:35.346]                             if (!grepl(pattern, name)) 
[17:37:35.346]                               next
[17:37:35.346]                             invokeRestart(restart)
[17:37:35.346]                             muffled <- TRUE
[17:37:35.346]                             break
[17:37:35.346]                           }
[17:37:35.346]                         }
[17:37:35.346]                       }
[17:37:35.346]                       invisible(muffled)
[17:37:35.346]                     }
[17:37:35.346]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.346]                   }
[17:37:35.346]                 }
[17:37:35.346]                 else {
[17:37:35.346]                   if (TRUE) {
[17:37:35.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.346]                     {
[17:37:35.346]                       inherits <- base::inherits
[17:37:35.346]                       invokeRestart <- base::invokeRestart
[17:37:35.346]                       is.null <- base::is.null
[17:37:35.346]                       muffled <- FALSE
[17:37:35.346]                       if (inherits(cond, "message")) {
[17:37:35.346]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.346]                         if (muffled) 
[17:37:35.346]                           invokeRestart("muffleMessage")
[17:37:35.346]                       }
[17:37:35.346]                       else if (inherits(cond, "warning")) {
[17:37:35.346]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.346]                         if (muffled) 
[17:37:35.346]                           invokeRestart("muffleWarning")
[17:37:35.346]                       }
[17:37:35.346]                       else if (inherits(cond, "condition")) {
[17:37:35.346]                         if (!is.null(pattern)) {
[17:37:35.346]                           computeRestarts <- base::computeRestarts
[17:37:35.346]                           grepl <- base::grepl
[17:37:35.346]                           restarts <- computeRestarts(cond)
[17:37:35.346]                           for (restart in restarts) {
[17:37:35.346]                             name <- restart$name
[17:37:35.346]                             if (is.null(name)) 
[17:37:35.346]                               next
[17:37:35.346]                             if (!grepl(pattern, name)) 
[17:37:35.346]                               next
[17:37:35.346]                             invokeRestart(restart)
[17:37:35.346]                             muffled <- TRUE
[17:37:35.346]                             break
[17:37:35.346]                           }
[17:37:35.346]                         }
[17:37:35.346]                       }
[17:37:35.346]                       invisible(muffled)
[17:37:35.346]                     }
[17:37:35.346]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.346]                   }
[17:37:35.346]                 }
[17:37:35.346]             }
[17:37:35.346]         }))
[17:37:35.346]     }, error = function(ex) {
[17:37:35.346]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:35.346]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.346]                 ...future.rng), started = ...future.startTime, 
[17:37:35.346]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:35.346]             version = "1.8"), class = "FutureResult")
[17:37:35.346]     }, finally = {
[17:37:35.346]         if (!identical(...future.workdir, getwd())) 
[17:37:35.346]             setwd(...future.workdir)
[17:37:35.346]         {
[17:37:35.346]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:35.346]                 ...future.oldOptions$nwarnings <- NULL
[17:37:35.346]             }
[17:37:35.346]             base::options(...future.oldOptions)
[17:37:35.346]             if (.Platform$OS.type == "windows") {
[17:37:35.346]                 old_names <- names(...future.oldEnvVars)
[17:37:35.346]                 envs <- base::Sys.getenv()
[17:37:35.346]                 names <- names(envs)
[17:37:35.346]                 common <- intersect(names, old_names)
[17:37:35.346]                 added <- setdiff(names, old_names)
[17:37:35.346]                 removed <- setdiff(old_names, names)
[17:37:35.346]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:35.346]                   envs[common]]
[17:37:35.346]                 NAMES <- toupper(changed)
[17:37:35.346]                 args <- list()
[17:37:35.346]                 for (kk in seq_along(NAMES)) {
[17:37:35.346]                   name <- changed[[kk]]
[17:37:35.346]                   NAME <- NAMES[[kk]]
[17:37:35.346]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.346]                     next
[17:37:35.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.346]                 }
[17:37:35.346]                 NAMES <- toupper(added)
[17:37:35.346]                 for (kk in seq_along(NAMES)) {
[17:37:35.346]                   name <- added[[kk]]
[17:37:35.346]                   NAME <- NAMES[[kk]]
[17:37:35.346]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.346]                     next
[17:37:35.346]                   args[[name]] <- ""
[17:37:35.346]                 }
[17:37:35.346]                 NAMES <- toupper(removed)
[17:37:35.346]                 for (kk in seq_along(NAMES)) {
[17:37:35.346]                   name <- removed[[kk]]
[17:37:35.346]                   NAME <- NAMES[[kk]]
[17:37:35.346]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.346]                     next
[17:37:35.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.346]                 }
[17:37:35.346]                 if (length(args) > 0) 
[17:37:35.346]                   base::do.call(base::Sys.setenv, args = args)
[17:37:35.346]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:35.346]             }
[17:37:35.346]             else {
[17:37:35.346]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:35.346]             }
[17:37:35.346]             {
[17:37:35.346]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:35.346]                   0L) {
[17:37:35.346]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:35.346]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:35.346]                   base::options(opts)
[17:37:35.346]                 }
[17:37:35.346]                 {
[17:37:35.346]                   {
[17:37:35.346]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:35.346]                     NULL
[17:37:35.346]                   }
[17:37:35.346]                   options(future.plan = NULL)
[17:37:35.346]                   if (is.na(NA_character_)) 
[17:37:35.346]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.346]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:35.346]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:35.346]                     .init = FALSE)
[17:37:35.346]                 }
[17:37:35.346]             }
[17:37:35.346]         }
[17:37:35.346]     })
[17:37:35.346]     if (TRUE) {
[17:37:35.346]         base::sink(type = "output", split = FALSE)
[17:37:35.346]         if (TRUE) {
[17:37:35.346]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:35.346]         }
[17:37:35.346]         else {
[17:37:35.346]             ...future.result["stdout"] <- base::list(NULL)
[17:37:35.346]         }
[17:37:35.346]         base::close(...future.stdout)
[17:37:35.346]         ...future.stdout <- NULL
[17:37:35.346]     }
[17:37:35.346]     ...future.result$conditions <- ...future.conditions
[17:37:35.346]     ...future.result$finished <- base::Sys.time()
[17:37:35.346]     ...future.result
[17:37:35.346] }
[17:37:35.349] assign_globals() ...
[17:37:35.349] List of 5
[17:37:35.349]  $ ...future.FUN            :function (x, y)  
[17:37:35.349]  $ MoreArgs                 : list()
[17:37:35.349]  $ ...future.elements_ii    :List of 2
[17:37:35.349]   ..$ :List of 2
[17:37:35.349]   .. ..$ b: num 2
[17:37:35.349]   .. ..$ c: num 3
[17:37:35.349]   ..$ :List of 2
[17:37:35.349]   .. ..$ B: num 0
[17:37:35.349]   .. ..$ C: num -10
[17:37:35.349]  $ ...future.seeds_ii       : NULL
[17:37:35.349]  $ ...future.globals.maxSize: NULL
[17:37:35.349]  - attr(*, "where")=List of 5
[17:37:35.349]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:35.349]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:35.349]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:35.349]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:35.349]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:35.349]  - attr(*, "resolved")= logi FALSE
[17:37:35.349]  - attr(*, "total_size")= num 2200
[17:37:35.349]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.349]  - attr(*, "already-done")= logi TRUE
[17:37:35.357] - reassign environment for ‘...future.FUN’
[17:37:35.357] - copied ‘...future.FUN’ to environment
[17:37:35.357] - copied ‘MoreArgs’ to environment
[17:37:35.357] - copied ‘...future.elements_ii’ to environment
[17:37:35.357] - copied ‘...future.seeds_ii’ to environment
[17:37:35.357] - copied ‘...future.globals.maxSize’ to environment
[17:37:35.357] assign_globals() ... done
[17:37:35.358] requestCore(): workers = 2
[17:37:35.360] MulticoreFuture started
[17:37:35.360] - Launch lazy future ... done
[17:37:35.361] run() for ‘MulticoreFuture’ ... done
[17:37:35.361] Created future:
[17:37:35.361] plan(): Setting new future strategy stack:
[17:37:35.361] List of future strategies:
[17:37:35.361] 1. sequential:
[17:37:35.361]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:35.361]    - tweaked: FALSE
[17:37:35.361]    - call: NULL
[17:37:35.362] plan(): nbrOfWorkers() = 1
[17:37:35.364] plan(): Setting new future strategy stack:
[17:37:35.364] List of future strategies:
[17:37:35.364] 1. multicore:
[17:37:35.364]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:35.364]    - tweaked: FALSE
[17:37:35.364]    - call: plan(strategy)
[17:37:35.370] plan(): nbrOfWorkers() = 2
[17:37:35.361] MulticoreFuture:
[17:37:35.361] Label: ‘future_.mapply-2’
[17:37:35.361] Expression:
[17:37:35.361] {
[17:37:35.361]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.361]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:35.361]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.361]         on.exit(options(oopts), add = TRUE)
[17:37:35.361]     }
[17:37:35.361]     {
[17:37:35.361]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.361]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:35.361]         do.call(mapply, args = args)
[17:37:35.361]     }
[17:37:35.361] }
[17:37:35.361] Lazy evaluation: FALSE
[17:37:35.361] Asynchronous evaluation: TRUE
[17:37:35.361] Local evaluation: TRUE
[17:37:35.361] Environment: R_GlobalEnv
[17:37:35.361] Capture standard output: TRUE
[17:37:35.361] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:35.361] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:35.361] Packages: <none>
[17:37:35.361] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:35.361] Resolved: TRUE
[17:37:35.361] Value: <not collected>
[17:37:35.361] Conditions captured: <none>
[17:37:35.361] Early signaling: FALSE
[17:37:35.361] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:35.361] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.371] Chunk #2 of 2 ... DONE
[17:37:35.371] Launching 2 futures (chunks) ... DONE
[17:37:35.371] Resolving 2 futures (chunks) ...
[17:37:35.371] resolve() on list ...
[17:37:35.372]  recursive: 0
[17:37:35.372]  length: 2
[17:37:35.372] 
[17:37:35.372] Future #1
[17:37:35.372] result() for MulticoreFuture ...
[17:37:35.373] result() for MulticoreFuture ...
[17:37:35.374] result() for MulticoreFuture ... done
[17:37:35.374] result() for MulticoreFuture ... done
[17:37:35.374] result() for MulticoreFuture ...
[17:37:35.374] result() for MulticoreFuture ... done
[17:37:35.374] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:37:35.374] - nx: 2
[17:37:35.374] - relay: TRUE
[17:37:35.375] - stdout: TRUE
[17:37:35.375] - signal: TRUE
[17:37:35.379] - resignal: FALSE
[17:37:35.380] - force: TRUE
[17:37:35.380] - relayed: [n=2] FALSE, FALSE
[17:37:35.380] - queued futures: [n=2] FALSE, FALSE
[17:37:35.381]  - until=1
[17:37:35.381]  - relaying element #1
[17:37:35.382] result() for MulticoreFuture ...
[17:37:35.382] result() for MulticoreFuture ... done
[17:37:35.382] result() for MulticoreFuture ...
[17:37:35.383] result() for MulticoreFuture ... done
[17:37:35.383] result() for MulticoreFuture ...
[17:37:35.383] result() for MulticoreFuture ... done
[17:37:35.383] result() for MulticoreFuture ...
[17:37:35.384] result() for MulticoreFuture ... done
[17:37:35.384] - relayed: [n=2] TRUE, FALSE
[17:37:35.384] - queued futures: [n=2] TRUE, FALSE
[17:37:35.385] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:37:35.385]  length: 1 (resolved future 1)
[17:37:35.386] Future #2
[17:37:35.386] result() for MulticoreFuture ...
[17:37:35.387] result() for MulticoreFuture ...
[17:37:35.387] result() for MulticoreFuture ... done
[17:37:35.387] result() for MulticoreFuture ... done
[17:37:35.388] result() for MulticoreFuture ...
[17:37:35.388] result() for MulticoreFuture ... done
[17:37:35.388] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:37:35.388] - nx: 2
[17:37:35.388] - relay: TRUE
[17:37:35.388] - stdout: TRUE
[17:37:35.389] - signal: TRUE
[17:37:35.389] - resignal: FALSE
[17:37:35.389] - force: TRUE
[17:37:35.389] - relayed: [n=2] TRUE, FALSE
[17:37:35.389] - queued futures: [n=2] TRUE, FALSE
[17:37:35.389]  - until=2
[17:37:35.389]  - relaying element #2
[17:37:35.389] result() for MulticoreFuture ...
[17:37:35.389] result() for MulticoreFuture ... done
[17:37:35.390] result() for MulticoreFuture ...
[17:37:35.390] result() for MulticoreFuture ... done
[17:37:35.390] result() for MulticoreFuture ...
[17:37:35.390] result() for MulticoreFuture ... done
[17:37:35.390] result() for MulticoreFuture ...
[17:37:35.390] result() for MulticoreFuture ... done
[17:37:35.390] - relayed: [n=2] TRUE, TRUE
[17:37:35.390] - queued futures: [n=2] TRUE, TRUE
[17:37:35.390] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:37:35.391]  length: 0 (resolved future 2)
[17:37:35.391] Relaying remaining futures
[17:37:35.391] signalConditionsASAP(NULL, pos=0) ...
[17:37:35.391] - nx: 2
[17:37:35.391] - relay: TRUE
[17:37:35.391] - stdout: TRUE
[17:37:35.391] - signal: TRUE
[17:37:35.391] - resignal: FALSE
[17:37:35.391] - force: TRUE
[17:37:35.392] - relayed: [n=2] TRUE, TRUE
[17:37:35.392] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:35.392] - relayed: [n=2] TRUE, TRUE
[17:37:35.392] - queued futures: [n=2] TRUE, TRUE
[17:37:35.392] signalConditionsASAP(NULL, pos=0) ... done
[17:37:35.392] resolve() on list ... DONE
[17:37:35.392] result() for MulticoreFuture ...
[17:37:35.393] result() for MulticoreFuture ... done
[17:37:35.393] result() for MulticoreFuture ...
[17:37:35.393] result() for MulticoreFuture ... done
[17:37:35.393] result() for MulticoreFuture ...
[17:37:35.393] result() for MulticoreFuture ... done
[17:37:35.393] result() for MulticoreFuture ...
[17:37:35.393] result() for MulticoreFuture ... done
[17:37:35.393]  - Number of value chunks collected: 2
[17:37:35.393] Resolving 2 futures (chunks) ... DONE
[17:37:35.394] Reducing values from 2 chunks ...
[17:37:35.394]  - Number of values collected after concatenation: 3
[17:37:35.394]  - Number of values expected: 3
[17:37:35.394] Reducing values from 2 chunks ... DONE
[17:37:35.394] future_mapply() ... DONE
[17:37:35.394] future_mapply() ...
[17:37:35.398] Number of chunks: 5
[17:37:35.399] getGlobalsAndPackagesXApply() ...
[17:37:35.399]  - future.globals: TRUE
[17:37:35.399] getGlobalsAndPackages() ...
[17:37:35.399] Searching for globals...
[17:37:35.400] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:37:35.401] Searching for globals ... DONE
[17:37:35.401] Resolving globals: FALSE
[17:37:35.401] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:37:35.401] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:37:35.402] - globals: [1] ‘FUN’
[17:37:35.402] 
[17:37:35.402] getGlobalsAndPackages() ... DONE
[17:37:35.402]  - globals found/used: [n=1] ‘FUN’
[17:37:35.402]  - needed namespaces: [n=0] 
[17:37:35.402] Finding globals ... DONE
[17:37:35.402] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:35.402] List of 2
[17:37:35.402]  $ ...future.FUN:function (C, k)  
[17:37:35.402]  $ MoreArgs     : NULL
[17:37:35.402]  - attr(*, "where")=List of 2
[17:37:35.402]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:35.402]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:35.402]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.402]  - attr(*, "resolved")= logi FALSE
[17:37:35.402]  - attr(*, "total_size")= num NA
[17:37:35.405] Packages to be attached in all futures: [n=0] 
[17:37:35.405] getGlobalsAndPackagesXApply() ... DONE
[17:37:35.406] Number of futures (= number of chunks): 5
[17:37:35.406] Launching 5 futures (chunks) ...
[17:37:35.406] Chunk #1 of 5 ...
[17:37:35.406]  - Finding globals in '...' for chunk #1 ...
[17:37:35.406] getGlobalsAndPackages() ...
[17:37:35.406] Searching for globals...
[17:37:35.406] 
[17:37:35.407] Searching for globals ... DONE
[17:37:35.407] - globals: [0] <none>
[17:37:35.407] getGlobalsAndPackages() ... DONE
[17:37:35.407]    + additional globals found: [n=0] 
[17:37:35.407]    + additional namespaces needed: [n=0] 
[17:37:35.407]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:35.407]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:37:35.407]  - seeds: <none>
[17:37:35.407]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.407] getGlobalsAndPackages() ...
[17:37:35.408] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.408] Resolving globals: FALSE
[17:37:35.408] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:37:35.409] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:35.409] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.409] 
[17:37:35.409] getGlobalsAndPackages() ... DONE
[17:37:35.409] run() for ‘Future’ ...
[17:37:35.409] - state: ‘created’
[17:37:35.410] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:35.416] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.416] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:35.416]   - Field: ‘label’
[17:37:35.416]   - Field: ‘local’
[17:37:35.416]   - Field: ‘owner’
[17:37:35.417]   - Field: ‘envir’
[17:37:35.417]   - Field: ‘workers’
[17:37:35.417]   - Field: ‘packages’
[17:37:35.417]   - Field: ‘gc’
[17:37:35.417]   - Field: ‘job’
[17:37:35.417]   - Field: ‘conditions’
[17:37:35.417]   - Field: ‘expr’
[17:37:35.417]   - Field: ‘uuid’
[17:37:35.418]   - Field: ‘seed’
[17:37:35.418]   - Field: ‘version’
[17:37:35.418]   - Field: ‘result’
[17:37:35.418]   - Field: ‘asynchronous’
[17:37:35.418]   - Field: ‘calls’
[17:37:35.418]   - Field: ‘globals’
[17:37:35.418]   - Field: ‘stdout’
[17:37:35.418]   - Field: ‘earlySignal’
[17:37:35.418]   - Field: ‘lazy’
[17:37:35.419]   - Field: ‘state’
[17:37:35.419] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:35.419] - Launch lazy future ...
[17:37:35.419] Packages needed by the future expression (n = 0): <none>
[17:37:35.419] Packages needed by future strategies (n = 0): <none>
[17:37:35.420] {
[17:37:35.420]     {
[17:37:35.420]         {
[17:37:35.420]             ...future.startTime <- base::Sys.time()
[17:37:35.420]             {
[17:37:35.420]                 {
[17:37:35.420]                   {
[17:37:35.420]                     {
[17:37:35.420]                       base::local({
[17:37:35.420]                         has_future <- base::requireNamespace("future", 
[17:37:35.420]                           quietly = TRUE)
[17:37:35.420]                         if (has_future) {
[17:37:35.420]                           ns <- base::getNamespace("future")
[17:37:35.420]                           version <- ns[[".package"]][["version"]]
[17:37:35.420]                           if (is.null(version)) 
[17:37:35.420]                             version <- utils::packageVersion("future")
[17:37:35.420]                         }
[17:37:35.420]                         else {
[17:37:35.420]                           version <- NULL
[17:37:35.420]                         }
[17:37:35.420]                         if (!has_future || version < "1.8.0") {
[17:37:35.420]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:35.420]                             "", base::R.version$version.string), 
[17:37:35.420]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:35.420]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:35.420]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:35.420]                               "release", "version")], collapse = " "), 
[17:37:35.420]                             hostname = base::Sys.info()[["nodename"]])
[17:37:35.420]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:35.420]                             info)
[17:37:35.420]                           info <- base::paste(info, collapse = "; ")
[17:37:35.420]                           if (!has_future) {
[17:37:35.420]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:35.420]                               info)
[17:37:35.420]                           }
[17:37:35.420]                           else {
[17:37:35.420]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:35.420]                               info, version)
[17:37:35.420]                           }
[17:37:35.420]                           base::stop(msg)
[17:37:35.420]                         }
[17:37:35.420]                       })
[17:37:35.420]                     }
[17:37:35.420]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:35.420]                     base::options(mc.cores = 1L)
[17:37:35.420]                   }
[17:37:35.420]                   ...future.strategy.old <- future::plan("list")
[17:37:35.420]                   options(future.plan = NULL)
[17:37:35.420]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.420]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:35.420]                 }
[17:37:35.420]                 ...future.workdir <- getwd()
[17:37:35.420]             }
[17:37:35.420]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:35.420]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:35.420]         }
[17:37:35.420]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:35.420]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:37:35.420]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:35.420]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:35.420]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:35.420]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:35.420]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:35.420]             base::names(...future.oldOptions))
[17:37:35.420]     }
[17:37:35.420]     if (FALSE) {
[17:37:35.420]     }
[17:37:35.420]     else {
[17:37:35.420]         if (TRUE) {
[17:37:35.420]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:35.420]                 open = "w")
[17:37:35.420]         }
[17:37:35.420]         else {
[17:37:35.420]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:35.420]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:35.420]         }
[17:37:35.420]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:35.420]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:35.420]             base::sink(type = "output", split = FALSE)
[17:37:35.420]             base::close(...future.stdout)
[17:37:35.420]         }, add = TRUE)
[17:37:35.420]     }
[17:37:35.420]     ...future.frame <- base::sys.nframe()
[17:37:35.420]     ...future.conditions <- base::list()
[17:37:35.420]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:35.420]     if (FALSE) {
[17:37:35.420]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:35.420]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:35.420]     }
[17:37:35.420]     ...future.result <- base::tryCatch({
[17:37:35.420]         base::withCallingHandlers({
[17:37:35.420]             ...future.value <- base::withVisible(base::local({
[17:37:35.420]                 withCallingHandlers({
[17:37:35.420]                   {
[17:37:35.420]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.420]                     if (!identical(...future.globals.maxSize.org, 
[17:37:35.420]                       ...future.globals.maxSize)) {
[17:37:35.420]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.420]                       on.exit(options(oopts), add = TRUE)
[17:37:35.420]                     }
[17:37:35.420]                     {
[17:37:35.420]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.420]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:35.420]                         USE.NAMES = FALSE)
[17:37:35.420]                       do.call(mapply, args = args)
[17:37:35.420]                     }
[17:37:35.420]                   }
[17:37:35.420]                 }, immediateCondition = function(cond) {
[17:37:35.420]                   save_rds <- function (object, pathname, ...) 
[17:37:35.420]                   {
[17:37:35.420]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:35.420]                     if (file_test("-f", pathname_tmp)) {
[17:37:35.420]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.420]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:35.420]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.420]                         fi_tmp[["mtime"]])
[17:37:35.420]                     }
[17:37:35.420]                     tryCatch({
[17:37:35.420]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:35.420]                     }, error = function(ex) {
[17:37:35.420]                       msg <- conditionMessage(ex)
[17:37:35.420]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.420]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:35.420]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.420]                         fi_tmp[["mtime"]], msg)
[17:37:35.420]                       ex$message <- msg
[17:37:35.420]                       stop(ex)
[17:37:35.420]                     })
[17:37:35.420]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:35.420]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:35.420]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:35.420]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.420]                       fi <- file.info(pathname)
[17:37:35.420]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:35.420]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.420]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:35.420]                         fi[["size"]], fi[["mtime"]])
[17:37:35.420]                       stop(msg)
[17:37:35.420]                     }
[17:37:35.420]                     invisible(pathname)
[17:37:35.420]                   }
[17:37:35.420]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:35.420]                     rootPath = tempdir()) 
[17:37:35.420]                   {
[17:37:35.420]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:35.420]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:35.420]                       tmpdir = path, fileext = ".rds")
[17:37:35.420]                     save_rds(obj, file)
[17:37:35.420]                   }
[17:37:35.420]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:35.420]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.420]                   {
[17:37:35.420]                     inherits <- base::inherits
[17:37:35.420]                     invokeRestart <- base::invokeRestart
[17:37:35.420]                     is.null <- base::is.null
[17:37:35.420]                     muffled <- FALSE
[17:37:35.420]                     if (inherits(cond, "message")) {
[17:37:35.420]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:35.420]                       if (muffled) 
[17:37:35.420]                         invokeRestart("muffleMessage")
[17:37:35.420]                     }
[17:37:35.420]                     else if (inherits(cond, "warning")) {
[17:37:35.420]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:35.420]                       if (muffled) 
[17:37:35.420]                         invokeRestart("muffleWarning")
[17:37:35.420]                     }
[17:37:35.420]                     else if (inherits(cond, "condition")) {
[17:37:35.420]                       if (!is.null(pattern)) {
[17:37:35.420]                         computeRestarts <- base::computeRestarts
[17:37:35.420]                         grepl <- base::grepl
[17:37:35.420]                         restarts <- computeRestarts(cond)
[17:37:35.420]                         for (restart in restarts) {
[17:37:35.420]                           name <- restart$name
[17:37:35.420]                           if (is.null(name)) 
[17:37:35.420]                             next
[17:37:35.420]                           if (!grepl(pattern, name)) 
[17:37:35.420]                             next
[17:37:35.420]                           invokeRestart(restart)
[17:37:35.420]                           muffled <- TRUE
[17:37:35.420]                           break
[17:37:35.420]                         }
[17:37:35.420]                       }
[17:37:35.420]                     }
[17:37:35.420]                     invisible(muffled)
[17:37:35.420]                   }
[17:37:35.420]                   muffleCondition(cond)
[17:37:35.420]                 })
[17:37:35.420]             }))
[17:37:35.420]             future::FutureResult(value = ...future.value$value, 
[17:37:35.420]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.420]                   ...future.rng), globalenv = if (FALSE) 
[17:37:35.420]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:35.420]                     ...future.globalenv.names))
[17:37:35.420]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:35.420]         }, condition = base::local({
[17:37:35.420]             c <- base::c
[17:37:35.420]             inherits <- base::inherits
[17:37:35.420]             invokeRestart <- base::invokeRestart
[17:37:35.420]             length <- base::length
[17:37:35.420]             list <- base::list
[17:37:35.420]             seq.int <- base::seq.int
[17:37:35.420]             signalCondition <- base::signalCondition
[17:37:35.420]             sys.calls <- base::sys.calls
[17:37:35.420]             `[[` <- base::`[[`
[17:37:35.420]             `+` <- base::`+`
[17:37:35.420]             `<<-` <- base::`<<-`
[17:37:35.420]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:35.420]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:35.420]                   3L)]
[17:37:35.420]             }
[17:37:35.420]             function(cond) {
[17:37:35.420]                 is_error <- inherits(cond, "error")
[17:37:35.420]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:35.420]                   NULL)
[17:37:35.420]                 if (is_error) {
[17:37:35.420]                   sessionInformation <- function() {
[17:37:35.420]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:35.420]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:35.420]                       search = base::search(), system = base::Sys.info())
[17:37:35.420]                   }
[17:37:35.420]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.420]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:35.420]                     cond$call), session = sessionInformation(), 
[17:37:35.420]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:35.420]                   signalCondition(cond)
[17:37:35.420]                 }
[17:37:35.420]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:35.420]                 "immediateCondition"))) {
[17:37:35.420]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:35.420]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.420]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:35.420]                   if (TRUE && !signal) {
[17:37:35.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.420]                     {
[17:37:35.420]                       inherits <- base::inherits
[17:37:35.420]                       invokeRestart <- base::invokeRestart
[17:37:35.420]                       is.null <- base::is.null
[17:37:35.420]                       muffled <- FALSE
[17:37:35.420]                       if (inherits(cond, "message")) {
[17:37:35.420]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.420]                         if (muffled) 
[17:37:35.420]                           invokeRestart("muffleMessage")
[17:37:35.420]                       }
[17:37:35.420]                       else if (inherits(cond, "warning")) {
[17:37:35.420]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.420]                         if (muffled) 
[17:37:35.420]                           invokeRestart("muffleWarning")
[17:37:35.420]                       }
[17:37:35.420]                       else if (inherits(cond, "condition")) {
[17:37:35.420]                         if (!is.null(pattern)) {
[17:37:35.420]                           computeRestarts <- base::computeRestarts
[17:37:35.420]                           grepl <- base::grepl
[17:37:35.420]                           restarts <- computeRestarts(cond)
[17:37:35.420]                           for (restart in restarts) {
[17:37:35.420]                             name <- restart$name
[17:37:35.420]                             if (is.null(name)) 
[17:37:35.420]                               next
[17:37:35.420]                             if (!grepl(pattern, name)) 
[17:37:35.420]                               next
[17:37:35.420]                             invokeRestart(restart)
[17:37:35.420]                             muffled <- TRUE
[17:37:35.420]                             break
[17:37:35.420]                           }
[17:37:35.420]                         }
[17:37:35.420]                       }
[17:37:35.420]                       invisible(muffled)
[17:37:35.420]                     }
[17:37:35.420]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.420]                   }
[17:37:35.420]                 }
[17:37:35.420]                 else {
[17:37:35.420]                   if (TRUE) {
[17:37:35.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.420]                     {
[17:37:35.420]                       inherits <- base::inherits
[17:37:35.420]                       invokeRestart <- base::invokeRestart
[17:37:35.420]                       is.null <- base::is.null
[17:37:35.420]                       muffled <- FALSE
[17:37:35.420]                       if (inherits(cond, "message")) {
[17:37:35.420]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.420]                         if (muffled) 
[17:37:35.420]                           invokeRestart("muffleMessage")
[17:37:35.420]                       }
[17:37:35.420]                       else if (inherits(cond, "warning")) {
[17:37:35.420]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.420]                         if (muffled) 
[17:37:35.420]                           invokeRestart("muffleWarning")
[17:37:35.420]                       }
[17:37:35.420]                       else if (inherits(cond, "condition")) {
[17:37:35.420]                         if (!is.null(pattern)) {
[17:37:35.420]                           computeRestarts <- base::computeRestarts
[17:37:35.420]                           grepl <- base::grepl
[17:37:35.420]                           restarts <- computeRestarts(cond)
[17:37:35.420]                           for (restart in restarts) {
[17:37:35.420]                             name <- restart$name
[17:37:35.420]                             if (is.null(name)) 
[17:37:35.420]                               next
[17:37:35.420]                             if (!grepl(pattern, name)) 
[17:37:35.420]                               next
[17:37:35.420]                             invokeRestart(restart)
[17:37:35.420]                             muffled <- TRUE
[17:37:35.420]                             break
[17:37:35.420]                           }
[17:37:35.420]                         }
[17:37:35.420]                       }
[17:37:35.420]                       invisible(muffled)
[17:37:35.420]                     }
[17:37:35.420]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.420]                   }
[17:37:35.420]                 }
[17:37:35.420]             }
[17:37:35.420]         }))
[17:37:35.420]     }, error = function(ex) {
[17:37:35.420]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:35.420]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.420]                 ...future.rng), started = ...future.startTime, 
[17:37:35.420]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:35.420]             version = "1.8"), class = "FutureResult")
[17:37:35.420]     }, finally = {
[17:37:35.420]         if (!identical(...future.workdir, getwd())) 
[17:37:35.420]             setwd(...future.workdir)
[17:37:35.420]         {
[17:37:35.420]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:35.420]                 ...future.oldOptions$nwarnings <- NULL
[17:37:35.420]             }
[17:37:35.420]             base::options(...future.oldOptions)
[17:37:35.420]             if (.Platform$OS.type == "windows") {
[17:37:35.420]                 old_names <- names(...future.oldEnvVars)
[17:37:35.420]                 envs <- base::Sys.getenv()
[17:37:35.420]                 names <- names(envs)
[17:37:35.420]                 common <- intersect(names, old_names)
[17:37:35.420]                 added <- setdiff(names, old_names)
[17:37:35.420]                 removed <- setdiff(old_names, names)
[17:37:35.420]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:35.420]                   envs[common]]
[17:37:35.420]                 NAMES <- toupper(changed)
[17:37:35.420]                 args <- list()
[17:37:35.420]                 for (kk in seq_along(NAMES)) {
[17:37:35.420]                   name <- changed[[kk]]
[17:37:35.420]                   NAME <- NAMES[[kk]]
[17:37:35.420]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.420]                     next
[17:37:35.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.420]                 }
[17:37:35.420]                 NAMES <- toupper(added)
[17:37:35.420]                 for (kk in seq_along(NAMES)) {
[17:37:35.420]                   name <- added[[kk]]
[17:37:35.420]                   NAME <- NAMES[[kk]]
[17:37:35.420]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.420]                     next
[17:37:35.420]                   args[[name]] <- ""
[17:37:35.420]                 }
[17:37:35.420]                 NAMES <- toupper(removed)
[17:37:35.420]                 for (kk in seq_along(NAMES)) {
[17:37:35.420]                   name <- removed[[kk]]
[17:37:35.420]                   NAME <- NAMES[[kk]]
[17:37:35.420]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.420]                     next
[17:37:35.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.420]                 }
[17:37:35.420]                 if (length(args) > 0) 
[17:37:35.420]                   base::do.call(base::Sys.setenv, args = args)
[17:37:35.420]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:35.420]             }
[17:37:35.420]             else {
[17:37:35.420]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:35.420]             }
[17:37:35.420]             {
[17:37:35.420]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:35.420]                   0L) {
[17:37:35.420]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:35.420]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:35.420]                   base::options(opts)
[17:37:35.420]                 }
[17:37:35.420]                 {
[17:37:35.420]                   {
[17:37:35.420]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:35.420]                     NULL
[17:37:35.420]                   }
[17:37:35.420]                   options(future.plan = NULL)
[17:37:35.420]                   if (is.na(NA_character_)) 
[17:37:35.420]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.420]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:35.420]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:35.420]                     .init = FALSE)
[17:37:35.420]                 }
[17:37:35.420]             }
[17:37:35.420]         }
[17:37:35.420]     })
[17:37:35.420]     if (TRUE) {
[17:37:35.420]         base::sink(type = "output", split = FALSE)
[17:37:35.420]         if (TRUE) {
[17:37:35.420]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:35.420]         }
[17:37:35.420]         else {
[17:37:35.420]             ...future.result["stdout"] <- base::list(NULL)
[17:37:35.420]         }
[17:37:35.420]         base::close(...future.stdout)
[17:37:35.420]         ...future.stdout <- NULL
[17:37:35.420]     }
[17:37:35.420]     ...future.result$conditions <- ...future.conditions
[17:37:35.420]     ...future.result$finished <- base::Sys.time()
[17:37:35.420]     ...future.result
[17:37:35.420] }
[17:37:35.422] assign_globals() ...
[17:37:35.422] List of 5
[17:37:35.422]  $ ...future.FUN            :function (C, k)  
[17:37:35.422]  $ MoreArgs                 : NULL
[17:37:35.422]  $ ...future.elements_ii    :List of 2
[17:37:35.422]   ..$ :List of 1
[17:37:35.422]   .. ..$ : chr "A"
[17:37:35.422]   ..$ :List of 1
[17:37:35.422]   .. ..$ : int 5
[17:37:35.422]  $ ...future.seeds_ii       : NULL
[17:37:35.422]  $ ...future.globals.maxSize: NULL
[17:37:35.422]  - attr(*, "where")=List of 5
[17:37:35.422]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:35.422]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:35.422]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:35.422]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:35.422]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:35.422]  - attr(*, "resolved")= logi FALSE
[17:37:35.422]  - attr(*, "total_size")= num 3488
[17:37:35.422]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.422]  - attr(*, "already-done")= logi TRUE
[17:37:35.427] - reassign environment for ‘...future.FUN’
[17:37:35.427] - copied ‘...future.FUN’ to environment
[17:37:35.427] - copied ‘MoreArgs’ to environment
[17:37:35.428] - copied ‘...future.elements_ii’ to environment
[17:37:35.428] - copied ‘...future.seeds_ii’ to environment
[17:37:35.428] - copied ‘...future.globals.maxSize’ to environment
[17:37:35.428] assign_globals() ... done
[17:37:35.428] requestCore(): workers = 2
[17:37:35.430] MulticoreFuture started
[17:37:35.431] - Launch lazy future ... done
[17:37:35.431] run() for ‘MulticoreFuture’ ... done
[17:37:35.431] Created future:
[17:37:35.431] plan(): Setting new future strategy stack:
[17:37:35.432] List of future strategies:
[17:37:35.432] 1. sequential:
[17:37:35.432]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:35.432]    - tweaked: FALSE
[17:37:35.432]    - call: NULL
[17:37:35.432] plan(): nbrOfWorkers() = 1
[17:37:35.435] plan(): Setting new future strategy stack:
[17:37:35.435] List of future strategies:
[17:37:35.435] 1. multicore:
[17:37:35.435]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:35.435]    - tweaked: FALSE
[17:37:35.435]    - call: plan(strategy)
[17:37:35.440] plan(): nbrOfWorkers() = 2
[17:37:35.431] MulticoreFuture:
[17:37:35.431] Label: ‘future_mapply-1’
[17:37:35.431] Expression:
[17:37:35.431] {
[17:37:35.431]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.431]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:35.431]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.431]         on.exit(options(oopts), add = TRUE)
[17:37:35.431]     }
[17:37:35.431]     {
[17:37:35.431]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.431]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:35.431]         do.call(mapply, args = args)
[17:37:35.431]     }
[17:37:35.431] }
[17:37:35.431] Lazy evaluation: FALSE
[17:37:35.431] Asynchronous evaluation: TRUE
[17:37:35.431] Local evaluation: TRUE
[17:37:35.431] Environment: R_GlobalEnv
[17:37:35.431] Capture standard output: TRUE
[17:37:35.431] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:35.431] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:35.431] Packages: <none>
[17:37:35.431] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:35.431] Resolved: TRUE
[17:37:35.431] Value: <not collected>
[17:37:35.431] Conditions captured: <none>
[17:37:35.431] Early signaling: FALSE
[17:37:35.431] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:35.431] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.441] Chunk #1 of 5 ... DONE
[17:37:35.441] Chunk #2 of 5 ...
[17:37:35.441]  - Finding globals in '...' for chunk #2 ...
[17:37:35.441] getGlobalsAndPackages() ...
[17:37:35.442] Searching for globals...
[17:37:35.442] 
[17:37:35.442] Searching for globals ... DONE
[17:37:35.442] - globals: [0] <none>
[17:37:35.443] getGlobalsAndPackages() ... DONE
[17:37:35.443]    + additional globals found: [n=0] 
[17:37:35.443]    + additional namespaces needed: [n=0] 
[17:37:35.443]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:35.443]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:37:35.443]  - seeds: <none>
[17:37:35.443]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.444] getGlobalsAndPackages() ...
[17:37:35.444] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.444] Resolving globals: FALSE
[17:37:35.445] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:37:35.446] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:35.446] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.446] 
[17:37:35.446] getGlobalsAndPackages() ... DONE
[17:37:35.447] run() for ‘Future’ ...
[17:37:35.447] - state: ‘created’
[17:37:35.447] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:35.452] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.452] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:35.452]   - Field: ‘label’
[17:37:35.453]   - Field: ‘local’
[17:37:35.453]   - Field: ‘owner’
[17:37:35.453]   - Field: ‘envir’
[17:37:35.453]   - Field: ‘workers’
[17:37:35.453]   - Field: ‘packages’
[17:37:35.453]   - Field: ‘gc’
[17:37:35.453]   - Field: ‘job’
[17:37:35.454]   - Field: ‘conditions’
[17:37:35.454]   - Field: ‘expr’
[17:37:35.454]   - Field: ‘uuid’
[17:37:35.454]   - Field: ‘seed’
[17:37:35.454]   - Field: ‘version’
[17:37:35.454]   - Field: ‘result’
[17:37:35.454]   - Field: ‘asynchronous’
[17:37:35.455]   - Field: ‘calls’
[17:37:35.455]   - Field: ‘globals’
[17:37:35.455]   - Field: ‘stdout’
[17:37:35.455]   - Field: ‘earlySignal’
[17:37:35.455]   - Field: ‘lazy’
[17:37:35.455]   - Field: ‘state’
[17:37:35.455] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:35.456] - Launch lazy future ...
[17:37:35.456] Packages needed by the future expression (n = 0): <none>
[17:37:35.456] Packages needed by future strategies (n = 0): <none>
[17:37:35.457] {
[17:37:35.457]     {
[17:37:35.457]         {
[17:37:35.457]             ...future.startTime <- base::Sys.time()
[17:37:35.457]             {
[17:37:35.457]                 {
[17:37:35.457]                   {
[17:37:35.457]                     {
[17:37:35.457]                       base::local({
[17:37:35.457]                         has_future <- base::requireNamespace("future", 
[17:37:35.457]                           quietly = TRUE)
[17:37:35.457]                         if (has_future) {
[17:37:35.457]                           ns <- base::getNamespace("future")
[17:37:35.457]                           version <- ns[[".package"]][["version"]]
[17:37:35.457]                           if (is.null(version)) 
[17:37:35.457]                             version <- utils::packageVersion("future")
[17:37:35.457]                         }
[17:37:35.457]                         else {
[17:37:35.457]                           version <- NULL
[17:37:35.457]                         }
[17:37:35.457]                         if (!has_future || version < "1.8.0") {
[17:37:35.457]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:35.457]                             "", base::R.version$version.string), 
[17:37:35.457]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:35.457]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:35.457]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:35.457]                               "release", "version")], collapse = " "), 
[17:37:35.457]                             hostname = base::Sys.info()[["nodename"]])
[17:37:35.457]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:35.457]                             info)
[17:37:35.457]                           info <- base::paste(info, collapse = "; ")
[17:37:35.457]                           if (!has_future) {
[17:37:35.457]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:35.457]                               info)
[17:37:35.457]                           }
[17:37:35.457]                           else {
[17:37:35.457]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:35.457]                               info, version)
[17:37:35.457]                           }
[17:37:35.457]                           base::stop(msg)
[17:37:35.457]                         }
[17:37:35.457]                       })
[17:37:35.457]                     }
[17:37:35.457]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:35.457]                     base::options(mc.cores = 1L)
[17:37:35.457]                   }
[17:37:35.457]                   ...future.strategy.old <- future::plan("list")
[17:37:35.457]                   options(future.plan = NULL)
[17:37:35.457]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.457]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:35.457]                 }
[17:37:35.457]                 ...future.workdir <- getwd()
[17:37:35.457]             }
[17:37:35.457]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:35.457]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:35.457]         }
[17:37:35.457]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:35.457]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:37:35.457]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:35.457]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:35.457]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:35.457]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:35.457]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:35.457]             base::names(...future.oldOptions))
[17:37:35.457]     }
[17:37:35.457]     if (FALSE) {
[17:37:35.457]     }
[17:37:35.457]     else {
[17:37:35.457]         if (TRUE) {
[17:37:35.457]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:35.457]                 open = "w")
[17:37:35.457]         }
[17:37:35.457]         else {
[17:37:35.457]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:35.457]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:35.457]         }
[17:37:35.457]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:35.457]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:35.457]             base::sink(type = "output", split = FALSE)
[17:37:35.457]             base::close(...future.stdout)
[17:37:35.457]         }, add = TRUE)
[17:37:35.457]     }
[17:37:35.457]     ...future.frame <- base::sys.nframe()
[17:37:35.457]     ...future.conditions <- base::list()
[17:37:35.457]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:35.457]     if (FALSE) {
[17:37:35.457]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:35.457]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:35.457]     }
[17:37:35.457]     ...future.result <- base::tryCatch({
[17:37:35.457]         base::withCallingHandlers({
[17:37:35.457]             ...future.value <- base::withVisible(base::local({
[17:37:35.457]                 withCallingHandlers({
[17:37:35.457]                   {
[17:37:35.457]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.457]                     if (!identical(...future.globals.maxSize.org, 
[17:37:35.457]                       ...future.globals.maxSize)) {
[17:37:35.457]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.457]                       on.exit(options(oopts), add = TRUE)
[17:37:35.457]                     }
[17:37:35.457]                     {
[17:37:35.457]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.457]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:35.457]                         USE.NAMES = FALSE)
[17:37:35.457]                       do.call(mapply, args = args)
[17:37:35.457]                     }
[17:37:35.457]                   }
[17:37:35.457]                 }, immediateCondition = function(cond) {
[17:37:35.457]                   save_rds <- function (object, pathname, ...) 
[17:37:35.457]                   {
[17:37:35.457]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:35.457]                     if (file_test("-f", pathname_tmp)) {
[17:37:35.457]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.457]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:35.457]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.457]                         fi_tmp[["mtime"]])
[17:37:35.457]                     }
[17:37:35.457]                     tryCatch({
[17:37:35.457]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:35.457]                     }, error = function(ex) {
[17:37:35.457]                       msg <- conditionMessage(ex)
[17:37:35.457]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.457]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:35.457]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.457]                         fi_tmp[["mtime"]], msg)
[17:37:35.457]                       ex$message <- msg
[17:37:35.457]                       stop(ex)
[17:37:35.457]                     })
[17:37:35.457]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:35.457]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:35.457]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:35.457]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.457]                       fi <- file.info(pathname)
[17:37:35.457]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:35.457]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.457]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:35.457]                         fi[["size"]], fi[["mtime"]])
[17:37:35.457]                       stop(msg)
[17:37:35.457]                     }
[17:37:35.457]                     invisible(pathname)
[17:37:35.457]                   }
[17:37:35.457]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:35.457]                     rootPath = tempdir()) 
[17:37:35.457]                   {
[17:37:35.457]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:35.457]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:35.457]                       tmpdir = path, fileext = ".rds")
[17:37:35.457]                     save_rds(obj, file)
[17:37:35.457]                   }
[17:37:35.457]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:35.457]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.457]                   {
[17:37:35.457]                     inherits <- base::inherits
[17:37:35.457]                     invokeRestart <- base::invokeRestart
[17:37:35.457]                     is.null <- base::is.null
[17:37:35.457]                     muffled <- FALSE
[17:37:35.457]                     if (inherits(cond, "message")) {
[17:37:35.457]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:35.457]                       if (muffled) 
[17:37:35.457]                         invokeRestart("muffleMessage")
[17:37:35.457]                     }
[17:37:35.457]                     else if (inherits(cond, "warning")) {
[17:37:35.457]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:35.457]                       if (muffled) 
[17:37:35.457]                         invokeRestart("muffleWarning")
[17:37:35.457]                     }
[17:37:35.457]                     else if (inherits(cond, "condition")) {
[17:37:35.457]                       if (!is.null(pattern)) {
[17:37:35.457]                         computeRestarts <- base::computeRestarts
[17:37:35.457]                         grepl <- base::grepl
[17:37:35.457]                         restarts <- computeRestarts(cond)
[17:37:35.457]                         for (restart in restarts) {
[17:37:35.457]                           name <- restart$name
[17:37:35.457]                           if (is.null(name)) 
[17:37:35.457]                             next
[17:37:35.457]                           if (!grepl(pattern, name)) 
[17:37:35.457]                             next
[17:37:35.457]                           invokeRestart(restart)
[17:37:35.457]                           muffled <- TRUE
[17:37:35.457]                           break
[17:37:35.457]                         }
[17:37:35.457]                       }
[17:37:35.457]                     }
[17:37:35.457]                     invisible(muffled)
[17:37:35.457]                   }
[17:37:35.457]                   muffleCondition(cond)
[17:37:35.457]                 })
[17:37:35.457]             }))
[17:37:35.457]             future::FutureResult(value = ...future.value$value, 
[17:37:35.457]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.457]                   ...future.rng), globalenv = if (FALSE) 
[17:37:35.457]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:35.457]                     ...future.globalenv.names))
[17:37:35.457]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:35.457]         }, condition = base::local({
[17:37:35.457]             c <- base::c
[17:37:35.457]             inherits <- base::inherits
[17:37:35.457]             invokeRestart <- base::invokeRestart
[17:37:35.457]             length <- base::length
[17:37:35.457]             list <- base::list
[17:37:35.457]             seq.int <- base::seq.int
[17:37:35.457]             signalCondition <- base::signalCondition
[17:37:35.457]             sys.calls <- base::sys.calls
[17:37:35.457]             `[[` <- base::`[[`
[17:37:35.457]             `+` <- base::`+`
[17:37:35.457]             `<<-` <- base::`<<-`
[17:37:35.457]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:35.457]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:35.457]                   3L)]
[17:37:35.457]             }
[17:37:35.457]             function(cond) {
[17:37:35.457]                 is_error <- inherits(cond, "error")
[17:37:35.457]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:35.457]                   NULL)
[17:37:35.457]                 if (is_error) {
[17:37:35.457]                   sessionInformation <- function() {
[17:37:35.457]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:35.457]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:35.457]                       search = base::search(), system = base::Sys.info())
[17:37:35.457]                   }
[17:37:35.457]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.457]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:35.457]                     cond$call), session = sessionInformation(), 
[17:37:35.457]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:35.457]                   signalCondition(cond)
[17:37:35.457]                 }
[17:37:35.457]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:35.457]                 "immediateCondition"))) {
[17:37:35.457]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:35.457]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.457]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:35.457]                   if (TRUE && !signal) {
[17:37:35.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.457]                     {
[17:37:35.457]                       inherits <- base::inherits
[17:37:35.457]                       invokeRestart <- base::invokeRestart
[17:37:35.457]                       is.null <- base::is.null
[17:37:35.457]                       muffled <- FALSE
[17:37:35.457]                       if (inherits(cond, "message")) {
[17:37:35.457]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.457]                         if (muffled) 
[17:37:35.457]                           invokeRestart("muffleMessage")
[17:37:35.457]                       }
[17:37:35.457]                       else if (inherits(cond, "warning")) {
[17:37:35.457]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.457]                         if (muffled) 
[17:37:35.457]                           invokeRestart("muffleWarning")
[17:37:35.457]                       }
[17:37:35.457]                       else if (inherits(cond, "condition")) {
[17:37:35.457]                         if (!is.null(pattern)) {
[17:37:35.457]                           computeRestarts <- base::computeRestarts
[17:37:35.457]                           grepl <- base::grepl
[17:37:35.457]                           restarts <- computeRestarts(cond)
[17:37:35.457]                           for (restart in restarts) {
[17:37:35.457]                             name <- restart$name
[17:37:35.457]                             if (is.null(name)) 
[17:37:35.457]                               next
[17:37:35.457]                             if (!grepl(pattern, name)) 
[17:37:35.457]                               next
[17:37:35.457]                             invokeRestart(restart)
[17:37:35.457]                             muffled <- TRUE
[17:37:35.457]                             break
[17:37:35.457]                           }
[17:37:35.457]                         }
[17:37:35.457]                       }
[17:37:35.457]                       invisible(muffled)
[17:37:35.457]                     }
[17:37:35.457]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.457]                   }
[17:37:35.457]                 }
[17:37:35.457]                 else {
[17:37:35.457]                   if (TRUE) {
[17:37:35.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.457]                     {
[17:37:35.457]                       inherits <- base::inherits
[17:37:35.457]                       invokeRestart <- base::invokeRestart
[17:37:35.457]                       is.null <- base::is.null
[17:37:35.457]                       muffled <- FALSE
[17:37:35.457]                       if (inherits(cond, "message")) {
[17:37:35.457]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.457]                         if (muffled) 
[17:37:35.457]                           invokeRestart("muffleMessage")
[17:37:35.457]                       }
[17:37:35.457]                       else if (inherits(cond, "warning")) {
[17:37:35.457]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.457]                         if (muffled) 
[17:37:35.457]                           invokeRestart("muffleWarning")
[17:37:35.457]                       }
[17:37:35.457]                       else if (inherits(cond, "condition")) {
[17:37:35.457]                         if (!is.null(pattern)) {
[17:37:35.457]                           computeRestarts <- base::computeRestarts
[17:37:35.457]                           grepl <- base::grepl
[17:37:35.457]                           restarts <- computeRestarts(cond)
[17:37:35.457]                           for (restart in restarts) {
[17:37:35.457]                             name <- restart$name
[17:37:35.457]                             if (is.null(name)) 
[17:37:35.457]                               next
[17:37:35.457]                             if (!grepl(pattern, name)) 
[17:37:35.457]                               next
[17:37:35.457]                             invokeRestart(restart)
[17:37:35.457]                             muffled <- TRUE
[17:37:35.457]                             break
[17:37:35.457]                           }
[17:37:35.457]                         }
[17:37:35.457]                       }
[17:37:35.457]                       invisible(muffled)
[17:37:35.457]                     }
[17:37:35.457]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.457]                   }
[17:37:35.457]                 }
[17:37:35.457]             }
[17:37:35.457]         }))
[17:37:35.457]     }, error = function(ex) {
[17:37:35.457]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:35.457]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.457]                 ...future.rng), started = ...future.startTime, 
[17:37:35.457]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:35.457]             version = "1.8"), class = "FutureResult")
[17:37:35.457]     }, finally = {
[17:37:35.457]         if (!identical(...future.workdir, getwd())) 
[17:37:35.457]             setwd(...future.workdir)
[17:37:35.457]         {
[17:37:35.457]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:35.457]                 ...future.oldOptions$nwarnings <- NULL
[17:37:35.457]             }
[17:37:35.457]             base::options(...future.oldOptions)
[17:37:35.457]             if (.Platform$OS.type == "windows") {
[17:37:35.457]                 old_names <- names(...future.oldEnvVars)
[17:37:35.457]                 envs <- base::Sys.getenv()
[17:37:35.457]                 names <- names(envs)
[17:37:35.457]                 common <- intersect(names, old_names)
[17:37:35.457]                 added <- setdiff(names, old_names)
[17:37:35.457]                 removed <- setdiff(old_names, names)
[17:37:35.457]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:35.457]                   envs[common]]
[17:37:35.457]                 NAMES <- toupper(changed)
[17:37:35.457]                 args <- list()
[17:37:35.457]                 for (kk in seq_along(NAMES)) {
[17:37:35.457]                   name <- changed[[kk]]
[17:37:35.457]                   NAME <- NAMES[[kk]]
[17:37:35.457]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.457]                     next
[17:37:35.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.457]                 }
[17:37:35.457]                 NAMES <- toupper(added)
[17:37:35.457]                 for (kk in seq_along(NAMES)) {
[17:37:35.457]                   name <- added[[kk]]
[17:37:35.457]                   NAME <- NAMES[[kk]]
[17:37:35.457]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.457]                     next
[17:37:35.457]                   args[[name]] <- ""
[17:37:35.457]                 }
[17:37:35.457]                 NAMES <- toupper(removed)
[17:37:35.457]                 for (kk in seq_along(NAMES)) {
[17:37:35.457]                   name <- removed[[kk]]
[17:37:35.457]                   NAME <- NAMES[[kk]]
[17:37:35.457]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.457]                     next
[17:37:35.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.457]                 }
[17:37:35.457]                 if (length(args) > 0) 
[17:37:35.457]                   base::do.call(base::Sys.setenv, args = args)
[17:37:35.457]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:35.457]             }
[17:37:35.457]             else {
[17:37:35.457]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:35.457]             }
[17:37:35.457]             {
[17:37:35.457]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:35.457]                   0L) {
[17:37:35.457]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:35.457]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:35.457]                   base::options(opts)
[17:37:35.457]                 }
[17:37:35.457]                 {
[17:37:35.457]                   {
[17:37:35.457]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:35.457]                     NULL
[17:37:35.457]                   }
[17:37:35.457]                   options(future.plan = NULL)
[17:37:35.457]                   if (is.na(NA_character_)) 
[17:37:35.457]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.457]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:35.457]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:35.457]                     .init = FALSE)
[17:37:35.457]                 }
[17:37:35.457]             }
[17:37:35.457]         }
[17:37:35.457]     })
[17:37:35.457]     if (TRUE) {
[17:37:35.457]         base::sink(type = "output", split = FALSE)
[17:37:35.457]         if (TRUE) {
[17:37:35.457]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:35.457]         }
[17:37:35.457]         else {
[17:37:35.457]             ...future.result["stdout"] <- base::list(NULL)
[17:37:35.457]         }
[17:37:35.457]         base::close(...future.stdout)
[17:37:35.457]         ...future.stdout <- NULL
[17:37:35.457]     }
[17:37:35.457]     ...future.result$conditions <- ...future.conditions
[17:37:35.457]     ...future.result$finished <- base::Sys.time()
[17:37:35.457]     ...future.result
[17:37:35.457] }
[17:37:35.464] assign_globals() ...
[17:37:35.464] List of 5
[17:37:35.464]  $ ...future.FUN            :function (C, k)  
[17:37:35.464]  $ MoreArgs                 : NULL
[17:37:35.464]  $ ...future.elements_ii    :List of 2
[17:37:35.464]   ..$ :List of 1
[17:37:35.464]   .. ..$ : chr "B"
[17:37:35.464]   ..$ :List of 1
[17:37:35.464]   .. ..$ : int 4
[17:37:35.464]  $ ...future.seeds_ii       : NULL
[17:37:35.464]  $ ...future.globals.maxSize: NULL
[17:37:35.464]  - attr(*, "where")=List of 5
[17:37:35.464]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:35.464]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:35.464]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:35.464]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:35.464]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:35.464]  - attr(*, "resolved")= logi FALSE
[17:37:35.464]  - attr(*, "total_size")= num 3488
[17:37:35.464]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.464]  - attr(*, "already-done")= logi TRUE
[17:37:35.474] - reassign environment for ‘...future.FUN’
[17:37:35.474] - copied ‘...future.FUN’ to environment
[17:37:35.474] - copied ‘MoreArgs’ to environment
[17:37:35.474] - copied ‘...future.elements_ii’ to environment
[17:37:35.475] - copied ‘...future.seeds_ii’ to environment
[17:37:35.475] - copied ‘...future.globals.maxSize’ to environment
[17:37:35.475] assign_globals() ... done
[17:37:35.475] requestCore(): workers = 2
[17:37:35.477] MulticoreFuture started
[17:37:35.478] - Launch lazy future ... done
[17:37:35.478] run() for ‘MulticoreFuture’ ... done
[17:37:35.478] Created future:
[17:37:35.478] plan(): Setting new future strategy stack:
[17:37:35.479] List of future strategies:
[17:37:35.479] 1. sequential:
[17:37:35.479]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:35.479]    - tweaked: FALSE
[17:37:35.479]    - call: NULL
[17:37:35.480] plan(): nbrOfWorkers() = 1
[17:37:35.482] plan(): Setting new future strategy stack:
[17:37:35.482] List of future strategies:
[17:37:35.482] 1. multicore:
[17:37:35.482]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:35.482]    - tweaked: FALSE
[17:37:35.482]    - call: plan(strategy)
[17:37:35.488] plan(): nbrOfWorkers() = 2
[17:37:35.478] MulticoreFuture:
[17:37:35.478] Label: ‘future_mapply-2’
[17:37:35.478] Expression:
[17:37:35.478] {
[17:37:35.478]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.478]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:35.478]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.478]         on.exit(options(oopts), add = TRUE)
[17:37:35.478]     }
[17:37:35.478]     {
[17:37:35.478]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.478]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:35.478]         do.call(mapply, args = args)
[17:37:35.478]     }
[17:37:35.478] }
[17:37:35.478] Lazy evaluation: FALSE
[17:37:35.478] Asynchronous evaluation: TRUE
[17:37:35.478] Local evaluation: TRUE
[17:37:35.478] Environment: R_GlobalEnv
[17:37:35.478] Capture standard output: TRUE
[17:37:35.478] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:35.478] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:35.478] Packages: <none>
[17:37:35.478] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:35.478] Resolved: TRUE
[17:37:35.478] Value: <not collected>
[17:37:35.478] Conditions captured: <none>
[17:37:35.478] Early signaling: FALSE
[17:37:35.478] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:35.478] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.489] Chunk #2 of 5 ... DONE
[17:37:35.489] Chunk #3 of 5 ...
[17:37:35.489]  - Finding globals in '...' for chunk #3 ...
[17:37:35.489] getGlobalsAndPackages() ...
[17:37:35.490] Searching for globals...
[17:37:35.490] 
[17:37:35.490] Searching for globals ... DONE
[17:37:35.491] - globals: [0] <none>
[17:37:35.491] getGlobalsAndPackages() ... DONE
[17:37:35.491]    + additional globals found: [n=0] 
[17:37:35.491]    + additional namespaces needed: [n=0] 
[17:37:35.491]  - Finding globals in '...' for chunk #3 ... DONE
[17:37:35.491]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:37:35.491]  - seeds: <none>
[17:37:35.491]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.492] getGlobalsAndPackages() ...
[17:37:35.492] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.492] Resolving globals: FALSE
[17:37:35.493] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:37:35.494] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:35.494] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.494] 
[17:37:35.494] getGlobalsAndPackages() ... DONE
[17:37:35.495] run() for ‘Future’ ...
[17:37:35.495] - state: ‘created’
[17:37:35.495] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:35.500] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.500] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:35.500]   - Field: ‘label’
[17:37:35.500]   - Field: ‘local’
[17:37:35.500]   - Field: ‘owner’
[17:37:35.500]   - Field: ‘envir’
[17:37:35.501]   - Field: ‘workers’
[17:37:35.501]   - Field: ‘packages’
[17:37:35.501]   - Field: ‘gc’
[17:37:35.501]   - Field: ‘job’
[17:37:35.501]   - Field: ‘conditions’
[17:37:35.501]   - Field: ‘expr’
[17:37:35.501]   - Field: ‘uuid’
[17:37:35.502]   - Field: ‘seed’
[17:37:35.502]   - Field: ‘version’
[17:37:35.502]   - Field: ‘result’
[17:37:35.502]   - Field: ‘asynchronous’
[17:37:35.502]   - Field: ‘calls’
[17:37:35.502]   - Field: ‘globals’
[17:37:35.502]   - Field: ‘stdout’
[17:37:35.503]   - Field: ‘earlySignal’
[17:37:35.503]   - Field: ‘lazy’
[17:37:35.503]   - Field: ‘state’
[17:37:35.503] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:35.503] - Launch lazy future ...
[17:37:35.504] Packages needed by the future expression (n = 0): <none>
[17:37:35.504] Packages needed by future strategies (n = 0): <none>
[17:37:35.505] {
[17:37:35.505]     {
[17:37:35.505]         {
[17:37:35.505]             ...future.startTime <- base::Sys.time()
[17:37:35.505]             {
[17:37:35.505]                 {
[17:37:35.505]                   {
[17:37:35.505]                     {
[17:37:35.505]                       base::local({
[17:37:35.505]                         has_future <- base::requireNamespace("future", 
[17:37:35.505]                           quietly = TRUE)
[17:37:35.505]                         if (has_future) {
[17:37:35.505]                           ns <- base::getNamespace("future")
[17:37:35.505]                           version <- ns[[".package"]][["version"]]
[17:37:35.505]                           if (is.null(version)) 
[17:37:35.505]                             version <- utils::packageVersion("future")
[17:37:35.505]                         }
[17:37:35.505]                         else {
[17:37:35.505]                           version <- NULL
[17:37:35.505]                         }
[17:37:35.505]                         if (!has_future || version < "1.8.0") {
[17:37:35.505]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:35.505]                             "", base::R.version$version.string), 
[17:37:35.505]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:35.505]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:35.505]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:35.505]                               "release", "version")], collapse = " "), 
[17:37:35.505]                             hostname = base::Sys.info()[["nodename"]])
[17:37:35.505]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:35.505]                             info)
[17:37:35.505]                           info <- base::paste(info, collapse = "; ")
[17:37:35.505]                           if (!has_future) {
[17:37:35.505]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:35.505]                               info)
[17:37:35.505]                           }
[17:37:35.505]                           else {
[17:37:35.505]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:35.505]                               info, version)
[17:37:35.505]                           }
[17:37:35.505]                           base::stop(msg)
[17:37:35.505]                         }
[17:37:35.505]                       })
[17:37:35.505]                     }
[17:37:35.505]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:35.505]                     base::options(mc.cores = 1L)
[17:37:35.505]                   }
[17:37:35.505]                   ...future.strategy.old <- future::plan("list")
[17:37:35.505]                   options(future.plan = NULL)
[17:37:35.505]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.505]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:35.505]                 }
[17:37:35.505]                 ...future.workdir <- getwd()
[17:37:35.505]             }
[17:37:35.505]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:35.505]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:35.505]         }
[17:37:35.505]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:35.505]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:37:35.505]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:35.505]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:35.505]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:35.505]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:35.505]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:35.505]             base::names(...future.oldOptions))
[17:37:35.505]     }
[17:37:35.505]     if (FALSE) {
[17:37:35.505]     }
[17:37:35.505]     else {
[17:37:35.505]         if (TRUE) {
[17:37:35.505]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:35.505]                 open = "w")
[17:37:35.505]         }
[17:37:35.505]         else {
[17:37:35.505]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:35.505]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:35.505]         }
[17:37:35.505]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:35.505]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:35.505]             base::sink(type = "output", split = FALSE)
[17:37:35.505]             base::close(...future.stdout)
[17:37:35.505]         }, add = TRUE)
[17:37:35.505]     }
[17:37:35.505]     ...future.frame <- base::sys.nframe()
[17:37:35.505]     ...future.conditions <- base::list()
[17:37:35.505]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:35.505]     if (FALSE) {
[17:37:35.505]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:35.505]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:35.505]     }
[17:37:35.505]     ...future.result <- base::tryCatch({
[17:37:35.505]         base::withCallingHandlers({
[17:37:35.505]             ...future.value <- base::withVisible(base::local({
[17:37:35.505]                 withCallingHandlers({
[17:37:35.505]                   {
[17:37:35.505]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.505]                     if (!identical(...future.globals.maxSize.org, 
[17:37:35.505]                       ...future.globals.maxSize)) {
[17:37:35.505]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.505]                       on.exit(options(oopts), add = TRUE)
[17:37:35.505]                     }
[17:37:35.505]                     {
[17:37:35.505]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.505]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:35.505]                         USE.NAMES = FALSE)
[17:37:35.505]                       do.call(mapply, args = args)
[17:37:35.505]                     }
[17:37:35.505]                   }
[17:37:35.505]                 }, immediateCondition = function(cond) {
[17:37:35.505]                   save_rds <- function (object, pathname, ...) 
[17:37:35.505]                   {
[17:37:35.505]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:35.505]                     if (file_test("-f", pathname_tmp)) {
[17:37:35.505]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.505]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:35.505]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.505]                         fi_tmp[["mtime"]])
[17:37:35.505]                     }
[17:37:35.505]                     tryCatch({
[17:37:35.505]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:35.505]                     }, error = function(ex) {
[17:37:35.505]                       msg <- conditionMessage(ex)
[17:37:35.505]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.505]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:35.505]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.505]                         fi_tmp[["mtime"]], msg)
[17:37:35.505]                       ex$message <- msg
[17:37:35.505]                       stop(ex)
[17:37:35.505]                     })
[17:37:35.505]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:35.505]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:35.505]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:35.505]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.505]                       fi <- file.info(pathname)
[17:37:35.505]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:35.505]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.505]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:35.505]                         fi[["size"]], fi[["mtime"]])
[17:37:35.505]                       stop(msg)
[17:37:35.505]                     }
[17:37:35.505]                     invisible(pathname)
[17:37:35.505]                   }
[17:37:35.505]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:35.505]                     rootPath = tempdir()) 
[17:37:35.505]                   {
[17:37:35.505]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:35.505]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:35.505]                       tmpdir = path, fileext = ".rds")
[17:37:35.505]                     save_rds(obj, file)
[17:37:35.505]                   }
[17:37:35.505]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:35.505]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.505]                   {
[17:37:35.505]                     inherits <- base::inherits
[17:37:35.505]                     invokeRestart <- base::invokeRestart
[17:37:35.505]                     is.null <- base::is.null
[17:37:35.505]                     muffled <- FALSE
[17:37:35.505]                     if (inherits(cond, "message")) {
[17:37:35.505]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:35.505]                       if (muffled) 
[17:37:35.505]                         invokeRestart("muffleMessage")
[17:37:35.505]                     }
[17:37:35.505]                     else if (inherits(cond, "warning")) {
[17:37:35.505]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:35.505]                       if (muffled) 
[17:37:35.505]                         invokeRestart("muffleWarning")
[17:37:35.505]                     }
[17:37:35.505]                     else if (inherits(cond, "condition")) {
[17:37:35.505]                       if (!is.null(pattern)) {
[17:37:35.505]                         computeRestarts <- base::computeRestarts
[17:37:35.505]                         grepl <- base::grepl
[17:37:35.505]                         restarts <- computeRestarts(cond)
[17:37:35.505]                         for (restart in restarts) {
[17:37:35.505]                           name <- restart$name
[17:37:35.505]                           if (is.null(name)) 
[17:37:35.505]                             next
[17:37:35.505]                           if (!grepl(pattern, name)) 
[17:37:35.505]                             next
[17:37:35.505]                           invokeRestart(restart)
[17:37:35.505]                           muffled <- TRUE
[17:37:35.505]                           break
[17:37:35.505]                         }
[17:37:35.505]                       }
[17:37:35.505]                     }
[17:37:35.505]                     invisible(muffled)
[17:37:35.505]                   }
[17:37:35.505]                   muffleCondition(cond)
[17:37:35.505]                 })
[17:37:35.505]             }))
[17:37:35.505]             future::FutureResult(value = ...future.value$value, 
[17:37:35.505]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.505]                   ...future.rng), globalenv = if (FALSE) 
[17:37:35.505]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:35.505]                     ...future.globalenv.names))
[17:37:35.505]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:35.505]         }, condition = base::local({
[17:37:35.505]             c <- base::c
[17:37:35.505]             inherits <- base::inherits
[17:37:35.505]             invokeRestart <- base::invokeRestart
[17:37:35.505]             length <- base::length
[17:37:35.505]             list <- base::list
[17:37:35.505]             seq.int <- base::seq.int
[17:37:35.505]             signalCondition <- base::signalCondition
[17:37:35.505]             sys.calls <- base::sys.calls
[17:37:35.505]             `[[` <- base::`[[`
[17:37:35.505]             `+` <- base::`+`
[17:37:35.505]             `<<-` <- base::`<<-`
[17:37:35.505]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:35.505]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:35.505]                   3L)]
[17:37:35.505]             }
[17:37:35.505]             function(cond) {
[17:37:35.505]                 is_error <- inherits(cond, "error")
[17:37:35.505]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:35.505]                   NULL)
[17:37:35.505]                 if (is_error) {
[17:37:35.505]                   sessionInformation <- function() {
[17:37:35.505]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:35.505]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:35.505]                       search = base::search(), system = base::Sys.info())
[17:37:35.505]                   }
[17:37:35.505]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.505]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:35.505]                     cond$call), session = sessionInformation(), 
[17:37:35.505]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:35.505]                   signalCondition(cond)
[17:37:35.505]                 }
[17:37:35.505]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:35.505]                 "immediateCondition"))) {
[17:37:35.505]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:35.505]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.505]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:35.505]                   if (TRUE && !signal) {
[17:37:35.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.505]                     {
[17:37:35.505]                       inherits <- base::inherits
[17:37:35.505]                       invokeRestart <- base::invokeRestart
[17:37:35.505]                       is.null <- base::is.null
[17:37:35.505]                       muffled <- FALSE
[17:37:35.505]                       if (inherits(cond, "message")) {
[17:37:35.505]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.505]                         if (muffled) 
[17:37:35.505]                           invokeRestart("muffleMessage")
[17:37:35.505]                       }
[17:37:35.505]                       else if (inherits(cond, "warning")) {
[17:37:35.505]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.505]                         if (muffled) 
[17:37:35.505]                           invokeRestart("muffleWarning")
[17:37:35.505]                       }
[17:37:35.505]                       else if (inherits(cond, "condition")) {
[17:37:35.505]                         if (!is.null(pattern)) {
[17:37:35.505]                           computeRestarts <- base::computeRestarts
[17:37:35.505]                           grepl <- base::grepl
[17:37:35.505]                           restarts <- computeRestarts(cond)
[17:37:35.505]                           for (restart in restarts) {
[17:37:35.505]                             name <- restart$name
[17:37:35.505]                             if (is.null(name)) 
[17:37:35.505]                               next
[17:37:35.505]                             if (!grepl(pattern, name)) 
[17:37:35.505]                               next
[17:37:35.505]                             invokeRestart(restart)
[17:37:35.505]                             muffled <- TRUE
[17:37:35.505]                             break
[17:37:35.505]                           }
[17:37:35.505]                         }
[17:37:35.505]                       }
[17:37:35.505]                       invisible(muffled)
[17:37:35.505]                     }
[17:37:35.505]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.505]                   }
[17:37:35.505]                 }
[17:37:35.505]                 else {
[17:37:35.505]                   if (TRUE) {
[17:37:35.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.505]                     {
[17:37:35.505]                       inherits <- base::inherits
[17:37:35.505]                       invokeRestart <- base::invokeRestart
[17:37:35.505]                       is.null <- base::is.null
[17:37:35.505]                       muffled <- FALSE
[17:37:35.505]                       if (inherits(cond, "message")) {
[17:37:35.505]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.505]                         if (muffled) 
[17:37:35.505]                           invokeRestart("muffleMessage")
[17:37:35.505]                       }
[17:37:35.505]                       else if (inherits(cond, "warning")) {
[17:37:35.505]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.505]                         if (muffled) 
[17:37:35.505]                           invokeRestart("muffleWarning")
[17:37:35.505]                       }
[17:37:35.505]                       else if (inherits(cond, "condition")) {
[17:37:35.505]                         if (!is.null(pattern)) {
[17:37:35.505]                           computeRestarts <- base::computeRestarts
[17:37:35.505]                           grepl <- base::grepl
[17:37:35.505]                           restarts <- computeRestarts(cond)
[17:37:35.505]                           for (restart in restarts) {
[17:37:35.505]                             name <- restart$name
[17:37:35.505]                             if (is.null(name)) 
[17:37:35.505]                               next
[17:37:35.505]                             if (!grepl(pattern, name)) 
[17:37:35.505]                               next
[17:37:35.505]                             invokeRestart(restart)
[17:37:35.505]                             muffled <- TRUE
[17:37:35.505]                             break
[17:37:35.505]                           }
[17:37:35.505]                         }
[17:37:35.505]                       }
[17:37:35.505]                       invisible(muffled)
[17:37:35.505]                     }
[17:37:35.505]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.505]                   }
[17:37:35.505]                 }
[17:37:35.505]             }
[17:37:35.505]         }))
[17:37:35.505]     }, error = function(ex) {
[17:37:35.505]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:35.505]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.505]                 ...future.rng), started = ...future.startTime, 
[17:37:35.505]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:35.505]             version = "1.8"), class = "FutureResult")
[17:37:35.505]     }, finally = {
[17:37:35.505]         if (!identical(...future.workdir, getwd())) 
[17:37:35.505]             setwd(...future.workdir)
[17:37:35.505]         {
[17:37:35.505]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:35.505]                 ...future.oldOptions$nwarnings <- NULL
[17:37:35.505]             }
[17:37:35.505]             base::options(...future.oldOptions)
[17:37:35.505]             if (.Platform$OS.type == "windows") {
[17:37:35.505]                 old_names <- names(...future.oldEnvVars)
[17:37:35.505]                 envs <- base::Sys.getenv()
[17:37:35.505]                 names <- names(envs)
[17:37:35.505]                 common <- intersect(names, old_names)
[17:37:35.505]                 added <- setdiff(names, old_names)
[17:37:35.505]                 removed <- setdiff(old_names, names)
[17:37:35.505]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:35.505]                   envs[common]]
[17:37:35.505]                 NAMES <- toupper(changed)
[17:37:35.505]                 args <- list()
[17:37:35.505]                 for (kk in seq_along(NAMES)) {
[17:37:35.505]                   name <- changed[[kk]]
[17:37:35.505]                   NAME <- NAMES[[kk]]
[17:37:35.505]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.505]                     next
[17:37:35.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.505]                 }
[17:37:35.505]                 NAMES <- toupper(added)
[17:37:35.505]                 for (kk in seq_along(NAMES)) {
[17:37:35.505]                   name <- added[[kk]]
[17:37:35.505]                   NAME <- NAMES[[kk]]
[17:37:35.505]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.505]                     next
[17:37:35.505]                   args[[name]] <- ""
[17:37:35.505]                 }
[17:37:35.505]                 NAMES <- toupper(removed)
[17:37:35.505]                 for (kk in seq_along(NAMES)) {
[17:37:35.505]                   name <- removed[[kk]]
[17:37:35.505]                   NAME <- NAMES[[kk]]
[17:37:35.505]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.505]                     next
[17:37:35.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.505]                 }
[17:37:35.505]                 if (length(args) > 0) 
[17:37:35.505]                   base::do.call(base::Sys.setenv, args = args)
[17:37:35.505]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:35.505]             }
[17:37:35.505]             else {
[17:37:35.505]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:35.505]             }
[17:37:35.505]             {
[17:37:35.505]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:35.505]                   0L) {
[17:37:35.505]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:35.505]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:35.505]                   base::options(opts)
[17:37:35.505]                 }
[17:37:35.505]                 {
[17:37:35.505]                   {
[17:37:35.505]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:35.505]                     NULL
[17:37:35.505]                   }
[17:37:35.505]                   options(future.plan = NULL)
[17:37:35.505]                   if (is.na(NA_character_)) 
[17:37:35.505]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.505]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:35.505]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:35.505]                     .init = FALSE)
[17:37:35.505]                 }
[17:37:35.505]             }
[17:37:35.505]         }
[17:37:35.505]     })
[17:37:35.505]     if (TRUE) {
[17:37:35.505]         base::sink(type = "output", split = FALSE)
[17:37:35.505]         if (TRUE) {
[17:37:35.505]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:35.505]         }
[17:37:35.505]         else {
[17:37:35.505]             ...future.result["stdout"] <- base::list(NULL)
[17:37:35.505]         }
[17:37:35.505]         base::close(...future.stdout)
[17:37:35.505]         ...future.stdout <- NULL
[17:37:35.505]     }
[17:37:35.505]     ...future.result$conditions <- ...future.conditions
[17:37:35.505]     ...future.result$finished <- base::Sys.time()
[17:37:35.505]     ...future.result
[17:37:35.505] }
[17:37:35.508] assign_globals() ...
[17:37:35.508] List of 5
[17:37:35.508]  $ ...future.FUN            :function (C, k)  
[17:37:35.508]  $ MoreArgs                 : NULL
[17:37:35.508]  $ ...future.elements_ii    :List of 2
[17:37:35.508]   ..$ :List of 1
[17:37:35.508]   .. ..$ : chr "C"
[17:37:35.508]   ..$ :List of 1
[17:37:35.508]   .. ..$ : int 3
[17:37:35.508]  $ ...future.seeds_ii       : NULL
[17:37:35.508]  $ ...future.globals.maxSize: NULL
[17:37:35.508]  - attr(*, "where")=List of 5
[17:37:35.508]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:35.508]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:35.508]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:35.508]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:35.508]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:35.508]  - attr(*, "resolved")= logi FALSE
[17:37:35.508]  - attr(*, "total_size")= num 3488
[17:37:35.508]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.508]  - attr(*, "already-done")= logi TRUE
[17:37:35.520] - reassign environment for ‘...future.FUN’
[17:37:35.520] - copied ‘...future.FUN’ to environment
[17:37:35.520] - copied ‘MoreArgs’ to environment
[17:37:35.521] - copied ‘...future.elements_ii’ to environment
[17:37:35.521] - copied ‘...future.seeds_ii’ to environment
[17:37:35.521] - copied ‘...future.globals.maxSize’ to environment
[17:37:35.521] assign_globals() ... done
[17:37:35.521] requestCore(): workers = 2
[17:37:35.522] Poll #1 (0): usedCores() = 2, workers = 2
[17:37:35.532] result() for MulticoreFuture ...
[17:37:35.533] result() for MulticoreFuture ...
[17:37:35.533] result() for MulticoreFuture ... done
[17:37:35.534] result() for MulticoreFuture ... done
[17:37:35.534] result() for MulticoreFuture ...
[17:37:35.534] result() for MulticoreFuture ... done
[17:37:35.537] MulticoreFuture started
[17:37:35.538] - Launch lazy future ... done
[17:37:35.538] run() for ‘MulticoreFuture’ ... done
[17:37:35.538] plan(): Setting new future strategy stack:
[17:37:35.538] Created future:
[17:37:35.539] List of future strategies:
[17:37:35.539] 1. sequential:
[17:37:35.539]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:35.539]    - tweaked: FALSE
[17:37:35.539]    - call: NULL
[17:37:35.540] plan(): nbrOfWorkers() = 1
[17:37:35.543] plan(): Setting new future strategy stack:
[17:37:35.543] List of future strategies:
[17:37:35.543] 1. multicore:
[17:37:35.543]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:35.543]    - tweaked: FALSE
[17:37:35.543]    - call: plan(strategy)
[17:37:35.549] plan(): nbrOfWorkers() = 2
[17:37:35.539] MulticoreFuture:
[17:37:35.539] Label: ‘future_mapply-3’
[17:37:35.539] Expression:
[17:37:35.539] {
[17:37:35.539]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.539]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:35.539]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.539]         on.exit(options(oopts), add = TRUE)
[17:37:35.539]     }
[17:37:35.539]     {
[17:37:35.539]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.539]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:35.539]         do.call(mapply, args = args)
[17:37:35.539]     }
[17:37:35.539] }
[17:37:35.539] Lazy evaluation: FALSE
[17:37:35.539] Asynchronous evaluation: TRUE
[17:37:35.539] Local evaluation: TRUE
[17:37:35.539] Environment: R_GlobalEnv
[17:37:35.539] Capture standard output: TRUE
[17:37:35.539] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:35.539] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:35.539] Packages: <none>
[17:37:35.539] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:35.539] Resolved: TRUE
[17:37:35.539] Value: <not collected>
[17:37:35.539] Conditions captured: <none>
[17:37:35.539] Early signaling: FALSE
[17:37:35.539] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:35.539] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.550] Chunk #3 of 5 ... DONE
[17:37:35.550] Chunk #4 of 5 ...
[17:37:35.550]  - Finding globals in '...' for chunk #4 ...
[17:37:35.550] getGlobalsAndPackages() ...
[17:37:35.551] Searching for globals...
[17:37:35.551] 
[17:37:35.552] Searching for globals ... DONE
[17:37:35.552] - globals: [0] <none>
[17:37:35.552] getGlobalsAndPackages() ... DONE
[17:37:35.552]    + additional globals found: [n=0] 
[17:37:35.552]    + additional namespaces needed: [n=0] 
[17:37:35.552]  - Finding globals in '...' for chunk #4 ... DONE
[17:37:35.552]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:37:35.553]  - seeds: <none>
[17:37:35.553]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.553] getGlobalsAndPackages() ...
[17:37:35.553] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.553] Resolving globals: FALSE
[17:37:35.554] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:37:35.555] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:35.555] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.555] 
[17:37:35.556] getGlobalsAndPackages() ... DONE
[17:37:35.556] run() for ‘Future’ ...
[17:37:35.556] - state: ‘created’
[17:37:35.557] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:35.561] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.561] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:35.562]   - Field: ‘label’
[17:37:35.562]   - Field: ‘local’
[17:37:35.562]   - Field: ‘owner’
[17:37:35.562]   - Field: ‘envir’
[17:37:35.562]   - Field: ‘workers’
[17:37:35.562]   - Field: ‘packages’
[17:37:35.562]   - Field: ‘gc’
[17:37:35.563]   - Field: ‘job’
[17:37:35.563]   - Field: ‘conditions’
[17:37:35.563]   - Field: ‘expr’
[17:37:35.563]   - Field: ‘uuid’
[17:37:35.563]   - Field: ‘seed’
[17:37:35.563]   - Field: ‘version’
[17:37:35.563]   - Field: ‘result’
[17:37:35.564]   - Field: ‘asynchronous’
[17:37:35.564]   - Field: ‘calls’
[17:37:35.564]   - Field: ‘globals’
[17:37:35.564]   - Field: ‘stdout’
[17:37:35.564]   - Field: ‘earlySignal’
[17:37:35.564]   - Field: ‘lazy’
[17:37:35.564]   - Field: ‘state’
[17:37:35.565] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:35.565] - Launch lazy future ...
[17:37:35.565] Packages needed by the future expression (n = 0): <none>
[17:37:35.565] Packages needed by future strategies (n = 0): <none>
[17:37:35.566] {
[17:37:35.566]     {
[17:37:35.566]         {
[17:37:35.566]             ...future.startTime <- base::Sys.time()
[17:37:35.566]             {
[17:37:35.566]                 {
[17:37:35.566]                   {
[17:37:35.566]                     {
[17:37:35.566]                       base::local({
[17:37:35.566]                         has_future <- base::requireNamespace("future", 
[17:37:35.566]                           quietly = TRUE)
[17:37:35.566]                         if (has_future) {
[17:37:35.566]                           ns <- base::getNamespace("future")
[17:37:35.566]                           version <- ns[[".package"]][["version"]]
[17:37:35.566]                           if (is.null(version)) 
[17:37:35.566]                             version <- utils::packageVersion("future")
[17:37:35.566]                         }
[17:37:35.566]                         else {
[17:37:35.566]                           version <- NULL
[17:37:35.566]                         }
[17:37:35.566]                         if (!has_future || version < "1.8.0") {
[17:37:35.566]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:35.566]                             "", base::R.version$version.string), 
[17:37:35.566]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:35.566]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:35.566]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:35.566]                               "release", "version")], collapse = " "), 
[17:37:35.566]                             hostname = base::Sys.info()[["nodename"]])
[17:37:35.566]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:35.566]                             info)
[17:37:35.566]                           info <- base::paste(info, collapse = "; ")
[17:37:35.566]                           if (!has_future) {
[17:37:35.566]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:35.566]                               info)
[17:37:35.566]                           }
[17:37:35.566]                           else {
[17:37:35.566]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:35.566]                               info, version)
[17:37:35.566]                           }
[17:37:35.566]                           base::stop(msg)
[17:37:35.566]                         }
[17:37:35.566]                       })
[17:37:35.566]                     }
[17:37:35.566]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:35.566]                     base::options(mc.cores = 1L)
[17:37:35.566]                   }
[17:37:35.566]                   ...future.strategy.old <- future::plan("list")
[17:37:35.566]                   options(future.plan = NULL)
[17:37:35.566]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.566]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:35.566]                 }
[17:37:35.566]                 ...future.workdir <- getwd()
[17:37:35.566]             }
[17:37:35.566]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:35.566]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:35.566]         }
[17:37:35.566]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:35.566]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:37:35.566]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:35.566]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:35.566]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:35.566]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:35.566]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:35.566]             base::names(...future.oldOptions))
[17:37:35.566]     }
[17:37:35.566]     if (FALSE) {
[17:37:35.566]     }
[17:37:35.566]     else {
[17:37:35.566]         if (TRUE) {
[17:37:35.566]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:35.566]                 open = "w")
[17:37:35.566]         }
[17:37:35.566]         else {
[17:37:35.566]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:35.566]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:35.566]         }
[17:37:35.566]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:35.566]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:35.566]             base::sink(type = "output", split = FALSE)
[17:37:35.566]             base::close(...future.stdout)
[17:37:35.566]         }, add = TRUE)
[17:37:35.566]     }
[17:37:35.566]     ...future.frame <- base::sys.nframe()
[17:37:35.566]     ...future.conditions <- base::list()
[17:37:35.566]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:35.566]     if (FALSE) {
[17:37:35.566]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:35.566]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:35.566]     }
[17:37:35.566]     ...future.result <- base::tryCatch({
[17:37:35.566]         base::withCallingHandlers({
[17:37:35.566]             ...future.value <- base::withVisible(base::local({
[17:37:35.566]                 withCallingHandlers({
[17:37:35.566]                   {
[17:37:35.566]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.566]                     if (!identical(...future.globals.maxSize.org, 
[17:37:35.566]                       ...future.globals.maxSize)) {
[17:37:35.566]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.566]                       on.exit(options(oopts), add = TRUE)
[17:37:35.566]                     }
[17:37:35.566]                     {
[17:37:35.566]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.566]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:35.566]                         USE.NAMES = FALSE)
[17:37:35.566]                       do.call(mapply, args = args)
[17:37:35.566]                     }
[17:37:35.566]                   }
[17:37:35.566]                 }, immediateCondition = function(cond) {
[17:37:35.566]                   save_rds <- function (object, pathname, ...) 
[17:37:35.566]                   {
[17:37:35.566]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:35.566]                     if (file_test("-f", pathname_tmp)) {
[17:37:35.566]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.566]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:35.566]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.566]                         fi_tmp[["mtime"]])
[17:37:35.566]                     }
[17:37:35.566]                     tryCatch({
[17:37:35.566]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:35.566]                     }, error = function(ex) {
[17:37:35.566]                       msg <- conditionMessage(ex)
[17:37:35.566]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.566]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:35.566]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.566]                         fi_tmp[["mtime"]], msg)
[17:37:35.566]                       ex$message <- msg
[17:37:35.566]                       stop(ex)
[17:37:35.566]                     })
[17:37:35.566]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:35.566]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:35.566]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:35.566]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.566]                       fi <- file.info(pathname)
[17:37:35.566]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:35.566]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.566]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:35.566]                         fi[["size"]], fi[["mtime"]])
[17:37:35.566]                       stop(msg)
[17:37:35.566]                     }
[17:37:35.566]                     invisible(pathname)
[17:37:35.566]                   }
[17:37:35.566]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:35.566]                     rootPath = tempdir()) 
[17:37:35.566]                   {
[17:37:35.566]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:35.566]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:35.566]                       tmpdir = path, fileext = ".rds")
[17:37:35.566]                     save_rds(obj, file)
[17:37:35.566]                   }
[17:37:35.566]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:35.566]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.566]                   {
[17:37:35.566]                     inherits <- base::inherits
[17:37:35.566]                     invokeRestart <- base::invokeRestart
[17:37:35.566]                     is.null <- base::is.null
[17:37:35.566]                     muffled <- FALSE
[17:37:35.566]                     if (inherits(cond, "message")) {
[17:37:35.566]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:35.566]                       if (muffled) 
[17:37:35.566]                         invokeRestart("muffleMessage")
[17:37:35.566]                     }
[17:37:35.566]                     else if (inherits(cond, "warning")) {
[17:37:35.566]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:35.566]                       if (muffled) 
[17:37:35.566]                         invokeRestart("muffleWarning")
[17:37:35.566]                     }
[17:37:35.566]                     else if (inherits(cond, "condition")) {
[17:37:35.566]                       if (!is.null(pattern)) {
[17:37:35.566]                         computeRestarts <- base::computeRestarts
[17:37:35.566]                         grepl <- base::grepl
[17:37:35.566]                         restarts <- computeRestarts(cond)
[17:37:35.566]                         for (restart in restarts) {
[17:37:35.566]                           name <- restart$name
[17:37:35.566]                           if (is.null(name)) 
[17:37:35.566]                             next
[17:37:35.566]                           if (!grepl(pattern, name)) 
[17:37:35.566]                             next
[17:37:35.566]                           invokeRestart(restart)
[17:37:35.566]                           muffled <- TRUE
[17:37:35.566]                           break
[17:37:35.566]                         }
[17:37:35.566]                       }
[17:37:35.566]                     }
[17:37:35.566]                     invisible(muffled)
[17:37:35.566]                   }
[17:37:35.566]                   muffleCondition(cond)
[17:37:35.566]                 })
[17:37:35.566]             }))
[17:37:35.566]             future::FutureResult(value = ...future.value$value, 
[17:37:35.566]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.566]                   ...future.rng), globalenv = if (FALSE) 
[17:37:35.566]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:35.566]                     ...future.globalenv.names))
[17:37:35.566]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:35.566]         }, condition = base::local({
[17:37:35.566]             c <- base::c
[17:37:35.566]             inherits <- base::inherits
[17:37:35.566]             invokeRestart <- base::invokeRestart
[17:37:35.566]             length <- base::length
[17:37:35.566]             list <- base::list
[17:37:35.566]             seq.int <- base::seq.int
[17:37:35.566]             signalCondition <- base::signalCondition
[17:37:35.566]             sys.calls <- base::sys.calls
[17:37:35.566]             `[[` <- base::`[[`
[17:37:35.566]             `+` <- base::`+`
[17:37:35.566]             `<<-` <- base::`<<-`
[17:37:35.566]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:35.566]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:35.566]                   3L)]
[17:37:35.566]             }
[17:37:35.566]             function(cond) {
[17:37:35.566]                 is_error <- inherits(cond, "error")
[17:37:35.566]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:35.566]                   NULL)
[17:37:35.566]                 if (is_error) {
[17:37:35.566]                   sessionInformation <- function() {
[17:37:35.566]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:35.566]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:35.566]                       search = base::search(), system = base::Sys.info())
[17:37:35.566]                   }
[17:37:35.566]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.566]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:35.566]                     cond$call), session = sessionInformation(), 
[17:37:35.566]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:35.566]                   signalCondition(cond)
[17:37:35.566]                 }
[17:37:35.566]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:35.566]                 "immediateCondition"))) {
[17:37:35.566]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:35.566]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.566]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:35.566]                   if (TRUE && !signal) {
[17:37:35.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.566]                     {
[17:37:35.566]                       inherits <- base::inherits
[17:37:35.566]                       invokeRestart <- base::invokeRestart
[17:37:35.566]                       is.null <- base::is.null
[17:37:35.566]                       muffled <- FALSE
[17:37:35.566]                       if (inherits(cond, "message")) {
[17:37:35.566]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.566]                         if (muffled) 
[17:37:35.566]                           invokeRestart("muffleMessage")
[17:37:35.566]                       }
[17:37:35.566]                       else if (inherits(cond, "warning")) {
[17:37:35.566]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.566]                         if (muffled) 
[17:37:35.566]                           invokeRestart("muffleWarning")
[17:37:35.566]                       }
[17:37:35.566]                       else if (inherits(cond, "condition")) {
[17:37:35.566]                         if (!is.null(pattern)) {
[17:37:35.566]                           computeRestarts <- base::computeRestarts
[17:37:35.566]                           grepl <- base::grepl
[17:37:35.566]                           restarts <- computeRestarts(cond)
[17:37:35.566]                           for (restart in restarts) {
[17:37:35.566]                             name <- restart$name
[17:37:35.566]                             if (is.null(name)) 
[17:37:35.566]                               next
[17:37:35.566]                             if (!grepl(pattern, name)) 
[17:37:35.566]                               next
[17:37:35.566]                             invokeRestart(restart)
[17:37:35.566]                             muffled <- TRUE
[17:37:35.566]                             break
[17:37:35.566]                           }
[17:37:35.566]                         }
[17:37:35.566]                       }
[17:37:35.566]                       invisible(muffled)
[17:37:35.566]                     }
[17:37:35.566]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.566]                   }
[17:37:35.566]                 }
[17:37:35.566]                 else {
[17:37:35.566]                   if (TRUE) {
[17:37:35.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.566]                     {
[17:37:35.566]                       inherits <- base::inherits
[17:37:35.566]                       invokeRestart <- base::invokeRestart
[17:37:35.566]                       is.null <- base::is.null
[17:37:35.566]                       muffled <- FALSE
[17:37:35.566]                       if (inherits(cond, "message")) {
[17:37:35.566]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.566]                         if (muffled) 
[17:37:35.566]                           invokeRestart("muffleMessage")
[17:37:35.566]                       }
[17:37:35.566]                       else if (inherits(cond, "warning")) {
[17:37:35.566]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.566]                         if (muffled) 
[17:37:35.566]                           invokeRestart("muffleWarning")
[17:37:35.566]                       }
[17:37:35.566]                       else if (inherits(cond, "condition")) {
[17:37:35.566]                         if (!is.null(pattern)) {
[17:37:35.566]                           computeRestarts <- base::computeRestarts
[17:37:35.566]                           grepl <- base::grepl
[17:37:35.566]                           restarts <- computeRestarts(cond)
[17:37:35.566]                           for (restart in restarts) {
[17:37:35.566]                             name <- restart$name
[17:37:35.566]                             if (is.null(name)) 
[17:37:35.566]                               next
[17:37:35.566]                             if (!grepl(pattern, name)) 
[17:37:35.566]                               next
[17:37:35.566]                             invokeRestart(restart)
[17:37:35.566]                             muffled <- TRUE
[17:37:35.566]                             break
[17:37:35.566]                           }
[17:37:35.566]                         }
[17:37:35.566]                       }
[17:37:35.566]                       invisible(muffled)
[17:37:35.566]                     }
[17:37:35.566]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.566]                   }
[17:37:35.566]                 }
[17:37:35.566]             }
[17:37:35.566]         }))
[17:37:35.566]     }, error = function(ex) {
[17:37:35.566]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:35.566]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.566]                 ...future.rng), started = ...future.startTime, 
[17:37:35.566]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:35.566]             version = "1.8"), class = "FutureResult")
[17:37:35.566]     }, finally = {
[17:37:35.566]         if (!identical(...future.workdir, getwd())) 
[17:37:35.566]             setwd(...future.workdir)
[17:37:35.566]         {
[17:37:35.566]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:35.566]                 ...future.oldOptions$nwarnings <- NULL
[17:37:35.566]             }
[17:37:35.566]             base::options(...future.oldOptions)
[17:37:35.566]             if (.Platform$OS.type == "windows") {
[17:37:35.566]                 old_names <- names(...future.oldEnvVars)
[17:37:35.566]                 envs <- base::Sys.getenv()
[17:37:35.566]                 names <- names(envs)
[17:37:35.566]                 common <- intersect(names, old_names)
[17:37:35.566]                 added <- setdiff(names, old_names)
[17:37:35.566]                 removed <- setdiff(old_names, names)
[17:37:35.566]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:35.566]                   envs[common]]
[17:37:35.566]                 NAMES <- toupper(changed)
[17:37:35.566]                 args <- list()
[17:37:35.566]                 for (kk in seq_along(NAMES)) {
[17:37:35.566]                   name <- changed[[kk]]
[17:37:35.566]                   NAME <- NAMES[[kk]]
[17:37:35.566]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.566]                     next
[17:37:35.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.566]                 }
[17:37:35.566]                 NAMES <- toupper(added)
[17:37:35.566]                 for (kk in seq_along(NAMES)) {
[17:37:35.566]                   name <- added[[kk]]
[17:37:35.566]                   NAME <- NAMES[[kk]]
[17:37:35.566]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.566]                     next
[17:37:35.566]                   args[[name]] <- ""
[17:37:35.566]                 }
[17:37:35.566]                 NAMES <- toupper(removed)
[17:37:35.566]                 for (kk in seq_along(NAMES)) {
[17:37:35.566]                   name <- removed[[kk]]
[17:37:35.566]                   NAME <- NAMES[[kk]]
[17:37:35.566]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.566]                     next
[17:37:35.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.566]                 }
[17:37:35.566]                 if (length(args) > 0) 
[17:37:35.566]                   base::do.call(base::Sys.setenv, args = args)
[17:37:35.566]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:35.566]             }
[17:37:35.566]             else {
[17:37:35.566]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:35.566]             }
[17:37:35.566]             {
[17:37:35.566]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:35.566]                   0L) {
[17:37:35.566]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:35.566]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:35.566]                   base::options(opts)
[17:37:35.566]                 }
[17:37:35.566]                 {
[17:37:35.566]                   {
[17:37:35.566]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:35.566]                     NULL
[17:37:35.566]                   }
[17:37:35.566]                   options(future.plan = NULL)
[17:37:35.566]                   if (is.na(NA_character_)) 
[17:37:35.566]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.566]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:35.566]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:35.566]                     .init = FALSE)
[17:37:35.566]                 }
[17:37:35.566]             }
[17:37:35.566]         }
[17:37:35.566]     })
[17:37:35.566]     if (TRUE) {
[17:37:35.566]         base::sink(type = "output", split = FALSE)
[17:37:35.566]         if (TRUE) {
[17:37:35.566]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:35.566]         }
[17:37:35.566]         else {
[17:37:35.566]             ...future.result["stdout"] <- base::list(NULL)
[17:37:35.566]         }
[17:37:35.566]         base::close(...future.stdout)
[17:37:35.566]         ...future.stdout <- NULL
[17:37:35.566]     }
[17:37:35.566]     ...future.result$conditions <- ...future.conditions
[17:37:35.566]     ...future.result$finished <- base::Sys.time()
[17:37:35.566]     ...future.result
[17:37:35.566] }
[17:37:35.570] assign_globals() ...
[17:37:35.570] List of 5
[17:37:35.570]  $ ...future.FUN            :function (C, k)  
[17:37:35.570]  $ MoreArgs                 : NULL
[17:37:35.570]  $ ...future.elements_ii    :List of 2
[17:37:35.570]   ..$ :List of 1
[17:37:35.570]   .. ..$ : chr "D"
[17:37:35.570]   ..$ :List of 1
[17:37:35.570]   .. ..$ : int 2
[17:37:35.570]  $ ...future.seeds_ii       : NULL
[17:37:35.570]  $ ...future.globals.maxSize: NULL
[17:37:35.570]  - attr(*, "where")=List of 5
[17:37:35.570]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:35.570]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:35.570]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:35.570]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:35.570]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:35.570]  - attr(*, "resolved")= logi FALSE
[17:37:35.570]  - attr(*, "total_size")= num 3488
[17:37:35.570]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.570]  - attr(*, "already-done")= logi TRUE
[17:37:35.578] - reassign environment for ‘...future.FUN’
[17:37:35.581] - copied ‘...future.FUN’ to environment
[17:37:35.581] - copied ‘MoreArgs’ to environment
[17:37:35.582] - copied ‘...future.elements_ii’ to environment
[17:37:35.582] - copied ‘...future.seeds_ii’ to environment
[17:37:35.582] - copied ‘...future.globals.maxSize’ to environment
[17:37:35.582] assign_globals() ... done
[17:37:35.582] requestCore(): workers = 2
[17:37:35.583] Poll #1 (0): usedCores() = 2, workers = 2
[17:37:35.604] result() for MulticoreFuture ...
[17:37:35.605] result() for MulticoreFuture ...
[17:37:35.605] result() for MulticoreFuture ... done
[17:37:35.605] result() for MulticoreFuture ... done
[17:37:35.605] result() for MulticoreFuture ...
[17:37:35.605] result() for MulticoreFuture ... done
[17:37:35.607] MulticoreFuture started
[17:37:35.608] - Launch lazy future ... done
[17:37:35.608] run() for ‘MulticoreFuture’ ... done
[17:37:35.609] Created future:
[17:37:35.609] plan(): Setting new future strategy stack:
[17:37:35.609] List of future strategies:
[17:37:35.609] 1. sequential:
[17:37:35.609]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:35.609]    - tweaked: FALSE
[17:37:35.609]    - call: NULL
[17:37:35.610] plan(): nbrOfWorkers() = 1
[17:37:35.613] plan(): Setting new future strategy stack:
[17:37:35.613] List of future strategies:
[17:37:35.613] 1. multicore:
[17:37:35.613]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:35.613]    - tweaked: FALSE
[17:37:35.613]    - call: plan(strategy)
[17:37:35.619] plan(): nbrOfWorkers() = 2
[17:37:35.609] MulticoreFuture:
[17:37:35.609] Label: ‘future_mapply-4’
[17:37:35.609] Expression:
[17:37:35.609] {
[17:37:35.609]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.609]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:35.609]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.609]         on.exit(options(oopts), add = TRUE)
[17:37:35.609]     }
[17:37:35.609]     {
[17:37:35.609]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.609]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:35.609]         do.call(mapply, args = args)
[17:37:35.609]     }
[17:37:35.609] }
[17:37:35.609] Lazy evaluation: FALSE
[17:37:35.609] Asynchronous evaluation: TRUE
[17:37:35.609] Local evaluation: TRUE
[17:37:35.609] Environment: R_GlobalEnv
[17:37:35.609] Capture standard output: TRUE
[17:37:35.609] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:35.609] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:35.609] Packages: <none>
[17:37:35.609] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:35.609] Resolved: TRUE
[17:37:35.609] Value: <not collected>
[17:37:35.609] Conditions captured: <none>
[17:37:35.609] Early signaling: FALSE
[17:37:35.609] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:35.609] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.620] Chunk #4 of 5 ... DONE
[17:37:35.620] Chunk #5 of 5 ...
[17:37:35.620]  - Finding globals in '...' for chunk #5 ...
[17:37:35.620] getGlobalsAndPackages() ...
[17:37:35.620] Searching for globals...
[17:37:35.621] 
[17:37:35.621] Searching for globals ... DONE
[17:37:35.621] - globals: [0] <none>
[17:37:35.621] getGlobalsAndPackages() ... DONE
[17:37:35.621]    + additional globals found: [n=0] 
[17:37:35.622]    + additional namespaces needed: [n=0] 
[17:37:35.622]  - Finding globals in '...' for chunk #5 ... DONE
[17:37:35.622]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:37:35.622]  - seeds: <none>
[17:37:35.622]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.622] getGlobalsAndPackages() ...
[17:37:35.622] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.623] Resolving globals: FALSE
[17:37:35.623] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:37:35.624] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:35.625] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.625] 
[17:37:35.625] getGlobalsAndPackages() ... DONE
[17:37:35.625] run() for ‘Future’ ...
[17:37:35.626] - state: ‘created’
[17:37:35.626] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:35.631] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.631] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:35.631]   - Field: ‘label’
[17:37:35.631]   - Field: ‘local’
[17:37:35.631]   - Field: ‘owner’
[17:37:35.632]   - Field: ‘envir’
[17:37:35.632]   - Field: ‘workers’
[17:37:35.632]   - Field: ‘packages’
[17:37:35.632]   - Field: ‘gc’
[17:37:35.632]   - Field: ‘job’
[17:37:35.641]   - Field: ‘conditions’
[17:37:35.641]   - Field: ‘expr’
[17:37:35.641]   - Field: ‘uuid’
[17:37:35.641]   - Field: ‘seed’
[17:37:35.642]   - Field: ‘version’
[17:37:35.642]   - Field: ‘result’
[17:37:35.642]   - Field: ‘asynchronous’
[17:37:35.642]   - Field: ‘calls’
[17:37:35.642]   - Field: ‘globals’
[17:37:35.642]   - Field: ‘stdout’
[17:37:35.642]   - Field: ‘earlySignal’
[17:37:35.642]   - Field: ‘lazy’
[17:37:35.642]   - Field: ‘state’
[17:37:35.643] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:35.643] - Launch lazy future ...
[17:37:35.643] Packages needed by the future expression (n = 0): <none>
[17:37:35.643] Packages needed by future strategies (n = 0): <none>
[17:37:35.644] {
[17:37:35.644]     {
[17:37:35.644]         {
[17:37:35.644]             ...future.startTime <- base::Sys.time()
[17:37:35.644]             {
[17:37:35.644]                 {
[17:37:35.644]                   {
[17:37:35.644]                     {
[17:37:35.644]                       base::local({
[17:37:35.644]                         has_future <- base::requireNamespace("future", 
[17:37:35.644]                           quietly = TRUE)
[17:37:35.644]                         if (has_future) {
[17:37:35.644]                           ns <- base::getNamespace("future")
[17:37:35.644]                           version <- ns[[".package"]][["version"]]
[17:37:35.644]                           if (is.null(version)) 
[17:37:35.644]                             version <- utils::packageVersion("future")
[17:37:35.644]                         }
[17:37:35.644]                         else {
[17:37:35.644]                           version <- NULL
[17:37:35.644]                         }
[17:37:35.644]                         if (!has_future || version < "1.8.0") {
[17:37:35.644]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:35.644]                             "", base::R.version$version.string), 
[17:37:35.644]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:35.644]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:35.644]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:35.644]                               "release", "version")], collapse = " "), 
[17:37:35.644]                             hostname = base::Sys.info()[["nodename"]])
[17:37:35.644]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:35.644]                             info)
[17:37:35.644]                           info <- base::paste(info, collapse = "; ")
[17:37:35.644]                           if (!has_future) {
[17:37:35.644]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:35.644]                               info)
[17:37:35.644]                           }
[17:37:35.644]                           else {
[17:37:35.644]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:35.644]                               info, version)
[17:37:35.644]                           }
[17:37:35.644]                           base::stop(msg)
[17:37:35.644]                         }
[17:37:35.644]                       })
[17:37:35.644]                     }
[17:37:35.644]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:35.644]                     base::options(mc.cores = 1L)
[17:37:35.644]                   }
[17:37:35.644]                   ...future.strategy.old <- future::plan("list")
[17:37:35.644]                   options(future.plan = NULL)
[17:37:35.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:35.644]                 }
[17:37:35.644]                 ...future.workdir <- getwd()
[17:37:35.644]             }
[17:37:35.644]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:35.644]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:35.644]         }
[17:37:35.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:35.644]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:37:35.644]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:35.644]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:35.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:35.644]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:35.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:35.644]             base::names(...future.oldOptions))
[17:37:35.644]     }
[17:37:35.644]     if (FALSE) {
[17:37:35.644]     }
[17:37:35.644]     else {
[17:37:35.644]         if (TRUE) {
[17:37:35.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:35.644]                 open = "w")
[17:37:35.644]         }
[17:37:35.644]         else {
[17:37:35.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:35.644]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:35.644]         }
[17:37:35.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:35.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:35.644]             base::sink(type = "output", split = FALSE)
[17:37:35.644]             base::close(...future.stdout)
[17:37:35.644]         }, add = TRUE)
[17:37:35.644]     }
[17:37:35.644]     ...future.frame <- base::sys.nframe()
[17:37:35.644]     ...future.conditions <- base::list()
[17:37:35.644]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:35.644]     if (FALSE) {
[17:37:35.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:35.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:35.644]     }
[17:37:35.644]     ...future.result <- base::tryCatch({
[17:37:35.644]         base::withCallingHandlers({
[17:37:35.644]             ...future.value <- base::withVisible(base::local({
[17:37:35.644]                 withCallingHandlers({
[17:37:35.644]                   {
[17:37:35.644]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.644]                     if (!identical(...future.globals.maxSize.org, 
[17:37:35.644]                       ...future.globals.maxSize)) {
[17:37:35.644]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.644]                       on.exit(options(oopts), add = TRUE)
[17:37:35.644]                     }
[17:37:35.644]                     {
[17:37:35.644]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.644]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:35.644]                         USE.NAMES = FALSE)
[17:37:35.644]                       do.call(mapply, args = args)
[17:37:35.644]                     }
[17:37:35.644]                   }
[17:37:35.644]                 }, immediateCondition = function(cond) {
[17:37:35.644]                   save_rds <- function (object, pathname, ...) 
[17:37:35.644]                   {
[17:37:35.644]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:35.644]                     if (file_test("-f", pathname_tmp)) {
[17:37:35.644]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.644]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:35.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.644]                         fi_tmp[["mtime"]])
[17:37:35.644]                     }
[17:37:35.644]                     tryCatch({
[17:37:35.644]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:35.644]                     }, error = function(ex) {
[17:37:35.644]                       msg <- conditionMessage(ex)
[17:37:35.644]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.644]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:35.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.644]                         fi_tmp[["mtime"]], msg)
[17:37:35.644]                       ex$message <- msg
[17:37:35.644]                       stop(ex)
[17:37:35.644]                     })
[17:37:35.644]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:35.644]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:35.644]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:35.644]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.644]                       fi <- file.info(pathname)
[17:37:35.644]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:35.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.644]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:35.644]                         fi[["size"]], fi[["mtime"]])
[17:37:35.644]                       stop(msg)
[17:37:35.644]                     }
[17:37:35.644]                     invisible(pathname)
[17:37:35.644]                   }
[17:37:35.644]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:35.644]                     rootPath = tempdir()) 
[17:37:35.644]                   {
[17:37:35.644]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:35.644]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:35.644]                       tmpdir = path, fileext = ".rds")
[17:37:35.644]                     save_rds(obj, file)
[17:37:35.644]                   }
[17:37:35.644]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:35.644]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.644]                   {
[17:37:35.644]                     inherits <- base::inherits
[17:37:35.644]                     invokeRestart <- base::invokeRestart
[17:37:35.644]                     is.null <- base::is.null
[17:37:35.644]                     muffled <- FALSE
[17:37:35.644]                     if (inherits(cond, "message")) {
[17:37:35.644]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:35.644]                       if (muffled) 
[17:37:35.644]                         invokeRestart("muffleMessage")
[17:37:35.644]                     }
[17:37:35.644]                     else if (inherits(cond, "warning")) {
[17:37:35.644]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:35.644]                       if (muffled) 
[17:37:35.644]                         invokeRestart("muffleWarning")
[17:37:35.644]                     }
[17:37:35.644]                     else if (inherits(cond, "condition")) {
[17:37:35.644]                       if (!is.null(pattern)) {
[17:37:35.644]                         computeRestarts <- base::computeRestarts
[17:37:35.644]                         grepl <- base::grepl
[17:37:35.644]                         restarts <- computeRestarts(cond)
[17:37:35.644]                         for (restart in restarts) {
[17:37:35.644]                           name <- restart$name
[17:37:35.644]                           if (is.null(name)) 
[17:37:35.644]                             next
[17:37:35.644]                           if (!grepl(pattern, name)) 
[17:37:35.644]                             next
[17:37:35.644]                           invokeRestart(restart)
[17:37:35.644]                           muffled <- TRUE
[17:37:35.644]                           break
[17:37:35.644]                         }
[17:37:35.644]                       }
[17:37:35.644]                     }
[17:37:35.644]                     invisible(muffled)
[17:37:35.644]                   }
[17:37:35.644]                   muffleCondition(cond)
[17:37:35.644]                 })
[17:37:35.644]             }))
[17:37:35.644]             future::FutureResult(value = ...future.value$value, 
[17:37:35.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.644]                   ...future.rng), globalenv = if (FALSE) 
[17:37:35.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:35.644]                     ...future.globalenv.names))
[17:37:35.644]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:35.644]         }, condition = base::local({
[17:37:35.644]             c <- base::c
[17:37:35.644]             inherits <- base::inherits
[17:37:35.644]             invokeRestart <- base::invokeRestart
[17:37:35.644]             length <- base::length
[17:37:35.644]             list <- base::list
[17:37:35.644]             seq.int <- base::seq.int
[17:37:35.644]             signalCondition <- base::signalCondition
[17:37:35.644]             sys.calls <- base::sys.calls
[17:37:35.644]             `[[` <- base::`[[`
[17:37:35.644]             `+` <- base::`+`
[17:37:35.644]             `<<-` <- base::`<<-`
[17:37:35.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:35.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:35.644]                   3L)]
[17:37:35.644]             }
[17:37:35.644]             function(cond) {
[17:37:35.644]                 is_error <- inherits(cond, "error")
[17:37:35.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:35.644]                   NULL)
[17:37:35.644]                 if (is_error) {
[17:37:35.644]                   sessionInformation <- function() {
[17:37:35.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:35.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:35.644]                       search = base::search(), system = base::Sys.info())
[17:37:35.644]                   }
[17:37:35.644]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:35.644]                     cond$call), session = sessionInformation(), 
[17:37:35.644]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:35.644]                   signalCondition(cond)
[17:37:35.644]                 }
[17:37:35.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:35.644]                 "immediateCondition"))) {
[17:37:35.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:35.644]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:35.644]                   if (TRUE && !signal) {
[17:37:35.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.644]                     {
[17:37:35.644]                       inherits <- base::inherits
[17:37:35.644]                       invokeRestart <- base::invokeRestart
[17:37:35.644]                       is.null <- base::is.null
[17:37:35.644]                       muffled <- FALSE
[17:37:35.644]                       if (inherits(cond, "message")) {
[17:37:35.644]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.644]                         if (muffled) 
[17:37:35.644]                           invokeRestart("muffleMessage")
[17:37:35.644]                       }
[17:37:35.644]                       else if (inherits(cond, "warning")) {
[17:37:35.644]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.644]                         if (muffled) 
[17:37:35.644]                           invokeRestart("muffleWarning")
[17:37:35.644]                       }
[17:37:35.644]                       else if (inherits(cond, "condition")) {
[17:37:35.644]                         if (!is.null(pattern)) {
[17:37:35.644]                           computeRestarts <- base::computeRestarts
[17:37:35.644]                           grepl <- base::grepl
[17:37:35.644]                           restarts <- computeRestarts(cond)
[17:37:35.644]                           for (restart in restarts) {
[17:37:35.644]                             name <- restart$name
[17:37:35.644]                             if (is.null(name)) 
[17:37:35.644]                               next
[17:37:35.644]                             if (!grepl(pattern, name)) 
[17:37:35.644]                               next
[17:37:35.644]                             invokeRestart(restart)
[17:37:35.644]                             muffled <- TRUE
[17:37:35.644]                             break
[17:37:35.644]                           }
[17:37:35.644]                         }
[17:37:35.644]                       }
[17:37:35.644]                       invisible(muffled)
[17:37:35.644]                     }
[17:37:35.644]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.644]                   }
[17:37:35.644]                 }
[17:37:35.644]                 else {
[17:37:35.644]                   if (TRUE) {
[17:37:35.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.644]                     {
[17:37:35.644]                       inherits <- base::inherits
[17:37:35.644]                       invokeRestart <- base::invokeRestart
[17:37:35.644]                       is.null <- base::is.null
[17:37:35.644]                       muffled <- FALSE
[17:37:35.644]                       if (inherits(cond, "message")) {
[17:37:35.644]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.644]                         if (muffled) 
[17:37:35.644]                           invokeRestart("muffleMessage")
[17:37:35.644]                       }
[17:37:35.644]                       else if (inherits(cond, "warning")) {
[17:37:35.644]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.644]                         if (muffled) 
[17:37:35.644]                           invokeRestart("muffleWarning")
[17:37:35.644]                       }
[17:37:35.644]                       else if (inherits(cond, "condition")) {
[17:37:35.644]                         if (!is.null(pattern)) {
[17:37:35.644]                           computeRestarts <- base::computeRestarts
[17:37:35.644]                           grepl <- base::grepl
[17:37:35.644]                           restarts <- computeRestarts(cond)
[17:37:35.644]                           for (restart in restarts) {
[17:37:35.644]                             name <- restart$name
[17:37:35.644]                             if (is.null(name)) 
[17:37:35.644]                               next
[17:37:35.644]                             if (!grepl(pattern, name)) 
[17:37:35.644]                               next
[17:37:35.644]                             invokeRestart(restart)
[17:37:35.644]                             muffled <- TRUE
[17:37:35.644]                             break
[17:37:35.644]                           }
[17:37:35.644]                         }
[17:37:35.644]                       }
[17:37:35.644]                       invisible(muffled)
[17:37:35.644]                     }
[17:37:35.644]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.644]                   }
[17:37:35.644]                 }
[17:37:35.644]             }
[17:37:35.644]         }))
[17:37:35.644]     }, error = function(ex) {
[17:37:35.644]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:35.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.644]                 ...future.rng), started = ...future.startTime, 
[17:37:35.644]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:35.644]             version = "1.8"), class = "FutureResult")
[17:37:35.644]     }, finally = {
[17:37:35.644]         if (!identical(...future.workdir, getwd())) 
[17:37:35.644]             setwd(...future.workdir)
[17:37:35.644]         {
[17:37:35.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:35.644]                 ...future.oldOptions$nwarnings <- NULL
[17:37:35.644]             }
[17:37:35.644]             base::options(...future.oldOptions)
[17:37:35.644]             if (.Platform$OS.type == "windows") {
[17:37:35.644]                 old_names <- names(...future.oldEnvVars)
[17:37:35.644]                 envs <- base::Sys.getenv()
[17:37:35.644]                 names <- names(envs)
[17:37:35.644]                 common <- intersect(names, old_names)
[17:37:35.644]                 added <- setdiff(names, old_names)
[17:37:35.644]                 removed <- setdiff(old_names, names)
[17:37:35.644]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:35.644]                   envs[common]]
[17:37:35.644]                 NAMES <- toupper(changed)
[17:37:35.644]                 args <- list()
[17:37:35.644]                 for (kk in seq_along(NAMES)) {
[17:37:35.644]                   name <- changed[[kk]]
[17:37:35.644]                   NAME <- NAMES[[kk]]
[17:37:35.644]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.644]                     next
[17:37:35.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.644]                 }
[17:37:35.644]                 NAMES <- toupper(added)
[17:37:35.644]                 for (kk in seq_along(NAMES)) {
[17:37:35.644]                   name <- added[[kk]]
[17:37:35.644]                   NAME <- NAMES[[kk]]
[17:37:35.644]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.644]                     next
[17:37:35.644]                   args[[name]] <- ""
[17:37:35.644]                 }
[17:37:35.644]                 NAMES <- toupper(removed)
[17:37:35.644]                 for (kk in seq_along(NAMES)) {
[17:37:35.644]                   name <- removed[[kk]]
[17:37:35.644]                   NAME <- NAMES[[kk]]
[17:37:35.644]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.644]                     next
[17:37:35.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.644]                 }
[17:37:35.644]                 if (length(args) > 0) 
[17:37:35.644]                   base::do.call(base::Sys.setenv, args = args)
[17:37:35.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:35.644]             }
[17:37:35.644]             else {
[17:37:35.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:35.644]             }
[17:37:35.644]             {
[17:37:35.644]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:35.644]                   0L) {
[17:37:35.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:35.644]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:35.644]                   base::options(opts)
[17:37:35.644]                 }
[17:37:35.644]                 {
[17:37:35.644]                   {
[17:37:35.644]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:35.644]                     NULL
[17:37:35.644]                   }
[17:37:35.644]                   options(future.plan = NULL)
[17:37:35.644]                   if (is.na(NA_character_)) 
[17:37:35.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:35.644]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:35.644]                     .init = FALSE)
[17:37:35.644]                 }
[17:37:35.644]             }
[17:37:35.644]         }
[17:37:35.644]     })
[17:37:35.644]     if (TRUE) {
[17:37:35.644]         base::sink(type = "output", split = FALSE)
[17:37:35.644]         if (TRUE) {
[17:37:35.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:35.644]         }
[17:37:35.644]         else {
[17:37:35.644]             ...future.result["stdout"] <- base::list(NULL)
[17:37:35.644]         }
[17:37:35.644]         base::close(...future.stdout)
[17:37:35.644]         ...future.stdout <- NULL
[17:37:35.644]     }
[17:37:35.644]     ...future.result$conditions <- ...future.conditions
[17:37:35.644]     ...future.result$finished <- base::Sys.time()
[17:37:35.644]     ...future.result
[17:37:35.644] }
[17:37:35.647] assign_globals() ...
[17:37:35.647] List of 5
[17:37:35.647]  $ ...future.FUN            :function (C, k)  
[17:37:35.647]  $ MoreArgs                 : NULL
[17:37:35.647]  $ ...future.elements_ii    :List of 2
[17:37:35.647]   ..$ :List of 1
[17:37:35.647]   .. ..$ : chr "E"
[17:37:35.647]   ..$ :List of 1
[17:37:35.647]   .. ..$ : int 1
[17:37:35.647]  $ ...future.seeds_ii       : NULL
[17:37:35.647]  $ ...future.globals.maxSize: NULL
[17:37:35.647]  - attr(*, "where")=List of 5
[17:37:35.647]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:35.647]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:35.647]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:35.647]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:35.647]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:35.647]  - attr(*, "resolved")= logi FALSE
[17:37:35.647]  - attr(*, "total_size")= num 3488
[17:37:35.647]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.647]  - attr(*, "already-done")= logi TRUE
[17:37:35.655] - reassign environment for ‘...future.FUN’
[17:37:35.655] - copied ‘...future.FUN’ to environment
[17:37:35.656] - copied ‘MoreArgs’ to environment
[17:37:35.656] - copied ‘...future.elements_ii’ to environment
[17:37:35.656] - copied ‘...future.seeds_ii’ to environment
[17:37:35.656] - copied ‘...future.globals.maxSize’ to environment
[17:37:35.656] assign_globals() ... done
[17:37:35.656] requestCore(): workers = 2
[17:37:35.657] Poll #1 (0): usedCores() = 2, workers = 2
[17:37:35.667] result() for MulticoreFuture ...
[17:37:35.668] result() for MulticoreFuture ...
[17:37:35.668] result() for MulticoreFuture ... done
[17:37:35.669] result() for MulticoreFuture ... done
[17:37:35.669] result() for MulticoreFuture ...
[17:37:35.669] result() for MulticoreFuture ... done
[17:37:35.672] MulticoreFuture started
[17:37:35.673] - Launch lazy future ... done
[17:37:35.673] run() for ‘MulticoreFuture’ ... done
[17:37:35.673] Created future:
[17:37:35.673] plan(): Setting new future strategy stack:
[17:37:35.673] List of future strategies:
[17:37:35.673] 1. sequential:
[17:37:35.673]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:35.673]    - tweaked: FALSE
[17:37:35.673]    - call: NULL
[17:37:35.674] plan(): nbrOfWorkers() = 1
[17:37:35.676] plan(): Setting new future strategy stack:
[17:37:35.677] List of future strategies:
[17:37:35.677] 1. multicore:
[17:37:35.677]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:35.677]    - tweaked: FALSE
[17:37:35.677]    - call: plan(strategy)
[17:37:35.682] plan(): nbrOfWorkers() = 2
[17:37:35.673] MulticoreFuture:
[17:37:35.673] Label: ‘future_mapply-5’
[17:37:35.673] Expression:
[17:37:35.673] {
[17:37:35.673]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.673]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:35.673]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.673]         on.exit(options(oopts), add = TRUE)
[17:37:35.673]     }
[17:37:35.673]     {
[17:37:35.673]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.673]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:35.673]         do.call(mapply, args = args)
[17:37:35.673]     }
[17:37:35.673] }
[17:37:35.673] Lazy evaluation: FALSE
[17:37:35.673] Asynchronous evaluation: TRUE
[17:37:35.673] Local evaluation: TRUE
[17:37:35.673] Environment: R_GlobalEnv
[17:37:35.673] Capture standard output: TRUE
[17:37:35.673] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:35.673] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:35.673] Packages: <none>
[17:37:35.673] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:35.673] Resolved: TRUE
[17:37:35.673] Value: <not collected>
[17:37:35.673] Conditions captured: <none>
[17:37:35.673] Early signaling: FALSE
[17:37:35.673] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:35.673] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.683] Chunk #5 of 5 ... DONE
[17:37:35.683] Launching 5 futures (chunks) ... DONE
[17:37:35.683] Resolving 5 futures (chunks) ...
[17:37:35.683] resolve() on list ...
[17:37:35.684]  recursive: 0
[17:37:35.684]  length: 5
[17:37:35.684] 
[17:37:35.684] Future #1
[17:37:35.684] result() for MulticoreFuture ...
[17:37:35.684] result() for MulticoreFuture ... done
[17:37:35.685] result() for MulticoreFuture ...
[17:37:35.685] result() for MulticoreFuture ... done
[17:37:35.685] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:37:35.685] - nx: 5
[17:37:35.685] - relay: TRUE
[17:37:35.685] - stdout: TRUE
[17:37:35.685] - signal: TRUE
[17:37:35.685] - resignal: FALSE
[17:37:35.686] - force: TRUE
[17:37:35.686] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[17:37:35.686] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[17:37:35.686]  - until=1
[17:37:35.686]  - relaying element #1
[17:37:35.686] result() for MulticoreFuture ...
[17:37:35.686] result() for MulticoreFuture ... done
[17:37:35.687] result() for MulticoreFuture ...
[17:37:35.687] result() for MulticoreFuture ... done
[17:37:35.687] result() for MulticoreFuture ...
[17:37:35.687] result() for MulticoreFuture ... done
[17:37:35.687] result() for MulticoreFuture ...
[17:37:35.688] result() for MulticoreFuture ... done
[17:37:35.688] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:37:35.688] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:37:35.688] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:37:35.688]  length: 4 (resolved future 1)
[17:37:35.688] Future #2
[17:37:35.689] result() for MulticoreFuture ...
[17:37:35.689] result() for MulticoreFuture ... done
[17:37:35.689] result() for MulticoreFuture ...
[17:37:35.689] result() for MulticoreFuture ... done
[17:37:35.689] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:37:35.689] - nx: 5
[17:37:35.689] - relay: TRUE
[17:37:35.690] - stdout: TRUE
[17:37:35.690] - signal: TRUE
[17:37:35.690] - resignal: FALSE
[17:37:35.690] - force: TRUE
[17:37:35.690] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:37:35.690] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:37:35.690]  - until=2
[17:37:35.691]  - relaying element #2
[17:37:35.691] result() for MulticoreFuture ...
[17:37:35.691] result() for MulticoreFuture ... done
[17:37:35.691] result() for MulticoreFuture ...
[17:37:35.691] result() for MulticoreFuture ... done
[17:37:35.691] result() for MulticoreFuture ...
[17:37:35.692] result() for MulticoreFuture ... done
[17:37:35.692] result() for MulticoreFuture ...
[17:37:35.692] result() for MulticoreFuture ... done
[17:37:35.692] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:37:35.692] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:37:35.692] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:37:35.693]  length: 3 (resolved future 2)
[17:37:35.693] Future #3
[17:37:35.693] result() for MulticoreFuture ...
[17:37:35.693] result() for MulticoreFuture ... done
[17:37:35.693] result() for MulticoreFuture ...
[17:37:35.693] result() for MulticoreFuture ... done
[17:37:35.693] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:37:35.694] - nx: 5
[17:37:35.694] - relay: TRUE
[17:37:35.694] - stdout: TRUE
[17:37:35.694] - signal: TRUE
[17:37:35.694] - resignal: FALSE
[17:37:35.694] - force: TRUE
[17:37:35.694] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:37:35.695] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:37:35.695]  - until=3
[17:37:35.695]  - relaying element #3
[17:37:35.695] result() for MulticoreFuture ...
[17:37:35.695] result() for MulticoreFuture ... done
[17:37:35.695] result() for MulticoreFuture ...
[17:37:35.695] result() for MulticoreFuture ... done
[17:37:35.696] result() for MulticoreFuture ...
[17:37:35.696] result() for MulticoreFuture ... done
[17:37:35.696] result() for MulticoreFuture ...
[17:37:35.696] result() for MulticoreFuture ... done
[17:37:35.696] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:37:35.696] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:37:35.697] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:37:35.697]  length: 2 (resolved future 3)
[17:37:35.697] Future #4
[17:37:35.697] result() for MulticoreFuture ...
[17:37:35.702] result() for MulticoreFuture ...
[17:37:35.703] result() for MulticoreFuture ... done
[17:37:35.703] result() for MulticoreFuture ... done
[17:37:35.703] result() for MulticoreFuture ...
[17:37:35.704] result() for MulticoreFuture ... done
[17:37:35.704] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:37:35.704] - nx: 5
[17:37:35.704] - relay: TRUE
[17:37:35.705] - stdout: TRUE
[17:37:35.705] - signal: TRUE
[17:37:35.705] - resignal: FALSE
[17:37:35.705] - force: TRUE
[17:37:35.706] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:37:35.706] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:37:35.706]  - until=4
[17:37:35.707]  - relaying element #4
[17:37:35.707] result() for MulticoreFuture ...
[17:37:35.707] result() for MulticoreFuture ... done
[17:37:35.707] result() for MulticoreFuture ...
[17:37:35.707] result() for MulticoreFuture ... done
[17:37:35.708] result() for MulticoreFuture ...
[17:37:35.708] result() for MulticoreFuture ... done
[17:37:35.708] result() for MulticoreFuture ...
[17:37:35.708] result() for MulticoreFuture ... done
[17:37:35.709] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:37:35.709] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:37:35.709] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:37:35.709]  length: 1 (resolved future 4)
[17:37:35.710] Future #5
[17:37:35.710] result() for MulticoreFuture ...
[17:37:35.711] result() for MulticoreFuture ...
[17:37:35.711] result() for MulticoreFuture ... done
[17:37:35.711] result() for MulticoreFuture ... done
[17:37:35.711] result() for MulticoreFuture ...
[17:37:35.712] result() for MulticoreFuture ... done
[17:37:35.712] signalConditionsASAP(MulticoreFuture, pos=5) ...
[17:37:35.712] - nx: 5
[17:37:35.712] - relay: TRUE
[17:37:35.712] - stdout: TRUE
[17:37:35.712] - signal: TRUE
[17:37:35.713] - resignal: FALSE
[17:37:35.713] - force: TRUE
[17:37:35.713] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:37:35.713] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:37:35.713]  - until=5
[17:37:35.713]  - relaying element #5
[17:37:35.713] result() for MulticoreFuture ...
[17:37:35.713] result() for MulticoreFuture ... done
[17:37:35.713] result() for MulticoreFuture ...
[17:37:35.714] result() for MulticoreFuture ... done
[17:37:35.714] result() for MulticoreFuture ...
[17:37:35.714] result() for MulticoreFuture ... done
[17:37:35.714] result() for MulticoreFuture ...
[17:37:35.714] result() for MulticoreFuture ... done
[17:37:35.714] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:37:35.714] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:37:35.714] signalConditionsASAP(MulticoreFuture, pos=5) ... done
[17:37:35.715]  length: 0 (resolved future 5)
[17:37:35.715] Relaying remaining futures
[17:37:35.715] signalConditionsASAP(NULL, pos=0) ...
[17:37:35.715] - nx: 5
[17:37:35.715] - relay: TRUE
[17:37:35.715] - stdout: TRUE
[17:37:35.715] - signal: TRUE
[17:37:35.715] - resignal: FALSE
[17:37:35.715] - force: TRUE
[17:37:35.716] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:37:35.716] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[17:37:35.716] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:37:35.716] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:37:35.716] signalConditionsASAP(NULL, pos=0) ... done
[17:37:35.716] resolve() on list ... DONE
[17:37:35.716] result() for MulticoreFuture ...
[17:37:35.716] result() for MulticoreFuture ... done
[17:37:35.717] result() for MulticoreFuture ...
[17:37:35.717] result() for MulticoreFuture ... done
[17:37:35.717] result() for MulticoreFuture ...
[17:37:35.717] result() for MulticoreFuture ... done
[17:37:35.717] result() for MulticoreFuture ...
[17:37:35.717] result() for MulticoreFuture ... done
[17:37:35.717] result() for MulticoreFuture ...
[17:37:35.717] result() for MulticoreFuture ... done
[17:37:35.717] result() for MulticoreFuture ...
[17:37:35.718] result() for MulticoreFuture ... done
[17:37:35.718] result() for MulticoreFuture ...
[17:37:35.718] result() for MulticoreFuture ... done
[17:37:35.718] result() for MulticoreFuture ...
[17:37:35.718] result() for MulticoreFuture ... done
[17:37:35.718] result() for MulticoreFuture ...
[17:37:35.718] result() for MulticoreFuture ... done
[17:37:35.718] result() for MulticoreFuture ...
[17:37:35.718] result() for MulticoreFuture ... done
[17:37:35.719]  - Number of value chunks collected: 5
[17:37:35.719] Resolving 5 futures (chunks) ... DONE
[17:37:35.719] Reducing values from 5 chunks ...
[17:37:35.719]  - Number of values collected after concatenation: 5
[17:37:35.719]  - Number of values expected: 5
[17:37:35.719] Reducing values from 5 chunks ... DONE
[17:37:35.719] future_mapply() ... DONE
[17:37:35.719] future_mapply() ...
[17:37:35.724] Number of chunks: 2
[17:37:35.724] getGlobalsAndPackagesXApply() ...
[17:37:35.724]  - future.globals: TRUE
[17:37:35.724] getGlobalsAndPackages() ...
[17:37:35.724] Searching for globals...
[17:37:35.726] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:37:35.726] Searching for globals ... DONE
[17:37:35.726] Resolving globals: FALSE
[17:37:35.726] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:37:35.727] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:37:35.727] - globals: [1] ‘FUN’
[17:37:35.727] 
[17:37:35.727] getGlobalsAndPackages() ... DONE
[17:37:35.727]  - globals found/used: [n=1] ‘FUN’
[17:37:35.727]  - needed namespaces: [n=0] 
[17:37:35.727] Finding globals ... DONE
[17:37:35.727] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:35.728] List of 2
[17:37:35.728]  $ ...future.FUN:function (C, k)  
[17:37:35.728]  $ MoreArgs     : list()
[17:37:35.728]  - attr(*, "where")=List of 2
[17:37:35.728]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:35.728]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:35.728]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.728]  - attr(*, "resolved")= logi FALSE
[17:37:35.728]  - attr(*, "total_size")= num NA
[17:37:35.730] Packages to be attached in all futures: [n=0] 
[17:37:35.730] getGlobalsAndPackagesXApply() ... DONE
[17:37:35.731] Number of futures (= number of chunks): 2
[17:37:35.731] Launching 2 futures (chunks) ...
[17:37:35.731] Chunk #1 of 2 ...
[17:37:35.731]  - Finding globals in '...' for chunk #1 ...
[17:37:35.731] getGlobalsAndPackages() ...
[17:37:35.731] Searching for globals...
[17:37:35.731] 
[17:37:35.732] Searching for globals ... DONE
[17:37:35.732] - globals: [0] <none>
[17:37:35.732] getGlobalsAndPackages() ... DONE
[17:37:35.732]    + additional globals found: [n=0] 
[17:37:35.732]    + additional namespaces needed: [n=0] 
[17:37:35.732]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:35.732]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:35.732]  - seeds: <none>
[17:37:35.732]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.733] getGlobalsAndPackages() ...
[17:37:35.733] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.733] Resolving globals: FALSE
[17:37:35.733] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:37:35.736] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:35.736] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.736] 
[17:37:35.737] getGlobalsAndPackages() ... DONE
[17:37:35.737] run() for ‘Future’ ...
[17:37:35.737] - state: ‘created’
[17:37:35.737] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:35.741] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.742] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:35.742]   - Field: ‘label’
[17:37:35.742]   - Field: ‘local’
[17:37:35.742]   - Field: ‘owner’
[17:37:35.742]   - Field: ‘envir’
[17:37:35.742]   - Field: ‘workers’
[17:37:35.742]   - Field: ‘packages’
[17:37:35.743]   - Field: ‘gc’
[17:37:35.743]   - Field: ‘job’
[17:37:35.743]   - Field: ‘conditions’
[17:37:35.743]   - Field: ‘expr’
[17:37:35.743]   - Field: ‘uuid’
[17:37:35.743]   - Field: ‘seed’
[17:37:35.743]   - Field: ‘version’
[17:37:35.743]   - Field: ‘result’
[17:37:35.743]   - Field: ‘asynchronous’
[17:37:35.744]   - Field: ‘calls’
[17:37:35.744]   - Field: ‘globals’
[17:37:35.744]   - Field: ‘stdout’
[17:37:35.744]   - Field: ‘earlySignal’
[17:37:35.744]   - Field: ‘lazy’
[17:37:35.744]   - Field: ‘state’
[17:37:35.744] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:35.745] - Launch lazy future ...
[17:37:35.745] Packages needed by the future expression (n = 0): <none>
[17:37:35.745] Packages needed by future strategies (n = 0): <none>
[17:37:35.745] {
[17:37:35.745]     {
[17:37:35.745]         {
[17:37:35.745]             ...future.startTime <- base::Sys.time()
[17:37:35.745]             {
[17:37:35.745]                 {
[17:37:35.745]                   {
[17:37:35.745]                     {
[17:37:35.745]                       base::local({
[17:37:35.745]                         has_future <- base::requireNamespace("future", 
[17:37:35.745]                           quietly = TRUE)
[17:37:35.745]                         if (has_future) {
[17:37:35.745]                           ns <- base::getNamespace("future")
[17:37:35.745]                           version <- ns[[".package"]][["version"]]
[17:37:35.745]                           if (is.null(version)) 
[17:37:35.745]                             version <- utils::packageVersion("future")
[17:37:35.745]                         }
[17:37:35.745]                         else {
[17:37:35.745]                           version <- NULL
[17:37:35.745]                         }
[17:37:35.745]                         if (!has_future || version < "1.8.0") {
[17:37:35.745]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:35.745]                             "", base::R.version$version.string), 
[17:37:35.745]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:35.745]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:35.745]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:35.745]                               "release", "version")], collapse = " "), 
[17:37:35.745]                             hostname = base::Sys.info()[["nodename"]])
[17:37:35.745]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:35.745]                             info)
[17:37:35.745]                           info <- base::paste(info, collapse = "; ")
[17:37:35.745]                           if (!has_future) {
[17:37:35.745]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:35.745]                               info)
[17:37:35.745]                           }
[17:37:35.745]                           else {
[17:37:35.745]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:35.745]                               info, version)
[17:37:35.745]                           }
[17:37:35.745]                           base::stop(msg)
[17:37:35.745]                         }
[17:37:35.745]                       })
[17:37:35.745]                     }
[17:37:35.745]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:35.745]                     base::options(mc.cores = 1L)
[17:37:35.745]                   }
[17:37:35.745]                   ...future.strategy.old <- future::plan("list")
[17:37:35.745]                   options(future.plan = NULL)
[17:37:35.745]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.745]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:35.745]                 }
[17:37:35.745]                 ...future.workdir <- getwd()
[17:37:35.745]             }
[17:37:35.745]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:35.745]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:35.745]         }
[17:37:35.745]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:35.745]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:35.745]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:35.745]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:35.745]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:35.745]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:35.745]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:35.745]             base::names(...future.oldOptions))
[17:37:35.745]     }
[17:37:35.745]     if (FALSE) {
[17:37:35.745]     }
[17:37:35.745]     else {
[17:37:35.745]         if (TRUE) {
[17:37:35.745]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:35.745]                 open = "w")
[17:37:35.745]         }
[17:37:35.745]         else {
[17:37:35.745]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:35.745]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:35.745]         }
[17:37:35.745]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:35.745]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:35.745]             base::sink(type = "output", split = FALSE)
[17:37:35.745]             base::close(...future.stdout)
[17:37:35.745]         }, add = TRUE)
[17:37:35.745]     }
[17:37:35.745]     ...future.frame <- base::sys.nframe()
[17:37:35.745]     ...future.conditions <- base::list()
[17:37:35.745]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:35.745]     if (FALSE) {
[17:37:35.745]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:35.745]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:35.745]     }
[17:37:35.745]     ...future.result <- base::tryCatch({
[17:37:35.745]         base::withCallingHandlers({
[17:37:35.745]             ...future.value <- base::withVisible(base::local({
[17:37:35.745]                 withCallingHandlers({
[17:37:35.745]                   {
[17:37:35.745]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.745]                     if (!identical(...future.globals.maxSize.org, 
[17:37:35.745]                       ...future.globals.maxSize)) {
[17:37:35.745]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.745]                       on.exit(options(oopts), add = TRUE)
[17:37:35.745]                     }
[17:37:35.745]                     {
[17:37:35.745]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.745]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:35.745]                         USE.NAMES = FALSE)
[17:37:35.745]                       do.call(mapply, args = args)
[17:37:35.745]                     }
[17:37:35.745]                   }
[17:37:35.745]                 }, immediateCondition = function(cond) {
[17:37:35.745]                   save_rds <- function (object, pathname, ...) 
[17:37:35.745]                   {
[17:37:35.745]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:35.745]                     if (file_test("-f", pathname_tmp)) {
[17:37:35.745]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.745]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:35.745]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.745]                         fi_tmp[["mtime"]])
[17:37:35.745]                     }
[17:37:35.745]                     tryCatch({
[17:37:35.745]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:35.745]                     }, error = function(ex) {
[17:37:35.745]                       msg <- conditionMessage(ex)
[17:37:35.745]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.745]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:35.745]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.745]                         fi_tmp[["mtime"]], msg)
[17:37:35.745]                       ex$message <- msg
[17:37:35.745]                       stop(ex)
[17:37:35.745]                     })
[17:37:35.745]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:35.745]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:35.745]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:35.745]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.745]                       fi <- file.info(pathname)
[17:37:35.745]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:35.745]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.745]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:35.745]                         fi[["size"]], fi[["mtime"]])
[17:37:35.745]                       stop(msg)
[17:37:35.745]                     }
[17:37:35.745]                     invisible(pathname)
[17:37:35.745]                   }
[17:37:35.745]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:35.745]                     rootPath = tempdir()) 
[17:37:35.745]                   {
[17:37:35.745]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:35.745]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:35.745]                       tmpdir = path, fileext = ".rds")
[17:37:35.745]                     save_rds(obj, file)
[17:37:35.745]                   }
[17:37:35.745]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:35.745]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.745]                   {
[17:37:35.745]                     inherits <- base::inherits
[17:37:35.745]                     invokeRestart <- base::invokeRestart
[17:37:35.745]                     is.null <- base::is.null
[17:37:35.745]                     muffled <- FALSE
[17:37:35.745]                     if (inherits(cond, "message")) {
[17:37:35.745]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:35.745]                       if (muffled) 
[17:37:35.745]                         invokeRestart("muffleMessage")
[17:37:35.745]                     }
[17:37:35.745]                     else if (inherits(cond, "warning")) {
[17:37:35.745]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:35.745]                       if (muffled) 
[17:37:35.745]                         invokeRestart("muffleWarning")
[17:37:35.745]                     }
[17:37:35.745]                     else if (inherits(cond, "condition")) {
[17:37:35.745]                       if (!is.null(pattern)) {
[17:37:35.745]                         computeRestarts <- base::computeRestarts
[17:37:35.745]                         grepl <- base::grepl
[17:37:35.745]                         restarts <- computeRestarts(cond)
[17:37:35.745]                         for (restart in restarts) {
[17:37:35.745]                           name <- restart$name
[17:37:35.745]                           if (is.null(name)) 
[17:37:35.745]                             next
[17:37:35.745]                           if (!grepl(pattern, name)) 
[17:37:35.745]                             next
[17:37:35.745]                           invokeRestart(restart)
[17:37:35.745]                           muffled <- TRUE
[17:37:35.745]                           break
[17:37:35.745]                         }
[17:37:35.745]                       }
[17:37:35.745]                     }
[17:37:35.745]                     invisible(muffled)
[17:37:35.745]                   }
[17:37:35.745]                   muffleCondition(cond)
[17:37:35.745]                 })
[17:37:35.745]             }))
[17:37:35.745]             future::FutureResult(value = ...future.value$value, 
[17:37:35.745]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.745]                   ...future.rng), globalenv = if (FALSE) 
[17:37:35.745]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:35.745]                     ...future.globalenv.names))
[17:37:35.745]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:35.745]         }, condition = base::local({
[17:37:35.745]             c <- base::c
[17:37:35.745]             inherits <- base::inherits
[17:37:35.745]             invokeRestart <- base::invokeRestart
[17:37:35.745]             length <- base::length
[17:37:35.745]             list <- base::list
[17:37:35.745]             seq.int <- base::seq.int
[17:37:35.745]             signalCondition <- base::signalCondition
[17:37:35.745]             sys.calls <- base::sys.calls
[17:37:35.745]             `[[` <- base::`[[`
[17:37:35.745]             `+` <- base::`+`
[17:37:35.745]             `<<-` <- base::`<<-`
[17:37:35.745]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:35.745]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:35.745]                   3L)]
[17:37:35.745]             }
[17:37:35.745]             function(cond) {
[17:37:35.745]                 is_error <- inherits(cond, "error")
[17:37:35.745]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:35.745]                   NULL)
[17:37:35.745]                 if (is_error) {
[17:37:35.745]                   sessionInformation <- function() {
[17:37:35.745]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:35.745]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:35.745]                       search = base::search(), system = base::Sys.info())
[17:37:35.745]                   }
[17:37:35.745]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.745]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:35.745]                     cond$call), session = sessionInformation(), 
[17:37:35.745]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:35.745]                   signalCondition(cond)
[17:37:35.745]                 }
[17:37:35.745]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:35.745]                 "immediateCondition"))) {
[17:37:35.745]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:35.745]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.745]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:35.745]                   if (TRUE && !signal) {
[17:37:35.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.745]                     {
[17:37:35.745]                       inherits <- base::inherits
[17:37:35.745]                       invokeRestart <- base::invokeRestart
[17:37:35.745]                       is.null <- base::is.null
[17:37:35.745]                       muffled <- FALSE
[17:37:35.745]                       if (inherits(cond, "message")) {
[17:37:35.745]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.745]                         if (muffled) 
[17:37:35.745]                           invokeRestart("muffleMessage")
[17:37:35.745]                       }
[17:37:35.745]                       else if (inherits(cond, "warning")) {
[17:37:35.745]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.745]                         if (muffled) 
[17:37:35.745]                           invokeRestart("muffleWarning")
[17:37:35.745]                       }
[17:37:35.745]                       else if (inherits(cond, "condition")) {
[17:37:35.745]                         if (!is.null(pattern)) {
[17:37:35.745]                           computeRestarts <- base::computeRestarts
[17:37:35.745]                           grepl <- base::grepl
[17:37:35.745]                           restarts <- computeRestarts(cond)
[17:37:35.745]                           for (restart in restarts) {
[17:37:35.745]                             name <- restart$name
[17:37:35.745]                             if (is.null(name)) 
[17:37:35.745]                               next
[17:37:35.745]                             if (!grepl(pattern, name)) 
[17:37:35.745]                               next
[17:37:35.745]                             invokeRestart(restart)
[17:37:35.745]                             muffled <- TRUE
[17:37:35.745]                             break
[17:37:35.745]                           }
[17:37:35.745]                         }
[17:37:35.745]                       }
[17:37:35.745]                       invisible(muffled)
[17:37:35.745]                     }
[17:37:35.745]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.745]                   }
[17:37:35.745]                 }
[17:37:35.745]                 else {
[17:37:35.745]                   if (TRUE) {
[17:37:35.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.745]                     {
[17:37:35.745]                       inherits <- base::inherits
[17:37:35.745]                       invokeRestart <- base::invokeRestart
[17:37:35.745]                       is.null <- base::is.null
[17:37:35.745]                       muffled <- FALSE
[17:37:35.745]                       if (inherits(cond, "message")) {
[17:37:35.745]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.745]                         if (muffled) 
[17:37:35.745]                           invokeRestart("muffleMessage")
[17:37:35.745]                       }
[17:37:35.745]                       else if (inherits(cond, "warning")) {
[17:37:35.745]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.745]                         if (muffled) 
[17:37:35.745]                           invokeRestart("muffleWarning")
[17:37:35.745]                       }
[17:37:35.745]                       else if (inherits(cond, "condition")) {
[17:37:35.745]                         if (!is.null(pattern)) {
[17:37:35.745]                           computeRestarts <- base::computeRestarts
[17:37:35.745]                           grepl <- base::grepl
[17:37:35.745]                           restarts <- computeRestarts(cond)
[17:37:35.745]                           for (restart in restarts) {
[17:37:35.745]                             name <- restart$name
[17:37:35.745]                             if (is.null(name)) 
[17:37:35.745]                               next
[17:37:35.745]                             if (!grepl(pattern, name)) 
[17:37:35.745]                               next
[17:37:35.745]                             invokeRestart(restart)
[17:37:35.745]                             muffled <- TRUE
[17:37:35.745]                             break
[17:37:35.745]                           }
[17:37:35.745]                         }
[17:37:35.745]                       }
[17:37:35.745]                       invisible(muffled)
[17:37:35.745]                     }
[17:37:35.745]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.745]                   }
[17:37:35.745]                 }
[17:37:35.745]             }
[17:37:35.745]         }))
[17:37:35.745]     }, error = function(ex) {
[17:37:35.745]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:35.745]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.745]                 ...future.rng), started = ...future.startTime, 
[17:37:35.745]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:35.745]             version = "1.8"), class = "FutureResult")
[17:37:35.745]     }, finally = {
[17:37:35.745]         if (!identical(...future.workdir, getwd())) 
[17:37:35.745]             setwd(...future.workdir)
[17:37:35.745]         {
[17:37:35.745]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:35.745]                 ...future.oldOptions$nwarnings <- NULL
[17:37:35.745]             }
[17:37:35.745]             base::options(...future.oldOptions)
[17:37:35.745]             if (.Platform$OS.type == "windows") {
[17:37:35.745]                 old_names <- names(...future.oldEnvVars)
[17:37:35.745]                 envs <- base::Sys.getenv()
[17:37:35.745]                 names <- names(envs)
[17:37:35.745]                 common <- intersect(names, old_names)
[17:37:35.745]                 added <- setdiff(names, old_names)
[17:37:35.745]                 removed <- setdiff(old_names, names)
[17:37:35.745]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:35.745]                   envs[common]]
[17:37:35.745]                 NAMES <- toupper(changed)
[17:37:35.745]                 args <- list()
[17:37:35.745]                 for (kk in seq_along(NAMES)) {
[17:37:35.745]                   name <- changed[[kk]]
[17:37:35.745]                   NAME <- NAMES[[kk]]
[17:37:35.745]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.745]                     next
[17:37:35.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.745]                 }
[17:37:35.745]                 NAMES <- toupper(added)
[17:37:35.745]                 for (kk in seq_along(NAMES)) {
[17:37:35.745]                   name <- added[[kk]]
[17:37:35.745]                   NAME <- NAMES[[kk]]
[17:37:35.745]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.745]                     next
[17:37:35.745]                   args[[name]] <- ""
[17:37:35.745]                 }
[17:37:35.745]                 NAMES <- toupper(removed)
[17:37:35.745]                 for (kk in seq_along(NAMES)) {
[17:37:35.745]                   name <- removed[[kk]]
[17:37:35.745]                   NAME <- NAMES[[kk]]
[17:37:35.745]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.745]                     next
[17:37:35.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.745]                 }
[17:37:35.745]                 if (length(args) > 0) 
[17:37:35.745]                   base::do.call(base::Sys.setenv, args = args)
[17:37:35.745]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:35.745]             }
[17:37:35.745]             else {
[17:37:35.745]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:35.745]             }
[17:37:35.745]             {
[17:37:35.745]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:35.745]                   0L) {
[17:37:35.745]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:35.745]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:35.745]                   base::options(opts)
[17:37:35.745]                 }
[17:37:35.745]                 {
[17:37:35.745]                   {
[17:37:35.745]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:35.745]                     NULL
[17:37:35.745]                   }
[17:37:35.745]                   options(future.plan = NULL)
[17:37:35.745]                   if (is.na(NA_character_)) 
[17:37:35.745]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.745]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:35.745]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:35.745]                     .init = FALSE)
[17:37:35.745]                 }
[17:37:35.745]             }
[17:37:35.745]         }
[17:37:35.745]     })
[17:37:35.745]     if (TRUE) {
[17:37:35.745]         base::sink(type = "output", split = FALSE)
[17:37:35.745]         if (TRUE) {
[17:37:35.745]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:35.745]         }
[17:37:35.745]         else {
[17:37:35.745]             ...future.result["stdout"] <- base::list(NULL)
[17:37:35.745]         }
[17:37:35.745]         base::close(...future.stdout)
[17:37:35.745]         ...future.stdout <- NULL
[17:37:35.745]     }
[17:37:35.745]     ...future.result$conditions <- ...future.conditions
[17:37:35.745]     ...future.result$finished <- base::Sys.time()
[17:37:35.745]     ...future.result
[17:37:35.745] }
[17:37:35.748] assign_globals() ...
[17:37:35.748] List of 5
[17:37:35.748]  $ ...future.FUN            :function (C, k)  
[17:37:35.748]  $ MoreArgs                 : list()
[17:37:35.748]  $ ...future.elements_ii    :List of 2
[17:37:35.748]   ..$ :List of 2
[17:37:35.748]   .. ..$ : chr "A"
[17:37:35.748]   .. ..$ : chr "B"
[17:37:35.748]   ..$ :List of 2
[17:37:35.748]   .. ..$ : int 5
[17:37:35.748]   .. ..$ : int 4
[17:37:35.748]  $ ...future.seeds_ii       : NULL
[17:37:35.748]  $ ...future.globals.maxSize: NULL
[17:37:35.748]  - attr(*, "where")=List of 5
[17:37:35.748]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:35.748]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:35.748]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:35.748]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:35.748]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:35.748]  - attr(*, "resolved")= logi FALSE
[17:37:35.748]  - attr(*, "total_size")= num 3656
[17:37:35.748]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.748]  - attr(*, "already-done")= logi TRUE
[17:37:35.754] - reassign environment for ‘...future.FUN’
[17:37:35.754] - copied ‘...future.FUN’ to environment
[17:37:35.754] - copied ‘MoreArgs’ to environment
[17:37:35.754] - copied ‘...future.elements_ii’ to environment
[17:37:35.754] - copied ‘...future.seeds_ii’ to environment
[17:37:35.755] - copied ‘...future.globals.maxSize’ to environment
[17:37:35.755] assign_globals() ... done
[17:37:35.755] requestCore(): workers = 2
[17:37:35.757] MulticoreFuture started
[17:37:35.758] - Launch lazy future ... done
[17:37:35.758] run() for ‘MulticoreFuture’ ... done
[17:37:35.758] Created future:
[17:37:35.758] plan(): Setting new future strategy stack:
[17:37:35.759] List of future strategies:
[17:37:35.759] 1. sequential:
[17:37:35.759]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:35.759]    - tweaked: FALSE
[17:37:35.759]    - call: NULL
[17:37:35.760] plan(): nbrOfWorkers() = 1
[17:37:35.762] plan(): Setting new future strategy stack:
[17:37:35.762] List of future strategies:
[17:37:35.762] 1. multicore:
[17:37:35.762]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:35.762]    - tweaked: FALSE
[17:37:35.762]    - call: plan(strategy)
[17:37:35.768] plan(): nbrOfWorkers() = 2
[17:37:35.759] MulticoreFuture:
[17:37:35.759] Label: ‘future_.mapply-1’
[17:37:35.759] Expression:
[17:37:35.759] {
[17:37:35.759]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.759]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:35.759]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.759]         on.exit(options(oopts), add = TRUE)
[17:37:35.759]     }
[17:37:35.759]     {
[17:37:35.759]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.759]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:35.759]         do.call(mapply, args = args)
[17:37:35.759]     }
[17:37:35.759] }
[17:37:35.759] Lazy evaluation: FALSE
[17:37:35.759] Asynchronous evaluation: TRUE
[17:37:35.759] Local evaluation: TRUE
[17:37:35.759] Environment: R_GlobalEnv
[17:37:35.759] Capture standard output: TRUE
[17:37:35.759] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:35.759] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:35.759] Packages: <none>
[17:37:35.759] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:35.759] Resolved: TRUE
[17:37:35.759] Value: <not collected>
[17:37:35.759] Conditions captured: <none>
[17:37:35.759] Early signaling: FALSE
[17:37:35.759] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:35.759] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.769] Chunk #1 of 2 ... DONE
[17:37:35.769] Chunk #2 of 2 ...
[17:37:35.769]  - Finding globals in '...' for chunk #2 ...
[17:37:35.769] getGlobalsAndPackages() ...
[17:37:35.769] Searching for globals...
[17:37:35.770] 
[17:37:35.770] Searching for globals ... DONE
[17:37:35.770] - globals: [0] <none>
[17:37:35.770] getGlobalsAndPackages() ... DONE
[17:37:35.771]    + additional globals found: [n=0] 
[17:37:35.771]    + additional namespaces needed: [n=0] 
[17:37:35.771]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:35.771]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:35.771]  - seeds: <none>
[17:37:35.771]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.771] getGlobalsAndPackages() ...
[17:37:35.772] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.772] Resolving globals: FALSE
[17:37:35.773] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:37:35.774] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:35.774] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.774] 
[17:37:35.774] getGlobalsAndPackages() ... DONE
[17:37:35.775] run() for ‘Future’ ...
[17:37:35.775] - state: ‘created’
[17:37:35.775] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:35.780] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.781] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:35.781]   - Field: ‘label’
[17:37:35.781]   - Field: ‘local’
[17:37:35.781]   - Field: ‘owner’
[17:37:35.781]   - Field: ‘envir’
[17:37:35.782]   - Field: ‘workers’
[17:37:35.782]   - Field: ‘packages’
[17:37:35.782]   - Field: ‘gc’
[17:37:35.782]   - Field: ‘job’
[17:37:35.782]   - Field: ‘conditions’
[17:37:35.782]   - Field: ‘expr’
[17:37:35.782]   - Field: ‘uuid’
[17:37:35.783]   - Field: ‘seed’
[17:37:35.783]   - Field: ‘version’
[17:37:35.783]   - Field: ‘result’
[17:37:35.783]   - Field: ‘asynchronous’
[17:37:35.783]   - Field: ‘calls’
[17:37:35.783]   - Field: ‘globals’
[17:37:35.787]   - Field: ‘stdout’
[17:37:35.787]   - Field: ‘earlySignal’
[17:37:35.788]   - Field: ‘lazy’
[17:37:35.788]   - Field: ‘state’
[17:37:35.788] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:35.789] - Launch lazy future ...
[17:37:35.789] Packages needed by the future expression (n = 0): <none>
[17:37:35.790] Packages needed by future strategies (n = 0): <none>
[17:37:35.791] {
[17:37:35.791]     {
[17:37:35.791]         {
[17:37:35.791]             ...future.startTime <- base::Sys.time()
[17:37:35.791]             {
[17:37:35.791]                 {
[17:37:35.791]                   {
[17:37:35.791]                     {
[17:37:35.791]                       base::local({
[17:37:35.791]                         has_future <- base::requireNamespace("future", 
[17:37:35.791]                           quietly = TRUE)
[17:37:35.791]                         if (has_future) {
[17:37:35.791]                           ns <- base::getNamespace("future")
[17:37:35.791]                           version <- ns[[".package"]][["version"]]
[17:37:35.791]                           if (is.null(version)) 
[17:37:35.791]                             version <- utils::packageVersion("future")
[17:37:35.791]                         }
[17:37:35.791]                         else {
[17:37:35.791]                           version <- NULL
[17:37:35.791]                         }
[17:37:35.791]                         if (!has_future || version < "1.8.0") {
[17:37:35.791]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:35.791]                             "", base::R.version$version.string), 
[17:37:35.791]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:35.791]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:35.791]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:35.791]                               "release", "version")], collapse = " "), 
[17:37:35.791]                             hostname = base::Sys.info()[["nodename"]])
[17:37:35.791]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:35.791]                             info)
[17:37:35.791]                           info <- base::paste(info, collapse = "; ")
[17:37:35.791]                           if (!has_future) {
[17:37:35.791]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:35.791]                               info)
[17:37:35.791]                           }
[17:37:35.791]                           else {
[17:37:35.791]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:35.791]                               info, version)
[17:37:35.791]                           }
[17:37:35.791]                           base::stop(msg)
[17:37:35.791]                         }
[17:37:35.791]                       })
[17:37:35.791]                     }
[17:37:35.791]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:35.791]                     base::options(mc.cores = 1L)
[17:37:35.791]                   }
[17:37:35.791]                   ...future.strategy.old <- future::plan("list")
[17:37:35.791]                   options(future.plan = NULL)
[17:37:35.791]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.791]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:35.791]                 }
[17:37:35.791]                 ...future.workdir <- getwd()
[17:37:35.791]             }
[17:37:35.791]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:35.791]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:35.791]         }
[17:37:35.791]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:35.791]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:35.791]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:35.791]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:35.791]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:35.791]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:35.791]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:35.791]             base::names(...future.oldOptions))
[17:37:35.791]     }
[17:37:35.791]     if (FALSE) {
[17:37:35.791]     }
[17:37:35.791]     else {
[17:37:35.791]         if (TRUE) {
[17:37:35.791]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:35.791]                 open = "w")
[17:37:35.791]         }
[17:37:35.791]         else {
[17:37:35.791]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:35.791]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:35.791]         }
[17:37:35.791]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:35.791]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:35.791]             base::sink(type = "output", split = FALSE)
[17:37:35.791]             base::close(...future.stdout)
[17:37:35.791]         }, add = TRUE)
[17:37:35.791]     }
[17:37:35.791]     ...future.frame <- base::sys.nframe()
[17:37:35.791]     ...future.conditions <- base::list()
[17:37:35.791]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:35.791]     if (FALSE) {
[17:37:35.791]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:35.791]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:35.791]     }
[17:37:35.791]     ...future.result <- base::tryCatch({
[17:37:35.791]         base::withCallingHandlers({
[17:37:35.791]             ...future.value <- base::withVisible(base::local({
[17:37:35.791]                 withCallingHandlers({
[17:37:35.791]                   {
[17:37:35.791]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.791]                     if (!identical(...future.globals.maxSize.org, 
[17:37:35.791]                       ...future.globals.maxSize)) {
[17:37:35.791]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.791]                       on.exit(options(oopts), add = TRUE)
[17:37:35.791]                     }
[17:37:35.791]                     {
[17:37:35.791]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.791]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:35.791]                         USE.NAMES = FALSE)
[17:37:35.791]                       do.call(mapply, args = args)
[17:37:35.791]                     }
[17:37:35.791]                   }
[17:37:35.791]                 }, immediateCondition = function(cond) {
[17:37:35.791]                   save_rds <- function (object, pathname, ...) 
[17:37:35.791]                   {
[17:37:35.791]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:35.791]                     if (file_test("-f", pathname_tmp)) {
[17:37:35.791]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.791]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:35.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.791]                         fi_tmp[["mtime"]])
[17:37:35.791]                     }
[17:37:35.791]                     tryCatch({
[17:37:35.791]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:35.791]                     }, error = function(ex) {
[17:37:35.791]                       msg <- conditionMessage(ex)
[17:37:35.791]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.791]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:35.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.791]                         fi_tmp[["mtime"]], msg)
[17:37:35.791]                       ex$message <- msg
[17:37:35.791]                       stop(ex)
[17:37:35.791]                     })
[17:37:35.791]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:35.791]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:35.791]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:35.791]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.791]                       fi <- file.info(pathname)
[17:37:35.791]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:35.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.791]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:35.791]                         fi[["size"]], fi[["mtime"]])
[17:37:35.791]                       stop(msg)
[17:37:35.791]                     }
[17:37:35.791]                     invisible(pathname)
[17:37:35.791]                   }
[17:37:35.791]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:35.791]                     rootPath = tempdir()) 
[17:37:35.791]                   {
[17:37:35.791]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:35.791]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:35.791]                       tmpdir = path, fileext = ".rds")
[17:37:35.791]                     save_rds(obj, file)
[17:37:35.791]                   }
[17:37:35.791]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:35.791]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.791]                   {
[17:37:35.791]                     inherits <- base::inherits
[17:37:35.791]                     invokeRestart <- base::invokeRestart
[17:37:35.791]                     is.null <- base::is.null
[17:37:35.791]                     muffled <- FALSE
[17:37:35.791]                     if (inherits(cond, "message")) {
[17:37:35.791]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:35.791]                       if (muffled) 
[17:37:35.791]                         invokeRestart("muffleMessage")
[17:37:35.791]                     }
[17:37:35.791]                     else if (inherits(cond, "warning")) {
[17:37:35.791]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:35.791]                       if (muffled) 
[17:37:35.791]                         invokeRestart("muffleWarning")
[17:37:35.791]                     }
[17:37:35.791]                     else if (inherits(cond, "condition")) {
[17:37:35.791]                       if (!is.null(pattern)) {
[17:37:35.791]                         computeRestarts <- base::computeRestarts
[17:37:35.791]                         grepl <- base::grepl
[17:37:35.791]                         restarts <- computeRestarts(cond)
[17:37:35.791]                         for (restart in restarts) {
[17:37:35.791]                           name <- restart$name
[17:37:35.791]                           if (is.null(name)) 
[17:37:35.791]                             next
[17:37:35.791]                           if (!grepl(pattern, name)) 
[17:37:35.791]                             next
[17:37:35.791]                           invokeRestart(restart)
[17:37:35.791]                           muffled <- TRUE
[17:37:35.791]                           break
[17:37:35.791]                         }
[17:37:35.791]                       }
[17:37:35.791]                     }
[17:37:35.791]                     invisible(muffled)
[17:37:35.791]                   }
[17:37:35.791]                   muffleCondition(cond)
[17:37:35.791]                 })
[17:37:35.791]             }))
[17:37:35.791]             future::FutureResult(value = ...future.value$value, 
[17:37:35.791]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.791]                   ...future.rng), globalenv = if (FALSE) 
[17:37:35.791]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:35.791]                     ...future.globalenv.names))
[17:37:35.791]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:35.791]         }, condition = base::local({
[17:37:35.791]             c <- base::c
[17:37:35.791]             inherits <- base::inherits
[17:37:35.791]             invokeRestart <- base::invokeRestart
[17:37:35.791]             length <- base::length
[17:37:35.791]             list <- base::list
[17:37:35.791]             seq.int <- base::seq.int
[17:37:35.791]             signalCondition <- base::signalCondition
[17:37:35.791]             sys.calls <- base::sys.calls
[17:37:35.791]             `[[` <- base::`[[`
[17:37:35.791]             `+` <- base::`+`
[17:37:35.791]             `<<-` <- base::`<<-`
[17:37:35.791]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:35.791]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:35.791]                   3L)]
[17:37:35.791]             }
[17:37:35.791]             function(cond) {
[17:37:35.791]                 is_error <- inherits(cond, "error")
[17:37:35.791]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:35.791]                   NULL)
[17:37:35.791]                 if (is_error) {
[17:37:35.791]                   sessionInformation <- function() {
[17:37:35.791]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:35.791]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:35.791]                       search = base::search(), system = base::Sys.info())
[17:37:35.791]                   }
[17:37:35.791]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.791]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:35.791]                     cond$call), session = sessionInformation(), 
[17:37:35.791]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:35.791]                   signalCondition(cond)
[17:37:35.791]                 }
[17:37:35.791]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:35.791]                 "immediateCondition"))) {
[17:37:35.791]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:35.791]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.791]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:35.791]                   if (TRUE && !signal) {
[17:37:35.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.791]                     {
[17:37:35.791]                       inherits <- base::inherits
[17:37:35.791]                       invokeRestart <- base::invokeRestart
[17:37:35.791]                       is.null <- base::is.null
[17:37:35.791]                       muffled <- FALSE
[17:37:35.791]                       if (inherits(cond, "message")) {
[17:37:35.791]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.791]                         if (muffled) 
[17:37:35.791]                           invokeRestart("muffleMessage")
[17:37:35.791]                       }
[17:37:35.791]                       else if (inherits(cond, "warning")) {
[17:37:35.791]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.791]                         if (muffled) 
[17:37:35.791]                           invokeRestart("muffleWarning")
[17:37:35.791]                       }
[17:37:35.791]                       else if (inherits(cond, "condition")) {
[17:37:35.791]                         if (!is.null(pattern)) {
[17:37:35.791]                           computeRestarts <- base::computeRestarts
[17:37:35.791]                           grepl <- base::grepl
[17:37:35.791]                           restarts <- computeRestarts(cond)
[17:37:35.791]                           for (restart in restarts) {
[17:37:35.791]                             name <- restart$name
[17:37:35.791]                             if (is.null(name)) 
[17:37:35.791]                               next
[17:37:35.791]                             if (!grepl(pattern, name)) 
[17:37:35.791]                               next
[17:37:35.791]                             invokeRestart(restart)
[17:37:35.791]                             muffled <- TRUE
[17:37:35.791]                             break
[17:37:35.791]                           }
[17:37:35.791]                         }
[17:37:35.791]                       }
[17:37:35.791]                       invisible(muffled)
[17:37:35.791]                     }
[17:37:35.791]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.791]                   }
[17:37:35.791]                 }
[17:37:35.791]                 else {
[17:37:35.791]                   if (TRUE) {
[17:37:35.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.791]                     {
[17:37:35.791]                       inherits <- base::inherits
[17:37:35.791]                       invokeRestart <- base::invokeRestart
[17:37:35.791]                       is.null <- base::is.null
[17:37:35.791]                       muffled <- FALSE
[17:37:35.791]                       if (inherits(cond, "message")) {
[17:37:35.791]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.791]                         if (muffled) 
[17:37:35.791]                           invokeRestart("muffleMessage")
[17:37:35.791]                       }
[17:37:35.791]                       else if (inherits(cond, "warning")) {
[17:37:35.791]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.791]                         if (muffled) 
[17:37:35.791]                           invokeRestart("muffleWarning")
[17:37:35.791]                       }
[17:37:35.791]                       else if (inherits(cond, "condition")) {
[17:37:35.791]                         if (!is.null(pattern)) {
[17:37:35.791]                           computeRestarts <- base::computeRestarts
[17:37:35.791]                           grepl <- base::grepl
[17:37:35.791]                           restarts <- computeRestarts(cond)
[17:37:35.791]                           for (restart in restarts) {
[17:37:35.791]                             name <- restart$name
[17:37:35.791]                             if (is.null(name)) 
[17:37:35.791]                               next
[17:37:35.791]                             if (!grepl(pattern, name)) 
[17:37:35.791]                               next
[17:37:35.791]                             invokeRestart(restart)
[17:37:35.791]                             muffled <- TRUE
[17:37:35.791]                             break
[17:37:35.791]                           }
[17:37:35.791]                         }
[17:37:35.791]                       }
[17:37:35.791]                       invisible(muffled)
[17:37:35.791]                     }
[17:37:35.791]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.791]                   }
[17:37:35.791]                 }
[17:37:35.791]             }
[17:37:35.791]         }))
[17:37:35.791]     }, error = function(ex) {
[17:37:35.791]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:35.791]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.791]                 ...future.rng), started = ...future.startTime, 
[17:37:35.791]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:35.791]             version = "1.8"), class = "FutureResult")
[17:37:35.791]     }, finally = {
[17:37:35.791]         if (!identical(...future.workdir, getwd())) 
[17:37:35.791]             setwd(...future.workdir)
[17:37:35.791]         {
[17:37:35.791]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:35.791]                 ...future.oldOptions$nwarnings <- NULL
[17:37:35.791]             }
[17:37:35.791]             base::options(...future.oldOptions)
[17:37:35.791]             if (.Platform$OS.type == "windows") {
[17:37:35.791]                 old_names <- names(...future.oldEnvVars)
[17:37:35.791]                 envs <- base::Sys.getenv()
[17:37:35.791]                 names <- names(envs)
[17:37:35.791]                 common <- intersect(names, old_names)
[17:37:35.791]                 added <- setdiff(names, old_names)
[17:37:35.791]                 removed <- setdiff(old_names, names)
[17:37:35.791]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:35.791]                   envs[common]]
[17:37:35.791]                 NAMES <- toupper(changed)
[17:37:35.791]                 args <- list()
[17:37:35.791]                 for (kk in seq_along(NAMES)) {
[17:37:35.791]                   name <- changed[[kk]]
[17:37:35.791]                   NAME <- NAMES[[kk]]
[17:37:35.791]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.791]                     next
[17:37:35.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.791]                 }
[17:37:35.791]                 NAMES <- toupper(added)
[17:37:35.791]                 for (kk in seq_along(NAMES)) {
[17:37:35.791]                   name <- added[[kk]]
[17:37:35.791]                   NAME <- NAMES[[kk]]
[17:37:35.791]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.791]                     next
[17:37:35.791]                   args[[name]] <- ""
[17:37:35.791]                 }
[17:37:35.791]                 NAMES <- toupper(removed)
[17:37:35.791]                 for (kk in seq_along(NAMES)) {
[17:37:35.791]                   name <- removed[[kk]]
[17:37:35.791]                   NAME <- NAMES[[kk]]
[17:37:35.791]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.791]                     next
[17:37:35.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.791]                 }
[17:37:35.791]                 if (length(args) > 0) 
[17:37:35.791]                   base::do.call(base::Sys.setenv, args = args)
[17:37:35.791]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:35.791]             }
[17:37:35.791]             else {
[17:37:35.791]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:35.791]             }
[17:37:35.791]             {
[17:37:35.791]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:35.791]                   0L) {
[17:37:35.791]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:35.791]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:35.791]                   base::options(opts)
[17:37:35.791]                 }
[17:37:35.791]                 {
[17:37:35.791]                   {
[17:37:35.791]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:35.791]                     NULL
[17:37:35.791]                   }
[17:37:35.791]                   options(future.plan = NULL)
[17:37:35.791]                   if (is.na(NA_character_)) 
[17:37:35.791]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.791]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:35.791]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:35.791]                     .init = FALSE)
[17:37:35.791]                 }
[17:37:35.791]             }
[17:37:35.791]         }
[17:37:35.791]     })
[17:37:35.791]     if (TRUE) {
[17:37:35.791]         base::sink(type = "output", split = FALSE)
[17:37:35.791]         if (TRUE) {
[17:37:35.791]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:35.791]         }
[17:37:35.791]         else {
[17:37:35.791]             ...future.result["stdout"] <- base::list(NULL)
[17:37:35.791]         }
[17:37:35.791]         base::close(...future.stdout)
[17:37:35.791]         ...future.stdout <- NULL
[17:37:35.791]     }
[17:37:35.791]     ...future.result$conditions <- ...future.conditions
[17:37:35.791]     ...future.result$finished <- base::Sys.time()
[17:37:35.791]     ...future.result
[17:37:35.791] }
[17:37:35.794] assign_globals() ...
[17:37:35.794] List of 5
[17:37:35.794]  $ ...future.FUN            :function (C, k)  
[17:37:35.794]  $ MoreArgs                 : list()
[17:37:35.794]  $ ...future.elements_ii    :List of 2
[17:37:35.794]   ..$ :List of 3
[17:37:35.794]   .. ..$ : chr "C"
[17:37:35.794]   .. ..$ : chr "D"
[17:37:35.794]   .. ..$ : chr "E"
[17:37:35.794]   ..$ :List of 3
[17:37:35.794]   .. ..$ : int 3
[17:37:35.794]   .. ..$ : int 2
[17:37:35.794]   .. ..$ : int 1
[17:37:35.794]  $ ...future.seeds_ii       : NULL
[17:37:35.794]  $ ...future.globals.maxSize: NULL
[17:37:35.794]  - attr(*, "where")=List of 5
[17:37:35.794]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:35.794]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:35.794]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:35.794]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:35.794]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:35.794]  - attr(*, "resolved")= logi FALSE
[17:37:35.794]  - attr(*, "total_size")= num 3824
[17:37:35.794]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.794]  - attr(*, "already-done")= logi TRUE
[17:37:35.804] - reassign environment for ‘...future.FUN’
[17:37:35.804] - copied ‘...future.FUN’ to environment
[17:37:35.804] - copied ‘MoreArgs’ to environment
[17:37:35.805] - copied ‘...future.elements_ii’ to environment
[17:37:35.805] - copied ‘...future.seeds_ii’ to environment
[17:37:35.805] - copied ‘...future.globals.maxSize’ to environment
[17:37:35.805] assign_globals() ... done
[17:37:35.805] requestCore(): workers = 2
[17:37:35.808] MulticoreFuture started
[17:37:35.808] - Launch lazy future ... done
[17:37:35.808] run() for ‘MulticoreFuture’ ... done
[17:37:35.809] Created future:
[17:37:35.809] plan(): Setting new future strategy stack:
[17:37:35.809] List of future strategies:
[17:37:35.809] 1. sequential:
[17:37:35.809]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:35.809]    - tweaked: FALSE
[17:37:35.809]    - call: NULL
[17:37:35.810] plan(): nbrOfWorkers() = 1
[17:37:35.812] plan(): Setting new future strategy stack:
[17:37:35.812] List of future strategies:
[17:37:35.812] 1. multicore:
[17:37:35.812]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:35.812]    - tweaked: FALSE
[17:37:35.812]    - call: plan(strategy)
[17:37:35.817] plan(): nbrOfWorkers() = 2
[17:37:35.809] MulticoreFuture:
[17:37:35.809] Label: ‘future_.mapply-2’
[17:37:35.809] Expression:
[17:37:35.809] {
[17:37:35.809]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.809]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:35.809]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.809]         on.exit(options(oopts), add = TRUE)
[17:37:35.809]     }
[17:37:35.809]     {
[17:37:35.809]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.809]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:35.809]         do.call(mapply, args = args)
[17:37:35.809]     }
[17:37:35.809] }
[17:37:35.809] Lazy evaluation: FALSE
[17:37:35.809] Asynchronous evaluation: TRUE
[17:37:35.809] Local evaluation: TRUE
[17:37:35.809] Environment: R_GlobalEnv
[17:37:35.809] Capture standard output: TRUE
[17:37:35.809] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:35.809] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:35.809] Packages: <none>
[17:37:35.809] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:35.809] Resolved: TRUE
[17:37:35.809] Value: <not collected>
[17:37:35.809] Conditions captured: <none>
[17:37:35.809] Early signaling: FALSE
[17:37:35.809] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:35.809] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.818] Chunk #2 of 2 ... DONE
[17:37:35.818] Launching 2 futures (chunks) ... DONE
[17:37:35.818] Resolving 2 futures (chunks) ...
[17:37:35.819] resolve() on list ...
[17:37:35.819]  recursive: 0
[17:37:35.819]  length: 2
[17:37:35.819] 
[17:37:35.819] Future #1
[17:37:35.820] result() for MulticoreFuture ...
[17:37:35.820] result() for MulticoreFuture ...
[17:37:35.821] result() for MulticoreFuture ... done
[17:37:35.821] result() for MulticoreFuture ... done
[17:37:35.821] result() for MulticoreFuture ...
[17:37:35.821] result() for MulticoreFuture ... done
[17:37:35.821] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:37:35.821] - nx: 2
[17:37:35.821] - relay: TRUE
[17:37:35.822] - stdout: TRUE
[17:37:35.822] - signal: TRUE
[17:37:35.822] - resignal: FALSE
[17:37:35.822] - force: TRUE
[17:37:35.822] - relayed: [n=2] FALSE, FALSE
[17:37:35.822] - queued futures: [n=2] FALSE, FALSE
[17:37:35.822]  - until=1
[17:37:35.823]  - relaying element #1
[17:37:35.823] result() for MulticoreFuture ...
[17:37:35.823] result() for MulticoreFuture ... done
[17:37:35.823] result() for MulticoreFuture ...
[17:37:35.823] result() for MulticoreFuture ... done
[17:37:35.823] result() for MulticoreFuture ...
[17:37:35.824] result() for MulticoreFuture ... done
[17:37:35.824] result() for MulticoreFuture ...
[17:37:35.824] result() for MulticoreFuture ... done
[17:37:35.824] - relayed: [n=2] TRUE, FALSE
[17:37:35.824] - queued futures: [n=2] TRUE, FALSE
[17:37:35.824] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:37:35.825]  length: 1 (resolved future 1)
[17:37:35.825] Future #2
[17:37:35.825] result() for MulticoreFuture ...
[17:37:35.826] result() for MulticoreFuture ...
[17:37:35.826] result() for MulticoreFuture ... done
[17:37:35.826] result() for MulticoreFuture ... done
[17:37:35.826] result() for MulticoreFuture ...
[17:37:35.827] result() for MulticoreFuture ... done
[17:37:35.827] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:37:35.827] - nx: 2
[17:37:35.827] - relay: TRUE
[17:37:35.827] - stdout: TRUE
[17:37:35.827] - signal: TRUE
[17:37:35.828] - resignal: FALSE
[17:37:35.828] - force: TRUE
[17:37:35.828] - relayed: [n=2] TRUE, FALSE
[17:37:35.828] - queued futures: [n=2] TRUE, FALSE
[17:37:35.828]  - until=2
[17:37:35.828]  - relaying element #2
[17:37:35.829] result() for MulticoreFuture ...
[17:37:35.829] result() for MulticoreFuture ... done
[17:37:35.829] result() for MulticoreFuture ...
[17:37:35.829] result() for MulticoreFuture ... done
[17:37:35.829] result() for MulticoreFuture ...
[17:37:35.829] result() for MulticoreFuture ... done
[17:37:35.829] result() for MulticoreFuture ...
[17:37:35.830] result() for MulticoreFuture ... done
[17:37:35.830] - relayed: [n=2] TRUE, TRUE
[17:37:35.830] - queued futures: [n=2] TRUE, TRUE
[17:37:35.830] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:37:35.830]  length: 0 (resolved future 2)
[17:37:35.830] Relaying remaining futures
[17:37:35.830] signalConditionsASAP(NULL, pos=0) ...
[17:37:35.830] - nx: 2
[17:37:35.830] - relay: TRUE
[17:37:35.831] - stdout: TRUE
[17:37:35.831] - signal: TRUE
[17:37:35.831] - resignal: FALSE
[17:37:35.831] - force: TRUE
[17:37:35.831] - relayed: [n=2] TRUE, TRUE
[17:37:35.831] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:35.831] - relayed: [n=2] TRUE, TRUE
[17:37:35.831] - queued futures: [n=2] TRUE, TRUE
[17:37:35.831] signalConditionsASAP(NULL, pos=0) ... done
[17:37:35.832] resolve() on list ... DONE
[17:37:35.832] result() for MulticoreFuture ...
[17:37:35.832] result() for MulticoreFuture ... done
[17:37:35.832] result() for MulticoreFuture ...
[17:37:35.832] result() for MulticoreFuture ... done
[17:37:35.832] result() for MulticoreFuture ...
[17:37:35.832] result() for MulticoreFuture ... done
[17:37:35.832] result() for MulticoreFuture ...
[17:37:35.833] result() for MulticoreFuture ... done
[17:37:35.833]  - Number of value chunks collected: 2
[17:37:35.833] Resolving 2 futures (chunks) ... DONE
[17:37:35.833] Reducing values from 2 chunks ...
[17:37:35.833]  - Number of values collected after concatenation: 5
[17:37:35.833]  - Number of values expected: 5
[17:37:35.836] Reducing values from 2 chunks ... DONE
[17:37:35.836] future_mapply() ... DONE
[17:37:35.837] future_mapply() ...
[17:37:35.842] Number of chunks: 3
[17:37:35.842] Index remapping (attribute 'ordering'): [n = 5] 5, 1, 4, 3, 2
[17:37:35.842] getGlobalsAndPackagesXApply() ...
[17:37:35.842]  - future.globals: TRUE
[17:37:35.843] getGlobalsAndPackages() ...
[17:37:35.843] Searching for globals...
[17:37:35.845] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:37:35.845] Searching for globals ... DONE
[17:37:35.845] Resolving globals: FALSE
[17:37:35.846] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:37:35.846] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:37:35.846] - globals: [1] ‘FUN’
[17:37:35.846] 
[17:37:35.847] getGlobalsAndPackages() ... DONE
[17:37:35.847]  - globals found/used: [n=1] ‘FUN’
[17:37:35.847]  - needed namespaces: [n=0] 
[17:37:35.847] Finding globals ... DONE
[17:37:35.847] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:35.847] List of 2
[17:37:35.847]  $ ...future.FUN:function (C, k)  
[17:37:35.847]  $ MoreArgs     : NULL
[17:37:35.847]  - attr(*, "where")=List of 2
[17:37:35.847]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:35.847]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:35.847]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.847]  - attr(*, "resolved")= logi FALSE
[17:37:35.847]  - attr(*, "total_size")= num NA
[17:37:35.850] Packages to be attached in all futures: [n=0] 
[17:37:35.850] getGlobalsAndPackagesXApply() ... DONE
[17:37:35.851] Number of futures (= number of chunks): 3
[17:37:35.851] Launching 3 futures (chunks) ...
[17:37:35.851] Chunk #1 of 3 ...
[17:37:35.851]  - Finding globals in '...' for chunk #1 ...
[17:37:35.851] getGlobalsAndPackages() ...
[17:37:35.851] Searching for globals...
[17:37:35.852] 
[17:37:35.852] Searching for globals ... DONE
[17:37:35.852] - globals: [0] <none>
[17:37:35.852] getGlobalsAndPackages() ... DONE
[17:37:35.852]    + additional globals found: [n=0] 
[17:37:35.852]    + additional namespaces needed: [n=0] 
[17:37:35.852]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:35.852]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:37:35.852]  - seeds: <none>
[17:37:35.852]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.853] getGlobalsAndPackages() ...
[17:37:35.853] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.853] Resolving globals: FALSE
[17:37:35.853] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:37:35.854] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:35.854] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.854] 
[17:37:35.854] getGlobalsAndPackages() ... DONE
[17:37:35.854] run() for ‘Future’ ...
[17:37:35.855] - state: ‘created’
[17:37:35.855] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:35.859] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.859] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:35.859]   - Field: ‘label’
[17:37:35.859]   - Field: ‘local’
[17:37:35.859]   - Field: ‘owner’
[17:37:35.859]   - Field: ‘envir’
[17:37:35.860]   - Field: ‘workers’
[17:37:35.860]   - Field: ‘packages’
[17:37:35.860]   - Field: ‘gc’
[17:37:35.860]   - Field: ‘job’
[17:37:35.860]   - Field: ‘conditions’
[17:37:35.860]   - Field: ‘expr’
[17:37:35.860]   - Field: ‘uuid’
[17:37:35.860]   - Field: ‘seed’
[17:37:35.860]   - Field: ‘version’
[17:37:35.861]   - Field: ‘result’
[17:37:35.861]   - Field: ‘asynchronous’
[17:37:35.861]   - Field: ‘calls’
[17:37:35.861]   - Field: ‘globals’
[17:37:35.861]   - Field: ‘stdout’
[17:37:35.861]   - Field: ‘earlySignal’
[17:37:35.861]   - Field: ‘lazy’
[17:37:35.861]   - Field: ‘state’
[17:37:35.861] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:35.861] - Launch lazy future ...
[17:37:35.862] Packages needed by the future expression (n = 0): <none>
[17:37:35.862] Packages needed by future strategies (n = 0): <none>
[17:37:35.862] {
[17:37:35.862]     {
[17:37:35.862]         {
[17:37:35.862]             ...future.startTime <- base::Sys.time()
[17:37:35.862]             {
[17:37:35.862]                 {
[17:37:35.862]                   {
[17:37:35.862]                     {
[17:37:35.862]                       base::local({
[17:37:35.862]                         has_future <- base::requireNamespace("future", 
[17:37:35.862]                           quietly = TRUE)
[17:37:35.862]                         if (has_future) {
[17:37:35.862]                           ns <- base::getNamespace("future")
[17:37:35.862]                           version <- ns[[".package"]][["version"]]
[17:37:35.862]                           if (is.null(version)) 
[17:37:35.862]                             version <- utils::packageVersion("future")
[17:37:35.862]                         }
[17:37:35.862]                         else {
[17:37:35.862]                           version <- NULL
[17:37:35.862]                         }
[17:37:35.862]                         if (!has_future || version < "1.8.0") {
[17:37:35.862]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:35.862]                             "", base::R.version$version.string), 
[17:37:35.862]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:35.862]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:35.862]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:35.862]                               "release", "version")], collapse = " "), 
[17:37:35.862]                             hostname = base::Sys.info()[["nodename"]])
[17:37:35.862]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:35.862]                             info)
[17:37:35.862]                           info <- base::paste(info, collapse = "; ")
[17:37:35.862]                           if (!has_future) {
[17:37:35.862]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:35.862]                               info)
[17:37:35.862]                           }
[17:37:35.862]                           else {
[17:37:35.862]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:35.862]                               info, version)
[17:37:35.862]                           }
[17:37:35.862]                           base::stop(msg)
[17:37:35.862]                         }
[17:37:35.862]                       })
[17:37:35.862]                     }
[17:37:35.862]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:35.862]                     base::options(mc.cores = 1L)
[17:37:35.862]                   }
[17:37:35.862]                   ...future.strategy.old <- future::plan("list")
[17:37:35.862]                   options(future.plan = NULL)
[17:37:35.862]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.862]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:35.862]                 }
[17:37:35.862]                 ...future.workdir <- getwd()
[17:37:35.862]             }
[17:37:35.862]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:35.862]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:35.862]         }
[17:37:35.862]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:35.862]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:37:35.862]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:35.862]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:35.862]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:35.862]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:35.862]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:35.862]             base::names(...future.oldOptions))
[17:37:35.862]     }
[17:37:35.862]     if (FALSE) {
[17:37:35.862]     }
[17:37:35.862]     else {
[17:37:35.862]         if (TRUE) {
[17:37:35.862]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:35.862]                 open = "w")
[17:37:35.862]         }
[17:37:35.862]         else {
[17:37:35.862]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:35.862]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:35.862]         }
[17:37:35.862]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:35.862]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:35.862]             base::sink(type = "output", split = FALSE)
[17:37:35.862]             base::close(...future.stdout)
[17:37:35.862]         }, add = TRUE)
[17:37:35.862]     }
[17:37:35.862]     ...future.frame <- base::sys.nframe()
[17:37:35.862]     ...future.conditions <- base::list()
[17:37:35.862]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:35.862]     if (FALSE) {
[17:37:35.862]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:35.862]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:35.862]     }
[17:37:35.862]     ...future.result <- base::tryCatch({
[17:37:35.862]         base::withCallingHandlers({
[17:37:35.862]             ...future.value <- base::withVisible(base::local({
[17:37:35.862]                 withCallingHandlers({
[17:37:35.862]                   {
[17:37:35.862]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.862]                     if (!identical(...future.globals.maxSize.org, 
[17:37:35.862]                       ...future.globals.maxSize)) {
[17:37:35.862]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.862]                       on.exit(options(oopts), add = TRUE)
[17:37:35.862]                     }
[17:37:35.862]                     {
[17:37:35.862]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.862]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:35.862]                         USE.NAMES = FALSE)
[17:37:35.862]                       do.call(mapply, args = args)
[17:37:35.862]                     }
[17:37:35.862]                   }
[17:37:35.862]                 }, immediateCondition = function(cond) {
[17:37:35.862]                   save_rds <- function (object, pathname, ...) 
[17:37:35.862]                   {
[17:37:35.862]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:35.862]                     if (file_test("-f", pathname_tmp)) {
[17:37:35.862]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.862]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:35.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.862]                         fi_tmp[["mtime"]])
[17:37:35.862]                     }
[17:37:35.862]                     tryCatch({
[17:37:35.862]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:35.862]                     }, error = function(ex) {
[17:37:35.862]                       msg <- conditionMessage(ex)
[17:37:35.862]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.862]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:35.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.862]                         fi_tmp[["mtime"]], msg)
[17:37:35.862]                       ex$message <- msg
[17:37:35.862]                       stop(ex)
[17:37:35.862]                     })
[17:37:35.862]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:35.862]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:35.862]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:35.862]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.862]                       fi <- file.info(pathname)
[17:37:35.862]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:35.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.862]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:35.862]                         fi[["size"]], fi[["mtime"]])
[17:37:35.862]                       stop(msg)
[17:37:35.862]                     }
[17:37:35.862]                     invisible(pathname)
[17:37:35.862]                   }
[17:37:35.862]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:35.862]                     rootPath = tempdir()) 
[17:37:35.862]                   {
[17:37:35.862]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:35.862]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:35.862]                       tmpdir = path, fileext = ".rds")
[17:37:35.862]                     save_rds(obj, file)
[17:37:35.862]                   }
[17:37:35.862]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:35.862]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.862]                   {
[17:37:35.862]                     inherits <- base::inherits
[17:37:35.862]                     invokeRestart <- base::invokeRestart
[17:37:35.862]                     is.null <- base::is.null
[17:37:35.862]                     muffled <- FALSE
[17:37:35.862]                     if (inherits(cond, "message")) {
[17:37:35.862]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:35.862]                       if (muffled) 
[17:37:35.862]                         invokeRestart("muffleMessage")
[17:37:35.862]                     }
[17:37:35.862]                     else if (inherits(cond, "warning")) {
[17:37:35.862]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:35.862]                       if (muffled) 
[17:37:35.862]                         invokeRestart("muffleWarning")
[17:37:35.862]                     }
[17:37:35.862]                     else if (inherits(cond, "condition")) {
[17:37:35.862]                       if (!is.null(pattern)) {
[17:37:35.862]                         computeRestarts <- base::computeRestarts
[17:37:35.862]                         grepl <- base::grepl
[17:37:35.862]                         restarts <- computeRestarts(cond)
[17:37:35.862]                         for (restart in restarts) {
[17:37:35.862]                           name <- restart$name
[17:37:35.862]                           if (is.null(name)) 
[17:37:35.862]                             next
[17:37:35.862]                           if (!grepl(pattern, name)) 
[17:37:35.862]                             next
[17:37:35.862]                           invokeRestart(restart)
[17:37:35.862]                           muffled <- TRUE
[17:37:35.862]                           break
[17:37:35.862]                         }
[17:37:35.862]                       }
[17:37:35.862]                     }
[17:37:35.862]                     invisible(muffled)
[17:37:35.862]                   }
[17:37:35.862]                   muffleCondition(cond)
[17:37:35.862]                 })
[17:37:35.862]             }))
[17:37:35.862]             future::FutureResult(value = ...future.value$value, 
[17:37:35.862]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.862]                   ...future.rng), globalenv = if (FALSE) 
[17:37:35.862]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:35.862]                     ...future.globalenv.names))
[17:37:35.862]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:35.862]         }, condition = base::local({
[17:37:35.862]             c <- base::c
[17:37:35.862]             inherits <- base::inherits
[17:37:35.862]             invokeRestart <- base::invokeRestart
[17:37:35.862]             length <- base::length
[17:37:35.862]             list <- base::list
[17:37:35.862]             seq.int <- base::seq.int
[17:37:35.862]             signalCondition <- base::signalCondition
[17:37:35.862]             sys.calls <- base::sys.calls
[17:37:35.862]             `[[` <- base::`[[`
[17:37:35.862]             `+` <- base::`+`
[17:37:35.862]             `<<-` <- base::`<<-`
[17:37:35.862]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:35.862]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:35.862]                   3L)]
[17:37:35.862]             }
[17:37:35.862]             function(cond) {
[17:37:35.862]                 is_error <- inherits(cond, "error")
[17:37:35.862]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:35.862]                   NULL)
[17:37:35.862]                 if (is_error) {
[17:37:35.862]                   sessionInformation <- function() {
[17:37:35.862]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:35.862]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:35.862]                       search = base::search(), system = base::Sys.info())
[17:37:35.862]                   }
[17:37:35.862]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.862]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:35.862]                     cond$call), session = sessionInformation(), 
[17:37:35.862]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:35.862]                   signalCondition(cond)
[17:37:35.862]                 }
[17:37:35.862]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:35.862]                 "immediateCondition"))) {
[17:37:35.862]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:35.862]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.862]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:35.862]                   if (TRUE && !signal) {
[17:37:35.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.862]                     {
[17:37:35.862]                       inherits <- base::inherits
[17:37:35.862]                       invokeRestart <- base::invokeRestart
[17:37:35.862]                       is.null <- base::is.null
[17:37:35.862]                       muffled <- FALSE
[17:37:35.862]                       if (inherits(cond, "message")) {
[17:37:35.862]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.862]                         if (muffled) 
[17:37:35.862]                           invokeRestart("muffleMessage")
[17:37:35.862]                       }
[17:37:35.862]                       else if (inherits(cond, "warning")) {
[17:37:35.862]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.862]                         if (muffled) 
[17:37:35.862]                           invokeRestart("muffleWarning")
[17:37:35.862]                       }
[17:37:35.862]                       else if (inherits(cond, "condition")) {
[17:37:35.862]                         if (!is.null(pattern)) {
[17:37:35.862]                           computeRestarts <- base::computeRestarts
[17:37:35.862]                           grepl <- base::grepl
[17:37:35.862]                           restarts <- computeRestarts(cond)
[17:37:35.862]                           for (restart in restarts) {
[17:37:35.862]                             name <- restart$name
[17:37:35.862]                             if (is.null(name)) 
[17:37:35.862]                               next
[17:37:35.862]                             if (!grepl(pattern, name)) 
[17:37:35.862]                               next
[17:37:35.862]                             invokeRestart(restart)
[17:37:35.862]                             muffled <- TRUE
[17:37:35.862]                             break
[17:37:35.862]                           }
[17:37:35.862]                         }
[17:37:35.862]                       }
[17:37:35.862]                       invisible(muffled)
[17:37:35.862]                     }
[17:37:35.862]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.862]                   }
[17:37:35.862]                 }
[17:37:35.862]                 else {
[17:37:35.862]                   if (TRUE) {
[17:37:35.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.862]                     {
[17:37:35.862]                       inherits <- base::inherits
[17:37:35.862]                       invokeRestart <- base::invokeRestart
[17:37:35.862]                       is.null <- base::is.null
[17:37:35.862]                       muffled <- FALSE
[17:37:35.862]                       if (inherits(cond, "message")) {
[17:37:35.862]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.862]                         if (muffled) 
[17:37:35.862]                           invokeRestart("muffleMessage")
[17:37:35.862]                       }
[17:37:35.862]                       else if (inherits(cond, "warning")) {
[17:37:35.862]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.862]                         if (muffled) 
[17:37:35.862]                           invokeRestart("muffleWarning")
[17:37:35.862]                       }
[17:37:35.862]                       else if (inherits(cond, "condition")) {
[17:37:35.862]                         if (!is.null(pattern)) {
[17:37:35.862]                           computeRestarts <- base::computeRestarts
[17:37:35.862]                           grepl <- base::grepl
[17:37:35.862]                           restarts <- computeRestarts(cond)
[17:37:35.862]                           for (restart in restarts) {
[17:37:35.862]                             name <- restart$name
[17:37:35.862]                             if (is.null(name)) 
[17:37:35.862]                               next
[17:37:35.862]                             if (!grepl(pattern, name)) 
[17:37:35.862]                               next
[17:37:35.862]                             invokeRestart(restart)
[17:37:35.862]                             muffled <- TRUE
[17:37:35.862]                             break
[17:37:35.862]                           }
[17:37:35.862]                         }
[17:37:35.862]                       }
[17:37:35.862]                       invisible(muffled)
[17:37:35.862]                     }
[17:37:35.862]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.862]                   }
[17:37:35.862]                 }
[17:37:35.862]             }
[17:37:35.862]         }))
[17:37:35.862]     }, error = function(ex) {
[17:37:35.862]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:35.862]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.862]                 ...future.rng), started = ...future.startTime, 
[17:37:35.862]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:35.862]             version = "1.8"), class = "FutureResult")
[17:37:35.862]     }, finally = {
[17:37:35.862]         if (!identical(...future.workdir, getwd())) 
[17:37:35.862]             setwd(...future.workdir)
[17:37:35.862]         {
[17:37:35.862]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:35.862]                 ...future.oldOptions$nwarnings <- NULL
[17:37:35.862]             }
[17:37:35.862]             base::options(...future.oldOptions)
[17:37:35.862]             if (.Platform$OS.type == "windows") {
[17:37:35.862]                 old_names <- names(...future.oldEnvVars)
[17:37:35.862]                 envs <- base::Sys.getenv()
[17:37:35.862]                 names <- names(envs)
[17:37:35.862]                 common <- intersect(names, old_names)
[17:37:35.862]                 added <- setdiff(names, old_names)
[17:37:35.862]                 removed <- setdiff(old_names, names)
[17:37:35.862]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:35.862]                   envs[common]]
[17:37:35.862]                 NAMES <- toupper(changed)
[17:37:35.862]                 args <- list()
[17:37:35.862]                 for (kk in seq_along(NAMES)) {
[17:37:35.862]                   name <- changed[[kk]]
[17:37:35.862]                   NAME <- NAMES[[kk]]
[17:37:35.862]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.862]                     next
[17:37:35.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.862]                 }
[17:37:35.862]                 NAMES <- toupper(added)
[17:37:35.862]                 for (kk in seq_along(NAMES)) {
[17:37:35.862]                   name <- added[[kk]]
[17:37:35.862]                   NAME <- NAMES[[kk]]
[17:37:35.862]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.862]                     next
[17:37:35.862]                   args[[name]] <- ""
[17:37:35.862]                 }
[17:37:35.862]                 NAMES <- toupper(removed)
[17:37:35.862]                 for (kk in seq_along(NAMES)) {
[17:37:35.862]                   name <- removed[[kk]]
[17:37:35.862]                   NAME <- NAMES[[kk]]
[17:37:35.862]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.862]                     next
[17:37:35.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.862]                 }
[17:37:35.862]                 if (length(args) > 0) 
[17:37:35.862]                   base::do.call(base::Sys.setenv, args = args)
[17:37:35.862]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:35.862]             }
[17:37:35.862]             else {
[17:37:35.862]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:35.862]             }
[17:37:35.862]             {
[17:37:35.862]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:35.862]                   0L) {
[17:37:35.862]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:35.862]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:35.862]                   base::options(opts)
[17:37:35.862]                 }
[17:37:35.862]                 {
[17:37:35.862]                   {
[17:37:35.862]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:35.862]                     NULL
[17:37:35.862]                   }
[17:37:35.862]                   options(future.plan = NULL)
[17:37:35.862]                   if (is.na(NA_character_)) 
[17:37:35.862]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.862]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:35.862]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:35.862]                     .init = FALSE)
[17:37:35.862]                 }
[17:37:35.862]             }
[17:37:35.862]         }
[17:37:35.862]     })
[17:37:35.862]     if (TRUE) {
[17:37:35.862]         base::sink(type = "output", split = FALSE)
[17:37:35.862]         if (TRUE) {
[17:37:35.862]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:35.862]         }
[17:37:35.862]         else {
[17:37:35.862]             ...future.result["stdout"] <- base::list(NULL)
[17:37:35.862]         }
[17:37:35.862]         base::close(...future.stdout)
[17:37:35.862]         ...future.stdout <- NULL
[17:37:35.862]     }
[17:37:35.862]     ...future.result$conditions <- ...future.conditions
[17:37:35.862]     ...future.result$finished <- base::Sys.time()
[17:37:35.862]     ...future.result
[17:37:35.862] }
[17:37:35.865] assign_globals() ...
[17:37:35.865] List of 5
[17:37:35.865]  $ ...future.FUN            :function (C, k)  
[17:37:35.865]  $ MoreArgs                 : NULL
[17:37:35.865]  $ ...future.elements_ii    :List of 2
[17:37:35.865]   ..$ :List of 2
[17:37:35.865]   .. ..$ : chr "E"
[17:37:35.865]   .. ..$ : chr "A"
[17:37:35.865]   ..$ :List of 2
[17:37:35.865]   .. ..$ : int 1
[17:37:35.865]   .. ..$ : int 5
[17:37:35.865]  $ ...future.seeds_ii       : NULL
[17:37:35.865]  $ ...future.globals.maxSize: NULL
[17:37:35.865]  - attr(*, "where")=List of 5
[17:37:35.865]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:35.865]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:35.865]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:35.865]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:35.865]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:35.865]  - attr(*, "resolved")= logi FALSE
[17:37:35.865]  - attr(*, "total_size")= num 3656
[17:37:35.865]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.865]  - attr(*, "already-done")= logi TRUE
[17:37:35.873] - reassign environment for ‘...future.FUN’
[17:37:35.873] - copied ‘...future.FUN’ to environment
[17:37:35.873] - copied ‘MoreArgs’ to environment
[17:37:35.873] - copied ‘...future.elements_ii’ to environment
[17:37:35.873] - copied ‘...future.seeds_ii’ to environment
[17:37:35.873] - copied ‘...future.globals.maxSize’ to environment
[17:37:35.874] assign_globals() ... done
[17:37:35.874] requestCore(): workers = 2
[17:37:35.876] MulticoreFuture started
[17:37:35.877] - Launch lazy future ... done
[17:37:35.877] plan(): Setting new future strategy stack:
[17:37:35.877] run() for ‘MulticoreFuture’ ... done
[17:37:35.878] Created future:
[17:37:35.878] List of future strategies:
[17:37:35.878] 1. sequential:
[17:37:35.878]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:35.878]    - tweaked: FALSE
[17:37:35.878]    - call: NULL
[17:37:35.880] plan(): nbrOfWorkers() = 1
[17:37:35.882] plan(): Setting new future strategy stack:
[17:37:35.883] List of future strategies:
[17:37:35.883] 1. multicore:
[17:37:35.883]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:35.883]    - tweaked: FALSE
[17:37:35.883]    - call: plan(strategy)
[17:37:35.888] plan(): nbrOfWorkers() = 2
[17:37:35.878] MulticoreFuture:
[17:37:35.878] Label: ‘future_mapply-1’
[17:37:35.878] Expression:
[17:37:35.878] {
[17:37:35.878]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.878]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:35.878]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.878]         on.exit(options(oopts), add = TRUE)
[17:37:35.878]     }
[17:37:35.878]     {
[17:37:35.878]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.878]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:35.878]         do.call(mapply, args = args)
[17:37:35.878]     }
[17:37:35.878] }
[17:37:35.878] Lazy evaluation: FALSE
[17:37:35.878] Asynchronous evaluation: TRUE
[17:37:35.878] Local evaluation: TRUE
[17:37:35.878] Environment: R_GlobalEnv
[17:37:35.878] Capture standard output: TRUE
[17:37:35.878] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:35.878] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:35.878] Packages: <none>
[17:37:35.878] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:35.878] Resolved: TRUE
[17:37:35.878] Value: <not collected>
[17:37:35.878] Conditions captured: <none>
[17:37:35.878] Early signaling: FALSE
[17:37:35.878] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:35.878] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.890] Chunk #1 of 3 ... DONE
[17:37:35.890] Chunk #2 of 3 ...
[17:37:35.890]  - Finding globals in '...' for chunk #2 ...
[17:37:35.890] getGlobalsAndPackages() ...
[17:37:35.891] Searching for globals...
[17:37:35.891] 
[17:37:35.891] Searching for globals ... DONE
[17:37:35.891] - globals: [0] <none>
[17:37:35.892] getGlobalsAndPackages() ... DONE
[17:37:35.892]    + additional globals found: [n=0] 
[17:37:35.892]    + additional namespaces needed: [n=0] 
[17:37:35.892]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:35.892]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:37:35.892]  - seeds: <none>
[17:37:35.893]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.893] getGlobalsAndPackages() ...
[17:37:35.893] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.893] Resolving globals: FALSE
[17:37:35.894] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:37:35.895] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:35.895] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.895] 
[17:37:35.895] getGlobalsAndPackages() ... DONE
[17:37:35.896] run() for ‘Future’ ...
[17:37:35.896] - state: ‘created’
[17:37:35.896] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:35.901] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.901] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:35.901]   - Field: ‘label’
[17:37:35.902]   - Field: ‘local’
[17:37:35.902]   - Field: ‘owner’
[17:37:35.902]   - Field: ‘envir’
[17:37:35.902]   - Field: ‘workers’
[17:37:35.902]   - Field: ‘packages’
[17:37:35.902]   - Field: ‘gc’
[17:37:35.902]   - Field: ‘job’
[17:37:35.902]   - Field: ‘conditions’
[17:37:35.903]   - Field: ‘expr’
[17:37:35.903]   - Field: ‘uuid’
[17:37:35.903]   - Field: ‘seed’
[17:37:35.903]   - Field: ‘version’
[17:37:35.903]   - Field: ‘result’
[17:37:35.903]   - Field: ‘asynchronous’
[17:37:35.903]   - Field: ‘calls’
[17:37:35.903]   - Field: ‘globals’
[17:37:35.904]   - Field: ‘stdout’
[17:37:35.904]   - Field: ‘earlySignal’
[17:37:35.904]   - Field: ‘lazy’
[17:37:35.904]   - Field: ‘state’
[17:37:35.904] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:35.904] - Launch lazy future ...
[17:37:35.905] Packages needed by the future expression (n = 0): <none>
[17:37:35.905] Packages needed by future strategies (n = 0): <none>
[17:37:35.905] {
[17:37:35.905]     {
[17:37:35.905]         {
[17:37:35.905]             ...future.startTime <- base::Sys.time()
[17:37:35.905]             {
[17:37:35.905]                 {
[17:37:35.905]                   {
[17:37:35.905]                     {
[17:37:35.905]                       base::local({
[17:37:35.905]                         has_future <- base::requireNamespace("future", 
[17:37:35.905]                           quietly = TRUE)
[17:37:35.905]                         if (has_future) {
[17:37:35.905]                           ns <- base::getNamespace("future")
[17:37:35.905]                           version <- ns[[".package"]][["version"]]
[17:37:35.905]                           if (is.null(version)) 
[17:37:35.905]                             version <- utils::packageVersion("future")
[17:37:35.905]                         }
[17:37:35.905]                         else {
[17:37:35.905]                           version <- NULL
[17:37:35.905]                         }
[17:37:35.905]                         if (!has_future || version < "1.8.0") {
[17:37:35.905]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:35.905]                             "", base::R.version$version.string), 
[17:37:35.905]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:35.905]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:35.905]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:35.905]                               "release", "version")], collapse = " "), 
[17:37:35.905]                             hostname = base::Sys.info()[["nodename"]])
[17:37:35.905]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:35.905]                             info)
[17:37:35.905]                           info <- base::paste(info, collapse = "; ")
[17:37:35.905]                           if (!has_future) {
[17:37:35.905]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:35.905]                               info)
[17:37:35.905]                           }
[17:37:35.905]                           else {
[17:37:35.905]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:35.905]                               info, version)
[17:37:35.905]                           }
[17:37:35.905]                           base::stop(msg)
[17:37:35.905]                         }
[17:37:35.905]                       })
[17:37:35.905]                     }
[17:37:35.905]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:35.905]                     base::options(mc.cores = 1L)
[17:37:35.905]                   }
[17:37:35.905]                   ...future.strategy.old <- future::plan("list")
[17:37:35.905]                   options(future.plan = NULL)
[17:37:35.905]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.905]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:35.905]                 }
[17:37:35.905]                 ...future.workdir <- getwd()
[17:37:35.905]             }
[17:37:35.905]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:35.905]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:35.905]         }
[17:37:35.905]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:35.905]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:37:35.905]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:35.905]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:35.905]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:35.905]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:35.905]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:35.905]             base::names(...future.oldOptions))
[17:37:35.905]     }
[17:37:35.905]     if (FALSE) {
[17:37:35.905]     }
[17:37:35.905]     else {
[17:37:35.905]         if (TRUE) {
[17:37:35.905]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:35.905]                 open = "w")
[17:37:35.905]         }
[17:37:35.905]         else {
[17:37:35.905]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:35.905]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:35.905]         }
[17:37:35.905]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:35.905]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:35.905]             base::sink(type = "output", split = FALSE)
[17:37:35.905]             base::close(...future.stdout)
[17:37:35.905]         }, add = TRUE)
[17:37:35.905]     }
[17:37:35.905]     ...future.frame <- base::sys.nframe()
[17:37:35.905]     ...future.conditions <- base::list()
[17:37:35.905]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:35.905]     if (FALSE) {
[17:37:35.905]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:35.905]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:35.905]     }
[17:37:35.905]     ...future.result <- base::tryCatch({
[17:37:35.905]         base::withCallingHandlers({
[17:37:35.905]             ...future.value <- base::withVisible(base::local({
[17:37:35.905]                 withCallingHandlers({
[17:37:35.905]                   {
[17:37:35.905]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.905]                     if (!identical(...future.globals.maxSize.org, 
[17:37:35.905]                       ...future.globals.maxSize)) {
[17:37:35.905]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.905]                       on.exit(options(oopts), add = TRUE)
[17:37:35.905]                     }
[17:37:35.905]                     {
[17:37:35.905]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.905]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:35.905]                         USE.NAMES = FALSE)
[17:37:35.905]                       do.call(mapply, args = args)
[17:37:35.905]                     }
[17:37:35.905]                   }
[17:37:35.905]                 }, immediateCondition = function(cond) {
[17:37:35.905]                   save_rds <- function (object, pathname, ...) 
[17:37:35.905]                   {
[17:37:35.905]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:35.905]                     if (file_test("-f", pathname_tmp)) {
[17:37:35.905]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.905]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:35.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.905]                         fi_tmp[["mtime"]])
[17:37:35.905]                     }
[17:37:35.905]                     tryCatch({
[17:37:35.905]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:35.905]                     }, error = function(ex) {
[17:37:35.905]                       msg <- conditionMessage(ex)
[17:37:35.905]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.905]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:35.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.905]                         fi_tmp[["mtime"]], msg)
[17:37:35.905]                       ex$message <- msg
[17:37:35.905]                       stop(ex)
[17:37:35.905]                     })
[17:37:35.905]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:35.905]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:35.905]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:35.905]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.905]                       fi <- file.info(pathname)
[17:37:35.905]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:35.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.905]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:35.905]                         fi[["size"]], fi[["mtime"]])
[17:37:35.905]                       stop(msg)
[17:37:35.905]                     }
[17:37:35.905]                     invisible(pathname)
[17:37:35.905]                   }
[17:37:35.905]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:35.905]                     rootPath = tempdir()) 
[17:37:35.905]                   {
[17:37:35.905]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:35.905]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:35.905]                       tmpdir = path, fileext = ".rds")
[17:37:35.905]                     save_rds(obj, file)
[17:37:35.905]                   }
[17:37:35.905]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:35.905]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.905]                   {
[17:37:35.905]                     inherits <- base::inherits
[17:37:35.905]                     invokeRestart <- base::invokeRestart
[17:37:35.905]                     is.null <- base::is.null
[17:37:35.905]                     muffled <- FALSE
[17:37:35.905]                     if (inherits(cond, "message")) {
[17:37:35.905]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:35.905]                       if (muffled) 
[17:37:35.905]                         invokeRestart("muffleMessage")
[17:37:35.905]                     }
[17:37:35.905]                     else if (inherits(cond, "warning")) {
[17:37:35.905]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:35.905]                       if (muffled) 
[17:37:35.905]                         invokeRestart("muffleWarning")
[17:37:35.905]                     }
[17:37:35.905]                     else if (inherits(cond, "condition")) {
[17:37:35.905]                       if (!is.null(pattern)) {
[17:37:35.905]                         computeRestarts <- base::computeRestarts
[17:37:35.905]                         grepl <- base::grepl
[17:37:35.905]                         restarts <- computeRestarts(cond)
[17:37:35.905]                         for (restart in restarts) {
[17:37:35.905]                           name <- restart$name
[17:37:35.905]                           if (is.null(name)) 
[17:37:35.905]                             next
[17:37:35.905]                           if (!grepl(pattern, name)) 
[17:37:35.905]                             next
[17:37:35.905]                           invokeRestart(restart)
[17:37:35.905]                           muffled <- TRUE
[17:37:35.905]                           break
[17:37:35.905]                         }
[17:37:35.905]                       }
[17:37:35.905]                     }
[17:37:35.905]                     invisible(muffled)
[17:37:35.905]                   }
[17:37:35.905]                   muffleCondition(cond)
[17:37:35.905]                 })
[17:37:35.905]             }))
[17:37:35.905]             future::FutureResult(value = ...future.value$value, 
[17:37:35.905]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.905]                   ...future.rng), globalenv = if (FALSE) 
[17:37:35.905]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:35.905]                     ...future.globalenv.names))
[17:37:35.905]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:35.905]         }, condition = base::local({
[17:37:35.905]             c <- base::c
[17:37:35.905]             inherits <- base::inherits
[17:37:35.905]             invokeRestart <- base::invokeRestart
[17:37:35.905]             length <- base::length
[17:37:35.905]             list <- base::list
[17:37:35.905]             seq.int <- base::seq.int
[17:37:35.905]             signalCondition <- base::signalCondition
[17:37:35.905]             sys.calls <- base::sys.calls
[17:37:35.905]             `[[` <- base::`[[`
[17:37:35.905]             `+` <- base::`+`
[17:37:35.905]             `<<-` <- base::`<<-`
[17:37:35.905]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:35.905]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:35.905]                   3L)]
[17:37:35.905]             }
[17:37:35.905]             function(cond) {
[17:37:35.905]                 is_error <- inherits(cond, "error")
[17:37:35.905]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:35.905]                   NULL)
[17:37:35.905]                 if (is_error) {
[17:37:35.905]                   sessionInformation <- function() {
[17:37:35.905]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:35.905]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:35.905]                       search = base::search(), system = base::Sys.info())
[17:37:35.905]                   }
[17:37:35.905]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.905]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:35.905]                     cond$call), session = sessionInformation(), 
[17:37:35.905]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:35.905]                   signalCondition(cond)
[17:37:35.905]                 }
[17:37:35.905]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:35.905]                 "immediateCondition"))) {
[17:37:35.905]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:35.905]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.905]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:35.905]                   if (TRUE && !signal) {
[17:37:35.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.905]                     {
[17:37:35.905]                       inherits <- base::inherits
[17:37:35.905]                       invokeRestart <- base::invokeRestart
[17:37:35.905]                       is.null <- base::is.null
[17:37:35.905]                       muffled <- FALSE
[17:37:35.905]                       if (inherits(cond, "message")) {
[17:37:35.905]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.905]                         if (muffled) 
[17:37:35.905]                           invokeRestart("muffleMessage")
[17:37:35.905]                       }
[17:37:35.905]                       else if (inherits(cond, "warning")) {
[17:37:35.905]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.905]                         if (muffled) 
[17:37:35.905]                           invokeRestart("muffleWarning")
[17:37:35.905]                       }
[17:37:35.905]                       else if (inherits(cond, "condition")) {
[17:37:35.905]                         if (!is.null(pattern)) {
[17:37:35.905]                           computeRestarts <- base::computeRestarts
[17:37:35.905]                           grepl <- base::grepl
[17:37:35.905]                           restarts <- computeRestarts(cond)
[17:37:35.905]                           for (restart in restarts) {
[17:37:35.905]                             name <- restart$name
[17:37:35.905]                             if (is.null(name)) 
[17:37:35.905]                               next
[17:37:35.905]                             if (!grepl(pattern, name)) 
[17:37:35.905]                               next
[17:37:35.905]                             invokeRestart(restart)
[17:37:35.905]                             muffled <- TRUE
[17:37:35.905]                             break
[17:37:35.905]                           }
[17:37:35.905]                         }
[17:37:35.905]                       }
[17:37:35.905]                       invisible(muffled)
[17:37:35.905]                     }
[17:37:35.905]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.905]                   }
[17:37:35.905]                 }
[17:37:35.905]                 else {
[17:37:35.905]                   if (TRUE) {
[17:37:35.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.905]                     {
[17:37:35.905]                       inherits <- base::inherits
[17:37:35.905]                       invokeRestart <- base::invokeRestart
[17:37:35.905]                       is.null <- base::is.null
[17:37:35.905]                       muffled <- FALSE
[17:37:35.905]                       if (inherits(cond, "message")) {
[17:37:35.905]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.905]                         if (muffled) 
[17:37:35.905]                           invokeRestart("muffleMessage")
[17:37:35.905]                       }
[17:37:35.905]                       else if (inherits(cond, "warning")) {
[17:37:35.905]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.905]                         if (muffled) 
[17:37:35.905]                           invokeRestart("muffleWarning")
[17:37:35.905]                       }
[17:37:35.905]                       else if (inherits(cond, "condition")) {
[17:37:35.905]                         if (!is.null(pattern)) {
[17:37:35.905]                           computeRestarts <- base::computeRestarts
[17:37:35.905]                           grepl <- base::grepl
[17:37:35.905]                           restarts <- computeRestarts(cond)
[17:37:35.905]                           for (restart in restarts) {
[17:37:35.905]                             name <- restart$name
[17:37:35.905]                             if (is.null(name)) 
[17:37:35.905]                               next
[17:37:35.905]                             if (!grepl(pattern, name)) 
[17:37:35.905]                               next
[17:37:35.905]                             invokeRestart(restart)
[17:37:35.905]                             muffled <- TRUE
[17:37:35.905]                             break
[17:37:35.905]                           }
[17:37:35.905]                         }
[17:37:35.905]                       }
[17:37:35.905]                       invisible(muffled)
[17:37:35.905]                     }
[17:37:35.905]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.905]                   }
[17:37:35.905]                 }
[17:37:35.905]             }
[17:37:35.905]         }))
[17:37:35.905]     }, error = function(ex) {
[17:37:35.905]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:35.905]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.905]                 ...future.rng), started = ...future.startTime, 
[17:37:35.905]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:35.905]             version = "1.8"), class = "FutureResult")
[17:37:35.905]     }, finally = {
[17:37:35.905]         if (!identical(...future.workdir, getwd())) 
[17:37:35.905]             setwd(...future.workdir)
[17:37:35.905]         {
[17:37:35.905]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:35.905]                 ...future.oldOptions$nwarnings <- NULL
[17:37:35.905]             }
[17:37:35.905]             base::options(...future.oldOptions)
[17:37:35.905]             if (.Platform$OS.type == "windows") {
[17:37:35.905]                 old_names <- names(...future.oldEnvVars)
[17:37:35.905]                 envs <- base::Sys.getenv()
[17:37:35.905]                 names <- names(envs)
[17:37:35.905]                 common <- intersect(names, old_names)
[17:37:35.905]                 added <- setdiff(names, old_names)
[17:37:35.905]                 removed <- setdiff(old_names, names)
[17:37:35.905]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:35.905]                   envs[common]]
[17:37:35.905]                 NAMES <- toupper(changed)
[17:37:35.905]                 args <- list()
[17:37:35.905]                 for (kk in seq_along(NAMES)) {
[17:37:35.905]                   name <- changed[[kk]]
[17:37:35.905]                   NAME <- NAMES[[kk]]
[17:37:35.905]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.905]                     next
[17:37:35.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.905]                 }
[17:37:35.905]                 NAMES <- toupper(added)
[17:37:35.905]                 for (kk in seq_along(NAMES)) {
[17:37:35.905]                   name <- added[[kk]]
[17:37:35.905]                   NAME <- NAMES[[kk]]
[17:37:35.905]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.905]                     next
[17:37:35.905]                   args[[name]] <- ""
[17:37:35.905]                 }
[17:37:35.905]                 NAMES <- toupper(removed)
[17:37:35.905]                 for (kk in seq_along(NAMES)) {
[17:37:35.905]                   name <- removed[[kk]]
[17:37:35.905]                   NAME <- NAMES[[kk]]
[17:37:35.905]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.905]                     next
[17:37:35.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.905]                 }
[17:37:35.905]                 if (length(args) > 0) 
[17:37:35.905]                   base::do.call(base::Sys.setenv, args = args)
[17:37:35.905]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:35.905]             }
[17:37:35.905]             else {
[17:37:35.905]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:35.905]             }
[17:37:35.905]             {
[17:37:35.905]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:35.905]                   0L) {
[17:37:35.905]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:35.905]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:35.905]                   base::options(opts)
[17:37:35.905]                 }
[17:37:35.905]                 {
[17:37:35.905]                   {
[17:37:35.905]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:35.905]                     NULL
[17:37:35.905]                   }
[17:37:35.905]                   options(future.plan = NULL)
[17:37:35.905]                   if (is.na(NA_character_)) 
[17:37:35.905]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.905]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:35.905]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:35.905]                     .init = FALSE)
[17:37:35.905]                 }
[17:37:35.905]             }
[17:37:35.905]         }
[17:37:35.905]     })
[17:37:35.905]     if (TRUE) {
[17:37:35.905]         base::sink(type = "output", split = FALSE)
[17:37:35.905]         if (TRUE) {
[17:37:35.905]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:35.905]         }
[17:37:35.905]         else {
[17:37:35.905]             ...future.result["stdout"] <- base::list(NULL)
[17:37:35.905]         }
[17:37:35.905]         base::close(...future.stdout)
[17:37:35.905]         ...future.stdout <- NULL
[17:37:35.905]     }
[17:37:35.905]     ...future.result$conditions <- ...future.conditions
[17:37:35.905]     ...future.result$finished <- base::Sys.time()
[17:37:35.905]     ...future.result
[17:37:35.905] }
[17:37:35.909] assign_globals() ...
[17:37:35.909] List of 5
[17:37:35.909]  $ ...future.FUN            :function (C, k)  
[17:37:35.909]  $ MoreArgs                 : NULL
[17:37:35.909]  $ ...future.elements_ii    :List of 2
[17:37:35.909]   ..$ :List of 1
[17:37:35.909]   .. ..$ : chr "D"
[17:37:35.909]   ..$ :List of 1
[17:37:35.909]   .. ..$ : int 2
[17:37:35.909]  $ ...future.seeds_ii       : NULL
[17:37:35.909]  $ ...future.globals.maxSize: NULL
[17:37:35.909]  - attr(*, "where")=List of 5
[17:37:35.909]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:35.909]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:35.909]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:35.909]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:35.909]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:35.909]  - attr(*, "resolved")= logi FALSE
[17:37:35.909]  - attr(*, "total_size")= num 3488
[17:37:35.909]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.909]  - attr(*, "already-done")= logi TRUE
[17:37:35.916] - reassign environment for ‘...future.FUN’
[17:37:35.916] - copied ‘...future.FUN’ to environment
[17:37:35.916] - copied ‘MoreArgs’ to environment
[17:37:35.917] - copied ‘...future.elements_ii’ to environment
[17:37:35.917] - copied ‘...future.seeds_ii’ to environment
[17:37:35.917] - copied ‘...future.globals.maxSize’ to environment
[17:37:35.917] assign_globals() ... done
[17:37:35.917] requestCore(): workers = 2
[17:37:35.920] MulticoreFuture started
[17:37:35.920] - Launch lazy future ... done
[17:37:35.920] run() for ‘MulticoreFuture’ ... done
[17:37:35.921] Created future:
[17:37:35.921] plan(): Setting new future strategy stack:
[17:37:35.921] List of future strategies:
[17:37:35.921] 1. sequential:
[17:37:35.921]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:35.921]    - tweaked: FALSE
[17:37:35.921]    - call: NULL
[17:37:35.922] plan(): nbrOfWorkers() = 1
[17:37:35.929] plan(): Setting new future strategy stack:
[17:37:35.930] List of future strategies:
[17:37:35.930] 1. multicore:
[17:37:35.930]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:35.930]    - tweaked: FALSE
[17:37:35.930]    - call: plan(strategy)
[17:37:35.921] MulticoreFuture:
[17:37:35.921] Label: ‘future_mapply-2’
[17:37:35.921] Expression:
[17:37:35.921] {
[17:37:35.921]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.921]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:35.921]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.921]         on.exit(options(oopts), add = TRUE)
[17:37:35.921]     }
[17:37:35.921]     {
[17:37:35.921]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.921]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:35.921]         do.call(mapply, args = args)
[17:37:35.921]     }
[17:37:35.921] }
[17:37:35.921] Lazy evaluation: FALSE
[17:37:35.921] Asynchronous evaluation: TRUE
[17:37:35.921] Local evaluation: TRUE
[17:37:35.921] Environment: R_GlobalEnv
[17:37:35.921] Capture standard output: TRUE
[17:37:35.921] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:35.921] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:35.921] Packages: <none>
[17:37:35.921] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:35.921] Resolved: FALSE
[17:37:35.921] Value: <not collected>
[17:37:35.921] Conditions captured: <none>
[17:37:35.921] Early signaling: FALSE
[17:37:35.921] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:35.921] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.936] Chunk #2 of 3 ... DONE
[17:37:35.937] plan(): nbrOfWorkers() = 2
[17:37:35.937] Chunk #3 of 3 ...
[17:37:35.937]  - Finding globals in '...' for chunk #3 ...
[17:37:35.937] getGlobalsAndPackages() ...
[17:37:35.938] Searching for globals...
[17:37:35.939] 
[17:37:35.939] Searching for globals ... DONE
[17:37:35.939] - globals: [0] <none>
[17:37:35.939] getGlobalsAndPackages() ... DONE
[17:37:35.939]    + additional globals found: [n=0] 
[17:37:35.940]    + additional namespaces needed: [n=0] 
[17:37:35.940]  - Finding globals in '...' for chunk #3 ... DONE
[17:37:35.940]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:37:35.940]  - seeds: <none>
[17:37:35.940]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.941] getGlobalsAndPackages() ...
[17:37:35.941] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.941] Resolving globals: FALSE
[17:37:35.943] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:37:35.943] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:35.944] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:35.944] 
[17:37:35.944] getGlobalsAndPackages() ... DONE
[17:37:35.945] run() for ‘Future’ ...
[17:37:35.945] - state: ‘created’
[17:37:35.945] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:35.951] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.951] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:35.951]   - Field: ‘label’
[17:37:35.951]   - Field: ‘local’
[17:37:35.951]   - Field: ‘owner’
[17:37:35.951]   - Field: ‘envir’
[17:37:35.952]   - Field: ‘workers’
[17:37:35.952]   - Field: ‘packages’
[17:37:35.952]   - Field: ‘gc’
[17:37:35.952]   - Field: ‘job’
[17:37:35.952]   - Field: ‘conditions’
[17:37:35.952]   - Field: ‘expr’
[17:37:35.952]   - Field: ‘uuid’
[17:37:35.953]   - Field: ‘seed’
[17:37:35.953]   - Field: ‘version’
[17:37:35.953]   - Field: ‘result’
[17:37:35.953]   - Field: ‘asynchronous’
[17:37:35.953]   - Field: ‘calls’
[17:37:35.953]   - Field: ‘globals’
[17:37:35.953]   - Field: ‘stdout’
[17:37:35.954]   - Field: ‘earlySignal’
[17:37:35.954]   - Field: ‘lazy’
[17:37:35.954]   - Field: ‘state’
[17:37:35.954] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:35.954] - Launch lazy future ...
[17:37:35.955] Packages needed by the future expression (n = 0): <none>
[17:37:35.955] Packages needed by future strategies (n = 0): <none>
[17:37:35.955] {
[17:37:35.955]     {
[17:37:35.955]         {
[17:37:35.955]             ...future.startTime <- base::Sys.time()
[17:37:35.955]             {
[17:37:35.955]                 {
[17:37:35.955]                   {
[17:37:35.955]                     {
[17:37:35.955]                       base::local({
[17:37:35.955]                         has_future <- base::requireNamespace("future", 
[17:37:35.955]                           quietly = TRUE)
[17:37:35.955]                         if (has_future) {
[17:37:35.955]                           ns <- base::getNamespace("future")
[17:37:35.955]                           version <- ns[[".package"]][["version"]]
[17:37:35.955]                           if (is.null(version)) 
[17:37:35.955]                             version <- utils::packageVersion("future")
[17:37:35.955]                         }
[17:37:35.955]                         else {
[17:37:35.955]                           version <- NULL
[17:37:35.955]                         }
[17:37:35.955]                         if (!has_future || version < "1.8.0") {
[17:37:35.955]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:35.955]                             "", base::R.version$version.string), 
[17:37:35.955]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:35.955]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:35.955]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:35.955]                               "release", "version")], collapse = " "), 
[17:37:35.955]                             hostname = base::Sys.info()[["nodename"]])
[17:37:35.955]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:35.955]                             info)
[17:37:35.955]                           info <- base::paste(info, collapse = "; ")
[17:37:35.955]                           if (!has_future) {
[17:37:35.955]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:35.955]                               info)
[17:37:35.955]                           }
[17:37:35.955]                           else {
[17:37:35.955]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:35.955]                               info, version)
[17:37:35.955]                           }
[17:37:35.955]                           base::stop(msg)
[17:37:35.955]                         }
[17:37:35.955]                       })
[17:37:35.955]                     }
[17:37:35.955]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:35.955]                     base::options(mc.cores = 1L)
[17:37:35.955]                   }
[17:37:35.955]                   ...future.strategy.old <- future::plan("list")
[17:37:35.955]                   options(future.plan = NULL)
[17:37:35.955]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.955]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:35.955]                 }
[17:37:35.955]                 ...future.workdir <- getwd()
[17:37:35.955]             }
[17:37:35.955]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:35.955]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:35.955]         }
[17:37:35.955]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:35.955]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:37:35.955]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:35.955]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:35.955]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:35.955]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:35.955]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:35.955]             base::names(...future.oldOptions))
[17:37:35.955]     }
[17:37:35.955]     if (FALSE) {
[17:37:35.955]     }
[17:37:35.955]     else {
[17:37:35.955]         if (TRUE) {
[17:37:35.955]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:35.955]                 open = "w")
[17:37:35.955]         }
[17:37:35.955]         else {
[17:37:35.955]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:35.955]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:35.955]         }
[17:37:35.955]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:35.955]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:35.955]             base::sink(type = "output", split = FALSE)
[17:37:35.955]             base::close(...future.stdout)
[17:37:35.955]         }, add = TRUE)
[17:37:35.955]     }
[17:37:35.955]     ...future.frame <- base::sys.nframe()
[17:37:35.955]     ...future.conditions <- base::list()
[17:37:35.955]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:35.955]     if (FALSE) {
[17:37:35.955]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:35.955]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:35.955]     }
[17:37:35.955]     ...future.result <- base::tryCatch({
[17:37:35.955]         base::withCallingHandlers({
[17:37:35.955]             ...future.value <- base::withVisible(base::local({
[17:37:35.955]                 withCallingHandlers({
[17:37:35.955]                   {
[17:37:35.955]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.955]                     if (!identical(...future.globals.maxSize.org, 
[17:37:35.955]                       ...future.globals.maxSize)) {
[17:37:35.955]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.955]                       on.exit(options(oopts), add = TRUE)
[17:37:35.955]                     }
[17:37:35.955]                     {
[17:37:35.955]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.955]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:35.955]                         USE.NAMES = FALSE)
[17:37:35.955]                       do.call(mapply, args = args)
[17:37:35.955]                     }
[17:37:35.955]                   }
[17:37:35.955]                 }, immediateCondition = function(cond) {
[17:37:35.955]                   save_rds <- function (object, pathname, ...) 
[17:37:35.955]                   {
[17:37:35.955]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:35.955]                     if (file_test("-f", pathname_tmp)) {
[17:37:35.955]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.955]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:35.955]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.955]                         fi_tmp[["mtime"]])
[17:37:35.955]                     }
[17:37:35.955]                     tryCatch({
[17:37:35.955]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:35.955]                     }, error = function(ex) {
[17:37:35.955]                       msg <- conditionMessage(ex)
[17:37:35.955]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.955]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:35.955]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.955]                         fi_tmp[["mtime"]], msg)
[17:37:35.955]                       ex$message <- msg
[17:37:35.955]                       stop(ex)
[17:37:35.955]                     })
[17:37:35.955]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:35.955]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:35.955]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:35.955]                       fi_tmp <- file.info(pathname_tmp)
[17:37:35.955]                       fi <- file.info(pathname)
[17:37:35.955]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:35.955]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:35.955]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:35.955]                         fi[["size"]], fi[["mtime"]])
[17:37:35.955]                       stop(msg)
[17:37:35.955]                     }
[17:37:35.955]                     invisible(pathname)
[17:37:35.955]                   }
[17:37:35.955]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:35.955]                     rootPath = tempdir()) 
[17:37:35.955]                   {
[17:37:35.955]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:35.955]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:35.955]                       tmpdir = path, fileext = ".rds")
[17:37:35.955]                     save_rds(obj, file)
[17:37:35.955]                   }
[17:37:35.955]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:35.955]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.955]                   {
[17:37:35.955]                     inherits <- base::inherits
[17:37:35.955]                     invokeRestart <- base::invokeRestart
[17:37:35.955]                     is.null <- base::is.null
[17:37:35.955]                     muffled <- FALSE
[17:37:35.955]                     if (inherits(cond, "message")) {
[17:37:35.955]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:35.955]                       if (muffled) 
[17:37:35.955]                         invokeRestart("muffleMessage")
[17:37:35.955]                     }
[17:37:35.955]                     else if (inherits(cond, "warning")) {
[17:37:35.955]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:35.955]                       if (muffled) 
[17:37:35.955]                         invokeRestart("muffleWarning")
[17:37:35.955]                     }
[17:37:35.955]                     else if (inherits(cond, "condition")) {
[17:37:35.955]                       if (!is.null(pattern)) {
[17:37:35.955]                         computeRestarts <- base::computeRestarts
[17:37:35.955]                         grepl <- base::grepl
[17:37:35.955]                         restarts <- computeRestarts(cond)
[17:37:35.955]                         for (restart in restarts) {
[17:37:35.955]                           name <- restart$name
[17:37:35.955]                           if (is.null(name)) 
[17:37:35.955]                             next
[17:37:35.955]                           if (!grepl(pattern, name)) 
[17:37:35.955]                             next
[17:37:35.955]                           invokeRestart(restart)
[17:37:35.955]                           muffled <- TRUE
[17:37:35.955]                           break
[17:37:35.955]                         }
[17:37:35.955]                       }
[17:37:35.955]                     }
[17:37:35.955]                     invisible(muffled)
[17:37:35.955]                   }
[17:37:35.955]                   muffleCondition(cond)
[17:37:35.955]                 })
[17:37:35.955]             }))
[17:37:35.955]             future::FutureResult(value = ...future.value$value, 
[17:37:35.955]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.955]                   ...future.rng), globalenv = if (FALSE) 
[17:37:35.955]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:35.955]                     ...future.globalenv.names))
[17:37:35.955]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:35.955]         }, condition = base::local({
[17:37:35.955]             c <- base::c
[17:37:35.955]             inherits <- base::inherits
[17:37:35.955]             invokeRestart <- base::invokeRestart
[17:37:35.955]             length <- base::length
[17:37:35.955]             list <- base::list
[17:37:35.955]             seq.int <- base::seq.int
[17:37:35.955]             signalCondition <- base::signalCondition
[17:37:35.955]             sys.calls <- base::sys.calls
[17:37:35.955]             `[[` <- base::`[[`
[17:37:35.955]             `+` <- base::`+`
[17:37:35.955]             `<<-` <- base::`<<-`
[17:37:35.955]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:35.955]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:35.955]                   3L)]
[17:37:35.955]             }
[17:37:35.955]             function(cond) {
[17:37:35.955]                 is_error <- inherits(cond, "error")
[17:37:35.955]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:35.955]                   NULL)
[17:37:35.955]                 if (is_error) {
[17:37:35.955]                   sessionInformation <- function() {
[17:37:35.955]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:35.955]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:35.955]                       search = base::search(), system = base::Sys.info())
[17:37:35.955]                   }
[17:37:35.955]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.955]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:35.955]                     cond$call), session = sessionInformation(), 
[17:37:35.955]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:35.955]                   signalCondition(cond)
[17:37:35.955]                 }
[17:37:35.955]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:35.955]                 "immediateCondition"))) {
[17:37:35.955]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:35.955]                   ...future.conditions[[length(...future.conditions) + 
[17:37:35.955]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:35.955]                   if (TRUE && !signal) {
[17:37:35.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.955]                     {
[17:37:35.955]                       inherits <- base::inherits
[17:37:35.955]                       invokeRestart <- base::invokeRestart
[17:37:35.955]                       is.null <- base::is.null
[17:37:35.955]                       muffled <- FALSE
[17:37:35.955]                       if (inherits(cond, "message")) {
[17:37:35.955]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.955]                         if (muffled) 
[17:37:35.955]                           invokeRestart("muffleMessage")
[17:37:35.955]                       }
[17:37:35.955]                       else if (inherits(cond, "warning")) {
[17:37:35.955]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.955]                         if (muffled) 
[17:37:35.955]                           invokeRestart("muffleWarning")
[17:37:35.955]                       }
[17:37:35.955]                       else if (inherits(cond, "condition")) {
[17:37:35.955]                         if (!is.null(pattern)) {
[17:37:35.955]                           computeRestarts <- base::computeRestarts
[17:37:35.955]                           grepl <- base::grepl
[17:37:35.955]                           restarts <- computeRestarts(cond)
[17:37:35.955]                           for (restart in restarts) {
[17:37:35.955]                             name <- restart$name
[17:37:35.955]                             if (is.null(name)) 
[17:37:35.955]                               next
[17:37:35.955]                             if (!grepl(pattern, name)) 
[17:37:35.955]                               next
[17:37:35.955]                             invokeRestart(restart)
[17:37:35.955]                             muffled <- TRUE
[17:37:35.955]                             break
[17:37:35.955]                           }
[17:37:35.955]                         }
[17:37:35.955]                       }
[17:37:35.955]                       invisible(muffled)
[17:37:35.955]                     }
[17:37:35.955]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.955]                   }
[17:37:35.955]                 }
[17:37:35.955]                 else {
[17:37:35.955]                   if (TRUE) {
[17:37:35.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:35.955]                     {
[17:37:35.955]                       inherits <- base::inherits
[17:37:35.955]                       invokeRestart <- base::invokeRestart
[17:37:35.955]                       is.null <- base::is.null
[17:37:35.955]                       muffled <- FALSE
[17:37:35.955]                       if (inherits(cond, "message")) {
[17:37:35.955]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:35.955]                         if (muffled) 
[17:37:35.955]                           invokeRestart("muffleMessage")
[17:37:35.955]                       }
[17:37:35.955]                       else if (inherits(cond, "warning")) {
[17:37:35.955]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:35.955]                         if (muffled) 
[17:37:35.955]                           invokeRestart("muffleWarning")
[17:37:35.955]                       }
[17:37:35.955]                       else if (inherits(cond, "condition")) {
[17:37:35.955]                         if (!is.null(pattern)) {
[17:37:35.955]                           computeRestarts <- base::computeRestarts
[17:37:35.955]                           grepl <- base::grepl
[17:37:35.955]                           restarts <- computeRestarts(cond)
[17:37:35.955]                           for (restart in restarts) {
[17:37:35.955]                             name <- restart$name
[17:37:35.955]                             if (is.null(name)) 
[17:37:35.955]                               next
[17:37:35.955]                             if (!grepl(pattern, name)) 
[17:37:35.955]                               next
[17:37:35.955]                             invokeRestart(restart)
[17:37:35.955]                             muffled <- TRUE
[17:37:35.955]                             break
[17:37:35.955]                           }
[17:37:35.955]                         }
[17:37:35.955]                       }
[17:37:35.955]                       invisible(muffled)
[17:37:35.955]                     }
[17:37:35.955]                     muffleCondition(cond, pattern = "^muffle")
[17:37:35.955]                   }
[17:37:35.955]                 }
[17:37:35.955]             }
[17:37:35.955]         }))
[17:37:35.955]     }, error = function(ex) {
[17:37:35.955]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:35.955]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:35.955]                 ...future.rng), started = ...future.startTime, 
[17:37:35.955]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:35.955]             version = "1.8"), class = "FutureResult")
[17:37:35.955]     }, finally = {
[17:37:35.955]         if (!identical(...future.workdir, getwd())) 
[17:37:35.955]             setwd(...future.workdir)
[17:37:35.955]         {
[17:37:35.955]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:35.955]                 ...future.oldOptions$nwarnings <- NULL
[17:37:35.955]             }
[17:37:35.955]             base::options(...future.oldOptions)
[17:37:35.955]             if (.Platform$OS.type == "windows") {
[17:37:35.955]                 old_names <- names(...future.oldEnvVars)
[17:37:35.955]                 envs <- base::Sys.getenv()
[17:37:35.955]                 names <- names(envs)
[17:37:35.955]                 common <- intersect(names, old_names)
[17:37:35.955]                 added <- setdiff(names, old_names)
[17:37:35.955]                 removed <- setdiff(old_names, names)
[17:37:35.955]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:35.955]                   envs[common]]
[17:37:35.955]                 NAMES <- toupper(changed)
[17:37:35.955]                 args <- list()
[17:37:35.955]                 for (kk in seq_along(NAMES)) {
[17:37:35.955]                   name <- changed[[kk]]
[17:37:35.955]                   NAME <- NAMES[[kk]]
[17:37:35.955]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.955]                     next
[17:37:35.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.955]                 }
[17:37:35.955]                 NAMES <- toupper(added)
[17:37:35.955]                 for (kk in seq_along(NAMES)) {
[17:37:35.955]                   name <- added[[kk]]
[17:37:35.955]                   NAME <- NAMES[[kk]]
[17:37:35.955]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.955]                     next
[17:37:35.955]                   args[[name]] <- ""
[17:37:35.955]                 }
[17:37:35.955]                 NAMES <- toupper(removed)
[17:37:35.955]                 for (kk in seq_along(NAMES)) {
[17:37:35.955]                   name <- removed[[kk]]
[17:37:35.955]                   NAME <- NAMES[[kk]]
[17:37:35.955]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:35.955]                     next
[17:37:35.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:35.955]                 }
[17:37:35.955]                 if (length(args) > 0) 
[17:37:35.955]                   base::do.call(base::Sys.setenv, args = args)
[17:37:35.955]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:35.955]             }
[17:37:35.955]             else {
[17:37:35.955]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:35.955]             }
[17:37:35.955]             {
[17:37:35.955]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:35.955]                   0L) {
[17:37:35.955]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:35.955]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:35.955]                   base::options(opts)
[17:37:35.955]                 }
[17:37:35.955]                 {
[17:37:35.955]                   {
[17:37:35.955]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:35.955]                     NULL
[17:37:35.955]                   }
[17:37:35.955]                   options(future.plan = NULL)
[17:37:35.955]                   if (is.na(NA_character_)) 
[17:37:35.955]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:35.955]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:35.955]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:35.955]                     .init = FALSE)
[17:37:35.955]                 }
[17:37:35.955]             }
[17:37:35.955]         }
[17:37:35.955]     })
[17:37:35.955]     if (TRUE) {
[17:37:35.955]         base::sink(type = "output", split = FALSE)
[17:37:35.955]         if (TRUE) {
[17:37:35.955]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:35.955]         }
[17:37:35.955]         else {
[17:37:35.955]             ...future.result["stdout"] <- base::list(NULL)
[17:37:35.955]         }
[17:37:35.955]         base::close(...future.stdout)
[17:37:35.955]         ...future.stdout <- NULL
[17:37:35.955]     }
[17:37:35.955]     ...future.result$conditions <- ...future.conditions
[17:37:35.955]     ...future.result$finished <- base::Sys.time()
[17:37:35.955]     ...future.result
[17:37:35.955] }
[17:37:35.958] assign_globals() ...
[17:37:35.958] List of 5
[17:37:35.958]  $ ...future.FUN            :function (C, k)  
[17:37:35.958]  $ MoreArgs                 : NULL
[17:37:35.958]  $ ...future.elements_ii    :List of 2
[17:37:35.958]   ..$ :List of 2
[17:37:35.958]   .. ..$ : chr "C"
[17:37:35.958]   .. ..$ : chr "B"
[17:37:35.958]   ..$ :List of 2
[17:37:35.958]   .. ..$ : int 3
[17:37:35.958]   .. ..$ : int 4
[17:37:35.958]  $ ...future.seeds_ii       : NULL
[17:37:35.958]  $ ...future.globals.maxSize: NULL
[17:37:35.958]  - attr(*, "where")=List of 5
[17:37:35.958]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:35.958]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:35.958]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:35.958]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:35.958]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:35.958]  - attr(*, "resolved")= logi FALSE
[17:37:35.958]  - attr(*, "total_size")= num 3656
[17:37:35.958]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:35.958]  - attr(*, "already-done")= logi TRUE
[17:37:35.965] - reassign environment for ‘...future.FUN’
[17:37:35.965] - copied ‘...future.FUN’ to environment
[17:37:35.965] - copied ‘MoreArgs’ to environment
[17:37:35.965] - copied ‘...future.elements_ii’ to environment
[17:37:35.966] - copied ‘...future.seeds_ii’ to environment
[17:37:35.966] - copied ‘...future.globals.maxSize’ to environment
[17:37:35.966] assign_globals() ... done
[17:37:35.966] requestCore(): workers = 2
[17:37:35.966] Poll #1 (0): usedCores() = 2, workers = 2
[17:37:35.977] result() for MulticoreFuture ...
[17:37:35.978] result() for MulticoreFuture ...
[17:37:35.978] result() for MulticoreFuture ... done
[17:37:35.978] result() for MulticoreFuture ... done
[17:37:35.978] result() for MulticoreFuture ...
[17:37:35.978] result() for MulticoreFuture ... done
[17:37:35.981] MulticoreFuture started
[17:37:35.982] - Launch lazy future ... done
[17:37:35.982] run() for ‘MulticoreFuture’ ... done
[17:37:35.982] plan(): Setting new future strategy stack:
[17:37:35.982] Created future:
[17:37:35.982] List of future strategies:
[17:37:35.982] 1. sequential:
[17:37:35.982]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:35.982]    - tweaked: FALSE
[17:37:35.982]    - call: NULL
[17:37:35.984] plan(): nbrOfWorkers() = 1
[17:37:35.986] plan(): Setting new future strategy stack:
[17:37:35.986] List of future strategies:
[17:37:35.986] 1. multicore:
[17:37:35.986]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:35.986]    - tweaked: FALSE
[17:37:35.986]    - call: plan(strategy)
[17:37:35.991] plan(): nbrOfWorkers() = 2
[17:37:35.983] MulticoreFuture:
[17:37:35.983] Label: ‘future_mapply-3’
[17:37:35.983] Expression:
[17:37:35.983] {
[17:37:35.983]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:35.983]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:35.983]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:35.983]         on.exit(options(oopts), add = TRUE)
[17:37:35.983]     }
[17:37:35.983]     {
[17:37:35.983]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:35.983]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:35.983]         do.call(mapply, args = args)
[17:37:35.983]     }
[17:37:35.983] }
[17:37:35.983] Lazy evaluation: FALSE
[17:37:35.983] Asynchronous evaluation: TRUE
[17:37:35.983] Local evaluation: TRUE
[17:37:35.983] Environment: R_GlobalEnv
[17:37:35.983] Capture standard output: TRUE
[17:37:35.983] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:35.983] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:35.983] Packages: <none>
[17:37:35.983] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:35.983] Resolved: TRUE
[17:37:35.983] Value: <not collected>
[17:37:35.983] Conditions captured: <none>
[17:37:35.983] Early signaling: FALSE
[17:37:35.983] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:35.983] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:35.992] Chunk #3 of 3 ... DONE
[17:37:35.992] Launching 3 futures (chunks) ... DONE
[17:37:35.992] Resolving 3 futures (chunks) ...
[17:37:35.993] resolve() on list ...
[17:37:35.993]  recursive: 0
[17:37:35.993]  length: 3
[17:37:35.993] 
[17:37:35.993] Future #1
[17:37:35.993] result() for MulticoreFuture ...
[17:37:35.994] result() for MulticoreFuture ... done
[17:37:35.994] result() for MulticoreFuture ...
[17:37:35.994] result() for MulticoreFuture ... done
[17:37:35.994] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:37:35.994] - nx: 3
[17:37:35.994] - relay: TRUE
[17:37:35.994] - stdout: TRUE
[17:37:35.994] - signal: TRUE
[17:37:35.995] - resignal: FALSE
[17:37:35.995] - force: TRUE
[17:37:35.995] - relayed: [n=3] FALSE, FALSE, FALSE
[17:37:35.995] - queued futures: [n=3] FALSE, FALSE, FALSE
[17:37:35.995]  - until=1
[17:37:35.999]  - relaying element #1
[17:37:36.000] result() for MulticoreFuture ...
[17:37:36.000] result() for MulticoreFuture ... done
[17:37:36.001] result() for MulticoreFuture ...
[17:37:36.001] result() for MulticoreFuture ... done
[17:37:36.001] result() for MulticoreFuture ...
[17:37:36.002] result() for MulticoreFuture ... done
[17:37:36.002] result() for MulticoreFuture ...
[17:37:36.002] result() for MulticoreFuture ... done
[17:37:36.002] - relayed: [n=3] TRUE, FALSE, FALSE
[17:37:36.003] - queued futures: [n=3] TRUE, FALSE, FALSE
[17:37:36.003] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:37:36.003]  length: 2 (resolved future 1)
[17:37:36.004] Future #2
[17:37:36.004] result() for MulticoreFuture ...
[17:37:36.005] result() for MulticoreFuture ...
[17:37:36.006] result() for MulticoreFuture ... done
[17:37:36.006] result() for MulticoreFuture ... done
[17:37:36.006] result() for MulticoreFuture ...
[17:37:36.006] result() for MulticoreFuture ... done
[17:37:36.007] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:37:36.007] - nx: 3
[17:37:36.007] - relay: TRUE
[17:37:36.007] - stdout: TRUE
[17:37:36.007] - signal: TRUE
[17:37:36.008] - resignal: FALSE
[17:37:36.008] - force: TRUE
[17:37:36.008] - relayed: [n=3] TRUE, FALSE, FALSE
[17:37:36.008] - queued futures: [n=3] TRUE, FALSE, FALSE
[17:37:36.008]  - until=2
[17:37:36.009]  - relaying element #2
[17:37:36.009] result() for MulticoreFuture ...
[17:37:36.009] result() for MulticoreFuture ... done
[17:37:36.009] result() for MulticoreFuture ...
[17:37:36.010] result() for MulticoreFuture ... done
[17:37:36.010] result() for MulticoreFuture ...
[17:37:36.010] result() for MulticoreFuture ... done
[17:37:36.010] result() for MulticoreFuture ...
[17:37:36.010] result() for MulticoreFuture ... done
[17:37:36.010] - relayed: [n=3] TRUE, TRUE, FALSE
[17:37:36.011] - queued futures: [n=3] TRUE, TRUE, FALSE
[17:37:36.011] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:37:36.011]  length: 1 (resolved future 2)
[17:37:36.011] Future #3
[17:37:36.012] result() for MulticoreFuture ...
[17:37:36.012] result() for MulticoreFuture ...
[17:37:36.012] result() for MulticoreFuture ... done
[17:37:36.012] result() for MulticoreFuture ... done
[17:37:36.013] result() for MulticoreFuture ...
[17:37:36.013] result() for MulticoreFuture ... done
[17:37:36.013] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:37:36.013] - nx: 3
[17:37:36.013] - relay: TRUE
[17:37:36.013] - stdout: TRUE
[17:37:36.013] - signal: TRUE
[17:37:36.013] - resignal: FALSE
[17:37:36.014] - force: TRUE
[17:37:36.014] - relayed: [n=3] TRUE, TRUE, FALSE
[17:37:36.014] - queued futures: [n=3] TRUE, TRUE, FALSE
[17:37:36.014]  - until=3
[17:37:36.014]  - relaying element #3
[17:37:36.014] result() for MulticoreFuture ...
[17:37:36.014] result() for MulticoreFuture ... done
[17:37:36.014] result() for MulticoreFuture ...
[17:37:36.015] result() for MulticoreFuture ... done
[17:37:36.015] result() for MulticoreFuture ...
[17:37:36.015] result() for MulticoreFuture ... done
[17:37:36.015] result() for MulticoreFuture ...
[17:37:36.015] result() for MulticoreFuture ... done
[17:37:36.015] - relayed: [n=3] TRUE, TRUE, TRUE
[17:37:36.015] - queued futures: [n=3] TRUE, TRUE, TRUE
[17:37:36.015] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:37:36.015]  length: 0 (resolved future 3)
[17:37:36.016] Relaying remaining futures
[17:37:36.016] signalConditionsASAP(NULL, pos=0) ...
[17:37:36.016] - nx: 3
[17:37:36.016] - relay: TRUE
[17:37:36.016] - stdout: TRUE
[17:37:36.016] - signal: TRUE
[17:37:36.016] - resignal: FALSE
[17:37:36.016] - force: TRUE
[17:37:36.016] - relayed: [n=3] TRUE, TRUE, TRUE
[17:37:36.016] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[17:37:36.017] - relayed: [n=3] TRUE, TRUE, TRUE
[17:37:36.017] - queued futures: [n=3] TRUE, TRUE, TRUE
[17:37:36.017] signalConditionsASAP(NULL, pos=0) ... done
[17:37:36.017] resolve() on list ... DONE
[17:37:36.017] result() for MulticoreFuture ...
[17:37:36.017] result() for MulticoreFuture ... done
[17:37:36.017] result() for MulticoreFuture ...
[17:37:36.017] result() for MulticoreFuture ... done
[17:37:36.018] result() for MulticoreFuture ...
[17:37:36.018] result() for MulticoreFuture ... done
[17:37:36.018] result() for MulticoreFuture ...
[17:37:36.018] result() for MulticoreFuture ... done
[17:37:36.018] result() for MulticoreFuture ...
[17:37:36.018] result() for MulticoreFuture ... done
[17:37:36.018] result() for MulticoreFuture ...
[17:37:36.018] result() for MulticoreFuture ... done
[17:37:36.018]  - Number of value chunks collected: 3
[17:37:36.018] Resolving 3 futures (chunks) ... DONE
[17:37:36.019] Reducing values from 3 chunks ...
[17:37:36.019]  - Number of values collected after concatenation: 5
[17:37:36.019]  - Number of values expected: 5
[17:37:36.019] Reverse index remapping (attribute 'ordering'): [n = 5] 2, 5, 4, 3, 1
[17:37:36.019] Reducing values from 3 chunks ... DONE
[17:37:36.019] future_mapply() ... DONE
[17:37:36.019] future_mapply() ...
[17:37:36.024] Number of chunks: 2
[17:37:36.024] getGlobalsAndPackagesXApply() ...
[17:37:36.024]  - future.globals: TRUE
[17:37:36.024] getGlobalsAndPackages() ...
[17:37:36.024] Searching for globals...
[17:37:36.026] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:37:36.026] Searching for globals ... DONE
[17:37:36.026] Resolving globals: FALSE
[17:37:36.027] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:37:36.027] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:37:36.027] - globals: [1] ‘FUN’
[17:37:36.027] 
[17:37:36.027] getGlobalsAndPackages() ... DONE
[17:37:36.028]  - globals found/used: [n=1] ‘FUN’
[17:37:36.028]  - needed namespaces: [n=0] 
[17:37:36.028] Finding globals ... DONE
[17:37:36.028] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:36.028] List of 2
[17:37:36.028]  $ ...future.FUN:function (C, k)  
[17:37:36.028]  $ MoreArgs     : list()
[17:37:36.028]  - attr(*, "where")=List of 2
[17:37:36.028]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:36.028]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:36.028]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.028]  - attr(*, "resolved")= logi FALSE
[17:37:36.028]  - attr(*, "total_size")= num NA
[17:37:36.031] Packages to be attached in all futures: [n=0] 
[17:37:36.031] getGlobalsAndPackagesXApply() ... DONE
[17:37:36.031] Number of futures (= number of chunks): 2
[17:37:36.031] Launching 2 futures (chunks) ...
[17:37:36.031] Chunk #1 of 2 ...
[17:37:36.032]  - Finding globals in '...' for chunk #1 ...
[17:37:36.032] getGlobalsAndPackages() ...
[17:37:36.032] Searching for globals...
[17:37:36.032] 
[17:37:36.034] Searching for globals ... DONE
[17:37:36.035] - globals: [0] <none>
[17:37:36.035] getGlobalsAndPackages() ... DONE
[17:37:36.035]    + additional globals found: [n=0] 
[17:37:36.035]    + additional namespaces needed: [n=0] 
[17:37:36.035]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:36.035]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:36.035]  - seeds: <none>
[17:37:36.035]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.036] getGlobalsAndPackages() ...
[17:37:36.036] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.036] Resolving globals: FALSE
[17:37:36.036] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:37:36.037] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:36.037] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.037] 
[17:37:36.037] getGlobalsAndPackages() ... DONE
[17:37:36.038] run() for ‘Future’ ...
[17:37:36.038] - state: ‘created’
[17:37:36.038] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:36.042] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.042] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:36.042]   - Field: ‘label’
[17:37:36.042]   - Field: ‘local’
[17:37:36.042]   - Field: ‘owner’
[17:37:36.043]   - Field: ‘envir’
[17:37:36.043]   - Field: ‘workers’
[17:37:36.043]   - Field: ‘packages’
[17:37:36.043]   - Field: ‘gc’
[17:37:36.043]   - Field: ‘job’
[17:37:36.043]   - Field: ‘conditions’
[17:37:36.043]   - Field: ‘expr’
[17:37:36.043]   - Field: ‘uuid’
[17:37:36.043]   - Field: ‘seed’
[17:37:36.043]   - Field: ‘version’
[17:37:36.044]   - Field: ‘result’
[17:37:36.044]   - Field: ‘asynchronous’
[17:37:36.044]   - Field: ‘calls’
[17:37:36.044]   - Field: ‘globals’
[17:37:36.044]   - Field: ‘stdout’
[17:37:36.044]   - Field: ‘earlySignal’
[17:37:36.044]   - Field: ‘lazy’
[17:37:36.044]   - Field: ‘state’
[17:37:36.044] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:36.044] - Launch lazy future ...
[17:37:36.045] Packages needed by the future expression (n = 0): <none>
[17:37:36.045] Packages needed by future strategies (n = 0): <none>
[17:37:36.045] {
[17:37:36.045]     {
[17:37:36.045]         {
[17:37:36.045]             ...future.startTime <- base::Sys.time()
[17:37:36.045]             {
[17:37:36.045]                 {
[17:37:36.045]                   {
[17:37:36.045]                     {
[17:37:36.045]                       base::local({
[17:37:36.045]                         has_future <- base::requireNamespace("future", 
[17:37:36.045]                           quietly = TRUE)
[17:37:36.045]                         if (has_future) {
[17:37:36.045]                           ns <- base::getNamespace("future")
[17:37:36.045]                           version <- ns[[".package"]][["version"]]
[17:37:36.045]                           if (is.null(version)) 
[17:37:36.045]                             version <- utils::packageVersion("future")
[17:37:36.045]                         }
[17:37:36.045]                         else {
[17:37:36.045]                           version <- NULL
[17:37:36.045]                         }
[17:37:36.045]                         if (!has_future || version < "1.8.0") {
[17:37:36.045]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:36.045]                             "", base::R.version$version.string), 
[17:37:36.045]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:36.045]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:36.045]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:36.045]                               "release", "version")], collapse = " "), 
[17:37:36.045]                             hostname = base::Sys.info()[["nodename"]])
[17:37:36.045]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:36.045]                             info)
[17:37:36.045]                           info <- base::paste(info, collapse = "; ")
[17:37:36.045]                           if (!has_future) {
[17:37:36.045]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:36.045]                               info)
[17:37:36.045]                           }
[17:37:36.045]                           else {
[17:37:36.045]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:36.045]                               info, version)
[17:37:36.045]                           }
[17:37:36.045]                           base::stop(msg)
[17:37:36.045]                         }
[17:37:36.045]                       })
[17:37:36.045]                     }
[17:37:36.045]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:36.045]                     base::options(mc.cores = 1L)
[17:37:36.045]                   }
[17:37:36.045]                   ...future.strategy.old <- future::plan("list")
[17:37:36.045]                   options(future.plan = NULL)
[17:37:36.045]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.045]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:36.045]                 }
[17:37:36.045]                 ...future.workdir <- getwd()
[17:37:36.045]             }
[17:37:36.045]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:36.045]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:36.045]         }
[17:37:36.045]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:36.045]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:36.045]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:36.045]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:36.045]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:36.045]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:36.045]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:36.045]             base::names(...future.oldOptions))
[17:37:36.045]     }
[17:37:36.045]     if (FALSE) {
[17:37:36.045]     }
[17:37:36.045]     else {
[17:37:36.045]         if (TRUE) {
[17:37:36.045]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:36.045]                 open = "w")
[17:37:36.045]         }
[17:37:36.045]         else {
[17:37:36.045]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:36.045]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:36.045]         }
[17:37:36.045]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:36.045]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:36.045]             base::sink(type = "output", split = FALSE)
[17:37:36.045]             base::close(...future.stdout)
[17:37:36.045]         }, add = TRUE)
[17:37:36.045]     }
[17:37:36.045]     ...future.frame <- base::sys.nframe()
[17:37:36.045]     ...future.conditions <- base::list()
[17:37:36.045]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:36.045]     if (FALSE) {
[17:37:36.045]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:36.045]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:36.045]     }
[17:37:36.045]     ...future.result <- base::tryCatch({
[17:37:36.045]         base::withCallingHandlers({
[17:37:36.045]             ...future.value <- base::withVisible(base::local({
[17:37:36.045]                 withCallingHandlers({
[17:37:36.045]                   {
[17:37:36.045]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.045]                     if (!identical(...future.globals.maxSize.org, 
[17:37:36.045]                       ...future.globals.maxSize)) {
[17:37:36.045]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.045]                       on.exit(options(oopts), add = TRUE)
[17:37:36.045]                     }
[17:37:36.045]                     {
[17:37:36.045]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.045]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:36.045]                         USE.NAMES = FALSE)
[17:37:36.045]                       do.call(mapply, args = args)
[17:37:36.045]                     }
[17:37:36.045]                   }
[17:37:36.045]                 }, immediateCondition = function(cond) {
[17:37:36.045]                   save_rds <- function (object, pathname, ...) 
[17:37:36.045]                   {
[17:37:36.045]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:36.045]                     if (file_test("-f", pathname_tmp)) {
[17:37:36.045]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.045]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:36.045]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.045]                         fi_tmp[["mtime"]])
[17:37:36.045]                     }
[17:37:36.045]                     tryCatch({
[17:37:36.045]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:36.045]                     }, error = function(ex) {
[17:37:36.045]                       msg <- conditionMessage(ex)
[17:37:36.045]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.045]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:36.045]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.045]                         fi_tmp[["mtime"]], msg)
[17:37:36.045]                       ex$message <- msg
[17:37:36.045]                       stop(ex)
[17:37:36.045]                     })
[17:37:36.045]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:36.045]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:36.045]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:36.045]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.045]                       fi <- file.info(pathname)
[17:37:36.045]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:36.045]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.045]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:36.045]                         fi[["size"]], fi[["mtime"]])
[17:37:36.045]                       stop(msg)
[17:37:36.045]                     }
[17:37:36.045]                     invisible(pathname)
[17:37:36.045]                   }
[17:37:36.045]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:36.045]                     rootPath = tempdir()) 
[17:37:36.045]                   {
[17:37:36.045]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:36.045]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:36.045]                       tmpdir = path, fileext = ".rds")
[17:37:36.045]                     save_rds(obj, file)
[17:37:36.045]                   }
[17:37:36.045]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:36.045]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.045]                   {
[17:37:36.045]                     inherits <- base::inherits
[17:37:36.045]                     invokeRestart <- base::invokeRestart
[17:37:36.045]                     is.null <- base::is.null
[17:37:36.045]                     muffled <- FALSE
[17:37:36.045]                     if (inherits(cond, "message")) {
[17:37:36.045]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:36.045]                       if (muffled) 
[17:37:36.045]                         invokeRestart("muffleMessage")
[17:37:36.045]                     }
[17:37:36.045]                     else if (inherits(cond, "warning")) {
[17:37:36.045]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:36.045]                       if (muffled) 
[17:37:36.045]                         invokeRestart("muffleWarning")
[17:37:36.045]                     }
[17:37:36.045]                     else if (inherits(cond, "condition")) {
[17:37:36.045]                       if (!is.null(pattern)) {
[17:37:36.045]                         computeRestarts <- base::computeRestarts
[17:37:36.045]                         grepl <- base::grepl
[17:37:36.045]                         restarts <- computeRestarts(cond)
[17:37:36.045]                         for (restart in restarts) {
[17:37:36.045]                           name <- restart$name
[17:37:36.045]                           if (is.null(name)) 
[17:37:36.045]                             next
[17:37:36.045]                           if (!grepl(pattern, name)) 
[17:37:36.045]                             next
[17:37:36.045]                           invokeRestart(restart)
[17:37:36.045]                           muffled <- TRUE
[17:37:36.045]                           break
[17:37:36.045]                         }
[17:37:36.045]                       }
[17:37:36.045]                     }
[17:37:36.045]                     invisible(muffled)
[17:37:36.045]                   }
[17:37:36.045]                   muffleCondition(cond)
[17:37:36.045]                 })
[17:37:36.045]             }))
[17:37:36.045]             future::FutureResult(value = ...future.value$value, 
[17:37:36.045]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.045]                   ...future.rng), globalenv = if (FALSE) 
[17:37:36.045]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:36.045]                     ...future.globalenv.names))
[17:37:36.045]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:36.045]         }, condition = base::local({
[17:37:36.045]             c <- base::c
[17:37:36.045]             inherits <- base::inherits
[17:37:36.045]             invokeRestart <- base::invokeRestart
[17:37:36.045]             length <- base::length
[17:37:36.045]             list <- base::list
[17:37:36.045]             seq.int <- base::seq.int
[17:37:36.045]             signalCondition <- base::signalCondition
[17:37:36.045]             sys.calls <- base::sys.calls
[17:37:36.045]             `[[` <- base::`[[`
[17:37:36.045]             `+` <- base::`+`
[17:37:36.045]             `<<-` <- base::`<<-`
[17:37:36.045]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:36.045]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:36.045]                   3L)]
[17:37:36.045]             }
[17:37:36.045]             function(cond) {
[17:37:36.045]                 is_error <- inherits(cond, "error")
[17:37:36.045]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:36.045]                   NULL)
[17:37:36.045]                 if (is_error) {
[17:37:36.045]                   sessionInformation <- function() {
[17:37:36.045]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:36.045]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:36.045]                       search = base::search(), system = base::Sys.info())
[17:37:36.045]                   }
[17:37:36.045]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.045]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:36.045]                     cond$call), session = sessionInformation(), 
[17:37:36.045]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:36.045]                   signalCondition(cond)
[17:37:36.045]                 }
[17:37:36.045]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:36.045]                 "immediateCondition"))) {
[17:37:36.045]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:36.045]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.045]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:36.045]                   if (TRUE && !signal) {
[17:37:36.045]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.045]                     {
[17:37:36.045]                       inherits <- base::inherits
[17:37:36.045]                       invokeRestart <- base::invokeRestart
[17:37:36.045]                       is.null <- base::is.null
[17:37:36.045]                       muffled <- FALSE
[17:37:36.045]                       if (inherits(cond, "message")) {
[17:37:36.045]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.045]                         if (muffled) 
[17:37:36.045]                           invokeRestart("muffleMessage")
[17:37:36.045]                       }
[17:37:36.045]                       else if (inherits(cond, "warning")) {
[17:37:36.045]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.045]                         if (muffled) 
[17:37:36.045]                           invokeRestart("muffleWarning")
[17:37:36.045]                       }
[17:37:36.045]                       else if (inherits(cond, "condition")) {
[17:37:36.045]                         if (!is.null(pattern)) {
[17:37:36.045]                           computeRestarts <- base::computeRestarts
[17:37:36.045]                           grepl <- base::grepl
[17:37:36.045]                           restarts <- computeRestarts(cond)
[17:37:36.045]                           for (restart in restarts) {
[17:37:36.045]                             name <- restart$name
[17:37:36.045]                             if (is.null(name)) 
[17:37:36.045]                               next
[17:37:36.045]                             if (!grepl(pattern, name)) 
[17:37:36.045]                               next
[17:37:36.045]                             invokeRestart(restart)
[17:37:36.045]                             muffled <- TRUE
[17:37:36.045]                             break
[17:37:36.045]                           }
[17:37:36.045]                         }
[17:37:36.045]                       }
[17:37:36.045]                       invisible(muffled)
[17:37:36.045]                     }
[17:37:36.045]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.045]                   }
[17:37:36.045]                 }
[17:37:36.045]                 else {
[17:37:36.045]                   if (TRUE) {
[17:37:36.045]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.045]                     {
[17:37:36.045]                       inherits <- base::inherits
[17:37:36.045]                       invokeRestart <- base::invokeRestart
[17:37:36.045]                       is.null <- base::is.null
[17:37:36.045]                       muffled <- FALSE
[17:37:36.045]                       if (inherits(cond, "message")) {
[17:37:36.045]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.045]                         if (muffled) 
[17:37:36.045]                           invokeRestart("muffleMessage")
[17:37:36.045]                       }
[17:37:36.045]                       else if (inherits(cond, "warning")) {
[17:37:36.045]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.045]                         if (muffled) 
[17:37:36.045]                           invokeRestart("muffleWarning")
[17:37:36.045]                       }
[17:37:36.045]                       else if (inherits(cond, "condition")) {
[17:37:36.045]                         if (!is.null(pattern)) {
[17:37:36.045]                           computeRestarts <- base::computeRestarts
[17:37:36.045]                           grepl <- base::grepl
[17:37:36.045]                           restarts <- computeRestarts(cond)
[17:37:36.045]                           for (restart in restarts) {
[17:37:36.045]                             name <- restart$name
[17:37:36.045]                             if (is.null(name)) 
[17:37:36.045]                               next
[17:37:36.045]                             if (!grepl(pattern, name)) 
[17:37:36.045]                               next
[17:37:36.045]                             invokeRestart(restart)
[17:37:36.045]                             muffled <- TRUE
[17:37:36.045]                             break
[17:37:36.045]                           }
[17:37:36.045]                         }
[17:37:36.045]                       }
[17:37:36.045]                       invisible(muffled)
[17:37:36.045]                     }
[17:37:36.045]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.045]                   }
[17:37:36.045]                 }
[17:37:36.045]             }
[17:37:36.045]         }))
[17:37:36.045]     }, error = function(ex) {
[17:37:36.045]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:36.045]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.045]                 ...future.rng), started = ...future.startTime, 
[17:37:36.045]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:36.045]             version = "1.8"), class = "FutureResult")
[17:37:36.045]     }, finally = {
[17:37:36.045]         if (!identical(...future.workdir, getwd())) 
[17:37:36.045]             setwd(...future.workdir)
[17:37:36.045]         {
[17:37:36.045]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:36.045]                 ...future.oldOptions$nwarnings <- NULL
[17:37:36.045]             }
[17:37:36.045]             base::options(...future.oldOptions)
[17:37:36.045]             if (.Platform$OS.type == "windows") {
[17:37:36.045]                 old_names <- names(...future.oldEnvVars)
[17:37:36.045]                 envs <- base::Sys.getenv()
[17:37:36.045]                 names <- names(envs)
[17:37:36.045]                 common <- intersect(names, old_names)
[17:37:36.045]                 added <- setdiff(names, old_names)
[17:37:36.045]                 removed <- setdiff(old_names, names)
[17:37:36.045]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:36.045]                   envs[common]]
[17:37:36.045]                 NAMES <- toupper(changed)
[17:37:36.045]                 args <- list()
[17:37:36.045]                 for (kk in seq_along(NAMES)) {
[17:37:36.045]                   name <- changed[[kk]]
[17:37:36.045]                   NAME <- NAMES[[kk]]
[17:37:36.045]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.045]                     next
[17:37:36.045]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.045]                 }
[17:37:36.045]                 NAMES <- toupper(added)
[17:37:36.045]                 for (kk in seq_along(NAMES)) {
[17:37:36.045]                   name <- added[[kk]]
[17:37:36.045]                   NAME <- NAMES[[kk]]
[17:37:36.045]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.045]                     next
[17:37:36.045]                   args[[name]] <- ""
[17:37:36.045]                 }
[17:37:36.045]                 NAMES <- toupper(removed)
[17:37:36.045]                 for (kk in seq_along(NAMES)) {
[17:37:36.045]                   name <- removed[[kk]]
[17:37:36.045]                   NAME <- NAMES[[kk]]
[17:37:36.045]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.045]                     next
[17:37:36.045]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.045]                 }
[17:37:36.045]                 if (length(args) > 0) 
[17:37:36.045]                   base::do.call(base::Sys.setenv, args = args)
[17:37:36.045]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:36.045]             }
[17:37:36.045]             else {
[17:37:36.045]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:36.045]             }
[17:37:36.045]             {
[17:37:36.045]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:36.045]                   0L) {
[17:37:36.045]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:36.045]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:36.045]                   base::options(opts)
[17:37:36.045]                 }
[17:37:36.045]                 {
[17:37:36.045]                   {
[17:37:36.045]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:36.045]                     NULL
[17:37:36.045]                   }
[17:37:36.045]                   options(future.plan = NULL)
[17:37:36.045]                   if (is.na(NA_character_)) 
[17:37:36.045]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.045]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:36.045]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:36.045]                     .init = FALSE)
[17:37:36.045]                 }
[17:37:36.045]             }
[17:37:36.045]         }
[17:37:36.045]     })
[17:37:36.045]     if (TRUE) {
[17:37:36.045]         base::sink(type = "output", split = FALSE)
[17:37:36.045]         if (TRUE) {
[17:37:36.045]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:36.045]         }
[17:37:36.045]         else {
[17:37:36.045]             ...future.result["stdout"] <- base::list(NULL)
[17:37:36.045]         }
[17:37:36.045]         base::close(...future.stdout)
[17:37:36.045]         ...future.stdout <- NULL
[17:37:36.045]     }
[17:37:36.045]     ...future.result$conditions <- ...future.conditions
[17:37:36.045]     ...future.result$finished <- base::Sys.time()
[17:37:36.045]     ...future.result
[17:37:36.045] }
[17:37:36.048] assign_globals() ...
[17:37:36.048] List of 5
[17:37:36.048]  $ ...future.FUN            :function (C, k)  
[17:37:36.048]  $ MoreArgs                 : list()
[17:37:36.048]  $ ...future.elements_ii    :List of 2
[17:37:36.048]   ..$ :List of 2
[17:37:36.048]   .. ..$ : chr "A"
[17:37:36.048]   .. ..$ : chr "B"
[17:37:36.048]   ..$ :List of 2
[17:37:36.048]   .. ..$ : int 5
[17:37:36.048]   .. ..$ : int 4
[17:37:36.048]  $ ...future.seeds_ii       : NULL
[17:37:36.048]  $ ...future.globals.maxSize: NULL
[17:37:36.048]  - attr(*, "where")=List of 5
[17:37:36.048]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:36.048]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:36.048]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:36.048]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:36.048]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:36.048]  - attr(*, "resolved")= logi FALSE
[17:37:36.048]  - attr(*, "total_size")= num 3656
[17:37:36.048]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.048]  - attr(*, "already-done")= logi TRUE
[17:37:36.053] - reassign environment for ‘...future.FUN’
[17:37:36.053] - copied ‘...future.FUN’ to environment
[17:37:36.054] - copied ‘MoreArgs’ to environment
[17:37:36.054] - copied ‘...future.elements_ii’ to environment
[17:37:36.054] - copied ‘...future.seeds_ii’ to environment
[17:37:36.054] - copied ‘...future.globals.maxSize’ to environment
[17:37:36.054] assign_globals() ... done
[17:37:36.054] requestCore(): workers = 2
[17:37:36.056] MulticoreFuture started
[17:37:36.057] - Launch lazy future ... done
[17:37:36.057] run() for ‘MulticoreFuture’ ... done
[17:37:36.057] Created future:
[17:37:36.057] plan(): Setting new future strategy stack:
[17:37:36.058] List of future strategies:
[17:37:36.058] 1. sequential:
[17:37:36.058]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:36.058]    - tweaked: FALSE
[17:37:36.058]    - call: NULL
[17:37:36.059] plan(): nbrOfWorkers() = 1
[17:37:36.061] plan(): Setting new future strategy stack:
[17:37:36.061] List of future strategies:
[17:37:36.061] 1. multicore:
[17:37:36.061]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:36.061]    - tweaked: FALSE
[17:37:36.061]    - call: plan(strategy)
[17:37:36.066] plan(): nbrOfWorkers() = 2
[17:37:36.057] MulticoreFuture:
[17:37:36.057] Label: ‘future_.mapply-1’
[17:37:36.057] Expression:
[17:37:36.057] {
[17:37:36.057]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.057]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:36.057]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.057]         on.exit(options(oopts), add = TRUE)
[17:37:36.057]     }
[17:37:36.057]     {
[17:37:36.057]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.057]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:36.057]         do.call(mapply, args = args)
[17:37:36.057]     }
[17:37:36.057] }
[17:37:36.057] Lazy evaluation: FALSE
[17:37:36.057] Asynchronous evaluation: TRUE
[17:37:36.057] Local evaluation: TRUE
[17:37:36.057] Environment: R_GlobalEnv
[17:37:36.057] Capture standard output: TRUE
[17:37:36.057] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:36.057] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:36.057] Packages: <none>
[17:37:36.057] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:36.057] Resolved: TRUE
[17:37:36.057] Value: <not collected>
[17:37:36.057] Conditions captured: <none>
[17:37:36.057] Early signaling: FALSE
[17:37:36.057] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:36.057] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.067] Chunk #1 of 2 ... DONE
[17:37:36.068] Chunk #2 of 2 ...
[17:37:36.068]  - Finding globals in '...' for chunk #2 ...
[17:37:36.068] getGlobalsAndPackages() ...
[17:37:36.068] Searching for globals...
[17:37:36.069] 
[17:37:36.069] Searching for globals ... DONE
[17:37:36.069] - globals: [0] <none>
[17:37:36.069] getGlobalsAndPackages() ... DONE
[17:37:36.069]    + additional globals found: [n=0] 
[17:37:36.069]    + additional namespaces needed: [n=0] 
[17:37:36.069]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:36.070]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:36.070]  - seeds: <none>
[17:37:36.070]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.070] getGlobalsAndPackages() ...
[17:37:36.070] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.070] Resolving globals: FALSE
[17:37:36.071] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:37:36.072] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:36.072] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.073] 
[17:37:36.073] getGlobalsAndPackages() ... DONE
[17:37:36.073] run() for ‘Future’ ...
[17:37:36.073] - state: ‘created’
[17:37:36.074] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:36.083] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.084] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:36.084]   - Field: ‘label’
[17:37:36.084]   - Field: ‘local’
[17:37:36.085]   - Field: ‘owner’
[17:37:36.085]   - Field: ‘envir’
[17:37:36.085]   - Field: ‘workers’
[17:37:36.086]   - Field: ‘packages’
[17:37:36.086]   - Field: ‘gc’
[17:37:36.086]   - Field: ‘job’
[17:37:36.086]   - Field: ‘conditions’
[17:37:36.087]   - Field: ‘expr’
[17:37:36.087]   - Field: ‘uuid’
[17:37:36.087]   - Field: ‘seed’
[17:37:36.087]   - Field: ‘version’
[17:37:36.088]   - Field: ‘result’
[17:37:36.088]   - Field: ‘asynchronous’
[17:37:36.088]   - Field: ‘calls’
[17:37:36.088]   - Field: ‘globals’
[17:37:36.088]   - Field: ‘stdout’
[17:37:36.089]   - Field: ‘earlySignal’
[17:37:36.089]   - Field: ‘lazy’
[17:37:36.089]   - Field: ‘state’
[17:37:36.089] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:36.089] - Launch lazy future ...
[17:37:36.090] Packages needed by the future expression (n = 0): <none>
[17:37:36.090] Packages needed by future strategies (n = 0): <none>
[17:37:36.091] {
[17:37:36.091]     {
[17:37:36.091]         {
[17:37:36.091]             ...future.startTime <- base::Sys.time()
[17:37:36.091]             {
[17:37:36.091]                 {
[17:37:36.091]                   {
[17:37:36.091]                     {
[17:37:36.091]                       base::local({
[17:37:36.091]                         has_future <- base::requireNamespace("future", 
[17:37:36.091]                           quietly = TRUE)
[17:37:36.091]                         if (has_future) {
[17:37:36.091]                           ns <- base::getNamespace("future")
[17:37:36.091]                           version <- ns[[".package"]][["version"]]
[17:37:36.091]                           if (is.null(version)) 
[17:37:36.091]                             version <- utils::packageVersion("future")
[17:37:36.091]                         }
[17:37:36.091]                         else {
[17:37:36.091]                           version <- NULL
[17:37:36.091]                         }
[17:37:36.091]                         if (!has_future || version < "1.8.0") {
[17:37:36.091]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:36.091]                             "", base::R.version$version.string), 
[17:37:36.091]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:36.091]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:36.091]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:36.091]                               "release", "version")], collapse = " "), 
[17:37:36.091]                             hostname = base::Sys.info()[["nodename"]])
[17:37:36.091]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:36.091]                             info)
[17:37:36.091]                           info <- base::paste(info, collapse = "; ")
[17:37:36.091]                           if (!has_future) {
[17:37:36.091]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:36.091]                               info)
[17:37:36.091]                           }
[17:37:36.091]                           else {
[17:37:36.091]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:36.091]                               info, version)
[17:37:36.091]                           }
[17:37:36.091]                           base::stop(msg)
[17:37:36.091]                         }
[17:37:36.091]                       })
[17:37:36.091]                     }
[17:37:36.091]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:36.091]                     base::options(mc.cores = 1L)
[17:37:36.091]                   }
[17:37:36.091]                   ...future.strategy.old <- future::plan("list")
[17:37:36.091]                   options(future.plan = NULL)
[17:37:36.091]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.091]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:36.091]                 }
[17:37:36.091]                 ...future.workdir <- getwd()
[17:37:36.091]             }
[17:37:36.091]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:36.091]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:36.091]         }
[17:37:36.091]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:36.091]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:36.091]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:36.091]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:36.091]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:36.091]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:36.091]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:36.091]             base::names(...future.oldOptions))
[17:37:36.091]     }
[17:37:36.091]     if (FALSE) {
[17:37:36.091]     }
[17:37:36.091]     else {
[17:37:36.091]         if (TRUE) {
[17:37:36.091]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:36.091]                 open = "w")
[17:37:36.091]         }
[17:37:36.091]         else {
[17:37:36.091]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:36.091]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:36.091]         }
[17:37:36.091]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:36.091]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:36.091]             base::sink(type = "output", split = FALSE)
[17:37:36.091]             base::close(...future.stdout)
[17:37:36.091]         }, add = TRUE)
[17:37:36.091]     }
[17:37:36.091]     ...future.frame <- base::sys.nframe()
[17:37:36.091]     ...future.conditions <- base::list()
[17:37:36.091]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:36.091]     if (FALSE) {
[17:37:36.091]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:36.091]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:36.091]     }
[17:37:36.091]     ...future.result <- base::tryCatch({
[17:37:36.091]         base::withCallingHandlers({
[17:37:36.091]             ...future.value <- base::withVisible(base::local({
[17:37:36.091]                 withCallingHandlers({
[17:37:36.091]                   {
[17:37:36.091]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.091]                     if (!identical(...future.globals.maxSize.org, 
[17:37:36.091]                       ...future.globals.maxSize)) {
[17:37:36.091]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.091]                       on.exit(options(oopts), add = TRUE)
[17:37:36.091]                     }
[17:37:36.091]                     {
[17:37:36.091]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.091]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:36.091]                         USE.NAMES = FALSE)
[17:37:36.091]                       do.call(mapply, args = args)
[17:37:36.091]                     }
[17:37:36.091]                   }
[17:37:36.091]                 }, immediateCondition = function(cond) {
[17:37:36.091]                   save_rds <- function (object, pathname, ...) 
[17:37:36.091]                   {
[17:37:36.091]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:36.091]                     if (file_test("-f", pathname_tmp)) {
[17:37:36.091]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.091]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:36.091]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.091]                         fi_tmp[["mtime"]])
[17:37:36.091]                     }
[17:37:36.091]                     tryCatch({
[17:37:36.091]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:36.091]                     }, error = function(ex) {
[17:37:36.091]                       msg <- conditionMessage(ex)
[17:37:36.091]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.091]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:36.091]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.091]                         fi_tmp[["mtime"]], msg)
[17:37:36.091]                       ex$message <- msg
[17:37:36.091]                       stop(ex)
[17:37:36.091]                     })
[17:37:36.091]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:36.091]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:36.091]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:36.091]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.091]                       fi <- file.info(pathname)
[17:37:36.091]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:36.091]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.091]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:36.091]                         fi[["size"]], fi[["mtime"]])
[17:37:36.091]                       stop(msg)
[17:37:36.091]                     }
[17:37:36.091]                     invisible(pathname)
[17:37:36.091]                   }
[17:37:36.091]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:36.091]                     rootPath = tempdir()) 
[17:37:36.091]                   {
[17:37:36.091]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:36.091]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:36.091]                       tmpdir = path, fileext = ".rds")
[17:37:36.091]                     save_rds(obj, file)
[17:37:36.091]                   }
[17:37:36.091]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:36.091]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.091]                   {
[17:37:36.091]                     inherits <- base::inherits
[17:37:36.091]                     invokeRestart <- base::invokeRestart
[17:37:36.091]                     is.null <- base::is.null
[17:37:36.091]                     muffled <- FALSE
[17:37:36.091]                     if (inherits(cond, "message")) {
[17:37:36.091]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:36.091]                       if (muffled) 
[17:37:36.091]                         invokeRestart("muffleMessage")
[17:37:36.091]                     }
[17:37:36.091]                     else if (inherits(cond, "warning")) {
[17:37:36.091]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:36.091]                       if (muffled) 
[17:37:36.091]                         invokeRestart("muffleWarning")
[17:37:36.091]                     }
[17:37:36.091]                     else if (inherits(cond, "condition")) {
[17:37:36.091]                       if (!is.null(pattern)) {
[17:37:36.091]                         computeRestarts <- base::computeRestarts
[17:37:36.091]                         grepl <- base::grepl
[17:37:36.091]                         restarts <- computeRestarts(cond)
[17:37:36.091]                         for (restart in restarts) {
[17:37:36.091]                           name <- restart$name
[17:37:36.091]                           if (is.null(name)) 
[17:37:36.091]                             next
[17:37:36.091]                           if (!grepl(pattern, name)) 
[17:37:36.091]                             next
[17:37:36.091]                           invokeRestart(restart)
[17:37:36.091]                           muffled <- TRUE
[17:37:36.091]                           break
[17:37:36.091]                         }
[17:37:36.091]                       }
[17:37:36.091]                     }
[17:37:36.091]                     invisible(muffled)
[17:37:36.091]                   }
[17:37:36.091]                   muffleCondition(cond)
[17:37:36.091]                 })
[17:37:36.091]             }))
[17:37:36.091]             future::FutureResult(value = ...future.value$value, 
[17:37:36.091]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.091]                   ...future.rng), globalenv = if (FALSE) 
[17:37:36.091]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:36.091]                     ...future.globalenv.names))
[17:37:36.091]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:36.091]         }, condition = base::local({
[17:37:36.091]             c <- base::c
[17:37:36.091]             inherits <- base::inherits
[17:37:36.091]             invokeRestart <- base::invokeRestart
[17:37:36.091]             length <- base::length
[17:37:36.091]             list <- base::list
[17:37:36.091]             seq.int <- base::seq.int
[17:37:36.091]             signalCondition <- base::signalCondition
[17:37:36.091]             sys.calls <- base::sys.calls
[17:37:36.091]             `[[` <- base::`[[`
[17:37:36.091]             `+` <- base::`+`
[17:37:36.091]             `<<-` <- base::`<<-`
[17:37:36.091]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:36.091]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:36.091]                   3L)]
[17:37:36.091]             }
[17:37:36.091]             function(cond) {
[17:37:36.091]                 is_error <- inherits(cond, "error")
[17:37:36.091]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:36.091]                   NULL)
[17:37:36.091]                 if (is_error) {
[17:37:36.091]                   sessionInformation <- function() {
[17:37:36.091]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:36.091]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:36.091]                       search = base::search(), system = base::Sys.info())
[17:37:36.091]                   }
[17:37:36.091]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.091]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:36.091]                     cond$call), session = sessionInformation(), 
[17:37:36.091]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:36.091]                   signalCondition(cond)
[17:37:36.091]                 }
[17:37:36.091]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:36.091]                 "immediateCondition"))) {
[17:37:36.091]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:36.091]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.091]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:36.091]                   if (TRUE && !signal) {
[17:37:36.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.091]                     {
[17:37:36.091]                       inherits <- base::inherits
[17:37:36.091]                       invokeRestart <- base::invokeRestart
[17:37:36.091]                       is.null <- base::is.null
[17:37:36.091]                       muffled <- FALSE
[17:37:36.091]                       if (inherits(cond, "message")) {
[17:37:36.091]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.091]                         if (muffled) 
[17:37:36.091]                           invokeRestart("muffleMessage")
[17:37:36.091]                       }
[17:37:36.091]                       else if (inherits(cond, "warning")) {
[17:37:36.091]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.091]                         if (muffled) 
[17:37:36.091]                           invokeRestart("muffleWarning")
[17:37:36.091]                       }
[17:37:36.091]                       else if (inherits(cond, "condition")) {
[17:37:36.091]                         if (!is.null(pattern)) {
[17:37:36.091]                           computeRestarts <- base::computeRestarts
[17:37:36.091]                           grepl <- base::grepl
[17:37:36.091]                           restarts <- computeRestarts(cond)
[17:37:36.091]                           for (restart in restarts) {
[17:37:36.091]                             name <- restart$name
[17:37:36.091]                             if (is.null(name)) 
[17:37:36.091]                               next
[17:37:36.091]                             if (!grepl(pattern, name)) 
[17:37:36.091]                               next
[17:37:36.091]                             invokeRestart(restart)
[17:37:36.091]                             muffled <- TRUE
[17:37:36.091]                             break
[17:37:36.091]                           }
[17:37:36.091]                         }
[17:37:36.091]                       }
[17:37:36.091]                       invisible(muffled)
[17:37:36.091]                     }
[17:37:36.091]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.091]                   }
[17:37:36.091]                 }
[17:37:36.091]                 else {
[17:37:36.091]                   if (TRUE) {
[17:37:36.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.091]                     {
[17:37:36.091]                       inherits <- base::inherits
[17:37:36.091]                       invokeRestart <- base::invokeRestart
[17:37:36.091]                       is.null <- base::is.null
[17:37:36.091]                       muffled <- FALSE
[17:37:36.091]                       if (inherits(cond, "message")) {
[17:37:36.091]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.091]                         if (muffled) 
[17:37:36.091]                           invokeRestart("muffleMessage")
[17:37:36.091]                       }
[17:37:36.091]                       else if (inherits(cond, "warning")) {
[17:37:36.091]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.091]                         if (muffled) 
[17:37:36.091]                           invokeRestart("muffleWarning")
[17:37:36.091]                       }
[17:37:36.091]                       else if (inherits(cond, "condition")) {
[17:37:36.091]                         if (!is.null(pattern)) {
[17:37:36.091]                           computeRestarts <- base::computeRestarts
[17:37:36.091]                           grepl <- base::grepl
[17:37:36.091]                           restarts <- computeRestarts(cond)
[17:37:36.091]                           for (restart in restarts) {
[17:37:36.091]                             name <- restart$name
[17:37:36.091]                             if (is.null(name)) 
[17:37:36.091]                               next
[17:37:36.091]                             if (!grepl(pattern, name)) 
[17:37:36.091]                               next
[17:37:36.091]                             invokeRestart(restart)
[17:37:36.091]                             muffled <- TRUE
[17:37:36.091]                             break
[17:37:36.091]                           }
[17:37:36.091]                         }
[17:37:36.091]                       }
[17:37:36.091]                       invisible(muffled)
[17:37:36.091]                     }
[17:37:36.091]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.091]                   }
[17:37:36.091]                 }
[17:37:36.091]             }
[17:37:36.091]         }))
[17:37:36.091]     }, error = function(ex) {
[17:37:36.091]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:36.091]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.091]                 ...future.rng), started = ...future.startTime, 
[17:37:36.091]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:36.091]             version = "1.8"), class = "FutureResult")
[17:37:36.091]     }, finally = {
[17:37:36.091]         if (!identical(...future.workdir, getwd())) 
[17:37:36.091]             setwd(...future.workdir)
[17:37:36.091]         {
[17:37:36.091]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:36.091]                 ...future.oldOptions$nwarnings <- NULL
[17:37:36.091]             }
[17:37:36.091]             base::options(...future.oldOptions)
[17:37:36.091]             if (.Platform$OS.type == "windows") {
[17:37:36.091]                 old_names <- names(...future.oldEnvVars)
[17:37:36.091]                 envs <- base::Sys.getenv()
[17:37:36.091]                 names <- names(envs)
[17:37:36.091]                 common <- intersect(names, old_names)
[17:37:36.091]                 added <- setdiff(names, old_names)
[17:37:36.091]                 removed <- setdiff(old_names, names)
[17:37:36.091]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:36.091]                   envs[common]]
[17:37:36.091]                 NAMES <- toupper(changed)
[17:37:36.091]                 args <- list()
[17:37:36.091]                 for (kk in seq_along(NAMES)) {
[17:37:36.091]                   name <- changed[[kk]]
[17:37:36.091]                   NAME <- NAMES[[kk]]
[17:37:36.091]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.091]                     next
[17:37:36.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.091]                 }
[17:37:36.091]                 NAMES <- toupper(added)
[17:37:36.091]                 for (kk in seq_along(NAMES)) {
[17:37:36.091]                   name <- added[[kk]]
[17:37:36.091]                   NAME <- NAMES[[kk]]
[17:37:36.091]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.091]                     next
[17:37:36.091]                   args[[name]] <- ""
[17:37:36.091]                 }
[17:37:36.091]                 NAMES <- toupper(removed)
[17:37:36.091]                 for (kk in seq_along(NAMES)) {
[17:37:36.091]                   name <- removed[[kk]]
[17:37:36.091]                   NAME <- NAMES[[kk]]
[17:37:36.091]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.091]                     next
[17:37:36.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.091]                 }
[17:37:36.091]                 if (length(args) > 0) 
[17:37:36.091]                   base::do.call(base::Sys.setenv, args = args)
[17:37:36.091]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:36.091]             }
[17:37:36.091]             else {
[17:37:36.091]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:36.091]             }
[17:37:36.091]             {
[17:37:36.091]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:36.091]                   0L) {
[17:37:36.091]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:36.091]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:36.091]                   base::options(opts)
[17:37:36.091]                 }
[17:37:36.091]                 {
[17:37:36.091]                   {
[17:37:36.091]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:36.091]                     NULL
[17:37:36.091]                   }
[17:37:36.091]                   options(future.plan = NULL)
[17:37:36.091]                   if (is.na(NA_character_)) 
[17:37:36.091]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.091]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:36.091]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:36.091]                     .init = FALSE)
[17:37:36.091]                 }
[17:37:36.091]             }
[17:37:36.091]         }
[17:37:36.091]     })
[17:37:36.091]     if (TRUE) {
[17:37:36.091]         base::sink(type = "output", split = FALSE)
[17:37:36.091]         if (TRUE) {
[17:37:36.091]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:36.091]         }
[17:37:36.091]         else {
[17:37:36.091]             ...future.result["stdout"] <- base::list(NULL)
[17:37:36.091]         }
[17:37:36.091]         base::close(...future.stdout)
[17:37:36.091]         ...future.stdout <- NULL
[17:37:36.091]     }
[17:37:36.091]     ...future.result$conditions <- ...future.conditions
[17:37:36.091]     ...future.result$finished <- base::Sys.time()
[17:37:36.091]     ...future.result
[17:37:36.091] }
[17:37:36.094] assign_globals() ...
[17:37:36.094] List of 5
[17:37:36.094]  $ ...future.FUN            :function (C, k)  
[17:37:36.094]  $ MoreArgs                 : list()
[17:37:36.094]  $ ...future.elements_ii    :List of 2
[17:37:36.094]   ..$ :List of 3
[17:37:36.094]   .. ..$ : chr "C"
[17:37:36.094]   .. ..$ : chr "D"
[17:37:36.094]   .. ..$ : chr "E"
[17:37:36.094]   ..$ :List of 3
[17:37:36.094]   .. ..$ : int 3
[17:37:36.094]   .. ..$ : int 2
[17:37:36.094]   .. ..$ : int 1
[17:37:36.094]  $ ...future.seeds_ii       : NULL
[17:37:36.094]  $ ...future.globals.maxSize: NULL
[17:37:36.094]  - attr(*, "where")=List of 5
[17:37:36.094]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:36.094]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:36.094]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:36.094]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:36.094]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:36.094]  - attr(*, "resolved")= logi FALSE
[17:37:36.094]  - attr(*, "total_size")= num 3824
[17:37:36.094]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.094]  - attr(*, "already-done")= logi TRUE
[17:37:36.103] - reassign environment for ‘...future.FUN’
[17:37:36.103] - copied ‘...future.FUN’ to environment
[17:37:36.103] - copied ‘MoreArgs’ to environment
[17:37:36.103] - copied ‘...future.elements_ii’ to environment
[17:37:36.104] - copied ‘...future.seeds_ii’ to environment
[17:37:36.104] - copied ‘...future.globals.maxSize’ to environment
[17:37:36.104] assign_globals() ... done
[17:37:36.104] requestCore(): workers = 2
[17:37:36.106] MulticoreFuture started
[17:37:36.107] - Launch lazy future ... done
[17:37:36.107] run() for ‘MulticoreFuture’ ... done
[17:37:36.107] Created future:
[17:37:36.107] plan(): Setting new future strategy stack:
[17:37:36.108] List of future strategies:
[17:37:36.108] 1. sequential:
[17:37:36.108]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:36.108]    - tweaked: FALSE
[17:37:36.108]    - call: NULL
[17:37:36.109] plan(): nbrOfWorkers() = 1
[17:37:36.111] plan(): Setting new future strategy stack:
[17:37:36.111] List of future strategies:
[17:37:36.111] 1. multicore:
[17:37:36.111]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:36.111]    - tweaked: FALSE
[17:37:36.111]    - call: plan(strategy)
[17:37:36.116] plan(): nbrOfWorkers() = 2
[17:37:36.107] MulticoreFuture:
[17:37:36.107] Label: ‘future_.mapply-2’
[17:37:36.107] Expression:
[17:37:36.107] {
[17:37:36.107]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.107]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:36.107]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.107]         on.exit(options(oopts), add = TRUE)
[17:37:36.107]     }
[17:37:36.107]     {
[17:37:36.107]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.107]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:36.107]         do.call(mapply, args = args)
[17:37:36.107]     }
[17:37:36.107] }
[17:37:36.107] Lazy evaluation: FALSE
[17:37:36.107] Asynchronous evaluation: TRUE
[17:37:36.107] Local evaluation: TRUE
[17:37:36.107] Environment: R_GlobalEnv
[17:37:36.107] Capture standard output: TRUE
[17:37:36.107] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:36.107] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:36.107] Packages: <none>
[17:37:36.107] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:36.107] Resolved: TRUE
[17:37:36.107] Value: <not collected>
[17:37:36.107] Conditions captured: <none>
[17:37:36.107] Early signaling: FALSE
[17:37:36.107] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:36.107] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.117] Chunk #2 of 2 ... DONE
[17:37:36.118] Launching 2 futures (chunks) ... DONE
[17:37:36.118] Resolving 2 futures (chunks) ...
[17:37:36.118] resolve() on list ...
[17:37:36.118]  recursive: 0
[17:37:36.118]  length: 2
[17:37:36.118] 
[17:37:36.119] Future #1
[17:37:36.119] result() for MulticoreFuture ...
[17:37:36.120] result() for MulticoreFuture ...
[17:37:36.120] result() for MulticoreFuture ... done
[17:37:36.120] result() for MulticoreFuture ... done
[17:37:36.120] result() for MulticoreFuture ...
[17:37:36.120] result() for MulticoreFuture ... done
[17:37:36.121] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:37:36.121] - nx: 2
[17:37:36.121] - relay: TRUE
[17:37:36.121] - stdout: TRUE
[17:37:36.121] - signal: TRUE
[17:37:36.121] - resignal: FALSE
[17:37:36.121] - force: TRUE
[17:37:36.122] - relayed: [n=2] FALSE, FALSE
[17:37:36.122] - queued futures: [n=2] FALSE, FALSE
[17:37:36.122]  - until=1
[17:37:36.122]  - relaying element #1
[17:37:36.122] result() for MulticoreFuture ...
[17:37:36.122] result() for MulticoreFuture ... done
[17:37:36.123] result() for MulticoreFuture ...
[17:37:36.123] result() for MulticoreFuture ... done
[17:37:36.123] result() for MulticoreFuture ...
[17:37:36.123] result() for MulticoreFuture ... done
[17:37:36.123] result() for MulticoreFuture ...
[17:37:36.123] result() for MulticoreFuture ... done
[17:37:36.124] - relayed: [n=2] TRUE, FALSE
[17:37:36.124] - queued futures: [n=2] TRUE, FALSE
[17:37:36.124] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:37:36.124]  length: 1 (resolved future 1)
[17:37:36.124] Future #2
[17:37:36.125] result() for MulticoreFuture ...
[17:37:36.125] result() for MulticoreFuture ...
[17:37:36.126] result() for MulticoreFuture ... done
[17:37:36.126] result() for MulticoreFuture ... done
[17:37:36.126] result() for MulticoreFuture ...
[17:37:36.126] result() for MulticoreFuture ... done
[17:37:36.126] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:37:36.126] - nx: 2
[17:37:36.126] - relay: TRUE
[17:37:36.127] - stdout: TRUE
[17:37:36.127] - signal: TRUE
[17:37:36.127] - resignal: FALSE
[17:37:36.127] - force: TRUE
[17:37:36.127] - relayed: [n=2] TRUE, FALSE
[17:37:36.127] - queued futures: [n=2] TRUE, FALSE
[17:37:36.127]  - until=2
[17:37:36.128]  - relaying element #2
[17:37:36.128] result() for MulticoreFuture ...
[17:37:36.128] result() for MulticoreFuture ... done
[17:37:36.128] result() for MulticoreFuture ...
[17:37:36.128] result() for MulticoreFuture ... done
[17:37:36.128] result() for MulticoreFuture ...
[17:37:36.128] result() for MulticoreFuture ... done
[17:37:36.131] result() for MulticoreFuture ...
[17:37:36.132] result() for MulticoreFuture ... done
[17:37:36.132] - relayed: [n=2] TRUE, TRUE
[17:37:36.132] - queued futures: [n=2] TRUE, TRUE
[17:37:36.132] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:37:36.132]  length: 0 (resolved future 2)
[17:37:36.133] Relaying remaining futures
[17:37:36.133] signalConditionsASAP(NULL, pos=0) ...
[17:37:36.133] - nx: 2
[17:37:36.133] - relay: TRUE
[17:37:36.133] - stdout: TRUE
[17:37:36.133] - signal: TRUE
[17:37:36.134] - resignal: FALSE
[17:37:36.134] - force: TRUE
[17:37:36.134] - relayed: [n=2] TRUE, TRUE
[17:37:36.134] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:36.134] - relayed: [n=2] TRUE, TRUE
[17:37:36.134] - queued futures: [n=2] TRUE, TRUE
[17:37:36.134] signalConditionsASAP(NULL, pos=0) ... done
[17:37:36.135] resolve() on list ... DONE
[17:37:36.135] result() for MulticoreFuture ...
[17:37:36.135] result() for MulticoreFuture ... done
[17:37:36.135] result() for MulticoreFuture ...
[17:37:36.135] result() for MulticoreFuture ... done
[17:37:36.135] result() for MulticoreFuture ...
[17:37:36.136] result() for MulticoreFuture ... done
[17:37:36.136] result() for MulticoreFuture ...
[17:37:36.136] result() for MulticoreFuture ... done
[17:37:36.136]  - Number of value chunks collected: 2
[17:37:36.136] Resolving 2 futures (chunks) ... DONE
[17:37:36.136] Reducing values from 2 chunks ...
[17:37:36.137]  - Number of values collected after concatenation: 5
[17:37:36.137]  - Number of values expected: 5
[17:37:36.137] Reducing values from 2 chunks ... DONE
[17:37:36.137] future_mapply() ... DONE
[17:37:36.137] future_mapply() ...
[17:37:36.142] Number of chunks: 2
[17:37:36.143] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[17:37:36.143] getGlobalsAndPackagesXApply() ...
[17:37:36.143]  - future.globals: TRUE
[17:37:36.143] getGlobalsAndPackages() ...
[17:37:36.143] Searching for globals...
[17:37:36.145] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:37:36.145] Searching for globals ... DONE
[17:37:36.145] Resolving globals: FALSE
[17:37:36.146] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:37:36.146] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:37:36.146] - globals: [1] ‘FUN’
[17:37:36.147] 
[17:37:36.147] getGlobalsAndPackages() ... DONE
[17:37:36.147]  - globals found/used: [n=1] ‘FUN’
[17:37:36.147]  - needed namespaces: [n=0] 
[17:37:36.147] Finding globals ... DONE
[17:37:36.147] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:36.147] List of 2
[17:37:36.147]  $ ...future.FUN:function (C, k)  
[17:37:36.147]  $ MoreArgs     : NULL
[17:37:36.147]  - attr(*, "where")=List of 2
[17:37:36.147]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:36.147]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:36.147]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.147]  - attr(*, "resolved")= logi FALSE
[17:37:36.147]  - attr(*, "total_size")= num NA
[17:37:36.150] Packages to be attached in all futures: [n=0] 
[17:37:36.150] getGlobalsAndPackagesXApply() ... DONE
[17:37:36.151] Number of futures (= number of chunks): 2
[17:37:36.151] Launching 2 futures (chunks) ...
[17:37:36.151] Chunk #1 of 2 ...
[17:37:36.151]  - Finding globals in '...' for chunk #1 ...
[17:37:36.151] getGlobalsAndPackages() ...
[17:37:36.151] Searching for globals...
[17:37:36.151] 
[17:37:36.152] Searching for globals ... DONE
[17:37:36.152] - globals: [0] <none>
[17:37:36.152] getGlobalsAndPackages() ... DONE
[17:37:36.152]    + additional globals found: [n=0] 
[17:37:36.152]    + additional namespaces needed: [n=0] 
[17:37:36.152]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:36.152]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:36.152]  - seeds: <none>
[17:37:36.152]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.152] getGlobalsAndPackages() ...
[17:37:36.153] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.153] Resolving globals: FALSE
[17:37:36.153] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:37:36.154] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:36.154] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.154] 
[17:37:36.154] getGlobalsAndPackages() ... DONE
[17:37:36.154] run() for ‘Future’ ...
[17:37:36.154] - state: ‘created’
[17:37:36.155] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:36.159] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.159] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:36.159]   - Field: ‘label’
[17:37:36.159]   - Field: ‘local’
[17:37:36.159]   - Field: ‘owner’
[17:37:36.160]   - Field: ‘envir’
[17:37:36.160]   - Field: ‘workers’
[17:37:36.160]   - Field: ‘packages’
[17:37:36.160]   - Field: ‘gc’
[17:37:36.160]   - Field: ‘job’
[17:37:36.160]   - Field: ‘conditions’
[17:37:36.160]   - Field: ‘expr’
[17:37:36.160]   - Field: ‘uuid’
[17:37:36.160]   - Field: ‘seed’
[17:37:36.161]   - Field: ‘version’
[17:37:36.161]   - Field: ‘result’
[17:37:36.161]   - Field: ‘asynchronous’
[17:37:36.161]   - Field: ‘calls’
[17:37:36.161]   - Field: ‘globals’
[17:37:36.161]   - Field: ‘stdout’
[17:37:36.161]   - Field: ‘earlySignal’
[17:37:36.161]   - Field: ‘lazy’
[17:37:36.161]   - Field: ‘state’
[17:37:36.161] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:36.162] - Launch lazy future ...
[17:37:36.162] Packages needed by the future expression (n = 0): <none>
[17:37:36.162] Packages needed by future strategies (n = 0): <none>
[17:37:36.163] {
[17:37:36.163]     {
[17:37:36.163]         {
[17:37:36.163]             ...future.startTime <- base::Sys.time()
[17:37:36.163]             {
[17:37:36.163]                 {
[17:37:36.163]                   {
[17:37:36.163]                     {
[17:37:36.163]                       base::local({
[17:37:36.163]                         has_future <- base::requireNamespace("future", 
[17:37:36.163]                           quietly = TRUE)
[17:37:36.163]                         if (has_future) {
[17:37:36.163]                           ns <- base::getNamespace("future")
[17:37:36.163]                           version <- ns[[".package"]][["version"]]
[17:37:36.163]                           if (is.null(version)) 
[17:37:36.163]                             version <- utils::packageVersion("future")
[17:37:36.163]                         }
[17:37:36.163]                         else {
[17:37:36.163]                           version <- NULL
[17:37:36.163]                         }
[17:37:36.163]                         if (!has_future || version < "1.8.0") {
[17:37:36.163]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:36.163]                             "", base::R.version$version.string), 
[17:37:36.163]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:36.163]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:36.163]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:36.163]                               "release", "version")], collapse = " "), 
[17:37:36.163]                             hostname = base::Sys.info()[["nodename"]])
[17:37:36.163]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:36.163]                             info)
[17:37:36.163]                           info <- base::paste(info, collapse = "; ")
[17:37:36.163]                           if (!has_future) {
[17:37:36.163]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:36.163]                               info)
[17:37:36.163]                           }
[17:37:36.163]                           else {
[17:37:36.163]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:36.163]                               info, version)
[17:37:36.163]                           }
[17:37:36.163]                           base::stop(msg)
[17:37:36.163]                         }
[17:37:36.163]                       })
[17:37:36.163]                     }
[17:37:36.163]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:36.163]                     base::options(mc.cores = 1L)
[17:37:36.163]                   }
[17:37:36.163]                   ...future.strategy.old <- future::plan("list")
[17:37:36.163]                   options(future.plan = NULL)
[17:37:36.163]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.163]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:36.163]                 }
[17:37:36.163]                 ...future.workdir <- getwd()
[17:37:36.163]             }
[17:37:36.163]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:36.163]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:36.163]         }
[17:37:36.163]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:36.163]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:36.163]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:36.163]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:36.163]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:36.163]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:36.163]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:36.163]             base::names(...future.oldOptions))
[17:37:36.163]     }
[17:37:36.163]     if (FALSE) {
[17:37:36.163]     }
[17:37:36.163]     else {
[17:37:36.163]         if (TRUE) {
[17:37:36.163]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:36.163]                 open = "w")
[17:37:36.163]         }
[17:37:36.163]         else {
[17:37:36.163]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:36.163]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:36.163]         }
[17:37:36.163]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:36.163]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:36.163]             base::sink(type = "output", split = FALSE)
[17:37:36.163]             base::close(...future.stdout)
[17:37:36.163]         }, add = TRUE)
[17:37:36.163]     }
[17:37:36.163]     ...future.frame <- base::sys.nframe()
[17:37:36.163]     ...future.conditions <- base::list()
[17:37:36.163]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:36.163]     if (FALSE) {
[17:37:36.163]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:36.163]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:36.163]     }
[17:37:36.163]     ...future.result <- base::tryCatch({
[17:37:36.163]         base::withCallingHandlers({
[17:37:36.163]             ...future.value <- base::withVisible(base::local({
[17:37:36.163]                 withCallingHandlers({
[17:37:36.163]                   {
[17:37:36.163]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.163]                     if (!identical(...future.globals.maxSize.org, 
[17:37:36.163]                       ...future.globals.maxSize)) {
[17:37:36.163]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.163]                       on.exit(options(oopts), add = TRUE)
[17:37:36.163]                     }
[17:37:36.163]                     {
[17:37:36.163]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.163]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:36.163]                         USE.NAMES = FALSE)
[17:37:36.163]                       do.call(mapply, args = args)
[17:37:36.163]                     }
[17:37:36.163]                   }
[17:37:36.163]                 }, immediateCondition = function(cond) {
[17:37:36.163]                   save_rds <- function (object, pathname, ...) 
[17:37:36.163]                   {
[17:37:36.163]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:36.163]                     if (file_test("-f", pathname_tmp)) {
[17:37:36.163]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.163]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:36.163]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.163]                         fi_tmp[["mtime"]])
[17:37:36.163]                     }
[17:37:36.163]                     tryCatch({
[17:37:36.163]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:36.163]                     }, error = function(ex) {
[17:37:36.163]                       msg <- conditionMessage(ex)
[17:37:36.163]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.163]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:36.163]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.163]                         fi_tmp[["mtime"]], msg)
[17:37:36.163]                       ex$message <- msg
[17:37:36.163]                       stop(ex)
[17:37:36.163]                     })
[17:37:36.163]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:36.163]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:36.163]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:36.163]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.163]                       fi <- file.info(pathname)
[17:37:36.163]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:36.163]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.163]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:36.163]                         fi[["size"]], fi[["mtime"]])
[17:37:36.163]                       stop(msg)
[17:37:36.163]                     }
[17:37:36.163]                     invisible(pathname)
[17:37:36.163]                   }
[17:37:36.163]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:36.163]                     rootPath = tempdir()) 
[17:37:36.163]                   {
[17:37:36.163]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:36.163]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:36.163]                       tmpdir = path, fileext = ".rds")
[17:37:36.163]                     save_rds(obj, file)
[17:37:36.163]                   }
[17:37:36.163]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:36.163]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.163]                   {
[17:37:36.163]                     inherits <- base::inherits
[17:37:36.163]                     invokeRestart <- base::invokeRestart
[17:37:36.163]                     is.null <- base::is.null
[17:37:36.163]                     muffled <- FALSE
[17:37:36.163]                     if (inherits(cond, "message")) {
[17:37:36.163]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:36.163]                       if (muffled) 
[17:37:36.163]                         invokeRestart("muffleMessage")
[17:37:36.163]                     }
[17:37:36.163]                     else if (inherits(cond, "warning")) {
[17:37:36.163]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:36.163]                       if (muffled) 
[17:37:36.163]                         invokeRestart("muffleWarning")
[17:37:36.163]                     }
[17:37:36.163]                     else if (inherits(cond, "condition")) {
[17:37:36.163]                       if (!is.null(pattern)) {
[17:37:36.163]                         computeRestarts <- base::computeRestarts
[17:37:36.163]                         grepl <- base::grepl
[17:37:36.163]                         restarts <- computeRestarts(cond)
[17:37:36.163]                         for (restart in restarts) {
[17:37:36.163]                           name <- restart$name
[17:37:36.163]                           if (is.null(name)) 
[17:37:36.163]                             next
[17:37:36.163]                           if (!grepl(pattern, name)) 
[17:37:36.163]                             next
[17:37:36.163]                           invokeRestart(restart)
[17:37:36.163]                           muffled <- TRUE
[17:37:36.163]                           break
[17:37:36.163]                         }
[17:37:36.163]                       }
[17:37:36.163]                     }
[17:37:36.163]                     invisible(muffled)
[17:37:36.163]                   }
[17:37:36.163]                   muffleCondition(cond)
[17:37:36.163]                 })
[17:37:36.163]             }))
[17:37:36.163]             future::FutureResult(value = ...future.value$value, 
[17:37:36.163]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.163]                   ...future.rng), globalenv = if (FALSE) 
[17:37:36.163]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:36.163]                     ...future.globalenv.names))
[17:37:36.163]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:36.163]         }, condition = base::local({
[17:37:36.163]             c <- base::c
[17:37:36.163]             inherits <- base::inherits
[17:37:36.163]             invokeRestart <- base::invokeRestart
[17:37:36.163]             length <- base::length
[17:37:36.163]             list <- base::list
[17:37:36.163]             seq.int <- base::seq.int
[17:37:36.163]             signalCondition <- base::signalCondition
[17:37:36.163]             sys.calls <- base::sys.calls
[17:37:36.163]             `[[` <- base::`[[`
[17:37:36.163]             `+` <- base::`+`
[17:37:36.163]             `<<-` <- base::`<<-`
[17:37:36.163]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:36.163]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:36.163]                   3L)]
[17:37:36.163]             }
[17:37:36.163]             function(cond) {
[17:37:36.163]                 is_error <- inherits(cond, "error")
[17:37:36.163]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:36.163]                   NULL)
[17:37:36.163]                 if (is_error) {
[17:37:36.163]                   sessionInformation <- function() {
[17:37:36.163]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:36.163]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:36.163]                       search = base::search(), system = base::Sys.info())
[17:37:36.163]                   }
[17:37:36.163]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.163]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:36.163]                     cond$call), session = sessionInformation(), 
[17:37:36.163]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:36.163]                   signalCondition(cond)
[17:37:36.163]                 }
[17:37:36.163]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:36.163]                 "immediateCondition"))) {
[17:37:36.163]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:36.163]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.163]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:36.163]                   if (TRUE && !signal) {
[17:37:36.163]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.163]                     {
[17:37:36.163]                       inherits <- base::inherits
[17:37:36.163]                       invokeRestart <- base::invokeRestart
[17:37:36.163]                       is.null <- base::is.null
[17:37:36.163]                       muffled <- FALSE
[17:37:36.163]                       if (inherits(cond, "message")) {
[17:37:36.163]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.163]                         if (muffled) 
[17:37:36.163]                           invokeRestart("muffleMessage")
[17:37:36.163]                       }
[17:37:36.163]                       else if (inherits(cond, "warning")) {
[17:37:36.163]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.163]                         if (muffled) 
[17:37:36.163]                           invokeRestart("muffleWarning")
[17:37:36.163]                       }
[17:37:36.163]                       else if (inherits(cond, "condition")) {
[17:37:36.163]                         if (!is.null(pattern)) {
[17:37:36.163]                           computeRestarts <- base::computeRestarts
[17:37:36.163]                           grepl <- base::grepl
[17:37:36.163]                           restarts <- computeRestarts(cond)
[17:37:36.163]                           for (restart in restarts) {
[17:37:36.163]                             name <- restart$name
[17:37:36.163]                             if (is.null(name)) 
[17:37:36.163]                               next
[17:37:36.163]                             if (!grepl(pattern, name)) 
[17:37:36.163]                               next
[17:37:36.163]                             invokeRestart(restart)
[17:37:36.163]                             muffled <- TRUE
[17:37:36.163]                             break
[17:37:36.163]                           }
[17:37:36.163]                         }
[17:37:36.163]                       }
[17:37:36.163]                       invisible(muffled)
[17:37:36.163]                     }
[17:37:36.163]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.163]                   }
[17:37:36.163]                 }
[17:37:36.163]                 else {
[17:37:36.163]                   if (TRUE) {
[17:37:36.163]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.163]                     {
[17:37:36.163]                       inherits <- base::inherits
[17:37:36.163]                       invokeRestart <- base::invokeRestart
[17:37:36.163]                       is.null <- base::is.null
[17:37:36.163]                       muffled <- FALSE
[17:37:36.163]                       if (inherits(cond, "message")) {
[17:37:36.163]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.163]                         if (muffled) 
[17:37:36.163]                           invokeRestart("muffleMessage")
[17:37:36.163]                       }
[17:37:36.163]                       else if (inherits(cond, "warning")) {
[17:37:36.163]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.163]                         if (muffled) 
[17:37:36.163]                           invokeRestart("muffleWarning")
[17:37:36.163]                       }
[17:37:36.163]                       else if (inherits(cond, "condition")) {
[17:37:36.163]                         if (!is.null(pattern)) {
[17:37:36.163]                           computeRestarts <- base::computeRestarts
[17:37:36.163]                           grepl <- base::grepl
[17:37:36.163]                           restarts <- computeRestarts(cond)
[17:37:36.163]                           for (restart in restarts) {
[17:37:36.163]                             name <- restart$name
[17:37:36.163]                             if (is.null(name)) 
[17:37:36.163]                               next
[17:37:36.163]                             if (!grepl(pattern, name)) 
[17:37:36.163]                               next
[17:37:36.163]                             invokeRestart(restart)
[17:37:36.163]                             muffled <- TRUE
[17:37:36.163]                             break
[17:37:36.163]                           }
[17:37:36.163]                         }
[17:37:36.163]                       }
[17:37:36.163]                       invisible(muffled)
[17:37:36.163]                     }
[17:37:36.163]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.163]                   }
[17:37:36.163]                 }
[17:37:36.163]             }
[17:37:36.163]         }))
[17:37:36.163]     }, error = function(ex) {
[17:37:36.163]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:36.163]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.163]                 ...future.rng), started = ...future.startTime, 
[17:37:36.163]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:36.163]             version = "1.8"), class = "FutureResult")
[17:37:36.163]     }, finally = {
[17:37:36.163]         if (!identical(...future.workdir, getwd())) 
[17:37:36.163]             setwd(...future.workdir)
[17:37:36.163]         {
[17:37:36.163]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:36.163]                 ...future.oldOptions$nwarnings <- NULL
[17:37:36.163]             }
[17:37:36.163]             base::options(...future.oldOptions)
[17:37:36.163]             if (.Platform$OS.type == "windows") {
[17:37:36.163]                 old_names <- names(...future.oldEnvVars)
[17:37:36.163]                 envs <- base::Sys.getenv()
[17:37:36.163]                 names <- names(envs)
[17:37:36.163]                 common <- intersect(names, old_names)
[17:37:36.163]                 added <- setdiff(names, old_names)
[17:37:36.163]                 removed <- setdiff(old_names, names)
[17:37:36.163]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:36.163]                   envs[common]]
[17:37:36.163]                 NAMES <- toupper(changed)
[17:37:36.163]                 args <- list()
[17:37:36.163]                 for (kk in seq_along(NAMES)) {
[17:37:36.163]                   name <- changed[[kk]]
[17:37:36.163]                   NAME <- NAMES[[kk]]
[17:37:36.163]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.163]                     next
[17:37:36.163]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.163]                 }
[17:37:36.163]                 NAMES <- toupper(added)
[17:37:36.163]                 for (kk in seq_along(NAMES)) {
[17:37:36.163]                   name <- added[[kk]]
[17:37:36.163]                   NAME <- NAMES[[kk]]
[17:37:36.163]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.163]                     next
[17:37:36.163]                   args[[name]] <- ""
[17:37:36.163]                 }
[17:37:36.163]                 NAMES <- toupper(removed)
[17:37:36.163]                 for (kk in seq_along(NAMES)) {
[17:37:36.163]                   name <- removed[[kk]]
[17:37:36.163]                   NAME <- NAMES[[kk]]
[17:37:36.163]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.163]                     next
[17:37:36.163]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.163]                 }
[17:37:36.163]                 if (length(args) > 0) 
[17:37:36.163]                   base::do.call(base::Sys.setenv, args = args)
[17:37:36.163]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:36.163]             }
[17:37:36.163]             else {
[17:37:36.163]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:36.163]             }
[17:37:36.163]             {
[17:37:36.163]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:36.163]                   0L) {
[17:37:36.163]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:36.163]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:36.163]                   base::options(opts)
[17:37:36.163]                 }
[17:37:36.163]                 {
[17:37:36.163]                   {
[17:37:36.163]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:36.163]                     NULL
[17:37:36.163]                   }
[17:37:36.163]                   options(future.plan = NULL)
[17:37:36.163]                   if (is.na(NA_character_)) 
[17:37:36.163]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.163]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:36.163]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:36.163]                     .init = FALSE)
[17:37:36.163]                 }
[17:37:36.163]             }
[17:37:36.163]         }
[17:37:36.163]     })
[17:37:36.163]     if (TRUE) {
[17:37:36.163]         base::sink(type = "output", split = FALSE)
[17:37:36.163]         if (TRUE) {
[17:37:36.163]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:36.163]         }
[17:37:36.163]         else {
[17:37:36.163]             ...future.result["stdout"] <- base::list(NULL)
[17:37:36.163]         }
[17:37:36.163]         base::close(...future.stdout)
[17:37:36.163]         ...future.stdout <- NULL
[17:37:36.163]     }
[17:37:36.163]     ...future.result$conditions <- ...future.conditions
[17:37:36.163]     ...future.result$finished <- base::Sys.time()
[17:37:36.163]     ...future.result
[17:37:36.163] }
[17:37:36.167] assign_globals() ...
[17:37:36.168] List of 5
[17:37:36.168]  $ ...future.FUN            :function (C, k)  
[17:37:36.168]  $ MoreArgs                 : NULL
[17:37:36.168]  $ ...future.elements_ii    :List of 2
[17:37:36.168]   ..$ :List of 2
[17:37:36.168]   .. ..$ : chr "E"
[17:37:36.168]   .. ..$ : chr "D"
[17:37:36.168]   ..$ :List of 2
[17:37:36.168]   .. ..$ : int 1
[17:37:36.168]   .. ..$ : int 2
[17:37:36.168]  $ ...future.seeds_ii       : NULL
[17:37:36.168]  $ ...future.globals.maxSize: NULL
[17:37:36.168]  - attr(*, "where")=List of 5
[17:37:36.168]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:36.168]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:36.168]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:36.168]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:36.168]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:36.168]  - attr(*, "resolved")= logi FALSE
[17:37:36.168]  - attr(*, "total_size")= num 3656
[17:37:36.168]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.168]  - attr(*, "already-done")= logi TRUE
[17:37:36.174] - reassign environment for ‘...future.FUN’
[17:37:36.174] - copied ‘...future.FUN’ to environment
[17:37:36.175] - copied ‘MoreArgs’ to environment
[17:37:36.175] - copied ‘...future.elements_ii’ to environment
[17:37:36.175] - copied ‘...future.seeds_ii’ to environment
[17:37:36.175] - copied ‘...future.globals.maxSize’ to environment
[17:37:36.175] assign_globals() ... done
[17:37:36.175] requestCore(): workers = 2
[17:37:36.177] MulticoreFuture started
[17:37:36.178] - Launch lazy future ... done
[17:37:36.178] run() for ‘MulticoreFuture’ ... done
[17:37:36.179] Created future:
[17:37:36.179] plan(): Setting new future strategy stack:
[17:37:36.179] List of future strategies:
[17:37:36.179] 1. sequential:
[17:37:36.179]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:36.179]    - tweaked: FALSE
[17:37:36.179]    - call: NULL
[17:37:36.180] plan(): nbrOfWorkers() = 1
[17:37:36.182] plan(): Setting new future strategy stack:
[17:37:36.182] List of future strategies:
[17:37:36.182] 1. multicore:
[17:37:36.182]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:36.182]    - tweaked: FALSE
[17:37:36.182]    - call: plan(strategy)
[17:37:36.188] plan(): nbrOfWorkers() = 2
[17:37:36.179] MulticoreFuture:
[17:37:36.179] Label: ‘future_mapply-1’
[17:37:36.179] Expression:
[17:37:36.179] {
[17:37:36.179]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.179]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:36.179]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.179]         on.exit(options(oopts), add = TRUE)
[17:37:36.179]     }
[17:37:36.179]     {
[17:37:36.179]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.179]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:36.179]         do.call(mapply, args = args)
[17:37:36.179]     }
[17:37:36.179] }
[17:37:36.179] Lazy evaluation: FALSE
[17:37:36.179] Asynchronous evaluation: TRUE
[17:37:36.179] Local evaluation: TRUE
[17:37:36.179] Environment: R_GlobalEnv
[17:37:36.179] Capture standard output: TRUE
[17:37:36.179] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:36.179] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:36.179] Packages: <none>
[17:37:36.179] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:36.179] Resolved: TRUE
[17:37:36.179] Value: <not collected>
[17:37:36.179] Conditions captured: <none>
[17:37:36.179] Early signaling: FALSE
[17:37:36.179] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:36.179] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.189] Chunk #1 of 2 ... DONE
[17:37:36.189] Chunk #2 of 2 ...
[17:37:36.190]  - Finding globals in '...' for chunk #2 ...
[17:37:36.190] getGlobalsAndPackages() ...
[17:37:36.190] Searching for globals...
[17:37:36.191] 
[17:37:36.191] Searching for globals ... DONE
[17:37:36.191] - globals: [0] <none>
[17:37:36.191] getGlobalsAndPackages() ... DONE
[17:37:36.191]    + additional globals found: [n=0] 
[17:37:36.191]    + additional namespaces needed: [n=0] 
[17:37:36.191]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:36.192]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:36.192]  - seeds: <none>
[17:37:36.192]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.192] getGlobalsAndPackages() ...
[17:37:36.192] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.192] Resolving globals: FALSE
[17:37:36.193] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:37:36.194] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:36.194] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.194] 
[17:37:36.195] getGlobalsAndPackages() ... DONE
[17:37:36.195] run() for ‘Future’ ...
[17:37:36.195] - state: ‘created’
[17:37:36.195] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:36.200] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.200] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:36.201]   - Field: ‘label’
[17:37:36.201]   - Field: ‘local’
[17:37:36.201]   - Field: ‘owner’
[17:37:36.201]   - Field: ‘envir’
[17:37:36.201]   - Field: ‘workers’
[17:37:36.201]   - Field: ‘packages’
[17:37:36.202]   - Field: ‘gc’
[17:37:36.202]   - Field: ‘job’
[17:37:36.202]   - Field: ‘conditions’
[17:37:36.202]   - Field: ‘expr’
[17:37:36.202]   - Field: ‘uuid’
[17:37:36.202]   - Field: ‘seed’
[17:37:36.203]   - Field: ‘version’
[17:37:36.203]   - Field: ‘result’
[17:37:36.203]   - Field: ‘asynchronous’
[17:37:36.203]   - Field: ‘calls’
[17:37:36.203]   - Field: ‘globals’
[17:37:36.203]   - Field: ‘stdout’
[17:37:36.203]   - Field: ‘earlySignal’
[17:37:36.204]   - Field: ‘lazy’
[17:37:36.204]   - Field: ‘state’
[17:37:36.204] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:36.204] - Launch lazy future ...
[17:37:36.205] Packages needed by the future expression (n = 0): <none>
[17:37:36.205] Packages needed by future strategies (n = 0): <none>
[17:37:36.206] {
[17:37:36.206]     {
[17:37:36.206]         {
[17:37:36.206]             ...future.startTime <- base::Sys.time()
[17:37:36.206]             {
[17:37:36.206]                 {
[17:37:36.206]                   {
[17:37:36.206]                     {
[17:37:36.206]                       base::local({
[17:37:36.206]                         has_future <- base::requireNamespace("future", 
[17:37:36.206]                           quietly = TRUE)
[17:37:36.206]                         if (has_future) {
[17:37:36.206]                           ns <- base::getNamespace("future")
[17:37:36.206]                           version <- ns[[".package"]][["version"]]
[17:37:36.206]                           if (is.null(version)) 
[17:37:36.206]                             version <- utils::packageVersion("future")
[17:37:36.206]                         }
[17:37:36.206]                         else {
[17:37:36.206]                           version <- NULL
[17:37:36.206]                         }
[17:37:36.206]                         if (!has_future || version < "1.8.0") {
[17:37:36.206]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:36.206]                             "", base::R.version$version.string), 
[17:37:36.206]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:36.206]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:36.206]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:36.206]                               "release", "version")], collapse = " "), 
[17:37:36.206]                             hostname = base::Sys.info()[["nodename"]])
[17:37:36.206]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:36.206]                             info)
[17:37:36.206]                           info <- base::paste(info, collapse = "; ")
[17:37:36.206]                           if (!has_future) {
[17:37:36.206]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:36.206]                               info)
[17:37:36.206]                           }
[17:37:36.206]                           else {
[17:37:36.206]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:36.206]                               info, version)
[17:37:36.206]                           }
[17:37:36.206]                           base::stop(msg)
[17:37:36.206]                         }
[17:37:36.206]                       })
[17:37:36.206]                     }
[17:37:36.206]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:36.206]                     base::options(mc.cores = 1L)
[17:37:36.206]                   }
[17:37:36.206]                   ...future.strategy.old <- future::plan("list")
[17:37:36.206]                   options(future.plan = NULL)
[17:37:36.206]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.206]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:36.206]                 }
[17:37:36.206]                 ...future.workdir <- getwd()
[17:37:36.206]             }
[17:37:36.206]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:36.206]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:36.206]         }
[17:37:36.206]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:36.206]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:36.206]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:36.206]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:36.206]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:36.206]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:36.206]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:36.206]             base::names(...future.oldOptions))
[17:37:36.206]     }
[17:37:36.206]     if (FALSE) {
[17:37:36.206]     }
[17:37:36.206]     else {
[17:37:36.206]         if (TRUE) {
[17:37:36.206]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:36.206]                 open = "w")
[17:37:36.206]         }
[17:37:36.206]         else {
[17:37:36.206]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:36.206]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:36.206]         }
[17:37:36.206]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:36.206]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:36.206]             base::sink(type = "output", split = FALSE)
[17:37:36.206]             base::close(...future.stdout)
[17:37:36.206]         }, add = TRUE)
[17:37:36.206]     }
[17:37:36.206]     ...future.frame <- base::sys.nframe()
[17:37:36.206]     ...future.conditions <- base::list()
[17:37:36.206]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:36.206]     if (FALSE) {
[17:37:36.206]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:36.206]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:36.206]     }
[17:37:36.206]     ...future.result <- base::tryCatch({
[17:37:36.206]         base::withCallingHandlers({
[17:37:36.206]             ...future.value <- base::withVisible(base::local({
[17:37:36.206]                 withCallingHandlers({
[17:37:36.206]                   {
[17:37:36.206]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.206]                     if (!identical(...future.globals.maxSize.org, 
[17:37:36.206]                       ...future.globals.maxSize)) {
[17:37:36.206]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.206]                       on.exit(options(oopts), add = TRUE)
[17:37:36.206]                     }
[17:37:36.206]                     {
[17:37:36.206]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.206]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:36.206]                         USE.NAMES = FALSE)
[17:37:36.206]                       do.call(mapply, args = args)
[17:37:36.206]                     }
[17:37:36.206]                   }
[17:37:36.206]                 }, immediateCondition = function(cond) {
[17:37:36.206]                   save_rds <- function (object, pathname, ...) 
[17:37:36.206]                   {
[17:37:36.206]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:36.206]                     if (file_test("-f", pathname_tmp)) {
[17:37:36.206]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.206]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:36.206]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.206]                         fi_tmp[["mtime"]])
[17:37:36.206]                     }
[17:37:36.206]                     tryCatch({
[17:37:36.206]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:36.206]                     }, error = function(ex) {
[17:37:36.206]                       msg <- conditionMessage(ex)
[17:37:36.206]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.206]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:36.206]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.206]                         fi_tmp[["mtime"]], msg)
[17:37:36.206]                       ex$message <- msg
[17:37:36.206]                       stop(ex)
[17:37:36.206]                     })
[17:37:36.206]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:36.206]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:36.206]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:36.206]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.206]                       fi <- file.info(pathname)
[17:37:36.206]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:36.206]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.206]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:36.206]                         fi[["size"]], fi[["mtime"]])
[17:37:36.206]                       stop(msg)
[17:37:36.206]                     }
[17:37:36.206]                     invisible(pathname)
[17:37:36.206]                   }
[17:37:36.206]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:36.206]                     rootPath = tempdir()) 
[17:37:36.206]                   {
[17:37:36.206]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:36.206]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:36.206]                       tmpdir = path, fileext = ".rds")
[17:37:36.206]                     save_rds(obj, file)
[17:37:36.206]                   }
[17:37:36.206]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:36.206]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.206]                   {
[17:37:36.206]                     inherits <- base::inherits
[17:37:36.206]                     invokeRestart <- base::invokeRestart
[17:37:36.206]                     is.null <- base::is.null
[17:37:36.206]                     muffled <- FALSE
[17:37:36.206]                     if (inherits(cond, "message")) {
[17:37:36.206]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:36.206]                       if (muffled) 
[17:37:36.206]                         invokeRestart("muffleMessage")
[17:37:36.206]                     }
[17:37:36.206]                     else if (inherits(cond, "warning")) {
[17:37:36.206]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:36.206]                       if (muffled) 
[17:37:36.206]                         invokeRestart("muffleWarning")
[17:37:36.206]                     }
[17:37:36.206]                     else if (inherits(cond, "condition")) {
[17:37:36.206]                       if (!is.null(pattern)) {
[17:37:36.206]                         computeRestarts <- base::computeRestarts
[17:37:36.206]                         grepl <- base::grepl
[17:37:36.206]                         restarts <- computeRestarts(cond)
[17:37:36.206]                         for (restart in restarts) {
[17:37:36.206]                           name <- restart$name
[17:37:36.206]                           if (is.null(name)) 
[17:37:36.206]                             next
[17:37:36.206]                           if (!grepl(pattern, name)) 
[17:37:36.206]                             next
[17:37:36.206]                           invokeRestart(restart)
[17:37:36.206]                           muffled <- TRUE
[17:37:36.206]                           break
[17:37:36.206]                         }
[17:37:36.206]                       }
[17:37:36.206]                     }
[17:37:36.206]                     invisible(muffled)
[17:37:36.206]                   }
[17:37:36.206]                   muffleCondition(cond)
[17:37:36.206]                 })
[17:37:36.206]             }))
[17:37:36.206]             future::FutureResult(value = ...future.value$value, 
[17:37:36.206]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.206]                   ...future.rng), globalenv = if (FALSE) 
[17:37:36.206]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:36.206]                     ...future.globalenv.names))
[17:37:36.206]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:36.206]         }, condition = base::local({
[17:37:36.206]             c <- base::c
[17:37:36.206]             inherits <- base::inherits
[17:37:36.206]             invokeRestart <- base::invokeRestart
[17:37:36.206]             length <- base::length
[17:37:36.206]             list <- base::list
[17:37:36.206]             seq.int <- base::seq.int
[17:37:36.206]             signalCondition <- base::signalCondition
[17:37:36.206]             sys.calls <- base::sys.calls
[17:37:36.206]             `[[` <- base::`[[`
[17:37:36.206]             `+` <- base::`+`
[17:37:36.206]             `<<-` <- base::`<<-`
[17:37:36.206]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:36.206]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:36.206]                   3L)]
[17:37:36.206]             }
[17:37:36.206]             function(cond) {
[17:37:36.206]                 is_error <- inherits(cond, "error")
[17:37:36.206]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:36.206]                   NULL)
[17:37:36.206]                 if (is_error) {
[17:37:36.206]                   sessionInformation <- function() {
[17:37:36.206]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:36.206]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:36.206]                       search = base::search(), system = base::Sys.info())
[17:37:36.206]                   }
[17:37:36.206]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.206]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:36.206]                     cond$call), session = sessionInformation(), 
[17:37:36.206]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:36.206]                   signalCondition(cond)
[17:37:36.206]                 }
[17:37:36.206]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:36.206]                 "immediateCondition"))) {
[17:37:36.206]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:36.206]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.206]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:36.206]                   if (TRUE && !signal) {
[17:37:36.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.206]                     {
[17:37:36.206]                       inherits <- base::inherits
[17:37:36.206]                       invokeRestart <- base::invokeRestart
[17:37:36.206]                       is.null <- base::is.null
[17:37:36.206]                       muffled <- FALSE
[17:37:36.206]                       if (inherits(cond, "message")) {
[17:37:36.206]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.206]                         if (muffled) 
[17:37:36.206]                           invokeRestart("muffleMessage")
[17:37:36.206]                       }
[17:37:36.206]                       else if (inherits(cond, "warning")) {
[17:37:36.206]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.206]                         if (muffled) 
[17:37:36.206]                           invokeRestart("muffleWarning")
[17:37:36.206]                       }
[17:37:36.206]                       else if (inherits(cond, "condition")) {
[17:37:36.206]                         if (!is.null(pattern)) {
[17:37:36.206]                           computeRestarts <- base::computeRestarts
[17:37:36.206]                           grepl <- base::grepl
[17:37:36.206]                           restarts <- computeRestarts(cond)
[17:37:36.206]                           for (restart in restarts) {
[17:37:36.206]                             name <- restart$name
[17:37:36.206]                             if (is.null(name)) 
[17:37:36.206]                               next
[17:37:36.206]                             if (!grepl(pattern, name)) 
[17:37:36.206]                               next
[17:37:36.206]                             invokeRestart(restart)
[17:37:36.206]                             muffled <- TRUE
[17:37:36.206]                             break
[17:37:36.206]                           }
[17:37:36.206]                         }
[17:37:36.206]                       }
[17:37:36.206]                       invisible(muffled)
[17:37:36.206]                     }
[17:37:36.206]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.206]                   }
[17:37:36.206]                 }
[17:37:36.206]                 else {
[17:37:36.206]                   if (TRUE) {
[17:37:36.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.206]                     {
[17:37:36.206]                       inherits <- base::inherits
[17:37:36.206]                       invokeRestart <- base::invokeRestart
[17:37:36.206]                       is.null <- base::is.null
[17:37:36.206]                       muffled <- FALSE
[17:37:36.206]                       if (inherits(cond, "message")) {
[17:37:36.206]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.206]                         if (muffled) 
[17:37:36.206]                           invokeRestart("muffleMessage")
[17:37:36.206]                       }
[17:37:36.206]                       else if (inherits(cond, "warning")) {
[17:37:36.206]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.206]                         if (muffled) 
[17:37:36.206]                           invokeRestart("muffleWarning")
[17:37:36.206]                       }
[17:37:36.206]                       else if (inherits(cond, "condition")) {
[17:37:36.206]                         if (!is.null(pattern)) {
[17:37:36.206]                           computeRestarts <- base::computeRestarts
[17:37:36.206]                           grepl <- base::grepl
[17:37:36.206]                           restarts <- computeRestarts(cond)
[17:37:36.206]                           for (restart in restarts) {
[17:37:36.206]                             name <- restart$name
[17:37:36.206]                             if (is.null(name)) 
[17:37:36.206]                               next
[17:37:36.206]                             if (!grepl(pattern, name)) 
[17:37:36.206]                               next
[17:37:36.206]                             invokeRestart(restart)
[17:37:36.206]                             muffled <- TRUE
[17:37:36.206]                             break
[17:37:36.206]                           }
[17:37:36.206]                         }
[17:37:36.206]                       }
[17:37:36.206]                       invisible(muffled)
[17:37:36.206]                     }
[17:37:36.206]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.206]                   }
[17:37:36.206]                 }
[17:37:36.206]             }
[17:37:36.206]         }))
[17:37:36.206]     }, error = function(ex) {
[17:37:36.206]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:36.206]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.206]                 ...future.rng), started = ...future.startTime, 
[17:37:36.206]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:36.206]             version = "1.8"), class = "FutureResult")
[17:37:36.206]     }, finally = {
[17:37:36.206]         if (!identical(...future.workdir, getwd())) 
[17:37:36.206]             setwd(...future.workdir)
[17:37:36.206]         {
[17:37:36.206]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:36.206]                 ...future.oldOptions$nwarnings <- NULL
[17:37:36.206]             }
[17:37:36.206]             base::options(...future.oldOptions)
[17:37:36.206]             if (.Platform$OS.type == "windows") {
[17:37:36.206]                 old_names <- names(...future.oldEnvVars)
[17:37:36.206]                 envs <- base::Sys.getenv()
[17:37:36.206]                 names <- names(envs)
[17:37:36.206]                 common <- intersect(names, old_names)
[17:37:36.206]                 added <- setdiff(names, old_names)
[17:37:36.206]                 removed <- setdiff(old_names, names)
[17:37:36.206]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:36.206]                   envs[common]]
[17:37:36.206]                 NAMES <- toupper(changed)
[17:37:36.206]                 args <- list()
[17:37:36.206]                 for (kk in seq_along(NAMES)) {
[17:37:36.206]                   name <- changed[[kk]]
[17:37:36.206]                   NAME <- NAMES[[kk]]
[17:37:36.206]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.206]                     next
[17:37:36.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.206]                 }
[17:37:36.206]                 NAMES <- toupper(added)
[17:37:36.206]                 for (kk in seq_along(NAMES)) {
[17:37:36.206]                   name <- added[[kk]]
[17:37:36.206]                   NAME <- NAMES[[kk]]
[17:37:36.206]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.206]                     next
[17:37:36.206]                   args[[name]] <- ""
[17:37:36.206]                 }
[17:37:36.206]                 NAMES <- toupper(removed)
[17:37:36.206]                 for (kk in seq_along(NAMES)) {
[17:37:36.206]                   name <- removed[[kk]]
[17:37:36.206]                   NAME <- NAMES[[kk]]
[17:37:36.206]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.206]                     next
[17:37:36.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.206]                 }
[17:37:36.206]                 if (length(args) > 0) 
[17:37:36.206]                   base::do.call(base::Sys.setenv, args = args)
[17:37:36.206]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:36.206]             }
[17:37:36.206]             else {
[17:37:36.206]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:36.206]             }
[17:37:36.206]             {
[17:37:36.206]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:36.206]                   0L) {
[17:37:36.206]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:36.206]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:36.206]                   base::options(opts)
[17:37:36.206]                 }
[17:37:36.206]                 {
[17:37:36.206]                   {
[17:37:36.206]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:36.206]                     NULL
[17:37:36.206]                   }
[17:37:36.206]                   options(future.plan = NULL)
[17:37:36.206]                   if (is.na(NA_character_)) 
[17:37:36.206]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.206]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:36.206]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:36.206]                     .init = FALSE)
[17:37:36.206]                 }
[17:37:36.206]             }
[17:37:36.206]         }
[17:37:36.206]     })
[17:37:36.206]     if (TRUE) {
[17:37:36.206]         base::sink(type = "output", split = FALSE)
[17:37:36.206]         if (TRUE) {
[17:37:36.206]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:36.206]         }
[17:37:36.206]         else {
[17:37:36.206]             ...future.result["stdout"] <- base::list(NULL)
[17:37:36.206]         }
[17:37:36.206]         base::close(...future.stdout)
[17:37:36.206]         ...future.stdout <- NULL
[17:37:36.206]     }
[17:37:36.206]     ...future.result$conditions <- ...future.conditions
[17:37:36.206]     ...future.result$finished <- base::Sys.time()
[17:37:36.206]     ...future.result
[17:37:36.206] }
[17:37:36.209] assign_globals() ...
[17:37:36.209] List of 5
[17:37:36.209]  $ ...future.FUN            :function (C, k)  
[17:37:36.209]  $ MoreArgs                 : NULL
[17:37:36.209]  $ ...future.elements_ii    :List of 2
[17:37:36.209]   ..$ :List of 3
[17:37:36.209]   .. ..$ : chr "C"
[17:37:36.209]   .. ..$ : chr "B"
[17:37:36.209]   .. ..$ : chr "A"
[17:37:36.209]   ..$ :List of 3
[17:37:36.209]   .. ..$ : int 3
[17:37:36.209]   .. ..$ : int 4
[17:37:36.209]   .. ..$ : int 5
[17:37:36.209]  $ ...future.seeds_ii       : NULL
[17:37:36.209]  $ ...future.globals.maxSize: NULL
[17:37:36.209]  - attr(*, "where")=List of 5
[17:37:36.209]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:36.209]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:36.209]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:36.209]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:36.209]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:36.209]  - attr(*, "resolved")= logi FALSE
[17:37:36.209]  - attr(*, "total_size")= num 3824
[17:37:36.209]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.209]  - attr(*, "already-done")= logi TRUE
[17:37:36.224] - reassign environment for ‘...future.FUN’
[17:37:36.224] - copied ‘...future.FUN’ to environment
[17:37:36.224] - copied ‘MoreArgs’ to environment
[17:37:36.224] - copied ‘...future.elements_ii’ to environment
[17:37:36.225] - copied ‘...future.seeds_ii’ to environment
[17:37:36.225] - copied ‘...future.globals.maxSize’ to environment
[17:37:36.225] assign_globals() ... done
[17:37:36.225] requestCore(): workers = 2
[17:37:36.227] MulticoreFuture started
[17:37:36.228] - Launch lazy future ... done
[17:37:36.228] run() for ‘MulticoreFuture’ ... done
[17:37:36.229] plan(): Setting new future strategy stack:
[17:37:36.229] Created future:
[17:37:36.229] List of future strategies:
[17:37:36.229] 1. sequential:
[17:37:36.229]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:36.229]    - tweaked: FALSE
[17:37:36.229]    - call: NULL
[17:37:36.230] plan(): nbrOfWorkers() = 1
[17:37:36.233] plan(): Setting new future strategy stack:
[17:37:36.233] List of future strategies:
[17:37:36.233] 1. multicore:
[17:37:36.233]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:36.233]    - tweaked: FALSE
[17:37:36.233]    - call: plan(strategy)
[17:37:36.239] plan(): nbrOfWorkers() = 2
[17:37:36.229] MulticoreFuture:
[17:37:36.229] Label: ‘future_mapply-2’
[17:37:36.229] Expression:
[17:37:36.229] {
[17:37:36.229]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.229]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:36.229]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.229]         on.exit(options(oopts), add = TRUE)
[17:37:36.229]     }
[17:37:36.229]     {
[17:37:36.229]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.229]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:36.229]         do.call(mapply, args = args)
[17:37:36.229]     }
[17:37:36.229] }
[17:37:36.229] Lazy evaluation: FALSE
[17:37:36.229] Asynchronous evaluation: TRUE
[17:37:36.229] Local evaluation: TRUE
[17:37:36.229] Environment: R_GlobalEnv
[17:37:36.229] Capture standard output: TRUE
[17:37:36.229] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:36.229] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:36.229] Packages: <none>
[17:37:36.229] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:36.229] Resolved: TRUE
[17:37:36.229] Value: <not collected>
[17:37:36.229] Conditions captured: <none>
[17:37:36.229] Early signaling: FALSE
[17:37:36.229] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:36.229] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.240] Chunk #2 of 2 ... DONE
[17:37:36.240] Launching 2 futures (chunks) ... DONE
[17:37:36.240] Resolving 2 futures (chunks) ...
[17:37:36.241] resolve() on list ...
[17:37:36.241]  recursive: 0
[17:37:36.241]  length: 2
[17:37:36.241] 
[17:37:36.242] Future #1
[17:37:36.242] result() for MulticoreFuture ...
[17:37:36.243] result() for MulticoreFuture ...
[17:37:36.243] result() for MulticoreFuture ... done
[17:37:36.243] result() for MulticoreFuture ... done
[17:37:36.243] result() for MulticoreFuture ...
[17:37:36.243] result() for MulticoreFuture ... done
[17:37:36.244] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:37:36.244] - nx: 2
[17:37:36.244] - relay: TRUE
[17:37:36.244] - stdout: TRUE
[17:37:36.244] - signal: TRUE
[17:37:36.244] - resignal: FALSE
[17:37:36.244] - force: TRUE
[17:37:36.245] - relayed: [n=2] FALSE, FALSE
[17:37:36.245] - queued futures: [n=2] FALSE, FALSE
[17:37:36.245]  - until=1
[17:37:36.245]  - relaying element #1
[17:37:36.245] result() for MulticoreFuture ...
[17:37:36.245] result() for MulticoreFuture ... done
[17:37:36.246] result() for MulticoreFuture ...
[17:37:36.246] result() for MulticoreFuture ... done
[17:37:36.246] result() for MulticoreFuture ...
[17:37:36.246] result() for MulticoreFuture ... done
[17:37:36.246] result() for MulticoreFuture ...
[17:37:36.246] result() for MulticoreFuture ... done
[17:37:36.247] - relayed: [n=2] TRUE, FALSE
[17:37:36.247] - queued futures: [n=2] TRUE, FALSE
[17:37:36.247] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:37:36.247]  length: 1 (resolved future 1)
[17:37:36.247] Future #2
[17:37:36.248] result() for MulticoreFuture ...
[17:37:36.248] result() for MulticoreFuture ...
[17:37:36.248] result() for MulticoreFuture ... done
[17:37:36.249] result() for MulticoreFuture ... done
[17:37:36.249] result() for MulticoreFuture ...
[17:37:36.249] result() for MulticoreFuture ... done
[17:37:36.249] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:37:36.249] - nx: 2
[17:37:36.249] - relay: TRUE
[17:37:36.249] - stdout: TRUE
[17:37:36.250] - signal: TRUE
[17:37:36.250] - resignal: FALSE
[17:37:36.250] - force: TRUE
[17:37:36.250] - relayed: [n=2] TRUE, FALSE
[17:37:36.250] - queued futures: [n=2] TRUE, FALSE
[17:37:36.250]  - until=2
[17:37:36.250]  - relaying element #2
[17:37:36.250] result() for MulticoreFuture ...
[17:37:36.251] result() for MulticoreFuture ... done
[17:37:36.251] result() for MulticoreFuture ...
[17:37:36.251] result() for MulticoreFuture ... done
[17:37:36.251] result() for MulticoreFuture ...
[17:37:36.251] result() for MulticoreFuture ... done
[17:37:36.251] result() for MulticoreFuture ...
[17:37:36.251] result() for MulticoreFuture ... done
[17:37:36.251] - relayed: [n=2] TRUE, TRUE
[17:37:36.252] - queued futures: [n=2] TRUE, TRUE
[17:37:36.252] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:37:36.252]  length: 0 (resolved future 2)
[17:37:36.252] Relaying remaining futures
[17:37:36.252] signalConditionsASAP(NULL, pos=0) ...
[17:37:36.252] - nx: 2
[17:37:36.252] - relay: TRUE
[17:37:36.252] - stdout: TRUE
[17:37:36.253] - signal: TRUE
[17:37:36.253] - resignal: FALSE
[17:37:36.253] - force: TRUE
[17:37:36.253] - relayed: [n=2] TRUE, TRUE
[17:37:36.253] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:36.253] - relayed: [n=2] TRUE, TRUE
[17:37:36.253] - queued futures: [n=2] TRUE, TRUE
[17:37:36.253] signalConditionsASAP(NULL, pos=0) ... done
[17:37:36.253] resolve() on list ... DONE
[17:37:36.254] result() for MulticoreFuture ...
[17:37:36.254] result() for MulticoreFuture ... done
[17:37:36.254] result() for MulticoreFuture ...
[17:37:36.254] result() for MulticoreFuture ... done
[17:37:36.254] result() for MulticoreFuture ...
[17:37:36.254] result() for MulticoreFuture ... done
[17:37:36.254] result() for MulticoreFuture ...
[17:37:36.254] result() for MulticoreFuture ... done
[17:37:36.255]  - Number of value chunks collected: 2
[17:37:36.255] Resolving 2 futures (chunks) ... DONE
[17:37:36.255] Reducing values from 2 chunks ...
[17:37:36.255]  - Number of values collected after concatenation: 5
[17:37:36.255]  - Number of values expected: 5
[17:37:36.255] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[17:37:36.255] Reducing values from 2 chunks ... DONE
[17:37:36.255] future_mapply() ... DONE
[17:37:36.256] future_mapply() ...
[17:37:36.261] Number of chunks: 2
[17:37:36.261] getGlobalsAndPackagesXApply() ...
[17:37:36.261]  - future.globals: TRUE
[17:37:36.261] getGlobalsAndPackages() ...
[17:37:36.261] Searching for globals...
[17:37:36.266] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:37:36.266] Searching for globals ... DONE
[17:37:36.266] Resolving globals: FALSE
[17:37:36.267] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:37:36.268] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:37:36.268] - globals: [1] ‘FUN’
[17:37:36.268] 
[17:37:36.268] getGlobalsAndPackages() ... DONE
[17:37:36.268]  - globals found/used: [n=1] ‘FUN’
[17:37:36.269]  - needed namespaces: [n=0] 
[17:37:36.269] Finding globals ... DONE
[17:37:36.269] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:36.269] List of 2
[17:37:36.269]  $ ...future.FUN:function (C, k)  
[17:37:36.269]  $ MoreArgs     : list()
[17:37:36.269]  - attr(*, "where")=List of 2
[17:37:36.269]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:36.269]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:36.269]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.269]  - attr(*, "resolved")= logi FALSE
[17:37:36.269]  - attr(*, "total_size")= num NA
[17:37:36.273] Packages to be attached in all futures: [n=0] 
[17:37:36.273] getGlobalsAndPackagesXApply() ... DONE
[17:37:36.274] Number of futures (= number of chunks): 2
[17:37:36.274] Launching 2 futures (chunks) ...
[17:37:36.274] Chunk #1 of 2 ...
[17:37:36.274]  - Finding globals in '...' for chunk #1 ...
[17:37:36.274] getGlobalsAndPackages() ...
[17:37:36.274] Searching for globals...
[17:37:36.275] 
[17:37:36.275] Searching for globals ... DONE
[17:37:36.275] - globals: [0] <none>
[17:37:36.275] getGlobalsAndPackages() ... DONE
[17:37:36.275]    + additional globals found: [n=0] 
[17:37:36.275]    + additional namespaces needed: [n=0] 
[17:37:36.275]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:36.275]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:36.275]  - seeds: <none>
[17:37:36.275]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.276] getGlobalsAndPackages() ...
[17:37:36.276] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.276] Resolving globals: FALSE
[17:37:36.276] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:37:36.277] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:36.277] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.277] 
[17:37:36.277] getGlobalsAndPackages() ... DONE
[17:37:36.277] run() for ‘Future’ ...
[17:37:36.278] - state: ‘created’
[17:37:36.278] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:36.282] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.282] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:36.282]   - Field: ‘label’
[17:37:36.282]   - Field: ‘local’
[17:37:36.283]   - Field: ‘owner’
[17:37:36.283]   - Field: ‘envir’
[17:37:36.283]   - Field: ‘workers’
[17:37:36.283]   - Field: ‘packages’
[17:37:36.283]   - Field: ‘gc’
[17:37:36.283]   - Field: ‘job’
[17:37:36.283]   - Field: ‘conditions’
[17:37:36.283]   - Field: ‘expr’
[17:37:36.283]   - Field: ‘uuid’
[17:37:36.283]   - Field: ‘seed’
[17:37:36.284]   - Field: ‘version’
[17:37:36.284]   - Field: ‘result’
[17:37:36.284]   - Field: ‘asynchronous’
[17:37:36.284]   - Field: ‘calls’
[17:37:36.284]   - Field: ‘globals’
[17:37:36.284]   - Field: ‘stdout’
[17:37:36.284]   - Field: ‘earlySignal’
[17:37:36.284]   - Field: ‘lazy’
[17:37:36.284]   - Field: ‘state’
[17:37:36.285] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:36.285] - Launch lazy future ...
[17:37:36.285] Packages needed by the future expression (n = 0): <none>
[17:37:36.285] Packages needed by future strategies (n = 0): <none>
[17:37:36.286] {
[17:37:36.286]     {
[17:37:36.286]         {
[17:37:36.286]             ...future.startTime <- base::Sys.time()
[17:37:36.286]             {
[17:37:36.286]                 {
[17:37:36.286]                   {
[17:37:36.286]                     {
[17:37:36.286]                       base::local({
[17:37:36.286]                         has_future <- base::requireNamespace("future", 
[17:37:36.286]                           quietly = TRUE)
[17:37:36.286]                         if (has_future) {
[17:37:36.286]                           ns <- base::getNamespace("future")
[17:37:36.286]                           version <- ns[[".package"]][["version"]]
[17:37:36.286]                           if (is.null(version)) 
[17:37:36.286]                             version <- utils::packageVersion("future")
[17:37:36.286]                         }
[17:37:36.286]                         else {
[17:37:36.286]                           version <- NULL
[17:37:36.286]                         }
[17:37:36.286]                         if (!has_future || version < "1.8.0") {
[17:37:36.286]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:36.286]                             "", base::R.version$version.string), 
[17:37:36.286]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:36.286]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:36.286]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:36.286]                               "release", "version")], collapse = " "), 
[17:37:36.286]                             hostname = base::Sys.info()[["nodename"]])
[17:37:36.286]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:36.286]                             info)
[17:37:36.286]                           info <- base::paste(info, collapse = "; ")
[17:37:36.286]                           if (!has_future) {
[17:37:36.286]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:36.286]                               info)
[17:37:36.286]                           }
[17:37:36.286]                           else {
[17:37:36.286]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:36.286]                               info, version)
[17:37:36.286]                           }
[17:37:36.286]                           base::stop(msg)
[17:37:36.286]                         }
[17:37:36.286]                       })
[17:37:36.286]                     }
[17:37:36.286]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:36.286]                     base::options(mc.cores = 1L)
[17:37:36.286]                   }
[17:37:36.286]                   ...future.strategy.old <- future::plan("list")
[17:37:36.286]                   options(future.plan = NULL)
[17:37:36.286]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.286]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:36.286]                 }
[17:37:36.286]                 ...future.workdir <- getwd()
[17:37:36.286]             }
[17:37:36.286]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:36.286]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:36.286]         }
[17:37:36.286]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:36.286]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:36.286]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:36.286]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:36.286]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:36.286]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:36.286]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:36.286]             base::names(...future.oldOptions))
[17:37:36.286]     }
[17:37:36.286]     if (FALSE) {
[17:37:36.286]     }
[17:37:36.286]     else {
[17:37:36.286]         if (TRUE) {
[17:37:36.286]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:36.286]                 open = "w")
[17:37:36.286]         }
[17:37:36.286]         else {
[17:37:36.286]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:36.286]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:36.286]         }
[17:37:36.286]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:36.286]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:36.286]             base::sink(type = "output", split = FALSE)
[17:37:36.286]             base::close(...future.stdout)
[17:37:36.286]         }, add = TRUE)
[17:37:36.286]     }
[17:37:36.286]     ...future.frame <- base::sys.nframe()
[17:37:36.286]     ...future.conditions <- base::list()
[17:37:36.286]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:36.286]     if (FALSE) {
[17:37:36.286]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:36.286]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:36.286]     }
[17:37:36.286]     ...future.result <- base::tryCatch({
[17:37:36.286]         base::withCallingHandlers({
[17:37:36.286]             ...future.value <- base::withVisible(base::local({
[17:37:36.286]                 withCallingHandlers({
[17:37:36.286]                   {
[17:37:36.286]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.286]                     if (!identical(...future.globals.maxSize.org, 
[17:37:36.286]                       ...future.globals.maxSize)) {
[17:37:36.286]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.286]                       on.exit(options(oopts), add = TRUE)
[17:37:36.286]                     }
[17:37:36.286]                     {
[17:37:36.286]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.286]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:36.286]                         USE.NAMES = FALSE)
[17:37:36.286]                       do.call(mapply, args = args)
[17:37:36.286]                     }
[17:37:36.286]                   }
[17:37:36.286]                 }, immediateCondition = function(cond) {
[17:37:36.286]                   save_rds <- function (object, pathname, ...) 
[17:37:36.286]                   {
[17:37:36.286]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:36.286]                     if (file_test("-f", pathname_tmp)) {
[17:37:36.286]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.286]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:36.286]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.286]                         fi_tmp[["mtime"]])
[17:37:36.286]                     }
[17:37:36.286]                     tryCatch({
[17:37:36.286]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:36.286]                     }, error = function(ex) {
[17:37:36.286]                       msg <- conditionMessage(ex)
[17:37:36.286]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.286]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:36.286]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.286]                         fi_tmp[["mtime"]], msg)
[17:37:36.286]                       ex$message <- msg
[17:37:36.286]                       stop(ex)
[17:37:36.286]                     })
[17:37:36.286]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:36.286]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:36.286]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:36.286]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.286]                       fi <- file.info(pathname)
[17:37:36.286]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:36.286]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.286]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:36.286]                         fi[["size"]], fi[["mtime"]])
[17:37:36.286]                       stop(msg)
[17:37:36.286]                     }
[17:37:36.286]                     invisible(pathname)
[17:37:36.286]                   }
[17:37:36.286]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:36.286]                     rootPath = tempdir()) 
[17:37:36.286]                   {
[17:37:36.286]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:36.286]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:36.286]                       tmpdir = path, fileext = ".rds")
[17:37:36.286]                     save_rds(obj, file)
[17:37:36.286]                   }
[17:37:36.286]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:36.286]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.286]                   {
[17:37:36.286]                     inherits <- base::inherits
[17:37:36.286]                     invokeRestart <- base::invokeRestart
[17:37:36.286]                     is.null <- base::is.null
[17:37:36.286]                     muffled <- FALSE
[17:37:36.286]                     if (inherits(cond, "message")) {
[17:37:36.286]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:36.286]                       if (muffled) 
[17:37:36.286]                         invokeRestart("muffleMessage")
[17:37:36.286]                     }
[17:37:36.286]                     else if (inherits(cond, "warning")) {
[17:37:36.286]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:36.286]                       if (muffled) 
[17:37:36.286]                         invokeRestart("muffleWarning")
[17:37:36.286]                     }
[17:37:36.286]                     else if (inherits(cond, "condition")) {
[17:37:36.286]                       if (!is.null(pattern)) {
[17:37:36.286]                         computeRestarts <- base::computeRestarts
[17:37:36.286]                         grepl <- base::grepl
[17:37:36.286]                         restarts <- computeRestarts(cond)
[17:37:36.286]                         for (restart in restarts) {
[17:37:36.286]                           name <- restart$name
[17:37:36.286]                           if (is.null(name)) 
[17:37:36.286]                             next
[17:37:36.286]                           if (!grepl(pattern, name)) 
[17:37:36.286]                             next
[17:37:36.286]                           invokeRestart(restart)
[17:37:36.286]                           muffled <- TRUE
[17:37:36.286]                           break
[17:37:36.286]                         }
[17:37:36.286]                       }
[17:37:36.286]                     }
[17:37:36.286]                     invisible(muffled)
[17:37:36.286]                   }
[17:37:36.286]                   muffleCondition(cond)
[17:37:36.286]                 })
[17:37:36.286]             }))
[17:37:36.286]             future::FutureResult(value = ...future.value$value, 
[17:37:36.286]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.286]                   ...future.rng), globalenv = if (FALSE) 
[17:37:36.286]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:36.286]                     ...future.globalenv.names))
[17:37:36.286]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:36.286]         }, condition = base::local({
[17:37:36.286]             c <- base::c
[17:37:36.286]             inherits <- base::inherits
[17:37:36.286]             invokeRestart <- base::invokeRestart
[17:37:36.286]             length <- base::length
[17:37:36.286]             list <- base::list
[17:37:36.286]             seq.int <- base::seq.int
[17:37:36.286]             signalCondition <- base::signalCondition
[17:37:36.286]             sys.calls <- base::sys.calls
[17:37:36.286]             `[[` <- base::`[[`
[17:37:36.286]             `+` <- base::`+`
[17:37:36.286]             `<<-` <- base::`<<-`
[17:37:36.286]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:36.286]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:36.286]                   3L)]
[17:37:36.286]             }
[17:37:36.286]             function(cond) {
[17:37:36.286]                 is_error <- inherits(cond, "error")
[17:37:36.286]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:36.286]                   NULL)
[17:37:36.286]                 if (is_error) {
[17:37:36.286]                   sessionInformation <- function() {
[17:37:36.286]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:36.286]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:36.286]                       search = base::search(), system = base::Sys.info())
[17:37:36.286]                   }
[17:37:36.286]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.286]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:36.286]                     cond$call), session = sessionInformation(), 
[17:37:36.286]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:36.286]                   signalCondition(cond)
[17:37:36.286]                 }
[17:37:36.286]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:36.286]                 "immediateCondition"))) {
[17:37:36.286]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:36.286]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.286]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:36.286]                   if (TRUE && !signal) {
[17:37:36.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.286]                     {
[17:37:36.286]                       inherits <- base::inherits
[17:37:36.286]                       invokeRestart <- base::invokeRestart
[17:37:36.286]                       is.null <- base::is.null
[17:37:36.286]                       muffled <- FALSE
[17:37:36.286]                       if (inherits(cond, "message")) {
[17:37:36.286]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.286]                         if (muffled) 
[17:37:36.286]                           invokeRestart("muffleMessage")
[17:37:36.286]                       }
[17:37:36.286]                       else if (inherits(cond, "warning")) {
[17:37:36.286]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.286]                         if (muffled) 
[17:37:36.286]                           invokeRestart("muffleWarning")
[17:37:36.286]                       }
[17:37:36.286]                       else if (inherits(cond, "condition")) {
[17:37:36.286]                         if (!is.null(pattern)) {
[17:37:36.286]                           computeRestarts <- base::computeRestarts
[17:37:36.286]                           grepl <- base::grepl
[17:37:36.286]                           restarts <- computeRestarts(cond)
[17:37:36.286]                           for (restart in restarts) {
[17:37:36.286]                             name <- restart$name
[17:37:36.286]                             if (is.null(name)) 
[17:37:36.286]                               next
[17:37:36.286]                             if (!grepl(pattern, name)) 
[17:37:36.286]                               next
[17:37:36.286]                             invokeRestart(restart)
[17:37:36.286]                             muffled <- TRUE
[17:37:36.286]                             break
[17:37:36.286]                           }
[17:37:36.286]                         }
[17:37:36.286]                       }
[17:37:36.286]                       invisible(muffled)
[17:37:36.286]                     }
[17:37:36.286]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.286]                   }
[17:37:36.286]                 }
[17:37:36.286]                 else {
[17:37:36.286]                   if (TRUE) {
[17:37:36.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.286]                     {
[17:37:36.286]                       inherits <- base::inherits
[17:37:36.286]                       invokeRestart <- base::invokeRestart
[17:37:36.286]                       is.null <- base::is.null
[17:37:36.286]                       muffled <- FALSE
[17:37:36.286]                       if (inherits(cond, "message")) {
[17:37:36.286]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.286]                         if (muffled) 
[17:37:36.286]                           invokeRestart("muffleMessage")
[17:37:36.286]                       }
[17:37:36.286]                       else if (inherits(cond, "warning")) {
[17:37:36.286]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.286]                         if (muffled) 
[17:37:36.286]                           invokeRestart("muffleWarning")
[17:37:36.286]                       }
[17:37:36.286]                       else if (inherits(cond, "condition")) {
[17:37:36.286]                         if (!is.null(pattern)) {
[17:37:36.286]                           computeRestarts <- base::computeRestarts
[17:37:36.286]                           grepl <- base::grepl
[17:37:36.286]                           restarts <- computeRestarts(cond)
[17:37:36.286]                           for (restart in restarts) {
[17:37:36.286]                             name <- restart$name
[17:37:36.286]                             if (is.null(name)) 
[17:37:36.286]                               next
[17:37:36.286]                             if (!grepl(pattern, name)) 
[17:37:36.286]                               next
[17:37:36.286]                             invokeRestart(restart)
[17:37:36.286]                             muffled <- TRUE
[17:37:36.286]                             break
[17:37:36.286]                           }
[17:37:36.286]                         }
[17:37:36.286]                       }
[17:37:36.286]                       invisible(muffled)
[17:37:36.286]                     }
[17:37:36.286]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.286]                   }
[17:37:36.286]                 }
[17:37:36.286]             }
[17:37:36.286]         }))
[17:37:36.286]     }, error = function(ex) {
[17:37:36.286]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:36.286]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.286]                 ...future.rng), started = ...future.startTime, 
[17:37:36.286]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:36.286]             version = "1.8"), class = "FutureResult")
[17:37:36.286]     }, finally = {
[17:37:36.286]         if (!identical(...future.workdir, getwd())) 
[17:37:36.286]             setwd(...future.workdir)
[17:37:36.286]         {
[17:37:36.286]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:36.286]                 ...future.oldOptions$nwarnings <- NULL
[17:37:36.286]             }
[17:37:36.286]             base::options(...future.oldOptions)
[17:37:36.286]             if (.Platform$OS.type == "windows") {
[17:37:36.286]                 old_names <- names(...future.oldEnvVars)
[17:37:36.286]                 envs <- base::Sys.getenv()
[17:37:36.286]                 names <- names(envs)
[17:37:36.286]                 common <- intersect(names, old_names)
[17:37:36.286]                 added <- setdiff(names, old_names)
[17:37:36.286]                 removed <- setdiff(old_names, names)
[17:37:36.286]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:36.286]                   envs[common]]
[17:37:36.286]                 NAMES <- toupper(changed)
[17:37:36.286]                 args <- list()
[17:37:36.286]                 for (kk in seq_along(NAMES)) {
[17:37:36.286]                   name <- changed[[kk]]
[17:37:36.286]                   NAME <- NAMES[[kk]]
[17:37:36.286]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.286]                     next
[17:37:36.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.286]                 }
[17:37:36.286]                 NAMES <- toupper(added)
[17:37:36.286]                 for (kk in seq_along(NAMES)) {
[17:37:36.286]                   name <- added[[kk]]
[17:37:36.286]                   NAME <- NAMES[[kk]]
[17:37:36.286]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.286]                     next
[17:37:36.286]                   args[[name]] <- ""
[17:37:36.286]                 }
[17:37:36.286]                 NAMES <- toupper(removed)
[17:37:36.286]                 for (kk in seq_along(NAMES)) {
[17:37:36.286]                   name <- removed[[kk]]
[17:37:36.286]                   NAME <- NAMES[[kk]]
[17:37:36.286]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.286]                     next
[17:37:36.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.286]                 }
[17:37:36.286]                 if (length(args) > 0) 
[17:37:36.286]                   base::do.call(base::Sys.setenv, args = args)
[17:37:36.286]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:36.286]             }
[17:37:36.286]             else {
[17:37:36.286]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:36.286]             }
[17:37:36.286]             {
[17:37:36.286]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:36.286]                   0L) {
[17:37:36.286]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:36.286]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:36.286]                   base::options(opts)
[17:37:36.286]                 }
[17:37:36.286]                 {
[17:37:36.286]                   {
[17:37:36.286]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:36.286]                     NULL
[17:37:36.286]                   }
[17:37:36.286]                   options(future.plan = NULL)
[17:37:36.286]                   if (is.na(NA_character_)) 
[17:37:36.286]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.286]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:36.286]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:36.286]                     .init = FALSE)
[17:37:36.286]                 }
[17:37:36.286]             }
[17:37:36.286]         }
[17:37:36.286]     })
[17:37:36.286]     if (TRUE) {
[17:37:36.286]         base::sink(type = "output", split = FALSE)
[17:37:36.286]         if (TRUE) {
[17:37:36.286]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:36.286]         }
[17:37:36.286]         else {
[17:37:36.286]             ...future.result["stdout"] <- base::list(NULL)
[17:37:36.286]         }
[17:37:36.286]         base::close(...future.stdout)
[17:37:36.286]         ...future.stdout <- NULL
[17:37:36.286]     }
[17:37:36.286]     ...future.result$conditions <- ...future.conditions
[17:37:36.286]     ...future.result$finished <- base::Sys.time()
[17:37:36.286]     ...future.result
[17:37:36.286] }
[17:37:36.288] assign_globals() ...
[17:37:36.288] List of 5
[17:37:36.288]  $ ...future.FUN            :function (C, k)  
[17:37:36.288]  $ MoreArgs                 : list()
[17:37:36.288]  $ ...future.elements_ii    :List of 2
[17:37:36.288]   ..$ :List of 2
[17:37:36.288]   .. ..$ : chr "A"
[17:37:36.288]   .. ..$ : chr "B"
[17:37:36.288]   ..$ :List of 2
[17:37:36.288]   .. ..$ : int 5
[17:37:36.288]   .. ..$ : int 4
[17:37:36.288]  $ ...future.seeds_ii       : NULL
[17:37:36.288]  $ ...future.globals.maxSize: NULL
[17:37:36.288]  - attr(*, "where")=List of 5
[17:37:36.288]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:36.288]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:36.288]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:36.288]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:36.288]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:36.288]  - attr(*, "resolved")= logi FALSE
[17:37:36.288]  - attr(*, "total_size")= num 3656
[17:37:36.288]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.288]  - attr(*, "already-done")= logi TRUE
[17:37:36.297] - reassign environment for ‘...future.FUN’
[17:37:36.297] - copied ‘...future.FUN’ to environment
[17:37:36.297] - copied ‘MoreArgs’ to environment
[17:37:36.297] - copied ‘...future.elements_ii’ to environment
[17:37:36.297] - copied ‘...future.seeds_ii’ to environment
[17:37:36.297] - copied ‘...future.globals.maxSize’ to environment
[17:37:36.297] assign_globals() ... done
[17:37:36.298] requestCore(): workers = 2
[17:37:36.300] MulticoreFuture started
[17:37:36.301] - Launch lazy future ... done
[17:37:36.302] plan(): Setting new future strategy stack:
[17:37:36.302] run() for ‘MulticoreFuture’ ... done
[17:37:36.302] Created future:
[17:37:36.302] List of future strategies:
[17:37:36.302] 1. sequential:
[17:37:36.302]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:36.302]    - tweaked: FALSE
[17:37:36.302]    - call: NULL
[17:37:36.304] plan(): nbrOfWorkers() = 1
[17:37:36.307] plan(): Setting new future strategy stack:
[17:37:36.307] List of future strategies:
[17:37:36.307] 1. multicore:
[17:37:36.307]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:36.307]    - tweaked: FALSE
[17:37:36.307]    - call: plan(strategy)
[17:37:36.314] plan(): nbrOfWorkers() = 2
[17:37:36.303] MulticoreFuture:
[17:37:36.303] Label: ‘future_.mapply-1’
[17:37:36.303] Expression:
[17:37:36.303] {
[17:37:36.303]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.303]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:36.303]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.303]         on.exit(options(oopts), add = TRUE)
[17:37:36.303]     }
[17:37:36.303]     {
[17:37:36.303]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.303]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:36.303]         do.call(mapply, args = args)
[17:37:36.303]     }
[17:37:36.303] }
[17:37:36.303] Lazy evaluation: FALSE
[17:37:36.303] Asynchronous evaluation: TRUE
[17:37:36.303] Local evaluation: TRUE
[17:37:36.303] Environment: R_GlobalEnv
[17:37:36.303] Capture standard output: TRUE
[17:37:36.303] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:36.303] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:36.303] Packages: <none>
[17:37:36.303] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:36.303] Resolved: TRUE
[17:37:36.303] Value: <not collected>
[17:37:36.303] Conditions captured: <none>
[17:37:36.303] Early signaling: FALSE
[17:37:36.303] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:36.303] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.315] Chunk #1 of 2 ... DONE
[17:37:36.315] Chunk #2 of 2 ...
[17:37:36.316]  - Finding globals in '...' for chunk #2 ...
[17:37:36.316] getGlobalsAndPackages() ...
[17:37:36.316] Searching for globals...
[17:37:36.317] 
[17:37:36.317] Searching for globals ... DONE
[17:37:36.317] - globals: [0] <none>
[17:37:36.318] getGlobalsAndPackages() ... DONE
[17:37:36.318]    + additional globals found: [n=0] 
[17:37:36.318]    + additional namespaces needed: [n=0] 
[17:37:36.318]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:36.318]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:36.318]  - seeds: <none>
[17:37:36.319]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.319] getGlobalsAndPackages() ...
[17:37:36.319] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.320] Resolving globals: FALSE
[17:37:36.320] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:37:36.321] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:36.321] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.321] 
[17:37:36.322] getGlobalsAndPackages() ... DONE
[17:37:36.322] run() for ‘Future’ ...
[17:37:36.322] - state: ‘created’
[17:37:36.323] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:36.327] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.328] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:36.328]   - Field: ‘label’
[17:37:36.328]   - Field: ‘local’
[17:37:36.328]   - Field: ‘owner’
[17:37:36.328]   - Field: ‘envir’
[17:37:36.329]   - Field: ‘workers’
[17:37:36.329]   - Field: ‘packages’
[17:37:36.329]   - Field: ‘gc’
[17:37:36.329]   - Field: ‘job’
[17:37:36.329]   - Field: ‘conditions’
[17:37:36.329]   - Field: ‘expr’
[17:37:36.329]   - Field: ‘uuid’
[17:37:36.329]   - Field: ‘seed’
[17:37:36.330]   - Field: ‘version’
[17:37:36.330]   - Field: ‘result’
[17:37:36.330]   - Field: ‘asynchronous’
[17:37:36.330]   - Field: ‘calls’
[17:37:36.330]   - Field: ‘globals’
[17:37:36.330]   - Field: ‘stdout’
[17:37:36.330]   - Field: ‘earlySignal’
[17:37:36.330]   - Field: ‘lazy’
[17:37:36.331]   - Field: ‘state’
[17:37:36.331] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:36.331] - Launch lazy future ...
[17:37:36.331] Packages needed by the future expression (n = 0): <none>
[17:37:36.331] Packages needed by future strategies (n = 0): <none>
[17:37:36.332] {
[17:37:36.332]     {
[17:37:36.332]         {
[17:37:36.332]             ...future.startTime <- base::Sys.time()
[17:37:36.332]             {
[17:37:36.332]                 {
[17:37:36.332]                   {
[17:37:36.332]                     {
[17:37:36.332]                       base::local({
[17:37:36.332]                         has_future <- base::requireNamespace("future", 
[17:37:36.332]                           quietly = TRUE)
[17:37:36.332]                         if (has_future) {
[17:37:36.332]                           ns <- base::getNamespace("future")
[17:37:36.332]                           version <- ns[[".package"]][["version"]]
[17:37:36.332]                           if (is.null(version)) 
[17:37:36.332]                             version <- utils::packageVersion("future")
[17:37:36.332]                         }
[17:37:36.332]                         else {
[17:37:36.332]                           version <- NULL
[17:37:36.332]                         }
[17:37:36.332]                         if (!has_future || version < "1.8.0") {
[17:37:36.332]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:36.332]                             "", base::R.version$version.string), 
[17:37:36.332]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:36.332]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:36.332]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:36.332]                               "release", "version")], collapse = " "), 
[17:37:36.332]                             hostname = base::Sys.info()[["nodename"]])
[17:37:36.332]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:36.332]                             info)
[17:37:36.332]                           info <- base::paste(info, collapse = "; ")
[17:37:36.332]                           if (!has_future) {
[17:37:36.332]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:36.332]                               info)
[17:37:36.332]                           }
[17:37:36.332]                           else {
[17:37:36.332]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:36.332]                               info, version)
[17:37:36.332]                           }
[17:37:36.332]                           base::stop(msg)
[17:37:36.332]                         }
[17:37:36.332]                       })
[17:37:36.332]                     }
[17:37:36.332]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:36.332]                     base::options(mc.cores = 1L)
[17:37:36.332]                   }
[17:37:36.332]                   ...future.strategy.old <- future::plan("list")
[17:37:36.332]                   options(future.plan = NULL)
[17:37:36.332]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.332]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:36.332]                 }
[17:37:36.332]                 ...future.workdir <- getwd()
[17:37:36.332]             }
[17:37:36.332]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:36.332]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:36.332]         }
[17:37:36.332]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:36.332]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:36.332]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:36.332]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:36.332]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:36.332]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:36.332]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:36.332]             base::names(...future.oldOptions))
[17:37:36.332]     }
[17:37:36.332]     if (FALSE) {
[17:37:36.332]     }
[17:37:36.332]     else {
[17:37:36.332]         if (TRUE) {
[17:37:36.332]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:36.332]                 open = "w")
[17:37:36.332]         }
[17:37:36.332]         else {
[17:37:36.332]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:36.332]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:36.332]         }
[17:37:36.332]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:36.332]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:36.332]             base::sink(type = "output", split = FALSE)
[17:37:36.332]             base::close(...future.stdout)
[17:37:36.332]         }, add = TRUE)
[17:37:36.332]     }
[17:37:36.332]     ...future.frame <- base::sys.nframe()
[17:37:36.332]     ...future.conditions <- base::list()
[17:37:36.332]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:36.332]     if (FALSE) {
[17:37:36.332]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:36.332]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:36.332]     }
[17:37:36.332]     ...future.result <- base::tryCatch({
[17:37:36.332]         base::withCallingHandlers({
[17:37:36.332]             ...future.value <- base::withVisible(base::local({
[17:37:36.332]                 withCallingHandlers({
[17:37:36.332]                   {
[17:37:36.332]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.332]                     if (!identical(...future.globals.maxSize.org, 
[17:37:36.332]                       ...future.globals.maxSize)) {
[17:37:36.332]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.332]                       on.exit(options(oopts), add = TRUE)
[17:37:36.332]                     }
[17:37:36.332]                     {
[17:37:36.332]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.332]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:36.332]                         USE.NAMES = FALSE)
[17:37:36.332]                       do.call(mapply, args = args)
[17:37:36.332]                     }
[17:37:36.332]                   }
[17:37:36.332]                 }, immediateCondition = function(cond) {
[17:37:36.332]                   save_rds <- function (object, pathname, ...) 
[17:37:36.332]                   {
[17:37:36.332]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:36.332]                     if (file_test("-f", pathname_tmp)) {
[17:37:36.332]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.332]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:36.332]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.332]                         fi_tmp[["mtime"]])
[17:37:36.332]                     }
[17:37:36.332]                     tryCatch({
[17:37:36.332]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:36.332]                     }, error = function(ex) {
[17:37:36.332]                       msg <- conditionMessage(ex)
[17:37:36.332]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.332]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:36.332]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.332]                         fi_tmp[["mtime"]], msg)
[17:37:36.332]                       ex$message <- msg
[17:37:36.332]                       stop(ex)
[17:37:36.332]                     })
[17:37:36.332]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:36.332]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:36.332]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:36.332]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.332]                       fi <- file.info(pathname)
[17:37:36.332]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:36.332]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.332]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:36.332]                         fi[["size"]], fi[["mtime"]])
[17:37:36.332]                       stop(msg)
[17:37:36.332]                     }
[17:37:36.332]                     invisible(pathname)
[17:37:36.332]                   }
[17:37:36.332]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:36.332]                     rootPath = tempdir()) 
[17:37:36.332]                   {
[17:37:36.332]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:36.332]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:36.332]                       tmpdir = path, fileext = ".rds")
[17:37:36.332]                     save_rds(obj, file)
[17:37:36.332]                   }
[17:37:36.332]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:36.332]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.332]                   {
[17:37:36.332]                     inherits <- base::inherits
[17:37:36.332]                     invokeRestart <- base::invokeRestart
[17:37:36.332]                     is.null <- base::is.null
[17:37:36.332]                     muffled <- FALSE
[17:37:36.332]                     if (inherits(cond, "message")) {
[17:37:36.332]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:36.332]                       if (muffled) 
[17:37:36.332]                         invokeRestart("muffleMessage")
[17:37:36.332]                     }
[17:37:36.332]                     else if (inherits(cond, "warning")) {
[17:37:36.332]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:36.332]                       if (muffled) 
[17:37:36.332]                         invokeRestart("muffleWarning")
[17:37:36.332]                     }
[17:37:36.332]                     else if (inherits(cond, "condition")) {
[17:37:36.332]                       if (!is.null(pattern)) {
[17:37:36.332]                         computeRestarts <- base::computeRestarts
[17:37:36.332]                         grepl <- base::grepl
[17:37:36.332]                         restarts <- computeRestarts(cond)
[17:37:36.332]                         for (restart in restarts) {
[17:37:36.332]                           name <- restart$name
[17:37:36.332]                           if (is.null(name)) 
[17:37:36.332]                             next
[17:37:36.332]                           if (!grepl(pattern, name)) 
[17:37:36.332]                             next
[17:37:36.332]                           invokeRestart(restart)
[17:37:36.332]                           muffled <- TRUE
[17:37:36.332]                           break
[17:37:36.332]                         }
[17:37:36.332]                       }
[17:37:36.332]                     }
[17:37:36.332]                     invisible(muffled)
[17:37:36.332]                   }
[17:37:36.332]                   muffleCondition(cond)
[17:37:36.332]                 })
[17:37:36.332]             }))
[17:37:36.332]             future::FutureResult(value = ...future.value$value, 
[17:37:36.332]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.332]                   ...future.rng), globalenv = if (FALSE) 
[17:37:36.332]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:36.332]                     ...future.globalenv.names))
[17:37:36.332]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:36.332]         }, condition = base::local({
[17:37:36.332]             c <- base::c
[17:37:36.332]             inherits <- base::inherits
[17:37:36.332]             invokeRestart <- base::invokeRestart
[17:37:36.332]             length <- base::length
[17:37:36.332]             list <- base::list
[17:37:36.332]             seq.int <- base::seq.int
[17:37:36.332]             signalCondition <- base::signalCondition
[17:37:36.332]             sys.calls <- base::sys.calls
[17:37:36.332]             `[[` <- base::`[[`
[17:37:36.332]             `+` <- base::`+`
[17:37:36.332]             `<<-` <- base::`<<-`
[17:37:36.332]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:36.332]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:36.332]                   3L)]
[17:37:36.332]             }
[17:37:36.332]             function(cond) {
[17:37:36.332]                 is_error <- inherits(cond, "error")
[17:37:36.332]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:36.332]                   NULL)
[17:37:36.332]                 if (is_error) {
[17:37:36.332]                   sessionInformation <- function() {
[17:37:36.332]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:36.332]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:36.332]                       search = base::search(), system = base::Sys.info())
[17:37:36.332]                   }
[17:37:36.332]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.332]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:36.332]                     cond$call), session = sessionInformation(), 
[17:37:36.332]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:36.332]                   signalCondition(cond)
[17:37:36.332]                 }
[17:37:36.332]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:36.332]                 "immediateCondition"))) {
[17:37:36.332]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:36.332]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.332]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:36.332]                   if (TRUE && !signal) {
[17:37:36.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.332]                     {
[17:37:36.332]                       inherits <- base::inherits
[17:37:36.332]                       invokeRestart <- base::invokeRestart
[17:37:36.332]                       is.null <- base::is.null
[17:37:36.332]                       muffled <- FALSE
[17:37:36.332]                       if (inherits(cond, "message")) {
[17:37:36.332]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.332]                         if (muffled) 
[17:37:36.332]                           invokeRestart("muffleMessage")
[17:37:36.332]                       }
[17:37:36.332]                       else if (inherits(cond, "warning")) {
[17:37:36.332]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.332]                         if (muffled) 
[17:37:36.332]                           invokeRestart("muffleWarning")
[17:37:36.332]                       }
[17:37:36.332]                       else if (inherits(cond, "condition")) {
[17:37:36.332]                         if (!is.null(pattern)) {
[17:37:36.332]                           computeRestarts <- base::computeRestarts
[17:37:36.332]                           grepl <- base::grepl
[17:37:36.332]                           restarts <- computeRestarts(cond)
[17:37:36.332]                           for (restart in restarts) {
[17:37:36.332]                             name <- restart$name
[17:37:36.332]                             if (is.null(name)) 
[17:37:36.332]                               next
[17:37:36.332]                             if (!grepl(pattern, name)) 
[17:37:36.332]                               next
[17:37:36.332]                             invokeRestart(restart)
[17:37:36.332]                             muffled <- TRUE
[17:37:36.332]                             break
[17:37:36.332]                           }
[17:37:36.332]                         }
[17:37:36.332]                       }
[17:37:36.332]                       invisible(muffled)
[17:37:36.332]                     }
[17:37:36.332]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.332]                   }
[17:37:36.332]                 }
[17:37:36.332]                 else {
[17:37:36.332]                   if (TRUE) {
[17:37:36.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.332]                     {
[17:37:36.332]                       inherits <- base::inherits
[17:37:36.332]                       invokeRestart <- base::invokeRestart
[17:37:36.332]                       is.null <- base::is.null
[17:37:36.332]                       muffled <- FALSE
[17:37:36.332]                       if (inherits(cond, "message")) {
[17:37:36.332]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.332]                         if (muffled) 
[17:37:36.332]                           invokeRestart("muffleMessage")
[17:37:36.332]                       }
[17:37:36.332]                       else if (inherits(cond, "warning")) {
[17:37:36.332]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.332]                         if (muffled) 
[17:37:36.332]                           invokeRestart("muffleWarning")
[17:37:36.332]                       }
[17:37:36.332]                       else if (inherits(cond, "condition")) {
[17:37:36.332]                         if (!is.null(pattern)) {
[17:37:36.332]                           computeRestarts <- base::computeRestarts
[17:37:36.332]                           grepl <- base::grepl
[17:37:36.332]                           restarts <- computeRestarts(cond)
[17:37:36.332]                           for (restart in restarts) {
[17:37:36.332]                             name <- restart$name
[17:37:36.332]                             if (is.null(name)) 
[17:37:36.332]                               next
[17:37:36.332]                             if (!grepl(pattern, name)) 
[17:37:36.332]                               next
[17:37:36.332]                             invokeRestart(restart)
[17:37:36.332]                             muffled <- TRUE
[17:37:36.332]                             break
[17:37:36.332]                           }
[17:37:36.332]                         }
[17:37:36.332]                       }
[17:37:36.332]                       invisible(muffled)
[17:37:36.332]                     }
[17:37:36.332]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.332]                   }
[17:37:36.332]                 }
[17:37:36.332]             }
[17:37:36.332]         }))
[17:37:36.332]     }, error = function(ex) {
[17:37:36.332]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:36.332]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.332]                 ...future.rng), started = ...future.startTime, 
[17:37:36.332]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:36.332]             version = "1.8"), class = "FutureResult")
[17:37:36.332]     }, finally = {
[17:37:36.332]         if (!identical(...future.workdir, getwd())) 
[17:37:36.332]             setwd(...future.workdir)
[17:37:36.332]         {
[17:37:36.332]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:36.332]                 ...future.oldOptions$nwarnings <- NULL
[17:37:36.332]             }
[17:37:36.332]             base::options(...future.oldOptions)
[17:37:36.332]             if (.Platform$OS.type == "windows") {
[17:37:36.332]                 old_names <- names(...future.oldEnvVars)
[17:37:36.332]                 envs <- base::Sys.getenv()
[17:37:36.332]                 names <- names(envs)
[17:37:36.332]                 common <- intersect(names, old_names)
[17:37:36.332]                 added <- setdiff(names, old_names)
[17:37:36.332]                 removed <- setdiff(old_names, names)
[17:37:36.332]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:36.332]                   envs[common]]
[17:37:36.332]                 NAMES <- toupper(changed)
[17:37:36.332]                 args <- list()
[17:37:36.332]                 for (kk in seq_along(NAMES)) {
[17:37:36.332]                   name <- changed[[kk]]
[17:37:36.332]                   NAME <- NAMES[[kk]]
[17:37:36.332]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.332]                     next
[17:37:36.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.332]                 }
[17:37:36.332]                 NAMES <- toupper(added)
[17:37:36.332]                 for (kk in seq_along(NAMES)) {
[17:37:36.332]                   name <- added[[kk]]
[17:37:36.332]                   NAME <- NAMES[[kk]]
[17:37:36.332]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.332]                     next
[17:37:36.332]                   args[[name]] <- ""
[17:37:36.332]                 }
[17:37:36.332]                 NAMES <- toupper(removed)
[17:37:36.332]                 for (kk in seq_along(NAMES)) {
[17:37:36.332]                   name <- removed[[kk]]
[17:37:36.332]                   NAME <- NAMES[[kk]]
[17:37:36.332]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.332]                     next
[17:37:36.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.332]                 }
[17:37:36.332]                 if (length(args) > 0) 
[17:37:36.332]                   base::do.call(base::Sys.setenv, args = args)
[17:37:36.332]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:36.332]             }
[17:37:36.332]             else {
[17:37:36.332]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:36.332]             }
[17:37:36.332]             {
[17:37:36.332]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:36.332]                   0L) {
[17:37:36.332]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:36.332]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:36.332]                   base::options(opts)
[17:37:36.332]                 }
[17:37:36.332]                 {
[17:37:36.332]                   {
[17:37:36.332]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:36.332]                     NULL
[17:37:36.332]                   }
[17:37:36.332]                   options(future.plan = NULL)
[17:37:36.332]                   if (is.na(NA_character_)) 
[17:37:36.332]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.332]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:36.332]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:36.332]                     .init = FALSE)
[17:37:36.332]                 }
[17:37:36.332]             }
[17:37:36.332]         }
[17:37:36.332]     })
[17:37:36.332]     if (TRUE) {
[17:37:36.332]         base::sink(type = "output", split = FALSE)
[17:37:36.332]         if (TRUE) {
[17:37:36.332]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:36.332]         }
[17:37:36.332]         else {
[17:37:36.332]             ...future.result["stdout"] <- base::list(NULL)
[17:37:36.332]         }
[17:37:36.332]         base::close(...future.stdout)
[17:37:36.332]         ...future.stdout <- NULL
[17:37:36.332]     }
[17:37:36.332]     ...future.result$conditions <- ...future.conditions
[17:37:36.332]     ...future.result$finished <- base::Sys.time()
[17:37:36.332]     ...future.result
[17:37:36.332] }
[17:37:36.335] assign_globals() ...
[17:37:36.336] List of 5
[17:37:36.336]  $ ...future.FUN            :function (C, k)  
[17:37:36.336]  $ MoreArgs                 : list()
[17:37:36.336]  $ ...future.elements_ii    :List of 2
[17:37:36.336]   ..$ :List of 3
[17:37:36.336]   .. ..$ : chr "C"
[17:37:36.336]   .. ..$ : chr "D"
[17:37:36.336]   .. ..$ : chr "E"
[17:37:36.336]   ..$ :List of 3
[17:37:36.336]   .. ..$ : int 3
[17:37:36.336]   .. ..$ : int 2
[17:37:36.336]   .. ..$ : int 1
[17:37:36.336]  $ ...future.seeds_ii       : NULL
[17:37:36.336]  $ ...future.globals.maxSize: NULL
[17:37:36.336]  - attr(*, "where")=List of 5
[17:37:36.336]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:36.336]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:36.336]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:36.336]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:36.336]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:36.336]  - attr(*, "resolved")= logi FALSE
[17:37:36.336]  - attr(*, "total_size")= num 3824
[17:37:36.336]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.336]  - attr(*, "already-done")= logi TRUE
[17:37:36.343] - reassign environment for ‘...future.FUN’
[17:37:36.343] - copied ‘...future.FUN’ to environment
[17:37:36.344] - copied ‘MoreArgs’ to environment
[17:37:36.344] - copied ‘...future.elements_ii’ to environment
[17:37:36.344] - copied ‘...future.seeds_ii’ to environment
[17:37:36.344] - copied ‘...future.globals.maxSize’ to environment
[17:37:36.344] assign_globals() ... done
[17:37:36.344] requestCore(): workers = 2
[17:37:36.347] MulticoreFuture started
[17:37:36.347] - Launch lazy future ... done
[17:37:36.348] plan(): Setting new future strategy stack:
[17:37:36.347] run() for ‘MulticoreFuture’ ... done
[17:37:36.352] Created future:
[17:37:36.352] List of future strategies:
[17:37:36.352] 1. sequential:
[17:37:36.352]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:36.352]    - tweaked: FALSE
[17:37:36.352]    - call: NULL
[17:37:36.354] plan(): nbrOfWorkers() = 1
[17:37:36.357] plan(): Setting new future strategy stack:
[17:37:36.357] List of future strategies:
[17:37:36.357] 1. multicore:
[17:37:36.357]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:36.357]    - tweaked: FALSE
[17:37:36.357]    - call: plan(strategy)
[17:37:36.364] plan(): nbrOfWorkers() = 2
[17:37:36.353] MulticoreFuture:
[17:37:36.353] Label: ‘future_.mapply-2’
[17:37:36.353] Expression:
[17:37:36.353] {
[17:37:36.353]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.353]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:36.353]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.353]         on.exit(options(oopts), add = TRUE)
[17:37:36.353]     }
[17:37:36.353]     {
[17:37:36.353]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.353]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:36.353]         do.call(mapply, args = args)
[17:37:36.353]     }
[17:37:36.353] }
[17:37:36.353] Lazy evaluation: FALSE
[17:37:36.353] Asynchronous evaluation: TRUE
[17:37:36.353] Local evaluation: TRUE
[17:37:36.353] Environment: R_GlobalEnv
[17:37:36.353] Capture standard output: TRUE
[17:37:36.353] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:36.353] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:36.353] Packages: <none>
[17:37:36.353] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:36.353] Resolved: TRUE
[17:37:36.353] Value: <not collected>
[17:37:36.353] Conditions captured: <none>
[17:37:36.353] Early signaling: FALSE
[17:37:36.353] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:36.353] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.365] Chunk #2 of 2 ... DONE
[17:37:36.365] Launching 2 futures (chunks) ... DONE
[17:37:36.366] Resolving 2 futures (chunks) ...
[17:37:36.366] resolve() on list ...
[17:37:36.366]  recursive: 0
[17:37:36.366]  length: 2
[17:37:36.366] 
[17:37:36.367] Future #1
[17:37:36.367] result() for MulticoreFuture ...
[17:37:36.368] result() for MulticoreFuture ...
[17:37:36.368] result() for MulticoreFuture ... done
[17:37:36.368] result() for MulticoreFuture ... done
[17:37:36.369] result() for MulticoreFuture ...
[17:37:36.369] result() for MulticoreFuture ... done
[17:37:36.369] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:37:36.369] - nx: 2
[17:37:36.370] - relay: TRUE
[17:37:36.370] - stdout: TRUE
[17:37:36.370] - signal: TRUE
[17:37:36.370] - resignal: FALSE
[17:37:36.370] - force: TRUE
[17:37:36.370] - relayed: [n=2] FALSE, FALSE
[17:37:36.371] - queued futures: [n=2] FALSE, FALSE
[17:37:36.371]  - until=1
[17:37:36.371]  - relaying element #1
[17:37:36.371] result() for MulticoreFuture ...
[17:37:36.372] result() for MulticoreFuture ... done
[17:37:36.372] result() for MulticoreFuture ...
[17:37:36.372] result() for MulticoreFuture ... done
[17:37:36.372] result() for MulticoreFuture ...
[17:37:36.373] result() for MulticoreFuture ... done
[17:37:36.373] result() for MulticoreFuture ...
[17:37:36.373] result() for MulticoreFuture ... done
[17:37:36.373] - relayed: [n=2] TRUE, FALSE
[17:37:36.373] - queued futures: [n=2] TRUE, FALSE
[17:37:36.373] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:37:36.374]  length: 1 (resolved future 1)
[17:37:36.374] Future #2
[17:37:36.374] result() for MulticoreFuture ...
[17:37:36.375] result() for MulticoreFuture ...
[17:37:36.375] result() for MulticoreFuture ... done
[17:37:36.375] result() for MulticoreFuture ... done
[17:37:36.375] result() for MulticoreFuture ...
[17:37:36.375] result() for MulticoreFuture ... done
[17:37:36.375] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:37:36.376] - nx: 2
[17:37:36.376] - relay: TRUE
[17:37:36.376] - stdout: TRUE
[17:37:36.376] - signal: TRUE
[17:37:36.376] - resignal: FALSE
[17:37:36.376] - force: TRUE
[17:37:36.376] - relayed: [n=2] TRUE, FALSE
[17:37:36.376] - queued futures: [n=2] TRUE, FALSE
[17:37:36.377]  - until=2
[17:37:36.377]  - relaying element #2
[17:37:36.377] result() for MulticoreFuture ...
[17:37:36.377] result() for MulticoreFuture ... done
[17:37:36.377] result() for MulticoreFuture ...
[17:37:36.377] result() for MulticoreFuture ... done
[17:37:36.377] result() for MulticoreFuture ...
[17:37:36.377] result() for MulticoreFuture ... done
[17:37:36.378] result() for MulticoreFuture ...
[17:37:36.378] result() for MulticoreFuture ... done
[17:37:36.378] - relayed: [n=2] TRUE, TRUE
[17:37:36.378] - queued futures: [n=2] TRUE, TRUE
[17:37:36.378] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:37:36.378]  length: 0 (resolved future 2)
[17:37:36.378] Relaying remaining futures
[17:37:36.378] signalConditionsASAP(NULL, pos=0) ...
[17:37:36.378] - nx: 2
[17:37:36.379] - relay: TRUE
[17:37:36.379] - stdout: TRUE
[17:37:36.379] - signal: TRUE
[17:37:36.379] - resignal: FALSE
[17:37:36.379] - force: TRUE
[17:37:36.379] - relayed: [n=2] TRUE, TRUE
[17:37:36.379] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:36.379] - relayed: [n=2] TRUE, TRUE
[17:37:36.379] - queued futures: [n=2] TRUE, TRUE
[17:37:36.379] signalConditionsASAP(NULL, pos=0) ... done
[17:37:36.380] resolve() on list ... DONE
[17:37:36.380] result() for MulticoreFuture ...
[17:37:36.380] result() for MulticoreFuture ... done
[17:37:36.380] result() for MulticoreFuture ...
[17:37:36.380] result() for MulticoreFuture ... done
[17:37:36.380] result() for MulticoreFuture ...
[17:37:36.380] result() for MulticoreFuture ... done
[17:37:36.380] result() for MulticoreFuture ...
[17:37:36.380] result() for MulticoreFuture ... done
[17:37:36.381]  - Number of value chunks collected: 2
[17:37:36.381] Resolving 2 futures (chunks) ... DONE
[17:37:36.381] Reducing values from 2 chunks ...
[17:37:36.381]  - Number of values collected after concatenation: 5
[17:37:36.381]  - Number of values expected: 5
[17:37:36.381] Reducing values from 2 chunks ... DONE
[17:37:36.381] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[17:37:36.382] future_mapply() ...
[17:37:36.386] Number of chunks: 1
[17:37:36.386] getGlobalsAndPackagesXApply() ...
[17:37:36.386]  - future.globals: TRUE
[17:37:36.386] getGlobalsAndPackages() ...
[17:37:36.386] Searching for globals...
[17:37:36.387] - globals found: [1] ‘FUN’
[17:37:36.387] Searching for globals ... DONE
[17:37:36.388] Resolving globals: FALSE
[17:37:36.388] The total size of the 1 globals is 848 bytes (848 bytes)
[17:37:36.388] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:37:36.388] - globals: [1] ‘FUN’
[17:37:36.389] 
[17:37:36.389] getGlobalsAndPackages() ... DONE
[17:37:36.389]  - globals found/used: [n=1] ‘FUN’
[17:37:36.389]  - needed namespaces: [n=0] 
[17:37:36.389] Finding globals ... DONE
[17:37:36.389] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:36.389] List of 2
[17:37:36.389]  $ ...future.FUN:function (x)  
[17:37:36.389]  $ MoreArgs     : NULL
[17:37:36.389]  - attr(*, "where")=List of 2
[17:37:36.389]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:36.389]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:36.389]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.389]  - attr(*, "resolved")= logi FALSE
[17:37:36.389]  - attr(*, "total_size")= num NA
[17:37:36.392] Packages to be attached in all futures: [n=0] 
[17:37:36.392] getGlobalsAndPackagesXApply() ... DONE
[17:37:36.392] Number of futures (= number of chunks): 1
[17:37:36.393] Launching 1 futures (chunks) ...
[17:37:36.393] Chunk #1 of 1 ...
[17:37:36.393]  - Finding globals in '...' for chunk #1 ...
[17:37:36.393] getGlobalsAndPackages() ...
[17:37:36.393] Searching for globals...
[17:37:36.396] 
[17:37:36.396] Searching for globals ... DONE
[17:37:36.396] - globals: [0] <none>
[17:37:36.396] getGlobalsAndPackages() ... DONE
[17:37:36.396]    + additional globals found: [n=0] 
[17:37:36.396]    + additional namespaces needed: [n=0] 
[17:37:36.397]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:36.397]  - seeds: <none>
[17:37:36.397]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.397] getGlobalsAndPackages() ...
[17:37:36.397] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.397] Resolving globals: FALSE
[17:37:36.398] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[17:37:36.398] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:36.398] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.398] 
[17:37:36.399] getGlobalsAndPackages() ... DONE
[17:37:36.399] run() for ‘Future’ ...
[17:37:36.399] - state: ‘created’
[17:37:36.399] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:36.403] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.403] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:36.403]   - Field: ‘label’
[17:37:36.403]   - Field: ‘local’
[17:37:36.404]   - Field: ‘owner’
[17:37:36.404]   - Field: ‘envir’
[17:37:36.404]   - Field: ‘workers’
[17:37:36.404]   - Field: ‘packages’
[17:37:36.404]   - Field: ‘gc’
[17:37:36.404]   - Field: ‘job’
[17:37:36.404]   - Field: ‘conditions’
[17:37:36.404]   - Field: ‘expr’
[17:37:36.404]   - Field: ‘uuid’
[17:37:36.405]   - Field: ‘seed’
[17:37:36.405]   - Field: ‘version’
[17:37:36.405]   - Field: ‘result’
[17:37:36.405]   - Field: ‘asynchronous’
[17:37:36.405]   - Field: ‘calls’
[17:37:36.405]   - Field: ‘globals’
[17:37:36.405]   - Field: ‘stdout’
[17:37:36.405]   - Field: ‘earlySignal’
[17:37:36.405]   - Field: ‘lazy’
[17:37:36.405]   - Field: ‘state’
[17:37:36.405] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:36.406] - Launch lazy future ...
[17:37:36.406] Packages needed by the future expression (n = 0): <none>
[17:37:36.406] Packages needed by future strategies (n = 0): <none>
[17:37:36.406] {
[17:37:36.406]     {
[17:37:36.406]         {
[17:37:36.406]             ...future.startTime <- base::Sys.time()
[17:37:36.406]             {
[17:37:36.406]                 {
[17:37:36.406]                   {
[17:37:36.406]                     {
[17:37:36.406]                       base::local({
[17:37:36.406]                         has_future <- base::requireNamespace("future", 
[17:37:36.406]                           quietly = TRUE)
[17:37:36.406]                         if (has_future) {
[17:37:36.406]                           ns <- base::getNamespace("future")
[17:37:36.406]                           version <- ns[[".package"]][["version"]]
[17:37:36.406]                           if (is.null(version)) 
[17:37:36.406]                             version <- utils::packageVersion("future")
[17:37:36.406]                         }
[17:37:36.406]                         else {
[17:37:36.406]                           version <- NULL
[17:37:36.406]                         }
[17:37:36.406]                         if (!has_future || version < "1.8.0") {
[17:37:36.406]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:36.406]                             "", base::R.version$version.string), 
[17:37:36.406]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:36.406]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:36.406]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:36.406]                               "release", "version")], collapse = " "), 
[17:37:36.406]                             hostname = base::Sys.info()[["nodename"]])
[17:37:36.406]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:36.406]                             info)
[17:37:36.406]                           info <- base::paste(info, collapse = "; ")
[17:37:36.406]                           if (!has_future) {
[17:37:36.406]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:36.406]                               info)
[17:37:36.406]                           }
[17:37:36.406]                           else {
[17:37:36.406]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:36.406]                               info, version)
[17:37:36.406]                           }
[17:37:36.406]                           base::stop(msg)
[17:37:36.406]                         }
[17:37:36.406]                       })
[17:37:36.406]                     }
[17:37:36.406]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:36.406]                     base::options(mc.cores = 1L)
[17:37:36.406]                   }
[17:37:36.406]                   ...future.strategy.old <- future::plan("list")
[17:37:36.406]                   options(future.plan = NULL)
[17:37:36.406]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.406]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:36.406]                 }
[17:37:36.406]                 ...future.workdir <- getwd()
[17:37:36.406]             }
[17:37:36.406]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:36.406]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:36.406]         }
[17:37:36.406]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:36.406]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:36.406]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:36.406]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:36.406]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:36.406]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:36.406]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:36.406]             base::names(...future.oldOptions))
[17:37:36.406]     }
[17:37:36.406]     if (FALSE) {
[17:37:36.406]     }
[17:37:36.406]     else {
[17:37:36.406]         if (TRUE) {
[17:37:36.406]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:36.406]                 open = "w")
[17:37:36.406]         }
[17:37:36.406]         else {
[17:37:36.406]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:36.406]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:36.406]         }
[17:37:36.406]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:36.406]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:36.406]             base::sink(type = "output", split = FALSE)
[17:37:36.406]             base::close(...future.stdout)
[17:37:36.406]         }, add = TRUE)
[17:37:36.406]     }
[17:37:36.406]     ...future.frame <- base::sys.nframe()
[17:37:36.406]     ...future.conditions <- base::list()
[17:37:36.406]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:36.406]     if (FALSE) {
[17:37:36.406]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:36.406]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:36.406]     }
[17:37:36.406]     ...future.result <- base::tryCatch({
[17:37:36.406]         base::withCallingHandlers({
[17:37:36.406]             ...future.value <- base::withVisible(base::local({
[17:37:36.406]                 withCallingHandlers({
[17:37:36.406]                   {
[17:37:36.406]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.406]                     if (!identical(...future.globals.maxSize.org, 
[17:37:36.406]                       ...future.globals.maxSize)) {
[17:37:36.406]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.406]                       on.exit(options(oopts), add = TRUE)
[17:37:36.406]                     }
[17:37:36.406]                     {
[17:37:36.406]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.406]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:36.406]                         USE.NAMES = FALSE)
[17:37:36.406]                       do.call(mapply, args = args)
[17:37:36.406]                     }
[17:37:36.406]                   }
[17:37:36.406]                 }, immediateCondition = function(cond) {
[17:37:36.406]                   save_rds <- function (object, pathname, ...) 
[17:37:36.406]                   {
[17:37:36.406]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:36.406]                     if (file_test("-f", pathname_tmp)) {
[17:37:36.406]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.406]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:36.406]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.406]                         fi_tmp[["mtime"]])
[17:37:36.406]                     }
[17:37:36.406]                     tryCatch({
[17:37:36.406]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:36.406]                     }, error = function(ex) {
[17:37:36.406]                       msg <- conditionMessage(ex)
[17:37:36.406]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.406]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:36.406]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.406]                         fi_tmp[["mtime"]], msg)
[17:37:36.406]                       ex$message <- msg
[17:37:36.406]                       stop(ex)
[17:37:36.406]                     })
[17:37:36.406]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:36.406]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:36.406]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:36.406]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.406]                       fi <- file.info(pathname)
[17:37:36.406]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:36.406]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.406]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:36.406]                         fi[["size"]], fi[["mtime"]])
[17:37:36.406]                       stop(msg)
[17:37:36.406]                     }
[17:37:36.406]                     invisible(pathname)
[17:37:36.406]                   }
[17:37:36.406]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:36.406]                     rootPath = tempdir()) 
[17:37:36.406]                   {
[17:37:36.406]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:36.406]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:36.406]                       tmpdir = path, fileext = ".rds")
[17:37:36.406]                     save_rds(obj, file)
[17:37:36.406]                   }
[17:37:36.406]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:36.406]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.406]                   {
[17:37:36.406]                     inherits <- base::inherits
[17:37:36.406]                     invokeRestart <- base::invokeRestart
[17:37:36.406]                     is.null <- base::is.null
[17:37:36.406]                     muffled <- FALSE
[17:37:36.406]                     if (inherits(cond, "message")) {
[17:37:36.406]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:36.406]                       if (muffled) 
[17:37:36.406]                         invokeRestart("muffleMessage")
[17:37:36.406]                     }
[17:37:36.406]                     else if (inherits(cond, "warning")) {
[17:37:36.406]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:36.406]                       if (muffled) 
[17:37:36.406]                         invokeRestart("muffleWarning")
[17:37:36.406]                     }
[17:37:36.406]                     else if (inherits(cond, "condition")) {
[17:37:36.406]                       if (!is.null(pattern)) {
[17:37:36.406]                         computeRestarts <- base::computeRestarts
[17:37:36.406]                         grepl <- base::grepl
[17:37:36.406]                         restarts <- computeRestarts(cond)
[17:37:36.406]                         for (restart in restarts) {
[17:37:36.406]                           name <- restart$name
[17:37:36.406]                           if (is.null(name)) 
[17:37:36.406]                             next
[17:37:36.406]                           if (!grepl(pattern, name)) 
[17:37:36.406]                             next
[17:37:36.406]                           invokeRestart(restart)
[17:37:36.406]                           muffled <- TRUE
[17:37:36.406]                           break
[17:37:36.406]                         }
[17:37:36.406]                       }
[17:37:36.406]                     }
[17:37:36.406]                     invisible(muffled)
[17:37:36.406]                   }
[17:37:36.406]                   muffleCondition(cond)
[17:37:36.406]                 })
[17:37:36.406]             }))
[17:37:36.406]             future::FutureResult(value = ...future.value$value, 
[17:37:36.406]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.406]                   ...future.rng), globalenv = if (FALSE) 
[17:37:36.406]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:36.406]                     ...future.globalenv.names))
[17:37:36.406]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:36.406]         }, condition = base::local({
[17:37:36.406]             c <- base::c
[17:37:36.406]             inherits <- base::inherits
[17:37:36.406]             invokeRestart <- base::invokeRestart
[17:37:36.406]             length <- base::length
[17:37:36.406]             list <- base::list
[17:37:36.406]             seq.int <- base::seq.int
[17:37:36.406]             signalCondition <- base::signalCondition
[17:37:36.406]             sys.calls <- base::sys.calls
[17:37:36.406]             `[[` <- base::`[[`
[17:37:36.406]             `+` <- base::`+`
[17:37:36.406]             `<<-` <- base::`<<-`
[17:37:36.406]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:36.406]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:36.406]                   3L)]
[17:37:36.406]             }
[17:37:36.406]             function(cond) {
[17:37:36.406]                 is_error <- inherits(cond, "error")
[17:37:36.406]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:36.406]                   NULL)
[17:37:36.406]                 if (is_error) {
[17:37:36.406]                   sessionInformation <- function() {
[17:37:36.406]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:36.406]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:36.406]                       search = base::search(), system = base::Sys.info())
[17:37:36.406]                   }
[17:37:36.406]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.406]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:36.406]                     cond$call), session = sessionInformation(), 
[17:37:36.406]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:36.406]                   signalCondition(cond)
[17:37:36.406]                 }
[17:37:36.406]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:36.406]                 "immediateCondition"))) {
[17:37:36.406]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:36.406]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.406]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:36.406]                   if (TRUE && !signal) {
[17:37:36.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.406]                     {
[17:37:36.406]                       inherits <- base::inherits
[17:37:36.406]                       invokeRestart <- base::invokeRestart
[17:37:36.406]                       is.null <- base::is.null
[17:37:36.406]                       muffled <- FALSE
[17:37:36.406]                       if (inherits(cond, "message")) {
[17:37:36.406]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.406]                         if (muffled) 
[17:37:36.406]                           invokeRestart("muffleMessage")
[17:37:36.406]                       }
[17:37:36.406]                       else if (inherits(cond, "warning")) {
[17:37:36.406]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.406]                         if (muffled) 
[17:37:36.406]                           invokeRestart("muffleWarning")
[17:37:36.406]                       }
[17:37:36.406]                       else if (inherits(cond, "condition")) {
[17:37:36.406]                         if (!is.null(pattern)) {
[17:37:36.406]                           computeRestarts <- base::computeRestarts
[17:37:36.406]                           grepl <- base::grepl
[17:37:36.406]                           restarts <- computeRestarts(cond)
[17:37:36.406]                           for (restart in restarts) {
[17:37:36.406]                             name <- restart$name
[17:37:36.406]                             if (is.null(name)) 
[17:37:36.406]                               next
[17:37:36.406]                             if (!grepl(pattern, name)) 
[17:37:36.406]                               next
[17:37:36.406]                             invokeRestart(restart)
[17:37:36.406]                             muffled <- TRUE
[17:37:36.406]                             break
[17:37:36.406]                           }
[17:37:36.406]                         }
[17:37:36.406]                       }
[17:37:36.406]                       invisible(muffled)
[17:37:36.406]                     }
[17:37:36.406]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.406]                   }
[17:37:36.406]                 }
[17:37:36.406]                 else {
[17:37:36.406]                   if (TRUE) {
[17:37:36.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.406]                     {
[17:37:36.406]                       inherits <- base::inherits
[17:37:36.406]                       invokeRestart <- base::invokeRestart
[17:37:36.406]                       is.null <- base::is.null
[17:37:36.406]                       muffled <- FALSE
[17:37:36.406]                       if (inherits(cond, "message")) {
[17:37:36.406]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.406]                         if (muffled) 
[17:37:36.406]                           invokeRestart("muffleMessage")
[17:37:36.406]                       }
[17:37:36.406]                       else if (inherits(cond, "warning")) {
[17:37:36.406]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.406]                         if (muffled) 
[17:37:36.406]                           invokeRestart("muffleWarning")
[17:37:36.406]                       }
[17:37:36.406]                       else if (inherits(cond, "condition")) {
[17:37:36.406]                         if (!is.null(pattern)) {
[17:37:36.406]                           computeRestarts <- base::computeRestarts
[17:37:36.406]                           grepl <- base::grepl
[17:37:36.406]                           restarts <- computeRestarts(cond)
[17:37:36.406]                           for (restart in restarts) {
[17:37:36.406]                             name <- restart$name
[17:37:36.406]                             if (is.null(name)) 
[17:37:36.406]                               next
[17:37:36.406]                             if (!grepl(pattern, name)) 
[17:37:36.406]                               next
[17:37:36.406]                             invokeRestart(restart)
[17:37:36.406]                             muffled <- TRUE
[17:37:36.406]                             break
[17:37:36.406]                           }
[17:37:36.406]                         }
[17:37:36.406]                       }
[17:37:36.406]                       invisible(muffled)
[17:37:36.406]                     }
[17:37:36.406]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.406]                   }
[17:37:36.406]                 }
[17:37:36.406]             }
[17:37:36.406]         }))
[17:37:36.406]     }, error = function(ex) {
[17:37:36.406]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:36.406]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.406]                 ...future.rng), started = ...future.startTime, 
[17:37:36.406]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:36.406]             version = "1.8"), class = "FutureResult")
[17:37:36.406]     }, finally = {
[17:37:36.406]         if (!identical(...future.workdir, getwd())) 
[17:37:36.406]             setwd(...future.workdir)
[17:37:36.406]         {
[17:37:36.406]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:36.406]                 ...future.oldOptions$nwarnings <- NULL
[17:37:36.406]             }
[17:37:36.406]             base::options(...future.oldOptions)
[17:37:36.406]             if (.Platform$OS.type == "windows") {
[17:37:36.406]                 old_names <- names(...future.oldEnvVars)
[17:37:36.406]                 envs <- base::Sys.getenv()
[17:37:36.406]                 names <- names(envs)
[17:37:36.406]                 common <- intersect(names, old_names)
[17:37:36.406]                 added <- setdiff(names, old_names)
[17:37:36.406]                 removed <- setdiff(old_names, names)
[17:37:36.406]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:36.406]                   envs[common]]
[17:37:36.406]                 NAMES <- toupper(changed)
[17:37:36.406]                 args <- list()
[17:37:36.406]                 for (kk in seq_along(NAMES)) {
[17:37:36.406]                   name <- changed[[kk]]
[17:37:36.406]                   NAME <- NAMES[[kk]]
[17:37:36.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.406]                     next
[17:37:36.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.406]                 }
[17:37:36.406]                 NAMES <- toupper(added)
[17:37:36.406]                 for (kk in seq_along(NAMES)) {
[17:37:36.406]                   name <- added[[kk]]
[17:37:36.406]                   NAME <- NAMES[[kk]]
[17:37:36.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.406]                     next
[17:37:36.406]                   args[[name]] <- ""
[17:37:36.406]                 }
[17:37:36.406]                 NAMES <- toupper(removed)
[17:37:36.406]                 for (kk in seq_along(NAMES)) {
[17:37:36.406]                   name <- removed[[kk]]
[17:37:36.406]                   NAME <- NAMES[[kk]]
[17:37:36.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.406]                     next
[17:37:36.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.406]                 }
[17:37:36.406]                 if (length(args) > 0) 
[17:37:36.406]                   base::do.call(base::Sys.setenv, args = args)
[17:37:36.406]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:36.406]             }
[17:37:36.406]             else {
[17:37:36.406]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:36.406]             }
[17:37:36.406]             {
[17:37:36.406]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:36.406]                   0L) {
[17:37:36.406]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:36.406]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:36.406]                   base::options(opts)
[17:37:36.406]                 }
[17:37:36.406]                 {
[17:37:36.406]                   {
[17:37:36.406]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:36.406]                     NULL
[17:37:36.406]                   }
[17:37:36.406]                   options(future.plan = NULL)
[17:37:36.406]                   if (is.na(NA_character_)) 
[17:37:36.406]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.406]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:36.406]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:36.406]                     .init = FALSE)
[17:37:36.406]                 }
[17:37:36.406]             }
[17:37:36.406]         }
[17:37:36.406]     })
[17:37:36.406]     if (TRUE) {
[17:37:36.406]         base::sink(type = "output", split = FALSE)
[17:37:36.406]         if (TRUE) {
[17:37:36.406]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:36.406]         }
[17:37:36.406]         else {
[17:37:36.406]             ...future.result["stdout"] <- base::list(NULL)
[17:37:36.406]         }
[17:37:36.406]         base::close(...future.stdout)
[17:37:36.406]         ...future.stdout <- NULL
[17:37:36.406]     }
[17:37:36.406]     ...future.result$conditions <- ...future.conditions
[17:37:36.406]     ...future.result$finished <- base::Sys.time()
[17:37:36.406]     ...future.result
[17:37:36.406] }
[17:37:36.409] assign_globals() ...
[17:37:36.409] List of 5
[17:37:36.409]  $ ...future.FUN            :function (x)  
[17:37:36.409]  $ MoreArgs                 : NULL
[17:37:36.409]  $ ...future.elements_ii    :List of 1
[17:37:36.409]   ..$ :List of 1
[17:37:36.409]   .. ..$ : Date[1:1], format: "2018-06-01"
[17:37:36.409]  $ ...future.seeds_ii       : NULL
[17:37:36.409]  $ ...future.globals.maxSize: NULL
[17:37:36.409]  - attr(*, "where")=List of 5
[17:37:36.409]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:36.409]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:36.409]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:36.409]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:36.409]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:36.409]  - attr(*, "resolved")= logi FALSE
[17:37:36.409]  - attr(*, "total_size")= num 1128
[17:37:36.409]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.409]  - attr(*, "already-done")= logi TRUE
[17:37:36.413] - copied ‘...future.FUN’ to environment
[17:37:36.413] - copied ‘MoreArgs’ to environment
[17:37:36.414] - copied ‘...future.elements_ii’ to environment
[17:37:36.414] - copied ‘...future.seeds_ii’ to environment
[17:37:36.414] - copied ‘...future.globals.maxSize’ to environment
[17:37:36.414] assign_globals() ... done
[17:37:36.414] requestCore(): workers = 2
[17:37:36.416] MulticoreFuture started
[17:37:36.417] - Launch lazy future ... done
[17:37:36.417] run() for ‘MulticoreFuture’ ... done
[17:37:36.417] Created future:
[17:37:36.417] plan(): Setting new future strategy stack:
[17:37:36.417] List of future strategies:
[17:37:36.417] 1. sequential:
[17:37:36.417]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:36.417]    - tweaked: FALSE
[17:37:36.417]    - call: NULL
[17:37:36.418] plan(): nbrOfWorkers() = 1
[17:37:36.420] plan(): Setting new future strategy stack:
[17:37:36.421] List of future strategies:
[17:37:36.421] 1. multicore:
[17:37:36.421]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:36.421]    - tweaked: FALSE
[17:37:36.421]    - call: plan(strategy)
[17:37:36.426] plan(): nbrOfWorkers() = 2
[17:37:36.417] MulticoreFuture:
[17:37:36.417] Label: ‘future_mapply-1’
[17:37:36.417] Expression:
[17:37:36.417] {
[17:37:36.417]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.417]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:36.417]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.417]         on.exit(options(oopts), add = TRUE)
[17:37:36.417]     }
[17:37:36.417]     {
[17:37:36.417]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.417]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:36.417]         do.call(mapply, args = args)
[17:37:36.417]     }
[17:37:36.417] }
[17:37:36.417] Lazy evaluation: FALSE
[17:37:36.417] Asynchronous evaluation: TRUE
[17:37:36.417] Local evaluation: TRUE
[17:37:36.417] Environment: R_GlobalEnv
[17:37:36.417] Capture standard output: TRUE
[17:37:36.417] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:36.417] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:36.417] Packages: <none>
[17:37:36.417] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:36.417] Resolved: TRUE
[17:37:36.417] Value: <not collected>
[17:37:36.417] Conditions captured: <none>
[17:37:36.417] Early signaling: FALSE
[17:37:36.417] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:36.417] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.427] Chunk #1 of 1 ... DONE
[17:37:36.427] Launching 1 futures (chunks) ... DONE
[17:37:36.427] Resolving 1 futures (chunks) ...
[17:37:36.427] resolve() on list ...
[17:37:36.428]  recursive: 0
[17:37:36.428]  length: 1
[17:37:36.428] 
[17:37:36.428] Future #1
[17:37:36.428] result() for MulticoreFuture ...
[17:37:36.429] result() for MulticoreFuture ...
[17:37:36.429] result() for MulticoreFuture ... done
[17:37:36.430] result() for MulticoreFuture ... done
[17:37:36.430] result() for MulticoreFuture ...
[17:37:36.430] result() for MulticoreFuture ... done
[17:37:36.430] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:37:36.430] - nx: 1
[17:37:36.430] - relay: TRUE
[17:37:36.430] - stdout: TRUE
[17:37:36.431] - signal: TRUE
[17:37:36.431] - resignal: FALSE
[17:37:36.431] - force: TRUE
[17:37:36.431] - relayed: [n=1] FALSE
[17:37:36.431] - queued futures: [n=1] FALSE
[17:37:36.431]  - until=1
[17:37:36.431]  - relaying element #1
[17:37:36.431] result() for MulticoreFuture ...
[17:37:36.432] result() for MulticoreFuture ... done
[17:37:36.432] result() for MulticoreFuture ...
[17:37:36.432] result() for MulticoreFuture ... done
[17:37:36.432] result() for MulticoreFuture ...
[17:37:36.432] result() for MulticoreFuture ... done
[17:37:36.432] result() for MulticoreFuture ...
[17:37:36.432] result() for MulticoreFuture ... done
[17:37:36.433] - relayed: [n=1] TRUE
[17:37:36.433] - queued futures: [n=1] TRUE
[17:37:36.433] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:37:36.433]  length: 0 (resolved future 1)
[17:37:36.433] Relaying remaining futures
[17:37:36.436] signalConditionsASAP(NULL, pos=0) ...
[17:37:36.436] - nx: 1
[17:37:36.437] - relay: TRUE
[17:37:36.437] - stdout: TRUE
[17:37:36.437] - signal: TRUE
[17:37:36.437] - resignal: FALSE
[17:37:36.437] - force: TRUE
[17:37:36.438] - relayed: [n=1] TRUE
[17:37:36.438] - queued futures: [n=1] TRUE
 - flush all
[17:37:36.438] - relayed: [n=1] TRUE
[17:37:36.438] - queued futures: [n=1] TRUE
[17:37:36.438] signalConditionsASAP(NULL, pos=0) ... done
[17:37:36.439] resolve() on list ... DONE
[17:37:36.439] result() for MulticoreFuture ...
[17:37:36.439] result() for MulticoreFuture ... done
[17:37:36.439] result() for MulticoreFuture ...
[17:37:36.439] result() for MulticoreFuture ... done
[17:37:36.439]  - Number of value chunks collected: 1
[17:37:36.440] Resolving 1 futures (chunks) ... DONE
[17:37:36.440] Reducing values from 1 chunks ...
[17:37:36.440]  - Number of values collected after concatenation: 1
[17:37:36.440]  - Number of values expected: 1
[17:37:36.440] Reducing values from 1 chunks ... DONE
[17:37:36.440] future_mapply() ... DONE
[17:37:36.441] future_mapply() ...
[17:37:36.445] Number of chunks: 1
[17:37:36.445] getGlobalsAndPackagesXApply() ...
[17:37:36.446]  - future.globals: TRUE
[17:37:36.446] getGlobalsAndPackages() ...
[17:37:36.446] Searching for globals...
[17:37:36.447] - globals found: [1] ‘FUN’
[17:37:36.447] Searching for globals ... DONE
[17:37:36.448] Resolving globals: FALSE
[17:37:36.448] The total size of the 1 globals is 848 bytes (848 bytes)
[17:37:36.448] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:37:36.449] - globals: [1] ‘FUN’
[17:37:36.449] 
[17:37:36.449] getGlobalsAndPackages() ... DONE
[17:37:36.449]  - globals found/used: [n=1] ‘FUN’
[17:37:36.449]  - needed namespaces: [n=0] 
[17:37:36.449] Finding globals ... DONE
[17:37:36.449] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:36.449] List of 2
[17:37:36.449]  $ ...future.FUN:function (x)  
[17:37:36.449]  $ MoreArgs     : list()
[17:37:36.449]  - attr(*, "where")=List of 2
[17:37:36.449]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:36.449]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:36.449]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.449]  - attr(*, "resolved")= logi FALSE
[17:37:36.449]  - attr(*, "total_size")= num NA
[17:37:36.452] Packages to be attached in all futures: [n=0] 
[17:37:36.453] getGlobalsAndPackagesXApply() ... DONE
[17:37:36.453] Number of futures (= number of chunks): 1
[17:37:36.453] Launching 1 futures (chunks) ...
[17:37:36.453] Chunk #1 of 1 ...
[17:37:36.453]  - Finding globals in '...' for chunk #1 ...
[17:37:36.453] getGlobalsAndPackages() ...
[17:37:36.453] Searching for globals...
[17:37:36.454] 
[17:37:36.454] Searching for globals ... DONE
[17:37:36.454] - globals: [0] <none>
[17:37:36.454] getGlobalsAndPackages() ... DONE
[17:37:36.454]    + additional globals found: [n=0] 
[17:37:36.454]    + additional namespaces needed: [n=0] 
[17:37:36.454]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:36.454]  - seeds: <none>
[17:37:36.454]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.455] getGlobalsAndPackages() ...
[17:37:36.455] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.455] Resolving globals: FALSE
[17:37:36.455] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[17:37:36.456] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:36.456] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.456] 
[17:37:36.456] getGlobalsAndPackages() ... DONE
[17:37:36.456] run() for ‘Future’ ...
[17:37:36.457] - state: ‘created’
[17:37:36.457] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:36.460] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.460] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:36.461]   - Field: ‘label’
[17:37:36.461]   - Field: ‘local’
[17:37:36.461]   - Field: ‘owner’
[17:37:36.461]   - Field: ‘envir’
[17:37:36.461]   - Field: ‘workers’
[17:37:36.461]   - Field: ‘packages’
[17:37:36.461]   - Field: ‘gc’
[17:37:36.461]   - Field: ‘job’
[17:37:36.461]   - Field: ‘conditions’
[17:37:36.461]   - Field: ‘expr’
[17:37:36.462]   - Field: ‘uuid’
[17:37:36.462]   - Field: ‘seed’
[17:37:36.462]   - Field: ‘version’
[17:37:36.462]   - Field: ‘result’
[17:37:36.462]   - Field: ‘asynchronous’
[17:37:36.462]   - Field: ‘calls’
[17:37:36.462]   - Field: ‘globals’
[17:37:36.462]   - Field: ‘stdout’
[17:37:36.462]   - Field: ‘earlySignal’
[17:37:36.462]   - Field: ‘lazy’
[17:37:36.463]   - Field: ‘state’
[17:37:36.463] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:36.463] - Launch lazy future ...
[17:37:36.463] Packages needed by the future expression (n = 0): <none>
[17:37:36.463] Packages needed by future strategies (n = 0): <none>
[17:37:36.464] {
[17:37:36.464]     {
[17:37:36.464]         {
[17:37:36.464]             ...future.startTime <- base::Sys.time()
[17:37:36.464]             {
[17:37:36.464]                 {
[17:37:36.464]                   {
[17:37:36.464]                     {
[17:37:36.464]                       base::local({
[17:37:36.464]                         has_future <- base::requireNamespace("future", 
[17:37:36.464]                           quietly = TRUE)
[17:37:36.464]                         if (has_future) {
[17:37:36.464]                           ns <- base::getNamespace("future")
[17:37:36.464]                           version <- ns[[".package"]][["version"]]
[17:37:36.464]                           if (is.null(version)) 
[17:37:36.464]                             version <- utils::packageVersion("future")
[17:37:36.464]                         }
[17:37:36.464]                         else {
[17:37:36.464]                           version <- NULL
[17:37:36.464]                         }
[17:37:36.464]                         if (!has_future || version < "1.8.0") {
[17:37:36.464]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:36.464]                             "", base::R.version$version.string), 
[17:37:36.464]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:36.464]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:36.464]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:36.464]                               "release", "version")], collapse = " "), 
[17:37:36.464]                             hostname = base::Sys.info()[["nodename"]])
[17:37:36.464]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:36.464]                             info)
[17:37:36.464]                           info <- base::paste(info, collapse = "; ")
[17:37:36.464]                           if (!has_future) {
[17:37:36.464]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:36.464]                               info)
[17:37:36.464]                           }
[17:37:36.464]                           else {
[17:37:36.464]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:36.464]                               info, version)
[17:37:36.464]                           }
[17:37:36.464]                           base::stop(msg)
[17:37:36.464]                         }
[17:37:36.464]                       })
[17:37:36.464]                     }
[17:37:36.464]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:36.464]                     base::options(mc.cores = 1L)
[17:37:36.464]                   }
[17:37:36.464]                   ...future.strategy.old <- future::plan("list")
[17:37:36.464]                   options(future.plan = NULL)
[17:37:36.464]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.464]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:36.464]                 }
[17:37:36.464]                 ...future.workdir <- getwd()
[17:37:36.464]             }
[17:37:36.464]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:36.464]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:36.464]         }
[17:37:36.464]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:36.464]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:36.464]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:36.464]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:36.464]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:36.464]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:36.464]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:36.464]             base::names(...future.oldOptions))
[17:37:36.464]     }
[17:37:36.464]     if (FALSE) {
[17:37:36.464]     }
[17:37:36.464]     else {
[17:37:36.464]         if (TRUE) {
[17:37:36.464]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:36.464]                 open = "w")
[17:37:36.464]         }
[17:37:36.464]         else {
[17:37:36.464]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:36.464]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:36.464]         }
[17:37:36.464]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:36.464]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:36.464]             base::sink(type = "output", split = FALSE)
[17:37:36.464]             base::close(...future.stdout)
[17:37:36.464]         }, add = TRUE)
[17:37:36.464]     }
[17:37:36.464]     ...future.frame <- base::sys.nframe()
[17:37:36.464]     ...future.conditions <- base::list()
[17:37:36.464]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:36.464]     if (FALSE) {
[17:37:36.464]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:36.464]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:36.464]     }
[17:37:36.464]     ...future.result <- base::tryCatch({
[17:37:36.464]         base::withCallingHandlers({
[17:37:36.464]             ...future.value <- base::withVisible(base::local({
[17:37:36.464]                 withCallingHandlers({
[17:37:36.464]                   {
[17:37:36.464]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.464]                     if (!identical(...future.globals.maxSize.org, 
[17:37:36.464]                       ...future.globals.maxSize)) {
[17:37:36.464]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.464]                       on.exit(options(oopts), add = TRUE)
[17:37:36.464]                     }
[17:37:36.464]                     {
[17:37:36.464]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.464]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:36.464]                         USE.NAMES = FALSE)
[17:37:36.464]                       do.call(mapply, args = args)
[17:37:36.464]                     }
[17:37:36.464]                   }
[17:37:36.464]                 }, immediateCondition = function(cond) {
[17:37:36.464]                   save_rds <- function (object, pathname, ...) 
[17:37:36.464]                   {
[17:37:36.464]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:36.464]                     if (file_test("-f", pathname_tmp)) {
[17:37:36.464]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.464]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:36.464]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.464]                         fi_tmp[["mtime"]])
[17:37:36.464]                     }
[17:37:36.464]                     tryCatch({
[17:37:36.464]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:36.464]                     }, error = function(ex) {
[17:37:36.464]                       msg <- conditionMessage(ex)
[17:37:36.464]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.464]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:36.464]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.464]                         fi_tmp[["mtime"]], msg)
[17:37:36.464]                       ex$message <- msg
[17:37:36.464]                       stop(ex)
[17:37:36.464]                     })
[17:37:36.464]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:36.464]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:36.464]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:36.464]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.464]                       fi <- file.info(pathname)
[17:37:36.464]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:36.464]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.464]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:36.464]                         fi[["size"]], fi[["mtime"]])
[17:37:36.464]                       stop(msg)
[17:37:36.464]                     }
[17:37:36.464]                     invisible(pathname)
[17:37:36.464]                   }
[17:37:36.464]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:36.464]                     rootPath = tempdir()) 
[17:37:36.464]                   {
[17:37:36.464]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:36.464]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:36.464]                       tmpdir = path, fileext = ".rds")
[17:37:36.464]                     save_rds(obj, file)
[17:37:36.464]                   }
[17:37:36.464]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:36.464]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.464]                   {
[17:37:36.464]                     inherits <- base::inherits
[17:37:36.464]                     invokeRestart <- base::invokeRestart
[17:37:36.464]                     is.null <- base::is.null
[17:37:36.464]                     muffled <- FALSE
[17:37:36.464]                     if (inherits(cond, "message")) {
[17:37:36.464]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:36.464]                       if (muffled) 
[17:37:36.464]                         invokeRestart("muffleMessage")
[17:37:36.464]                     }
[17:37:36.464]                     else if (inherits(cond, "warning")) {
[17:37:36.464]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:36.464]                       if (muffled) 
[17:37:36.464]                         invokeRestart("muffleWarning")
[17:37:36.464]                     }
[17:37:36.464]                     else if (inherits(cond, "condition")) {
[17:37:36.464]                       if (!is.null(pattern)) {
[17:37:36.464]                         computeRestarts <- base::computeRestarts
[17:37:36.464]                         grepl <- base::grepl
[17:37:36.464]                         restarts <- computeRestarts(cond)
[17:37:36.464]                         for (restart in restarts) {
[17:37:36.464]                           name <- restart$name
[17:37:36.464]                           if (is.null(name)) 
[17:37:36.464]                             next
[17:37:36.464]                           if (!grepl(pattern, name)) 
[17:37:36.464]                             next
[17:37:36.464]                           invokeRestart(restart)
[17:37:36.464]                           muffled <- TRUE
[17:37:36.464]                           break
[17:37:36.464]                         }
[17:37:36.464]                       }
[17:37:36.464]                     }
[17:37:36.464]                     invisible(muffled)
[17:37:36.464]                   }
[17:37:36.464]                   muffleCondition(cond)
[17:37:36.464]                 })
[17:37:36.464]             }))
[17:37:36.464]             future::FutureResult(value = ...future.value$value, 
[17:37:36.464]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.464]                   ...future.rng), globalenv = if (FALSE) 
[17:37:36.464]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:36.464]                     ...future.globalenv.names))
[17:37:36.464]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:36.464]         }, condition = base::local({
[17:37:36.464]             c <- base::c
[17:37:36.464]             inherits <- base::inherits
[17:37:36.464]             invokeRestart <- base::invokeRestart
[17:37:36.464]             length <- base::length
[17:37:36.464]             list <- base::list
[17:37:36.464]             seq.int <- base::seq.int
[17:37:36.464]             signalCondition <- base::signalCondition
[17:37:36.464]             sys.calls <- base::sys.calls
[17:37:36.464]             `[[` <- base::`[[`
[17:37:36.464]             `+` <- base::`+`
[17:37:36.464]             `<<-` <- base::`<<-`
[17:37:36.464]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:36.464]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:36.464]                   3L)]
[17:37:36.464]             }
[17:37:36.464]             function(cond) {
[17:37:36.464]                 is_error <- inherits(cond, "error")
[17:37:36.464]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:36.464]                   NULL)
[17:37:36.464]                 if (is_error) {
[17:37:36.464]                   sessionInformation <- function() {
[17:37:36.464]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:36.464]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:36.464]                       search = base::search(), system = base::Sys.info())
[17:37:36.464]                   }
[17:37:36.464]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.464]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:36.464]                     cond$call), session = sessionInformation(), 
[17:37:36.464]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:36.464]                   signalCondition(cond)
[17:37:36.464]                 }
[17:37:36.464]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:36.464]                 "immediateCondition"))) {
[17:37:36.464]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:36.464]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.464]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:36.464]                   if (TRUE && !signal) {
[17:37:36.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.464]                     {
[17:37:36.464]                       inherits <- base::inherits
[17:37:36.464]                       invokeRestart <- base::invokeRestart
[17:37:36.464]                       is.null <- base::is.null
[17:37:36.464]                       muffled <- FALSE
[17:37:36.464]                       if (inherits(cond, "message")) {
[17:37:36.464]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.464]                         if (muffled) 
[17:37:36.464]                           invokeRestart("muffleMessage")
[17:37:36.464]                       }
[17:37:36.464]                       else if (inherits(cond, "warning")) {
[17:37:36.464]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.464]                         if (muffled) 
[17:37:36.464]                           invokeRestart("muffleWarning")
[17:37:36.464]                       }
[17:37:36.464]                       else if (inherits(cond, "condition")) {
[17:37:36.464]                         if (!is.null(pattern)) {
[17:37:36.464]                           computeRestarts <- base::computeRestarts
[17:37:36.464]                           grepl <- base::grepl
[17:37:36.464]                           restarts <- computeRestarts(cond)
[17:37:36.464]                           for (restart in restarts) {
[17:37:36.464]                             name <- restart$name
[17:37:36.464]                             if (is.null(name)) 
[17:37:36.464]                               next
[17:37:36.464]                             if (!grepl(pattern, name)) 
[17:37:36.464]                               next
[17:37:36.464]                             invokeRestart(restart)
[17:37:36.464]                             muffled <- TRUE
[17:37:36.464]                             break
[17:37:36.464]                           }
[17:37:36.464]                         }
[17:37:36.464]                       }
[17:37:36.464]                       invisible(muffled)
[17:37:36.464]                     }
[17:37:36.464]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.464]                   }
[17:37:36.464]                 }
[17:37:36.464]                 else {
[17:37:36.464]                   if (TRUE) {
[17:37:36.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.464]                     {
[17:37:36.464]                       inherits <- base::inherits
[17:37:36.464]                       invokeRestart <- base::invokeRestart
[17:37:36.464]                       is.null <- base::is.null
[17:37:36.464]                       muffled <- FALSE
[17:37:36.464]                       if (inherits(cond, "message")) {
[17:37:36.464]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.464]                         if (muffled) 
[17:37:36.464]                           invokeRestart("muffleMessage")
[17:37:36.464]                       }
[17:37:36.464]                       else if (inherits(cond, "warning")) {
[17:37:36.464]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.464]                         if (muffled) 
[17:37:36.464]                           invokeRestart("muffleWarning")
[17:37:36.464]                       }
[17:37:36.464]                       else if (inherits(cond, "condition")) {
[17:37:36.464]                         if (!is.null(pattern)) {
[17:37:36.464]                           computeRestarts <- base::computeRestarts
[17:37:36.464]                           grepl <- base::grepl
[17:37:36.464]                           restarts <- computeRestarts(cond)
[17:37:36.464]                           for (restart in restarts) {
[17:37:36.464]                             name <- restart$name
[17:37:36.464]                             if (is.null(name)) 
[17:37:36.464]                               next
[17:37:36.464]                             if (!grepl(pattern, name)) 
[17:37:36.464]                               next
[17:37:36.464]                             invokeRestart(restart)
[17:37:36.464]                             muffled <- TRUE
[17:37:36.464]                             break
[17:37:36.464]                           }
[17:37:36.464]                         }
[17:37:36.464]                       }
[17:37:36.464]                       invisible(muffled)
[17:37:36.464]                     }
[17:37:36.464]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.464]                   }
[17:37:36.464]                 }
[17:37:36.464]             }
[17:37:36.464]         }))
[17:37:36.464]     }, error = function(ex) {
[17:37:36.464]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:36.464]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.464]                 ...future.rng), started = ...future.startTime, 
[17:37:36.464]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:36.464]             version = "1.8"), class = "FutureResult")
[17:37:36.464]     }, finally = {
[17:37:36.464]         if (!identical(...future.workdir, getwd())) 
[17:37:36.464]             setwd(...future.workdir)
[17:37:36.464]         {
[17:37:36.464]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:36.464]                 ...future.oldOptions$nwarnings <- NULL
[17:37:36.464]             }
[17:37:36.464]             base::options(...future.oldOptions)
[17:37:36.464]             if (.Platform$OS.type == "windows") {
[17:37:36.464]                 old_names <- names(...future.oldEnvVars)
[17:37:36.464]                 envs <- base::Sys.getenv()
[17:37:36.464]                 names <- names(envs)
[17:37:36.464]                 common <- intersect(names, old_names)
[17:37:36.464]                 added <- setdiff(names, old_names)
[17:37:36.464]                 removed <- setdiff(old_names, names)
[17:37:36.464]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:36.464]                   envs[common]]
[17:37:36.464]                 NAMES <- toupper(changed)
[17:37:36.464]                 args <- list()
[17:37:36.464]                 for (kk in seq_along(NAMES)) {
[17:37:36.464]                   name <- changed[[kk]]
[17:37:36.464]                   NAME <- NAMES[[kk]]
[17:37:36.464]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.464]                     next
[17:37:36.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.464]                 }
[17:37:36.464]                 NAMES <- toupper(added)
[17:37:36.464]                 for (kk in seq_along(NAMES)) {
[17:37:36.464]                   name <- added[[kk]]
[17:37:36.464]                   NAME <- NAMES[[kk]]
[17:37:36.464]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.464]                     next
[17:37:36.464]                   args[[name]] <- ""
[17:37:36.464]                 }
[17:37:36.464]                 NAMES <- toupper(removed)
[17:37:36.464]                 for (kk in seq_along(NAMES)) {
[17:37:36.464]                   name <- removed[[kk]]
[17:37:36.464]                   NAME <- NAMES[[kk]]
[17:37:36.464]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.464]                     next
[17:37:36.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.464]                 }
[17:37:36.464]                 if (length(args) > 0) 
[17:37:36.464]                   base::do.call(base::Sys.setenv, args = args)
[17:37:36.464]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:36.464]             }
[17:37:36.464]             else {
[17:37:36.464]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:36.464]             }
[17:37:36.464]             {
[17:37:36.464]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:36.464]                   0L) {
[17:37:36.464]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:36.464]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:36.464]                   base::options(opts)
[17:37:36.464]                 }
[17:37:36.464]                 {
[17:37:36.464]                   {
[17:37:36.464]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:36.464]                     NULL
[17:37:36.464]                   }
[17:37:36.464]                   options(future.plan = NULL)
[17:37:36.464]                   if (is.na(NA_character_)) 
[17:37:36.464]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.464]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:36.464]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:36.464]                     .init = FALSE)
[17:37:36.464]                 }
[17:37:36.464]             }
[17:37:36.464]         }
[17:37:36.464]     })
[17:37:36.464]     if (TRUE) {
[17:37:36.464]         base::sink(type = "output", split = FALSE)
[17:37:36.464]         if (TRUE) {
[17:37:36.464]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:36.464]         }
[17:37:36.464]         else {
[17:37:36.464]             ...future.result["stdout"] <- base::list(NULL)
[17:37:36.464]         }
[17:37:36.464]         base::close(...future.stdout)
[17:37:36.464]         ...future.stdout <- NULL
[17:37:36.464]     }
[17:37:36.464]     ...future.result$conditions <- ...future.conditions
[17:37:36.464]     ...future.result$finished <- base::Sys.time()
[17:37:36.464]     ...future.result
[17:37:36.464] }
[17:37:36.466] assign_globals() ...
[17:37:36.466] List of 5
[17:37:36.466]  $ ...future.FUN            :function (x)  
[17:37:36.466]  $ MoreArgs                 : list()
[17:37:36.466]  $ ...future.elements_ii    :List of 1
[17:37:36.466]   ..$ :List of 1
[17:37:36.466]   .. ..$ : Date[1:1], format: "2018-06-01"
[17:37:36.466]  $ ...future.seeds_ii       : NULL
[17:37:36.466]  $ ...future.globals.maxSize: NULL
[17:37:36.466]  - attr(*, "where")=List of 5
[17:37:36.466]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:36.466]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:36.466]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:36.466]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:36.466]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:36.466]  - attr(*, "resolved")= logi FALSE
[17:37:36.466]  - attr(*, "total_size")= num 1128
[17:37:36.466]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.466]  - attr(*, "already-done")= logi TRUE
[17:37:36.474] - copied ‘...future.FUN’ to environment
[17:37:36.474] - copied ‘MoreArgs’ to environment
[17:37:36.474] - copied ‘...future.elements_ii’ to environment
[17:37:36.474] - copied ‘...future.seeds_ii’ to environment
[17:37:36.474] - copied ‘...future.globals.maxSize’ to environment
[17:37:36.475] assign_globals() ... done
[17:37:36.475] requestCore(): workers = 2
[17:37:36.477] MulticoreFuture started
[17:37:36.478] - Launch lazy future ... done
[17:37:36.478] run() for ‘MulticoreFuture’ ... done
[17:37:36.478] plan(): Setting new future strategy stack:
[17:37:36.478] Created future:
[17:37:36.478] List of future strategies:
[17:37:36.478] 1. sequential:
[17:37:36.478]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:36.478]    - tweaked: FALSE
[17:37:36.478]    - call: NULL
[17:37:36.480] plan(): nbrOfWorkers() = 1
[17:37:36.482] plan(): Setting new future strategy stack:
[17:37:36.483] List of future strategies:
[17:37:36.483] 1. multicore:
[17:37:36.483]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:36.483]    - tweaked: FALSE
[17:37:36.483]    - call: plan(strategy)
[17:37:36.489] plan(): nbrOfWorkers() = 2
[17:37:36.479] MulticoreFuture:
[17:37:36.479] Label: ‘future_.mapply-1’
[17:37:36.479] Expression:
[17:37:36.479] {
[17:37:36.479]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.479]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:36.479]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.479]         on.exit(options(oopts), add = TRUE)
[17:37:36.479]     }
[17:37:36.479]     {
[17:37:36.479]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.479]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:36.479]         do.call(mapply, args = args)
[17:37:36.479]     }
[17:37:36.479] }
[17:37:36.479] Lazy evaluation: FALSE
[17:37:36.479] Asynchronous evaluation: TRUE
[17:37:36.479] Local evaluation: TRUE
[17:37:36.479] Environment: R_GlobalEnv
[17:37:36.479] Capture standard output: TRUE
[17:37:36.479] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:36.479] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:36.479] Packages: <none>
[17:37:36.479] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:36.479] Resolved: TRUE
[17:37:36.479] Value: <not collected>
[17:37:36.479] Conditions captured: <none>
[17:37:36.479] Early signaling: FALSE
[17:37:36.479] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:36.479] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.490] Chunk #1 of 1 ... DONE
[17:37:36.490] Launching 1 futures (chunks) ... DONE
[17:37:36.490] Resolving 1 futures (chunks) ...
[17:37:36.491] resolve() on list ...
[17:37:36.491]  recursive: 0
[17:37:36.491]  length: 1
[17:37:36.491] 
[17:37:36.491] Future #1
[17:37:36.492] result() for MulticoreFuture ...
[17:37:36.492] result() for MulticoreFuture ...
[17:37:36.493] result() for MulticoreFuture ... done
[17:37:36.493] result() for MulticoreFuture ... done
[17:37:36.493] result() for MulticoreFuture ...
[17:37:36.493] result() for MulticoreFuture ... done
[17:37:36.493] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:37:36.493] - nx: 1
[17:37:36.494] - relay: TRUE
[17:37:36.494] - stdout: TRUE
[17:37:36.494] - signal: TRUE
[17:37:36.494] - resignal: FALSE
[17:37:36.494] - force: TRUE
[17:37:36.494] - relayed: [n=1] FALSE
[17:37:36.494] - queued futures: [n=1] FALSE
[17:37:36.494]  - until=1
[17:37:36.494]  - relaying element #1
[17:37:36.495] result() for MulticoreFuture ...
[17:37:36.495] result() for MulticoreFuture ... done
[17:37:36.495] result() for MulticoreFuture ...
[17:37:36.495] result() for MulticoreFuture ... done
[17:37:36.495] result() for MulticoreFuture ...
[17:37:36.495] result() for MulticoreFuture ... done
[17:37:36.495] result() for MulticoreFuture ...
[17:37:36.496] result() for MulticoreFuture ... done
[17:37:36.496] - relayed: [n=1] TRUE
[17:37:36.496] - queued futures: [n=1] TRUE
[17:37:36.496] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:37:36.496]  length: 0 (resolved future 1)
[17:37:36.496] Relaying remaining futures
[17:37:36.496] signalConditionsASAP(NULL, pos=0) ...
[17:37:36.496] - nx: 1
[17:37:36.496] - relay: TRUE
[17:37:36.497] - stdout: TRUE
[17:37:36.497] - signal: TRUE
[17:37:36.497] - resignal: FALSE
[17:37:36.497] - force: TRUE
[17:37:36.497] - relayed: [n=1] TRUE
[17:37:36.497] - queued futures: [n=1] TRUE
 - flush all
[17:37:36.497] - relayed: [n=1] TRUE
[17:37:36.497] - queued futures: [n=1] TRUE
[17:37:36.498] signalConditionsASAP(NULL, pos=0) ... done
[17:37:36.498] resolve() on list ... DONE
[17:37:36.498] result() for MulticoreFuture ...
[17:37:36.498] result() for MulticoreFuture ... done
[17:37:36.498] result() for MulticoreFuture ...
[17:37:36.498] result() for MulticoreFuture ... done
[17:37:36.498]  - Number of value chunks collected: 1
[17:37:36.498] Resolving 1 futures (chunks) ... DONE
[17:37:36.498] Reducing values from 1 chunks ...
[17:37:36.499]  - Number of values collected after concatenation: 1
[17:37:36.499]  - Number of values expected: 1
[17:37:36.499] Reducing values from 1 chunks ... DONE
[17:37:36.499] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[17:37:36.499] future_mapply() ...
[17:37:36.503] Number of chunks: 2
[17:37:36.504] getGlobalsAndPackagesXApply() ...
[17:37:36.504]  - future.globals: TRUE
[17:37:36.504] getGlobalsAndPackages() ...
[17:37:36.504] Searching for globals...
[17:37:36.505] - globals found: [1] ‘FUN’
[17:37:36.505] Searching for globals ... DONE
[17:37:36.506] Resolving globals: FALSE
[17:37:36.506] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:37:36.506] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:37:36.506] - globals: [1] ‘FUN’
[17:37:36.507] 
[17:37:36.507] getGlobalsAndPackages() ... DONE
[17:37:36.507]  - globals found/used: [n=1] ‘FUN’
[17:37:36.507]  - needed namespaces: [n=0] 
[17:37:36.507] Finding globals ... DONE
[17:37:36.507] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:36.507] List of 2
[17:37:36.507]  $ ...future.FUN:function (x, y)  
[17:37:36.507]  $ MoreArgs     :List of 1
[17:37:36.507]   ..$ y: int [1:2] 3 4
[17:37:36.507]  - attr(*, "where")=List of 2
[17:37:36.507]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:36.507]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:36.507]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.507]  - attr(*, "resolved")= logi FALSE
[17:37:36.507]  - attr(*, "total_size")= num NA
[17:37:36.514] Packages to be attached in all futures: [n=0] 
[17:37:36.514] getGlobalsAndPackagesXApply() ... DONE
[17:37:36.515] Number of futures (= number of chunks): 2
[17:37:36.515] Launching 2 futures (chunks) ...
[17:37:36.515] Chunk #1 of 2 ...
[17:37:36.515]  - Finding globals in '...' for chunk #1 ...
[17:37:36.515] getGlobalsAndPackages() ...
[17:37:36.515] Searching for globals...
[17:37:36.516] 
[17:37:36.516] Searching for globals ... DONE
[17:37:36.516] - globals: [0] <none>
[17:37:36.516] getGlobalsAndPackages() ... DONE
[17:37:36.516]    + additional globals found: [n=0] 
[17:37:36.516]    + additional namespaces needed: [n=0] 
[17:37:36.516]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:36.517]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:36.517]  - seeds: <none>
[17:37:36.517]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.517] getGlobalsAndPackages() ...
[17:37:36.517] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.517] Resolving globals: FALSE
[17:37:36.518] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:37:36.518] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:37:36.519] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.519] 
[17:37:36.519] getGlobalsAndPackages() ... DONE
[17:37:36.519] run() for ‘Future’ ...
[17:37:36.519] - state: ‘created’
[17:37:36.519] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:36.523] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.523] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:36.523]   - Field: ‘label’
[17:37:36.523]   - Field: ‘local’
[17:37:36.524]   - Field: ‘owner’
[17:37:36.524]   - Field: ‘envir’
[17:37:36.524]   - Field: ‘workers’
[17:37:36.524]   - Field: ‘packages’
[17:37:36.524]   - Field: ‘gc’
[17:37:36.524]   - Field: ‘job’
[17:37:36.524]   - Field: ‘conditions’
[17:37:36.524]   - Field: ‘expr’
[17:37:36.524]   - Field: ‘uuid’
[17:37:36.524]   - Field: ‘seed’
[17:37:36.525]   - Field: ‘version’
[17:37:36.525]   - Field: ‘result’
[17:37:36.525]   - Field: ‘asynchronous’
[17:37:36.525]   - Field: ‘calls’
[17:37:36.525]   - Field: ‘globals’
[17:37:36.525]   - Field: ‘stdout’
[17:37:36.525]   - Field: ‘earlySignal’
[17:37:36.525]   - Field: ‘lazy’
[17:37:36.525]   - Field: ‘state’
[17:37:36.525] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:36.525] - Launch lazy future ...
[17:37:36.526] Packages needed by the future expression (n = 0): <none>
[17:37:36.526] Packages needed by future strategies (n = 0): <none>
[17:37:36.526] {
[17:37:36.526]     {
[17:37:36.526]         {
[17:37:36.526]             ...future.startTime <- base::Sys.time()
[17:37:36.526]             {
[17:37:36.526]                 {
[17:37:36.526]                   {
[17:37:36.526]                     {
[17:37:36.526]                       base::local({
[17:37:36.526]                         has_future <- base::requireNamespace("future", 
[17:37:36.526]                           quietly = TRUE)
[17:37:36.526]                         if (has_future) {
[17:37:36.526]                           ns <- base::getNamespace("future")
[17:37:36.526]                           version <- ns[[".package"]][["version"]]
[17:37:36.526]                           if (is.null(version)) 
[17:37:36.526]                             version <- utils::packageVersion("future")
[17:37:36.526]                         }
[17:37:36.526]                         else {
[17:37:36.526]                           version <- NULL
[17:37:36.526]                         }
[17:37:36.526]                         if (!has_future || version < "1.8.0") {
[17:37:36.526]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:36.526]                             "", base::R.version$version.string), 
[17:37:36.526]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:36.526]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:36.526]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:36.526]                               "release", "version")], collapse = " "), 
[17:37:36.526]                             hostname = base::Sys.info()[["nodename"]])
[17:37:36.526]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:36.526]                             info)
[17:37:36.526]                           info <- base::paste(info, collapse = "; ")
[17:37:36.526]                           if (!has_future) {
[17:37:36.526]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:36.526]                               info)
[17:37:36.526]                           }
[17:37:36.526]                           else {
[17:37:36.526]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:36.526]                               info, version)
[17:37:36.526]                           }
[17:37:36.526]                           base::stop(msg)
[17:37:36.526]                         }
[17:37:36.526]                       })
[17:37:36.526]                     }
[17:37:36.526]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:36.526]                     base::options(mc.cores = 1L)
[17:37:36.526]                   }
[17:37:36.526]                   ...future.strategy.old <- future::plan("list")
[17:37:36.526]                   options(future.plan = NULL)
[17:37:36.526]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.526]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:36.526]                 }
[17:37:36.526]                 ...future.workdir <- getwd()
[17:37:36.526]             }
[17:37:36.526]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:36.526]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:36.526]         }
[17:37:36.526]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:36.526]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:36.526]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:36.526]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:36.526]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:36.526]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:36.526]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:36.526]             base::names(...future.oldOptions))
[17:37:36.526]     }
[17:37:36.526]     if (FALSE) {
[17:37:36.526]     }
[17:37:36.526]     else {
[17:37:36.526]         if (TRUE) {
[17:37:36.526]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:36.526]                 open = "w")
[17:37:36.526]         }
[17:37:36.526]         else {
[17:37:36.526]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:36.526]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:36.526]         }
[17:37:36.526]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:36.526]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:36.526]             base::sink(type = "output", split = FALSE)
[17:37:36.526]             base::close(...future.stdout)
[17:37:36.526]         }, add = TRUE)
[17:37:36.526]     }
[17:37:36.526]     ...future.frame <- base::sys.nframe()
[17:37:36.526]     ...future.conditions <- base::list()
[17:37:36.526]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:36.526]     if (FALSE) {
[17:37:36.526]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:36.526]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:36.526]     }
[17:37:36.526]     ...future.result <- base::tryCatch({
[17:37:36.526]         base::withCallingHandlers({
[17:37:36.526]             ...future.value <- base::withVisible(base::local({
[17:37:36.526]                 withCallingHandlers({
[17:37:36.526]                   {
[17:37:36.526]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.526]                     if (!identical(...future.globals.maxSize.org, 
[17:37:36.526]                       ...future.globals.maxSize)) {
[17:37:36.526]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.526]                       on.exit(options(oopts), add = TRUE)
[17:37:36.526]                     }
[17:37:36.526]                     {
[17:37:36.526]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.526]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:36.526]                         USE.NAMES = FALSE)
[17:37:36.526]                       do.call(mapply, args = args)
[17:37:36.526]                     }
[17:37:36.526]                   }
[17:37:36.526]                 }, immediateCondition = function(cond) {
[17:37:36.526]                   save_rds <- function (object, pathname, ...) 
[17:37:36.526]                   {
[17:37:36.526]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:36.526]                     if (file_test("-f", pathname_tmp)) {
[17:37:36.526]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.526]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:36.526]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.526]                         fi_tmp[["mtime"]])
[17:37:36.526]                     }
[17:37:36.526]                     tryCatch({
[17:37:36.526]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:36.526]                     }, error = function(ex) {
[17:37:36.526]                       msg <- conditionMessage(ex)
[17:37:36.526]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.526]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:36.526]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.526]                         fi_tmp[["mtime"]], msg)
[17:37:36.526]                       ex$message <- msg
[17:37:36.526]                       stop(ex)
[17:37:36.526]                     })
[17:37:36.526]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:36.526]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:36.526]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:36.526]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.526]                       fi <- file.info(pathname)
[17:37:36.526]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:36.526]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.526]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:36.526]                         fi[["size"]], fi[["mtime"]])
[17:37:36.526]                       stop(msg)
[17:37:36.526]                     }
[17:37:36.526]                     invisible(pathname)
[17:37:36.526]                   }
[17:37:36.526]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:36.526]                     rootPath = tempdir()) 
[17:37:36.526]                   {
[17:37:36.526]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:36.526]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:36.526]                       tmpdir = path, fileext = ".rds")
[17:37:36.526]                     save_rds(obj, file)
[17:37:36.526]                   }
[17:37:36.526]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:36.526]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.526]                   {
[17:37:36.526]                     inherits <- base::inherits
[17:37:36.526]                     invokeRestart <- base::invokeRestart
[17:37:36.526]                     is.null <- base::is.null
[17:37:36.526]                     muffled <- FALSE
[17:37:36.526]                     if (inherits(cond, "message")) {
[17:37:36.526]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:36.526]                       if (muffled) 
[17:37:36.526]                         invokeRestart("muffleMessage")
[17:37:36.526]                     }
[17:37:36.526]                     else if (inherits(cond, "warning")) {
[17:37:36.526]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:36.526]                       if (muffled) 
[17:37:36.526]                         invokeRestart("muffleWarning")
[17:37:36.526]                     }
[17:37:36.526]                     else if (inherits(cond, "condition")) {
[17:37:36.526]                       if (!is.null(pattern)) {
[17:37:36.526]                         computeRestarts <- base::computeRestarts
[17:37:36.526]                         grepl <- base::grepl
[17:37:36.526]                         restarts <- computeRestarts(cond)
[17:37:36.526]                         for (restart in restarts) {
[17:37:36.526]                           name <- restart$name
[17:37:36.526]                           if (is.null(name)) 
[17:37:36.526]                             next
[17:37:36.526]                           if (!grepl(pattern, name)) 
[17:37:36.526]                             next
[17:37:36.526]                           invokeRestart(restart)
[17:37:36.526]                           muffled <- TRUE
[17:37:36.526]                           break
[17:37:36.526]                         }
[17:37:36.526]                       }
[17:37:36.526]                     }
[17:37:36.526]                     invisible(muffled)
[17:37:36.526]                   }
[17:37:36.526]                   muffleCondition(cond)
[17:37:36.526]                 })
[17:37:36.526]             }))
[17:37:36.526]             future::FutureResult(value = ...future.value$value, 
[17:37:36.526]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.526]                   ...future.rng), globalenv = if (FALSE) 
[17:37:36.526]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:36.526]                     ...future.globalenv.names))
[17:37:36.526]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:36.526]         }, condition = base::local({
[17:37:36.526]             c <- base::c
[17:37:36.526]             inherits <- base::inherits
[17:37:36.526]             invokeRestart <- base::invokeRestart
[17:37:36.526]             length <- base::length
[17:37:36.526]             list <- base::list
[17:37:36.526]             seq.int <- base::seq.int
[17:37:36.526]             signalCondition <- base::signalCondition
[17:37:36.526]             sys.calls <- base::sys.calls
[17:37:36.526]             `[[` <- base::`[[`
[17:37:36.526]             `+` <- base::`+`
[17:37:36.526]             `<<-` <- base::`<<-`
[17:37:36.526]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:36.526]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:36.526]                   3L)]
[17:37:36.526]             }
[17:37:36.526]             function(cond) {
[17:37:36.526]                 is_error <- inherits(cond, "error")
[17:37:36.526]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:36.526]                   NULL)
[17:37:36.526]                 if (is_error) {
[17:37:36.526]                   sessionInformation <- function() {
[17:37:36.526]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:36.526]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:36.526]                       search = base::search(), system = base::Sys.info())
[17:37:36.526]                   }
[17:37:36.526]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.526]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:36.526]                     cond$call), session = sessionInformation(), 
[17:37:36.526]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:36.526]                   signalCondition(cond)
[17:37:36.526]                 }
[17:37:36.526]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:36.526]                 "immediateCondition"))) {
[17:37:36.526]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:36.526]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.526]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:36.526]                   if (TRUE && !signal) {
[17:37:36.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.526]                     {
[17:37:36.526]                       inherits <- base::inherits
[17:37:36.526]                       invokeRestart <- base::invokeRestart
[17:37:36.526]                       is.null <- base::is.null
[17:37:36.526]                       muffled <- FALSE
[17:37:36.526]                       if (inherits(cond, "message")) {
[17:37:36.526]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.526]                         if (muffled) 
[17:37:36.526]                           invokeRestart("muffleMessage")
[17:37:36.526]                       }
[17:37:36.526]                       else if (inherits(cond, "warning")) {
[17:37:36.526]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.526]                         if (muffled) 
[17:37:36.526]                           invokeRestart("muffleWarning")
[17:37:36.526]                       }
[17:37:36.526]                       else if (inherits(cond, "condition")) {
[17:37:36.526]                         if (!is.null(pattern)) {
[17:37:36.526]                           computeRestarts <- base::computeRestarts
[17:37:36.526]                           grepl <- base::grepl
[17:37:36.526]                           restarts <- computeRestarts(cond)
[17:37:36.526]                           for (restart in restarts) {
[17:37:36.526]                             name <- restart$name
[17:37:36.526]                             if (is.null(name)) 
[17:37:36.526]                               next
[17:37:36.526]                             if (!grepl(pattern, name)) 
[17:37:36.526]                               next
[17:37:36.526]                             invokeRestart(restart)
[17:37:36.526]                             muffled <- TRUE
[17:37:36.526]                             break
[17:37:36.526]                           }
[17:37:36.526]                         }
[17:37:36.526]                       }
[17:37:36.526]                       invisible(muffled)
[17:37:36.526]                     }
[17:37:36.526]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.526]                   }
[17:37:36.526]                 }
[17:37:36.526]                 else {
[17:37:36.526]                   if (TRUE) {
[17:37:36.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.526]                     {
[17:37:36.526]                       inherits <- base::inherits
[17:37:36.526]                       invokeRestart <- base::invokeRestart
[17:37:36.526]                       is.null <- base::is.null
[17:37:36.526]                       muffled <- FALSE
[17:37:36.526]                       if (inherits(cond, "message")) {
[17:37:36.526]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.526]                         if (muffled) 
[17:37:36.526]                           invokeRestart("muffleMessage")
[17:37:36.526]                       }
[17:37:36.526]                       else if (inherits(cond, "warning")) {
[17:37:36.526]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.526]                         if (muffled) 
[17:37:36.526]                           invokeRestart("muffleWarning")
[17:37:36.526]                       }
[17:37:36.526]                       else if (inherits(cond, "condition")) {
[17:37:36.526]                         if (!is.null(pattern)) {
[17:37:36.526]                           computeRestarts <- base::computeRestarts
[17:37:36.526]                           grepl <- base::grepl
[17:37:36.526]                           restarts <- computeRestarts(cond)
[17:37:36.526]                           for (restart in restarts) {
[17:37:36.526]                             name <- restart$name
[17:37:36.526]                             if (is.null(name)) 
[17:37:36.526]                               next
[17:37:36.526]                             if (!grepl(pattern, name)) 
[17:37:36.526]                               next
[17:37:36.526]                             invokeRestart(restart)
[17:37:36.526]                             muffled <- TRUE
[17:37:36.526]                             break
[17:37:36.526]                           }
[17:37:36.526]                         }
[17:37:36.526]                       }
[17:37:36.526]                       invisible(muffled)
[17:37:36.526]                     }
[17:37:36.526]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.526]                   }
[17:37:36.526]                 }
[17:37:36.526]             }
[17:37:36.526]         }))
[17:37:36.526]     }, error = function(ex) {
[17:37:36.526]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:36.526]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.526]                 ...future.rng), started = ...future.startTime, 
[17:37:36.526]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:36.526]             version = "1.8"), class = "FutureResult")
[17:37:36.526]     }, finally = {
[17:37:36.526]         if (!identical(...future.workdir, getwd())) 
[17:37:36.526]             setwd(...future.workdir)
[17:37:36.526]         {
[17:37:36.526]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:36.526]                 ...future.oldOptions$nwarnings <- NULL
[17:37:36.526]             }
[17:37:36.526]             base::options(...future.oldOptions)
[17:37:36.526]             if (.Platform$OS.type == "windows") {
[17:37:36.526]                 old_names <- names(...future.oldEnvVars)
[17:37:36.526]                 envs <- base::Sys.getenv()
[17:37:36.526]                 names <- names(envs)
[17:37:36.526]                 common <- intersect(names, old_names)
[17:37:36.526]                 added <- setdiff(names, old_names)
[17:37:36.526]                 removed <- setdiff(old_names, names)
[17:37:36.526]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:36.526]                   envs[common]]
[17:37:36.526]                 NAMES <- toupper(changed)
[17:37:36.526]                 args <- list()
[17:37:36.526]                 for (kk in seq_along(NAMES)) {
[17:37:36.526]                   name <- changed[[kk]]
[17:37:36.526]                   NAME <- NAMES[[kk]]
[17:37:36.526]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.526]                     next
[17:37:36.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.526]                 }
[17:37:36.526]                 NAMES <- toupper(added)
[17:37:36.526]                 for (kk in seq_along(NAMES)) {
[17:37:36.526]                   name <- added[[kk]]
[17:37:36.526]                   NAME <- NAMES[[kk]]
[17:37:36.526]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.526]                     next
[17:37:36.526]                   args[[name]] <- ""
[17:37:36.526]                 }
[17:37:36.526]                 NAMES <- toupper(removed)
[17:37:36.526]                 for (kk in seq_along(NAMES)) {
[17:37:36.526]                   name <- removed[[kk]]
[17:37:36.526]                   NAME <- NAMES[[kk]]
[17:37:36.526]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.526]                     next
[17:37:36.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.526]                 }
[17:37:36.526]                 if (length(args) > 0) 
[17:37:36.526]                   base::do.call(base::Sys.setenv, args = args)
[17:37:36.526]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:36.526]             }
[17:37:36.526]             else {
[17:37:36.526]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:36.526]             }
[17:37:36.526]             {
[17:37:36.526]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:36.526]                   0L) {
[17:37:36.526]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:36.526]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:36.526]                   base::options(opts)
[17:37:36.526]                 }
[17:37:36.526]                 {
[17:37:36.526]                   {
[17:37:36.526]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:36.526]                     NULL
[17:37:36.526]                   }
[17:37:36.526]                   options(future.plan = NULL)
[17:37:36.526]                   if (is.na(NA_character_)) 
[17:37:36.526]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.526]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:36.526]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:36.526]                     .init = FALSE)
[17:37:36.526]                 }
[17:37:36.526]             }
[17:37:36.526]         }
[17:37:36.526]     })
[17:37:36.526]     if (TRUE) {
[17:37:36.526]         base::sink(type = "output", split = FALSE)
[17:37:36.526]         if (TRUE) {
[17:37:36.526]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:36.526]         }
[17:37:36.526]         else {
[17:37:36.526]             ...future.result["stdout"] <- base::list(NULL)
[17:37:36.526]         }
[17:37:36.526]         base::close(...future.stdout)
[17:37:36.526]         ...future.stdout <- NULL
[17:37:36.526]     }
[17:37:36.526]     ...future.result$conditions <- ...future.conditions
[17:37:36.526]     ...future.result$finished <- base::Sys.time()
[17:37:36.526]     ...future.result
[17:37:36.526] }
[17:37:36.529] assign_globals() ...
[17:37:36.529] List of 5
[17:37:36.529]  $ ...future.FUN            :function (x, y)  
[17:37:36.529]  $ MoreArgs                 :List of 1
[17:37:36.529]   ..$ y: int [1:2] 3 4
[17:37:36.529]  $ ...future.elements_ii    :List of 1
[17:37:36.529]   ..$ x:List of 1
[17:37:36.529]   .. ..$ : int 1
[17:37:36.529]  $ ...future.seeds_ii       : NULL
[17:37:36.529]  $ ...future.globals.maxSize: NULL
[17:37:36.529]  - attr(*, "where")=List of 5
[17:37:36.529]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:36.529]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:36.529]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:36.529]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:36.529]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:36.529]  - attr(*, "resolved")= logi FALSE
[17:37:36.529]  - attr(*, "total_size")= num 1816
[17:37:36.529]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.529]  - attr(*, "already-done")= logi TRUE
[17:37:36.534] - reassign environment for ‘...future.FUN’
[17:37:36.534] - copied ‘...future.FUN’ to environment
[17:37:36.534] - copied ‘MoreArgs’ to environment
[17:37:36.534] - copied ‘...future.elements_ii’ to environment
[17:37:36.534] - copied ‘...future.seeds_ii’ to environment
[17:37:36.534] - copied ‘...future.globals.maxSize’ to environment
[17:37:36.535] assign_globals() ... done
[17:37:36.535] requestCore(): workers = 2
[17:37:36.537] MulticoreFuture started
[17:37:36.537] - Launch lazy future ... done
[17:37:36.538] run() for ‘MulticoreFuture’ ... done
[17:37:36.538] Created future:
[17:37:36.538] plan(): Setting new future strategy stack:
[17:37:36.538] List of future strategies:
[17:37:36.538] 1. sequential:
[17:37:36.538]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:36.538]    - tweaked: FALSE
[17:37:36.538]    - call: NULL
[17:37:36.539] plan(): nbrOfWorkers() = 1
[17:37:36.541] plan(): Setting new future strategy stack:
[17:37:36.542] List of future strategies:
[17:37:36.542] 1. multicore:
[17:37:36.542]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:36.542]    - tweaked: FALSE
[17:37:36.542]    - call: plan(strategy)
[17:37:36.538] MulticoreFuture:
[17:37:36.538] Label: ‘future_mapply-1’
[17:37:36.538] Expression:
[17:37:36.538] {
[17:37:36.538]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.538]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:36.538]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.538]         on.exit(options(oopts), add = TRUE)
[17:37:36.538]     }
[17:37:36.538]     {
[17:37:36.538]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.538]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:36.538]         do.call(mapply, args = args)
[17:37:36.538]     }
[17:37:36.538] }
[17:37:36.538] Lazy evaluation: FALSE
[17:37:36.538] Asynchronous evaluation: TRUE
[17:37:36.538] Local evaluation: TRUE
[17:37:36.538] Environment: R_GlobalEnv
[17:37:36.538] Capture standard output: TRUE
[17:37:36.538] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:36.538] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:36.538] Packages: <none>
[17:37:36.538] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:36.538] Resolved: FALSE
[17:37:36.538] Value: <not collected>
[17:37:36.538] Conditions captured: <none>
[17:37:36.538] Early signaling: FALSE
[17:37:36.538] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:36.538] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.551] Chunk #1 of 2 ... DONE
[17:37:36.551] Chunk #2 of 2 ...
[17:37:36.551]  - Finding globals in '...' for chunk #2 ...
[17:37:36.551] getGlobalsAndPackages() ...
[17:37:36.551] Searching for globals...
[17:37:36.553] plan(): nbrOfWorkers() = 2
[17:37:36.555] 
[17:37:36.555] Searching for globals ... DONE
[17:37:36.556] - globals: [0] <none>
[17:37:36.556] getGlobalsAndPackages() ... DONE
[17:37:36.556]    + additional globals found: [n=0] 
[17:37:36.556]    + additional namespaces needed: [n=0] 
[17:37:36.556]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:36.557]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:36.557]  - seeds: <none>
[17:37:36.557]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.558] getGlobalsAndPackages() ...
[17:37:36.558] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.558] Resolving globals: FALSE
[17:37:36.559] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:37:36.560] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:37:36.561] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.561] 
[17:37:36.561] getGlobalsAndPackages() ... DONE
[17:37:36.562] run() for ‘Future’ ...
[17:37:36.562] - state: ‘created’
[17:37:36.562] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:36.568] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.568] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:36.569]   - Field: ‘label’
[17:37:36.569]   - Field: ‘local’
[17:37:36.569]   - Field: ‘owner’
[17:37:36.569]   - Field: ‘envir’
[17:37:36.569]   - Field: ‘workers’
[17:37:36.569]   - Field: ‘packages’
[17:37:36.570]   - Field: ‘gc’
[17:37:36.570]   - Field: ‘job’
[17:37:36.570]   - Field: ‘conditions’
[17:37:36.570]   - Field: ‘expr’
[17:37:36.570]   - Field: ‘uuid’
[17:37:36.570]   - Field: ‘seed’
[17:37:36.570]   - Field: ‘version’
[17:37:36.570]   - Field: ‘result’
[17:37:36.571]   - Field: ‘asynchronous’
[17:37:36.571]   - Field: ‘calls’
[17:37:36.571]   - Field: ‘globals’
[17:37:36.571]   - Field: ‘stdout’
[17:37:36.571]   - Field: ‘earlySignal’
[17:37:36.571]   - Field: ‘lazy’
[17:37:36.571]   - Field: ‘state’
[17:37:36.572] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:36.572] - Launch lazy future ...
[17:37:36.572] Packages needed by the future expression (n = 0): <none>
[17:37:36.572] Packages needed by future strategies (n = 0): <none>
[17:37:36.573] {
[17:37:36.573]     {
[17:37:36.573]         {
[17:37:36.573]             ...future.startTime <- base::Sys.time()
[17:37:36.573]             {
[17:37:36.573]                 {
[17:37:36.573]                   {
[17:37:36.573]                     {
[17:37:36.573]                       base::local({
[17:37:36.573]                         has_future <- base::requireNamespace("future", 
[17:37:36.573]                           quietly = TRUE)
[17:37:36.573]                         if (has_future) {
[17:37:36.573]                           ns <- base::getNamespace("future")
[17:37:36.573]                           version <- ns[[".package"]][["version"]]
[17:37:36.573]                           if (is.null(version)) 
[17:37:36.573]                             version <- utils::packageVersion("future")
[17:37:36.573]                         }
[17:37:36.573]                         else {
[17:37:36.573]                           version <- NULL
[17:37:36.573]                         }
[17:37:36.573]                         if (!has_future || version < "1.8.0") {
[17:37:36.573]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:36.573]                             "", base::R.version$version.string), 
[17:37:36.573]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:36.573]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:36.573]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:36.573]                               "release", "version")], collapse = " "), 
[17:37:36.573]                             hostname = base::Sys.info()[["nodename"]])
[17:37:36.573]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:36.573]                             info)
[17:37:36.573]                           info <- base::paste(info, collapse = "; ")
[17:37:36.573]                           if (!has_future) {
[17:37:36.573]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:36.573]                               info)
[17:37:36.573]                           }
[17:37:36.573]                           else {
[17:37:36.573]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:36.573]                               info, version)
[17:37:36.573]                           }
[17:37:36.573]                           base::stop(msg)
[17:37:36.573]                         }
[17:37:36.573]                       })
[17:37:36.573]                     }
[17:37:36.573]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:36.573]                     base::options(mc.cores = 1L)
[17:37:36.573]                   }
[17:37:36.573]                   ...future.strategy.old <- future::plan("list")
[17:37:36.573]                   options(future.plan = NULL)
[17:37:36.573]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.573]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:36.573]                 }
[17:37:36.573]                 ...future.workdir <- getwd()
[17:37:36.573]             }
[17:37:36.573]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:36.573]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:36.573]         }
[17:37:36.573]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:36.573]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:36.573]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:36.573]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:36.573]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:36.573]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:36.573]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:36.573]             base::names(...future.oldOptions))
[17:37:36.573]     }
[17:37:36.573]     if (FALSE) {
[17:37:36.573]     }
[17:37:36.573]     else {
[17:37:36.573]         if (TRUE) {
[17:37:36.573]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:36.573]                 open = "w")
[17:37:36.573]         }
[17:37:36.573]         else {
[17:37:36.573]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:36.573]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:36.573]         }
[17:37:36.573]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:36.573]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:36.573]             base::sink(type = "output", split = FALSE)
[17:37:36.573]             base::close(...future.stdout)
[17:37:36.573]         }, add = TRUE)
[17:37:36.573]     }
[17:37:36.573]     ...future.frame <- base::sys.nframe()
[17:37:36.573]     ...future.conditions <- base::list()
[17:37:36.573]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:36.573]     if (FALSE) {
[17:37:36.573]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:36.573]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:36.573]     }
[17:37:36.573]     ...future.result <- base::tryCatch({
[17:37:36.573]         base::withCallingHandlers({
[17:37:36.573]             ...future.value <- base::withVisible(base::local({
[17:37:36.573]                 withCallingHandlers({
[17:37:36.573]                   {
[17:37:36.573]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.573]                     if (!identical(...future.globals.maxSize.org, 
[17:37:36.573]                       ...future.globals.maxSize)) {
[17:37:36.573]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.573]                       on.exit(options(oopts), add = TRUE)
[17:37:36.573]                     }
[17:37:36.573]                     {
[17:37:36.573]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.573]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:36.573]                         USE.NAMES = FALSE)
[17:37:36.573]                       do.call(mapply, args = args)
[17:37:36.573]                     }
[17:37:36.573]                   }
[17:37:36.573]                 }, immediateCondition = function(cond) {
[17:37:36.573]                   save_rds <- function (object, pathname, ...) 
[17:37:36.573]                   {
[17:37:36.573]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:36.573]                     if (file_test("-f", pathname_tmp)) {
[17:37:36.573]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.573]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:36.573]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.573]                         fi_tmp[["mtime"]])
[17:37:36.573]                     }
[17:37:36.573]                     tryCatch({
[17:37:36.573]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:36.573]                     }, error = function(ex) {
[17:37:36.573]                       msg <- conditionMessage(ex)
[17:37:36.573]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.573]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:36.573]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.573]                         fi_tmp[["mtime"]], msg)
[17:37:36.573]                       ex$message <- msg
[17:37:36.573]                       stop(ex)
[17:37:36.573]                     })
[17:37:36.573]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:36.573]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:36.573]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:36.573]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.573]                       fi <- file.info(pathname)
[17:37:36.573]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:36.573]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.573]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:36.573]                         fi[["size"]], fi[["mtime"]])
[17:37:36.573]                       stop(msg)
[17:37:36.573]                     }
[17:37:36.573]                     invisible(pathname)
[17:37:36.573]                   }
[17:37:36.573]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:36.573]                     rootPath = tempdir()) 
[17:37:36.573]                   {
[17:37:36.573]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:36.573]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:36.573]                       tmpdir = path, fileext = ".rds")
[17:37:36.573]                     save_rds(obj, file)
[17:37:36.573]                   }
[17:37:36.573]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:36.573]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.573]                   {
[17:37:36.573]                     inherits <- base::inherits
[17:37:36.573]                     invokeRestart <- base::invokeRestart
[17:37:36.573]                     is.null <- base::is.null
[17:37:36.573]                     muffled <- FALSE
[17:37:36.573]                     if (inherits(cond, "message")) {
[17:37:36.573]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:36.573]                       if (muffled) 
[17:37:36.573]                         invokeRestart("muffleMessage")
[17:37:36.573]                     }
[17:37:36.573]                     else if (inherits(cond, "warning")) {
[17:37:36.573]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:36.573]                       if (muffled) 
[17:37:36.573]                         invokeRestart("muffleWarning")
[17:37:36.573]                     }
[17:37:36.573]                     else if (inherits(cond, "condition")) {
[17:37:36.573]                       if (!is.null(pattern)) {
[17:37:36.573]                         computeRestarts <- base::computeRestarts
[17:37:36.573]                         grepl <- base::grepl
[17:37:36.573]                         restarts <- computeRestarts(cond)
[17:37:36.573]                         for (restart in restarts) {
[17:37:36.573]                           name <- restart$name
[17:37:36.573]                           if (is.null(name)) 
[17:37:36.573]                             next
[17:37:36.573]                           if (!grepl(pattern, name)) 
[17:37:36.573]                             next
[17:37:36.573]                           invokeRestart(restart)
[17:37:36.573]                           muffled <- TRUE
[17:37:36.573]                           break
[17:37:36.573]                         }
[17:37:36.573]                       }
[17:37:36.573]                     }
[17:37:36.573]                     invisible(muffled)
[17:37:36.573]                   }
[17:37:36.573]                   muffleCondition(cond)
[17:37:36.573]                 })
[17:37:36.573]             }))
[17:37:36.573]             future::FutureResult(value = ...future.value$value, 
[17:37:36.573]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.573]                   ...future.rng), globalenv = if (FALSE) 
[17:37:36.573]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:36.573]                     ...future.globalenv.names))
[17:37:36.573]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:36.573]         }, condition = base::local({
[17:37:36.573]             c <- base::c
[17:37:36.573]             inherits <- base::inherits
[17:37:36.573]             invokeRestart <- base::invokeRestart
[17:37:36.573]             length <- base::length
[17:37:36.573]             list <- base::list
[17:37:36.573]             seq.int <- base::seq.int
[17:37:36.573]             signalCondition <- base::signalCondition
[17:37:36.573]             sys.calls <- base::sys.calls
[17:37:36.573]             `[[` <- base::`[[`
[17:37:36.573]             `+` <- base::`+`
[17:37:36.573]             `<<-` <- base::`<<-`
[17:37:36.573]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:36.573]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:36.573]                   3L)]
[17:37:36.573]             }
[17:37:36.573]             function(cond) {
[17:37:36.573]                 is_error <- inherits(cond, "error")
[17:37:36.573]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:36.573]                   NULL)
[17:37:36.573]                 if (is_error) {
[17:37:36.573]                   sessionInformation <- function() {
[17:37:36.573]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:36.573]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:36.573]                       search = base::search(), system = base::Sys.info())
[17:37:36.573]                   }
[17:37:36.573]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.573]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:36.573]                     cond$call), session = sessionInformation(), 
[17:37:36.573]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:36.573]                   signalCondition(cond)
[17:37:36.573]                 }
[17:37:36.573]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:36.573]                 "immediateCondition"))) {
[17:37:36.573]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:36.573]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.573]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:36.573]                   if (TRUE && !signal) {
[17:37:36.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.573]                     {
[17:37:36.573]                       inherits <- base::inherits
[17:37:36.573]                       invokeRestart <- base::invokeRestart
[17:37:36.573]                       is.null <- base::is.null
[17:37:36.573]                       muffled <- FALSE
[17:37:36.573]                       if (inherits(cond, "message")) {
[17:37:36.573]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.573]                         if (muffled) 
[17:37:36.573]                           invokeRestart("muffleMessage")
[17:37:36.573]                       }
[17:37:36.573]                       else if (inherits(cond, "warning")) {
[17:37:36.573]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.573]                         if (muffled) 
[17:37:36.573]                           invokeRestart("muffleWarning")
[17:37:36.573]                       }
[17:37:36.573]                       else if (inherits(cond, "condition")) {
[17:37:36.573]                         if (!is.null(pattern)) {
[17:37:36.573]                           computeRestarts <- base::computeRestarts
[17:37:36.573]                           grepl <- base::grepl
[17:37:36.573]                           restarts <- computeRestarts(cond)
[17:37:36.573]                           for (restart in restarts) {
[17:37:36.573]                             name <- restart$name
[17:37:36.573]                             if (is.null(name)) 
[17:37:36.573]                               next
[17:37:36.573]                             if (!grepl(pattern, name)) 
[17:37:36.573]                               next
[17:37:36.573]                             invokeRestart(restart)
[17:37:36.573]                             muffled <- TRUE
[17:37:36.573]                             break
[17:37:36.573]                           }
[17:37:36.573]                         }
[17:37:36.573]                       }
[17:37:36.573]                       invisible(muffled)
[17:37:36.573]                     }
[17:37:36.573]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.573]                   }
[17:37:36.573]                 }
[17:37:36.573]                 else {
[17:37:36.573]                   if (TRUE) {
[17:37:36.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.573]                     {
[17:37:36.573]                       inherits <- base::inherits
[17:37:36.573]                       invokeRestart <- base::invokeRestart
[17:37:36.573]                       is.null <- base::is.null
[17:37:36.573]                       muffled <- FALSE
[17:37:36.573]                       if (inherits(cond, "message")) {
[17:37:36.573]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.573]                         if (muffled) 
[17:37:36.573]                           invokeRestart("muffleMessage")
[17:37:36.573]                       }
[17:37:36.573]                       else if (inherits(cond, "warning")) {
[17:37:36.573]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.573]                         if (muffled) 
[17:37:36.573]                           invokeRestart("muffleWarning")
[17:37:36.573]                       }
[17:37:36.573]                       else if (inherits(cond, "condition")) {
[17:37:36.573]                         if (!is.null(pattern)) {
[17:37:36.573]                           computeRestarts <- base::computeRestarts
[17:37:36.573]                           grepl <- base::grepl
[17:37:36.573]                           restarts <- computeRestarts(cond)
[17:37:36.573]                           for (restart in restarts) {
[17:37:36.573]                             name <- restart$name
[17:37:36.573]                             if (is.null(name)) 
[17:37:36.573]                               next
[17:37:36.573]                             if (!grepl(pattern, name)) 
[17:37:36.573]                               next
[17:37:36.573]                             invokeRestart(restart)
[17:37:36.573]                             muffled <- TRUE
[17:37:36.573]                             break
[17:37:36.573]                           }
[17:37:36.573]                         }
[17:37:36.573]                       }
[17:37:36.573]                       invisible(muffled)
[17:37:36.573]                     }
[17:37:36.573]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.573]                   }
[17:37:36.573]                 }
[17:37:36.573]             }
[17:37:36.573]         }))
[17:37:36.573]     }, error = function(ex) {
[17:37:36.573]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:36.573]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.573]                 ...future.rng), started = ...future.startTime, 
[17:37:36.573]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:36.573]             version = "1.8"), class = "FutureResult")
[17:37:36.573]     }, finally = {
[17:37:36.573]         if (!identical(...future.workdir, getwd())) 
[17:37:36.573]             setwd(...future.workdir)
[17:37:36.573]         {
[17:37:36.573]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:36.573]                 ...future.oldOptions$nwarnings <- NULL
[17:37:36.573]             }
[17:37:36.573]             base::options(...future.oldOptions)
[17:37:36.573]             if (.Platform$OS.type == "windows") {
[17:37:36.573]                 old_names <- names(...future.oldEnvVars)
[17:37:36.573]                 envs <- base::Sys.getenv()
[17:37:36.573]                 names <- names(envs)
[17:37:36.573]                 common <- intersect(names, old_names)
[17:37:36.573]                 added <- setdiff(names, old_names)
[17:37:36.573]                 removed <- setdiff(old_names, names)
[17:37:36.573]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:36.573]                   envs[common]]
[17:37:36.573]                 NAMES <- toupper(changed)
[17:37:36.573]                 args <- list()
[17:37:36.573]                 for (kk in seq_along(NAMES)) {
[17:37:36.573]                   name <- changed[[kk]]
[17:37:36.573]                   NAME <- NAMES[[kk]]
[17:37:36.573]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.573]                     next
[17:37:36.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.573]                 }
[17:37:36.573]                 NAMES <- toupper(added)
[17:37:36.573]                 for (kk in seq_along(NAMES)) {
[17:37:36.573]                   name <- added[[kk]]
[17:37:36.573]                   NAME <- NAMES[[kk]]
[17:37:36.573]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.573]                     next
[17:37:36.573]                   args[[name]] <- ""
[17:37:36.573]                 }
[17:37:36.573]                 NAMES <- toupper(removed)
[17:37:36.573]                 for (kk in seq_along(NAMES)) {
[17:37:36.573]                   name <- removed[[kk]]
[17:37:36.573]                   NAME <- NAMES[[kk]]
[17:37:36.573]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.573]                     next
[17:37:36.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.573]                 }
[17:37:36.573]                 if (length(args) > 0) 
[17:37:36.573]                   base::do.call(base::Sys.setenv, args = args)
[17:37:36.573]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:36.573]             }
[17:37:36.573]             else {
[17:37:36.573]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:36.573]             }
[17:37:36.573]             {
[17:37:36.573]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:36.573]                   0L) {
[17:37:36.573]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:36.573]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:36.573]                   base::options(opts)
[17:37:36.573]                 }
[17:37:36.573]                 {
[17:37:36.573]                   {
[17:37:36.573]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:36.573]                     NULL
[17:37:36.573]                   }
[17:37:36.573]                   options(future.plan = NULL)
[17:37:36.573]                   if (is.na(NA_character_)) 
[17:37:36.573]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.573]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:36.573]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:36.573]                     .init = FALSE)
[17:37:36.573]                 }
[17:37:36.573]             }
[17:37:36.573]         }
[17:37:36.573]     })
[17:37:36.573]     if (TRUE) {
[17:37:36.573]         base::sink(type = "output", split = FALSE)
[17:37:36.573]         if (TRUE) {
[17:37:36.573]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:36.573]         }
[17:37:36.573]         else {
[17:37:36.573]             ...future.result["stdout"] <- base::list(NULL)
[17:37:36.573]         }
[17:37:36.573]         base::close(...future.stdout)
[17:37:36.573]         ...future.stdout <- NULL
[17:37:36.573]     }
[17:37:36.573]     ...future.result$conditions <- ...future.conditions
[17:37:36.573]     ...future.result$finished <- base::Sys.time()
[17:37:36.573]     ...future.result
[17:37:36.573] }
[17:37:36.576] assign_globals() ...
[17:37:36.576] List of 5
[17:37:36.576]  $ ...future.FUN            :function (x, y)  
[17:37:36.576]  $ MoreArgs                 :List of 1
[17:37:36.576]   ..$ y: int [1:2] 3 4
[17:37:36.576]  $ ...future.elements_ii    :List of 1
[17:37:36.576]   ..$ x:List of 1
[17:37:36.576]   .. ..$ : int 2
[17:37:36.576]  $ ...future.seeds_ii       : NULL
[17:37:36.576]  $ ...future.globals.maxSize: NULL
[17:37:36.576]  - attr(*, "where")=List of 5
[17:37:36.576]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:36.576]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:36.576]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:36.576]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:36.576]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:36.576]  - attr(*, "resolved")= logi FALSE
[17:37:36.576]  - attr(*, "total_size")= num 1816
[17:37:36.576]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.576]  - attr(*, "already-done")= logi TRUE
[17:37:36.582] - reassign environment for ‘...future.FUN’
[17:37:36.582] - copied ‘...future.FUN’ to environment
[17:37:36.583] - copied ‘MoreArgs’ to environment
[17:37:36.583] - copied ‘...future.elements_ii’ to environment
[17:37:36.583] - copied ‘...future.seeds_ii’ to environment
[17:37:36.583] - copied ‘...future.globals.maxSize’ to environment
[17:37:36.583] assign_globals() ... done
[17:37:36.583] requestCore(): workers = 2
[17:37:36.586] MulticoreFuture started
[17:37:36.586] - Launch lazy future ... done
[17:37:36.586] run() for ‘MulticoreFuture’ ... done
[17:37:36.587] Created future:
[17:37:36.587] plan(): Setting new future strategy stack:
[17:37:36.587] List of future strategies:
[17:37:36.587] 1. sequential:
[17:37:36.587]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:36.587]    - tweaked: FALSE
[17:37:36.587]    - call: NULL
[17:37:36.588] plan(): nbrOfWorkers() = 1
[17:37:36.590] plan(): Setting new future strategy stack:
[17:37:36.590] List of future strategies:
[17:37:36.590] 1. multicore:
[17:37:36.590]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:36.590]    - tweaked: FALSE
[17:37:36.590]    - call: plan(strategy)
[17:37:36.595] plan(): nbrOfWorkers() = 2
[17:37:36.587] MulticoreFuture:
[17:37:36.587] Label: ‘future_mapply-2’
[17:37:36.587] Expression:
[17:37:36.587] {
[17:37:36.587]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.587]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:36.587]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.587]         on.exit(options(oopts), add = TRUE)
[17:37:36.587]     }
[17:37:36.587]     {
[17:37:36.587]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.587]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:36.587]         do.call(mapply, args = args)
[17:37:36.587]     }
[17:37:36.587] }
[17:37:36.587] Lazy evaluation: FALSE
[17:37:36.587] Asynchronous evaluation: TRUE
[17:37:36.587] Local evaluation: TRUE
[17:37:36.587] Environment: R_GlobalEnv
[17:37:36.587] Capture standard output: TRUE
[17:37:36.587] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:36.587] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:36.587] Packages: <none>
[17:37:36.587] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:36.587] Resolved: TRUE
[17:37:36.587] Value: <not collected>
[17:37:36.587] Conditions captured: <none>
[17:37:36.587] Early signaling: FALSE
[17:37:36.587] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:36.587] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.597] Chunk #2 of 2 ... DONE
[17:37:36.597] Launching 2 futures (chunks) ... DONE
[17:37:36.597] Resolving 2 futures (chunks) ...
[17:37:36.597] resolve() on list ...
[17:37:36.597]  recursive: 0
[17:37:36.597]  length: 2
[17:37:36.597] 
[17:37:36.598] Future #1
[17:37:36.598] result() for MulticoreFuture ...
[17:37:36.599] result() for MulticoreFuture ...
[17:37:36.599] result() for MulticoreFuture ... done
[17:37:36.599] result() for MulticoreFuture ... done
[17:37:36.599] result() for MulticoreFuture ...
[17:37:36.599] result() for MulticoreFuture ... done
[17:37:36.600] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:37:36.600] - nx: 2
[17:37:36.600] - relay: TRUE
[17:37:36.600] - stdout: TRUE
[17:37:36.600] - signal: TRUE
[17:37:36.600] - resignal: FALSE
[17:37:36.601] - force: TRUE
[17:37:36.601] - relayed: [n=2] FALSE, FALSE
[17:37:36.601] - queued futures: [n=2] FALSE, FALSE
[17:37:36.601]  - until=1
[17:37:36.601]  - relaying element #1
[17:37:36.601] result() for MulticoreFuture ...
[17:37:36.602] result() for MulticoreFuture ... done
[17:37:36.611] result() for MulticoreFuture ...
[17:37:36.611] result() for MulticoreFuture ... done
[17:37:36.611] result() for MulticoreFuture ...
[17:37:36.611] result() for MulticoreFuture ... done
[17:37:36.611] result() for MulticoreFuture ...
[17:37:36.611] result() for MulticoreFuture ... done
[17:37:36.611] - relayed: [n=2] TRUE, FALSE
[17:37:36.612] - queued futures: [n=2] TRUE, FALSE
[17:37:36.612] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:37:36.612]  length: 1 (resolved future 1)
[17:37:36.612] Future #2
[17:37:36.612] result() for MulticoreFuture ...
[17:37:36.613] result() for MulticoreFuture ...
[17:37:36.613] result() for MulticoreFuture ... done
[17:37:36.614] result() for MulticoreFuture ... done
[17:37:36.614] result() for MulticoreFuture ...
[17:37:36.614] result() for MulticoreFuture ... done
[17:37:36.614] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:37:36.614] - nx: 2
[17:37:36.615] - relay: TRUE
[17:37:36.615] - stdout: TRUE
[17:37:36.615] - signal: TRUE
[17:37:36.615] - resignal: FALSE
[17:37:36.615] - force: TRUE
[17:37:36.615] - relayed: [n=2] TRUE, FALSE
[17:37:36.616] - queued futures: [n=2] TRUE, FALSE
[17:37:36.616]  - until=2
[17:37:36.616]  - relaying element #2
[17:37:36.616] result() for MulticoreFuture ...
[17:37:36.616] result() for MulticoreFuture ... done
[17:37:36.616] result() for MulticoreFuture ...
[17:37:36.617] result() for MulticoreFuture ... done
[17:37:36.617] result() for MulticoreFuture ...
[17:37:36.617] result() for MulticoreFuture ... done
[17:37:36.617] result() for MulticoreFuture ...
[17:37:36.617] result() for MulticoreFuture ... done
[17:37:36.617] - relayed: [n=2] TRUE, TRUE
[17:37:36.617] - queued futures: [n=2] TRUE, TRUE
[17:37:36.617] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:37:36.618]  length: 0 (resolved future 2)
[17:37:36.618] Relaying remaining futures
[17:37:36.618] signalConditionsASAP(NULL, pos=0) ...
[17:37:36.618] - nx: 2
[17:37:36.618] - relay: TRUE
[17:37:36.618] - stdout: TRUE
[17:37:36.618] - signal: TRUE
[17:37:36.618] - resignal: FALSE
[17:37:36.619] - force: TRUE
[17:37:36.619] - relayed: [n=2] TRUE, TRUE
[17:37:36.619] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:36.619] - relayed: [n=2] TRUE, TRUE
[17:37:36.619] - queued futures: [n=2] TRUE, TRUE
[17:37:36.619] signalConditionsASAP(NULL, pos=0) ... done
[17:37:36.619] resolve() on list ... DONE
[17:37:36.620] result() for MulticoreFuture ...
[17:37:36.620] result() for MulticoreFuture ... done
[17:37:36.620] result() for MulticoreFuture ...
[17:37:36.620] result() for MulticoreFuture ... done
[17:37:36.620] result() for MulticoreFuture ...
[17:37:36.620] result() for MulticoreFuture ... done
[17:37:36.620] result() for MulticoreFuture ...
[17:37:36.621] result() for MulticoreFuture ... done
[17:37:36.621]  - Number of value chunks collected: 2
[17:37:36.621] Resolving 2 futures (chunks) ... DONE
[17:37:36.621] Reducing values from 2 chunks ...
[17:37:36.621]  - Number of values collected after concatenation: 2
[17:37:36.621]  - Number of values expected: 2
[17:37:36.621] Reducing values from 2 chunks ... DONE
[17:37:36.621] future_mapply() ... DONE
[17:37:36.621] future_mapply() ...
[17:37:36.622] Generating random seeds ...
[17:37:36.622] Generating random seed streams for 2 elements ...
[17:37:36.622] Generating random seed streams for 2 elements ... DONE
[17:37:36.622] Generating random seeds ... DONE
[17:37:36.622] Will set RNG state on exit: 10407, -790978071, 1998022178, -68461757, -753596510, 1927991039, 1122918283
[17:37:36.626] Number of chunks: 2
[17:37:36.627] getGlobalsAndPackagesXApply() ...
[17:37:36.627]  - future.globals: TRUE
[17:37:36.627] getGlobalsAndPackages() ...
[17:37:36.627] Searching for globals...
[17:37:36.628] - globals found: [1] ‘FUN’
[17:37:36.628] Searching for globals ... DONE
[17:37:36.628] Resolving globals: FALSE
[17:37:36.629] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:37:36.629] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:37:36.629] - globals: [1] ‘FUN’
[17:37:36.629] 
[17:37:36.629] getGlobalsAndPackages() ... DONE
[17:37:36.629]  - globals found/used: [n=1] ‘FUN’
[17:37:36.630]  - needed namespaces: [n=0] 
[17:37:36.630] Finding globals ... DONE
[17:37:36.630] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:36.630] List of 2
[17:37:36.630]  $ ...future.FUN:function (x, y)  
[17:37:36.630]  $ MoreArgs     :List of 1
[17:37:36.630]   ..$ y: int [1:2] 3 4
[17:37:36.630]  - attr(*, "where")=List of 2
[17:37:36.630]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:36.630]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:36.630]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.630]  - attr(*, "resolved")= logi FALSE
[17:37:36.630]  - attr(*, "total_size")= num NA
[17:37:36.633] Packages to be attached in all futures: [n=0] 
[17:37:36.633] getGlobalsAndPackagesXApply() ... DONE
[17:37:36.633] Number of futures (= number of chunks): 2
[17:37:36.634] Launching 2 futures (chunks) ...
[17:37:36.634] Chunk #1 of 2 ...
[17:37:36.634]  - Finding globals in '...' for chunk #1 ...
[17:37:36.634] getGlobalsAndPackages() ...
[17:37:36.634] Searching for globals...
[17:37:36.634] 
[17:37:36.634] Searching for globals ... DONE
[17:37:36.634] - globals: [0] <none>
[17:37:36.635] getGlobalsAndPackages() ... DONE
[17:37:36.635]    + additional globals found: [n=0] 
[17:37:36.635]    + additional namespaces needed: [n=0] 
[17:37:36.635]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:36.635]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:36.635]  - seeds: [1] <seeds>
[17:37:36.635]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.635] getGlobalsAndPackages() ...
[17:37:36.635] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.635] Resolving globals: FALSE
[17:37:36.636] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[17:37:36.636] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:37:36.637] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.637] 
[17:37:36.637] getGlobalsAndPackages() ... DONE
[17:37:36.637] run() for ‘Future’ ...
[17:37:36.637] - state: ‘created’
[17:37:36.637] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:36.643] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.643] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:36.644]   - Field: ‘label’
[17:37:36.644]   - Field: ‘local’
[17:37:36.644]   - Field: ‘owner’
[17:37:36.644]   - Field: ‘envir’
[17:37:36.644]   - Field: ‘workers’
[17:37:36.644]   - Field: ‘packages’
[17:37:36.644]   - Field: ‘gc’
[17:37:36.644]   - Field: ‘job’
[17:37:36.645]   - Field: ‘conditions’
[17:37:36.645]   - Field: ‘expr’
[17:37:36.645]   - Field: ‘uuid’
[17:37:36.645]   - Field: ‘seed’
[17:37:36.645]   - Field: ‘version’
[17:37:36.645]   - Field: ‘result’
[17:37:36.645]   - Field: ‘asynchronous’
[17:37:36.645]   - Field: ‘calls’
[17:37:36.645]   - Field: ‘globals’
[17:37:36.646]   - Field: ‘stdout’
[17:37:36.646]   - Field: ‘earlySignal’
[17:37:36.646]   - Field: ‘lazy’
[17:37:36.646]   - Field: ‘state’
[17:37:36.646] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:36.646] - Launch lazy future ...
[17:37:36.646] Packages needed by the future expression (n = 0): <none>
[17:37:36.647] Packages needed by future strategies (n = 0): <none>
[17:37:36.647] {
[17:37:36.647]     {
[17:37:36.647]         {
[17:37:36.647]             ...future.startTime <- base::Sys.time()
[17:37:36.647]             {
[17:37:36.647]                 {
[17:37:36.647]                   {
[17:37:36.647]                     {
[17:37:36.647]                       base::local({
[17:37:36.647]                         has_future <- base::requireNamespace("future", 
[17:37:36.647]                           quietly = TRUE)
[17:37:36.647]                         if (has_future) {
[17:37:36.647]                           ns <- base::getNamespace("future")
[17:37:36.647]                           version <- ns[[".package"]][["version"]]
[17:37:36.647]                           if (is.null(version)) 
[17:37:36.647]                             version <- utils::packageVersion("future")
[17:37:36.647]                         }
[17:37:36.647]                         else {
[17:37:36.647]                           version <- NULL
[17:37:36.647]                         }
[17:37:36.647]                         if (!has_future || version < "1.8.0") {
[17:37:36.647]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:36.647]                             "", base::R.version$version.string), 
[17:37:36.647]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:36.647]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:36.647]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:36.647]                               "release", "version")], collapse = " "), 
[17:37:36.647]                             hostname = base::Sys.info()[["nodename"]])
[17:37:36.647]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:36.647]                             info)
[17:37:36.647]                           info <- base::paste(info, collapse = "; ")
[17:37:36.647]                           if (!has_future) {
[17:37:36.647]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:36.647]                               info)
[17:37:36.647]                           }
[17:37:36.647]                           else {
[17:37:36.647]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:36.647]                               info, version)
[17:37:36.647]                           }
[17:37:36.647]                           base::stop(msg)
[17:37:36.647]                         }
[17:37:36.647]                       })
[17:37:36.647]                     }
[17:37:36.647]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:36.647]                     base::options(mc.cores = 1L)
[17:37:36.647]                   }
[17:37:36.647]                   ...future.strategy.old <- future::plan("list")
[17:37:36.647]                   options(future.plan = NULL)
[17:37:36.647]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.647]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:36.647]                 }
[17:37:36.647]                 ...future.workdir <- getwd()
[17:37:36.647]             }
[17:37:36.647]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:36.647]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:36.647]         }
[17:37:36.647]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:36.647]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:36.647]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:36.647]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:36.647]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:36.647]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:36.647]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:36.647]             base::names(...future.oldOptions))
[17:37:36.647]     }
[17:37:36.647]     if (FALSE) {
[17:37:36.647]     }
[17:37:36.647]     else {
[17:37:36.647]         if (TRUE) {
[17:37:36.647]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:36.647]                 open = "w")
[17:37:36.647]         }
[17:37:36.647]         else {
[17:37:36.647]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:36.647]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:36.647]         }
[17:37:36.647]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:36.647]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:36.647]             base::sink(type = "output", split = FALSE)
[17:37:36.647]             base::close(...future.stdout)
[17:37:36.647]         }, add = TRUE)
[17:37:36.647]     }
[17:37:36.647]     ...future.frame <- base::sys.nframe()
[17:37:36.647]     ...future.conditions <- base::list()
[17:37:36.647]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:36.647]     if (FALSE) {
[17:37:36.647]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:36.647]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:36.647]     }
[17:37:36.647]     ...future.result <- base::tryCatch({
[17:37:36.647]         base::withCallingHandlers({
[17:37:36.647]             ...future.value <- base::withVisible(base::local({
[17:37:36.647]                 withCallingHandlers({
[17:37:36.647]                   {
[17:37:36.647]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.647]                     if (!identical(...future.globals.maxSize.org, 
[17:37:36.647]                       ...future.globals.maxSize)) {
[17:37:36.647]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.647]                       on.exit(options(oopts), add = TRUE)
[17:37:36.647]                     }
[17:37:36.647]                     {
[17:37:36.647]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:37:36.647]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:37:36.647]                           envir = globalenv(), inherits = FALSE)
[17:37:36.647]                         ...future.FUN(...)
[17:37:36.647]                       }
[17:37:36.647]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:37:36.647]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:37:36.647]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:36.647]                         USE.NAMES = FALSE)
[17:37:36.647]                       do.call(mapply, args = args)
[17:37:36.647]                     }
[17:37:36.647]                   }
[17:37:36.647]                 }, immediateCondition = function(cond) {
[17:37:36.647]                   save_rds <- function (object, pathname, ...) 
[17:37:36.647]                   {
[17:37:36.647]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:36.647]                     if (file_test("-f", pathname_tmp)) {
[17:37:36.647]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.647]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:36.647]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.647]                         fi_tmp[["mtime"]])
[17:37:36.647]                     }
[17:37:36.647]                     tryCatch({
[17:37:36.647]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:36.647]                     }, error = function(ex) {
[17:37:36.647]                       msg <- conditionMessage(ex)
[17:37:36.647]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.647]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:36.647]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.647]                         fi_tmp[["mtime"]], msg)
[17:37:36.647]                       ex$message <- msg
[17:37:36.647]                       stop(ex)
[17:37:36.647]                     })
[17:37:36.647]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:36.647]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:36.647]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:36.647]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.647]                       fi <- file.info(pathname)
[17:37:36.647]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:36.647]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.647]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:36.647]                         fi[["size"]], fi[["mtime"]])
[17:37:36.647]                       stop(msg)
[17:37:36.647]                     }
[17:37:36.647]                     invisible(pathname)
[17:37:36.647]                   }
[17:37:36.647]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:36.647]                     rootPath = tempdir()) 
[17:37:36.647]                   {
[17:37:36.647]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:36.647]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:36.647]                       tmpdir = path, fileext = ".rds")
[17:37:36.647]                     save_rds(obj, file)
[17:37:36.647]                   }
[17:37:36.647]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:36.647]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.647]                   {
[17:37:36.647]                     inherits <- base::inherits
[17:37:36.647]                     invokeRestart <- base::invokeRestart
[17:37:36.647]                     is.null <- base::is.null
[17:37:36.647]                     muffled <- FALSE
[17:37:36.647]                     if (inherits(cond, "message")) {
[17:37:36.647]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:36.647]                       if (muffled) 
[17:37:36.647]                         invokeRestart("muffleMessage")
[17:37:36.647]                     }
[17:37:36.647]                     else if (inherits(cond, "warning")) {
[17:37:36.647]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:36.647]                       if (muffled) 
[17:37:36.647]                         invokeRestart("muffleWarning")
[17:37:36.647]                     }
[17:37:36.647]                     else if (inherits(cond, "condition")) {
[17:37:36.647]                       if (!is.null(pattern)) {
[17:37:36.647]                         computeRestarts <- base::computeRestarts
[17:37:36.647]                         grepl <- base::grepl
[17:37:36.647]                         restarts <- computeRestarts(cond)
[17:37:36.647]                         for (restart in restarts) {
[17:37:36.647]                           name <- restart$name
[17:37:36.647]                           if (is.null(name)) 
[17:37:36.647]                             next
[17:37:36.647]                           if (!grepl(pattern, name)) 
[17:37:36.647]                             next
[17:37:36.647]                           invokeRestart(restart)
[17:37:36.647]                           muffled <- TRUE
[17:37:36.647]                           break
[17:37:36.647]                         }
[17:37:36.647]                       }
[17:37:36.647]                     }
[17:37:36.647]                     invisible(muffled)
[17:37:36.647]                   }
[17:37:36.647]                   muffleCondition(cond)
[17:37:36.647]                 })
[17:37:36.647]             }))
[17:37:36.647]             future::FutureResult(value = ...future.value$value, 
[17:37:36.647]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.647]                   ...future.rng), globalenv = if (FALSE) 
[17:37:36.647]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:36.647]                     ...future.globalenv.names))
[17:37:36.647]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:36.647]         }, condition = base::local({
[17:37:36.647]             c <- base::c
[17:37:36.647]             inherits <- base::inherits
[17:37:36.647]             invokeRestart <- base::invokeRestart
[17:37:36.647]             length <- base::length
[17:37:36.647]             list <- base::list
[17:37:36.647]             seq.int <- base::seq.int
[17:37:36.647]             signalCondition <- base::signalCondition
[17:37:36.647]             sys.calls <- base::sys.calls
[17:37:36.647]             `[[` <- base::`[[`
[17:37:36.647]             `+` <- base::`+`
[17:37:36.647]             `<<-` <- base::`<<-`
[17:37:36.647]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:36.647]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:36.647]                   3L)]
[17:37:36.647]             }
[17:37:36.647]             function(cond) {
[17:37:36.647]                 is_error <- inherits(cond, "error")
[17:37:36.647]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:36.647]                   NULL)
[17:37:36.647]                 if (is_error) {
[17:37:36.647]                   sessionInformation <- function() {
[17:37:36.647]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:36.647]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:36.647]                       search = base::search(), system = base::Sys.info())
[17:37:36.647]                   }
[17:37:36.647]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.647]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:36.647]                     cond$call), session = sessionInformation(), 
[17:37:36.647]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:36.647]                   signalCondition(cond)
[17:37:36.647]                 }
[17:37:36.647]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:36.647]                 "immediateCondition"))) {
[17:37:36.647]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:36.647]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.647]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:36.647]                   if (TRUE && !signal) {
[17:37:36.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.647]                     {
[17:37:36.647]                       inherits <- base::inherits
[17:37:36.647]                       invokeRestart <- base::invokeRestart
[17:37:36.647]                       is.null <- base::is.null
[17:37:36.647]                       muffled <- FALSE
[17:37:36.647]                       if (inherits(cond, "message")) {
[17:37:36.647]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.647]                         if (muffled) 
[17:37:36.647]                           invokeRestart("muffleMessage")
[17:37:36.647]                       }
[17:37:36.647]                       else if (inherits(cond, "warning")) {
[17:37:36.647]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.647]                         if (muffled) 
[17:37:36.647]                           invokeRestart("muffleWarning")
[17:37:36.647]                       }
[17:37:36.647]                       else if (inherits(cond, "condition")) {
[17:37:36.647]                         if (!is.null(pattern)) {
[17:37:36.647]                           computeRestarts <- base::computeRestarts
[17:37:36.647]                           grepl <- base::grepl
[17:37:36.647]                           restarts <- computeRestarts(cond)
[17:37:36.647]                           for (restart in restarts) {
[17:37:36.647]                             name <- restart$name
[17:37:36.647]                             if (is.null(name)) 
[17:37:36.647]                               next
[17:37:36.647]                             if (!grepl(pattern, name)) 
[17:37:36.647]                               next
[17:37:36.647]                             invokeRestart(restart)
[17:37:36.647]                             muffled <- TRUE
[17:37:36.647]                             break
[17:37:36.647]                           }
[17:37:36.647]                         }
[17:37:36.647]                       }
[17:37:36.647]                       invisible(muffled)
[17:37:36.647]                     }
[17:37:36.647]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.647]                   }
[17:37:36.647]                 }
[17:37:36.647]                 else {
[17:37:36.647]                   if (TRUE) {
[17:37:36.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.647]                     {
[17:37:36.647]                       inherits <- base::inherits
[17:37:36.647]                       invokeRestart <- base::invokeRestart
[17:37:36.647]                       is.null <- base::is.null
[17:37:36.647]                       muffled <- FALSE
[17:37:36.647]                       if (inherits(cond, "message")) {
[17:37:36.647]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.647]                         if (muffled) 
[17:37:36.647]                           invokeRestart("muffleMessage")
[17:37:36.647]                       }
[17:37:36.647]                       else if (inherits(cond, "warning")) {
[17:37:36.647]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.647]                         if (muffled) 
[17:37:36.647]                           invokeRestart("muffleWarning")
[17:37:36.647]                       }
[17:37:36.647]                       else if (inherits(cond, "condition")) {
[17:37:36.647]                         if (!is.null(pattern)) {
[17:37:36.647]                           computeRestarts <- base::computeRestarts
[17:37:36.647]                           grepl <- base::grepl
[17:37:36.647]                           restarts <- computeRestarts(cond)
[17:37:36.647]                           for (restart in restarts) {
[17:37:36.647]                             name <- restart$name
[17:37:36.647]                             if (is.null(name)) 
[17:37:36.647]                               next
[17:37:36.647]                             if (!grepl(pattern, name)) 
[17:37:36.647]                               next
[17:37:36.647]                             invokeRestart(restart)
[17:37:36.647]                             muffled <- TRUE
[17:37:36.647]                             break
[17:37:36.647]                           }
[17:37:36.647]                         }
[17:37:36.647]                       }
[17:37:36.647]                       invisible(muffled)
[17:37:36.647]                     }
[17:37:36.647]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.647]                   }
[17:37:36.647]                 }
[17:37:36.647]             }
[17:37:36.647]         }))
[17:37:36.647]     }, error = function(ex) {
[17:37:36.647]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:36.647]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.647]                 ...future.rng), started = ...future.startTime, 
[17:37:36.647]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:36.647]             version = "1.8"), class = "FutureResult")
[17:37:36.647]     }, finally = {
[17:37:36.647]         if (!identical(...future.workdir, getwd())) 
[17:37:36.647]             setwd(...future.workdir)
[17:37:36.647]         {
[17:37:36.647]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:36.647]                 ...future.oldOptions$nwarnings <- NULL
[17:37:36.647]             }
[17:37:36.647]             base::options(...future.oldOptions)
[17:37:36.647]             if (.Platform$OS.type == "windows") {
[17:37:36.647]                 old_names <- names(...future.oldEnvVars)
[17:37:36.647]                 envs <- base::Sys.getenv()
[17:37:36.647]                 names <- names(envs)
[17:37:36.647]                 common <- intersect(names, old_names)
[17:37:36.647]                 added <- setdiff(names, old_names)
[17:37:36.647]                 removed <- setdiff(old_names, names)
[17:37:36.647]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:36.647]                   envs[common]]
[17:37:36.647]                 NAMES <- toupper(changed)
[17:37:36.647]                 args <- list()
[17:37:36.647]                 for (kk in seq_along(NAMES)) {
[17:37:36.647]                   name <- changed[[kk]]
[17:37:36.647]                   NAME <- NAMES[[kk]]
[17:37:36.647]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.647]                     next
[17:37:36.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.647]                 }
[17:37:36.647]                 NAMES <- toupper(added)
[17:37:36.647]                 for (kk in seq_along(NAMES)) {
[17:37:36.647]                   name <- added[[kk]]
[17:37:36.647]                   NAME <- NAMES[[kk]]
[17:37:36.647]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.647]                     next
[17:37:36.647]                   args[[name]] <- ""
[17:37:36.647]                 }
[17:37:36.647]                 NAMES <- toupper(removed)
[17:37:36.647]                 for (kk in seq_along(NAMES)) {
[17:37:36.647]                   name <- removed[[kk]]
[17:37:36.647]                   NAME <- NAMES[[kk]]
[17:37:36.647]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.647]                     next
[17:37:36.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.647]                 }
[17:37:36.647]                 if (length(args) > 0) 
[17:37:36.647]                   base::do.call(base::Sys.setenv, args = args)
[17:37:36.647]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:36.647]             }
[17:37:36.647]             else {
[17:37:36.647]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:36.647]             }
[17:37:36.647]             {
[17:37:36.647]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:36.647]                   0L) {
[17:37:36.647]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:36.647]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:36.647]                   base::options(opts)
[17:37:36.647]                 }
[17:37:36.647]                 {
[17:37:36.647]                   {
[17:37:36.647]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:36.647]                     NULL
[17:37:36.647]                   }
[17:37:36.647]                   options(future.plan = NULL)
[17:37:36.647]                   if (is.na(NA_character_)) 
[17:37:36.647]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.647]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:36.647]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:36.647]                     .init = FALSE)
[17:37:36.647]                 }
[17:37:36.647]             }
[17:37:36.647]         }
[17:37:36.647]     })
[17:37:36.647]     if (TRUE) {
[17:37:36.647]         base::sink(type = "output", split = FALSE)
[17:37:36.647]         if (TRUE) {
[17:37:36.647]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:36.647]         }
[17:37:36.647]         else {
[17:37:36.647]             ...future.result["stdout"] <- base::list(NULL)
[17:37:36.647]         }
[17:37:36.647]         base::close(...future.stdout)
[17:37:36.647]         ...future.stdout <- NULL
[17:37:36.647]     }
[17:37:36.647]     ...future.result$conditions <- ...future.conditions
[17:37:36.647]     ...future.result$finished <- base::Sys.time()
[17:37:36.647]     ...future.result
[17:37:36.647] }
[17:37:36.649] assign_globals() ...
[17:37:36.650] List of 5
[17:37:36.650]  $ ...future.FUN            :function (x, y)  
[17:37:36.650]  $ MoreArgs                 :List of 1
[17:37:36.650]   ..$ y: int [1:2] 3 4
[17:37:36.650]  $ ...future.elements_ii    :List of 1
[17:37:36.650]   ..$ x:List of 1
[17:37:36.650]   .. ..$ : int 1
[17:37:36.650]  $ ...future.seeds_ii       :List of 1
[17:37:36.650]   ..$ : int [1:7] 10407 -2136641726 -1057916956 -265514552 1908717141 -643141726 -996514641
[17:37:36.650]  $ ...future.globals.maxSize: NULL
[17:37:36.650]  - attr(*, "where")=List of 5
[17:37:36.650]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:36.650]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:36.650]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:36.650]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:36.650]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:36.650]  - attr(*, "resolved")= logi FALSE
[17:37:36.650]  - attr(*, "total_size")= num 1896
[17:37:36.650]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.650]  - attr(*, "already-done")= logi TRUE
[17:37:36.655] - reassign environment for ‘...future.FUN’
[17:37:36.655] - copied ‘...future.FUN’ to environment
[17:37:36.655] - copied ‘MoreArgs’ to environment
[17:37:36.656] - copied ‘...future.elements_ii’ to environment
[17:37:36.656] - copied ‘...future.seeds_ii’ to environment
[17:37:36.656] - copied ‘...future.globals.maxSize’ to environment
[17:37:36.656] assign_globals() ... done
[17:37:36.656] requestCore(): workers = 2
[17:37:36.658] MulticoreFuture started
[17:37:36.659] - Launch lazy future ... done
[17:37:36.659] run() for ‘MulticoreFuture’ ... done
[17:37:36.659] Created future:
[17:37:36.659] plan(): Setting new future strategy stack:
[17:37:36.659] List of future strategies:
[17:37:36.659] 1. sequential:
[17:37:36.659]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:36.659]    - tweaked: FALSE
[17:37:36.659]    - call: NULL
[17:37:36.660] plan(): nbrOfWorkers() = 1
[17:37:36.663] plan(): Setting new future strategy stack:
[17:37:36.663] List of future strategies:
[17:37:36.663] 1. multicore:
[17:37:36.663]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:36.663]    - tweaked: FALSE
[17:37:36.663]    - call: plan(strategy)
[17:37:36.669] plan(): nbrOfWorkers() = 2
[17:37:36.659] MulticoreFuture:
[17:37:36.659] Label: ‘future_mapply-1’
[17:37:36.659] Expression:
[17:37:36.659] {
[17:37:36.659]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.659]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:36.659]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.659]         on.exit(options(oopts), add = TRUE)
[17:37:36.659]     }
[17:37:36.659]     {
[17:37:36.659]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:37:36.659]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:37:36.659]                 inherits = FALSE)
[17:37:36.659]             ...future.FUN(...)
[17:37:36.659]         }
[17:37:36.659]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:37:36.659]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:37:36.659]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:36.659]         do.call(mapply, args = args)
[17:37:36.659]     }
[17:37:36.659] }
[17:37:36.659] Lazy evaluation: FALSE
[17:37:36.659] Asynchronous evaluation: TRUE
[17:37:36.659] Local evaluation: TRUE
[17:37:36.659] Environment: R_GlobalEnv
[17:37:36.659] Capture standard output: TRUE
[17:37:36.659] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:36.659] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:36.659] Packages: <none>
[17:37:36.659] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:37:36.659] Resolved: TRUE
[17:37:36.659] Value: <not collected>
[17:37:36.659] Conditions captured: <none>
[17:37:36.659] Early signaling: FALSE
[17:37:36.659] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:36.659] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.670] Chunk #1 of 2 ... DONE
[17:37:36.670] Chunk #2 of 2 ...
[17:37:36.670]  - Finding globals in '...' for chunk #2 ...
[17:37:36.670] getGlobalsAndPackages() ...
[17:37:36.670] Searching for globals...
[17:37:36.671] 
[17:37:36.671] Searching for globals ... DONE
[17:37:36.671] - globals: [0] <none>
[17:37:36.671] getGlobalsAndPackages() ... DONE
[17:37:36.671]    + additional globals found: [n=0] 
[17:37:36.672]    + additional namespaces needed: [n=0] 
[17:37:36.672]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:36.672]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:36.672]  - seeds: [1] <seeds>
[17:37:36.672]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.672] getGlobalsAndPackages() ...
[17:37:36.672] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.673] Resolving globals: FALSE
[17:37:36.674] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[17:37:36.674] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:37:36.675] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.675] 
[17:37:36.675] getGlobalsAndPackages() ... DONE
[17:37:36.676] run() for ‘Future’ ...
[17:37:36.676] - state: ‘created’
[17:37:36.676] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:36.680] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.681] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:36.681]   - Field: ‘label’
[17:37:36.681]   - Field: ‘local’
[17:37:36.681]   - Field: ‘owner’
[17:37:36.681]   - Field: ‘envir’
[17:37:36.682]   - Field: ‘workers’
[17:37:36.682]   - Field: ‘packages’
[17:37:36.682]   - Field: ‘gc’
[17:37:36.682]   - Field: ‘job’
[17:37:36.682]   - Field: ‘conditions’
[17:37:36.682]   - Field: ‘expr’
[17:37:36.683]   - Field: ‘uuid’
[17:37:36.683]   - Field: ‘seed’
[17:37:36.683]   - Field: ‘version’
[17:37:36.683]   - Field: ‘result’
[17:37:36.683]   - Field: ‘asynchronous’
[17:37:36.683]   - Field: ‘calls’
[17:37:36.684]   - Field: ‘globals’
[17:37:36.684]   - Field: ‘stdout’
[17:37:36.684]   - Field: ‘earlySignal’
[17:37:36.684]   - Field: ‘lazy’
[17:37:36.684]   - Field: ‘state’
[17:37:36.684] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:36.684] - Launch lazy future ...
[17:37:36.685] Packages needed by the future expression (n = 0): <none>
[17:37:36.685] Packages needed by future strategies (n = 0): <none>
[17:37:36.690] {
[17:37:36.690]     {
[17:37:36.690]         {
[17:37:36.690]             ...future.startTime <- base::Sys.time()
[17:37:36.690]             {
[17:37:36.690]                 {
[17:37:36.690]                   {
[17:37:36.690]                     {
[17:37:36.690]                       base::local({
[17:37:36.690]                         has_future <- base::requireNamespace("future", 
[17:37:36.690]                           quietly = TRUE)
[17:37:36.690]                         if (has_future) {
[17:37:36.690]                           ns <- base::getNamespace("future")
[17:37:36.690]                           version <- ns[[".package"]][["version"]]
[17:37:36.690]                           if (is.null(version)) 
[17:37:36.690]                             version <- utils::packageVersion("future")
[17:37:36.690]                         }
[17:37:36.690]                         else {
[17:37:36.690]                           version <- NULL
[17:37:36.690]                         }
[17:37:36.690]                         if (!has_future || version < "1.8.0") {
[17:37:36.690]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:36.690]                             "", base::R.version$version.string), 
[17:37:36.690]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:36.690]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:36.690]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:36.690]                               "release", "version")], collapse = " "), 
[17:37:36.690]                             hostname = base::Sys.info()[["nodename"]])
[17:37:36.690]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:36.690]                             info)
[17:37:36.690]                           info <- base::paste(info, collapse = "; ")
[17:37:36.690]                           if (!has_future) {
[17:37:36.690]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:36.690]                               info)
[17:37:36.690]                           }
[17:37:36.690]                           else {
[17:37:36.690]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:36.690]                               info, version)
[17:37:36.690]                           }
[17:37:36.690]                           base::stop(msg)
[17:37:36.690]                         }
[17:37:36.690]                       })
[17:37:36.690]                     }
[17:37:36.690]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:36.690]                     base::options(mc.cores = 1L)
[17:37:36.690]                   }
[17:37:36.690]                   ...future.strategy.old <- future::plan("list")
[17:37:36.690]                   options(future.plan = NULL)
[17:37:36.690]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.690]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:36.690]                 }
[17:37:36.690]                 ...future.workdir <- getwd()
[17:37:36.690]             }
[17:37:36.690]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:36.690]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:36.690]         }
[17:37:36.690]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:36.690]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:36.690]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:36.690]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:36.690]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:36.690]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:36.690]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:36.690]             base::names(...future.oldOptions))
[17:37:36.690]     }
[17:37:36.690]     if (FALSE) {
[17:37:36.690]     }
[17:37:36.690]     else {
[17:37:36.690]         if (TRUE) {
[17:37:36.690]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:36.690]                 open = "w")
[17:37:36.690]         }
[17:37:36.690]         else {
[17:37:36.690]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:36.690]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:36.690]         }
[17:37:36.690]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:36.690]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:36.690]             base::sink(type = "output", split = FALSE)
[17:37:36.690]             base::close(...future.stdout)
[17:37:36.690]         }, add = TRUE)
[17:37:36.690]     }
[17:37:36.690]     ...future.frame <- base::sys.nframe()
[17:37:36.690]     ...future.conditions <- base::list()
[17:37:36.690]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:36.690]     if (FALSE) {
[17:37:36.690]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:36.690]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:36.690]     }
[17:37:36.690]     ...future.result <- base::tryCatch({
[17:37:36.690]         base::withCallingHandlers({
[17:37:36.690]             ...future.value <- base::withVisible(base::local({
[17:37:36.690]                 withCallingHandlers({
[17:37:36.690]                   {
[17:37:36.690]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.690]                     if (!identical(...future.globals.maxSize.org, 
[17:37:36.690]                       ...future.globals.maxSize)) {
[17:37:36.690]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.690]                       on.exit(options(oopts), add = TRUE)
[17:37:36.690]                     }
[17:37:36.690]                     {
[17:37:36.690]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:37:36.690]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:37:36.690]                           envir = globalenv(), inherits = FALSE)
[17:37:36.690]                         ...future.FUN(...)
[17:37:36.690]                       }
[17:37:36.690]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:37:36.690]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:37:36.690]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:36.690]                         USE.NAMES = FALSE)
[17:37:36.690]                       do.call(mapply, args = args)
[17:37:36.690]                     }
[17:37:36.690]                   }
[17:37:36.690]                 }, immediateCondition = function(cond) {
[17:37:36.690]                   save_rds <- function (object, pathname, ...) 
[17:37:36.690]                   {
[17:37:36.690]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:36.690]                     if (file_test("-f", pathname_tmp)) {
[17:37:36.690]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.690]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:36.690]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.690]                         fi_tmp[["mtime"]])
[17:37:36.690]                     }
[17:37:36.690]                     tryCatch({
[17:37:36.690]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:36.690]                     }, error = function(ex) {
[17:37:36.690]                       msg <- conditionMessage(ex)
[17:37:36.690]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.690]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:36.690]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.690]                         fi_tmp[["mtime"]], msg)
[17:37:36.690]                       ex$message <- msg
[17:37:36.690]                       stop(ex)
[17:37:36.690]                     })
[17:37:36.690]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:36.690]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:36.690]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:36.690]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.690]                       fi <- file.info(pathname)
[17:37:36.690]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:36.690]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.690]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:36.690]                         fi[["size"]], fi[["mtime"]])
[17:37:36.690]                       stop(msg)
[17:37:36.690]                     }
[17:37:36.690]                     invisible(pathname)
[17:37:36.690]                   }
[17:37:36.690]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:36.690]                     rootPath = tempdir()) 
[17:37:36.690]                   {
[17:37:36.690]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:36.690]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:36.690]                       tmpdir = path, fileext = ".rds")
[17:37:36.690]                     save_rds(obj, file)
[17:37:36.690]                   }
[17:37:36.690]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:36.690]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.690]                   {
[17:37:36.690]                     inherits <- base::inherits
[17:37:36.690]                     invokeRestart <- base::invokeRestart
[17:37:36.690]                     is.null <- base::is.null
[17:37:36.690]                     muffled <- FALSE
[17:37:36.690]                     if (inherits(cond, "message")) {
[17:37:36.690]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:36.690]                       if (muffled) 
[17:37:36.690]                         invokeRestart("muffleMessage")
[17:37:36.690]                     }
[17:37:36.690]                     else if (inherits(cond, "warning")) {
[17:37:36.690]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:36.690]                       if (muffled) 
[17:37:36.690]                         invokeRestart("muffleWarning")
[17:37:36.690]                     }
[17:37:36.690]                     else if (inherits(cond, "condition")) {
[17:37:36.690]                       if (!is.null(pattern)) {
[17:37:36.690]                         computeRestarts <- base::computeRestarts
[17:37:36.690]                         grepl <- base::grepl
[17:37:36.690]                         restarts <- computeRestarts(cond)
[17:37:36.690]                         for (restart in restarts) {
[17:37:36.690]                           name <- restart$name
[17:37:36.690]                           if (is.null(name)) 
[17:37:36.690]                             next
[17:37:36.690]                           if (!grepl(pattern, name)) 
[17:37:36.690]                             next
[17:37:36.690]                           invokeRestart(restart)
[17:37:36.690]                           muffled <- TRUE
[17:37:36.690]                           break
[17:37:36.690]                         }
[17:37:36.690]                       }
[17:37:36.690]                     }
[17:37:36.690]                     invisible(muffled)
[17:37:36.690]                   }
[17:37:36.690]                   muffleCondition(cond)
[17:37:36.690]                 })
[17:37:36.690]             }))
[17:37:36.690]             future::FutureResult(value = ...future.value$value, 
[17:37:36.690]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.690]                   ...future.rng), globalenv = if (FALSE) 
[17:37:36.690]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:36.690]                     ...future.globalenv.names))
[17:37:36.690]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:36.690]         }, condition = base::local({
[17:37:36.690]             c <- base::c
[17:37:36.690]             inherits <- base::inherits
[17:37:36.690]             invokeRestart <- base::invokeRestart
[17:37:36.690]             length <- base::length
[17:37:36.690]             list <- base::list
[17:37:36.690]             seq.int <- base::seq.int
[17:37:36.690]             signalCondition <- base::signalCondition
[17:37:36.690]             sys.calls <- base::sys.calls
[17:37:36.690]             `[[` <- base::`[[`
[17:37:36.690]             `+` <- base::`+`
[17:37:36.690]             `<<-` <- base::`<<-`
[17:37:36.690]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:36.690]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:36.690]                   3L)]
[17:37:36.690]             }
[17:37:36.690]             function(cond) {
[17:37:36.690]                 is_error <- inherits(cond, "error")
[17:37:36.690]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:36.690]                   NULL)
[17:37:36.690]                 if (is_error) {
[17:37:36.690]                   sessionInformation <- function() {
[17:37:36.690]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:36.690]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:36.690]                       search = base::search(), system = base::Sys.info())
[17:37:36.690]                   }
[17:37:36.690]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.690]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:36.690]                     cond$call), session = sessionInformation(), 
[17:37:36.690]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:36.690]                   signalCondition(cond)
[17:37:36.690]                 }
[17:37:36.690]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:36.690]                 "immediateCondition"))) {
[17:37:36.690]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:36.690]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.690]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:36.690]                   if (TRUE && !signal) {
[17:37:36.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.690]                     {
[17:37:36.690]                       inherits <- base::inherits
[17:37:36.690]                       invokeRestart <- base::invokeRestart
[17:37:36.690]                       is.null <- base::is.null
[17:37:36.690]                       muffled <- FALSE
[17:37:36.690]                       if (inherits(cond, "message")) {
[17:37:36.690]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.690]                         if (muffled) 
[17:37:36.690]                           invokeRestart("muffleMessage")
[17:37:36.690]                       }
[17:37:36.690]                       else if (inherits(cond, "warning")) {
[17:37:36.690]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.690]                         if (muffled) 
[17:37:36.690]                           invokeRestart("muffleWarning")
[17:37:36.690]                       }
[17:37:36.690]                       else if (inherits(cond, "condition")) {
[17:37:36.690]                         if (!is.null(pattern)) {
[17:37:36.690]                           computeRestarts <- base::computeRestarts
[17:37:36.690]                           grepl <- base::grepl
[17:37:36.690]                           restarts <- computeRestarts(cond)
[17:37:36.690]                           for (restart in restarts) {
[17:37:36.690]                             name <- restart$name
[17:37:36.690]                             if (is.null(name)) 
[17:37:36.690]                               next
[17:37:36.690]                             if (!grepl(pattern, name)) 
[17:37:36.690]                               next
[17:37:36.690]                             invokeRestart(restart)
[17:37:36.690]                             muffled <- TRUE
[17:37:36.690]                             break
[17:37:36.690]                           }
[17:37:36.690]                         }
[17:37:36.690]                       }
[17:37:36.690]                       invisible(muffled)
[17:37:36.690]                     }
[17:37:36.690]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.690]                   }
[17:37:36.690]                 }
[17:37:36.690]                 else {
[17:37:36.690]                   if (TRUE) {
[17:37:36.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.690]                     {
[17:37:36.690]                       inherits <- base::inherits
[17:37:36.690]                       invokeRestart <- base::invokeRestart
[17:37:36.690]                       is.null <- base::is.null
[17:37:36.690]                       muffled <- FALSE
[17:37:36.690]                       if (inherits(cond, "message")) {
[17:37:36.690]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.690]                         if (muffled) 
[17:37:36.690]                           invokeRestart("muffleMessage")
[17:37:36.690]                       }
[17:37:36.690]                       else if (inherits(cond, "warning")) {
[17:37:36.690]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.690]                         if (muffled) 
[17:37:36.690]                           invokeRestart("muffleWarning")
[17:37:36.690]                       }
[17:37:36.690]                       else if (inherits(cond, "condition")) {
[17:37:36.690]                         if (!is.null(pattern)) {
[17:37:36.690]                           computeRestarts <- base::computeRestarts
[17:37:36.690]                           grepl <- base::grepl
[17:37:36.690]                           restarts <- computeRestarts(cond)
[17:37:36.690]                           for (restart in restarts) {
[17:37:36.690]                             name <- restart$name
[17:37:36.690]                             if (is.null(name)) 
[17:37:36.690]                               next
[17:37:36.690]                             if (!grepl(pattern, name)) 
[17:37:36.690]                               next
[17:37:36.690]                             invokeRestart(restart)
[17:37:36.690]                             muffled <- TRUE
[17:37:36.690]                             break
[17:37:36.690]                           }
[17:37:36.690]                         }
[17:37:36.690]                       }
[17:37:36.690]                       invisible(muffled)
[17:37:36.690]                     }
[17:37:36.690]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.690]                   }
[17:37:36.690]                 }
[17:37:36.690]             }
[17:37:36.690]         }))
[17:37:36.690]     }, error = function(ex) {
[17:37:36.690]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:36.690]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.690]                 ...future.rng), started = ...future.startTime, 
[17:37:36.690]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:36.690]             version = "1.8"), class = "FutureResult")
[17:37:36.690]     }, finally = {
[17:37:36.690]         if (!identical(...future.workdir, getwd())) 
[17:37:36.690]             setwd(...future.workdir)
[17:37:36.690]         {
[17:37:36.690]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:36.690]                 ...future.oldOptions$nwarnings <- NULL
[17:37:36.690]             }
[17:37:36.690]             base::options(...future.oldOptions)
[17:37:36.690]             if (.Platform$OS.type == "windows") {
[17:37:36.690]                 old_names <- names(...future.oldEnvVars)
[17:37:36.690]                 envs <- base::Sys.getenv()
[17:37:36.690]                 names <- names(envs)
[17:37:36.690]                 common <- intersect(names, old_names)
[17:37:36.690]                 added <- setdiff(names, old_names)
[17:37:36.690]                 removed <- setdiff(old_names, names)
[17:37:36.690]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:36.690]                   envs[common]]
[17:37:36.690]                 NAMES <- toupper(changed)
[17:37:36.690]                 args <- list()
[17:37:36.690]                 for (kk in seq_along(NAMES)) {
[17:37:36.690]                   name <- changed[[kk]]
[17:37:36.690]                   NAME <- NAMES[[kk]]
[17:37:36.690]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.690]                     next
[17:37:36.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.690]                 }
[17:37:36.690]                 NAMES <- toupper(added)
[17:37:36.690]                 for (kk in seq_along(NAMES)) {
[17:37:36.690]                   name <- added[[kk]]
[17:37:36.690]                   NAME <- NAMES[[kk]]
[17:37:36.690]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.690]                     next
[17:37:36.690]                   args[[name]] <- ""
[17:37:36.690]                 }
[17:37:36.690]                 NAMES <- toupper(removed)
[17:37:36.690]                 for (kk in seq_along(NAMES)) {
[17:37:36.690]                   name <- removed[[kk]]
[17:37:36.690]                   NAME <- NAMES[[kk]]
[17:37:36.690]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.690]                     next
[17:37:36.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.690]                 }
[17:37:36.690]                 if (length(args) > 0) 
[17:37:36.690]                   base::do.call(base::Sys.setenv, args = args)
[17:37:36.690]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:36.690]             }
[17:37:36.690]             else {
[17:37:36.690]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:36.690]             }
[17:37:36.690]             {
[17:37:36.690]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:36.690]                   0L) {
[17:37:36.690]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:36.690]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:36.690]                   base::options(opts)
[17:37:36.690]                 }
[17:37:36.690]                 {
[17:37:36.690]                   {
[17:37:36.690]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:36.690]                     NULL
[17:37:36.690]                   }
[17:37:36.690]                   options(future.plan = NULL)
[17:37:36.690]                   if (is.na(NA_character_)) 
[17:37:36.690]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.690]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:36.690]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:36.690]                     .init = FALSE)
[17:37:36.690]                 }
[17:37:36.690]             }
[17:37:36.690]         }
[17:37:36.690]     })
[17:37:36.690]     if (TRUE) {
[17:37:36.690]         base::sink(type = "output", split = FALSE)
[17:37:36.690]         if (TRUE) {
[17:37:36.690]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:36.690]         }
[17:37:36.690]         else {
[17:37:36.690]             ...future.result["stdout"] <- base::list(NULL)
[17:37:36.690]         }
[17:37:36.690]         base::close(...future.stdout)
[17:37:36.690]         ...future.stdout <- NULL
[17:37:36.690]     }
[17:37:36.690]     ...future.result$conditions <- ...future.conditions
[17:37:36.690]     ...future.result$finished <- base::Sys.time()
[17:37:36.690]     ...future.result
[17:37:36.690] }
[17:37:36.693] assign_globals() ...
[17:37:36.693] List of 5
[17:37:36.693]  $ ...future.FUN            :function (x, y)  
[17:37:36.693]  $ MoreArgs                 :List of 1
[17:37:36.693]   ..$ y: int [1:2] 3 4
[17:37:36.693]  $ ...future.elements_ii    :List of 1
[17:37:36.693]   ..$ x:List of 1
[17:37:36.693]   .. ..$ : int 2
[17:37:36.693]  $ ...future.seeds_ii       :List of 1
[17:37:36.693]   ..$ : int [1:7] 10407 1393897242 1305686673 693708955 1677693833 1101178286 745388296
[17:37:36.693]  $ ...future.globals.maxSize: NULL
[17:37:36.693]  - attr(*, "where")=List of 5
[17:37:36.693]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:36.693]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:36.693]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:36.693]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:36.693]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:36.693]  - attr(*, "resolved")= logi FALSE
[17:37:36.693]  - attr(*, "total_size")= num 1896
[17:37:36.693]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.693]  - attr(*, "already-done")= logi TRUE
[17:37:36.704] - reassign environment for ‘...future.FUN’
[17:37:36.704] - copied ‘...future.FUN’ to environment
[17:37:36.704] - copied ‘MoreArgs’ to environment
[17:37:36.704] - copied ‘...future.elements_ii’ to environment
[17:37:36.704] - copied ‘...future.seeds_ii’ to environment
[17:37:36.704] - copied ‘...future.globals.maxSize’ to environment
[17:37:36.705] assign_globals() ... done
[17:37:36.705] requestCore(): workers = 2
[17:37:36.707] MulticoreFuture started
[17:37:36.708] - Launch lazy future ... done
[17:37:36.708] run() for ‘MulticoreFuture’ ... done
[17:37:36.708] plan(): Setting new future strategy stack:
[17:37:36.709] Created future:
[17:37:36.709] List of future strategies:
[17:37:36.709] 1. sequential:
[17:37:36.709]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:36.709]    - tweaked: FALSE
[17:37:36.709]    - call: NULL
[17:37:36.710] plan(): nbrOfWorkers() = 1
[17:37:36.712] plan(): Setting new future strategy stack:
[17:37:36.712] List of future strategies:
[17:37:36.712] 1. multicore:
[17:37:36.712]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:36.712]    - tweaked: FALSE
[17:37:36.712]    - call: plan(strategy)
[17:37:36.718] plan(): nbrOfWorkers() = 2
[17:37:36.709] MulticoreFuture:
[17:37:36.709] Label: ‘future_mapply-2’
[17:37:36.709] Expression:
[17:37:36.709] {
[17:37:36.709]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.709]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:36.709]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.709]         on.exit(options(oopts), add = TRUE)
[17:37:36.709]     }
[17:37:36.709]     {
[17:37:36.709]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:37:36.709]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:37:36.709]                 inherits = FALSE)
[17:37:36.709]             ...future.FUN(...)
[17:37:36.709]         }
[17:37:36.709]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:37:36.709]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:37:36.709]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:36.709]         do.call(mapply, args = args)
[17:37:36.709]     }
[17:37:36.709] }
[17:37:36.709] Lazy evaluation: FALSE
[17:37:36.709] Asynchronous evaluation: TRUE
[17:37:36.709] Local evaluation: TRUE
[17:37:36.709] Environment: R_GlobalEnv
[17:37:36.709] Capture standard output: TRUE
[17:37:36.709] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:36.709] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:36.709] Packages: <none>
[17:37:36.709] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:37:36.709] Resolved: TRUE
[17:37:36.709] Value: <not collected>
[17:37:36.709] Conditions captured: <none>
[17:37:36.709] Early signaling: FALSE
[17:37:36.709] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:36.709] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.720] Chunk #2 of 2 ... DONE
[17:37:36.720] Launching 2 futures (chunks) ... DONE
[17:37:36.720] Resolving 2 futures (chunks) ...
[17:37:36.720] resolve() on list ...
[17:37:36.720]  recursive: 0
[17:37:36.720]  length: 2
[17:37:36.721] 
[17:37:36.721] Future #1
[17:37:36.721] result() for MulticoreFuture ...
[17:37:36.722] result() for MulticoreFuture ...
[17:37:36.722] result() for MulticoreFuture ... done
[17:37:36.722] result() for MulticoreFuture ... done
[17:37:36.723] result() for MulticoreFuture ...
[17:37:36.723] result() for MulticoreFuture ... done
[17:37:36.723] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:37:36.723] - nx: 2
[17:37:36.723] - relay: TRUE
[17:37:36.723] - stdout: TRUE
[17:37:36.723] - signal: TRUE
[17:37:36.724] - resignal: FALSE
[17:37:36.724] - force: TRUE
[17:37:36.724] - relayed: [n=2] FALSE, FALSE
[17:37:36.724] - queued futures: [n=2] FALSE, FALSE
[17:37:36.724]  - until=1
[17:37:36.724]  - relaying element #1
[17:37:36.725] result() for MulticoreFuture ...
[17:37:36.725] result() for MulticoreFuture ... done
[17:37:36.725] result() for MulticoreFuture ...
[17:37:36.725] result() for MulticoreFuture ... done
[17:37:36.725] result() for MulticoreFuture ...
[17:37:36.726] result() for MulticoreFuture ... done
[17:37:36.726] result() for MulticoreFuture ...
[17:37:36.726] result() for MulticoreFuture ... done
[17:37:36.726] - relayed: [n=2] TRUE, FALSE
[17:37:36.726] - queued futures: [n=2] TRUE, FALSE
[17:37:36.726] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:37:36.726]  length: 1 (resolved future 1)
[17:37:36.727] Future #2
[17:37:36.727] result() for MulticoreFuture ...
[17:37:36.728] result() for MulticoreFuture ...
[17:37:36.728] result() for MulticoreFuture ... done
[17:37:36.728] result() for MulticoreFuture ... done
[17:37:36.728] result() for MulticoreFuture ...
[17:37:36.728] result() for MulticoreFuture ... done
[17:37:36.728] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:37:36.729] - nx: 2
[17:37:36.729] - relay: TRUE
[17:37:36.729] - stdout: TRUE
[17:37:36.729] - signal: TRUE
[17:37:36.729] - resignal: FALSE
[17:37:36.729] - force: TRUE
[17:37:36.729] - relayed: [n=2] TRUE, FALSE
[17:37:36.729] - queued futures: [n=2] TRUE, FALSE
[17:37:36.730]  - until=2
[17:37:36.730]  - relaying element #2
[17:37:36.730] result() for MulticoreFuture ...
[17:37:36.730] result() for MulticoreFuture ... done
[17:37:36.730] result() for MulticoreFuture ...
[17:37:36.730] result() for MulticoreFuture ... done
[17:37:36.730] result() for MulticoreFuture ...
[17:37:36.730] result() for MulticoreFuture ... done
[17:37:36.731] result() for MulticoreFuture ...
[17:37:36.731] result() for MulticoreFuture ... done
[17:37:36.731] - relayed: [n=2] TRUE, TRUE
[17:37:36.731] - queued futures: [n=2] TRUE, TRUE
[17:37:36.731] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:37:36.731]  length: 0 (resolved future 2)
[17:37:36.731] Relaying remaining futures
[17:37:36.731] signalConditionsASAP(NULL, pos=0) ...
[17:37:36.731] - nx: 2
[17:37:36.731] - relay: TRUE
[17:37:36.732] - stdout: TRUE
[17:37:36.732] - signal: TRUE
[17:37:36.732] - resignal: FALSE
[17:37:36.732] - force: TRUE
[17:37:36.732] - relayed: [n=2] TRUE, TRUE
[17:37:36.732] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:36.732] - relayed: [n=2] TRUE, TRUE
[17:37:36.732] - queued futures: [n=2] TRUE, TRUE
[17:37:36.733] signalConditionsASAP(NULL, pos=0) ... done
[17:37:36.733] resolve() on list ... DONE
[17:37:36.733] result() for MulticoreFuture ...
[17:37:36.733] result() for MulticoreFuture ... done
[17:37:36.733] result() for MulticoreFuture ...
[17:37:36.733] result() for MulticoreFuture ... done
[17:37:36.733] result() for MulticoreFuture ...
[17:37:36.733] result() for MulticoreFuture ... done
[17:37:36.734] result() for MulticoreFuture ...
[17:37:36.734] result() for MulticoreFuture ... done
[17:37:36.734]  - Number of value chunks collected: 2
[17:37:36.734] Resolving 2 futures (chunks) ... DONE
[17:37:36.734] Reducing values from 2 chunks ...
[17:37:36.734]  - Number of values collected after concatenation: 2
[17:37:36.734]  - Number of values expected: 2
[17:37:36.734] Reducing values from 2 chunks ... DONE
[17:37:36.735] future_mapply() ... DONE
[17:37:36.735] future_mapply() ...
[17:37:36.742] Number of chunks: 2
[17:37:36.743] getGlobalsAndPackagesXApply() ...
[17:37:36.743]  - future.globals: TRUE
[17:37:36.743] getGlobalsAndPackages() ...
[17:37:36.743] Searching for globals...
[17:37:36.745] - globals found: [1] ‘FUN’
[17:37:36.745] Searching for globals ... DONE
[17:37:36.745] Resolving globals: FALSE
[17:37:36.745] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:37:36.746] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:37:36.746] - globals: [1] ‘FUN’
[17:37:36.746] 
[17:37:36.746] getGlobalsAndPackages() ... DONE
[17:37:36.746]  - globals found/used: [n=1] ‘FUN’
[17:37:36.747]  - needed namespaces: [n=0] 
[17:37:36.747] Finding globals ... DONE
[17:37:36.747] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:36.747] List of 2
[17:37:36.747]  $ ...future.FUN:function (x, y)  
[17:37:36.747]  $ MoreArgs     :List of 1
[17:37:36.747]   ..$ y: int [1:2] 3 4
[17:37:36.747]  - attr(*, "where")=List of 2
[17:37:36.747]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:36.747]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:36.747]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.747]  - attr(*, "resolved")= logi FALSE
[17:37:36.747]  - attr(*, "total_size")= num NA
[17:37:36.751] Packages to be attached in all futures: [n=0] 
[17:37:36.751] getGlobalsAndPackagesXApply() ... DONE
[17:37:36.752] Number of futures (= number of chunks): 2
[17:37:36.752] Launching 2 futures (chunks) ...
[17:37:36.752] Chunk #1 of 2 ...
[17:37:36.752]  - Finding globals in '...' for chunk #1 ...
[17:37:36.752] getGlobalsAndPackages() ...
[17:37:36.752] Searching for globals...
[17:37:36.752] 
[17:37:36.753] Searching for globals ... DONE
[17:37:36.753] - globals: [0] <none>
[17:37:36.753] getGlobalsAndPackages() ... DONE
[17:37:36.753]    + additional globals found: [n=0] 
[17:37:36.753]    + additional namespaces needed: [n=0] 
[17:37:36.753]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:36.753]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:36.753]  - seeds: <none>
[17:37:36.753]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.753] getGlobalsAndPackages() ...
[17:37:36.754] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.754] Resolving globals: FALSE
[17:37:36.754] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:37:36.755] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:37:36.755] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.755] 
[17:37:36.755] getGlobalsAndPackages() ... DONE
[17:37:36.755] run() for ‘Future’ ...
[17:37:36.755] - state: ‘created’
[17:37:36.756] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:36.760] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.760] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:36.760]   - Field: ‘label’
[17:37:36.760]   - Field: ‘local’
[17:37:36.760]   - Field: ‘owner’
[17:37:36.760]   - Field: ‘envir’
[17:37:36.760]   - Field: ‘workers’
[17:37:36.761]   - Field: ‘packages’
[17:37:36.761]   - Field: ‘gc’
[17:37:36.761]   - Field: ‘job’
[17:37:36.761]   - Field: ‘conditions’
[17:37:36.761]   - Field: ‘expr’
[17:37:36.761]   - Field: ‘uuid’
[17:37:36.761]   - Field: ‘seed’
[17:37:36.761]   - Field: ‘version’
[17:37:36.761]   - Field: ‘result’
[17:37:36.761]   - Field: ‘asynchronous’
[17:37:36.762]   - Field: ‘calls’
[17:37:36.762]   - Field: ‘globals’
[17:37:36.762]   - Field: ‘stdout’
[17:37:36.762]   - Field: ‘earlySignal’
[17:37:36.762]   - Field: ‘lazy’
[17:37:36.762]   - Field: ‘state’
[17:37:36.762] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:36.762] - Launch lazy future ...
[17:37:36.763] Packages needed by the future expression (n = 0): <none>
[17:37:36.763] Packages needed by future strategies (n = 0): <none>
[17:37:36.763] {
[17:37:36.763]     {
[17:37:36.763]         {
[17:37:36.763]             ...future.startTime <- base::Sys.time()
[17:37:36.763]             {
[17:37:36.763]                 {
[17:37:36.763]                   {
[17:37:36.763]                     {
[17:37:36.763]                       base::local({
[17:37:36.763]                         has_future <- base::requireNamespace("future", 
[17:37:36.763]                           quietly = TRUE)
[17:37:36.763]                         if (has_future) {
[17:37:36.763]                           ns <- base::getNamespace("future")
[17:37:36.763]                           version <- ns[[".package"]][["version"]]
[17:37:36.763]                           if (is.null(version)) 
[17:37:36.763]                             version <- utils::packageVersion("future")
[17:37:36.763]                         }
[17:37:36.763]                         else {
[17:37:36.763]                           version <- NULL
[17:37:36.763]                         }
[17:37:36.763]                         if (!has_future || version < "1.8.0") {
[17:37:36.763]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:36.763]                             "", base::R.version$version.string), 
[17:37:36.763]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:36.763]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:36.763]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:36.763]                               "release", "version")], collapse = " "), 
[17:37:36.763]                             hostname = base::Sys.info()[["nodename"]])
[17:37:36.763]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:36.763]                             info)
[17:37:36.763]                           info <- base::paste(info, collapse = "; ")
[17:37:36.763]                           if (!has_future) {
[17:37:36.763]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:36.763]                               info)
[17:37:36.763]                           }
[17:37:36.763]                           else {
[17:37:36.763]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:36.763]                               info, version)
[17:37:36.763]                           }
[17:37:36.763]                           base::stop(msg)
[17:37:36.763]                         }
[17:37:36.763]                       })
[17:37:36.763]                     }
[17:37:36.763]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:36.763]                     base::options(mc.cores = 1L)
[17:37:36.763]                   }
[17:37:36.763]                   ...future.strategy.old <- future::plan("list")
[17:37:36.763]                   options(future.plan = NULL)
[17:37:36.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:36.763]                 }
[17:37:36.763]                 ...future.workdir <- getwd()
[17:37:36.763]             }
[17:37:36.763]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:36.763]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:36.763]         }
[17:37:36.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:36.763]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:36.763]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:36.763]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:36.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:36.763]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:36.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:36.763]             base::names(...future.oldOptions))
[17:37:36.763]     }
[17:37:36.763]     if (FALSE) {
[17:37:36.763]     }
[17:37:36.763]     else {
[17:37:36.763]         if (TRUE) {
[17:37:36.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:36.763]                 open = "w")
[17:37:36.763]         }
[17:37:36.763]         else {
[17:37:36.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:36.763]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:36.763]         }
[17:37:36.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:36.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:36.763]             base::sink(type = "output", split = FALSE)
[17:37:36.763]             base::close(...future.stdout)
[17:37:36.763]         }, add = TRUE)
[17:37:36.763]     }
[17:37:36.763]     ...future.frame <- base::sys.nframe()
[17:37:36.763]     ...future.conditions <- base::list()
[17:37:36.763]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:36.763]     if (FALSE) {
[17:37:36.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:36.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:36.763]     }
[17:37:36.763]     ...future.result <- base::tryCatch({
[17:37:36.763]         base::withCallingHandlers({
[17:37:36.763]             ...future.value <- base::withVisible(base::local({
[17:37:36.763]                 withCallingHandlers({
[17:37:36.763]                   {
[17:37:36.763]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.763]                     if (!identical(...future.globals.maxSize.org, 
[17:37:36.763]                       ...future.globals.maxSize)) {
[17:37:36.763]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.763]                       on.exit(options(oopts), add = TRUE)
[17:37:36.763]                     }
[17:37:36.763]                     {
[17:37:36.763]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.763]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:36.763]                         USE.NAMES = FALSE)
[17:37:36.763]                       do.call(mapply, args = args)
[17:37:36.763]                     }
[17:37:36.763]                   }
[17:37:36.763]                 }, immediateCondition = function(cond) {
[17:37:36.763]                   save_rds <- function (object, pathname, ...) 
[17:37:36.763]                   {
[17:37:36.763]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:36.763]                     if (file_test("-f", pathname_tmp)) {
[17:37:36.763]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.763]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:36.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.763]                         fi_tmp[["mtime"]])
[17:37:36.763]                     }
[17:37:36.763]                     tryCatch({
[17:37:36.763]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:36.763]                     }, error = function(ex) {
[17:37:36.763]                       msg <- conditionMessage(ex)
[17:37:36.763]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.763]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:36.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.763]                         fi_tmp[["mtime"]], msg)
[17:37:36.763]                       ex$message <- msg
[17:37:36.763]                       stop(ex)
[17:37:36.763]                     })
[17:37:36.763]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:36.763]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:36.763]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:36.763]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.763]                       fi <- file.info(pathname)
[17:37:36.763]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:36.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.763]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:36.763]                         fi[["size"]], fi[["mtime"]])
[17:37:36.763]                       stop(msg)
[17:37:36.763]                     }
[17:37:36.763]                     invisible(pathname)
[17:37:36.763]                   }
[17:37:36.763]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:36.763]                     rootPath = tempdir()) 
[17:37:36.763]                   {
[17:37:36.763]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:36.763]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:36.763]                       tmpdir = path, fileext = ".rds")
[17:37:36.763]                     save_rds(obj, file)
[17:37:36.763]                   }
[17:37:36.763]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:36.763]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.763]                   {
[17:37:36.763]                     inherits <- base::inherits
[17:37:36.763]                     invokeRestart <- base::invokeRestart
[17:37:36.763]                     is.null <- base::is.null
[17:37:36.763]                     muffled <- FALSE
[17:37:36.763]                     if (inherits(cond, "message")) {
[17:37:36.763]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:36.763]                       if (muffled) 
[17:37:36.763]                         invokeRestart("muffleMessage")
[17:37:36.763]                     }
[17:37:36.763]                     else if (inherits(cond, "warning")) {
[17:37:36.763]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:36.763]                       if (muffled) 
[17:37:36.763]                         invokeRestart("muffleWarning")
[17:37:36.763]                     }
[17:37:36.763]                     else if (inherits(cond, "condition")) {
[17:37:36.763]                       if (!is.null(pattern)) {
[17:37:36.763]                         computeRestarts <- base::computeRestarts
[17:37:36.763]                         grepl <- base::grepl
[17:37:36.763]                         restarts <- computeRestarts(cond)
[17:37:36.763]                         for (restart in restarts) {
[17:37:36.763]                           name <- restart$name
[17:37:36.763]                           if (is.null(name)) 
[17:37:36.763]                             next
[17:37:36.763]                           if (!grepl(pattern, name)) 
[17:37:36.763]                             next
[17:37:36.763]                           invokeRestart(restart)
[17:37:36.763]                           muffled <- TRUE
[17:37:36.763]                           break
[17:37:36.763]                         }
[17:37:36.763]                       }
[17:37:36.763]                     }
[17:37:36.763]                     invisible(muffled)
[17:37:36.763]                   }
[17:37:36.763]                   muffleCondition(cond)
[17:37:36.763]                 })
[17:37:36.763]             }))
[17:37:36.763]             future::FutureResult(value = ...future.value$value, 
[17:37:36.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.763]                   ...future.rng), globalenv = if (FALSE) 
[17:37:36.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:36.763]                     ...future.globalenv.names))
[17:37:36.763]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:36.763]         }, condition = base::local({
[17:37:36.763]             c <- base::c
[17:37:36.763]             inherits <- base::inherits
[17:37:36.763]             invokeRestart <- base::invokeRestart
[17:37:36.763]             length <- base::length
[17:37:36.763]             list <- base::list
[17:37:36.763]             seq.int <- base::seq.int
[17:37:36.763]             signalCondition <- base::signalCondition
[17:37:36.763]             sys.calls <- base::sys.calls
[17:37:36.763]             `[[` <- base::`[[`
[17:37:36.763]             `+` <- base::`+`
[17:37:36.763]             `<<-` <- base::`<<-`
[17:37:36.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:36.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:36.763]                   3L)]
[17:37:36.763]             }
[17:37:36.763]             function(cond) {
[17:37:36.763]                 is_error <- inherits(cond, "error")
[17:37:36.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:36.763]                   NULL)
[17:37:36.763]                 if (is_error) {
[17:37:36.763]                   sessionInformation <- function() {
[17:37:36.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:36.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:36.763]                       search = base::search(), system = base::Sys.info())
[17:37:36.763]                   }
[17:37:36.763]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:36.763]                     cond$call), session = sessionInformation(), 
[17:37:36.763]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:36.763]                   signalCondition(cond)
[17:37:36.763]                 }
[17:37:36.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:36.763]                 "immediateCondition"))) {
[17:37:36.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:36.763]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:36.763]                   if (TRUE && !signal) {
[17:37:36.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.763]                     {
[17:37:36.763]                       inherits <- base::inherits
[17:37:36.763]                       invokeRestart <- base::invokeRestart
[17:37:36.763]                       is.null <- base::is.null
[17:37:36.763]                       muffled <- FALSE
[17:37:36.763]                       if (inherits(cond, "message")) {
[17:37:36.763]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.763]                         if (muffled) 
[17:37:36.763]                           invokeRestart("muffleMessage")
[17:37:36.763]                       }
[17:37:36.763]                       else if (inherits(cond, "warning")) {
[17:37:36.763]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.763]                         if (muffled) 
[17:37:36.763]                           invokeRestart("muffleWarning")
[17:37:36.763]                       }
[17:37:36.763]                       else if (inherits(cond, "condition")) {
[17:37:36.763]                         if (!is.null(pattern)) {
[17:37:36.763]                           computeRestarts <- base::computeRestarts
[17:37:36.763]                           grepl <- base::grepl
[17:37:36.763]                           restarts <- computeRestarts(cond)
[17:37:36.763]                           for (restart in restarts) {
[17:37:36.763]                             name <- restart$name
[17:37:36.763]                             if (is.null(name)) 
[17:37:36.763]                               next
[17:37:36.763]                             if (!grepl(pattern, name)) 
[17:37:36.763]                               next
[17:37:36.763]                             invokeRestart(restart)
[17:37:36.763]                             muffled <- TRUE
[17:37:36.763]                             break
[17:37:36.763]                           }
[17:37:36.763]                         }
[17:37:36.763]                       }
[17:37:36.763]                       invisible(muffled)
[17:37:36.763]                     }
[17:37:36.763]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.763]                   }
[17:37:36.763]                 }
[17:37:36.763]                 else {
[17:37:36.763]                   if (TRUE) {
[17:37:36.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.763]                     {
[17:37:36.763]                       inherits <- base::inherits
[17:37:36.763]                       invokeRestart <- base::invokeRestart
[17:37:36.763]                       is.null <- base::is.null
[17:37:36.763]                       muffled <- FALSE
[17:37:36.763]                       if (inherits(cond, "message")) {
[17:37:36.763]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.763]                         if (muffled) 
[17:37:36.763]                           invokeRestart("muffleMessage")
[17:37:36.763]                       }
[17:37:36.763]                       else if (inherits(cond, "warning")) {
[17:37:36.763]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.763]                         if (muffled) 
[17:37:36.763]                           invokeRestart("muffleWarning")
[17:37:36.763]                       }
[17:37:36.763]                       else if (inherits(cond, "condition")) {
[17:37:36.763]                         if (!is.null(pattern)) {
[17:37:36.763]                           computeRestarts <- base::computeRestarts
[17:37:36.763]                           grepl <- base::grepl
[17:37:36.763]                           restarts <- computeRestarts(cond)
[17:37:36.763]                           for (restart in restarts) {
[17:37:36.763]                             name <- restart$name
[17:37:36.763]                             if (is.null(name)) 
[17:37:36.763]                               next
[17:37:36.763]                             if (!grepl(pattern, name)) 
[17:37:36.763]                               next
[17:37:36.763]                             invokeRestart(restart)
[17:37:36.763]                             muffled <- TRUE
[17:37:36.763]                             break
[17:37:36.763]                           }
[17:37:36.763]                         }
[17:37:36.763]                       }
[17:37:36.763]                       invisible(muffled)
[17:37:36.763]                     }
[17:37:36.763]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.763]                   }
[17:37:36.763]                 }
[17:37:36.763]             }
[17:37:36.763]         }))
[17:37:36.763]     }, error = function(ex) {
[17:37:36.763]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:36.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.763]                 ...future.rng), started = ...future.startTime, 
[17:37:36.763]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:36.763]             version = "1.8"), class = "FutureResult")
[17:37:36.763]     }, finally = {
[17:37:36.763]         if (!identical(...future.workdir, getwd())) 
[17:37:36.763]             setwd(...future.workdir)
[17:37:36.763]         {
[17:37:36.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:36.763]                 ...future.oldOptions$nwarnings <- NULL
[17:37:36.763]             }
[17:37:36.763]             base::options(...future.oldOptions)
[17:37:36.763]             if (.Platform$OS.type == "windows") {
[17:37:36.763]                 old_names <- names(...future.oldEnvVars)
[17:37:36.763]                 envs <- base::Sys.getenv()
[17:37:36.763]                 names <- names(envs)
[17:37:36.763]                 common <- intersect(names, old_names)
[17:37:36.763]                 added <- setdiff(names, old_names)
[17:37:36.763]                 removed <- setdiff(old_names, names)
[17:37:36.763]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:36.763]                   envs[common]]
[17:37:36.763]                 NAMES <- toupper(changed)
[17:37:36.763]                 args <- list()
[17:37:36.763]                 for (kk in seq_along(NAMES)) {
[17:37:36.763]                   name <- changed[[kk]]
[17:37:36.763]                   NAME <- NAMES[[kk]]
[17:37:36.763]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.763]                     next
[17:37:36.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.763]                 }
[17:37:36.763]                 NAMES <- toupper(added)
[17:37:36.763]                 for (kk in seq_along(NAMES)) {
[17:37:36.763]                   name <- added[[kk]]
[17:37:36.763]                   NAME <- NAMES[[kk]]
[17:37:36.763]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.763]                     next
[17:37:36.763]                   args[[name]] <- ""
[17:37:36.763]                 }
[17:37:36.763]                 NAMES <- toupper(removed)
[17:37:36.763]                 for (kk in seq_along(NAMES)) {
[17:37:36.763]                   name <- removed[[kk]]
[17:37:36.763]                   NAME <- NAMES[[kk]]
[17:37:36.763]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.763]                     next
[17:37:36.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.763]                 }
[17:37:36.763]                 if (length(args) > 0) 
[17:37:36.763]                   base::do.call(base::Sys.setenv, args = args)
[17:37:36.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:36.763]             }
[17:37:36.763]             else {
[17:37:36.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:36.763]             }
[17:37:36.763]             {
[17:37:36.763]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:36.763]                   0L) {
[17:37:36.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:36.763]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:36.763]                   base::options(opts)
[17:37:36.763]                 }
[17:37:36.763]                 {
[17:37:36.763]                   {
[17:37:36.763]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:36.763]                     NULL
[17:37:36.763]                   }
[17:37:36.763]                   options(future.plan = NULL)
[17:37:36.763]                   if (is.na(NA_character_)) 
[17:37:36.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:36.763]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:36.763]                     .init = FALSE)
[17:37:36.763]                 }
[17:37:36.763]             }
[17:37:36.763]         }
[17:37:36.763]     })
[17:37:36.763]     if (TRUE) {
[17:37:36.763]         base::sink(type = "output", split = FALSE)
[17:37:36.763]         if (TRUE) {
[17:37:36.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:36.763]         }
[17:37:36.763]         else {
[17:37:36.763]             ...future.result["stdout"] <- base::list(NULL)
[17:37:36.763]         }
[17:37:36.763]         base::close(...future.stdout)
[17:37:36.763]         ...future.stdout <- NULL
[17:37:36.763]     }
[17:37:36.763]     ...future.result$conditions <- ...future.conditions
[17:37:36.763]     ...future.result$finished <- base::Sys.time()
[17:37:36.763]     ...future.result
[17:37:36.763] }
[17:37:36.766] assign_globals() ...
[17:37:36.766] List of 5
[17:37:36.766]  $ ...future.FUN            :function (x, y)  
[17:37:36.766]  $ MoreArgs                 :List of 1
[17:37:36.766]   ..$ y: int [1:2] 3 4
[17:37:36.766]  $ ...future.elements_ii    :List of 1
[17:37:36.766]   ..$ x:List of 1
[17:37:36.766]   .. ..$ : int 1
[17:37:36.766]  $ ...future.seeds_ii       : NULL
[17:37:36.766]  $ ...future.globals.maxSize: NULL
[17:37:36.766]  - attr(*, "where")=List of 5
[17:37:36.766]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:36.766]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:36.766]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:36.766]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:36.766]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:36.766]  - attr(*, "resolved")= logi FALSE
[17:37:36.766]  - attr(*, "total_size")= num 1816
[17:37:36.766]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.766]  - attr(*, "already-done")= logi TRUE
[17:37:36.773] - reassign environment for ‘...future.FUN’
[17:37:36.774] - copied ‘...future.FUN’ to environment
[17:37:36.774] - copied ‘MoreArgs’ to environment
[17:37:36.774] - copied ‘...future.elements_ii’ to environment
[17:37:36.774] - copied ‘...future.seeds_ii’ to environment
[17:37:36.774] - copied ‘...future.globals.maxSize’ to environment
[17:37:36.774] assign_globals() ... done
[17:37:36.774] requestCore(): workers = 2
[17:37:36.777] MulticoreFuture started
[17:37:36.778] - Launch lazy future ... done
[17:37:36.778] plan(): Setting new future strategy stack:
[17:37:36.778] run() for ‘MulticoreFuture’ ... done
[17:37:36.779] Created future:
[17:37:36.779] List of future strategies:
[17:37:36.779] 1. sequential:
[17:37:36.779]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:36.779]    - tweaked: FALSE
[17:37:36.779]    - call: NULL
[17:37:36.781] plan(): nbrOfWorkers() = 1
[17:37:36.784] plan(): Setting new future strategy stack:
[17:37:36.784] List of future strategies:
[17:37:36.784] 1. multicore:
[17:37:36.784]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:36.784]    - tweaked: FALSE
[17:37:36.784]    - call: plan(strategy)
[17:37:36.791] plan(): nbrOfWorkers() = 2
[17:37:36.779] MulticoreFuture:
[17:37:36.779] Label: ‘future_.mapply-1’
[17:37:36.779] Expression:
[17:37:36.779] {
[17:37:36.779]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.779]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:36.779]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.779]         on.exit(options(oopts), add = TRUE)
[17:37:36.779]     }
[17:37:36.779]     {
[17:37:36.779]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.779]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:36.779]         do.call(mapply, args = args)
[17:37:36.779]     }
[17:37:36.779] }
[17:37:36.779] Lazy evaluation: FALSE
[17:37:36.779] Asynchronous evaluation: TRUE
[17:37:36.779] Local evaluation: TRUE
[17:37:36.779] Environment: R_GlobalEnv
[17:37:36.779] Capture standard output: TRUE
[17:37:36.779] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:36.779] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:36.779] Packages: <none>
[17:37:36.779] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:36.779] Resolved: TRUE
[17:37:36.779] Value: <not collected>
[17:37:36.779] Conditions captured: <none>
[17:37:36.779] Early signaling: FALSE
[17:37:36.779] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:36.779] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.792] Chunk #1 of 2 ... DONE
[17:37:36.792] Chunk #2 of 2 ...
[17:37:36.793]  - Finding globals in '...' for chunk #2 ...
[17:37:36.793] getGlobalsAndPackages() ...
[17:37:36.793] Searching for globals...
[17:37:36.794] 
[17:37:36.794] Searching for globals ... DONE
[17:37:36.794] - globals: [0] <none>
[17:37:36.794] getGlobalsAndPackages() ... DONE
[17:37:36.795]    + additional globals found: [n=0] 
[17:37:36.795]    + additional namespaces needed: [n=0] 
[17:37:36.795]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:36.795]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:36.795]  - seeds: <none>
[17:37:36.796]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.796] getGlobalsAndPackages() ...
[17:37:36.796] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.796] Resolving globals: FALSE
[17:37:36.798] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:37:36.799] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:37:36.799] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.799] 
[17:37:36.799] getGlobalsAndPackages() ... DONE
[17:37:36.800] run() for ‘Future’ ...
[17:37:36.800] - state: ‘created’
[17:37:36.800] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:36.805] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.805] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:36.805]   - Field: ‘label’
[17:37:36.805]   - Field: ‘local’
[17:37:36.805]   - Field: ‘owner’
[17:37:36.806]   - Field: ‘envir’
[17:37:36.806]   - Field: ‘workers’
[17:37:36.806]   - Field: ‘packages’
[17:37:36.806]   - Field: ‘gc’
[17:37:36.806]   - Field: ‘job’
[17:37:36.806]   - Field: ‘conditions’
[17:37:36.806]   - Field: ‘expr’
[17:37:36.807]   - Field: ‘uuid’
[17:37:36.807]   - Field: ‘seed’
[17:37:36.807]   - Field: ‘version’
[17:37:36.807]   - Field: ‘result’
[17:37:36.807]   - Field: ‘asynchronous’
[17:37:36.807]   - Field: ‘calls’
[17:37:36.807]   - Field: ‘globals’
[17:37:36.807]   - Field: ‘stdout’
[17:37:36.808]   - Field: ‘earlySignal’
[17:37:36.808]   - Field: ‘lazy’
[17:37:36.808]   - Field: ‘state’
[17:37:36.808] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:36.808] - Launch lazy future ...
[17:37:36.808] Packages needed by the future expression (n = 0): <none>
[17:37:36.809] Packages needed by future strategies (n = 0): <none>
[17:37:36.809] {
[17:37:36.809]     {
[17:37:36.809]         {
[17:37:36.809]             ...future.startTime <- base::Sys.time()
[17:37:36.809]             {
[17:37:36.809]                 {
[17:37:36.809]                   {
[17:37:36.809]                     {
[17:37:36.809]                       base::local({
[17:37:36.809]                         has_future <- base::requireNamespace("future", 
[17:37:36.809]                           quietly = TRUE)
[17:37:36.809]                         if (has_future) {
[17:37:36.809]                           ns <- base::getNamespace("future")
[17:37:36.809]                           version <- ns[[".package"]][["version"]]
[17:37:36.809]                           if (is.null(version)) 
[17:37:36.809]                             version <- utils::packageVersion("future")
[17:37:36.809]                         }
[17:37:36.809]                         else {
[17:37:36.809]                           version <- NULL
[17:37:36.809]                         }
[17:37:36.809]                         if (!has_future || version < "1.8.0") {
[17:37:36.809]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:36.809]                             "", base::R.version$version.string), 
[17:37:36.809]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:36.809]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:36.809]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:36.809]                               "release", "version")], collapse = " "), 
[17:37:36.809]                             hostname = base::Sys.info()[["nodename"]])
[17:37:36.809]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:36.809]                             info)
[17:37:36.809]                           info <- base::paste(info, collapse = "; ")
[17:37:36.809]                           if (!has_future) {
[17:37:36.809]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:36.809]                               info)
[17:37:36.809]                           }
[17:37:36.809]                           else {
[17:37:36.809]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:36.809]                               info, version)
[17:37:36.809]                           }
[17:37:36.809]                           base::stop(msg)
[17:37:36.809]                         }
[17:37:36.809]                       })
[17:37:36.809]                     }
[17:37:36.809]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:36.809]                     base::options(mc.cores = 1L)
[17:37:36.809]                   }
[17:37:36.809]                   ...future.strategy.old <- future::plan("list")
[17:37:36.809]                   options(future.plan = NULL)
[17:37:36.809]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.809]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:36.809]                 }
[17:37:36.809]                 ...future.workdir <- getwd()
[17:37:36.809]             }
[17:37:36.809]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:36.809]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:36.809]         }
[17:37:36.809]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:36.809]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:36.809]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:36.809]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:36.809]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:36.809]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:36.809]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:36.809]             base::names(...future.oldOptions))
[17:37:36.809]     }
[17:37:36.809]     if (FALSE) {
[17:37:36.809]     }
[17:37:36.809]     else {
[17:37:36.809]         if (TRUE) {
[17:37:36.809]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:36.809]                 open = "w")
[17:37:36.809]         }
[17:37:36.809]         else {
[17:37:36.809]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:36.809]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:36.809]         }
[17:37:36.809]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:36.809]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:36.809]             base::sink(type = "output", split = FALSE)
[17:37:36.809]             base::close(...future.stdout)
[17:37:36.809]         }, add = TRUE)
[17:37:36.809]     }
[17:37:36.809]     ...future.frame <- base::sys.nframe()
[17:37:36.809]     ...future.conditions <- base::list()
[17:37:36.809]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:36.809]     if (FALSE) {
[17:37:36.809]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:36.809]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:36.809]     }
[17:37:36.809]     ...future.result <- base::tryCatch({
[17:37:36.809]         base::withCallingHandlers({
[17:37:36.809]             ...future.value <- base::withVisible(base::local({
[17:37:36.809]                 withCallingHandlers({
[17:37:36.809]                   {
[17:37:36.809]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.809]                     if (!identical(...future.globals.maxSize.org, 
[17:37:36.809]                       ...future.globals.maxSize)) {
[17:37:36.809]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.809]                       on.exit(options(oopts), add = TRUE)
[17:37:36.809]                     }
[17:37:36.809]                     {
[17:37:36.809]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.809]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:36.809]                         USE.NAMES = FALSE)
[17:37:36.809]                       do.call(mapply, args = args)
[17:37:36.809]                     }
[17:37:36.809]                   }
[17:37:36.809]                 }, immediateCondition = function(cond) {
[17:37:36.809]                   save_rds <- function (object, pathname, ...) 
[17:37:36.809]                   {
[17:37:36.809]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:36.809]                     if (file_test("-f", pathname_tmp)) {
[17:37:36.809]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.809]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:36.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.809]                         fi_tmp[["mtime"]])
[17:37:36.809]                     }
[17:37:36.809]                     tryCatch({
[17:37:36.809]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:36.809]                     }, error = function(ex) {
[17:37:36.809]                       msg <- conditionMessage(ex)
[17:37:36.809]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.809]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:36.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.809]                         fi_tmp[["mtime"]], msg)
[17:37:36.809]                       ex$message <- msg
[17:37:36.809]                       stop(ex)
[17:37:36.809]                     })
[17:37:36.809]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:36.809]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:36.809]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:36.809]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.809]                       fi <- file.info(pathname)
[17:37:36.809]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:36.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.809]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:36.809]                         fi[["size"]], fi[["mtime"]])
[17:37:36.809]                       stop(msg)
[17:37:36.809]                     }
[17:37:36.809]                     invisible(pathname)
[17:37:36.809]                   }
[17:37:36.809]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:36.809]                     rootPath = tempdir()) 
[17:37:36.809]                   {
[17:37:36.809]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:36.809]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:36.809]                       tmpdir = path, fileext = ".rds")
[17:37:36.809]                     save_rds(obj, file)
[17:37:36.809]                   }
[17:37:36.809]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:36.809]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.809]                   {
[17:37:36.809]                     inherits <- base::inherits
[17:37:36.809]                     invokeRestart <- base::invokeRestart
[17:37:36.809]                     is.null <- base::is.null
[17:37:36.809]                     muffled <- FALSE
[17:37:36.809]                     if (inherits(cond, "message")) {
[17:37:36.809]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:36.809]                       if (muffled) 
[17:37:36.809]                         invokeRestart("muffleMessage")
[17:37:36.809]                     }
[17:37:36.809]                     else if (inherits(cond, "warning")) {
[17:37:36.809]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:36.809]                       if (muffled) 
[17:37:36.809]                         invokeRestart("muffleWarning")
[17:37:36.809]                     }
[17:37:36.809]                     else if (inherits(cond, "condition")) {
[17:37:36.809]                       if (!is.null(pattern)) {
[17:37:36.809]                         computeRestarts <- base::computeRestarts
[17:37:36.809]                         grepl <- base::grepl
[17:37:36.809]                         restarts <- computeRestarts(cond)
[17:37:36.809]                         for (restart in restarts) {
[17:37:36.809]                           name <- restart$name
[17:37:36.809]                           if (is.null(name)) 
[17:37:36.809]                             next
[17:37:36.809]                           if (!grepl(pattern, name)) 
[17:37:36.809]                             next
[17:37:36.809]                           invokeRestart(restart)
[17:37:36.809]                           muffled <- TRUE
[17:37:36.809]                           break
[17:37:36.809]                         }
[17:37:36.809]                       }
[17:37:36.809]                     }
[17:37:36.809]                     invisible(muffled)
[17:37:36.809]                   }
[17:37:36.809]                   muffleCondition(cond)
[17:37:36.809]                 })
[17:37:36.809]             }))
[17:37:36.809]             future::FutureResult(value = ...future.value$value, 
[17:37:36.809]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.809]                   ...future.rng), globalenv = if (FALSE) 
[17:37:36.809]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:36.809]                     ...future.globalenv.names))
[17:37:36.809]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:36.809]         }, condition = base::local({
[17:37:36.809]             c <- base::c
[17:37:36.809]             inherits <- base::inherits
[17:37:36.809]             invokeRestart <- base::invokeRestart
[17:37:36.809]             length <- base::length
[17:37:36.809]             list <- base::list
[17:37:36.809]             seq.int <- base::seq.int
[17:37:36.809]             signalCondition <- base::signalCondition
[17:37:36.809]             sys.calls <- base::sys.calls
[17:37:36.809]             `[[` <- base::`[[`
[17:37:36.809]             `+` <- base::`+`
[17:37:36.809]             `<<-` <- base::`<<-`
[17:37:36.809]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:36.809]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:36.809]                   3L)]
[17:37:36.809]             }
[17:37:36.809]             function(cond) {
[17:37:36.809]                 is_error <- inherits(cond, "error")
[17:37:36.809]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:36.809]                   NULL)
[17:37:36.809]                 if (is_error) {
[17:37:36.809]                   sessionInformation <- function() {
[17:37:36.809]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:36.809]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:36.809]                       search = base::search(), system = base::Sys.info())
[17:37:36.809]                   }
[17:37:36.809]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.809]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:36.809]                     cond$call), session = sessionInformation(), 
[17:37:36.809]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:36.809]                   signalCondition(cond)
[17:37:36.809]                 }
[17:37:36.809]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:36.809]                 "immediateCondition"))) {
[17:37:36.809]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:36.809]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.809]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:36.809]                   if (TRUE && !signal) {
[17:37:36.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.809]                     {
[17:37:36.809]                       inherits <- base::inherits
[17:37:36.809]                       invokeRestart <- base::invokeRestart
[17:37:36.809]                       is.null <- base::is.null
[17:37:36.809]                       muffled <- FALSE
[17:37:36.809]                       if (inherits(cond, "message")) {
[17:37:36.809]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.809]                         if (muffled) 
[17:37:36.809]                           invokeRestart("muffleMessage")
[17:37:36.809]                       }
[17:37:36.809]                       else if (inherits(cond, "warning")) {
[17:37:36.809]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.809]                         if (muffled) 
[17:37:36.809]                           invokeRestart("muffleWarning")
[17:37:36.809]                       }
[17:37:36.809]                       else if (inherits(cond, "condition")) {
[17:37:36.809]                         if (!is.null(pattern)) {
[17:37:36.809]                           computeRestarts <- base::computeRestarts
[17:37:36.809]                           grepl <- base::grepl
[17:37:36.809]                           restarts <- computeRestarts(cond)
[17:37:36.809]                           for (restart in restarts) {
[17:37:36.809]                             name <- restart$name
[17:37:36.809]                             if (is.null(name)) 
[17:37:36.809]                               next
[17:37:36.809]                             if (!grepl(pattern, name)) 
[17:37:36.809]                               next
[17:37:36.809]                             invokeRestart(restart)
[17:37:36.809]                             muffled <- TRUE
[17:37:36.809]                             break
[17:37:36.809]                           }
[17:37:36.809]                         }
[17:37:36.809]                       }
[17:37:36.809]                       invisible(muffled)
[17:37:36.809]                     }
[17:37:36.809]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.809]                   }
[17:37:36.809]                 }
[17:37:36.809]                 else {
[17:37:36.809]                   if (TRUE) {
[17:37:36.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.809]                     {
[17:37:36.809]                       inherits <- base::inherits
[17:37:36.809]                       invokeRestart <- base::invokeRestart
[17:37:36.809]                       is.null <- base::is.null
[17:37:36.809]                       muffled <- FALSE
[17:37:36.809]                       if (inherits(cond, "message")) {
[17:37:36.809]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.809]                         if (muffled) 
[17:37:36.809]                           invokeRestart("muffleMessage")
[17:37:36.809]                       }
[17:37:36.809]                       else if (inherits(cond, "warning")) {
[17:37:36.809]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.809]                         if (muffled) 
[17:37:36.809]                           invokeRestart("muffleWarning")
[17:37:36.809]                       }
[17:37:36.809]                       else if (inherits(cond, "condition")) {
[17:37:36.809]                         if (!is.null(pattern)) {
[17:37:36.809]                           computeRestarts <- base::computeRestarts
[17:37:36.809]                           grepl <- base::grepl
[17:37:36.809]                           restarts <- computeRestarts(cond)
[17:37:36.809]                           for (restart in restarts) {
[17:37:36.809]                             name <- restart$name
[17:37:36.809]                             if (is.null(name)) 
[17:37:36.809]                               next
[17:37:36.809]                             if (!grepl(pattern, name)) 
[17:37:36.809]                               next
[17:37:36.809]                             invokeRestart(restart)
[17:37:36.809]                             muffled <- TRUE
[17:37:36.809]                             break
[17:37:36.809]                           }
[17:37:36.809]                         }
[17:37:36.809]                       }
[17:37:36.809]                       invisible(muffled)
[17:37:36.809]                     }
[17:37:36.809]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.809]                   }
[17:37:36.809]                 }
[17:37:36.809]             }
[17:37:36.809]         }))
[17:37:36.809]     }, error = function(ex) {
[17:37:36.809]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:36.809]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.809]                 ...future.rng), started = ...future.startTime, 
[17:37:36.809]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:36.809]             version = "1.8"), class = "FutureResult")
[17:37:36.809]     }, finally = {
[17:37:36.809]         if (!identical(...future.workdir, getwd())) 
[17:37:36.809]             setwd(...future.workdir)
[17:37:36.809]         {
[17:37:36.809]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:36.809]                 ...future.oldOptions$nwarnings <- NULL
[17:37:36.809]             }
[17:37:36.809]             base::options(...future.oldOptions)
[17:37:36.809]             if (.Platform$OS.type == "windows") {
[17:37:36.809]                 old_names <- names(...future.oldEnvVars)
[17:37:36.809]                 envs <- base::Sys.getenv()
[17:37:36.809]                 names <- names(envs)
[17:37:36.809]                 common <- intersect(names, old_names)
[17:37:36.809]                 added <- setdiff(names, old_names)
[17:37:36.809]                 removed <- setdiff(old_names, names)
[17:37:36.809]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:36.809]                   envs[common]]
[17:37:36.809]                 NAMES <- toupper(changed)
[17:37:36.809]                 args <- list()
[17:37:36.809]                 for (kk in seq_along(NAMES)) {
[17:37:36.809]                   name <- changed[[kk]]
[17:37:36.809]                   NAME <- NAMES[[kk]]
[17:37:36.809]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.809]                     next
[17:37:36.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.809]                 }
[17:37:36.809]                 NAMES <- toupper(added)
[17:37:36.809]                 for (kk in seq_along(NAMES)) {
[17:37:36.809]                   name <- added[[kk]]
[17:37:36.809]                   NAME <- NAMES[[kk]]
[17:37:36.809]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.809]                     next
[17:37:36.809]                   args[[name]] <- ""
[17:37:36.809]                 }
[17:37:36.809]                 NAMES <- toupper(removed)
[17:37:36.809]                 for (kk in seq_along(NAMES)) {
[17:37:36.809]                   name <- removed[[kk]]
[17:37:36.809]                   NAME <- NAMES[[kk]]
[17:37:36.809]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.809]                     next
[17:37:36.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.809]                 }
[17:37:36.809]                 if (length(args) > 0) 
[17:37:36.809]                   base::do.call(base::Sys.setenv, args = args)
[17:37:36.809]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:36.809]             }
[17:37:36.809]             else {
[17:37:36.809]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:36.809]             }
[17:37:36.809]             {
[17:37:36.809]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:36.809]                   0L) {
[17:37:36.809]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:36.809]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:36.809]                   base::options(opts)
[17:37:36.809]                 }
[17:37:36.809]                 {
[17:37:36.809]                   {
[17:37:36.809]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:36.809]                     NULL
[17:37:36.809]                   }
[17:37:36.809]                   options(future.plan = NULL)
[17:37:36.809]                   if (is.na(NA_character_)) 
[17:37:36.809]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.809]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:36.809]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:36.809]                     .init = FALSE)
[17:37:36.809]                 }
[17:37:36.809]             }
[17:37:36.809]         }
[17:37:36.809]     })
[17:37:36.809]     if (TRUE) {
[17:37:36.809]         base::sink(type = "output", split = FALSE)
[17:37:36.809]         if (TRUE) {
[17:37:36.809]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:36.809]         }
[17:37:36.809]         else {
[17:37:36.809]             ...future.result["stdout"] <- base::list(NULL)
[17:37:36.809]         }
[17:37:36.809]         base::close(...future.stdout)
[17:37:36.809]         ...future.stdout <- NULL
[17:37:36.809]     }
[17:37:36.809]     ...future.result$conditions <- ...future.conditions
[17:37:36.809]     ...future.result$finished <- base::Sys.time()
[17:37:36.809]     ...future.result
[17:37:36.809] }
[17:37:36.813] assign_globals() ...
[17:37:36.813] List of 5
[17:37:36.813]  $ ...future.FUN            :function (x, y)  
[17:37:36.813]  $ MoreArgs                 :List of 1
[17:37:36.813]   ..$ y: int [1:2] 3 4
[17:37:36.813]  $ ...future.elements_ii    :List of 1
[17:37:36.813]   ..$ x:List of 1
[17:37:36.813]   .. ..$ : int 2
[17:37:36.813]  $ ...future.seeds_ii       : NULL
[17:37:36.813]  $ ...future.globals.maxSize: NULL
[17:37:36.813]  - attr(*, "where")=List of 5
[17:37:36.813]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:36.813]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:36.813]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:36.813]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:36.813]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:36.813]  - attr(*, "resolved")= logi FALSE
[17:37:36.813]  - attr(*, "total_size")= num 1816
[17:37:36.813]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.813]  - attr(*, "already-done")= logi TRUE
[17:37:36.819] - reassign environment for ‘...future.FUN’
[17:37:36.819] - copied ‘...future.FUN’ to environment
[17:37:36.819] - copied ‘MoreArgs’ to environment
[17:37:36.819] - copied ‘...future.elements_ii’ to environment
[17:37:36.819] - copied ‘...future.seeds_ii’ to environment
[17:37:36.820] - copied ‘...future.globals.maxSize’ to environment
[17:37:36.820] assign_globals() ... done
[17:37:36.820] requestCore(): workers = 2
[17:37:36.822] MulticoreFuture started
[17:37:36.823] - Launch lazy future ... done
[17:37:36.823] run() for ‘MulticoreFuture’ ... done
[17:37:36.823] Created future:
[17:37:36.823] plan(): Setting new future strategy stack:
[17:37:36.823] List of future strategies:
[17:37:36.823] 1. sequential:
[17:37:36.823]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:36.823]    - tweaked: FALSE
[17:37:36.823]    - call: NULL
[17:37:36.824] plan(): nbrOfWorkers() = 1
[17:37:36.832] plan(): Setting new future strategy stack:
[17:37:36.832] List of future strategies:
[17:37:36.832] 1. multicore:
[17:37:36.832]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:36.832]    - tweaked: FALSE
[17:37:36.832]    - call: plan(strategy)
[17:37:36.823] MulticoreFuture:
[17:37:36.823] Label: ‘future_.mapply-2’
[17:37:36.823] Expression:
[17:37:36.823] {
[17:37:36.823]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.823]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:36.823]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.823]         on.exit(options(oopts), add = TRUE)
[17:37:36.823]     }
[17:37:36.823]     {
[17:37:36.823]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.823]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:36.823]         do.call(mapply, args = args)
[17:37:36.823]     }
[17:37:36.823] }
[17:37:36.823] Lazy evaluation: FALSE
[17:37:36.823] Asynchronous evaluation: TRUE
[17:37:36.823] Local evaluation: TRUE
[17:37:36.823] Environment: R_GlobalEnv
[17:37:36.823] Capture standard output: TRUE
[17:37:36.823] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:36.823] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:36.823] Packages: <none>
[17:37:36.823] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:36.823] Resolved: FALSE
[17:37:36.823] Value: <not collected>
[17:37:36.823] Conditions captured: <none>
[17:37:36.823] Early signaling: FALSE
[17:37:36.823] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:36.823] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.839] Chunk #2 of 2 ... DONE
[17:37:36.840] plan(): nbrOfWorkers() = 2
[17:37:36.840] Launching 2 futures (chunks) ... DONE
[17:37:36.840] Resolving 2 futures (chunks) ...
[17:37:36.840] resolve() on list ...
[17:37:36.841]  recursive: 0
[17:37:36.841]  length: 2
[17:37:36.841] 
[17:37:36.842] Future #1
[17:37:36.842] result() for MulticoreFuture ...
[17:37:36.843] result() for MulticoreFuture ...
[17:37:36.843] result() for MulticoreFuture ... done
[17:37:36.844] result() for MulticoreFuture ... done
[17:37:36.844] result() for MulticoreFuture ...
[17:37:36.844] result() for MulticoreFuture ... done
[17:37:36.844] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:37:36.845] - nx: 2
[17:37:36.845] - relay: TRUE
[17:37:36.845] - stdout: TRUE
[17:37:36.845] - signal: TRUE
[17:37:36.846] - resignal: FALSE
[17:37:36.846] - force: TRUE
[17:37:36.846] - relayed: [n=2] FALSE, FALSE
[17:37:36.846] - queued futures: [n=2] FALSE, FALSE
[17:37:36.847]  - until=1
[17:37:36.847]  - relaying element #1
[17:37:36.847] result() for MulticoreFuture ...
[17:37:36.847] result() for MulticoreFuture ... done
[17:37:36.847] result() for MulticoreFuture ...
[17:37:36.848] result() for MulticoreFuture ... done
[17:37:36.848] result() for MulticoreFuture ...
[17:37:36.848] result() for MulticoreFuture ... done
[17:37:36.848] result() for MulticoreFuture ...
[17:37:36.849] result() for MulticoreFuture ... done
[17:37:36.849] - relayed: [n=2] TRUE, FALSE
[17:37:36.849] - queued futures: [n=2] TRUE, FALSE
[17:37:36.849] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:37:36.849]  length: 1 (resolved future 1)
[17:37:36.850] Future #2
[17:37:36.850] result() for MulticoreFuture ...
[17:37:36.851] result() for MulticoreFuture ...
[17:37:36.851] result() for MulticoreFuture ... done
[17:37:36.851] result() for MulticoreFuture ... done
[17:37:36.852] result() for MulticoreFuture ...
[17:37:36.852] result() for MulticoreFuture ... done
[17:37:36.852] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:37:36.852] - nx: 2
[17:37:36.852] - relay: TRUE
[17:37:36.852] - stdout: TRUE
[17:37:36.853] - signal: TRUE
[17:37:36.853] - resignal: FALSE
[17:37:36.853] - force: TRUE
[17:37:36.853] - relayed: [n=2] TRUE, FALSE
[17:37:36.853] - queued futures: [n=2] TRUE, FALSE
[17:37:36.853]  - until=2
[17:37:36.853]  - relaying element #2
[17:37:36.854] result() for MulticoreFuture ...
[17:37:36.854] result() for MulticoreFuture ... done
[17:37:36.854] result() for MulticoreFuture ...
[17:37:36.854] result() for MulticoreFuture ... done
[17:37:36.854] result() for MulticoreFuture ...
[17:37:36.854] result() for MulticoreFuture ... done
[17:37:36.854] result() for MulticoreFuture ...
[17:37:36.854] result() for MulticoreFuture ... done
[17:37:36.854] - relayed: [n=2] TRUE, TRUE
[17:37:36.854] - queued futures: [n=2] TRUE, TRUE
[17:37:36.855] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:37:36.855]  length: 0 (resolved future 2)
[17:37:36.855] Relaying remaining futures
[17:37:36.855] signalConditionsASAP(NULL, pos=0) ...
[17:37:36.855] - nx: 2
[17:37:36.855] - relay: TRUE
[17:37:36.855] - stdout: TRUE
[17:37:36.855] - signal: TRUE
[17:37:36.855] - resignal: FALSE
[17:37:36.856] - force: TRUE
[17:37:36.856] - relayed: [n=2] TRUE, TRUE
[17:37:36.856] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:36.856] - relayed: [n=2] TRUE, TRUE
[17:37:36.856] - queued futures: [n=2] TRUE, TRUE
[17:37:36.856] signalConditionsASAP(NULL, pos=0) ... done
[17:37:36.856] resolve() on list ... DONE
[17:37:36.856] result() for MulticoreFuture ...
[17:37:36.857] result() for MulticoreFuture ... done
[17:37:36.857] result() for MulticoreFuture ...
[17:37:36.857] result() for MulticoreFuture ... done
[17:37:36.857] result() for MulticoreFuture ...
[17:37:36.857] result() for MulticoreFuture ... done
[17:37:36.857] result() for MulticoreFuture ...
[17:37:36.857] result() for MulticoreFuture ... done
[17:37:36.857]  - Number of value chunks collected: 2
[17:37:36.857] Resolving 2 futures (chunks) ... DONE
[17:37:36.857] Reducing values from 2 chunks ...
[17:37:36.858]  - Number of values collected after concatenation: 2
[17:37:36.858]  - Number of values expected: 2
[17:37:36.858] Reducing values from 2 chunks ... DONE
[17:37:36.858] future_mapply() ... DONE
- Recycle arguments to same length ...
[17:37:36.858] future_mapply() ...
[17:37:36.862] Number of chunks: 2
[17:37:36.862] getGlobalsAndPackagesXApply() ...
[17:37:36.863]  - future.globals: TRUE
[17:37:36.863] getGlobalsAndPackages() ...
[17:37:36.863] Searching for globals...
[17:37:36.863] - globals found: [1] ‘FUN’
[17:37:36.864] Searching for globals ... DONE
[17:37:36.864] Resolving globals: FALSE
[17:37:36.864] The total size of the 1 globals is 56 bytes (56 bytes)
[17:37:36.864] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:37:36.865] - globals: [1] ‘FUN’
[17:37:36.865] 
[17:37:36.865] getGlobalsAndPackages() ... DONE
[17:37:36.865]  - globals found/used: [n=1] ‘FUN’
[17:37:36.865]  - needed namespaces: [n=0] 
[17:37:36.865] Finding globals ... DONE
[17:37:36.865] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:36.865] List of 2
[17:37:36.865]  $ ...future.FUN:function (x, ...)  
[17:37:36.865]  $ MoreArgs     : NULL
[17:37:36.865]  - attr(*, "where")=List of 2
[17:37:36.865]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:36.865]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:36.865]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.865]  - attr(*, "resolved")= logi FALSE
[17:37:36.865]  - attr(*, "total_size")= num NA
[17:37:36.868] Packages to be attached in all futures: [n=0] 
[17:37:36.868] getGlobalsAndPackagesXApply() ... DONE
[17:37:36.868] Number of futures (= number of chunks): 2
[17:37:36.869] Launching 2 futures (chunks) ...
[17:37:36.869] Chunk #1 of 2 ...
[17:37:36.869]  - Finding globals in '...' for chunk #1 ...
[17:37:36.869] getGlobalsAndPackages() ...
[17:37:36.869] Searching for globals...
[17:37:36.869] 
[17:37:36.869] Searching for globals ... DONE
[17:37:36.870] - globals: [0] <none>
[17:37:36.870] getGlobalsAndPackages() ... DONE
[17:37:36.870]    + additional globals found: [n=0] 
[17:37:36.870]    + additional namespaces needed: [n=0] 
[17:37:36.870]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:36.870]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:36.870]  - seeds: <none>
[17:37:36.870]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.870] getGlobalsAndPackages() ...
[17:37:36.870] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.873] Resolving globals: FALSE
[17:37:36.874] The total size of the 5 globals is 280 bytes (280 bytes)
[17:37:36.874] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:36.874] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.875] 
[17:37:36.875] getGlobalsAndPackages() ... DONE
[17:37:36.875] run() for ‘Future’ ...
[17:37:36.875] - state: ‘created’
[17:37:36.875] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:36.879] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.879] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:36.879]   - Field: ‘label’
[17:37:36.880]   - Field: ‘local’
[17:37:36.880]   - Field: ‘owner’
[17:37:36.880]   - Field: ‘envir’
[17:37:36.880]   - Field: ‘workers’
[17:37:36.880]   - Field: ‘packages’
[17:37:36.880]   - Field: ‘gc’
[17:37:36.880]   - Field: ‘job’
[17:37:36.880]   - Field: ‘conditions’
[17:37:36.881]   - Field: ‘expr’
[17:37:36.881]   - Field: ‘uuid’
[17:37:36.881]   - Field: ‘seed’
[17:37:36.881]   - Field: ‘version’
[17:37:36.881]   - Field: ‘result’
[17:37:36.881]   - Field: ‘asynchronous’
[17:37:36.881]   - Field: ‘calls’
[17:37:36.881]   - Field: ‘globals’
[17:37:36.881]   - Field: ‘stdout’
[17:37:36.882]   - Field: ‘earlySignal’
[17:37:36.882]   - Field: ‘lazy’
[17:37:36.882]   - Field: ‘state’
[17:37:36.882] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:36.882] - Launch lazy future ...
[17:37:36.882] Packages needed by the future expression (n = 0): <none>
[17:37:36.882] Packages needed by future strategies (n = 0): <none>
[17:37:36.883] {
[17:37:36.883]     {
[17:37:36.883]         {
[17:37:36.883]             ...future.startTime <- base::Sys.time()
[17:37:36.883]             {
[17:37:36.883]                 {
[17:37:36.883]                   {
[17:37:36.883]                     {
[17:37:36.883]                       base::local({
[17:37:36.883]                         has_future <- base::requireNamespace("future", 
[17:37:36.883]                           quietly = TRUE)
[17:37:36.883]                         if (has_future) {
[17:37:36.883]                           ns <- base::getNamespace("future")
[17:37:36.883]                           version <- ns[[".package"]][["version"]]
[17:37:36.883]                           if (is.null(version)) 
[17:37:36.883]                             version <- utils::packageVersion("future")
[17:37:36.883]                         }
[17:37:36.883]                         else {
[17:37:36.883]                           version <- NULL
[17:37:36.883]                         }
[17:37:36.883]                         if (!has_future || version < "1.8.0") {
[17:37:36.883]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:36.883]                             "", base::R.version$version.string), 
[17:37:36.883]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:36.883]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:36.883]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:36.883]                               "release", "version")], collapse = " "), 
[17:37:36.883]                             hostname = base::Sys.info()[["nodename"]])
[17:37:36.883]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:36.883]                             info)
[17:37:36.883]                           info <- base::paste(info, collapse = "; ")
[17:37:36.883]                           if (!has_future) {
[17:37:36.883]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:36.883]                               info)
[17:37:36.883]                           }
[17:37:36.883]                           else {
[17:37:36.883]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:36.883]                               info, version)
[17:37:36.883]                           }
[17:37:36.883]                           base::stop(msg)
[17:37:36.883]                         }
[17:37:36.883]                       })
[17:37:36.883]                     }
[17:37:36.883]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:36.883]                     base::options(mc.cores = 1L)
[17:37:36.883]                   }
[17:37:36.883]                   ...future.strategy.old <- future::plan("list")
[17:37:36.883]                   options(future.plan = NULL)
[17:37:36.883]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.883]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:36.883]                 }
[17:37:36.883]                 ...future.workdir <- getwd()
[17:37:36.883]             }
[17:37:36.883]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:36.883]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:36.883]         }
[17:37:36.883]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:36.883]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:36.883]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:36.883]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:36.883]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:36.883]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:36.883]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:36.883]             base::names(...future.oldOptions))
[17:37:36.883]     }
[17:37:36.883]     if (FALSE) {
[17:37:36.883]     }
[17:37:36.883]     else {
[17:37:36.883]         if (TRUE) {
[17:37:36.883]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:36.883]                 open = "w")
[17:37:36.883]         }
[17:37:36.883]         else {
[17:37:36.883]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:36.883]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:36.883]         }
[17:37:36.883]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:36.883]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:36.883]             base::sink(type = "output", split = FALSE)
[17:37:36.883]             base::close(...future.stdout)
[17:37:36.883]         }, add = TRUE)
[17:37:36.883]     }
[17:37:36.883]     ...future.frame <- base::sys.nframe()
[17:37:36.883]     ...future.conditions <- base::list()
[17:37:36.883]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:36.883]     if (FALSE) {
[17:37:36.883]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:36.883]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:36.883]     }
[17:37:36.883]     ...future.result <- base::tryCatch({
[17:37:36.883]         base::withCallingHandlers({
[17:37:36.883]             ...future.value <- base::withVisible(base::local({
[17:37:36.883]                 withCallingHandlers({
[17:37:36.883]                   {
[17:37:36.883]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.883]                     if (!identical(...future.globals.maxSize.org, 
[17:37:36.883]                       ...future.globals.maxSize)) {
[17:37:36.883]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.883]                       on.exit(options(oopts), add = TRUE)
[17:37:36.883]                     }
[17:37:36.883]                     {
[17:37:36.883]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.883]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:36.883]                         USE.NAMES = FALSE)
[17:37:36.883]                       do.call(mapply, args = args)
[17:37:36.883]                     }
[17:37:36.883]                   }
[17:37:36.883]                 }, immediateCondition = function(cond) {
[17:37:36.883]                   save_rds <- function (object, pathname, ...) 
[17:37:36.883]                   {
[17:37:36.883]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:36.883]                     if (file_test("-f", pathname_tmp)) {
[17:37:36.883]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.883]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:36.883]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.883]                         fi_tmp[["mtime"]])
[17:37:36.883]                     }
[17:37:36.883]                     tryCatch({
[17:37:36.883]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:36.883]                     }, error = function(ex) {
[17:37:36.883]                       msg <- conditionMessage(ex)
[17:37:36.883]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.883]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:36.883]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.883]                         fi_tmp[["mtime"]], msg)
[17:37:36.883]                       ex$message <- msg
[17:37:36.883]                       stop(ex)
[17:37:36.883]                     })
[17:37:36.883]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:36.883]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:36.883]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:36.883]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.883]                       fi <- file.info(pathname)
[17:37:36.883]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:36.883]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.883]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:36.883]                         fi[["size"]], fi[["mtime"]])
[17:37:36.883]                       stop(msg)
[17:37:36.883]                     }
[17:37:36.883]                     invisible(pathname)
[17:37:36.883]                   }
[17:37:36.883]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:36.883]                     rootPath = tempdir()) 
[17:37:36.883]                   {
[17:37:36.883]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:36.883]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:36.883]                       tmpdir = path, fileext = ".rds")
[17:37:36.883]                     save_rds(obj, file)
[17:37:36.883]                   }
[17:37:36.883]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:36.883]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.883]                   {
[17:37:36.883]                     inherits <- base::inherits
[17:37:36.883]                     invokeRestart <- base::invokeRestart
[17:37:36.883]                     is.null <- base::is.null
[17:37:36.883]                     muffled <- FALSE
[17:37:36.883]                     if (inherits(cond, "message")) {
[17:37:36.883]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:36.883]                       if (muffled) 
[17:37:36.883]                         invokeRestart("muffleMessage")
[17:37:36.883]                     }
[17:37:36.883]                     else if (inherits(cond, "warning")) {
[17:37:36.883]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:36.883]                       if (muffled) 
[17:37:36.883]                         invokeRestart("muffleWarning")
[17:37:36.883]                     }
[17:37:36.883]                     else if (inherits(cond, "condition")) {
[17:37:36.883]                       if (!is.null(pattern)) {
[17:37:36.883]                         computeRestarts <- base::computeRestarts
[17:37:36.883]                         grepl <- base::grepl
[17:37:36.883]                         restarts <- computeRestarts(cond)
[17:37:36.883]                         for (restart in restarts) {
[17:37:36.883]                           name <- restart$name
[17:37:36.883]                           if (is.null(name)) 
[17:37:36.883]                             next
[17:37:36.883]                           if (!grepl(pattern, name)) 
[17:37:36.883]                             next
[17:37:36.883]                           invokeRestart(restart)
[17:37:36.883]                           muffled <- TRUE
[17:37:36.883]                           break
[17:37:36.883]                         }
[17:37:36.883]                       }
[17:37:36.883]                     }
[17:37:36.883]                     invisible(muffled)
[17:37:36.883]                   }
[17:37:36.883]                   muffleCondition(cond)
[17:37:36.883]                 })
[17:37:36.883]             }))
[17:37:36.883]             future::FutureResult(value = ...future.value$value, 
[17:37:36.883]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.883]                   ...future.rng), globalenv = if (FALSE) 
[17:37:36.883]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:36.883]                     ...future.globalenv.names))
[17:37:36.883]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:36.883]         }, condition = base::local({
[17:37:36.883]             c <- base::c
[17:37:36.883]             inherits <- base::inherits
[17:37:36.883]             invokeRestart <- base::invokeRestart
[17:37:36.883]             length <- base::length
[17:37:36.883]             list <- base::list
[17:37:36.883]             seq.int <- base::seq.int
[17:37:36.883]             signalCondition <- base::signalCondition
[17:37:36.883]             sys.calls <- base::sys.calls
[17:37:36.883]             `[[` <- base::`[[`
[17:37:36.883]             `+` <- base::`+`
[17:37:36.883]             `<<-` <- base::`<<-`
[17:37:36.883]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:36.883]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:36.883]                   3L)]
[17:37:36.883]             }
[17:37:36.883]             function(cond) {
[17:37:36.883]                 is_error <- inherits(cond, "error")
[17:37:36.883]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:36.883]                   NULL)
[17:37:36.883]                 if (is_error) {
[17:37:36.883]                   sessionInformation <- function() {
[17:37:36.883]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:36.883]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:36.883]                       search = base::search(), system = base::Sys.info())
[17:37:36.883]                   }
[17:37:36.883]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.883]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:36.883]                     cond$call), session = sessionInformation(), 
[17:37:36.883]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:36.883]                   signalCondition(cond)
[17:37:36.883]                 }
[17:37:36.883]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:36.883]                 "immediateCondition"))) {
[17:37:36.883]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:36.883]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.883]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:36.883]                   if (TRUE && !signal) {
[17:37:36.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.883]                     {
[17:37:36.883]                       inherits <- base::inherits
[17:37:36.883]                       invokeRestart <- base::invokeRestart
[17:37:36.883]                       is.null <- base::is.null
[17:37:36.883]                       muffled <- FALSE
[17:37:36.883]                       if (inherits(cond, "message")) {
[17:37:36.883]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.883]                         if (muffled) 
[17:37:36.883]                           invokeRestart("muffleMessage")
[17:37:36.883]                       }
[17:37:36.883]                       else if (inherits(cond, "warning")) {
[17:37:36.883]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.883]                         if (muffled) 
[17:37:36.883]                           invokeRestart("muffleWarning")
[17:37:36.883]                       }
[17:37:36.883]                       else if (inherits(cond, "condition")) {
[17:37:36.883]                         if (!is.null(pattern)) {
[17:37:36.883]                           computeRestarts <- base::computeRestarts
[17:37:36.883]                           grepl <- base::grepl
[17:37:36.883]                           restarts <- computeRestarts(cond)
[17:37:36.883]                           for (restart in restarts) {
[17:37:36.883]                             name <- restart$name
[17:37:36.883]                             if (is.null(name)) 
[17:37:36.883]                               next
[17:37:36.883]                             if (!grepl(pattern, name)) 
[17:37:36.883]                               next
[17:37:36.883]                             invokeRestart(restart)
[17:37:36.883]                             muffled <- TRUE
[17:37:36.883]                             break
[17:37:36.883]                           }
[17:37:36.883]                         }
[17:37:36.883]                       }
[17:37:36.883]                       invisible(muffled)
[17:37:36.883]                     }
[17:37:36.883]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.883]                   }
[17:37:36.883]                 }
[17:37:36.883]                 else {
[17:37:36.883]                   if (TRUE) {
[17:37:36.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.883]                     {
[17:37:36.883]                       inherits <- base::inherits
[17:37:36.883]                       invokeRestart <- base::invokeRestart
[17:37:36.883]                       is.null <- base::is.null
[17:37:36.883]                       muffled <- FALSE
[17:37:36.883]                       if (inherits(cond, "message")) {
[17:37:36.883]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.883]                         if (muffled) 
[17:37:36.883]                           invokeRestart("muffleMessage")
[17:37:36.883]                       }
[17:37:36.883]                       else if (inherits(cond, "warning")) {
[17:37:36.883]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.883]                         if (muffled) 
[17:37:36.883]                           invokeRestart("muffleWarning")
[17:37:36.883]                       }
[17:37:36.883]                       else if (inherits(cond, "condition")) {
[17:37:36.883]                         if (!is.null(pattern)) {
[17:37:36.883]                           computeRestarts <- base::computeRestarts
[17:37:36.883]                           grepl <- base::grepl
[17:37:36.883]                           restarts <- computeRestarts(cond)
[17:37:36.883]                           for (restart in restarts) {
[17:37:36.883]                             name <- restart$name
[17:37:36.883]                             if (is.null(name)) 
[17:37:36.883]                               next
[17:37:36.883]                             if (!grepl(pattern, name)) 
[17:37:36.883]                               next
[17:37:36.883]                             invokeRestart(restart)
[17:37:36.883]                             muffled <- TRUE
[17:37:36.883]                             break
[17:37:36.883]                           }
[17:37:36.883]                         }
[17:37:36.883]                       }
[17:37:36.883]                       invisible(muffled)
[17:37:36.883]                     }
[17:37:36.883]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.883]                   }
[17:37:36.883]                 }
[17:37:36.883]             }
[17:37:36.883]         }))
[17:37:36.883]     }, error = function(ex) {
[17:37:36.883]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:36.883]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.883]                 ...future.rng), started = ...future.startTime, 
[17:37:36.883]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:36.883]             version = "1.8"), class = "FutureResult")
[17:37:36.883]     }, finally = {
[17:37:36.883]         if (!identical(...future.workdir, getwd())) 
[17:37:36.883]             setwd(...future.workdir)
[17:37:36.883]         {
[17:37:36.883]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:36.883]                 ...future.oldOptions$nwarnings <- NULL
[17:37:36.883]             }
[17:37:36.883]             base::options(...future.oldOptions)
[17:37:36.883]             if (.Platform$OS.type == "windows") {
[17:37:36.883]                 old_names <- names(...future.oldEnvVars)
[17:37:36.883]                 envs <- base::Sys.getenv()
[17:37:36.883]                 names <- names(envs)
[17:37:36.883]                 common <- intersect(names, old_names)
[17:37:36.883]                 added <- setdiff(names, old_names)
[17:37:36.883]                 removed <- setdiff(old_names, names)
[17:37:36.883]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:36.883]                   envs[common]]
[17:37:36.883]                 NAMES <- toupper(changed)
[17:37:36.883]                 args <- list()
[17:37:36.883]                 for (kk in seq_along(NAMES)) {
[17:37:36.883]                   name <- changed[[kk]]
[17:37:36.883]                   NAME <- NAMES[[kk]]
[17:37:36.883]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.883]                     next
[17:37:36.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.883]                 }
[17:37:36.883]                 NAMES <- toupper(added)
[17:37:36.883]                 for (kk in seq_along(NAMES)) {
[17:37:36.883]                   name <- added[[kk]]
[17:37:36.883]                   NAME <- NAMES[[kk]]
[17:37:36.883]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.883]                     next
[17:37:36.883]                   args[[name]] <- ""
[17:37:36.883]                 }
[17:37:36.883]                 NAMES <- toupper(removed)
[17:37:36.883]                 for (kk in seq_along(NAMES)) {
[17:37:36.883]                   name <- removed[[kk]]
[17:37:36.883]                   NAME <- NAMES[[kk]]
[17:37:36.883]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.883]                     next
[17:37:36.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.883]                 }
[17:37:36.883]                 if (length(args) > 0) 
[17:37:36.883]                   base::do.call(base::Sys.setenv, args = args)
[17:37:36.883]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:36.883]             }
[17:37:36.883]             else {
[17:37:36.883]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:36.883]             }
[17:37:36.883]             {
[17:37:36.883]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:36.883]                   0L) {
[17:37:36.883]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:36.883]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:36.883]                   base::options(opts)
[17:37:36.883]                 }
[17:37:36.883]                 {
[17:37:36.883]                   {
[17:37:36.883]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:36.883]                     NULL
[17:37:36.883]                   }
[17:37:36.883]                   options(future.plan = NULL)
[17:37:36.883]                   if (is.na(NA_character_)) 
[17:37:36.883]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.883]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:36.883]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:36.883]                     .init = FALSE)
[17:37:36.883]                 }
[17:37:36.883]             }
[17:37:36.883]         }
[17:37:36.883]     })
[17:37:36.883]     if (TRUE) {
[17:37:36.883]         base::sink(type = "output", split = FALSE)
[17:37:36.883]         if (TRUE) {
[17:37:36.883]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:36.883]         }
[17:37:36.883]         else {
[17:37:36.883]             ...future.result["stdout"] <- base::list(NULL)
[17:37:36.883]         }
[17:37:36.883]         base::close(...future.stdout)
[17:37:36.883]         ...future.stdout <- NULL
[17:37:36.883]     }
[17:37:36.883]     ...future.result$conditions <- ...future.conditions
[17:37:36.883]     ...future.result$finished <- base::Sys.time()
[17:37:36.883]     ...future.result
[17:37:36.883] }
[17:37:36.885] assign_globals() ...
[17:37:36.886] List of 5
[17:37:36.886]  $ ...future.FUN            :function (x, ...)  
[17:37:36.886]  $ MoreArgs                 : NULL
[17:37:36.886]  $ ...future.elements_ii    :List of 2
[17:37:36.886]   ..$ :List of 2
[17:37:36.886]   .. ..$ : int 1
[17:37:36.886]   .. ..$ : int 2
[17:37:36.886]   ..$ :List of 2
[17:37:36.886]   .. ..$ : int 2
[17:37:36.886]   .. ..$ : int 1
[17:37:36.886]  $ ...future.seeds_ii       : NULL
[17:37:36.886]  $ ...future.globals.maxSize: NULL
[17:37:36.886]  - attr(*, "where")=List of 5
[17:37:36.886]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:36.886]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:36.886]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:36.886]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:36.886]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:36.886]  - attr(*, "resolved")= logi FALSE
[17:37:36.886]  - attr(*, "total_size")= num 280
[17:37:36.886]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.886]  - attr(*, "already-done")= logi TRUE
[17:37:36.891] - copied ‘...future.FUN’ to environment
[17:37:36.891] - copied ‘MoreArgs’ to environment
[17:37:36.891] - copied ‘...future.elements_ii’ to environment
[17:37:36.891] - copied ‘...future.seeds_ii’ to environment
[17:37:36.891] - copied ‘...future.globals.maxSize’ to environment
[17:37:36.892] assign_globals() ... done
[17:37:36.892] requestCore(): workers = 2
[17:37:36.894] MulticoreFuture started
[17:37:36.894] - Launch lazy future ... done
[17:37:36.895] run() for ‘MulticoreFuture’ ... done
[17:37:36.895] Created future:
[17:37:36.895] plan(): Setting new future strategy stack:
[17:37:36.895] List of future strategies:
[17:37:36.895] 1. sequential:
[17:37:36.895]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:36.895]    - tweaked: FALSE
[17:37:36.895]    - call: NULL
[17:37:36.896] plan(): nbrOfWorkers() = 1
[17:37:36.898] plan(): Setting new future strategy stack:
[17:37:36.899] List of future strategies:
[17:37:36.899] 1. multicore:
[17:37:36.899]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:36.899]    - tweaked: FALSE
[17:37:36.899]    - call: plan(strategy)
[17:37:36.904] plan(): nbrOfWorkers() = 2
[17:37:36.895] MulticoreFuture:
[17:37:36.895] Label: ‘future_mapply-1’
[17:37:36.895] Expression:
[17:37:36.895] {
[17:37:36.895]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.895]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:36.895]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.895]         on.exit(options(oopts), add = TRUE)
[17:37:36.895]     }
[17:37:36.895]     {
[17:37:36.895]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.895]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:36.895]         do.call(mapply, args = args)
[17:37:36.895]     }
[17:37:36.895] }
[17:37:36.895] Lazy evaluation: FALSE
[17:37:36.895] Asynchronous evaluation: TRUE
[17:37:36.895] Local evaluation: TRUE
[17:37:36.895] Environment: R_GlobalEnv
[17:37:36.895] Capture standard output: TRUE
[17:37:36.895] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:36.895] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:36.895] Packages: <none>
[17:37:36.895] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:36.895] Resolved: TRUE
[17:37:36.895] Value: <not collected>
[17:37:36.895] Conditions captured: <none>
[17:37:36.895] Early signaling: FALSE
[17:37:36.895] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:36.895] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.905] Chunk #1 of 2 ... DONE
[17:37:36.905] Chunk #2 of 2 ...
[17:37:36.905]  - Finding globals in '...' for chunk #2 ...
[17:37:36.905] getGlobalsAndPackages() ...
[17:37:36.905] Searching for globals...
[17:37:36.906] 
[17:37:36.906] Searching for globals ... DONE
[17:37:36.906] - globals: [0] <none>
[17:37:36.906] getGlobalsAndPackages() ... DONE
[17:37:36.907]    + additional globals found: [n=0] 
[17:37:36.907]    + additional namespaces needed: [n=0] 
[17:37:36.907]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:36.907]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:36.907]  - seeds: <none>
[17:37:36.907]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.907] getGlobalsAndPackages() ...
[17:37:36.907] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.908] Resolving globals: FALSE
[17:37:36.909] The total size of the 5 globals is 280 bytes (280 bytes)
[17:37:36.909] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:36.910] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.910] 
[17:37:36.910] getGlobalsAndPackages() ... DONE
[17:37:36.911] run() for ‘Future’ ...
[17:37:36.911] - state: ‘created’
[17:37:36.911] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:36.921] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.921] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:36.921]   - Field: ‘label’
[17:37:36.921]   - Field: ‘local’
[17:37:36.922]   - Field: ‘owner’
[17:37:36.922]   - Field: ‘envir’
[17:37:36.922]   - Field: ‘workers’
[17:37:36.923]   - Field: ‘packages’
[17:37:36.923]   - Field: ‘gc’
[17:37:36.923]   - Field: ‘job’
[17:37:36.923]   - Field: ‘conditions’
[17:37:36.924]   - Field: ‘expr’
[17:37:36.924]   - Field: ‘uuid’
[17:37:36.924]   - Field: ‘seed’
[17:37:36.924]   - Field: ‘version’
[17:37:36.925]   - Field: ‘result’
[17:37:36.925]   - Field: ‘asynchronous’
[17:37:36.925]   - Field: ‘calls’
[17:37:36.925]   - Field: ‘globals’
[17:37:36.925]   - Field: ‘stdout’
[17:37:36.926]   - Field: ‘earlySignal’
[17:37:36.926]   - Field: ‘lazy’
[17:37:36.926]   - Field: ‘state’
[17:37:36.926] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:36.926] - Launch lazy future ...
[17:37:36.927] Packages needed by the future expression (n = 0): <none>
[17:37:36.927] Packages needed by future strategies (n = 0): <none>
[17:37:36.928] {
[17:37:36.928]     {
[17:37:36.928]         {
[17:37:36.928]             ...future.startTime <- base::Sys.time()
[17:37:36.928]             {
[17:37:36.928]                 {
[17:37:36.928]                   {
[17:37:36.928]                     {
[17:37:36.928]                       base::local({
[17:37:36.928]                         has_future <- base::requireNamespace("future", 
[17:37:36.928]                           quietly = TRUE)
[17:37:36.928]                         if (has_future) {
[17:37:36.928]                           ns <- base::getNamespace("future")
[17:37:36.928]                           version <- ns[[".package"]][["version"]]
[17:37:36.928]                           if (is.null(version)) 
[17:37:36.928]                             version <- utils::packageVersion("future")
[17:37:36.928]                         }
[17:37:36.928]                         else {
[17:37:36.928]                           version <- NULL
[17:37:36.928]                         }
[17:37:36.928]                         if (!has_future || version < "1.8.0") {
[17:37:36.928]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:36.928]                             "", base::R.version$version.string), 
[17:37:36.928]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:36.928]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:36.928]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:36.928]                               "release", "version")], collapse = " "), 
[17:37:36.928]                             hostname = base::Sys.info()[["nodename"]])
[17:37:36.928]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:36.928]                             info)
[17:37:36.928]                           info <- base::paste(info, collapse = "; ")
[17:37:36.928]                           if (!has_future) {
[17:37:36.928]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:36.928]                               info)
[17:37:36.928]                           }
[17:37:36.928]                           else {
[17:37:36.928]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:36.928]                               info, version)
[17:37:36.928]                           }
[17:37:36.928]                           base::stop(msg)
[17:37:36.928]                         }
[17:37:36.928]                       })
[17:37:36.928]                     }
[17:37:36.928]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:36.928]                     base::options(mc.cores = 1L)
[17:37:36.928]                   }
[17:37:36.928]                   ...future.strategy.old <- future::plan("list")
[17:37:36.928]                   options(future.plan = NULL)
[17:37:36.928]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.928]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:36.928]                 }
[17:37:36.928]                 ...future.workdir <- getwd()
[17:37:36.928]             }
[17:37:36.928]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:36.928]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:36.928]         }
[17:37:36.928]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:36.928]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:36.928]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:36.928]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:36.928]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:36.928]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:36.928]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:36.928]             base::names(...future.oldOptions))
[17:37:36.928]     }
[17:37:36.928]     if (FALSE) {
[17:37:36.928]     }
[17:37:36.928]     else {
[17:37:36.928]         if (TRUE) {
[17:37:36.928]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:36.928]                 open = "w")
[17:37:36.928]         }
[17:37:36.928]         else {
[17:37:36.928]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:36.928]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:36.928]         }
[17:37:36.928]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:36.928]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:36.928]             base::sink(type = "output", split = FALSE)
[17:37:36.928]             base::close(...future.stdout)
[17:37:36.928]         }, add = TRUE)
[17:37:36.928]     }
[17:37:36.928]     ...future.frame <- base::sys.nframe()
[17:37:36.928]     ...future.conditions <- base::list()
[17:37:36.928]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:36.928]     if (FALSE) {
[17:37:36.928]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:36.928]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:36.928]     }
[17:37:36.928]     ...future.result <- base::tryCatch({
[17:37:36.928]         base::withCallingHandlers({
[17:37:36.928]             ...future.value <- base::withVisible(base::local({
[17:37:36.928]                 withCallingHandlers({
[17:37:36.928]                   {
[17:37:36.928]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.928]                     if (!identical(...future.globals.maxSize.org, 
[17:37:36.928]                       ...future.globals.maxSize)) {
[17:37:36.928]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.928]                       on.exit(options(oopts), add = TRUE)
[17:37:36.928]                     }
[17:37:36.928]                     {
[17:37:36.928]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.928]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:36.928]                         USE.NAMES = FALSE)
[17:37:36.928]                       do.call(mapply, args = args)
[17:37:36.928]                     }
[17:37:36.928]                   }
[17:37:36.928]                 }, immediateCondition = function(cond) {
[17:37:36.928]                   save_rds <- function (object, pathname, ...) 
[17:37:36.928]                   {
[17:37:36.928]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:36.928]                     if (file_test("-f", pathname_tmp)) {
[17:37:36.928]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.928]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:36.928]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.928]                         fi_tmp[["mtime"]])
[17:37:36.928]                     }
[17:37:36.928]                     tryCatch({
[17:37:36.928]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:36.928]                     }, error = function(ex) {
[17:37:36.928]                       msg <- conditionMessage(ex)
[17:37:36.928]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.928]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:36.928]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.928]                         fi_tmp[["mtime"]], msg)
[17:37:36.928]                       ex$message <- msg
[17:37:36.928]                       stop(ex)
[17:37:36.928]                     })
[17:37:36.928]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:36.928]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:36.928]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:36.928]                       fi_tmp <- file.info(pathname_tmp)
[17:37:36.928]                       fi <- file.info(pathname)
[17:37:36.928]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:36.928]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:36.928]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:36.928]                         fi[["size"]], fi[["mtime"]])
[17:37:36.928]                       stop(msg)
[17:37:36.928]                     }
[17:37:36.928]                     invisible(pathname)
[17:37:36.928]                   }
[17:37:36.928]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:36.928]                     rootPath = tempdir()) 
[17:37:36.928]                   {
[17:37:36.928]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:36.928]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:36.928]                       tmpdir = path, fileext = ".rds")
[17:37:36.928]                     save_rds(obj, file)
[17:37:36.928]                   }
[17:37:36.928]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:36.928]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.928]                   {
[17:37:36.928]                     inherits <- base::inherits
[17:37:36.928]                     invokeRestart <- base::invokeRestart
[17:37:36.928]                     is.null <- base::is.null
[17:37:36.928]                     muffled <- FALSE
[17:37:36.928]                     if (inherits(cond, "message")) {
[17:37:36.928]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:36.928]                       if (muffled) 
[17:37:36.928]                         invokeRestart("muffleMessage")
[17:37:36.928]                     }
[17:37:36.928]                     else if (inherits(cond, "warning")) {
[17:37:36.928]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:36.928]                       if (muffled) 
[17:37:36.928]                         invokeRestart("muffleWarning")
[17:37:36.928]                     }
[17:37:36.928]                     else if (inherits(cond, "condition")) {
[17:37:36.928]                       if (!is.null(pattern)) {
[17:37:36.928]                         computeRestarts <- base::computeRestarts
[17:37:36.928]                         grepl <- base::grepl
[17:37:36.928]                         restarts <- computeRestarts(cond)
[17:37:36.928]                         for (restart in restarts) {
[17:37:36.928]                           name <- restart$name
[17:37:36.928]                           if (is.null(name)) 
[17:37:36.928]                             next
[17:37:36.928]                           if (!grepl(pattern, name)) 
[17:37:36.928]                             next
[17:37:36.928]                           invokeRestart(restart)
[17:37:36.928]                           muffled <- TRUE
[17:37:36.928]                           break
[17:37:36.928]                         }
[17:37:36.928]                       }
[17:37:36.928]                     }
[17:37:36.928]                     invisible(muffled)
[17:37:36.928]                   }
[17:37:36.928]                   muffleCondition(cond)
[17:37:36.928]                 })
[17:37:36.928]             }))
[17:37:36.928]             future::FutureResult(value = ...future.value$value, 
[17:37:36.928]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.928]                   ...future.rng), globalenv = if (FALSE) 
[17:37:36.928]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:36.928]                     ...future.globalenv.names))
[17:37:36.928]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:36.928]         }, condition = base::local({
[17:37:36.928]             c <- base::c
[17:37:36.928]             inherits <- base::inherits
[17:37:36.928]             invokeRestart <- base::invokeRestart
[17:37:36.928]             length <- base::length
[17:37:36.928]             list <- base::list
[17:37:36.928]             seq.int <- base::seq.int
[17:37:36.928]             signalCondition <- base::signalCondition
[17:37:36.928]             sys.calls <- base::sys.calls
[17:37:36.928]             `[[` <- base::`[[`
[17:37:36.928]             `+` <- base::`+`
[17:37:36.928]             `<<-` <- base::`<<-`
[17:37:36.928]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:36.928]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:36.928]                   3L)]
[17:37:36.928]             }
[17:37:36.928]             function(cond) {
[17:37:36.928]                 is_error <- inherits(cond, "error")
[17:37:36.928]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:36.928]                   NULL)
[17:37:36.928]                 if (is_error) {
[17:37:36.928]                   sessionInformation <- function() {
[17:37:36.928]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:36.928]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:36.928]                       search = base::search(), system = base::Sys.info())
[17:37:36.928]                   }
[17:37:36.928]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.928]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:36.928]                     cond$call), session = sessionInformation(), 
[17:37:36.928]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:36.928]                   signalCondition(cond)
[17:37:36.928]                 }
[17:37:36.928]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:36.928]                 "immediateCondition"))) {
[17:37:36.928]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:36.928]                   ...future.conditions[[length(...future.conditions) + 
[17:37:36.928]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:36.928]                   if (TRUE && !signal) {
[17:37:36.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.928]                     {
[17:37:36.928]                       inherits <- base::inherits
[17:37:36.928]                       invokeRestart <- base::invokeRestart
[17:37:36.928]                       is.null <- base::is.null
[17:37:36.928]                       muffled <- FALSE
[17:37:36.928]                       if (inherits(cond, "message")) {
[17:37:36.928]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.928]                         if (muffled) 
[17:37:36.928]                           invokeRestart("muffleMessage")
[17:37:36.928]                       }
[17:37:36.928]                       else if (inherits(cond, "warning")) {
[17:37:36.928]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.928]                         if (muffled) 
[17:37:36.928]                           invokeRestart("muffleWarning")
[17:37:36.928]                       }
[17:37:36.928]                       else if (inherits(cond, "condition")) {
[17:37:36.928]                         if (!is.null(pattern)) {
[17:37:36.928]                           computeRestarts <- base::computeRestarts
[17:37:36.928]                           grepl <- base::grepl
[17:37:36.928]                           restarts <- computeRestarts(cond)
[17:37:36.928]                           for (restart in restarts) {
[17:37:36.928]                             name <- restart$name
[17:37:36.928]                             if (is.null(name)) 
[17:37:36.928]                               next
[17:37:36.928]                             if (!grepl(pattern, name)) 
[17:37:36.928]                               next
[17:37:36.928]                             invokeRestart(restart)
[17:37:36.928]                             muffled <- TRUE
[17:37:36.928]                             break
[17:37:36.928]                           }
[17:37:36.928]                         }
[17:37:36.928]                       }
[17:37:36.928]                       invisible(muffled)
[17:37:36.928]                     }
[17:37:36.928]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.928]                   }
[17:37:36.928]                 }
[17:37:36.928]                 else {
[17:37:36.928]                   if (TRUE) {
[17:37:36.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:36.928]                     {
[17:37:36.928]                       inherits <- base::inherits
[17:37:36.928]                       invokeRestart <- base::invokeRestart
[17:37:36.928]                       is.null <- base::is.null
[17:37:36.928]                       muffled <- FALSE
[17:37:36.928]                       if (inherits(cond, "message")) {
[17:37:36.928]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:36.928]                         if (muffled) 
[17:37:36.928]                           invokeRestart("muffleMessage")
[17:37:36.928]                       }
[17:37:36.928]                       else if (inherits(cond, "warning")) {
[17:37:36.928]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:36.928]                         if (muffled) 
[17:37:36.928]                           invokeRestart("muffleWarning")
[17:37:36.928]                       }
[17:37:36.928]                       else if (inherits(cond, "condition")) {
[17:37:36.928]                         if (!is.null(pattern)) {
[17:37:36.928]                           computeRestarts <- base::computeRestarts
[17:37:36.928]                           grepl <- base::grepl
[17:37:36.928]                           restarts <- computeRestarts(cond)
[17:37:36.928]                           for (restart in restarts) {
[17:37:36.928]                             name <- restart$name
[17:37:36.928]                             if (is.null(name)) 
[17:37:36.928]                               next
[17:37:36.928]                             if (!grepl(pattern, name)) 
[17:37:36.928]                               next
[17:37:36.928]                             invokeRestart(restart)
[17:37:36.928]                             muffled <- TRUE
[17:37:36.928]                             break
[17:37:36.928]                           }
[17:37:36.928]                         }
[17:37:36.928]                       }
[17:37:36.928]                       invisible(muffled)
[17:37:36.928]                     }
[17:37:36.928]                     muffleCondition(cond, pattern = "^muffle")
[17:37:36.928]                   }
[17:37:36.928]                 }
[17:37:36.928]             }
[17:37:36.928]         }))
[17:37:36.928]     }, error = function(ex) {
[17:37:36.928]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:36.928]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:36.928]                 ...future.rng), started = ...future.startTime, 
[17:37:36.928]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:36.928]             version = "1.8"), class = "FutureResult")
[17:37:36.928]     }, finally = {
[17:37:36.928]         if (!identical(...future.workdir, getwd())) 
[17:37:36.928]             setwd(...future.workdir)
[17:37:36.928]         {
[17:37:36.928]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:36.928]                 ...future.oldOptions$nwarnings <- NULL
[17:37:36.928]             }
[17:37:36.928]             base::options(...future.oldOptions)
[17:37:36.928]             if (.Platform$OS.type == "windows") {
[17:37:36.928]                 old_names <- names(...future.oldEnvVars)
[17:37:36.928]                 envs <- base::Sys.getenv()
[17:37:36.928]                 names <- names(envs)
[17:37:36.928]                 common <- intersect(names, old_names)
[17:37:36.928]                 added <- setdiff(names, old_names)
[17:37:36.928]                 removed <- setdiff(old_names, names)
[17:37:36.928]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:36.928]                   envs[common]]
[17:37:36.928]                 NAMES <- toupper(changed)
[17:37:36.928]                 args <- list()
[17:37:36.928]                 for (kk in seq_along(NAMES)) {
[17:37:36.928]                   name <- changed[[kk]]
[17:37:36.928]                   NAME <- NAMES[[kk]]
[17:37:36.928]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.928]                     next
[17:37:36.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.928]                 }
[17:37:36.928]                 NAMES <- toupper(added)
[17:37:36.928]                 for (kk in seq_along(NAMES)) {
[17:37:36.928]                   name <- added[[kk]]
[17:37:36.928]                   NAME <- NAMES[[kk]]
[17:37:36.928]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.928]                     next
[17:37:36.928]                   args[[name]] <- ""
[17:37:36.928]                 }
[17:37:36.928]                 NAMES <- toupper(removed)
[17:37:36.928]                 for (kk in seq_along(NAMES)) {
[17:37:36.928]                   name <- removed[[kk]]
[17:37:36.928]                   NAME <- NAMES[[kk]]
[17:37:36.928]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:36.928]                     next
[17:37:36.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:36.928]                 }
[17:37:36.928]                 if (length(args) > 0) 
[17:37:36.928]                   base::do.call(base::Sys.setenv, args = args)
[17:37:36.928]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:36.928]             }
[17:37:36.928]             else {
[17:37:36.928]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:36.928]             }
[17:37:36.928]             {
[17:37:36.928]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:36.928]                   0L) {
[17:37:36.928]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:36.928]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:36.928]                   base::options(opts)
[17:37:36.928]                 }
[17:37:36.928]                 {
[17:37:36.928]                   {
[17:37:36.928]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:36.928]                     NULL
[17:37:36.928]                   }
[17:37:36.928]                   options(future.plan = NULL)
[17:37:36.928]                   if (is.na(NA_character_)) 
[17:37:36.928]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:36.928]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:36.928]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:36.928]                     .init = FALSE)
[17:37:36.928]                 }
[17:37:36.928]             }
[17:37:36.928]         }
[17:37:36.928]     })
[17:37:36.928]     if (TRUE) {
[17:37:36.928]         base::sink(type = "output", split = FALSE)
[17:37:36.928]         if (TRUE) {
[17:37:36.928]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:36.928]         }
[17:37:36.928]         else {
[17:37:36.928]             ...future.result["stdout"] <- base::list(NULL)
[17:37:36.928]         }
[17:37:36.928]         base::close(...future.stdout)
[17:37:36.928]         ...future.stdout <- NULL
[17:37:36.928]     }
[17:37:36.928]     ...future.result$conditions <- ...future.conditions
[17:37:36.928]     ...future.result$finished <- base::Sys.time()
[17:37:36.928]     ...future.result
[17:37:36.928] }
[17:37:36.931] assign_globals() ...
[17:37:36.931] List of 5
[17:37:36.931]  $ ...future.FUN            :function (x, ...)  
[17:37:36.931]  $ MoreArgs                 : NULL
[17:37:36.931]  $ ...future.elements_ii    :List of 2
[17:37:36.931]   ..$ :List of 2
[17:37:36.931]   .. ..$ : int 3
[17:37:36.931]   .. ..$ : int 4
[17:37:36.931]   ..$ :List of 2
[17:37:36.931]   .. ..$ : int 2
[17:37:36.931]   .. ..$ : int 1
[17:37:36.931]  $ ...future.seeds_ii       : NULL
[17:37:36.931]  $ ...future.globals.maxSize: NULL
[17:37:36.931]  - attr(*, "where")=List of 5
[17:37:36.931]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:36.931]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:36.931]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:36.931]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:36.931]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:36.931]  - attr(*, "resolved")= logi FALSE
[17:37:36.931]  - attr(*, "total_size")= num 280
[17:37:36.931]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.931]  - attr(*, "already-done")= logi TRUE
[17:37:36.940] - copied ‘...future.FUN’ to environment
[17:37:36.940] - copied ‘MoreArgs’ to environment
[17:37:36.940] - copied ‘...future.elements_ii’ to environment
[17:37:36.940] - copied ‘...future.seeds_ii’ to environment
[17:37:36.941] - copied ‘...future.globals.maxSize’ to environment
[17:37:36.941] assign_globals() ... done
[17:37:36.941] requestCore(): workers = 2
[17:37:36.943] MulticoreFuture started
[17:37:36.944] - Launch lazy future ... done
[17:37:36.944] run() for ‘MulticoreFuture’ ... done
[17:37:36.944] Created future:
[17:37:36.944] plan(): Setting new future strategy stack:
[17:37:36.945] List of future strategies:
[17:37:36.945] 1. sequential:
[17:37:36.945]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:36.945]    - tweaked: FALSE
[17:37:36.945]    - call: NULL
[17:37:36.945] plan(): nbrOfWorkers() = 1
[17:37:36.948] plan(): Setting new future strategy stack:
[17:37:36.948] List of future strategies:
[17:37:36.948] 1. multicore:
[17:37:36.948]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:36.948]    - tweaked: FALSE
[17:37:36.948]    - call: plan(strategy)
[17:37:36.954] plan(): nbrOfWorkers() = 2
[17:37:36.944] MulticoreFuture:
[17:37:36.944] Label: ‘future_mapply-2’
[17:37:36.944] Expression:
[17:37:36.944] {
[17:37:36.944]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:36.944]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:36.944]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:36.944]         on.exit(options(oopts), add = TRUE)
[17:37:36.944]     }
[17:37:36.944]     {
[17:37:36.944]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:36.944]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:36.944]         do.call(mapply, args = args)
[17:37:36.944]     }
[17:37:36.944] }
[17:37:36.944] Lazy evaluation: FALSE
[17:37:36.944] Asynchronous evaluation: TRUE
[17:37:36.944] Local evaluation: TRUE
[17:37:36.944] Environment: R_GlobalEnv
[17:37:36.944] Capture standard output: TRUE
[17:37:36.944] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:36.944] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:36.944] Packages: <none>
[17:37:36.944] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:36.944] Resolved: TRUE
[17:37:36.944] Value: <not collected>
[17:37:36.944] Conditions captured: <none>
[17:37:36.944] Early signaling: FALSE
[17:37:36.944] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:36.944] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.955] Chunk #2 of 2 ... DONE
[17:37:36.955] Launching 2 futures (chunks) ... DONE
[17:37:36.955] Resolving 2 futures (chunks) ...
[17:37:36.955] resolve() on list ...
[17:37:36.955]  recursive: 0
[17:37:36.955]  length: 2
[17:37:36.956] 
[17:37:36.956] Future #1
[17:37:36.956] result() for MulticoreFuture ...
[17:37:36.957] result() for MulticoreFuture ...
[17:37:36.957] result() for MulticoreFuture ... done
[17:37:36.957] result() for MulticoreFuture ... done
[17:37:36.957] result() for MulticoreFuture ...
[17:37:36.958] result() for MulticoreFuture ... done
[17:37:36.958] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:37:36.958] - nx: 2
[17:37:36.958] - relay: TRUE
[17:37:36.958] - stdout: TRUE
[17:37:36.958] - signal: TRUE
[17:37:36.958] - resignal: FALSE
[17:37:36.959] - force: TRUE
[17:37:36.959] - relayed: [n=2] FALSE, FALSE
[17:37:36.959] - queued futures: [n=2] FALSE, FALSE
[17:37:36.959]  - until=1
[17:37:36.959]  - relaying element #1
[17:37:36.959] result() for MulticoreFuture ...
[17:37:36.959] result() for MulticoreFuture ... done
[17:37:36.960] result() for MulticoreFuture ...
[17:37:36.960] result() for MulticoreFuture ... done
[17:37:36.960] result() for MulticoreFuture ...
[17:37:36.960] result() for MulticoreFuture ... done
[17:37:36.960] result() for MulticoreFuture ...
[17:37:36.960] result() for MulticoreFuture ... done
[17:37:36.961] - relayed: [n=2] TRUE, FALSE
[17:37:36.961] - queued futures: [n=2] TRUE, FALSE
[17:37:36.961] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:37:36.961]  length: 1 (resolved future 1)
[17:37:36.961] Future #2
[17:37:36.962] result() for MulticoreFuture ...
[17:37:36.962] result() for MulticoreFuture ...
[17:37:36.962] result() for MulticoreFuture ... done
[17:37:36.963] result() for MulticoreFuture ... done
[17:37:36.963] result() for MulticoreFuture ...
[17:37:36.963] result() for MulticoreFuture ... done
[17:37:36.963] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:37:36.963] - nx: 2
[17:37:36.963] - relay: TRUE
[17:37:36.964] - stdout: TRUE
[17:37:36.964] - signal: TRUE
[17:37:36.964] - resignal: FALSE
[17:37:36.964] - force: TRUE
[17:37:36.964] - relayed: [n=2] TRUE, FALSE
[17:37:36.964] - queued futures: [n=2] TRUE, FALSE
[17:37:36.964]  - until=2
[17:37:36.964]  - relaying element #2
[17:37:36.965] result() for MulticoreFuture ...
[17:37:36.965] result() for MulticoreFuture ... done
[17:37:36.968] result() for MulticoreFuture ...
[17:37:36.968] result() for MulticoreFuture ... done
[17:37:36.968] result() for MulticoreFuture ...
[17:37:36.969] result() for MulticoreFuture ... done
[17:37:36.969] result() for MulticoreFuture ...
[17:37:36.969] result() for MulticoreFuture ... done
[17:37:36.969] - relayed: [n=2] TRUE, TRUE
[17:37:36.969] - queued futures: [n=2] TRUE, TRUE
[17:37:36.969] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:37:36.970]  length: 0 (resolved future 2)
[17:37:36.970] Relaying remaining futures
[17:37:36.970] signalConditionsASAP(NULL, pos=0) ...
[17:37:36.970] - nx: 2
[17:37:36.970] - relay: TRUE
[17:37:36.970] - stdout: TRUE
[17:37:36.971] - signal: TRUE
[17:37:36.971] - resignal: FALSE
[17:37:36.971] - force: TRUE
[17:37:36.971] - relayed: [n=2] TRUE, TRUE
[17:37:36.971] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:36.971] - relayed: [n=2] TRUE, TRUE
[17:37:36.972] - queued futures: [n=2] TRUE, TRUE
[17:37:36.972] signalConditionsASAP(NULL, pos=0) ... done
[17:37:36.972] resolve() on list ... DONE
[17:37:36.972] result() for MulticoreFuture ...
[17:37:36.972] result() for MulticoreFuture ... done
[17:37:36.972] result() for MulticoreFuture ...
[17:37:36.972] result() for MulticoreFuture ... done
[17:37:36.973] result() for MulticoreFuture ...
[17:37:36.973] result() for MulticoreFuture ... done
[17:37:36.973] result() for MulticoreFuture ...
[17:37:36.973] result() for MulticoreFuture ... done
[17:37:36.973]  - Number of value chunks collected: 2
[17:37:36.973] Resolving 2 futures (chunks) ... DONE
[17:37:36.973] Reducing values from 2 chunks ...
[17:37:36.974]  - Number of values collected after concatenation: 4
[17:37:36.974]  - Number of values expected: 4
[17:37:36.974] Reducing values from 2 chunks ... DONE
[17:37:36.974] future_mapply() ... DONE
- Parallel RNG ...
[17:37:36.974] future_mapply() ...
[17:37:36.974] Generating random seeds ...
[17:37:36.975] Generating random seed streams for 4 elements ...
[17:37:36.975] Generating random seed streams for 4 elements ... DONE
[17:37:36.975] Generating random seeds ... DONE
[17:37:36.975] Will set RNG state on exit: 10407, -68461757, 1638253765, -1353401045, 1122918283, -834872073, -1411263191
[17:37:36.980] Number of chunks: 2
[17:37:36.980] getGlobalsAndPackagesXApply() ...
[17:37:36.980]  - future.globals: TRUE
[17:37:36.980] getGlobalsAndPackages() ...
[17:37:36.980] Searching for globals...
[17:37:36.982] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[17:37:36.982] Searching for globals ... DONE
[17:37:36.982] Resolving globals: FALSE
[17:37:36.983] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[17:37:36.983] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[17:37:36.983] - globals: [1] ‘FUN’
[17:37:36.983] - packages: [1] ‘stats’
[17:37:36.983] getGlobalsAndPackages() ... DONE
[17:37:36.984]  - globals found/used: [n=1] ‘FUN’
[17:37:36.984]  - needed namespaces: [n=1] ‘stats’
[17:37:36.984] Finding globals ... DONE
[17:37:36.984] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:36.984] List of 2
[17:37:36.984]  $ ...future.FUN:function (n, min = 0, max = 1)  
[17:37:36.984]  $ MoreArgs     :List of 1
[17:37:36.984]   ..$ min: num 1
[17:37:36.984]  - attr(*, "where")=List of 2
[17:37:36.984]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:36.984]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:36.984]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:36.984]  - attr(*, "resolved")= logi FALSE
[17:37:36.984]  - attr(*, "total_size")= num NA
[17:37:36.987] Packages to be attached in all futures: [n=1] ‘stats’
[17:37:36.987] getGlobalsAndPackagesXApply() ... DONE
[17:37:36.988] Number of futures (= number of chunks): 2
[17:37:36.988] Launching 2 futures (chunks) ...
[17:37:36.988] Chunk #1 of 2 ...
[17:37:36.988]  - Finding globals in '...' for chunk #1 ...
[17:37:36.988] getGlobalsAndPackages() ...
[17:37:36.988] Searching for globals...
[17:37:36.988] 
[17:37:36.989] Searching for globals ... DONE
[17:37:36.989] - globals: [0] <none>
[17:37:36.989] getGlobalsAndPackages() ... DONE
[17:37:36.989]    + additional globals found: [n=0] 
[17:37:36.989]    + additional namespaces needed: [n=0] 
[17:37:36.989]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:36.989]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:36.989]  - seeds: [2] <seeds>
[17:37:36.989]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.989] getGlobalsAndPackages() ...
[17:37:36.990] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.990] Resolving globals: FALSE
[17:37:36.990] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[17:37:36.991] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[17:37:36.991] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:36.991] - packages: [1] ‘stats’
[17:37:36.991] getGlobalsAndPackages() ... DONE
[17:37:36.991] run() for ‘Future’ ...
[17:37:36.991] - state: ‘created’
[17:37:36.992] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:36.995] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:36.995] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:36.995]   - Field: ‘label’
[17:37:36.996]   - Field: ‘local’
[17:37:36.996]   - Field: ‘owner’
[17:37:36.996]   - Field: ‘envir’
[17:37:36.996]   - Field: ‘workers’
[17:37:36.996]   - Field: ‘packages’
[17:37:36.996]   - Field: ‘gc’
[17:37:36.996]   - Field: ‘job’
[17:37:36.996]   - Field: ‘conditions’
[17:37:36.996]   - Field: ‘expr’
[17:37:36.999]   - Field: ‘uuid’
[17:37:36.999]   - Field: ‘seed’
[17:37:36.999]   - Field: ‘version’
[17:37:36.999]   - Field: ‘result’
[17:37:36.999]   - Field: ‘asynchronous’
[17:37:37.000]   - Field: ‘calls’
[17:37:37.000]   - Field: ‘globals’
[17:37:37.000]   - Field: ‘stdout’
[17:37:37.000]   - Field: ‘earlySignal’
[17:37:37.000]   - Field: ‘lazy’
[17:37:37.000]   - Field: ‘state’
[17:37:37.000] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:37.000] - Launch lazy future ...
[17:37:37.001] Packages needed by the future expression (n = 1): ‘stats’
[17:37:37.001] Packages needed by future strategies (n = 0): <none>
[17:37:37.001] {
[17:37:37.001]     {
[17:37:37.001]         {
[17:37:37.001]             ...future.startTime <- base::Sys.time()
[17:37:37.001]             {
[17:37:37.001]                 {
[17:37:37.001]                   {
[17:37:37.001]                     {
[17:37:37.001]                       {
[17:37:37.001]                         base::local({
[17:37:37.001]                           has_future <- base::requireNamespace("future", 
[17:37:37.001]                             quietly = TRUE)
[17:37:37.001]                           if (has_future) {
[17:37:37.001]                             ns <- base::getNamespace("future")
[17:37:37.001]                             version <- ns[[".package"]][["version"]]
[17:37:37.001]                             if (is.null(version)) 
[17:37:37.001]                               version <- utils::packageVersion("future")
[17:37:37.001]                           }
[17:37:37.001]                           else {
[17:37:37.001]                             version <- NULL
[17:37:37.001]                           }
[17:37:37.001]                           if (!has_future || version < "1.8.0") {
[17:37:37.001]                             info <- base::c(r_version = base::gsub("R version ", 
[17:37:37.001]                               "", base::R.version$version.string), 
[17:37:37.001]                               platform = base::sprintf("%s (%s-bit)", 
[17:37:37.001]                                 base::R.version$platform, 8 * 
[17:37:37.001]                                   base::.Machine$sizeof.pointer), 
[17:37:37.001]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:37.001]                                 "release", "version")], collapse = " "), 
[17:37:37.001]                               hostname = base::Sys.info()[["nodename"]])
[17:37:37.001]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:37:37.001]                               info)
[17:37:37.001]                             info <- base::paste(info, collapse = "; ")
[17:37:37.001]                             if (!has_future) {
[17:37:37.001]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:37.001]                                 info)
[17:37:37.001]                             }
[17:37:37.001]                             else {
[17:37:37.001]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:37.001]                                 info, version)
[17:37:37.001]                             }
[17:37:37.001]                             base::stop(msg)
[17:37:37.001]                           }
[17:37:37.001]                         })
[17:37:37.001]                       }
[17:37:37.001]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:37.001]                       base::options(mc.cores = 1L)
[17:37:37.001]                     }
[17:37:37.001]                     base::local({
[17:37:37.001]                       for (pkg in "stats") {
[17:37:37.001]                         base::loadNamespace(pkg)
[17:37:37.001]                         base::library(pkg, character.only = TRUE)
[17:37:37.001]                       }
[17:37:37.001]                     })
[17:37:37.001]                   }
[17:37:37.001]                   ...future.strategy.old <- future::plan("list")
[17:37:37.001]                   options(future.plan = NULL)
[17:37:37.001]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:37.001]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:37.001]                 }
[17:37:37.001]                 ...future.workdir <- getwd()
[17:37:37.001]             }
[17:37:37.001]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:37.001]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:37.001]         }
[17:37:37.001]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:37.001]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:37.001]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:37.001]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:37.001]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:37.001]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:37.001]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:37.001]             base::names(...future.oldOptions))
[17:37:37.001]     }
[17:37:37.001]     if (FALSE) {
[17:37:37.001]     }
[17:37:37.001]     else {
[17:37:37.001]         if (TRUE) {
[17:37:37.001]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:37.001]                 open = "w")
[17:37:37.001]         }
[17:37:37.001]         else {
[17:37:37.001]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:37.001]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:37.001]         }
[17:37:37.001]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:37.001]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:37.001]             base::sink(type = "output", split = FALSE)
[17:37:37.001]             base::close(...future.stdout)
[17:37:37.001]         }, add = TRUE)
[17:37:37.001]     }
[17:37:37.001]     ...future.frame <- base::sys.nframe()
[17:37:37.001]     ...future.conditions <- base::list()
[17:37:37.001]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:37.001]     if (FALSE) {
[17:37:37.001]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:37.001]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:37.001]     }
[17:37:37.001]     ...future.result <- base::tryCatch({
[17:37:37.001]         base::withCallingHandlers({
[17:37:37.001]             ...future.value <- base::withVisible(base::local({
[17:37:37.001]                 withCallingHandlers({
[17:37:37.001]                   {
[17:37:37.001]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:37.001]                     if (!identical(...future.globals.maxSize.org, 
[17:37:37.001]                       ...future.globals.maxSize)) {
[17:37:37.001]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:37.001]                       on.exit(options(oopts), add = TRUE)
[17:37:37.001]                     }
[17:37:37.001]                     {
[17:37:37.001]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:37:37.001]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:37:37.001]                           envir = globalenv(), inherits = FALSE)
[17:37:37.001]                         ...future.FUN(...)
[17:37:37.001]                       }
[17:37:37.001]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:37:37.001]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:37:37.001]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:37.001]                         USE.NAMES = FALSE)
[17:37:37.001]                       do.call(mapply, args = args)
[17:37:37.001]                     }
[17:37:37.001]                   }
[17:37:37.001]                 }, immediateCondition = function(cond) {
[17:37:37.001]                   save_rds <- function (object, pathname, ...) 
[17:37:37.001]                   {
[17:37:37.001]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:37.001]                     if (file_test("-f", pathname_tmp)) {
[17:37:37.001]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.001]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:37.001]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.001]                         fi_tmp[["mtime"]])
[17:37:37.001]                     }
[17:37:37.001]                     tryCatch({
[17:37:37.001]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:37.001]                     }, error = function(ex) {
[17:37:37.001]                       msg <- conditionMessage(ex)
[17:37:37.001]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.001]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:37.001]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.001]                         fi_tmp[["mtime"]], msg)
[17:37:37.001]                       ex$message <- msg
[17:37:37.001]                       stop(ex)
[17:37:37.001]                     })
[17:37:37.001]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:37.001]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:37.001]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:37.001]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.001]                       fi <- file.info(pathname)
[17:37:37.001]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:37.001]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.001]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:37.001]                         fi[["size"]], fi[["mtime"]])
[17:37:37.001]                       stop(msg)
[17:37:37.001]                     }
[17:37:37.001]                     invisible(pathname)
[17:37:37.001]                   }
[17:37:37.001]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:37.001]                     rootPath = tempdir()) 
[17:37:37.001]                   {
[17:37:37.001]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:37.001]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:37.001]                       tmpdir = path, fileext = ".rds")
[17:37:37.001]                     save_rds(obj, file)
[17:37:37.001]                   }
[17:37:37.001]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:37.001]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.001]                   {
[17:37:37.001]                     inherits <- base::inherits
[17:37:37.001]                     invokeRestart <- base::invokeRestart
[17:37:37.001]                     is.null <- base::is.null
[17:37:37.001]                     muffled <- FALSE
[17:37:37.001]                     if (inherits(cond, "message")) {
[17:37:37.001]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:37.001]                       if (muffled) 
[17:37:37.001]                         invokeRestart("muffleMessage")
[17:37:37.001]                     }
[17:37:37.001]                     else if (inherits(cond, "warning")) {
[17:37:37.001]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:37.001]                       if (muffled) 
[17:37:37.001]                         invokeRestart("muffleWarning")
[17:37:37.001]                     }
[17:37:37.001]                     else if (inherits(cond, "condition")) {
[17:37:37.001]                       if (!is.null(pattern)) {
[17:37:37.001]                         computeRestarts <- base::computeRestarts
[17:37:37.001]                         grepl <- base::grepl
[17:37:37.001]                         restarts <- computeRestarts(cond)
[17:37:37.001]                         for (restart in restarts) {
[17:37:37.001]                           name <- restart$name
[17:37:37.001]                           if (is.null(name)) 
[17:37:37.001]                             next
[17:37:37.001]                           if (!grepl(pattern, name)) 
[17:37:37.001]                             next
[17:37:37.001]                           invokeRestart(restart)
[17:37:37.001]                           muffled <- TRUE
[17:37:37.001]                           break
[17:37:37.001]                         }
[17:37:37.001]                       }
[17:37:37.001]                     }
[17:37:37.001]                     invisible(muffled)
[17:37:37.001]                   }
[17:37:37.001]                   muffleCondition(cond)
[17:37:37.001]                 })
[17:37:37.001]             }))
[17:37:37.001]             future::FutureResult(value = ...future.value$value, 
[17:37:37.001]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:37.001]                   ...future.rng), globalenv = if (FALSE) 
[17:37:37.001]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:37.001]                     ...future.globalenv.names))
[17:37:37.001]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:37.001]         }, condition = base::local({
[17:37:37.001]             c <- base::c
[17:37:37.001]             inherits <- base::inherits
[17:37:37.001]             invokeRestart <- base::invokeRestart
[17:37:37.001]             length <- base::length
[17:37:37.001]             list <- base::list
[17:37:37.001]             seq.int <- base::seq.int
[17:37:37.001]             signalCondition <- base::signalCondition
[17:37:37.001]             sys.calls <- base::sys.calls
[17:37:37.001]             `[[` <- base::`[[`
[17:37:37.001]             `+` <- base::`+`
[17:37:37.001]             `<<-` <- base::`<<-`
[17:37:37.001]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:37.001]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:37.001]                   3L)]
[17:37:37.001]             }
[17:37:37.001]             function(cond) {
[17:37:37.001]                 is_error <- inherits(cond, "error")
[17:37:37.001]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:37.001]                   NULL)
[17:37:37.001]                 if (is_error) {
[17:37:37.001]                   sessionInformation <- function() {
[17:37:37.001]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:37.001]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:37.001]                       search = base::search(), system = base::Sys.info())
[17:37:37.001]                   }
[17:37:37.001]                   ...future.conditions[[length(...future.conditions) + 
[17:37:37.001]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:37.001]                     cond$call), session = sessionInformation(), 
[17:37:37.001]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:37.001]                   signalCondition(cond)
[17:37:37.001]                 }
[17:37:37.001]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:37.001]                 "immediateCondition"))) {
[17:37:37.001]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:37.001]                   ...future.conditions[[length(...future.conditions) + 
[17:37:37.001]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:37.001]                   if (TRUE && !signal) {
[17:37:37.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.001]                     {
[17:37:37.001]                       inherits <- base::inherits
[17:37:37.001]                       invokeRestart <- base::invokeRestart
[17:37:37.001]                       is.null <- base::is.null
[17:37:37.001]                       muffled <- FALSE
[17:37:37.001]                       if (inherits(cond, "message")) {
[17:37:37.001]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:37.001]                         if (muffled) 
[17:37:37.001]                           invokeRestart("muffleMessage")
[17:37:37.001]                       }
[17:37:37.001]                       else if (inherits(cond, "warning")) {
[17:37:37.001]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:37.001]                         if (muffled) 
[17:37:37.001]                           invokeRestart("muffleWarning")
[17:37:37.001]                       }
[17:37:37.001]                       else if (inherits(cond, "condition")) {
[17:37:37.001]                         if (!is.null(pattern)) {
[17:37:37.001]                           computeRestarts <- base::computeRestarts
[17:37:37.001]                           grepl <- base::grepl
[17:37:37.001]                           restarts <- computeRestarts(cond)
[17:37:37.001]                           for (restart in restarts) {
[17:37:37.001]                             name <- restart$name
[17:37:37.001]                             if (is.null(name)) 
[17:37:37.001]                               next
[17:37:37.001]                             if (!grepl(pattern, name)) 
[17:37:37.001]                               next
[17:37:37.001]                             invokeRestart(restart)
[17:37:37.001]                             muffled <- TRUE
[17:37:37.001]                             break
[17:37:37.001]                           }
[17:37:37.001]                         }
[17:37:37.001]                       }
[17:37:37.001]                       invisible(muffled)
[17:37:37.001]                     }
[17:37:37.001]                     muffleCondition(cond, pattern = "^muffle")
[17:37:37.001]                   }
[17:37:37.001]                 }
[17:37:37.001]                 else {
[17:37:37.001]                   if (TRUE) {
[17:37:37.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.001]                     {
[17:37:37.001]                       inherits <- base::inherits
[17:37:37.001]                       invokeRestart <- base::invokeRestart
[17:37:37.001]                       is.null <- base::is.null
[17:37:37.001]                       muffled <- FALSE
[17:37:37.001]                       if (inherits(cond, "message")) {
[17:37:37.001]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:37.001]                         if (muffled) 
[17:37:37.001]                           invokeRestart("muffleMessage")
[17:37:37.001]                       }
[17:37:37.001]                       else if (inherits(cond, "warning")) {
[17:37:37.001]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:37.001]                         if (muffled) 
[17:37:37.001]                           invokeRestart("muffleWarning")
[17:37:37.001]                       }
[17:37:37.001]                       else if (inherits(cond, "condition")) {
[17:37:37.001]                         if (!is.null(pattern)) {
[17:37:37.001]                           computeRestarts <- base::computeRestarts
[17:37:37.001]                           grepl <- base::grepl
[17:37:37.001]                           restarts <- computeRestarts(cond)
[17:37:37.001]                           for (restart in restarts) {
[17:37:37.001]                             name <- restart$name
[17:37:37.001]                             if (is.null(name)) 
[17:37:37.001]                               next
[17:37:37.001]                             if (!grepl(pattern, name)) 
[17:37:37.001]                               next
[17:37:37.001]                             invokeRestart(restart)
[17:37:37.001]                             muffled <- TRUE
[17:37:37.001]                             break
[17:37:37.001]                           }
[17:37:37.001]                         }
[17:37:37.001]                       }
[17:37:37.001]                       invisible(muffled)
[17:37:37.001]                     }
[17:37:37.001]                     muffleCondition(cond, pattern = "^muffle")
[17:37:37.001]                   }
[17:37:37.001]                 }
[17:37:37.001]             }
[17:37:37.001]         }))
[17:37:37.001]     }, error = function(ex) {
[17:37:37.001]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:37.001]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:37.001]                 ...future.rng), started = ...future.startTime, 
[17:37:37.001]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:37.001]             version = "1.8"), class = "FutureResult")
[17:37:37.001]     }, finally = {
[17:37:37.001]         if (!identical(...future.workdir, getwd())) 
[17:37:37.001]             setwd(...future.workdir)
[17:37:37.001]         {
[17:37:37.001]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:37.001]                 ...future.oldOptions$nwarnings <- NULL
[17:37:37.001]             }
[17:37:37.001]             base::options(...future.oldOptions)
[17:37:37.001]             if (.Platform$OS.type == "windows") {
[17:37:37.001]                 old_names <- names(...future.oldEnvVars)
[17:37:37.001]                 envs <- base::Sys.getenv()
[17:37:37.001]                 names <- names(envs)
[17:37:37.001]                 common <- intersect(names, old_names)
[17:37:37.001]                 added <- setdiff(names, old_names)
[17:37:37.001]                 removed <- setdiff(old_names, names)
[17:37:37.001]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:37.001]                   envs[common]]
[17:37:37.001]                 NAMES <- toupper(changed)
[17:37:37.001]                 args <- list()
[17:37:37.001]                 for (kk in seq_along(NAMES)) {
[17:37:37.001]                   name <- changed[[kk]]
[17:37:37.001]                   NAME <- NAMES[[kk]]
[17:37:37.001]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.001]                     next
[17:37:37.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:37.001]                 }
[17:37:37.001]                 NAMES <- toupper(added)
[17:37:37.001]                 for (kk in seq_along(NAMES)) {
[17:37:37.001]                   name <- added[[kk]]
[17:37:37.001]                   NAME <- NAMES[[kk]]
[17:37:37.001]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.001]                     next
[17:37:37.001]                   args[[name]] <- ""
[17:37:37.001]                 }
[17:37:37.001]                 NAMES <- toupper(removed)
[17:37:37.001]                 for (kk in seq_along(NAMES)) {
[17:37:37.001]                   name <- removed[[kk]]
[17:37:37.001]                   NAME <- NAMES[[kk]]
[17:37:37.001]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.001]                     next
[17:37:37.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:37.001]                 }
[17:37:37.001]                 if (length(args) > 0) 
[17:37:37.001]                   base::do.call(base::Sys.setenv, args = args)
[17:37:37.001]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:37.001]             }
[17:37:37.001]             else {
[17:37:37.001]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:37.001]             }
[17:37:37.001]             {
[17:37:37.001]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:37.001]                   0L) {
[17:37:37.001]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:37.001]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:37.001]                   base::options(opts)
[17:37:37.001]                 }
[17:37:37.001]                 {
[17:37:37.001]                   {
[17:37:37.001]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:37.001]                     NULL
[17:37:37.001]                   }
[17:37:37.001]                   options(future.plan = NULL)
[17:37:37.001]                   if (is.na(NA_character_)) 
[17:37:37.001]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:37.001]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:37.001]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:37.001]                     .init = FALSE)
[17:37:37.001]                 }
[17:37:37.001]             }
[17:37:37.001]         }
[17:37:37.001]     })
[17:37:37.001]     if (TRUE) {
[17:37:37.001]         base::sink(type = "output", split = FALSE)
[17:37:37.001]         if (TRUE) {
[17:37:37.001]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:37.001]         }
[17:37:37.001]         else {
[17:37:37.001]             ...future.result["stdout"] <- base::list(NULL)
[17:37:37.001]         }
[17:37:37.001]         base::close(...future.stdout)
[17:37:37.001]         ...future.stdout <- NULL
[17:37:37.001]     }
[17:37:37.001]     ...future.result$conditions <- ...future.conditions
[17:37:37.001]     ...future.result$finished <- base::Sys.time()
[17:37:37.001]     ...future.result
[17:37:37.001] }
[17:37:37.004] assign_globals() ...
[17:37:37.004] List of 5
[17:37:37.004]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[17:37:37.004]  $ MoreArgs                 :List of 1
[17:37:37.004]   ..$ min: num 1
[17:37:37.004]  $ ...future.elements_ii    :List of 2
[17:37:37.004]   ..$ n  :List of 2
[17:37:37.004]   .. ..$ : int 1
[17:37:37.004]   .. ..$ : int 2
[17:37:37.004]   ..$ max:List of 2
[17:37:37.004]   .. ..$ : int 2
[17:37:37.004]   .. ..$ : int 3
[17:37:37.004]  $ ...future.seeds_ii       :List of 2
[17:37:37.004]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[17:37:37.004]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[17:37:37.004]  $ ...future.globals.maxSize: NULL
[17:37:37.004]  - attr(*, "where")=List of 5
[17:37:37.004]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:37.004]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:37.004]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:37.004]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:37.004]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:37.004]  - attr(*, "resolved")= logi FALSE
[17:37:37.004]  - attr(*, "total_size")= num 2528
[17:37:37.004]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:37.004]  - attr(*, "already-done")= logi TRUE
[17:37:37.011] - copied ‘...future.FUN’ to environment
[17:37:37.012] - copied ‘MoreArgs’ to environment
[17:37:37.012] - copied ‘...future.elements_ii’ to environment
[17:37:37.012] - copied ‘...future.seeds_ii’ to environment
[17:37:37.012] - copied ‘...future.globals.maxSize’ to environment
[17:37:37.012] assign_globals() ... done
[17:37:37.012] requestCore(): workers = 2
[17:37:37.014] MulticoreFuture started
[17:37:37.015] - Launch lazy future ... done
[17:37:37.015] run() for ‘MulticoreFuture’ ... done
[17:37:37.015] Created future:
[17:37:37.016] plan(): Setting new future strategy stack:
[17:37:37.016] List of future strategies:
[17:37:37.016] 1. sequential:
[17:37:37.016]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:37.016]    - tweaked: FALSE
[17:37:37.016]    - call: NULL
[17:37:37.017] plan(): nbrOfWorkers() = 1
[17:37:37.019] plan(): Setting new future strategy stack:
[17:37:37.019] List of future strategies:
[17:37:37.019] 1. multicore:
[17:37:37.019]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:37.019]    - tweaked: FALSE
[17:37:37.019]    - call: plan(strategy)
[17:37:37.024] plan(): nbrOfWorkers() = 2
[17:37:37.016] MulticoreFuture:
[17:37:37.016] Label: ‘future_mapply-1’
[17:37:37.016] Expression:
[17:37:37.016] {
[17:37:37.016]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:37.016]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:37.016]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:37.016]         on.exit(options(oopts), add = TRUE)
[17:37:37.016]     }
[17:37:37.016]     {
[17:37:37.016]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:37:37.016]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:37:37.016]                 inherits = FALSE)
[17:37:37.016]             ...future.FUN(...)
[17:37:37.016]         }
[17:37:37.016]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:37:37.016]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:37:37.016]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:37.016]         do.call(mapply, args = args)
[17:37:37.016]     }
[17:37:37.016] }
[17:37:37.016] Lazy evaluation: FALSE
[17:37:37.016] Asynchronous evaluation: TRUE
[17:37:37.016] Local evaluation: TRUE
[17:37:37.016] Environment: R_GlobalEnv
[17:37:37.016] Capture standard output: TRUE
[17:37:37.016] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:37.016] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:37.016] Packages: 1 packages (‘stats’)
[17:37:37.016] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:37:37.016] Resolved: TRUE
[17:37:37.016] Value: <not collected>
[17:37:37.016] Conditions captured: <none>
[17:37:37.016] Early signaling: FALSE
[17:37:37.016] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:37.016] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:37.026] Chunk #1 of 2 ... DONE
[17:37:37.026] Chunk #2 of 2 ...
[17:37:37.026]  - Finding globals in '...' for chunk #2 ...
[17:37:37.026] getGlobalsAndPackages() ...
[17:37:37.026] Searching for globals...
[17:37:37.027] 
[17:37:37.027] Searching for globals ... DONE
[17:37:37.027] - globals: [0] <none>
[17:37:37.027] getGlobalsAndPackages() ... DONE
[17:37:37.027]    + additional globals found: [n=0] 
[17:37:37.027]    + additional namespaces needed: [n=0] 
[17:37:37.028]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:37.028]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:37.028]  - seeds: [2] <seeds>
[17:37:37.028]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:37.028] getGlobalsAndPackages() ...
[17:37:37.028] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:37.029] Resolving globals: FALSE
[17:37:37.030] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[17:37:37.030] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[17:37:37.031] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:37.031] - packages: [1] ‘stats’
[17:37:37.031] getGlobalsAndPackages() ... DONE
[17:37:37.032] run() for ‘Future’ ...
[17:37:37.032] - state: ‘created’
[17:37:37.032] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:37.037] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:37.037] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:37.037]   - Field: ‘label’
[17:37:37.037]   - Field: ‘local’
[17:37:37.037]   - Field: ‘owner’
[17:37:37.038]   - Field: ‘envir’
[17:37:37.038]   - Field: ‘workers’
[17:37:37.038]   - Field: ‘packages’
[17:37:37.038]   - Field: ‘gc’
[17:37:37.038]   - Field: ‘job’
[17:37:37.038]   - Field: ‘conditions’
[17:37:37.039]   - Field: ‘expr’
[17:37:37.039]   - Field: ‘uuid’
[17:37:37.039]   - Field: ‘seed’
[17:37:37.039]   - Field: ‘version’
[17:37:37.039]   - Field: ‘result’
[17:37:37.039]   - Field: ‘asynchronous’
[17:37:37.043]   - Field: ‘calls’
[17:37:37.044]   - Field: ‘globals’
[17:37:37.044]   - Field: ‘stdout’
[17:37:37.044]   - Field: ‘earlySignal’
[17:37:37.045]   - Field: ‘lazy’
[17:37:37.045]   - Field: ‘state’
[17:37:37.045] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:37.045] - Launch lazy future ...
[17:37:37.046] Packages needed by the future expression (n = 1): ‘stats’
[17:37:37.046] Packages needed by future strategies (n = 0): <none>
[17:37:37.048] {
[17:37:37.048]     {
[17:37:37.048]         {
[17:37:37.048]             ...future.startTime <- base::Sys.time()
[17:37:37.048]             {
[17:37:37.048]                 {
[17:37:37.048]                   {
[17:37:37.048]                     {
[17:37:37.048]                       {
[17:37:37.048]                         base::local({
[17:37:37.048]                           has_future <- base::requireNamespace("future", 
[17:37:37.048]                             quietly = TRUE)
[17:37:37.048]                           if (has_future) {
[17:37:37.048]                             ns <- base::getNamespace("future")
[17:37:37.048]                             version <- ns[[".package"]][["version"]]
[17:37:37.048]                             if (is.null(version)) 
[17:37:37.048]                               version <- utils::packageVersion("future")
[17:37:37.048]                           }
[17:37:37.048]                           else {
[17:37:37.048]                             version <- NULL
[17:37:37.048]                           }
[17:37:37.048]                           if (!has_future || version < "1.8.0") {
[17:37:37.048]                             info <- base::c(r_version = base::gsub("R version ", 
[17:37:37.048]                               "", base::R.version$version.string), 
[17:37:37.048]                               platform = base::sprintf("%s (%s-bit)", 
[17:37:37.048]                                 base::R.version$platform, 8 * 
[17:37:37.048]                                   base::.Machine$sizeof.pointer), 
[17:37:37.048]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:37.048]                                 "release", "version")], collapse = " "), 
[17:37:37.048]                               hostname = base::Sys.info()[["nodename"]])
[17:37:37.048]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:37:37.048]                               info)
[17:37:37.048]                             info <- base::paste(info, collapse = "; ")
[17:37:37.048]                             if (!has_future) {
[17:37:37.048]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:37.048]                                 info)
[17:37:37.048]                             }
[17:37:37.048]                             else {
[17:37:37.048]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:37.048]                                 info, version)
[17:37:37.048]                             }
[17:37:37.048]                             base::stop(msg)
[17:37:37.048]                           }
[17:37:37.048]                         })
[17:37:37.048]                       }
[17:37:37.048]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:37.048]                       base::options(mc.cores = 1L)
[17:37:37.048]                     }
[17:37:37.048]                     base::local({
[17:37:37.048]                       for (pkg in "stats") {
[17:37:37.048]                         base::loadNamespace(pkg)
[17:37:37.048]                         base::library(pkg, character.only = TRUE)
[17:37:37.048]                       }
[17:37:37.048]                     })
[17:37:37.048]                   }
[17:37:37.048]                   ...future.strategy.old <- future::plan("list")
[17:37:37.048]                   options(future.plan = NULL)
[17:37:37.048]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:37.048]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:37.048]                 }
[17:37:37.048]                 ...future.workdir <- getwd()
[17:37:37.048]             }
[17:37:37.048]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:37.048]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:37.048]         }
[17:37:37.048]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:37.048]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:37.048]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:37.048]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:37.048]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:37.048]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:37.048]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:37.048]             base::names(...future.oldOptions))
[17:37:37.048]     }
[17:37:37.048]     if (FALSE) {
[17:37:37.048]     }
[17:37:37.048]     else {
[17:37:37.048]         if (TRUE) {
[17:37:37.048]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:37.048]                 open = "w")
[17:37:37.048]         }
[17:37:37.048]         else {
[17:37:37.048]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:37.048]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:37.048]         }
[17:37:37.048]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:37.048]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:37.048]             base::sink(type = "output", split = FALSE)
[17:37:37.048]             base::close(...future.stdout)
[17:37:37.048]         }, add = TRUE)
[17:37:37.048]     }
[17:37:37.048]     ...future.frame <- base::sys.nframe()
[17:37:37.048]     ...future.conditions <- base::list()
[17:37:37.048]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:37.048]     if (FALSE) {
[17:37:37.048]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:37.048]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:37.048]     }
[17:37:37.048]     ...future.result <- base::tryCatch({
[17:37:37.048]         base::withCallingHandlers({
[17:37:37.048]             ...future.value <- base::withVisible(base::local({
[17:37:37.048]                 withCallingHandlers({
[17:37:37.048]                   {
[17:37:37.048]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:37.048]                     if (!identical(...future.globals.maxSize.org, 
[17:37:37.048]                       ...future.globals.maxSize)) {
[17:37:37.048]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:37.048]                       on.exit(options(oopts), add = TRUE)
[17:37:37.048]                     }
[17:37:37.048]                     {
[17:37:37.048]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:37:37.048]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:37:37.048]                           envir = globalenv(), inherits = FALSE)
[17:37:37.048]                         ...future.FUN(...)
[17:37:37.048]                       }
[17:37:37.048]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:37:37.048]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:37:37.048]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:37.048]                         USE.NAMES = FALSE)
[17:37:37.048]                       do.call(mapply, args = args)
[17:37:37.048]                     }
[17:37:37.048]                   }
[17:37:37.048]                 }, immediateCondition = function(cond) {
[17:37:37.048]                   save_rds <- function (object, pathname, ...) 
[17:37:37.048]                   {
[17:37:37.048]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:37.048]                     if (file_test("-f", pathname_tmp)) {
[17:37:37.048]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.048]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:37.048]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.048]                         fi_tmp[["mtime"]])
[17:37:37.048]                     }
[17:37:37.048]                     tryCatch({
[17:37:37.048]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:37.048]                     }, error = function(ex) {
[17:37:37.048]                       msg <- conditionMessage(ex)
[17:37:37.048]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.048]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:37.048]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.048]                         fi_tmp[["mtime"]], msg)
[17:37:37.048]                       ex$message <- msg
[17:37:37.048]                       stop(ex)
[17:37:37.048]                     })
[17:37:37.048]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:37.048]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:37.048]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:37.048]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.048]                       fi <- file.info(pathname)
[17:37:37.048]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:37.048]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.048]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:37.048]                         fi[["size"]], fi[["mtime"]])
[17:37:37.048]                       stop(msg)
[17:37:37.048]                     }
[17:37:37.048]                     invisible(pathname)
[17:37:37.048]                   }
[17:37:37.048]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:37.048]                     rootPath = tempdir()) 
[17:37:37.048]                   {
[17:37:37.048]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:37.048]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:37.048]                       tmpdir = path, fileext = ".rds")
[17:37:37.048]                     save_rds(obj, file)
[17:37:37.048]                   }
[17:37:37.048]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:37.048]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.048]                   {
[17:37:37.048]                     inherits <- base::inherits
[17:37:37.048]                     invokeRestart <- base::invokeRestart
[17:37:37.048]                     is.null <- base::is.null
[17:37:37.048]                     muffled <- FALSE
[17:37:37.048]                     if (inherits(cond, "message")) {
[17:37:37.048]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:37.048]                       if (muffled) 
[17:37:37.048]                         invokeRestart("muffleMessage")
[17:37:37.048]                     }
[17:37:37.048]                     else if (inherits(cond, "warning")) {
[17:37:37.048]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:37.048]                       if (muffled) 
[17:37:37.048]                         invokeRestart("muffleWarning")
[17:37:37.048]                     }
[17:37:37.048]                     else if (inherits(cond, "condition")) {
[17:37:37.048]                       if (!is.null(pattern)) {
[17:37:37.048]                         computeRestarts <- base::computeRestarts
[17:37:37.048]                         grepl <- base::grepl
[17:37:37.048]                         restarts <- computeRestarts(cond)
[17:37:37.048]                         for (restart in restarts) {
[17:37:37.048]                           name <- restart$name
[17:37:37.048]                           if (is.null(name)) 
[17:37:37.048]                             next
[17:37:37.048]                           if (!grepl(pattern, name)) 
[17:37:37.048]                             next
[17:37:37.048]                           invokeRestart(restart)
[17:37:37.048]                           muffled <- TRUE
[17:37:37.048]                           break
[17:37:37.048]                         }
[17:37:37.048]                       }
[17:37:37.048]                     }
[17:37:37.048]                     invisible(muffled)
[17:37:37.048]                   }
[17:37:37.048]                   muffleCondition(cond)
[17:37:37.048]                 })
[17:37:37.048]             }))
[17:37:37.048]             future::FutureResult(value = ...future.value$value, 
[17:37:37.048]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:37.048]                   ...future.rng), globalenv = if (FALSE) 
[17:37:37.048]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:37.048]                     ...future.globalenv.names))
[17:37:37.048]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:37.048]         }, condition = base::local({
[17:37:37.048]             c <- base::c
[17:37:37.048]             inherits <- base::inherits
[17:37:37.048]             invokeRestart <- base::invokeRestart
[17:37:37.048]             length <- base::length
[17:37:37.048]             list <- base::list
[17:37:37.048]             seq.int <- base::seq.int
[17:37:37.048]             signalCondition <- base::signalCondition
[17:37:37.048]             sys.calls <- base::sys.calls
[17:37:37.048]             `[[` <- base::`[[`
[17:37:37.048]             `+` <- base::`+`
[17:37:37.048]             `<<-` <- base::`<<-`
[17:37:37.048]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:37.048]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:37.048]                   3L)]
[17:37:37.048]             }
[17:37:37.048]             function(cond) {
[17:37:37.048]                 is_error <- inherits(cond, "error")
[17:37:37.048]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:37.048]                   NULL)
[17:37:37.048]                 if (is_error) {
[17:37:37.048]                   sessionInformation <- function() {
[17:37:37.048]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:37.048]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:37.048]                       search = base::search(), system = base::Sys.info())
[17:37:37.048]                   }
[17:37:37.048]                   ...future.conditions[[length(...future.conditions) + 
[17:37:37.048]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:37.048]                     cond$call), session = sessionInformation(), 
[17:37:37.048]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:37.048]                   signalCondition(cond)
[17:37:37.048]                 }
[17:37:37.048]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:37.048]                 "immediateCondition"))) {
[17:37:37.048]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:37.048]                   ...future.conditions[[length(...future.conditions) + 
[17:37:37.048]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:37.048]                   if (TRUE && !signal) {
[17:37:37.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.048]                     {
[17:37:37.048]                       inherits <- base::inherits
[17:37:37.048]                       invokeRestart <- base::invokeRestart
[17:37:37.048]                       is.null <- base::is.null
[17:37:37.048]                       muffled <- FALSE
[17:37:37.048]                       if (inherits(cond, "message")) {
[17:37:37.048]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:37.048]                         if (muffled) 
[17:37:37.048]                           invokeRestart("muffleMessage")
[17:37:37.048]                       }
[17:37:37.048]                       else if (inherits(cond, "warning")) {
[17:37:37.048]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:37.048]                         if (muffled) 
[17:37:37.048]                           invokeRestart("muffleWarning")
[17:37:37.048]                       }
[17:37:37.048]                       else if (inherits(cond, "condition")) {
[17:37:37.048]                         if (!is.null(pattern)) {
[17:37:37.048]                           computeRestarts <- base::computeRestarts
[17:37:37.048]                           grepl <- base::grepl
[17:37:37.048]                           restarts <- computeRestarts(cond)
[17:37:37.048]                           for (restart in restarts) {
[17:37:37.048]                             name <- restart$name
[17:37:37.048]                             if (is.null(name)) 
[17:37:37.048]                               next
[17:37:37.048]                             if (!grepl(pattern, name)) 
[17:37:37.048]                               next
[17:37:37.048]                             invokeRestart(restart)
[17:37:37.048]                             muffled <- TRUE
[17:37:37.048]                             break
[17:37:37.048]                           }
[17:37:37.048]                         }
[17:37:37.048]                       }
[17:37:37.048]                       invisible(muffled)
[17:37:37.048]                     }
[17:37:37.048]                     muffleCondition(cond, pattern = "^muffle")
[17:37:37.048]                   }
[17:37:37.048]                 }
[17:37:37.048]                 else {
[17:37:37.048]                   if (TRUE) {
[17:37:37.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.048]                     {
[17:37:37.048]                       inherits <- base::inherits
[17:37:37.048]                       invokeRestart <- base::invokeRestart
[17:37:37.048]                       is.null <- base::is.null
[17:37:37.048]                       muffled <- FALSE
[17:37:37.048]                       if (inherits(cond, "message")) {
[17:37:37.048]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:37.048]                         if (muffled) 
[17:37:37.048]                           invokeRestart("muffleMessage")
[17:37:37.048]                       }
[17:37:37.048]                       else if (inherits(cond, "warning")) {
[17:37:37.048]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:37.048]                         if (muffled) 
[17:37:37.048]                           invokeRestart("muffleWarning")
[17:37:37.048]                       }
[17:37:37.048]                       else if (inherits(cond, "condition")) {
[17:37:37.048]                         if (!is.null(pattern)) {
[17:37:37.048]                           computeRestarts <- base::computeRestarts
[17:37:37.048]                           grepl <- base::grepl
[17:37:37.048]                           restarts <- computeRestarts(cond)
[17:37:37.048]                           for (restart in restarts) {
[17:37:37.048]                             name <- restart$name
[17:37:37.048]                             if (is.null(name)) 
[17:37:37.048]                               next
[17:37:37.048]                             if (!grepl(pattern, name)) 
[17:37:37.048]                               next
[17:37:37.048]                             invokeRestart(restart)
[17:37:37.048]                             muffled <- TRUE
[17:37:37.048]                             break
[17:37:37.048]                           }
[17:37:37.048]                         }
[17:37:37.048]                       }
[17:37:37.048]                       invisible(muffled)
[17:37:37.048]                     }
[17:37:37.048]                     muffleCondition(cond, pattern = "^muffle")
[17:37:37.048]                   }
[17:37:37.048]                 }
[17:37:37.048]             }
[17:37:37.048]         }))
[17:37:37.048]     }, error = function(ex) {
[17:37:37.048]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:37.048]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:37.048]                 ...future.rng), started = ...future.startTime, 
[17:37:37.048]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:37.048]             version = "1.8"), class = "FutureResult")
[17:37:37.048]     }, finally = {
[17:37:37.048]         if (!identical(...future.workdir, getwd())) 
[17:37:37.048]             setwd(...future.workdir)
[17:37:37.048]         {
[17:37:37.048]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:37.048]                 ...future.oldOptions$nwarnings <- NULL
[17:37:37.048]             }
[17:37:37.048]             base::options(...future.oldOptions)
[17:37:37.048]             if (.Platform$OS.type == "windows") {
[17:37:37.048]                 old_names <- names(...future.oldEnvVars)
[17:37:37.048]                 envs <- base::Sys.getenv()
[17:37:37.048]                 names <- names(envs)
[17:37:37.048]                 common <- intersect(names, old_names)
[17:37:37.048]                 added <- setdiff(names, old_names)
[17:37:37.048]                 removed <- setdiff(old_names, names)
[17:37:37.048]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:37.048]                   envs[common]]
[17:37:37.048]                 NAMES <- toupper(changed)
[17:37:37.048]                 args <- list()
[17:37:37.048]                 for (kk in seq_along(NAMES)) {
[17:37:37.048]                   name <- changed[[kk]]
[17:37:37.048]                   NAME <- NAMES[[kk]]
[17:37:37.048]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.048]                     next
[17:37:37.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:37.048]                 }
[17:37:37.048]                 NAMES <- toupper(added)
[17:37:37.048]                 for (kk in seq_along(NAMES)) {
[17:37:37.048]                   name <- added[[kk]]
[17:37:37.048]                   NAME <- NAMES[[kk]]
[17:37:37.048]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.048]                     next
[17:37:37.048]                   args[[name]] <- ""
[17:37:37.048]                 }
[17:37:37.048]                 NAMES <- toupper(removed)
[17:37:37.048]                 for (kk in seq_along(NAMES)) {
[17:37:37.048]                   name <- removed[[kk]]
[17:37:37.048]                   NAME <- NAMES[[kk]]
[17:37:37.048]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.048]                     next
[17:37:37.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:37.048]                 }
[17:37:37.048]                 if (length(args) > 0) 
[17:37:37.048]                   base::do.call(base::Sys.setenv, args = args)
[17:37:37.048]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:37.048]             }
[17:37:37.048]             else {
[17:37:37.048]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:37.048]             }
[17:37:37.048]             {
[17:37:37.048]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:37.048]                   0L) {
[17:37:37.048]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:37.048]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:37.048]                   base::options(opts)
[17:37:37.048]                 }
[17:37:37.048]                 {
[17:37:37.048]                   {
[17:37:37.048]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:37.048]                     NULL
[17:37:37.048]                   }
[17:37:37.048]                   options(future.plan = NULL)
[17:37:37.048]                   if (is.na(NA_character_)) 
[17:37:37.048]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:37.048]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:37.048]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:37.048]                     .init = FALSE)
[17:37:37.048]                 }
[17:37:37.048]             }
[17:37:37.048]         }
[17:37:37.048]     })
[17:37:37.048]     if (TRUE) {
[17:37:37.048]         base::sink(type = "output", split = FALSE)
[17:37:37.048]         if (TRUE) {
[17:37:37.048]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:37.048]         }
[17:37:37.048]         else {
[17:37:37.048]             ...future.result["stdout"] <- base::list(NULL)
[17:37:37.048]         }
[17:37:37.048]         base::close(...future.stdout)
[17:37:37.048]         ...future.stdout <- NULL
[17:37:37.048]     }
[17:37:37.048]     ...future.result$conditions <- ...future.conditions
[17:37:37.048]     ...future.result$finished <- base::Sys.time()
[17:37:37.048]     ...future.result
[17:37:37.048] }
[17:37:37.051] assign_globals() ...
[17:37:37.051] List of 5
[17:37:37.051]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[17:37:37.051]  $ MoreArgs                 :List of 1
[17:37:37.051]   ..$ min: num 1
[17:37:37.051]  $ ...future.elements_ii    :List of 2
[17:37:37.051]   ..$ n  :List of 2
[17:37:37.051]   .. ..$ : int 3
[17:37:37.051]   .. ..$ : int 4
[17:37:37.051]   ..$ max:List of 2
[17:37:37.051]   .. ..$ : int 4
[17:37:37.051]   .. ..$ : int 5
[17:37:37.051]  $ ...future.seeds_ii       :List of 2
[17:37:37.051]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[17:37:37.051]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[17:37:37.051]  $ ...future.globals.maxSize: NULL
[17:37:37.051]  - attr(*, "where")=List of 5
[17:37:37.051]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:37.051]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:37.051]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:37.051]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:37.051]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:37.051]  - attr(*, "resolved")= logi FALSE
[17:37:37.051]  - attr(*, "total_size")= num 2528
[17:37:37.051]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:37.051]  - attr(*, "already-done")= logi TRUE
[17:37:37.062] - copied ‘...future.FUN’ to environment
[17:37:37.062] - copied ‘MoreArgs’ to environment
[17:37:37.063] - copied ‘...future.elements_ii’ to environment
[17:37:37.063] - copied ‘...future.seeds_ii’ to environment
[17:37:37.063] - copied ‘...future.globals.maxSize’ to environment
[17:37:37.063] assign_globals() ... done
[17:37:37.063] requestCore(): workers = 2
[17:37:37.066] MulticoreFuture started
[17:37:37.066] - Launch lazy future ... done
[17:37:37.066] run() for ‘MulticoreFuture’ ... done
[17:37:37.067] Created future:
[17:37:37.067] plan(): Setting new future strategy stack:
[17:37:37.067] List of future strategies:
[17:37:37.067] 1. sequential:
[17:37:37.067]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:37.067]    - tweaked: FALSE
[17:37:37.067]    - call: NULL
[17:37:37.068] plan(): nbrOfWorkers() = 1
[17:37:37.071] plan(): Setting new future strategy stack:
[17:37:37.071] List of future strategies:
[17:37:37.071] 1. multicore:
[17:37:37.071]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:37.071]    - tweaked: FALSE
[17:37:37.071]    - call: plan(strategy)
[17:37:37.076] plan(): nbrOfWorkers() = 2
[17:37:37.067] MulticoreFuture:
[17:37:37.067] Label: ‘future_mapply-2’
[17:37:37.067] Expression:
[17:37:37.067] {
[17:37:37.067]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:37.067]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:37.067]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:37.067]         on.exit(options(oopts), add = TRUE)
[17:37:37.067]     }
[17:37:37.067]     {
[17:37:37.067]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:37:37.067]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:37:37.067]                 inherits = FALSE)
[17:37:37.067]             ...future.FUN(...)
[17:37:37.067]         }
[17:37:37.067]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:37:37.067]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:37:37.067]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:37.067]         do.call(mapply, args = args)
[17:37:37.067]     }
[17:37:37.067] }
[17:37:37.067] Lazy evaluation: FALSE
[17:37:37.067] Asynchronous evaluation: TRUE
[17:37:37.067] Local evaluation: TRUE
[17:37:37.067] Environment: R_GlobalEnv
[17:37:37.067] Capture standard output: TRUE
[17:37:37.067] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:37.067] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:37.067] Packages: 1 packages (‘stats’)
[17:37:37.067] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:37:37.067] Resolved: TRUE
[17:37:37.067] Value: <not collected>
[17:37:37.067] Conditions captured: <none>
[17:37:37.067] Early signaling: FALSE
[17:37:37.067] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:37.067] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:37.077] Chunk #2 of 2 ... DONE
[17:37:37.077] Launching 2 futures (chunks) ... DONE
[17:37:37.078] Resolving 2 futures (chunks) ...
[17:37:37.078] resolve() on list ...
[17:37:37.078]  recursive: 0
[17:37:37.078]  length: 2
[17:37:37.078] 
[17:37:37.078] Future #1
[17:37:37.079] result() for MulticoreFuture ...
[17:37:37.079] result() for MulticoreFuture ...
[17:37:37.080] result() for MulticoreFuture ... done
[17:37:37.080] result() for MulticoreFuture ... done
[17:37:37.080] result() for MulticoreFuture ...
[17:37:37.080] result() for MulticoreFuture ... done
[17:37:37.080] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:37:37.080] - nx: 2
[17:37:37.080] - relay: TRUE
[17:37:37.081] - stdout: TRUE
[17:37:37.081] - signal: TRUE
[17:37:37.081] - resignal: FALSE
[17:37:37.081] - force: TRUE
[17:37:37.081] - relayed: [n=2] FALSE, FALSE
[17:37:37.081] - queued futures: [n=2] FALSE, FALSE
[17:37:37.082]  - until=1
[17:37:37.082]  - relaying element #1
[17:37:37.082] result() for MulticoreFuture ...
[17:37:37.082] result() for MulticoreFuture ... done
[17:37:37.082] result() for MulticoreFuture ...
[17:37:37.082] result() for MulticoreFuture ... done
[17:37:37.083] result() for MulticoreFuture ...
[17:37:37.083] result() for MulticoreFuture ... done
[17:37:37.083] result() for MulticoreFuture ...
[17:37:37.083] result() for MulticoreFuture ... done
[17:37:37.083] - relayed: [n=2] TRUE, FALSE
[17:37:37.083] - queued futures: [n=2] TRUE, FALSE
[17:37:37.083] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:37:37.084]  length: 1 (resolved future 1)
[17:37:37.084] Future #2
[17:37:37.084] result() for MulticoreFuture ...
[17:37:37.085] result() for MulticoreFuture ...
[17:37:37.085] result() for MulticoreFuture ... done
[17:37:37.085] result() for MulticoreFuture ... done
[17:37:37.085] result() for MulticoreFuture ...
[17:37:37.086] result() for MulticoreFuture ... done
[17:37:37.086] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:37:37.086] - nx: 2
[17:37:37.086] - relay: TRUE
[17:37:37.086] - stdout: TRUE
[17:37:37.087] - signal: TRUE
[17:37:37.087] - resignal: FALSE
[17:37:37.087] - force: TRUE
[17:37:37.087] - relayed: [n=2] TRUE, FALSE
[17:37:37.087] - queued futures: [n=2] TRUE, FALSE
[17:37:37.087]  - until=2
[17:37:37.088]  - relaying element #2
[17:37:37.088] result() for MulticoreFuture ...
[17:37:37.088] result() for MulticoreFuture ... done
[17:37:37.088] result() for MulticoreFuture ...
[17:37:37.088] result() for MulticoreFuture ... done
[17:37:37.088] result() for MulticoreFuture ...
[17:37:37.089] result() for MulticoreFuture ... done
[17:37:37.089] result() for MulticoreFuture ...
[17:37:37.089] result() for MulticoreFuture ... done
[17:37:37.089] - relayed: [n=2] TRUE, TRUE
[17:37:37.089] - queued futures: [n=2] TRUE, TRUE
[17:37:37.092] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:37:37.093]  length: 0 (resolved future 2)
[17:37:37.093] Relaying remaining futures
[17:37:37.093] signalConditionsASAP(NULL, pos=0) ...
[17:37:37.093] - nx: 2
[17:37:37.093] - relay: TRUE
[17:37:37.094] - stdout: TRUE
[17:37:37.094] - signal: TRUE
[17:37:37.094] - resignal: FALSE
[17:37:37.094] - force: TRUE
[17:37:37.094] - relayed: [n=2] TRUE, TRUE
[17:37:37.094] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:37.095] - relayed: [n=2] TRUE, TRUE
[17:37:37.095] - queued futures: [n=2] TRUE, TRUE
[17:37:37.095] signalConditionsASAP(NULL, pos=0) ... done
[17:37:37.095] resolve() on list ... DONE
[17:37:37.095] result() for MulticoreFuture ...
[17:37:37.095] result() for MulticoreFuture ... done
[17:37:37.096] result() for MulticoreFuture ...
[17:37:37.096] result() for MulticoreFuture ... done
[17:37:37.096] result() for MulticoreFuture ...
[17:37:37.096] result() for MulticoreFuture ... done
[17:37:37.096] result() for MulticoreFuture ...
[17:37:37.096] result() for MulticoreFuture ... done
[17:37:37.097]  - Number of value chunks collected: 2
[17:37:37.097] Resolving 2 futures (chunks) ... DONE
[17:37:37.097] Reducing values from 2 chunks ...
[17:37:37.097]  - Number of values collected after concatenation: 4
[17:37:37.097]  - Number of values expected: 4
[17:37:37.097] Reducing values from 2 chunks ... DONE
[17:37:37.097] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[17:37:37.098] future_mapply() ...
[17:37:37.103] Number of chunks: 2
[17:37:37.103] getGlobalsAndPackagesXApply() ...
[17:37:37.103]  - future.globals: TRUE
[17:37:37.104] getGlobalsAndPackages() ...
[17:37:37.104] Searching for globals...
[17:37:37.105] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:37:37.106] Searching for globals ... DONE
[17:37:37.106] Resolving globals: FALSE
[17:37:37.106] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[17:37:37.107] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[17:37:37.107] - globals: [1] ‘FUN’
[17:37:37.107] - packages: [1] ‘stats’
[17:37:37.107] getGlobalsAndPackages() ... DONE
[17:37:37.107]  - globals found/used: [n=1] ‘FUN’
[17:37:37.107]  - needed namespaces: [n=1] ‘stats’
[17:37:37.107] Finding globals ... DONE
[17:37:37.108] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:37.108] List of 2
[17:37:37.108]  $ ...future.FUN:function (x, w, ...)  
[17:37:37.108]  $ MoreArgs     : NULL
[17:37:37.108]  - attr(*, "where")=List of 2
[17:37:37.108]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:37.108]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:37.108]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:37.108]  - attr(*, "resolved")= logi FALSE
[17:37:37.108]  - attr(*, "total_size")= num NA
[17:37:37.111] Packages to be attached in all futures: [n=1] ‘stats’
[17:37:37.111] getGlobalsAndPackagesXApply() ... DONE
[17:37:37.111] Number of futures (= number of chunks): 2
[17:37:37.111] Launching 2 futures (chunks) ...
[17:37:37.111] Chunk #1 of 2 ...
[17:37:37.111]  - Finding globals in '...' for chunk #1 ...
[17:37:37.111] getGlobalsAndPackages() ...
[17:37:37.112] Searching for globals...
[17:37:37.112] 
[17:37:37.112] Searching for globals ... DONE
[17:37:37.112] - globals: [0] <none>
[17:37:37.112] getGlobalsAndPackages() ... DONE
[17:37:37.112]    + additional globals found: [n=0] 
[17:37:37.112]    + additional namespaces needed: [n=0] 
[17:37:37.112]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:37.113]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:37.113]  - seeds: <none>
[17:37:37.113]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:37.113] getGlobalsAndPackages() ...
[17:37:37.113] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:37.113] Resolving globals: FALSE
[17:37:37.114] The total size of the 5 globals is 2.07 KiB (2120 bytes)
[17:37:37.114] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.07 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (704 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:37.114] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:37.114] - packages: [1] ‘stats’
[17:37:37.115] getGlobalsAndPackages() ... DONE
[17:37:37.115] run() for ‘Future’ ...
[17:37:37.115] - state: ‘created’
[17:37:37.115] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:37.119] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:37.119] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:37.119]   - Field: ‘label’
[17:37:37.119]   - Field: ‘local’
[17:37:37.120]   - Field: ‘owner’
[17:37:37.120]   - Field: ‘envir’
[17:37:37.120]   - Field: ‘workers’
[17:37:37.120]   - Field: ‘packages’
[17:37:37.120]   - Field: ‘gc’
[17:37:37.120]   - Field: ‘job’
[17:37:37.120]   - Field: ‘conditions’
[17:37:37.120]   - Field: ‘expr’
[17:37:37.120]   - Field: ‘uuid’
[17:37:37.120]   - Field: ‘seed’
[17:37:37.121]   - Field: ‘version’
[17:37:37.121]   - Field: ‘result’
[17:37:37.121]   - Field: ‘asynchronous’
[17:37:37.121]   - Field: ‘calls’
[17:37:37.121]   - Field: ‘globals’
[17:37:37.121]   - Field: ‘stdout’
[17:37:37.121]   - Field: ‘earlySignal’
[17:37:37.121]   - Field: ‘lazy’
[17:37:37.121]   - Field: ‘state’
[17:37:37.121] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:37.122] - Launch lazy future ...
[17:37:37.125] Packages needed by the future expression (n = 1): ‘stats’
[17:37:37.125] Packages needed by future strategies (n = 0): <none>
[17:37:37.125] {
[17:37:37.125]     {
[17:37:37.125]         {
[17:37:37.125]             ...future.startTime <- base::Sys.time()
[17:37:37.125]             {
[17:37:37.125]                 {
[17:37:37.125]                   {
[17:37:37.125]                     {
[17:37:37.125]                       {
[17:37:37.125]                         base::local({
[17:37:37.125]                           has_future <- base::requireNamespace("future", 
[17:37:37.125]                             quietly = TRUE)
[17:37:37.125]                           if (has_future) {
[17:37:37.125]                             ns <- base::getNamespace("future")
[17:37:37.125]                             version <- ns[[".package"]][["version"]]
[17:37:37.125]                             if (is.null(version)) 
[17:37:37.125]                               version <- utils::packageVersion("future")
[17:37:37.125]                           }
[17:37:37.125]                           else {
[17:37:37.125]                             version <- NULL
[17:37:37.125]                           }
[17:37:37.125]                           if (!has_future || version < "1.8.0") {
[17:37:37.125]                             info <- base::c(r_version = base::gsub("R version ", 
[17:37:37.125]                               "", base::R.version$version.string), 
[17:37:37.125]                               platform = base::sprintf("%s (%s-bit)", 
[17:37:37.125]                                 base::R.version$platform, 8 * 
[17:37:37.125]                                   base::.Machine$sizeof.pointer), 
[17:37:37.125]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:37.125]                                 "release", "version")], collapse = " "), 
[17:37:37.125]                               hostname = base::Sys.info()[["nodename"]])
[17:37:37.125]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:37:37.125]                               info)
[17:37:37.125]                             info <- base::paste(info, collapse = "; ")
[17:37:37.125]                             if (!has_future) {
[17:37:37.125]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:37.125]                                 info)
[17:37:37.125]                             }
[17:37:37.125]                             else {
[17:37:37.125]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:37.125]                                 info, version)
[17:37:37.125]                             }
[17:37:37.125]                             base::stop(msg)
[17:37:37.125]                           }
[17:37:37.125]                         })
[17:37:37.125]                       }
[17:37:37.125]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:37.125]                       base::options(mc.cores = 1L)
[17:37:37.125]                     }
[17:37:37.125]                     base::local({
[17:37:37.125]                       for (pkg in "stats") {
[17:37:37.125]                         base::loadNamespace(pkg)
[17:37:37.125]                         base::library(pkg, character.only = TRUE)
[17:37:37.125]                       }
[17:37:37.125]                     })
[17:37:37.125]                   }
[17:37:37.125]                   ...future.strategy.old <- future::plan("list")
[17:37:37.125]                   options(future.plan = NULL)
[17:37:37.125]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:37.125]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:37.125]                 }
[17:37:37.125]                 ...future.workdir <- getwd()
[17:37:37.125]             }
[17:37:37.125]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:37.125]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:37.125]         }
[17:37:37.125]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:37.125]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:37.125]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:37.125]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:37.125]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:37.125]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:37.125]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:37.125]             base::names(...future.oldOptions))
[17:37:37.125]     }
[17:37:37.125]     if (FALSE) {
[17:37:37.125]     }
[17:37:37.125]     else {
[17:37:37.125]         if (TRUE) {
[17:37:37.125]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:37.125]                 open = "w")
[17:37:37.125]         }
[17:37:37.125]         else {
[17:37:37.125]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:37.125]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:37.125]         }
[17:37:37.125]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:37.125]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:37.125]             base::sink(type = "output", split = FALSE)
[17:37:37.125]             base::close(...future.stdout)
[17:37:37.125]         }, add = TRUE)
[17:37:37.125]     }
[17:37:37.125]     ...future.frame <- base::sys.nframe()
[17:37:37.125]     ...future.conditions <- base::list()
[17:37:37.125]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:37.125]     if (FALSE) {
[17:37:37.125]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:37.125]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:37.125]     }
[17:37:37.125]     ...future.result <- base::tryCatch({
[17:37:37.125]         base::withCallingHandlers({
[17:37:37.125]             ...future.value <- base::withVisible(base::local({
[17:37:37.125]                 withCallingHandlers({
[17:37:37.125]                   {
[17:37:37.125]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:37.125]                     if (!identical(...future.globals.maxSize.org, 
[17:37:37.125]                       ...future.globals.maxSize)) {
[17:37:37.125]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:37.125]                       on.exit(options(oopts), add = TRUE)
[17:37:37.125]                     }
[17:37:37.125]                     {
[17:37:37.125]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:37.125]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:37.125]                         USE.NAMES = FALSE)
[17:37:37.125]                       do.call(mapply, args = args)
[17:37:37.125]                     }
[17:37:37.125]                   }
[17:37:37.125]                 }, immediateCondition = function(cond) {
[17:37:37.125]                   save_rds <- function (object, pathname, ...) 
[17:37:37.125]                   {
[17:37:37.125]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:37.125]                     if (file_test("-f", pathname_tmp)) {
[17:37:37.125]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.125]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:37.125]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.125]                         fi_tmp[["mtime"]])
[17:37:37.125]                     }
[17:37:37.125]                     tryCatch({
[17:37:37.125]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:37.125]                     }, error = function(ex) {
[17:37:37.125]                       msg <- conditionMessage(ex)
[17:37:37.125]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.125]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:37.125]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.125]                         fi_tmp[["mtime"]], msg)
[17:37:37.125]                       ex$message <- msg
[17:37:37.125]                       stop(ex)
[17:37:37.125]                     })
[17:37:37.125]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:37.125]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:37.125]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:37.125]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.125]                       fi <- file.info(pathname)
[17:37:37.125]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:37.125]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.125]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:37.125]                         fi[["size"]], fi[["mtime"]])
[17:37:37.125]                       stop(msg)
[17:37:37.125]                     }
[17:37:37.125]                     invisible(pathname)
[17:37:37.125]                   }
[17:37:37.125]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:37.125]                     rootPath = tempdir()) 
[17:37:37.125]                   {
[17:37:37.125]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:37.125]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:37.125]                       tmpdir = path, fileext = ".rds")
[17:37:37.125]                     save_rds(obj, file)
[17:37:37.125]                   }
[17:37:37.125]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:37.125]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.125]                   {
[17:37:37.125]                     inherits <- base::inherits
[17:37:37.125]                     invokeRestart <- base::invokeRestart
[17:37:37.125]                     is.null <- base::is.null
[17:37:37.125]                     muffled <- FALSE
[17:37:37.125]                     if (inherits(cond, "message")) {
[17:37:37.125]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:37.125]                       if (muffled) 
[17:37:37.125]                         invokeRestart("muffleMessage")
[17:37:37.125]                     }
[17:37:37.125]                     else if (inherits(cond, "warning")) {
[17:37:37.125]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:37.125]                       if (muffled) 
[17:37:37.125]                         invokeRestart("muffleWarning")
[17:37:37.125]                     }
[17:37:37.125]                     else if (inherits(cond, "condition")) {
[17:37:37.125]                       if (!is.null(pattern)) {
[17:37:37.125]                         computeRestarts <- base::computeRestarts
[17:37:37.125]                         grepl <- base::grepl
[17:37:37.125]                         restarts <- computeRestarts(cond)
[17:37:37.125]                         for (restart in restarts) {
[17:37:37.125]                           name <- restart$name
[17:37:37.125]                           if (is.null(name)) 
[17:37:37.125]                             next
[17:37:37.125]                           if (!grepl(pattern, name)) 
[17:37:37.125]                             next
[17:37:37.125]                           invokeRestart(restart)
[17:37:37.125]                           muffled <- TRUE
[17:37:37.125]                           break
[17:37:37.125]                         }
[17:37:37.125]                       }
[17:37:37.125]                     }
[17:37:37.125]                     invisible(muffled)
[17:37:37.125]                   }
[17:37:37.125]                   muffleCondition(cond)
[17:37:37.125]                 })
[17:37:37.125]             }))
[17:37:37.125]             future::FutureResult(value = ...future.value$value, 
[17:37:37.125]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:37.125]                   ...future.rng), globalenv = if (FALSE) 
[17:37:37.125]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:37.125]                     ...future.globalenv.names))
[17:37:37.125]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:37.125]         }, condition = base::local({
[17:37:37.125]             c <- base::c
[17:37:37.125]             inherits <- base::inherits
[17:37:37.125]             invokeRestart <- base::invokeRestart
[17:37:37.125]             length <- base::length
[17:37:37.125]             list <- base::list
[17:37:37.125]             seq.int <- base::seq.int
[17:37:37.125]             signalCondition <- base::signalCondition
[17:37:37.125]             sys.calls <- base::sys.calls
[17:37:37.125]             `[[` <- base::`[[`
[17:37:37.125]             `+` <- base::`+`
[17:37:37.125]             `<<-` <- base::`<<-`
[17:37:37.125]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:37.125]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:37.125]                   3L)]
[17:37:37.125]             }
[17:37:37.125]             function(cond) {
[17:37:37.125]                 is_error <- inherits(cond, "error")
[17:37:37.125]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:37.125]                   NULL)
[17:37:37.125]                 if (is_error) {
[17:37:37.125]                   sessionInformation <- function() {
[17:37:37.125]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:37.125]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:37.125]                       search = base::search(), system = base::Sys.info())
[17:37:37.125]                   }
[17:37:37.125]                   ...future.conditions[[length(...future.conditions) + 
[17:37:37.125]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:37.125]                     cond$call), session = sessionInformation(), 
[17:37:37.125]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:37.125]                   signalCondition(cond)
[17:37:37.125]                 }
[17:37:37.125]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:37.125]                 "immediateCondition"))) {
[17:37:37.125]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:37.125]                   ...future.conditions[[length(...future.conditions) + 
[17:37:37.125]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:37.125]                   if (TRUE && !signal) {
[17:37:37.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.125]                     {
[17:37:37.125]                       inherits <- base::inherits
[17:37:37.125]                       invokeRestart <- base::invokeRestart
[17:37:37.125]                       is.null <- base::is.null
[17:37:37.125]                       muffled <- FALSE
[17:37:37.125]                       if (inherits(cond, "message")) {
[17:37:37.125]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:37.125]                         if (muffled) 
[17:37:37.125]                           invokeRestart("muffleMessage")
[17:37:37.125]                       }
[17:37:37.125]                       else if (inherits(cond, "warning")) {
[17:37:37.125]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:37.125]                         if (muffled) 
[17:37:37.125]                           invokeRestart("muffleWarning")
[17:37:37.125]                       }
[17:37:37.125]                       else if (inherits(cond, "condition")) {
[17:37:37.125]                         if (!is.null(pattern)) {
[17:37:37.125]                           computeRestarts <- base::computeRestarts
[17:37:37.125]                           grepl <- base::grepl
[17:37:37.125]                           restarts <- computeRestarts(cond)
[17:37:37.125]                           for (restart in restarts) {
[17:37:37.125]                             name <- restart$name
[17:37:37.125]                             if (is.null(name)) 
[17:37:37.125]                               next
[17:37:37.125]                             if (!grepl(pattern, name)) 
[17:37:37.125]                               next
[17:37:37.125]                             invokeRestart(restart)
[17:37:37.125]                             muffled <- TRUE
[17:37:37.125]                             break
[17:37:37.125]                           }
[17:37:37.125]                         }
[17:37:37.125]                       }
[17:37:37.125]                       invisible(muffled)
[17:37:37.125]                     }
[17:37:37.125]                     muffleCondition(cond, pattern = "^muffle")
[17:37:37.125]                   }
[17:37:37.125]                 }
[17:37:37.125]                 else {
[17:37:37.125]                   if (TRUE) {
[17:37:37.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.125]                     {
[17:37:37.125]                       inherits <- base::inherits
[17:37:37.125]                       invokeRestart <- base::invokeRestart
[17:37:37.125]                       is.null <- base::is.null
[17:37:37.125]                       muffled <- FALSE
[17:37:37.125]                       if (inherits(cond, "message")) {
[17:37:37.125]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:37.125]                         if (muffled) 
[17:37:37.125]                           invokeRestart("muffleMessage")
[17:37:37.125]                       }
[17:37:37.125]                       else if (inherits(cond, "warning")) {
[17:37:37.125]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:37.125]                         if (muffled) 
[17:37:37.125]                           invokeRestart("muffleWarning")
[17:37:37.125]                       }
[17:37:37.125]                       else if (inherits(cond, "condition")) {
[17:37:37.125]                         if (!is.null(pattern)) {
[17:37:37.125]                           computeRestarts <- base::computeRestarts
[17:37:37.125]                           grepl <- base::grepl
[17:37:37.125]                           restarts <- computeRestarts(cond)
[17:37:37.125]                           for (restart in restarts) {
[17:37:37.125]                             name <- restart$name
[17:37:37.125]                             if (is.null(name)) 
[17:37:37.125]                               next
[17:37:37.125]                             if (!grepl(pattern, name)) 
[17:37:37.125]                               next
[17:37:37.125]                             invokeRestart(restart)
[17:37:37.125]                             muffled <- TRUE
[17:37:37.125]                             break
[17:37:37.125]                           }
[17:37:37.125]                         }
[17:37:37.125]                       }
[17:37:37.125]                       invisible(muffled)
[17:37:37.125]                     }
[17:37:37.125]                     muffleCondition(cond, pattern = "^muffle")
[17:37:37.125]                   }
[17:37:37.125]                 }
[17:37:37.125]             }
[17:37:37.125]         }))
[17:37:37.125]     }, error = function(ex) {
[17:37:37.125]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:37.125]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:37.125]                 ...future.rng), started = ...future.startTime, 
[17:37:37.125]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:37.125]             version = "1.8"), class = "FutureResult")
[17:37:37.125]     }, finally = {
[17:37:37.125]         if (!identical(...future.workdir, getwd())) 
[17:37:37.125]             setwd(...future.workdir)
[17:37:37.125]         {
[17:37:37.125]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:37.125]                 ...future.oldOptions$nwarnings <- NULL
[17:37:37.125]             }
[17:37:37.125]             base::options(...future.oldOptions)
[17:37:37.125]             if (.Platform$OS.type == "windows") {
[17:37:37.125]                 old_names <- names(...future.oldEnvVars)
[17:37:37.125]                 envs <- base::Sys.getenv()
[17:37:37.125]                 names <- names(envs)
[17:37:37.125]                 common <- intersect(names, old_names)
[17:37:37.125]                 added <- setdiff(names, old_names)
[17:37:37.125]                 removed <- setdiff(old_names, names)
[17:37:37.125]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:37.125]                   envs[common]]
[17:37:37.125]                 NAMES <- toupper(changed)
[17:37:37.125]                 args <- list()
[17:37:37.125]                 for (kk in seq_along(NAMES)) {
[17:37:37.125]                   name <- changed[[kk]]
[17:37:37.125]                   NAME <- NAMES[[kk]]
[17:37:37.125]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.125]                     next
[17:37:37.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:37.125]                 }
[17:37:37.125]                 NAMES <- toupper(added)
[17:37:37.125]                 for (kk in seq_along(NAMES)) {
[17:37:37.125]                   name <- added[[kk]]
[17:37:37.125]                   NAME <- NAMES[[kk]]
[17:37:37.125]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.125]                     next
[17:37:37.125]                   args[[name]] <- ""
[17:37:37.125]                 }
[17:37:37.125]                 NAMES <- toupper(removed)
[17:37:37.125]                 for (kk in seq_along(NAMES)) {
[17:37:37.125]                   name <- removed[[kk]]
[17:37:37.125]                   NAME <- NAMES[[kk]]
[17:37:37.125]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.125]                     next
[17:37:37.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:37.125]                 }
[17:37:37.125]                 if (length(args) > 0) 
[17:37:37.125]                   base::do.call(base::Sys.setenv, args = args)
[17:37:37.125]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:37.125]             }
[17:37:37.125]             else {
[17:37:37.125]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:37.125]             }
[17:37:37.125]             {
[17:37:37.125]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:37.125]                   0L) {
[17:37:37.125]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:37.125]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:37.125]                   base::options(opts)
[17:37:37.125]                 }
[17:37:37.125]                 {
[17:37:37.125]                   {
[17:37:37.125]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:37.125]                     NULL
[17:37:37.125]                   }
[17:37:37.125]                   options(future.plan = NULL)
[17:37:37.125]                   if (is.na(NA_character_)) 
[17:37:37.125]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:37.125]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:37.125]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:37.125]                     .init = FALSE)
[17:37:37.125]                 }
[17:37:37.125]             }
[17:37:37.125]         }
[17:37:37.125]     })
[17:37:37.125]     if (TRUE) {
[17:37:37.125]         base::sink(type = "output", split = FALSE)
[17:37:37.125]         if (TRUE) {
[17:37:37.125]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:37.125]         }
[17:37:37.125]         else {
[17:37:37.125]             ...future.result["stdout"] <- base::list(NULL)
[17:37:37.125]         }
[17:37:37.125]         base::close(...future.stdout)
[17:37:37.125]         ...future.stdout <- NULL
[17:37:37.125]     }
[17:37:37.125]     ...future.result$conditions <- ...future.conditions
[17:37:37.125]     ...future.result$finished <- base::Sys.time()
[17:37:37.125]     ...future.result
[17:37:37.125] }
[17:37:37.128] assign_globals() ...
[17:37:37.128] List of 5
[17:37:37.128]  $ ...future.FUN            :function (x, w, ...)  
[17:37:37.128]  $ MoreArgs                 : NULL
[17:37:37.128]  $ ...future.elements_ii    :List of 2
[17:37:37.128]   ..$ :List of 2
[17:37:37.128]   .. ..$ : num [1:10] 0.257 0.307 0.242 0.355 0.901 ...
[17:37:37.128]   .. ..$ : num [1:10] 0.941 0.9498 0.837 0.0622 0.5051 ...
[17:37:37.128]   ..$ :List of 2
[17:37:37.128]   .. ..$ : num [1:10] 5 5 3 7 8 8 4 8 7 4
[17:37:37.128]   .. ..$ : num [1:10] 5 7 4 7 5 5 2 4 2 9
[17:37:37.128]  $ ...future.seeds_ii       : NULL
[17:37:37.128]  $ ...future.globals.maxSize: NULL
[17:37:37.128]  - attr(*, "where")=List of 5
[17:37:37.128]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:37.128]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:37.128]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:37.128]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:37.128]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:37.128]  - attr(*, "resolved")= logi FALSE
[17:37:37.128]  - attr(*, "total_size")= num 2120
[17:37:37.128]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:37.128]  - attr(*, "already-done")= logi TRUE
[17:37:37.135] - copied ‘...future.FUN’ to environment
[17:37:37.135] - copied ‘MoreArgs’ to environment
[17:37:37.135] - copied ‘...future.elements_ii’ to environment
[17:37:37.135] - copied ‘...future.seeds_ii’ to environment
[17:37:37.135] - copied ‘...future.globals.maxSize’ to environment
[17:37:37.136] assign_globals() ... done
[17:37:37.136] requestCore(): workers = 2
[17:37:37.138] MulticoreFuture started
[17:37:37.139] - Launch lazy future ... done
[17:37:37.139] run() for ‘MulticoreFuture’ ... done
[17:37:37.139] Created future:
[17:37:37.140] plan(): Setting new future strategy stack:
[17:37:37.140] List of future strategies:
[17:37:37.140] 1. sequential:
[17:37:37.140]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:37.140]    - tweaked: FALSE
[17:37:37.140]    - call: NULL
[17:37:37.141] plan(): nbrOfWorkers() = 1
[17:37:37.143] plan(): Setting new future strategy stack:
[17:37:37.144] List of future strategies:
[17:37:37.144] 1. multicore:
[17:37:37.144]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:37.144]    - tweaked: FALSE
[17:37:37.144]    - call: plan(strategy)
[17:37:37.149] plan(): nbrOfWorkers() = 2
[17:37:37.139] MulticoreFuture:
[17:37:37.139] Label: ‘future_Map-1’
[17:37:37.139] Expression:
[17:37:37.139] {
[17:37:37.139]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:37.139]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:37.139]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:37.139]         on.exit(options(oopts), add = TRUE)
[17:37:37.139]     }
[17:37:37.139]     {
[17:37:37.139]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:37.139]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:37.139]         do.call(mapply, args = args)
[17:37:37.139]     }
[17:37:37.139] }
[17:37:37.139] Lazy evaluation: FALSE
[17:37:37.139] Asynchronous evaluation: TRUE
[17:37:37.139] Local evaluation: TRUE
[17:37:37.139] Environment: R_GlobalEnv
[17:37:37.139] Capture standard output: TRUE
[17:37:37.139] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:37.139] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 704 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:37.139] Packages: 1 packages (‘stats’)
[17:37:37.139] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:37.139] Resolved: TRUE
[17:37:37.139] Value: <not collected>
[17:37:37.139] Conditions captured: <none>
[17:37:37.139] Early signaling: FALSE
[17:37:37.139] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:37.139] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:37.150] Chunk #1 of 2 ... DONE
[17:37:37.151] Chunk #2 of 2 ...
[17:37:37.151]  - Finding globals in '...' for chunk #2 ...
[17:37:37.151] getGlobalsAndPackages() ...
[17:37:37.151] Searching for globals...
[17:37:37.152] 
[17:37:37.152] Searching for globals ... DONE
[17:37:37.152] - globals: [0] <none>
[17:37:37.152] getGlobalsAndPackages() ... DONE
[17:37:37.152]    + additional globals found: [n=0] 
[17:37:37.152]    + additional namespaces needed: [n=0] 
[17:37:37.153]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:37.153]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:37.153]  - seeds: <none>
[17:37:37.153]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:37.153] getGlobalsAndPackages() ...
[17:37:37.153] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:37.154] Resolving globals: FALSE
[17:37:37.155] The total size of the 5 globals is 2.41 KiB (2472 bytes)
[17:37:37.155] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.41 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (1.03 KiB of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:37.156] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:37.156] - packages: [1] ‘stats’
[17:37:37.156] getGlobalsAndPackages() ... DONE
[17:37:37.157] run() for ‘Future’ ...
[17:37:37.157] - state: ‘created’
[17:37:37.157] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:37.162] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:37.162] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:37.162]   - Field: ‘label’
[17:37:37.163]   - Field: ‘local’
[17:37:37.163]   - Field: ‘owner’
[17:37:37.163]   - Field: ‘envir’
[17:37:37.163]   - Field: ‘workers’
[17:37:37.163]   - Field: ‘packages’
[17:37:37.163]   - Field: ‘gc’
[17:37:37.163]   - Field: ‘job’
[17:37:37.164]   - Field: ‘conditions’
[17:37:37.164]   - Field: ‘expr’
[17:37:37.164]   - Field: ‘uuid’
[17:37:37.164]   - Field: ‘seed’
[17:37:37.164]   - Field: ‘version’
[17:37:37.164]   - Field: ‘result’
[17:37:37.164]   - Field: ‘asynchronous’
[17:37:37.165]   - Field: ‘calls’
[17:37:37.165]   - Field: ‘globals’
[17:37:37.165]   - Field: ‘stdout’
[17:37:37.165]   - Field: ‘earlySignal’
[17:37:37.165]   - Field: ‘lazy’
[17:37:37.165]   - Field: ‘state’
[17:37:37.166] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:37.166] - Launch lazy future ...
[17:37:37.166] Packages needed by the future expression (n = 1): ‘stats’
[17:37:37.166] Packages needed by future strategies (n = 0): <none>
[17:37:37.167] {
[17:37:37.167]     {
[17:37:37.167]         {
[17:37:37.167]             ...future.startTime <- base::Sys.time()
[17:37:37.167]             {
[17:37:37.167]                 {
[17:37:37.167]                   {
[17:37:37.167]                     {
[17:37:37.167]                       {
[17:37:37.167]                         base::local({
[17:37:37.167]                           has_future <- base::requireNamespace("future", 
[17:37:37.167]                             quietly = TRUE)
[17:37:37.167]                           if (has_future) {
[17:37:37.167]                             ns <- base::getNamespace("future")
[17:37:37.167]                             version <- ns[[".package"]][["version"]]
[17:37:37.167]                             if (is.null(version)) 
[17:37:37.167]                               version <- utils::packageVersion("future")
[17:37:37.167]                           }
[17:37:37.167]                           else {
[17:37:37.167]                             version <- NULL
[17:37:37.167]                           }
[17:37:37.167]                           if (!has_future || version < "1.8.0") {
[17:37:37.167]                             info <- base::c(r_version = base::gsub("R version ", 
[17:37:37.167]                               "", base::R.version$version.string), 
[17:37:37.167]                               platform = base::sprintf("%s (%s-bit)", 
[17:37:37.167]                                 base::R.version$platform, 8 * 
[17:37:37.167]                                   base::.Machine$sizeof.pointer), 
[17:37:37.167]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:37.167]                                 "release", "version")], collapse = " "), 
[17:37:37.167]                               hostname = base::Sys.info()[["nodename"]])
[17:37:37.167]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:37:37.167]                               info)
[17:37:37.167]                             info <- base::paste(info, collapse = "; ")
[17:37:37.167]                             if (!has_future) {
[17:37:37.167]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:37.167]                                 info)
[17:37:37.167]                             }
[17:37:37.167]                             else {
[17:37:37.167]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:37.167]                                 info, version)
[17:37:37.167]                             }
[17:37:37.167]                             base::stop(msg)
[17:37:37.167]                           }
[17:37:37.167]                         })
[17:37:37.167]                       }
[17:37:37.167]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:37.167]                       base::options(mc.cores = 1L)
[17:37:37.167]                     }
[17:37:37.167]                     base::local({
[17:37:37.167]                       for (pkg in "stats") {
[17:37:37.167]                         base::loadNamespace(pkg)
[17:37:37.167]                         base::library(pkg, character.only = TRUE)
[17:37:37.167]                       }
[17:37:37.167]                     })
[17:37:37.167]                   }
[17:37:37.167]                   ...future.strategy.old <- future::plan("list")
[17:37:37.167]                   options(future.plan = NULL)
[17:37:37.167]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:37.167]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:37.167]                 }
[17:37:37.167]                 ...future.workdir <- getwd()
[17:37:37.167]             }
[17:37:37.167]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:37.167]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:37.167]         }
[17:37:37.167]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:37.167]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:37.167]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:37.167]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:37.167]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:37.167]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:37.167]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:37.167]             base::names(...future.oldOptions))
[17:37:37.167]     }
[17:37:37.167]     if (FALSE) {
[17:37:37.167]     }
[17:37:37.167]     else {
[17:37:37.167]         if (TRUE) {
[17:37:37.167]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:37.167]                 open = "w")
[17:37:37.167]         }
[17:37:37.167]         else {
[17:37:37.167]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:37.167]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:37.167]         }
[17:37:37.167]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:37.167]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:37.167]             base::sink(type = "output", split = FALSE)
[17:37:37.167]             base::close(...future.stdout)
[17:37:37.167]         }, add = TRUE)
[17:37:37.167]     }
[17:37:37.167]     ...future.frame <- base::sys.nframe()
[17:37:37.167]     ...future.conditions <- base::list()
[17:37:37.167]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:37.167]     if (FALSE) {
[17:37:37.167]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:37.167]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:37.167]     }
[17:37:37.167]     ...future.result <- base::tryCatch({
[17:37:37.167]         base::withCallingHandlers({
[17:37:37.167]             ...future.value <- base::withVisible(base::local({
[17:37:37.167]                 withCallingHandlers({
[17:37:37.167]                   {
[17:37:37.167]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:37.167]                     if (!identical(...future.globals.maxSize.org, 
[17:37:37.167]                       ...future.globals.maxSize)) {
[17:37:37.167]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:37.167]                       on.exit(options(oopts), add = TRUE)
[17:37:37.167]                     }
[17:37:37.167]                     {
[17:37:37.167]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:37.167]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:37.167]                         USE.NAMES = FALSE)
[17:37:37.167]                       do.call(mapply, args = args)
[17:37:37.167]                     }
[17:37:37.167]                   }
[17:37:37.167]                 }, immediateCondition = function(cond) {
[17:37:37.167]                   save_rds <- function (object, pathname, ...) 
[17:37:37.167]                   {
[17:37:37.167]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:37.167]                     if (file_test("-f", pathname_tmp)) {
[17:37:37.167]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.167]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:37.167]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.167]                         fi_tmp[["mtime"]])
[17:37:37.167]                     }
[17:37:37.167]                     tryCatch({
[17:37:37.167]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:37.167]                     }, error = function(ex) {
[17:37:37.167]                       msg <- conditionMessage(ex)
[17:37:37.167]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.167]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:37.167]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.167]                         fi_tmp[["mtime"]], msg)
[17:37:37.167]                       ex$message <- msg
[17:37:37.167]                       stop(ex)
[17:37:37.167]                     })
[17:37:37.167]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:37.167]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:37.167]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:37.167]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.167]                       fi <- file.info(pathname)
[17:37:37.167]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:37.167]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.167]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:37.167]                         fi[["size"]], fi[["mtime"]])
[17:37:37.167]                       stop(msg)
[17:37:37.167]                     }
[17:37:37.167]                     invisible(pathname)
[17:37:37.167]                   }
[17:37:37.167]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:37.167]                     rootPath = tempdir()) 
[17:37:37.167]                   {
[17:37:37.167]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:37.167]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:37.167]                       tmpdir = path, fileext = ".rds")
[17:37:37.167]                     save_rds(obj, file)
[17:37:37.167]                   }
[17:37:37.167]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:37.167]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.167]                   {
[17:37:37.167]                     inherits <- base::inherits
[17:37:37.167]                     invokeRestart <- base::invokeRestart
[17:37:37.167]                     is.null <- base::is.null
[17:37:37.167]                     muffled <- FALSE
[17:37:37.167]                     if (inherits(cond, "message")) {
[17:37:37.167]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:37.167]                       if (muffled) 
[17:37:37.167]                         invokeRestart("muffleMessage")
[17:37:37.167]                     }
[17:37:37.167]                     else if (inherits(cond, "warning")) {
[17:37:37.167]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:37.167]                       if (muffled) 
[17:37:37.167]                         invokeRestart("muffleWarning")
[17:37:37.167]                     }
[17:37:37.167]                     else if (inherits(cond, "condition")) {
[17:37:37.167]                       if (!is.null(pattern)) {
[17:37:37.167]                         computeRestarts <- base::computeRestarts
[17:37:37.167]                         grepl <- base::grepl
[17:37:37.167]                         restarts <- computeRestarts(cond)
[17:37:37.167]                         for (restart in restarts) {
[17:37:37.167]                           name <- restart$name
[17:37:37.167]                           if (is.null(name)) 
[17:37:37.167]                             next
[17:37:37.167]                           if (!grepl(pattern, name)) 
[17:37:37.167]                             next
[17:37:37.167]                           invokeRestart(restart)
[17:37:37.167]                           muffled <- TRUE
[17:37:37.167]                           break
[17:37:37.167]                         }
[17:37:37.167]                       }
[17:37:37.167]                     }
[17:37:37.167]                     invisible(muffled)
[17:37:37.167]                   }
[17:37:37.167]                   muffleCondition(cond)
[17:37:37.167]                 })
[17:37:37.167]             }))
[17:37:37.167]             future::FutureResult(value = ...future.value$value, 
[17:37:37.167]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:37.167]                   ...future.rng), globalenv = if (FALSE) 
[17:37:37.167]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:37.167]                     ...future.globalenv.names))
[17:37:37.167]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:37.167]         }, condition = base::local({
[17:37:37.167]             c <- base::c
[17:37:37.167]             inherits <- base::inherits
[17:37:37.167]             invokeRestart <- base::invokeRestart
[17:37:37.167]             length <- base::length
[17:37:37.167]             list <- base::list
[17:37:37.167]             seq.int <- base::seq.int
[17:37:37.167]             signalCondition <- base::signalCondition
[17:37:37.167]             sys.calls <- base::sys.calls
[17:37:37.167]             `[[` <- base::`[[`
[17:37:37.167]             `+` <- base::`+`
[17:37:37.167]             `<<-` <- base::`<<-`
[17:37:37.167]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:37.167]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:37.167]                   3L)]
[17:37:37.167]             }
[17:37:37.167]             function(cond) {
[17:37:37.167]                 is_error <- inherits(cond, "error")
[17:37:37.167]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:37.167]                   NULL)
[17:37:37.167]                 if (is_error) {
[17:37:37.167]                   sessionInformation <- function() {
[17:37:37.167]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:37.167]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:37.167]                       search = base::search(), system = base::Sys.info())
[17:37:37.167]                   }
[17:37:37.167]                   ...future.conditions[[length(...future.conditions) + 
[17:37:37.167]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:37.167]                     cond$call), session = sessionInformation(), 
[17:37:37.167]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:37.167]                   signalCondition(cond)
[17:37:37.167]                 }
[17:37:37.167]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:37.167]                 "immediateCondition"))) {
[17:37:37.167]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:37.167]                   ...future.conditions[[length(...future.conditions) + 
[17:37:37.167]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:37.167]                   if (TRUE && !signal) {
[17:37:37.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.167]                     {
[17:37:37.167]                       inherits <- base::inherits
[17:37:37.167]                       invokeRestart <- base::invokeRestart
[17:37:37.167]                       is.null <- base::is.null
[17:37:37.167]                       muffled <- FALSE
[17:37:37.167]                       if (inherits(cond, "message")) {
[17:37:37.167]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:37.167]                         if (muffled) 
[17:37:37.167]                           invokeRestart("muffleMessage")
[17:37:37.167]                       }
[17:37:37.167]                       else if (inherits(cond, "warning")) {
[17:37:37.167]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:37.167]                         if (muffled) 
[17:37:37.167]                           invokeRestart("muffleWarning")
[17:37:37.167]                       }
[17:37:37.167]                       else if (inherits(cond, "condition")) {
[17:37:37.167]                         if (!is.null(pattern)) {
[17:37:37.167]                           computeRestarts <- base::computeRestarts
[17:37:37.167]                           grepl <- base::grepl
[17:37:37.167]                           restarts <- computeRestarts(cond)
[17:37:37.167]                           for (restart in restarts) {
[17:37:37.167]                             name <- restart$name
[17:37:37.167]                             if (is.null(name)) 
[17:37:37.167]                               next
[17:37:37.167]                             if (!grepl(pattern, name)) 
[17:37:37.167]                               next
[17:37:37.167]                             invokeRestart(restart)
[17:37:37.167]                             muffled <- TRUE
[17:37:37.167]                             break
[17:37:37.167]                           }
[17:37:37.167]                         }
[17:37:37.167]                       }
[17:37:37.167]                       invisible(muffled)
[17:37:37.167]                     }
[17:37:37.167]                     muffleCondition(cond, pattern = "^muffle")
[17:37:37.167]                   }
[17:37:37.167]                 }
[17:37:37.167]                 else {
[17:37:37.167]                   if (TRUE) {
[17:37:37.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.167]                     {
[17:37:37.167]                       inherits <- base::inherits
[17:37:37.167]                       invokeRestart <- base::invokeRestart
[17:37:37.167]                       is.null <- base::is.null
[17:37:37.167]                       muffled <- FALSE
[17:37:37.167]                       if (inherits(cond, "message")) {
[17:37:37.167]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:37.167]                         if (muffled) 
[17:37:37.167]                           invokeRestart("muffleMessage")
[17:37:37.167]                       }
[17:37:37.167]                       else if (inherits(cond, "warning")) {
[17:37:37.167]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:37.167]                         if (muffled) 
[17:37:37.167]                           invokeRestart("muffleWarning")
[17:37:37.167]                       }
[17:37:37.167]                       else if (inherits(cond, "condition")) {
[17:37:37.167]                         if (!is.null(pattern)) {
[17:37:37.167]                           computeRestarts <- base::computeRestarts
[17:37:37.167]                           grepl <- base::grepl
[17:37:37.167]                           restarts <- computeRestarts(cond)
[17:37:37.167]                           for (restart in restarts) {
[17:37:37.167]                             name <- restart$name
[17:37:37.167]                             if (is.null(name)) 
[17:37:37.167]                               next
[17:37:37.167]                             if (!grepl(pattern, name)) 
[17:37:37.167]                               next
[17:37:37.167]                             invokeRestart(restart)
[17:37:37.167]                             muffled <- TRUE
[17:37:37.167]                             break
[17:37:37.167]                           }
[17:37:37.167]                         }
[17:37:37.167]                       }
[17:37:37.167]                       invisible(muffled)
[17:37:37.167]                     }
[17:37:37.167]                     muffleCondition(cond, pattern = "^muffle")
[17:37:37.167]                   }
[17:37:37.167]                 }
[17:37:37.167]             }
[17:37:37.167]         }))
[17:37:37.167]     }, error = function(ex) {
[17:37:37.167]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:37.167]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:37.167]                 ...future.rng), started = ...future.startTime, 
[17:37:37.167]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:37.167]             version = "1.8"), class = "FutureResult")
[17:37:37.167]     }, finally = {
[17:37:37.167]         if (!identical(...future.workdir, getwd())) 
[17:37:37.167]             setwd(...future.workdir)
[17:37:37.167]         {
[17:37:37.167]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:37.167]                 ...future.oldOptions$nwarnings <- NULL
[17:37:37.167]             }
[17:37:37.167]             base::options(...future.oldOptions)
[17:37:37.167]             if (.Platform$OS.type == "windows") {
[17:37:37.167]                 old_names <- names(...future.oldEnvVars)
[17:37:37.167]                 envs <- base::Sys.getenv()
[17:37:37.167]                 names <- names(envs)
[17:37:37.167]                 common <- intersect(names, old_names)
[17:37:37.167]                 added <- setdiff(names, old_names)
[17:37:37.167]                 removed <- setdiff(old_names, names)
[17:37:37.167]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:37.167]                   envs[common]]
[17:37:37.167]                 NAMES <- toupper(changed)
[17:37:37.167]                 args <- list()
[17:37:37.167]                 for (kk in seq_along(NAMES)) {
[17:37:37.167]                   name <- changed[[kk]]
[17:37:37.167]                   NAME <- NAMES[[kk]]
[17:37:37.167]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.167]                     next
[17:37:37.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:37.167]                 }
[17:37:37.167]                 NAMES <- toupper(added)
[17:37:37.167]                 for (kk in seq_along(NAMES)) {
[17:37:37.167]                   name <- added[[kk]]
[17:37:37.167]                   NAME <- NAMES[[kk]]
[17:37:37.167]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.167]                     next
[17:37:37.167]                   args[[name]] <- ""
[17:37:37.167]                 }
[17:37:37.167]                 NAMES <- toupper(removed)
[17:37:37.167]                 for (kk in seq_along(NAMES)) {
[17:37:37.167]                   name <- removed[[kk]]
[17:37:37.167]                   NAME <- NAMES[[kk]]
[17:37:37.167]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.167]                     next
[17:37:37.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:37.167]                 }
[17:37:37.167]                 if (length(args) > 0) 
[17:37:37.167]                   base::do.call(base::Sys.setenv, args = args)
[17:37:37.167]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:37.167]             }
[17:37:37.167]             else {
[17:37:37.167]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:37.167]             }
[17:37:37.167]             {
[17:37:37.167]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:37.167]                   0L) {
[17:37:37.167]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:37.167]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:37.167]                   base::options(opts)
[17:37:37.167]                 }
[17:37:37.167]                 {
[17:37:37.167]                   {
[17:37:37.167]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:37.167]                     NULL
[17:37:37.167]                   }
[17:37:37.167]                   options(future.plan = NULL)
[17:37:37.167]                   if (is.na(NA_character_)) 
[17:37:37.167]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:37.167]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:37.167]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:37.167]                     .init = FALSE)
[17:37:37.167]                 }
[17:37:37.167]             }
[17:37:37.167]         }
[17:37:37.167]     })
[17:37:37.167]     if (TRUE) {
[17:37:37.167]         base::sink(type = "output", split = FALSE)
[17:37:37.167]         if (TRUE) {
[17:37:37.167]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:37.167]         }
[17:37:37.167]         else {
[17:37:37.167]             ...future.result["stdout"] <- base::list(NULL)
[17:37:37.167]         }
[17:37:37.167]         base::close(...future.stdout)
[17:37:37.167]         ...future.stdout <- NULL
[17:37:37.167]     }
[17:37:37.167]     ...future.result$conditions <- ...future.conditions
[17:37:37.167]     ...future.result$finished <- base::Sys.time()
[17:37:37.167]     ...future.result
[17:37:37.167] }
[17:37:37.171] assign_globals() ...
[17:37:37.171] List of 5
[17:37:37.171]  $ ...future.FUN            :function (x, w, ...)  
[17:37:37.171]  $ MoreArgs                 : NULL
[17:37:37.171]  $ ...future.elements_ii    :List of 2
[17:37:37.171]   ..$ :List of 3
[17:37:37.171]   .. ..$ : num [1:10] 0.65648 0.43901 0.38422 0.00979 0.66562 ...
[17:37:37.171]   .. ..$ : num [1:10] 0.896 0.351 0.968 0.338 0.268 ...
[17:37:37.171]   .. ..$ : num [1:10] 0.0443 0.4227 0.9719 0.9727 0.0431 ...
[17:37:37.171]   ..$ :List of 3
[17:37:37.171]   .. ..$ : num [1:10] 8 7 2 7 5 7 7 5 8 4
[17:37:37.171]   .. ..$ : num [1:10] 7 11 4 3 6 4 3 2 7 6
[17:37:37.171]   .. ..$ : num [1:10] 8 3 6 3 1 5 6 7 5 5
[17:37:37.171]  $ ...future.seeds_ii       : NULL
[17:37:37.171]  $ ...future.globals.maxSize: NULL
[17:37:37.171]  - attr(*, "where")=List of 5
[17:37:37.171]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:37.171]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:37.171]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:37.171]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:37.171]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:37.171]  - attr(*, "resolved")= logi FALSE
[17:37:37.171]  - attr(*, "total_size")= num 2472
[17:37:37.171]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:37.171]  - attr(*, "already-done")= logi TRUE
[17:37:37.187] - copied ‘...future.FUN’ to environment
[17:37:37.188] - copied ‘MoreArgs’ to environment
[17:37:37.188] - copied ‘...future.elements_ii’ to environment
[17:37:37.188] - copied ‘...future.seeds_ii’ to environment
[17:37:37.188] - copied ‘...future.globals.maxSize’ to environment
[17:37:37.188] assign_globals() ... done
[17:37:37.188] requestCore(): workers = 2
[17:37:37.191] MulticoreFuture started
[17:37:37.192] - Launch lazy future ... done
[17:37:37.192] run() for ‘MulticoreFuture’ ... done
[17:37:37.192] Created future:
[17:37:37.193] plan(): Setting new future strategy stack:
[17:37:37.193] List of future strategies:
[17:37:37.193] 1. sequential:
[17:37:37.193]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:37.193]    - tweaked: FALSE
[17:37:37.193]    - call: NULL
[17:37:37.194] plan(): nbrOfWorkers() = 1
[17:37:37.196] plan(): Setting new future strategy stack:
[17:37:37.197] List of future strategies:
[17:37:37.197] 1. multicore:
[17:37:37.197]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:37.197]    - tweaked: FALSE
[17:37:37.197]    - call: plan(strategy)
[17:37:37.202] plan(): nbrOfWorkers() = 2
[17:37:37.192] MulticoreFuture:
[17:37:37.192] Label: ‘future_Map-2’
[17:37:37.192] Expression:
[17:37:37.192] {
[17:37:37.192]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:37.192]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:37.192]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:37.192]         on.exit(options(oopts), add = TRUE)
[17:37:37.192]     }
[17:37:37.192]     {
[17:37:37.192]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:37.192]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:37.192]         do.call(mapply, args = args)
[17:37:37.192]     }
[17:37:37.192] }
[17:37:37.192] Lazy evaluation: FALSE
[17:37:37.192] Asynchronous evaluation: TRUE
[17:37:37.192] Local evaluation: TRUE
[17:37:37.192] Environment: R_GlobalEnv
[17:37:37.192] Capture standard output: TRUE
[17:37:37.192] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:37.192] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:37.192] Packages: 1 packages (‘stats’)
[17:37:37.192] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:37.192] Resolved: TRUE
[17:37:37.192] Value: <not collected>
[17:37:37.192] Conditions captured: <none>
[17:37:37.192] Early signaling: FALSE
[17:37:37.192] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:37.192] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:37.203] Chunk #2 of 2 ... DONE
[17:37:37.203] Launching 2 futures (chunks) ... DONE
[17:37:37.203] Resolving 2 futures (chunks) ...
[17:37:37.204] resolve() on list ...
[17:37:37.204]  recursive: 0
[17:37:37.204]  length: 2
[17:37:37.204] 
[17:37:37.204] Future #1
[17:37:37.205] result() for MulticoreFuture ...
[17:37:37.206] result() for MulticoreFuture ...
[17:37:37.206] result() for MulticoreFuture ... done
[17:37:37.206] result() for MulticoreFuture ... done
[17:37:37.206] result() for MulticoreFuture ...
[17:37:37.206] result() for MulticoreFuture ... done
[17:37:37.206] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:37:37.207] - nx: 2
[17:37:37.207] - relay: TRUE
[17:37:37.207] - stdout: TRUE
[17:37:37.207] - signal: TRUE
[17:37:37.207] - resignal: FALSE
[17:37:37.208] - force: TRUE
[17:37:37.208] - relayed: [n=2] FALSE, FALSE
[17:37:37.208] - queued futures: [n=2] FALSE, FALSE
[17:37:37.208]  - until=1
[17:37:37.208]  - relaying element #1
[17:37:37.209] result() for MulticoreFuture ...
[17:37:37.209] result() for MulticoreFuture ... done
[17:37:37.209] result() for MulticoreFuture ...
[17:37:37.209] result() for MulticoreFuture ... done
[17:37:37.210] result() for MulticoreFuture ...
[17:37:37.210] result() for MulticoreFuture ... done
[17:37:37.210] result() for MulticoreFuture ...
[17:37:37.210] result() for MulticoreFuture ... done
[17:37:37.210] - relayed: [n=2] TRUE, FALSE
[17:37:37.210] - queued futures: [n=2] TRUE, FALSE
[17:37:37.211] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:37:37.211]  length: 1 (resolved future 1)
[17:37:37.211] Future #2
[17:37:37.211] result() for MulticoreFuture ...
[17:37:37.212] result() for MulticoreFuture ...
[17:37:37.212] result() for MulticoreFuture ... done
[17:37:37.212] result() for MulticoreFuture ... done
[17:37:37.213] result() for MulticoreFuture ...
[17:37:37.213] result() for MulticoreFuture ... done
[17:37:37.213] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:37:37.213] - nx: 2
[17:37:37.214] - relay: TRUE
[17:37:37.214] - stdout: TRUE
[17:37:37.214] - signal: TRUE
[17:37:37.214] - resignal: FALSE
[17:37:37.214] - force: TRUE
[17:37:37.214] - relayed: [n=2] TRUE, FALSE
[17:37:37.214] - queued futures: [n=2] TRUE, FALSE
[17:37:37.215]  - until=2
[17:37:37.215]  - relaying element #2
[17:37:37.215] result() for MulticoreFuture ...
[17:37:37.215] result() for MulticoreFuture ... done
[17:37:37.215] result() for MulticoreFuture ...
[17:37:37.215] result() for MulticoreFuture ... done
[17:37:37.216] result() for MulticoreFuture ...
[17:37:37.216] result() for MulticoreFuture ... done
[17:37:37.216] result() for MulticoreFuture ...
[17:37:37.216] result() for MulticoreFuture ... done
[17:37:37.216] - relayed: [n=2] TRUE, TRUE
[17:37:37.216] - queued futures: [n=2] TRUE, TRUE
[17:37:37.216] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:37:37.216]  length: 0 (resolved future 2)
[17:37:37.216] Relaying remaining futures
[17:37:37.217] signalConditionsASAP(NULL, pos=0) ...
[17:37:37.217] - nx: 2
[17:37:37.217] - relay: TRUE
[17:37:37.217] - stdout: TRUE
[17:37:37.217] - signal: TRUE
[17:37:37.217] - resignal: FALSE
[17:37:37.217] - force: TRUE
[17:37:37.217] - relayed: [n=2] TRUE, TRUE
[17:37:37.217] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:37.218] - relayed: [n=2] TRUE, TRUE
[17:37:37.218] - queued futures: [n=2] TRUE, TRUE
[17:37:37.218] signalConditionsASAP(NULL, pos=0) ... done
[17:37:37.218] resolve() on list ... DONE
[17:37:37.218] result() for MulticoreFuture ...
[17:37:37.218] result() for MulticoreFuture ... done
[17:37:37.218] result() for MulticoreFuture ...
[17:37:37.218] result() for MulticoreFuture ... done
[17:37:37.219] result() for MulticoreFuture ...
[17:37:37.222] result() for MulticoreFuture ... done
[17:37:37.222] result() for MulticoreFuture ...
[17:37:37.222] result() for MulticoreFuture ... done
[17:37:37.222]  - Number of value chunks collected: 2
[17:37:37.222] Resolving 2 futures (chunks) ... DONE
[17:37:37.223] Reducing values from 2 chunks ...
[17:37:37.223]  - Number of values collected after concatenation: 5
[17:37:37.223]  - Number of values expected: 5
[17:37:37.223] Reducing values from 2 chunks ... DONE
[17:37:37.223] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[17:37:37.226] future_mapply() ...
[17:37:37.230] Number of chunks: 2
[17:37:37.231] getGlobalsAndPackagesXApply() ...
[17:37:37.231]  - future.globals: TRUE
[17:37:37.231] getGlobalsAndPackages() ...
[17:37:37.231] Searching for globals...
[17:37:37.232] - globals found: [1] ‘FUN’
[17:37:37.232] Searching for globals ... DONE
[17:37:37.232] Resolving globals: FALSE
[17:37:37.233] The total size of the 1 globals is 56 bytes (56 bytes)
[17:37:37.233] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:37:37.233] - globals: [1] ‘FUN’
[17:37:37.234] 
[17:37:37.234] getGlobalsAndPackages() ... DONE
[17:37:37.234]  - globals found/used: [n=1] ‘FUN’
[17:37:37.234]  - needed namespaces: [n=0] 
[17:37:37.234] Finding globals ... DONE
[17:37:37.234] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:37.234] List of 2
[17:37:37.234]  $ ...future.FUN:function (e1, e2)  
[17:37:37.234]  $ MoreArgs     : NULL
[17:37:37.234]  - attr(*, "where")=List of 2
[17:37:37.234]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:37.234]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:37.234]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:37.234]  - attr(*, "resolved")= logi FALSE
[17:37:37.234]  - attr(*, "total_size")= num NA
[17:37:37.237] Packages to be attached in all futures: [n=0] 
[17:37:37.237] getGlobalsAndPackagesXApply() ... DONE
[17:37:37.237] Number of futures (= number of chunks): 2
[17:37:37.238] Launching 2 futures (chunks) ...
[17:37:37.238] Chunk #1 of 2 ...
[17:37:37.238]  - Finding globals in '...' for chunk #1 ...
[17:37:37.238] getGlobalsAndPackages() ...
[17:37:37.238] Searching for globals...
[17:37:37.238] 
[17:37:37.238] Searching for globals ... DONE
[17:37:37.238] - globals: [0] <none>
[17:37:37.239] getGlobalsAndPackages() ... DONE
[17:37:37.239]    + additional globals found: [n=0] 
[17:37:37.239]    + additional namespaces needed: [n=0] 
[17:37:37.239]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:37.239]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:37.239]  - seeds: <none>
[17:37:37.239]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:37.239] getGlobalsAndPackages() ...
[17:37:37.239] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:37.239] Resolving globals: FALSE
[17:37:37.240] The total size of the 5 globals is 168 bytes (168 bytes)
[17:37:37.240] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 168 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:37.241] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:37.241] 
[17:37:37.241] getGlobalsAndPackages() ... DONE
[17:37:37.241] run() for ‘Future’ ...
[17:37:37.241] - state: ‘created’
[17:37:37.241] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:37.245] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:37.245] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:37.245]   - Field: ‘label’
[17:37:37.245]   - Field: ‘local’
[17:37:37.246]   - Field: ‘owner’
[17:37:37.246]   - Field: ‘envir’
[17:37:37.246]   - Field: ‘workers’
[17:37:37.246]   - Field: ‘packages’
[17:37:37.246]   - Field: ‘gc’
[17:37:37.246]   - Field: ‘job’
[17:37:37.246]   - Field: ‘conditions’
[17:37:37.246]   - Field: ‘expr’
[17:37:37.246]   - Field: ‘uuid’
[17:37:37.246]   - Field: ‘seed’
[17:37:37.247]   - Field: ‘version’
[17:37:37.247]   - Field: ‘result’
[17:37:37.247]   - Field: ‘asynchronous’
[17:37:37.247]   - Field: ‘calls’
[17:37:37.247]   - Field: ‘globals’
[17:37:37.247]   - Field: ‘stdout’
[17:37:37.247]   - Field: ‘earlySignal’
[17:37:37.247]   - Field: ‘lazy’
[17:37:37.247]   - Field: ‘state’
[17:37:37.247] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:37.247] - Launch lazy future ...
[17:37:37.248] Packages needed by the future expression (n = 0): <none>
[17:37:37.248] Packages needed by future strategies (n = 0): <none>
[17:37:37.248] {
[17:37:37.248]     {
[17:37:37.248]         {
[17:37:37.248]             ...future.startTime <- base::Sys.time()
[17:37:37.248]             {
[17:37:37.248]                 {
[17:37:37.248]                   {
[17:37:37.248]                     {
[17:37:37.248]                       base::local({
[17:37:37.248]                         has_future <- base::requireNamespace("future", 
[17:37:37.248]                           quietly = TRUE)
[17:37:37.248]                         if (has_future) {
[17:37:37.248]                           ns <- base::getNamespace("future")
[17:37:37.248]                           version <- ns[[".package"]][["version"]]
[17:37:37.248]                           if (is.null(version)) 
[17:37:37.248]                             version <- utils::packageVersion("future")
[17:37:37.248]                         }
[17:37:37.248]                         else {
[17:37:37.248]                           version <- NULL
[17:37:37.248]                         }
[17:37:37.248]                         if (!has_future || version < "1.8.0") {
[17:37:37.248]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:37.248]                             "", base::R.version$version.string), 
[17:37:37.248]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:37.248]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:37.248]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:37.248]                               "release", "version")], collapse = " "), 
[17:37:37.248]                             hostname = base::Sys.info()[["nodename"]])
[17:37:37.248]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:37.248]                             info)
[17:37:37.248]                           info <- base::paste(info, collapse = "; ")
[17:37:37.248]                           if (!has_future) {
[17:37:37.248]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:37.248]                               info)
[17:37:37.248]                           }
[17:37:37.248]                           else {
[17:37:37.248]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:37.248]                               info, version)
[17:37:37.248]                           }
[17:37:37.248]                           base::stop(msg)
[17:37:37.248]                         }
[17:37:37.248]                       })
[17:37:37.248]                     }
[17:37:37.248]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:37.248]                     base::options(mc.cores = 1L)
[17:37:37.248]                   }
[17:37:37.248]                   ...future.strategy.old <- future::plan("list")
[17:37:37.248]                   options(future.plan = NULL)
[17:37:37.248]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:37.248]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:37.248]                 }
[17:37:37.248]                 ...future.workdir <- getwd()
[17:37:37.248]             }
[17:37:37.248]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:37.248]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:37.248]         }
[17:37:37.248]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:37.248]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:37.248]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:37.248]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:37.248]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:37.248]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:37.248]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:37.248]             base::names(...future.oldOptions))
[17:37:37.248]     }
[17:37:37.248]     if (FALSE) {
[17:37:37.248]     }
[17:37:37.248]     else {
[17:37:37.248]         if (TRUE) {
[17:37:37.248]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:37.248]                 open = "w")
[17:37:37.248]         }
[17:37:37.248]         else {
[17:37:37.248]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:37.248]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:37.248]         }
[17:37:37.248]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:37.248]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:37.248]             base::sink(type = "output", split = FALSE)
[17:37:37.248]             base::close(...future.stdout)
[17:37:37.248]         }, add = TRUE)
[17:37:37.248]     }
[17:37:37.248]     ...future.frame <- base::sys.nframe()
[17:37:37.248]     ...future.conditions <- base::list()
[17:37:37.248]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:37.248]     if (FALSE) {
[17:37:37.248]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:37.248]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:37.248]     }
[17:37:37.248]     ...future.result <- base::tryCatch({
[17:37:37.248]         base::withCallingHandlers({
[17:37:37.248]             ...future.value <- base::withVisible(base::local({
[17:37:37.248]                 withCallingHandlers({
[17:37:37.248]                   {
[17:37:37.248]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:37.248]                     if (!identical(...future.globals.maxSize.org, 
[17:37:37.248]                       ...future.globals.maxSize)) {
[17:37:37.248]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:37.248]                       on.exit(options(oopts), add = TRUE)
[17:37:37.248]                     }
[17:37:37.248]                     {
[17:37:37.248]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:37.248]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:37.248]                         USE.NAMES = FALSE)
[17:37:37.248]                       do.call(mapply, args = args)
[17:37:37.248]                     }
[17:37:37.248]                   }
[17:37:37.248]                 }, immediateCondition = function(cond) {
[17:37:37.248]                   save_rds <- function (object, pathname, ...) 
[17:37:37.248]                   {
[17:37:37.248]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:37.248]                     if (file_test("-f", pathname_tmp)) {
[17:37:37.248]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.248]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:37.248]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.248]                         fi_tmp[["mtime"]])
[17:37:37.248]                     }
[17:37:37.248]                     tryCatch({
[17:37:37.248]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:37.248]                     }, error = function(ex) {
[17:37:37.248]                       msg <- conditionMessage(ex)
[17:37:37.248]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.248]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:37.248]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.248]                         fi_tmp[["mtime"]], msg)
[17:37:37.248]                       ex$message <- msg
[17:37:37.248]                       stop(ex)
[17:37:37.248]                     })
[17:37:37.248]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:37.248]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:37.248]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:37.248]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.248]                       fi <- file.info(pathname)
[17:37:37.248]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:37.248]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.248]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:37.248]                         fi[["size"]], fi[["mtime"]])
[17:37:37.248]                       stop(msg)
[17:37:37.248]                     }
[17:37:37.248]                     invisible(pathname)
[17:37:37.248]                   }
[17:37:37.248]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:37.248]                     rootPath = tempdir()) 
[17:37:37.248]                   {
[17:37:37.248]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:37.248]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:37.248]                       tmpdir = path, fileext = ".rds")
[17:37:37.248]                     save_rds(obj, file)
[17:37:37.248]                   }
[17:37:37.248]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:37.248]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.248]                   {
[17:37:37.248]                     inherits <- base::inherits
[17:37:37.248]                     invokeRestart <- base::invokeRestart
[17:37:37.248]                     is.null <- base::is.null
[17:37:37.248]                     muffled <- FALSE
[17:37:37.248]                     if (inherits(cond, "message")) {
[17:37:37.248]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:37.248]                       if (muffled) 
[17:37:37.248]                         invokeRestart("muffleMessage")
[17:37:37.248]                     }
[17:37:37.248]                     else if (inherits(cond, "warning")) {
[17:37:37.248]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:37.248]                       if (muffled) 
[17:37:37.248]                         invokeRestart("muffleWarning")
[17:37:37.248]                     }
[17:37:37.248]                     else if (inherits(cond, "condition")) {
[17:37:37.248]                       if (!is.null(pattern)) {
[17:37:37.248]                         computeRestarts <- base::computeRestarts
[17:37:37.248]                         grepl <- base::grepl
[17:37:37.248]                         restarts <- computeRestarts(cond)
[17:37:37.248]                         for (restart in restarts) {
[17:37:37.248]                           name <- restart$name
[17:37:37.248]                           if (is.null(name)) 
[17:37:37.248]                             next
[17:37:37.248]                           if (!grepl(pattern, name)) 
[17:37:37.248]                             next
[17:37:37.248]                           invokeRestart(restart)
[17:37:37.248]                           muffled <- TRUE
[17:37:37.248]                           break
[17:37:37.248]                         }
[17:37:37.248]                       }
[17:37:37.248]                     }
[17:37:37.248]                     invisible(muffled)
[17:37:37.248]                   }
[17:37:37.248]                   muffleCondition(cond)
[17:37:37.248]                 })
[17:37:37.248]             }))
[17:37:37.248]             future::FutureResult(value = ...future.value$value, 
[17:37:37.248]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:37.248]                   ...future.rng), globalenv = if (FALSE) 
[17:37:37.248]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:37.248]                     ...future.globalenv.names))
[17:37:37.248]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:37.248]         }, condition = base::local({
[17:37:37.248]             c <- base::c
[17:37:37.248]             inherits <- base::inherits
[17:37:37.248]             invokeRestart <- base::invokeRestart
[17:37:37.248]             length <- base::length
[17:37:37.248]             list <- base::list
[17:37:37.248]             seq.int <- base::seq.int
[17:37:37.248]             signalCondition <- base::signalCondition
[17:37:37.248]             sys.calls <- base::sys.calls
[17:37:37.248]             `[[` <- base::`[[`
[17:37:37.248]             `+` <- base::`+`
[17:37:37.248]             `<<-` <- base::`<<-`
[17:37:37.248]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:37.248]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:37.248]                   3L)]
[17:37:37.248]             }
[17:37:37.248]             function(cond) {
[17:37:37.248]                 is_error <- inherits(cond, "error")
[17:37:37.248]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:37.248]                   NULL)
[17:37:37.248]                 if (is_error) {
[17:37:37.248]                   sessionInformation <- function() {
[17:37:37.248]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:37.248]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:37.248]                       search = base::search(), system = base::Sys.info())
[17:37:37.248]                   }
[17:37:37.248]                   ...future.conditions[[length(...future.conditions) + 
[17:37:37.248]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:37.248]                     cond$call), session = sessionInformation(), 
[17:37:37.248]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:37.248]                   signalCondition(cond)
[17:37:37.248]                 }
[17:37:37.248]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:37.248]                 "immediateCondition"))) {
[17:37:37.248]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:37.248]                   ...future.conditions[[length(...future.conditions) + 
[17:37:37.248]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:37.248]                   if (TRUE && !signal) {
[17:37:37.248]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.248]                     {
[17:37:37.248]                       inherits <- base::inherits
[17:37:37.248]                       invokeRestart <- base::invokeRestart
[17:37:37.248]                       is.null <- base::is.null
[17:37:37.248]                       muffled <- FALSE
[17:37:37.248]                       if (inherits(cond, "message")) {
[17:37:37.248]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:37.248]                         if (muffled) 
[17:37:37.248]                           invokeRestart("muffleMessage")
[17:37:37.248]                       }
[17:37:37.248]                       else if (inherits(cond, "warning")) {
[17:37:37.248]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:37.248]                         if (muffled) 
[17:37:37.248]                           invokeRestart("muffleWarning")
[17:37:37.248]                       }
[17:37:37.248]                       else if (inherits(cond, "condition")) {
[17:37:37.248]                         if (!is.null(pattern)) {
[17:37:37.248]                           computeRestarts <- base::computeRestarts
[17:37:37.248]                           grepl <- base::grepl
[17:37:37.248]                           restarts <- computeRestarts(cond)
[17:37:37.248]                           for (restart in restarts) {
[17:37:37.248]                             name <- restart$name
[17:37:37.248]                             if (is.null(name)) 
[17:37:37.248]                               next
[17:37:37.248]                             if (!grepl(pattern, name)) 
[17:37:37.248]                               next
[17:37:37.248]                             invokeRestart(restart)
[17:37:37.248]                             muffled <- TRUE
[17:37:37.248]                             break
[17:37:37.248]                           }
[17:37:37.248]                         }
[17:37:37.248]                       }
[17:37:37.248]                       invisible(muffled)
[17:37:37.248]                     }
[17:37:37.248]                     muffleCondition(cond, pattern = "^muffle")
[17:37:37.248]                   }
[17:37:37.248]                 }
[17:37:37.248]                 else {
[17:37:37.248]                   if (TRUE) {
[17:37:37.248]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.248]                     {
[17:37:37.248]                       inherits <- base::inherits
[17:37:37.248]                       invokeRestart <- base::invokeRestart
[17:37:37.248]                       is.null <- base::is.null
[17:37:37.248]                       muffled <- FALSE
[17:37:37.248]                       if (inherits(cond, "message")) {
[17:37:37.248]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:37.248]                         if (muffled) 
[17:37:37.248]                           invokeRestart("muffleMessage")
[17:37:37.248]                       }
[17:37:37.248]                       else if (inherits(cond, "warning")) {
[17:37:37.248]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:37.248]                         if (muffled) 
[17:37:37.248]                           invokeRestart("muffleWarning")
[17:37:37.248]                       }
[17:37:37.248]                       else if (inherits(cond, "condition")) {
[17:37:37.248]                         if (!is.null(pattern)) {
[17:37:37.248]                           computeRestarts <- base::computeRestarts
[17:37:37.248]                           grepl <- base::grepl
[17:37:37.248]                           restarts <- computeRestarts(cond)
[17:37:37.248]                           for (restart in restarts) {
[17:37:37.248]                             name <- restart$name
[17:37:37.248]                             if (is.null(name)) 
[17:37:37.248]                               next
[17:37:37.248]                             if (!grepl(pattern, name)) 
[17:37:37.248]                               next
[17:37:37.248]                             invokeRestart(restart)
[17:37:37.248]                             muffled <- TRUE
[17:37:37.248]                             break
[17:37:37.248]                           }
[17:37:37.248]                         }
[17:37:37.248]                       }
[17:37:37.248]                       invisible(muffled)
[17:37:37.248]                     }
[17:37:37.248]                     muffleCondition(cond, pattern = "^muffle")
[17:37:37.248]                   }
[17:37:37.248]                 }
[17:37:37.248]             }
[17:37:37.248]         }))
[17:37:37.248]     }, error = function(ex) {
[17:37:37.248]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:37.248]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:37.248]                 ...future.rng), started = ...future.startTime, 
[17:37:37.248]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:37.248]             version = "1.8"), class = "FutureResult")
[17:37:37.248]     }, finally = {
[17:37:37.248]         if (!identical(...future.workdir, getwd())) 
[17:37:37.248]             setwd(...future.workdir)
[17:37:37.248]         {
[17:37:37.248]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:37.248]                 ...future.oldOptions$nwarnings <- NULL
[17:37:37.248]             }
[17:37:37.248]             base::options(...future.oldOptions)
[17:37:37.248]             if (.Platform$OS.type == "windows") {
[17:37:37.248]                 old_names <- names(...future.oldEnvVars)
[17:37:37.248]                 envs <- base::Sys.getenv()
[17:37:37.248]                 names <- names(envs)
[17:37:37.248]                 common <- intersect(names, old_names)
[17:37:37.248]                 added <- setdiff(names, old_names)
[17:37:37.248]                 removed <- setdiff(old_names, names)
[17:37:37.248]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:37.248]                   envs[common]]
[17:37:37.248]                 NAMES <- toupper(changed)
[17:37:37.248]                 args <- list()
[17:37:37.248]                 for (kk in seq_along(NAMES)) {
[17:37:37.248]                   name <- changed[[kk]]
[17:37:37.248]                   NAME <- NAMES[[kk]]
[17:37:37.248]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.248]                     next
[17:37:37.248]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:37.248]                 }
[17:37:37.248]                 NAMES <- toupper(added)
[17:37:37.248]                 for (kk in seq_along(NAMES)) {
[17:37:37.248]                   name <- added[[kk]]
[17:37:37.248]                   NAME <- NAMES[[kk]]
[17:37:37.248]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.248]                     next
[17:37:37.248]                   args[[name]] <- ""
[17:37:37.248]                 }
[17:37:37.248]                 NAMES <- toupper(removed)
[17:37:37.248]                 for (kk in seq_along(NAMES)) {
[17:37:37.248]                   name <- removed[[kk]]
[17:37:37.248]                   NAME <- NAMES[[kk]]
[17:37:37.248]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.248]                     next
[17:37:37.248]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:37.248]                 }
[17:37:37.248]                 if (length(args) > 0) 
[17:37:37.248]                   base::do.call(base::Sys.setenv, args = args)
[17:37:37.248]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:37.248]             }
[17:37:37.248]             else {
[17:37:37.248]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:37.248]             }
[17:37:37.248]             {
[17:37:37.248]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:37.248]                   0L) {
[17:37:37.248]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:37.248]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:37.248]                   base::options(opts)
[17:37:37.248]                 }
[17:37:37.248]                 {
[17:37:37.248]                   {
[17:37:37.248]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:37.248]                     NULL
[17:37:37.248]                   }
[17:37:37.248]                   options(future.plan = NULL)
[17:37:37.248]                   if (is.na(NA_character_)) 
[17:37:37.248]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:37.248]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:37.248]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:37.248]                     .init = FALSE)
[17:37:37.248]                 }
[17:37:37.248]             }
[17:37:37.248]         }
[17:37:37.248]     })
[17:37:37.248]     if (TRUE) {
[17:37:37.248]         base::sink(type = "output", split = FALSE)
[17:37:37.248]         if (TRUE) {
[17:37:37.248]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:37.248]         }
[17:37:37.248]         else {
[17:37:37.248]             ...future.result["stdout"] <- base::list(NULL)
[17:37:37.248]         }
[17:37:37.248]         base::close(...future.stdout)
[17:37:37.248]         ...future.stdout <- NULL
[17:37:37.248]     }
[17:37:37.248]     ...future.result$conditions <- ...future.conditions
[17:37:37.248]     ...future.result$finished <- base::Sys.time()
[17:37:37.248]     ...future.result
[17:37:37.248] }
[17:37:37.251] assign_globals() ...
[17:37:37.251] List of 5
[17:37:37.251]  $ ...future.FUN            :function (e1, e2)  
[17:37:37.251]  $ MoreArgs                 : NULL
[17:37:37.251]  $ ...future.elements_ii    :List of 2
[17:37:37.251]   ..$ :List of 1
[17:37:37.251]   .. ..$ : num 1
[17:37:37.251]   ..$ :List of 1
[17:37:37.251]   .. ..$ : int 1
[17:37:37.251]  $ ...future.seeds_ii       : NULL
[17:37:37.251]  $ ...future.globals.maxSize: NULL
[17:37:37.251]  - attr(*, "where")=List of 5
[17:37:37.251]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:37.251]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:37.251]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:37.251]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:37.251]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:37.251]  - attr(*, "resolved")= logi FALSE
[17:37:37.251]  - attr(*, "total_size")= num 168
[17:37:37.251]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:37.251]  - attr(*, "already-done")= logi TRUE
[17:37:37.260] - copied ‘...future.FUN’ to environment
[17:37:37.260] - copied ‘MoreArgs’ to environment
[17:37:37.260] - copied ‘...future.elements_ii’ to environment
[17:37:37.260] - copied ‘...future.seeds_ii’ to environment
[17:37:37.260] - copied ‘...future.globals.maxSize’ to environment
[17:37:37.261] assign_globals() ... done
[17:37:37.261] requestCore(): workers = 2
[17:37:37.263] MulticoreFuture started
[17:37:37.264] - Launch lazy future ... done
[17:37:37.264] run() for ‘MulticoreFuture’ ... done
[17:37:37.264] plan(): Setting new future strategy stack:
[17:37:37.264] Created future:
[17:37:37.265] List of future strategies:
[17:37:37.265] 1. sequential:
[17:37:37.265]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:37.265]    - tweaked: FALSE
[17:37:37.265]    - call: NULL
[17:37:37.266] plan(): nbrOfWorkers() = 1
[17:37:37.268] plan(): Setting new future strategy stack:
[17:37:37.268] List of future strategies:
[17:37:37.268] 1. multicore:
[17:37:37.268]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:37.268]    - tweaked: FALSE
[17:37:37.268]    - call: plan(strategy)
[17:37:37.274] plan(): nbrOfWorkers() = 2
[17:37:37.265] MulticoreFuture:
[17:37:37.265] Label: ‘future_Map-1’
[17:37:37.265] Expression:
[17:37:37.265] {
[17:37:37.265]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:37.265]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:37.265]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:37.265]         on.exit(options(oopts), add = TRUE)
[17:37:37.265]     }
[17:37:37.265]     {
[17:37:37.265]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:37.265]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:37.265]         do.call(mapply, args = args)
[17:37:37.265]     }
[17:37:37.265] }
[17:37:37.265] Lazy evaluation: FALSE
[17:37:37.265] Asynchronous evaluation: TRUE
[17:37:37.265] Local evaluation: TRUE
[17:37:37.265] Environment: R_GlobalEnv
[17:37:37.265] Capture standard output: TRUE
[17:37:37.265] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:37.265] Globals: 5 objects totaling 168 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:37.265] Packages: <none>
[17:37:37.265] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:37.265] Resolved: TRUE
[17:37:37.265] Value: <not collected>
[17:37:37.265] Conditions captured: <none>
[17:37:37.265] Early signaling: FALSE
[17:37:37.265] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:37.265] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:37.276] Chunk #1 of 2 ... DONE
[17:37:37.276] Chunk #2 of 2 ...
[17:37:37.276]  - Finding globals in '...' for chunk #2 ...
[17:37:37.277] getGlobalsAndPackages() ...
[17:37:37.277] Searching for globals...
[17:37:37.278] 
[17:37:37.278] Searching for globals ... DONE
[17:37:37.278] - globals: [0] <none>
[17:37:37.278] getGlobalsAndPackages() ... DONE
[17:37:37.279]    + additional globals found: [n=0] 
[17:37:37.279]    + additional namespaces needed: [n=0] 
[17:37:37.279]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:37.279]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:37.279]  - seeds: <none>
[17:37:37.279]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:37.280] getGlobalsAndPackages() ...
[17:37:37.280] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:37.280] Resolving globals: FALSE
[17:37:37.281] The total size of the 5 globals is 280 bytes (280 bytes)
[17:37:37.282] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:37.282] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:37.282] 
[17:37:37.282] getGlobalsAndPackages() ... DONE
[17:37:37.283] run() for ‘Future’ ...
[17:37:37.283] - state: ‘created’
[17:37:37.283] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:37.288] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:37.288] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:37.288]   - Field: ‘label’
[17:37:37.288]   - Field: ‘local’
[17:37:37.289]   - Field: ‘owner’
[17:37:37.289]   - Field: ‘envir’
[17:37:37.289]   - Field: ‘workers’
[17:37:37.289]   - Field: ‘packages’
[17:37:37.289]   - Field: ‘gc’
[17:37:37.289]   - Field: ‘job’
[17:37:37.289]   - Field: ‘conditions’
[17:37:37.290]   - Field: ‘expr’
[17:37:37.290]   - Field: ‘uuid’
[17:37:37.290]   - Field: ‘seed’
[17:37:37.290]   - Field: ‘version’
[17:37:37.290]   - Field: ‘result’
[17:37:37.290]   - Field: ‘asynchronous’
[17:37:37.290]   - Field: ‘calls’
[17:37:37.291]   - Field: ‘globals’
[17:37:37.291]   - Field: ‘stdout’
[17:37:37.291]   - Field: ‘earlySignal’
[17:37:37.291]   - Field: ‘lazy’
[17:37:37.291]   - Field: ‘state’
[17:37:37.291] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:37.292] - Launch lazy future ...
[17:37:37.292] Packages needed by the future expression (n = 0): <none>
[17:37:37.292] Packages needed by future strategies (n = 0): <none>
[17:37:37.293] {
[17:37:37.293]     {
[17:37:37.293]         {
[17:37:37.293]             ...future.startTime <- base::Sys.time()
[17:37:37.293]             {
[17:37:37.293]                 {
[17:37:37.293]                   {
[17:37:37.293]                     {
[17:37:37.293]                       base::local({
[17:37:37.293]                         has_future <- base::requireNamespace("future", 
[17:37:37.293]                           quietly = TRUE)
[17:37:37.293]                         if (has_future) {
[17:37:37.293]                           ns <- base::getNamespace("future")
[17:37:37.293]                           version <- ns[[".package"]][["version"]]
[17:37:37.293]                           if (is.null(version)) 
[17:37:37.293]                             version <- utils::packageVersion("future")
[17:37:37.293]                         }
[17:37:37.293]                         else {
[17:37:37.293]                           version <- NULL
[17:37:37.293]                         }
[17:37:37.293]                         if (!has_future || version < "1.8.0") {
[17:37:37.293]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:37.293]                             "", base::R.version$version.string), 
[17:37:37.293]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:37.293]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:37.293]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:37.293]                               "release", "version")], collapse = " "), 
[17:37:37.293]                             hostname = base::Sys.info()[["nodename"]])
[17:37:37.293]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:37.293]                             info)
[17:37:37.293]                           info <- base::paste(info, collapse = "; ")
[17:37:37.293]                           if (!has_future) {
[17:37:37.293]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:37.293]                               info)
[17:37:37.293]                           }
[17:37:37.293]                           else {
[17:37:37.293]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:37.293]                               info, version)
[17:37:37.293]                           }
[17:37:37.293]                           base::stop(msg)
[17:37:37.293]                         }
[17:37:37.293]                       })
[17:37:37.293]                     }
[17:37:37.293]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:37.293]                     base::options(mc.cores = 1L)
[17:37:37.293]                   }
[17:37:37.293]                   ...future.strategy.old <- future::plan("list")
[17:37:37.293]                   options(future.plan = NULL)
[17:37:37.293]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:37.293]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:37.293]                 }
[17:37:37.293]                 ...future.workdir <- getwd()
[17:37:37.293]             }
[17:37:37.293]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:37.293]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:37.293]         }
[17:37:37.293]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:37.293]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:37.293]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:37.293]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:37.293]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:37.293]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:37.293]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:37.293]             base::names(...future.oldOptions))
[17:37:37.293]     }
[17:37:37.293]     if (FALSE) {
[17:37:37.293]     }
[17:37:37.293]     else {
[17:37:37.293]         if (TRUE) {
[17:37:37.293]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:37.293]                 open = "w")
[17:37:37.293]         }
[17:37:37.293]         else {
[17:37:37.293]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:37.293]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:37.293]         }
[17:37:37.293]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:37.293]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:37.293]             base::sink(type = "output", split = FALSE)
[17:37:37.293]             base::close(...future.stdout)
[17:37:37.293]         }, add = TRUE)
[17:37:37.293]     }
[17:37:37.293]     ...future.frame <- base::sys.nframe()
[17:37:37.293]     ...future.conditions <- base::list()
[17:37:37.293]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:37.293]     if (FALSE) {
[17:37:37.293]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:37.293]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:37.293]     }
[17:37:37.293]     ...future.result <- base::tryCatch({
[17:37:37.293]         base::withCallingHandlers({
[17:37:37.293]             ...future.value <- base::withVisible(base::local({
[17:37:37.293]                 withCallingHandlers({
[17:37:37.293]                   {
[17:37:37.293]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:37.293]                     if (!identical(...future.globals.maxSize.org, 
[17:37:37.293]                       ...future.globals.maxSize)) {
[17:37:37.293]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:37.293]                       on.exit(options(oopts), add = TRUE)
[17:37:37.293]                     }
[17:37:37.293]                     {
[17:37:37.293]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:37.293]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:37.293]                         USE.NAMES = FALSE)
[17:37:37.293]                       do.call(mapply, args = args)
[17:37:37.293]                     }
[17:37:37.293]                   }
[17:37:37.293]                 }, immediateCondition = function(cond) {
[17:37:37.293]                   save_rds <- function (object, pathname, ...) 
[17:37:37.293]                   {
[17:37:37.293]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:37.293]                     if (file_test("-f", pathname_tmp)) {
[17:37:37.293]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.293]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:37.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.293]                         fi_tmp[["mtime"]])
[17:37:37.293]                     }
[17:37:37.293]                     tryCatch({
[17:37:37.293]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:37.293]                     }, error = function(ex) {
[17:37:37.293]                       msg <- conditionMessage(ex)
[17:37:37.293]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.293]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:37.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.293]                         fi_tmp[["mtime"]], msg)
[17:37:37.293]                       ex$message <- msg
[17:37:37.293]                       stop(ex)
[17:37:37.293]                     })
[17:37:37.293]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:37.293]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:37.293]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:37.293]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.293]                       fi <- file.info(pathname)
[17:37:37.293]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:37.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.293]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:37.293]                         fi[["size"]], fi[["mtime"]])
[17:37:37.293]                       stop(msg)
[17:37:37.293]                     }
[17:37:37.293]                     invisible(pathname)
[17:37:37.293]                   }
[17:37:37.293]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:37.293]                     rootPath = tempdir()) 
[17:37:37.293]                   {
[17:37:37.293]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:37.293]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:37.293]                       tmpdir = path, fileext = ".rds")
[17:37:37.293]                     save_rds(obj, file)
[17:37:37.293]                   }
[17:37:37.293]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:37.293]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.293]                   {
[17:37:37.293]                     inherits <- base::inherits
[17:37:37.293]                     invokeRestart <- base::invokeRestart
[17:37:37.293]                     is.null <- base::is.null
[17:37:37.293]                     muffled <- FALSE
[17:37:37.293]                     if (inherits(cond, "message")) {
[17:37:37.293]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:37.293]                       if (muffled) 
[17:37:37.293]                         invokeRestart("muffleMessage")
[17:37:37.293]                     }
[17:37:37.293]                     else if (inherits(cond, "warning")) {
[17:37:37.293]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:37.293]                       if (muffled) 
[17:37:37.293]                         invokeRestart("muffleWarning")
[17:37:37.293]                     }
[17:37:37.293]                     else if (inherits(cond, "condition")) {
[17:37:37.293]                       if (!is.null(pattern)) {
[17:37:37.293]                         computeRestarts <- base::computeRestarts
[17:37:37.293]                         grepl <- base::grepl
[17:37:37.293]                         restarts <- computeRestarts(cond)
[17:37:37.293]                         for (restart in restarts) {
[17:37:37.293]                           name <- restart$name
[17:37:37.293]                           if (is.null(name)) 
[17:37:37.293]                             next
[17:37:37.293]                           if (!grepl(pattern, name)) 
[17:37:37.293]                             next
[17:37:37.293]                           invokeRestart(restart)
[17:37:37.293]                           muffled <- TRUE
[17:37:37.293]                           break
[17:37:37.293]                         }
[17:37:37.293]                       }
[17:37:37.293]                     }
[17:37:37.293]                     invisible(muffled)
[17:37:37.293]                   }
[17:37:37.293]                   muffleCondition(cond)
[17:37:37.293]                 })
[17:37:37.293]             }))
[17:37:37.293]             future::FutureResult(value = ...future.value$value, 
[17:37:37.293]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:37.293]                   ...future.rng), globalenv = if (FALSE) 
[17:37:37.293]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:37.293]                     ...future.globalenv.names))
[17:37:37.293]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:37.293]         }, condition = base::local({
[17:37:37.293]             c <- base::c
[17:37:37.293]             inherits <- base::inherits
[17:37:37.293]             invokeRestart <- base::invokeRestart
[17:37:37.293]             length <- base::length
[17:37:37.293]             list <- base::list
[17:37:37.293]             seq.int <- base::seq.int
[17:37:37.293]             signalCondition <- base::signalCondition
[17:37:37.293]             sys.calls <- base::sys.calls
[17:37:37.293]             `[[` <- base::`[[`
[17:37:37.293]             `+` <- base::`+`
[17:37:37.293]             `<<-` <- base::`<<-`
[17:37:37.293]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:37.293]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:37.293]                   3L)]
[17:37:37.293]             }
[17:37:37.293]             function(cond) {
[17:37:37.293]                 is_error <- inherits(cond, "error")
[17:37:37.293]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:37.293]                   NULL)
[17:37:37.293]                 if (is_error) {
[17:37:37.293]                   sessionInformation <- function() {
[17:37:37.293]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:37.293]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:37.293]                       search = base::search(), system = base::Sys.info())
[17:37:37.293]                   }
[17:37:37.293]                   ...future.conditions[[length(...future.conditions) + 
[17:37:37.293]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:37.293]                     cond$call), session = sessionInformation(), 
[17:37:37.293]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:37.293]                   signalCondition(cond)
[17:37:37.293]                 }
[17:37:37.293]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:37.293]                 "immediateCondition"))) {
[17:37:37.293]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:37.293]                   ...future.conditions[[length(...future.conditions) + 
[17:37:37.293]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:37.293]                   if (TRUE && !signal) {
[17:37:37.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.293]                     {
[17:37:37.293]                       inherits <- base::inherits
[17:37:37.293]                       invokeRestart <- base::invokeRestart
[17:37:37.293]                       is.null <- base::is.null
[17:37:37.293]                       muffled <- FALSE
[17:37:37.293]                       if (inherits(cond, "message")) {
[17:37:37.293]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:37.293]                         if (muffled) 
[17:37:37.293]                           invokeRestart("muffleMessage")
[17:37:37.293]                       }
[17:37:37.293]                       else if (inherits(cond, "warning")) {
[17:37:37.293]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:37.293]                         if (muffled) 
[17:37:37.293]                           invokeRestart("muffleWarning")
[17:37:37.293]                       }
[17:37:37.293]                       else if (inherits(cond, "condition")) {
[17:37:37.293]                         if (!is.null(pattern)) {
[17:37:37.293]                           computeRestarts <- base::computeRestarts
[17:37:37.293]                           grepl <- base::grepl
[17:37:37.293]                           restarts <- computeRestarts(cond)
[17:37:37.293]                           for (restart in restarts) {
[17:37:37.293]                             name <- restart$name
[17:37:37.293]                             if (is.null(name)) 
[17:37:37.293]                               next
[17:37:37.293]                             if (!grepl(pattern, name)) 
[17:37:37.293]                               next
[17:37:37.293]                             invokeRestart(restart)
[17:37:37.293]                             muffled <- TRUE
[17:37:37.293]                             break
[17:37:37.293]                           }
[17:37:37.293]                         }
[17:37:37.293]                       }
[17:37:37.293]                       invisible(muffled)
[17:37:37.293]                     }
[17:37:37.293]                     muffleCondition(cond, pattern = "^muffle")
[17:37:37.293]                   }
[17:37:37.293]                 }
[17:37:37.293]                 else {
[17:37:37.293]                   if (TRUE) {
[17:37:37.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.293]                     {
[17:37:37.293]                       inherits <- base::inherits
[17:37:37.293]                       invokeRestart <- base::invokeRestart
[17:37:37.293]                       is.null <- base::is.null
[17:37:37.293]                       muffled <- FALSE
[17:37:37.293]                       if (inherits(cond, "message")) {
[17:37:37.293]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:37.293]                         if (muffled) 
[17:37:37.293]                           invokeRestart("muffleMessage")
[17:37:37.293]                       }
[17:37:37.293]                       else if (inherits(cond, "warning")) {
[17:37:37.293]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:37.293]                         if (muffled) 
[17:37:37.293]                           invokeRestart("muffleWarning")
[17:37:37.293]                       }
[17:37:37.293]                       else if (inherits(cond, "condition")) {
[17:37:37.293]                         if (!is.null(pattern)) {
[17:37:37.293]                           computeRestarts <- base::computeRestarts
[17:37:37.293]                           grepl <- base::grepl
[17:37:37.293]                           restarts <- computeRestarts(cond)
[17:37:37.293]                           for (restart in restarts) {
[17:37:37.293]                             name <- restart$name
[17:37:37.293]                             if (is.null(name)) 
[17:37:37.293]                               next
[17:37:37.293]                             if (!grepl(pattern, name)) 
[17:37:37.293]                               next
[17:37:37.293]                             invokeRestart(restart)
[17:37:37.293]                             muffled <- TRUE
[17:37:37.293]                             break
[17:37:37.293]                           }
[17:37:37.293]                         }
[17:37:37.293]                       }
[17:37:37.293]                       invisible(muffled)
[17:37:37.293]                     }
[17:37:37.293]                     muffleCondition(cond, pattern = "^muffle")
[17:37:37.293]                   }
[17:37:37.293]                 }
[17:37:37.293]             }
[17:37:37.293]         }))
[17:37:37.293]     }, error = function(ex) {
[17:37:37.293]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:37.293]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:37.293]                 ...future.rng), started = ...future.startTime, 
[17:37:37.293]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:37.293]             version = "1.8"), class = "FutureResult")
[17:37:37.293]     }, finally = {
[17:37:37.293]         if (!identical(...future.workdir, getwd())) 
[17:37:37.293]             setwd(...future.workdir)
[17:37:37.293]         {
[17:37:37.293]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:37.293]                 ...future.oldOptions$nwarnings <- NULL
[17:37:37.293]             }
[17:37:37.293]             base::options(...future.oldOptions)
[17:37:37.293]             if (.Platform$OS.type == "windows") {
[17:37:37.293]                 old_names <- names(...future.oldEnvVars)
[17:37:37.293]                 envs <- base::Sys.getenv()
[17:37:37.293]                 names <- names(envs)
[17:37:37.293]                 common <- intersect(names, old_names)
[17:37:37.293]                 added <- setdiff(names, old_names)
[17:37:37.293]                 removed <- setdiff(old_names, names)
[17:37:37.293]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:37.293]                   envs[common]]
[17:37:37.293]                 NAMES <- toupper(changed)
[17:37:37.293]                 args <- list()
[17:37:37.293]                 for (kk in seq_along(NAMES)) {
[17:37:37.293]                   name <- changed[[kk]]
[17:37:37.293]                   NAME <- NAMES[[kk]]
[17:37:37.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.293]                     next
[17:37:37.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:37.293]                 }
[17:37:37.293]                 NAMES <- toupper(added)
[17:37:37.293]                 for (kk in seq_along(NAMES)) {
[17:37:37.293]                   name <- added[[kk]]
[17:37:37.293]                   NAME <- NAMES[[kk]]
[17:37:37.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.293]                     next
[17:37:37.293]                   args[[name]] <- ""
[17:37:37.293]                 }
[17:37:37.293]                 NAMES <- toupper(removed)
[17:37:37.293]                 for (kk in seq_along(NAMES)) {
[17:37:37.293]                   name <- removed[[kk]]
[17:37:37.293]                   NAME <- NAMES[[kk]]
[17:37:37.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.293]                     next
[17:37:37.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:37.293]                 }
[17:37:37.293]                 if (length(args) > 0) 
[17:37:37.293]                   base::do.call(base::Sys.setenv, args = args)
[17:37:37.293]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:37.293]             }
[17:37:37.293]             else {
[17:37:37.293]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:37.293]             }
[17:37:37.293]             {
[17:37:37.293]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:37.293]                   0L) {
[17:37:37.293]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:37.293]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:37.293]                   base::options(opts)
[17:37:37.293]                 }
[17:37:37.293]                 {
[17:37:37.293]                   {
[17:37:37.293]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:37.293]                     NULL
[17:37:37.293]                   }
[17:37:37.293]                   options(future.plan = NULL)
[17:37:37.293]                   if (is.na(NA_character_)) 
[17:37:37.293]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:37.293]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:37.293]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:37.293]                     .init = FALSE)
[17:37:37.293]                 }
[17:37:37.293]             }
[17:37:37.293]         }
[17:37:37.293]     })
[17:37:37.293]     if (TRUE) {
[17:37:37.293]         base::sink(type = "output", split = FALSE)
[17:37:37.293]         if (TRUE) {
[17:37:37.293]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:37.293]         }
[17:37:37.293]         else {
[17:37:37.293]             ...future.result["stdout"] <- base::list(NULL)
[17:37:37.293]         }
[17:37:37.293]         base::close(...future.stdout)
[17:37:37.293]         ...future.stdout <- NULL
[17:37:37.293]     }
[17:37:37.293]     ...future.result$conditions <- ...future.conditions
[17:37:37.293]     ...future.result$finished <- base::Sys.time()
[17:37:37.293]     ...future.result
[17:37:37.293] }
[17:37:37.296] assign_globals() ...
[17:37:37.297] List of 5
[17:37:37.297]  $ ...future.FUN            :function (e1, e2)  
[17:37:37.297]  $ MoreArgs                 : NULL
[17:37:37.297]  $ ...future.elements_ii    :List of 2
[17:37:37.297]   ..$ :List of 2
[17:37:37.297]   .. ..$ : num 1
[17:37:37.297]   .. ..$ : num 1
[17:37:37.297]   ..$ :List of 2
[17:37:37.297]   .. ..$ : int 2
[17:37:37.297]   .. ..$ : int 3
[17:37:37.297]  $ ...future.seeds_ii       : NULL
[17:37:37.297]  $ ...future.globals.maxSize: NULL
[17:37:37.297]  - attr(*, "where")=List of 5
[17:37:37.297]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:37.297]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:37.297]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:37.297]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:37.297]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:37.297]  - attr(*, "resolved")= logi FALSE
[17:37:37.297]  - attr(*, "total_size")= num 280
[17:37:37.297]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:37.297]  - attr(*, "already-done")= logi TRUE
[17:37:37.310] - copied ‘...future.FUN’ to environment
[17:37:37.310] - copied ‘MoreArgs’ to environment
[17:37:37.311] - copied ‘...future.elements_ii’ to environment
[17:37:37.311] - copied ‘...future.seeds_ii’ to environment
[17:37:37.311] - copied ‘...future.globals.maxSize’ to environment
[17:37:37.311] assign_globals() ... done
[17:37:37.311] requestCore(): workers = 2
[17:37:37.314] MulticoreFuture started
[17:37:37.314] - Launch lazy future ... done
[17:37:37.315] plan(): Setting new future strategy stack:
[17:37:37.315] run() for ‘MulticoreFuture’ ... done
[17:37:37.316] Created future:
[17:37:37.315] List of future strategies:
[17:37:37.315] 1. sequential:
[17:37:37.315]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:37.315]    - tweaked: FALSE
[17:37:37.315]    - call: NULL
[17:37:37.317] plan(): nbrOfWorkers() = 1
[17:37:37.319] plan(): Setting new future strategy stack:
[17:37:37.320] List of future strategies:
[17:37:37.320] 1. multicore:
[17:37:37.320]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:37.320]    - tweaked: FALSE
[17:37:37.320]    - call: plan(strategy)
[17:37:37.325] plan(): nbrOfWorkers() = 2
[17:37:37.316] MulticoreFuture:
[17:37:37.316] Label: ‘future_Map-2’
[17:37:37.316] Expression:
[17:37:37.316] {
[17:37:37.316]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:37.316]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:37.316]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:37.316]         on.exit(options(oopts), add = TRUE)
[17:37:37.316]     }
[17:37:37.316]     {
[17:37:37.316]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:37.316]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:37.316]         do.call(mapply, args = args)
[17:37:37.316]     }
[17:37:37.316] }
[17:37:37.316] Lazy evaluation: FALSE
[17:37:37.316] Asynchronous evaluation: TRUE
[17:37:37.316] Local evaluation: TRUE
[17:37:37.316] Environment: R_GlobalEnv
[17:37:37.316] Capture standard output: TRUE
[17:37:37.316] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:37.316] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:37.316] Packages: <none>
[17:37:37.316] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:37.316] Resolved: TRUE
[17:37:37.316] Value: <not collected>
[17:37:37.316] Conditions captured: <none>
[17:37:37.316] Early signaling: FALSE
[17:37:37.316] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:37.316] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:37.326] Chunk #2 of 2 ... DONE
[17:37:37.326] Launching 2 futures (chunks) ... DONE
[17:37:37.327] Resolving 2 futures (chunks) ...
[17:37:37.327] resolve() on list ...
[17:37:37.327]  recursive: 0
[17:37:37.327]  length: 2
[17:37:37.327] 
[17:37:37.328] Future #1
[17:37:37.328] result() for MulticoreFuture ...
[17:37:37.329] result() for MulticoreFuture ...
[17:37:37.329] result() for MulticoreFuture ... done
[17:37:37.329] result() for MulticoreFuture ... done
[17:37:37.329] result() for MulticoreFuture ...
[17:37:37.329] result() for MulticoreFuture ... done
[17:37:37.330] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:37:37.330] - nx: 2
[17:37:37.330] - relay: TRUE
[17:37:37.330] - stdout: TRUE
[17:37:37.330] - signal: TRUE
[17:37:37.330] - resignal: FALSE
[17:37:37.331] - force: TRUE
[17:37:37.331] - relayed: [n=2] FALSE, FALSE
[17:37:37.331] - queued futures: [n=2] FALSE, FALSE
[17:37:37.331]  - until=1
[17:37:37.331]  - relaying element #1
[17:37:37.331] result() for MulticoreFuture ...
[17:37:37.332] result() for MulticoreFuture ... done
[17:37:37.332] result() for MulticoreFuture ...
[17:37:37.332] result() for MulticoreFuture ... done
[17:37:37.332] result() for MulticoreFuture ...
[17:37:37.332] result() for MulticoreFuture ... done
[17:37:37.332] result() for MulticoreFuture ...
[17:37:37.333] result() for MulticoreFuture ... done
[17:37:37.333] - relayed: [n=2] TRUE, FALSE
[17:37:37.333] - queued futures: [n=2] TRUE, FALSE
[17:37:37.333] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:37:37.333]  length: 1 (resolved future 1)
[17:37:37.334] Future #2
[17:37:37.334] result() for MulticoreFuture ...
[17:37:37.334] result() for MulticoreFuture ...
[17:37:37.335] result() for MulticoreFuture ... done
[17:37:37.335] result() for MulticoreFuture ... done
[17:37:37.335] result() for MulticoreFuture ...
[17:37:37.335] result() for MulticoreFuture ... done
[17:37:37.335] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:37:37.335] - nx: 2
[17:37:37.335] - relay: TRUE
[17:37:37.336] - stdout: TRUE
[17:37:37.336] - signal: TRUE
[17:37:37.336] - resignal: FALSE
[17:37:37.336] - force: TRUE
[17:37:37.336] - relayed: [n=2] TRUE, FALSE
[17:37:37.336] - queued futures: [n=2] TRUE, FALSE
[17:37:37.336]  - until=2
[17:37:37.336]  - relaying element #2
[17:37:37.337] result() for MulticoreFuture ...
[17:37:37.337] result() for MulticoreFuture ... done
[17:37:37.337] result() for MulticoreFuture ...
[17:37:37.337] result() for MulticoreFuture ... done
[17:37:37.337] result() for MulticoreFuture ...
[17:37:37.337] result() for MulticoreFuture ... done
[17:37:37.337] result() for MulticoreFuture ...
[17:37:37.337] result() for MulticoreFuture ... done
[17:37:37.338] - relayed: [n=2] TRUE, TRUE
[17:37:37.338] - queued futures: [n=2] TRUE, TRUE
[17:37:37.338] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:37:37.338]  length: 0 (resolved future 2)
[17:37:37.338] Relaying remaining futures
[17:37:37.338] signalConditionsASAP(NULL, pos=0) ...
[17:37:37.338] - nx: 2
[17:37:37.338] - relay: TRUE
[17:37:37.338] - stdout: TRUE
[17:37:37.339] - signal: TRUE
[17:37:37.339] - resignal: FALSE
[17:37:37.339] - force: TRUE
[17:37:37.339] - relayed: [n=2] TRUE, TRUE
[17:37:37.339] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:37.339] - relayed: [n=2] TRUE, TRUE
[17:37:37.339] - queued futures: [n=2] TRUE, TRUE
[17:37:37.339] signalConditionsASAP(NULL, pos=0) ... done
[17:37:37.339] resolve() on list ... DONE
[17:37:37.340] result() for MulticoreFuture ...
[17:37:37.340] result() for MulticoreFuture ... done
[17:37:37.340] result() for MulticoreFuture ...
[17:37:37.340] result() for MulticoreFuture ... done
[17:37:37.340] result() for MulticoreFuture ...
[17:37:37.340] result() for MulticoreFuture ... done
[17:37:37.340] result() for MulticoreFuture ...
[17:37:37.340] result() for MulticoreFuture ... done
[17:37:37.341]  - Number of value chunks collected: 2
[17:37:37.341] Resolving 2 futures (chunks) ... DONE
[17:37:37.341] Reducing values from 2 chunks ...
[17:37:37.341]  - Number of values collected after concatenation: 3
[17:37:37.341]  - Number of values expected: 3
[17:37:37.341] Reducing values from 2 chunks ... DONE
[17:37:37.341] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[17:37:37.342] future_mapply() ...
[17:37:37.350] Number of chunks: 2
[17:37:37.350] getGlobalsAndPackagesXApply() ...
[17:37:37.350]  - future.globals: TRUE
[17:37:37.350] getGlobalsAndPackages() ...
[17:37:37.350] Searching for globals...
[17:37:37.352] - globals found: [1] ‘FUN’
[17:37:37.352] Searching for globals ... DONE
[17:37:37.352] Resolving globals: FALSE
[17:37:37.353] The total size of the 1 globals is 848 bytes (848 bytes)
[17:37:37.353] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:37:37.353] - globals: [1] ‘FUN’
[17:37:37.353] 
[17:37:37.353] getGlobalsAndPackages() ... DONE
[17:37:37.354]  - globals found/used: [n=1] ‘FUN’
[17:37:37.354]  - needed namespaces: [n=0] 
[17:37:37.354] Finding globals ... DONE
[17:37:37.354] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:37.354] List of 2
[17:37:37.354]  $ ...future.FUN:function (x)  
[17:37:37.354]  $ MoreArgs     : NULL
[17:37:37.354]  - attr(*, "where")=List of 2
[17:37:37.354]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:37.354]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:37.354]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:37.354]  - attr(*, "resolved")= logi FALSE
[17:37:37.354]  - attr(*, "total_size")= num NA
[17:37:37.358] Packages to be attached in all futures: [n=0] 
[17:37:37.358] getGlobalsAndPackagesXApply() ... DONE
[17:37:37.358] Number of futures (= number of chunks): 2
[17:37:37.358] Launching 2 futures (chunks) ...
[17:37:37.358] Chunk #1 of 2 ...
[17:37:37.358]  - Finding globals in '...' for chunk #1 ...
[17:37:37.358] getGlobalsAndPackages() ...
[17:37:37.358] Searching for globals...
[17:37:37.359] 
[17:37:37.359] Searching for globals ... DONE
[17:37:37.359] - globals: [0] <none>
[17:37:37.359] getGlobalsAndPackages() ... DONE
[17:37:37.359]    + additional globals found: [n=0] 
[17:37:37.359]    + additional namespaces needed: [n=0] 
[17:37:37.359]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:37.359]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:37.360]  - seeds: <none>
[17:37:37.360]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:37.360] getGlobalsAndPackages() ...
[17:37:37.360] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:37.360] Resolving globals: FALSE
[17:37:37.360] The total size of the 5 globals is 904 bytes (904 bytes)
[17:37:37.361] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:37.361] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:37.361] 
[17:37:37.361] getGlobalsAndPackages() ... DONE
[17:37:37.362] run() for ‘Future’ ...
[17:37:37.362] - state: ‘created’
[17:37:37.362] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:37.366] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:37.366] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:37.366]   - Field: ‘label’
[17:37:37.366]   - Field: ‘local’
[17:37:37.366]   - Field: ‘owner’
[17:37:37.366]   - Field: ‘envir’
[17:37:37.366]   - Field: ‘workers’
[17:37:37.366]   - Field: ‘packages’
[17:37:37.366]   - Field: ‘gc’
[17:37:37.367]   - Field: ‘job’
[17:37:37.367]   - Field: ‘conditions’
[17:37:37.367]   - Field: ‘expr’
[17:37:37.367]   - Field: ‘uuid’
[17:37:37.367]   - Field: ‘seed’
[17:37:37.367]   - Field: ‘version’
[17:37:37.367]   - Field: ‘result’
[17:37:37.367]   - Field: ‘asynchronous’
[17:37:37.367]   - Field: ‘calls’
[17:37:37.367]   - Field: ‘globals’
[17:37:37.368]   - Field: ‘stdout’
[17:37:37.368]   - Field: ‘earlySignal’
[17:37:37.368]   - Field: ‘lazy’
[17:37:37.368]   - Field: ‘state’
[17:37:37.368] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:37.368] - Launch lazy future ...
[17:37:37.368] Packages needed by the future expression (n = 0): <none>
[17:37:37.368] Packages needed by future strategies (n = 0): <none>
[17:37:37.369] {
[17:37:37.369]     {
[17:37:37.369]         {
[17:37:37.369]             ...future.startTime <- base::Sys.time()
[17:37:37.369]             {
[17:37:37.369]                 {
[17:37:37.369]                   {
[17:37:37.369]                     {
[17:37:37.369]                       base::local({
[17:37:37.369]                         has_future <- base::requireNamespace("future", 
[17:37:37.369]                           quietly = TRUE)
[17:37:37.369]                         if (has_future) {
[17:37:37.369]                           ns <- base::getNamespace("future")
[17:37:37.369]                           version <- ns[[".package"]][["version"]]
[17:37:37.369]                           if (is.null(version)) 
[17:37:37.369]                             version <- utils::packageVersion("future")
[17:37:37.369]                         }
[17:37:37.369]                         else {
[17:37:37.369]                           version <- NULL
[17:37:37.369]                         }
[17:37:37.369]                         if (!has_future || version < "1.8.0") {
[17:37:37.369]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:37.369]                             "", base::R.version$version.string), 
[17:37:37.369]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:37.369]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:37.369]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:37.369]                               "release", "version")], collapse = " "), 
[17:37:37.369]                             hostname = base::Sys.info()[["nodename"]])
[17:37:37.369]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:37.369]                             info)
[17:37:37.369]                           info <- base::paste(info, collapse = "; ")
[17:37:37.369]                           if (!has_future) {
[17:37:37.369]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:37.369]                               info)
[17:37:37.369]                           }
[17:37:37.369]                           else {
[17:37:37.369]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:37.369]                               info, version)
[17:37:37.369]                           }
[17:37:37.369]                           base::stop(msg)
[17:37:37.369]                         }
[17:37:37.369]                       })
[17:37:37.369]                     }
[17:37:37.369]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:37.369]                     base::options(mc.cores = 1L)
[17:37:37.369]                   }
[17:37:37.369]                   ...future.strategy.old <- future::plan("list")
[17:37:37.369]                   options(future.plan = NULL)
[17:37:37.369]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:37.369]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:37.369]                 }
[17:37:37.369]                 ...future.workdir <- getwd()
[17:37:37.369]             }
[17:37:37.369]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:37.369]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:37.369]         }
[17:37:37.369]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:37.369]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:37.369]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:37.369]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:37.369]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:37.369]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:37.369]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:37.369]             base::names(...future.oldOptions))
[17:37:37.369]     }
[17:37:37.369]     if (FALSE) {
[17:37:37.369]     }
[17:37:37.369]     else {
[17:37:37.369]         if (TRUE) {
[17:37:37.369]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:37.369]                 open = "w")
[17:37:37.369]         }
[17:37:37.369]         else {
[17:37:37.369]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:37.369]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:37.369]         }
[17:37:37.369]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:37.369]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:37.369]             base::sink(type = "output", split = FALSE)
[17:37:37.369]             base::close(...future.stdout)
[17:37:37.369]         }, add = TRUE)
[17:37:37.369]     }
[17:37:37.369]     ...future.frame <- base::sys.nframe()
[17:37:37.369]     ...future.conditions <- base::list()
[17:37:37.369]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:37.369]     if (FALSE) {
[17:37:37.369]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:37.369]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:37.369]     }
[17:37:37.369]     ...future.result <- base::tryCatch({
[17:37:37.369]         base::withCallingHandlers({
[17:37:37.369]             ...future.value <- base::withVisible(base::local({
[17:37:37.369]                 withCallingHandlers({
[17:37:37.369]                   {
[17:37:37.369]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:37.369]                     if (!identical(...future.globals.maxSize.org, 
[17:37:37.369]                       ...future.globals.maxSize)) {
[17:37:37.369]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:37.369]                       on.exit(options(oopts), add = TRUE)
[17:37:37.369]                     }
[17:37:37.369]                     {
[17:37:37.369]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:37.369]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:37.369]                         USE.NAMES = FALSE)
[17:37:37.369]                       do.call(mapply, args = args)
[17:37:37.369]                     }
[17:37:37.369]                   }
[17:37:37.369]                 }, immediateCondition = function(cond) {
[17:37:37.369]                   save_rds <- function (object, pathname, ...) 
[17:37:37.369]                   {
[17:37:37.369]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:37.369]                     if (file_test("-f", pathname_tmp)) {
[17:37:37.369]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.369]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:37.369]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.369]                         fi_tmp[["mtime"]])
[17:37:37.369]                     }
[17:37:37.369]                     tryCatch({
[17:37:37.369]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:37.369]                     }, error = function(ex) {
[17:37:37.369]                       msg <- conditionMessage(ex)
[17:37:37.369]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.369]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:37.369]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.369]                         fi_tmp[["mtime"]], msg)
[17:37:37.369]                       ex$message <- msg
[17:37:37.369]                       stop(ex)
[17:37:37.369]                     })
[17:37:37.369]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:37.369]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:37.369]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:37.369]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.369]                       fi <- file.info(pathname)
[17:37:37.369]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:37.369]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.369]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:37.369]                         fi[["size"]], fi[["mtime"]])
[17:37:37.369]                       stop(msg)
[17:37:37.369]                     }
[17:37:37.369]                     invisible(pathname)
[17:37:37.369]                   }
[17:37:37.369]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:37.369]                     rootPath = tempdir()) 
[17:37:37.369]                   {
[17:37:37.369]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:37.369]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:37.369]                       tmpdir = path, fileext = ".rds")
[17:37:37.369]                     save_rds(obj, file)
[17:37:37.369]                   }
[17:37:37.369]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:37.369]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.369]                   {
[17:37:37.369]                     inherits <- base::inherits
[17:37:37.369]                     invokeRestart <- base::invokeRestart
[17:37:37.369]                     is.null <- base::is.null
[17:37:37.369]                     muffled <- FALSE
[17:37:37.369]                     if (inherits(cond, "message")) {
[17:37:37.369]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:37.369]                       if (muffled) 
[17:37:37.369]                         invokeRestart("muffleMessage")
[17:37:37.369]                     }
[17:37:37.369]                     else if (inherits(cond, "warning")) {
[17:37:37.369]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:37.369]                       if (muffled) 
[17:37:37.369]                         invokeRestart("muffleWarning")
[17:37:37.369]                     }
[17:37:37.369]                     else if (inherits(cond, "condition")) {
[17:37:37.369]                       if (!is.null(pattern)) {
[17:37:37.369]                         computeRestarts <- base::computeRestarts
[17:37:37.369]                         grepl <- base::grepl
[17:37:37.369]                         restarts <- computeRestarts(cond)
[17:37:37.369]                         for (restart in restarts) {
[17:37:37.369]                           name <- restart$name
[17:37:37.369]                           if (is.null(name)) 
[17:37:37.369]                             next
[17:37:37.369]                           if (!grepl(pattern, name)) 
[17:37:37.369]                             next
[17:37:37.369]                           invokeRestart(restart)
[17:37:37.369]                           muffled <- TRUE
[17:37:37.369]                           break
[17:37:37.369]                         }
[17:37:37.369]                       }
[17:37:37.369]                     }
[17:37:37.369]                     invisible(muffled)
[17:37:37.369]                   }
[17:37:37.369]                   muffleCondition(cond)
[17:37:37.369]                 })
[17:37:37.369]             }))
[17:37:37.369]             future::FutureResult(value = ...future.value$value, 
[17:37:37.369]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:37.369]                   ...future.rng), globalenv = if (FALSE) 
[17:37:37.369]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:37.369]                     ...future.globalenv.names))
[17:37:37.369]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:37.369]         }, condition = base::local({
[17:37:37.369]             c <- base::c
[17:37:37.369]             inherits <- base::inherits
[17:37:37.369]             invokeRestart <- base::invokeRestart
[17:37:37.369]             length <- base::length
[17:37:37.369]             list <- base::list
[17:37:37.369]             seq.int <- base::seq.int
[17:37:37.369]             signalCondition <- base::signalCondition
[17:37:37.369]             sys.calls <- base::sys.calls
[17:37:37.369]             `[[` <- base::`[[`
[17:37:37.369]             `+` <- base::`+`
[17:37:37.369]             `<<-` <- base::`<<-`
[17:37:37.369]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:37.369]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:37.369]                   3L)]
[17:37:37.369]             }
[17:37:37.369]             function(cond) {
[17:37:37.369]                 is_error <- inherits(cond, "error")
[17:37:37.369]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:37.369]                   NULL)
[17:37:37.369]                 if (is_error) {
[17:37:37.369]                   sessionInformation <- function() {
[17:37:37.369]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:37.369]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:37.369]                       search = base::search(), system = base::Sys.info())
[17:37:37.369]                   }
[17:37:37.369]                   ...future.conditions[[length(...future.conditions) + 
[17:37:37.369]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:37.369]                     cond$call), session = sessionInformation(), 
[17:37:37.369]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:37.369]                   signalCondition(cond)
[17:37:37.369]                 }
[17:37:37.369]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:37.369]                 "immediateCondition"))) {
[17:37:37.369]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:37.369]                   ...future.conditions[[length(...future.conditions) + 
[17:37:37.369]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:37.369]                   if (TRUE && !signal) {
[17:37:37.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.369]                     {
[17:37:37.369]                       inherits <- base::inherits
[17:37:37.369]                       invokeRestart <- base::invokeRestart
[17:37:37.369]                       is.null <- base::is.null
[17:37:37.369]                       muffled <- FALSE
[17:37:37.369]                       if (inherits(cond, "message")) {
[17:37:37.369]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:37.369]                         if (muffled) 
[17:37:37.369]                           invokeRestart("muffleMessage")
[17:37:37.369]                       }
[17:37:37.369]                       else if (inherits(cond, "warning")) {
[17:37:37.369]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:37.369]                         if (muffled) 
[17:37:37.369]                           invokeRestart("muffleWarning")
[17:37:37.369]                       }
[17:37:37.369]                       else if (inherits(cond, "condition")) {
[17:37:37.369]                         if (!is.null(pattern)) {
[17:37:37.369]                           computeRestarts <- base::computeRestarts
[17:37:37.369]                           grepl <- base::grepl
[17:37:37.369]                           restarts <- computeRestarts(cond)
[17:37:37.369]                           for (restart in restarts) {
[17:37:37.369]                             name <- restart$name
[17:37:37.369]                             if (is.null(name)) 
[17:37:37.369]                               next
[17:37:37.369]                             if (!grepl(pattern, name)) 
[17:37:37.369]                               next
[17:37:37.369]                             invokeRestart(restart)
[17:37:37.369]                             muffled <- TRUE
[17:37:37.369]                             break
[17:37:37.369]                           }
[17:37:37.369]                         }
[17:37:37.369]                       }
[17:37:37.369]                       invisible(muffled)
[17:37:37.369]                     }
[17:37:37.369]                     muffleCondition(cond, pattern = "^muffle")
[17:37:37.369]                   }
[17:37:37.369]                 }
[17:37:37.369]                 else {
[17:37:37.369]                   if (TRUE) {
[17:37:37.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.369]                     {
[17:37:37.369]                       inherits <- base::inherits
[17:37:37.369]                       invokeRestart <- base::invokeRestart
[17:37:37.369]                       is.null <- base::is.null
[17:37:37.369]                       muffled <- FALSE
[17:37:37.369]                       if (inherits(cond, "message")) {
[17:37:37.369]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:37.369]                         if (muffled) 
[17:37:37.369]                           invokeRestart("muffleMessage")
[17:37:37.369]                       }
[17:37:37.369]                       else if (inherits(cond, "warning")) {
[17:37:37.369]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:37.369]                         if (muffled) 
[17:37:37.369]                           invokeRestart("muffleWarning")
[17:37:37.369]                       }
[17:37:37.369]                       else if (inherits(cond, "condition")) {
[17:37:37.369]                         if (!is.null(pattern)) {
[17:37:37.369]                           computeRestarts <- base::computeRestarts
[17:37:37.369]                           grepl <- base::grepl
[17:37:37.369]                           restarts <- computeRestarts(cond)
[17:37:37.369]                           for (restart in restarts) {
[17:37:37.369]                             name <- restart$name
[17:37:37.369]                             if (is.null(name)) 
[17:37:37.369]                               next
[17:37:37.369]                             if (!grepl(pattern, name)) 
[17:37:37.369]                               next
[17:37:37.369]                             invokeRestart(restart)
[17:37:37.369]                             muffled <- TRUE
[17:37:37.369]                             break
[17:37:37.369]                           }
[17:37:37.369]                         }
[17:37:37.369]                       }
[17:37:37.369]                       invisible(muffled)
[17:37:37.369]                     }
[17:37:37.369]                     muffleCondition(cond, pattern = "^muffle")
[17:37:37.369]                   }
[17:37:37.369]                 }
[17:37:37.369]             }
[17:37:37.369]         }))
[17:37:37.369]     }, error = function(ex) {
[17:37:37.369]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:37.369]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:37.369]                 ...future.rng), started = ...future.startTime, 
[17:37:37.369]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:37.369]             version = "1.8"), class = "FutureResult")
[17:37:37.369]     }, finally = {
[17:37:37.369]         if (!identical(...future.workdir, getwd())) 
[17:37:37.369]             setwd(...future.workdir)
[17:37:37.369]         {
[17:37:37.369]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:37.369]                 ...future.oldOptions$nwarnings <- NULL
[17:37:37.369]             }
[17:37:37.369]             base::options(...future.oldOptions)
[17:37:37.369]             if (.Platform$OS.type == "windows") {
[17:37:37.369]                 old_names <- names(...future.oldEnvVars)
[17:37:37.369]                 envs <- base::Sys.getenv()
[17:37:37.369]                 names <- names(envs)
[17:37:37.369]                 common <- intersect(names, old_names)
[17:37:37.369]                 added <- setdiff(names, old_names)
[17:37:37.369]                 removed <- setdiff(old_names, names)
[17:37:37.369]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:37.369]                   envs[common]]
[17:37:37.369]                 NAMES <- toupper(changed)
[17:37:37.369]                 args <- list()
[17:37:37.369]                 for (kk in seq_along(NAMES)) {
[17:37:37.369]                   name <- changed[[kk]]
[17:37:37.369]                   NAME <- NAMES[[kk]]
[17:37:37.369]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.369]                     next
[17:37:37.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:37.369]                 }
[17:37:37.369]                 NAMES <- toupper(added)
[17:37:37.369]                 for (kk in seq_along(NAMES)) {
[17:37:37.369]                   name <- added[[kk]]
[17:37:37.369]                   NAME <- NAMES[[kk]]
[17:37:37.369]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.369]                     next
[17:37:37.369]                   args[[name]] <- ""
[17:37:37.369]                 }
[17:37:37.369]                 NAMES <- toupper(removed)
[17:37:37.369]                 for (kk in seq_along(NAMES)) {
[17:37:37.369]                   name <- removed[[kk]]
[17:37:37.369]                   NAME <- NAMES[[kk]]
[17:37:37.369]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.369]                     next
[17:37:37.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:37.369]                 }
[17:37:37.369]                 if (length(args) > 0) 
[17:37:37.369]                   base::do.call(base::Sys.setenv, args = args)
[17:37:37.369]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:37.369]             }
[17:37:37.369]             else {
[17:37:37.369]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:37.369]             }
[17:37:37.369]             {
[17:37:37.369]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:37.369]                   0L) {
[17:37:37.369]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:37.369]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:37.369]                   base::options(opts)
[17:37:37.369]                 }
[17:37:37.369]                 {
[17:37:37.369]                   {
[17:37:37.369]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:37.369]                     NULL
[17:37:37.369]                   }
[17:37:37.369]                   options(future.plan = NULL)
[17:37:37.369]                   if (is.na(NA_character_)) 
[17:37:37.369]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:37.369]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:37.369]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:37.369]                     .init = FALSE)
[17:37:37.369]                 }
[17:37:37.369]             }
[17:37:37.369]         }
[17:37:37.369]     })
[17:37:37.369]     if (TRUE) {
[17:37:37.369]         base::sink(type = "output", split = FALSE)
[17:37:37.369]         if (TRUE) {
[17:37:37.369]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:37.369]         }
[17:37:37.369]         else {
[17:37:37.369]             ...future.result["stdout"] <- base::list(NULL)
[17:37:37.369]         }
[17:37:37.369]         base::close(...future.stdout)
[17:37:37.369]         ...future.stdout <- NULL
[17:37:37.369]     }
[17:37:37.369]     ...future.result$conditions <- ...future.conditions
[17:37:37.369]     ...future.result$finished <- base::Sys.time()
[17:37:37.369]     ...future.result
[17:37:37.369] }
[17:37:37.372] assign_globals() ...
[17:37:37.372] List of 5
[17:37:37.372]  $ ...future.FUN            :function (x)  
[17:37:37.372]  $ MoreArgs                 : NULL
[17:37:37.372]  $ ...future.elements_ii    :List of 1
[17:37:37.372]   ..$ :List of 1
[17:37:37.372]   .. ..$ a: num 0
[17:37:37.372]  $ ...future.seeds_ii       : NULL
[17:37:37.372]  $ ...future.globals.maxSize: NULL
[17:37:37.372]  - attr(*, "where")=List of 5
[17:37:37.372]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:37.372]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:37.372]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:37.372]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:37.372]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:37.372]  - attr(*, "resolved")= logi FALSE
[17:37:37.372]  - attr(*, "total_size")= num 904
[17:37:37.372]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:37.372]  - attr(*, "already-done")= logi TRUE
[17:37:37.380] - copied ‘...future.FUN’ to environment
[17:37:37.380] - copied ‘MoreArgs’ to environment
[17:37:37.380] - copied ‘...future.elements_ii’ to environment
[17:37:37.380] - copied ‘...future.seeds_ii’ to environment
[17:37:37.380] - copied ‘...future.globals.maxSize’ to environment
[17:37:37.380] assign_globals() ... done
[17:37:37.381] requestCore(): workers = 2
[17:37:37.383] MulticoreFuture started
[17:37:37.384] - Launch lazy future ... done
[17:37:37.384] plan(): Setting new future strategy stack:
[17:37:37.385] run() for ‘MulticoreFuture’ ... done
[17:37:37.385] Created future:
[17:37:37.385] List of future strategies:
[17:37:37.385] 1. sequential:
[17:37:37.385]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:37.385]    - tweaked: FALSE
[17:37:37.385]    - call: NULL
[17:37:37.387] plan(): nbrOfWorkers() = 1
[17:37:37.390] plan(): Setting new future strategy stack:
[17:37:37.390] List of future strategies:
[17:37:37.390] 1. multicore:
[17:37:37.390]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:37.390]    - tweaked: FALSE
[17:37:37.390]    - call: plan(strategy)
[17:37:37.397] plan(): nbrOfWorkers() = 2
[17:37:37.385] MulticoreFuture:
[17:37:37.385] Label: ‘future_mapply-1’
[17:37:37.385] Expression:
[17:37:37.385] {
[17:37:37.385]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:37.385]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:37.385]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:37.385]         on.exit(options(oopts), add = TRUE)
[17:37:37.385]     }
[17:37:37.385]     {
[17:37:37.385]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:37.385]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:37.385]         do.call(mapply, args = args)
[17:37:37.385]     }
[17:37:37.385] }
[17:37:37.385] Lazy evaluation: FALSE
[17:37:37.385] Asynchronous evaluation: TRUE
[17:37:37.385] Local evaluation: TRUE
[17:37:37.385] Environment: R_GlobalEnv
[17:37:37.385] Capture standard output: TRUE
[17:37:37.385] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:37.385] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:37.385] Packages: <none>
[17:37:37.385] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:37.385] Resolved: TRUE
[17:37:37.385] Value: <not collected>
[17:37:37.385] Conditions captured: <none>
[17:37:37.385] Early signaling: FALSE
[17:37:37.385] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:37.385] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:37.398] Chunk #1 of 2 ... DONE
[17:37:37.399] Chunk #2 of 2 ...
[17:37:37.399]  - Finding globals in '...' for chunk #2 ...
[17:37:37.399] getGlobalsAndPackages() ...
[17:37:37.399] Searching for globals...
[17:37:37.400] 
[17:37:37.400] Searching for globals ... DONE
[17:37:37.400] - globals: [0] <none>
[17:37:37.400] getGlobalsAndPackages() ... DONE
[17:37:37.401]    + additional globals found: [n=0] 
[17:37:37.401]    + additional namespaces needed: [n=0] 
[17:37:37.401]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:37.401]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:37.401]  - seeds: <none>
[17:37:37.401]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:37.402] getGlobalsAndPackages() ...
[17:37:37.402] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:37.402] Resolving globals: FALSE
[17:37:37.403] The total size of the 5 globals is 904 bytes (904 bytes)
[17:37:37.404] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:37.404] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:37.404] 
[17:37:37.404] getGlobalsAndPackages() ... DONE
[17:37:37.405] run() for ‘Future’ ...
[17:37:37.405] - state: ‘created’
[17:37:37.405] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:37:37.410] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:37.410] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:37:37.410]   - Field: ‘label’
[17:37:37.410]   - Field: ‘local’
[17:37:37.410]   - Field: ‘owner’
[17:37:37.411]   - Field: ‘envir’
[17:37:37.411]   - Field: ‘workers’
[17:37:37.411]   - Field: ‘packages’
[17:37:37.411]   - Field: ‘gc’
[17:37:37.411]   - Field: ‘job’
[17:37:37.411]   - Field: ‘conditions’
[17:37:37.411]   - Field: ‘expr’
[17:37:37.411]   - Field: ‘uuid’
[17:37:37.412]   - Field: ‘seed’
[17:37:37.412]   - Field: ‘version’
[17:37:37.412]   - Field: ‘result’
[17:37:37.412]   - Field: ‘asynchronous’
[17:37:37.412]   - Field: ‘calls’
[17:37:37.412]   - Field: ‘globals’
[17:37:37.413]   - Field: ‘stdout’
[17:37:37.413]   - Field: ‘earlySignal’
[17:37:37.413]   - Field: ‘lazy’
[17:37:37.413]   - Field: ‘state’
[17:37:37.413] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:37:37.413] - Launch lazy future ...
[17:37:37.414] Packages needed by the future expression (n = 0): <none>
[17:37:37.414] Packages needed by future strategies (n = 0): <none>
[17:37:37.414] {
[17:37:37.414]     {
[17:37:37.414]         {
[17:37:37.414]             ...future.startTime <- base::Sys.time()
[17:37:37.414]             {
[17:37:37.414]                 {
[17:37:37.414]                   {
[17:37:37.414]                     {
[17:37:37.414]                       base::local({
[17:37:37.414]                         has_future <- base::requireNamespace("future", 
[17:37:37.414]                           quietly = TRUE)
[17:37:37.414]                         if (has_future) {
[17:37:37.414]                           ns <- base::getNamespace("future")
[17:37:37.414]                           version <- ns[[".package"]][["version"]]
[17:37:37.414]                           if (is.null(version)) 
[17:37:37.414]                             version <- utils::packageVersion("future")
[17:37:37.414]                         }
[17:37:37.414]                         else {
[17:37:37.414]                           version <- NULL
[17:37:37.414]                         }
[17:37:37.414]                         if (!has_future || version < "1.8.0") {
[17:37:37.414]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:37.414]                             "", base::R.version$version.string), 
[17:37:37.414]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:37.414]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:37.414]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:37.414]                               "release", "version")], collapse = " "), 
[17:37:37.414]                             hostname = base::Sys.info()[["nodename"]])
[17:37:37.414]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:37.414]                             info)
[17:37:37.414]                           info <- base::paste(info, collapse = "; ")
[17:37:37.414]                           if (!has_future) {
[17:37:37.414]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:37.414]                               info)
[17:37:37.414]                           }
[17:37:37.414]                           else {
[17:37:37.414]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:37.414]                               info, version)
[17:37:37.414]                           }
[17:37:37.414]                           base::stop(msg)
[17:37:37.414]                         }
[17:37:37.414]                       })
[17:37:37.414]                     }
[17:37:37.414]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:37.414]                     base::options(mc.cores = 1L)
[17:37:37.414]                   }
[17:37:37.414]                   ...future.strategy.old <- future::plan("list")
[17:37:37.414]                   options(future.plan = NULL)
[17:37:37.414]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:37.414]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:37.414]                 }
[17:37:37.414]                 ...future.workdir <- getwd()
[17:37:37.414]             }
[17:37:37.414]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:37.414]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:37.414]         }
[17:37:37.414]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:37.414]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:37.414]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:37.414]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:37.414]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:37.414]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:37.414]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:37.414]             base::names(...future.oldOptions))
[17:37:37.414]     }
[17:37:37.414]     if (FALSE) {
[17:37:37.414]     }
[17:37:37.414]     else {
[17:37:37.414]         if (TRUE) {
[17:37:37.414]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:37.414]                 open = "w")
[17:37:37.414]         }
[17:37:37.414]         else {
[17:37:37.414]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:37.414]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:37.414]         }
[17:37:37.414]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:37.414]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:37.414]             base::sink(type = "output", split = FALSE)
[17:37:37.414]             base::close(...future.stdout)
[17:37:37.414]         }, add = TRUE)
[17:37:37.414]     }
[17:37:37.414]     ...future.frame <- base::sys.nframe()
[17:37:37.414]     ...future.conditions <- base::list()
[17:37:37.414]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:37.414]     if (FALSE) {
[17:37:37.414]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:37.414]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:37.414]     }
[17:37:37.414]     ...future.result <- base::tryCatch({
[17:37:37.414]         base::withCallingHandlers({
[17:37:37.414]             ...future.value <- base::withVisible(base::local({
[17:37:37.414]                 withCallingHandlers({
[17:37:37.414]                   {
[17:37:37.414]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:37.414]                     if (!identical(...future.globals.maxSize.org, 
[17:37:37.414]                       ...future.globals.maxSize)) {
[17:37:37.414]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:37.414]                       on.exit(options(oopts), add = TRUE)
[17:37:37.414]                     }
[17:37:37.414]                     {
[17:37:37.414]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:37.414]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:37.414]                         USE.NAMES = FALSE)
[17:37:37.414]                       do.call(mapply, args = args)
[17:37:37.414]                     }
[17:37:37.414]                   }
[17:37:37.414]                 }, immediateCondition = function(cond) {
[17:37:37.414]                   save_rds <- function (object, pathname, ...) 
[17:37:37.414]                   {
[17:37:37.414]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:37:37.414]                     if (file_test("-f", pathname_tmp)) {
[17:37:37.414]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.414]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:37:37.414]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.414]                         fi_tmp[["mtime"]])
[17:37:37.414]                     }
[17:37:37.414]                     tryCatch({
[17:37:37.414]                       saveRDS(object, file = pathname_tmp, ...)
[17:37:37.414]                     }, error = function(ex) {
[17:37:37.414]                       msg <- conditionMessage(ex)
[17:37:37.414]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.414]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:37:37.414]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.414]                         fi_tmp[["mtime"]], msg)
[17:37:37.414]                       ex$message <- msg
[17:37:37.414]                       stop(ex)
[17:37:37.414]                     })
[17:37:37.414]                     stopifnot(file_test("-f", pathname_tmp))
[17:37:37.414]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:37:37.414]                     if (!res || file_test("-f", pathname_tmp)) {
[17:37:37.414]                       fi_tmp <- file.info(pathname_tmp)
[17:37:37.414]                       fi <- file.info(pathname)
[17:37:37.414]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:37:37.414]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:37:37.414]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:37:37.414]                         fi[["size"]], fi[["mtime"]])
[17:37:37.414]                       stop(msg)
[17:37:37.414]                     }
[17:37:37.414]                     invisible(pathname)
[17:37:37.414]                   }
[17:37:37.414]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:37:37.414]                     rootPath = tempdir()) 
[17:37:37.414]                   {
[17:37:37.414]                     obj <- list(time = Sys.time(), condition = cond)
[17:37:37.414]                     file <- tempfile(pattern = class(cond)[1], 
[17:37:37.414]                       tmpdir = path, fileext = ".rds")
[17:37:37.414]                     save_rds(obj, file)
[17:37:37.414]                   }
[17:37:37.414]                   saveImmediateCondition(cond, path = "/tmp/RtmpSKK1iF/.future/immediateConditions")
[17:37:37.414]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.414]                   {
[17:37:37.414]                     inherits <- base::inherits
[17:37:37.414]                     invokeRestart <- base::invokeRestart
[17:37:37.414]                     is.null <- base::is.null
[17:37:37.414]                     muffled <- FALSE
[17:37:37.414]                     if (inherits(cond, "message")) {
[17:37:37.414]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:37.414]                       if (muffled) 
[17:37:37.414]                         invokeRestart("muffleMessage")
[17:37:37.414]                     }
[17:37:37.414]                     else if (inherits(cond, "warning")) {
[17:37:37.414]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:37.414]                       if (muffled) 
[17:37:37.414]                         invokeRestart("muffleWarning")
[17:37:37.414]                     }
[17:37:37.414]                     else if (inherits(cond, "condition")) {
[17:37:37.414]                       if (!is.null(pattern)) {
[17:37:37.414]                         computeRestarts <- base::computeRestarts
[17:37:37.414]                         grepl <- base::grepl
[17:37:37.414]                         restarts <- computeRestarts(cond)
[17:37:37.414]                         for (restart in restarts) {
[17:37:37.414]                           name <- restart$name
[17:37:37.414]                           if (is.null(name)) 
[17:37:37.414]                             next
[17:37:37.414]                           if (!grepl(pattern, name)) 
[17:37:37.414]                             next
[17:37:37.414]                           invokeRestart(restart)
[17:37:37.414]                           muffled <- TRUE
[17:37:37.414]                           break
[17:37:37.414]                         }
[17:37:37.414]                       }
[17:37:37.414]                     }
[17:37:37.414]                     invisible(muffled)
[17:37:37.414]                   }
[17:37:37.414]                   muffleCondition(cond)
[17:37:37.414]                 })
[17:37:37.414]             }))
[17:37:37.414]             future::FutureResult(value = ...future.value$value, 
[17:37:37.414]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:37.414]                   ...future.rng), globalenv = if (FALSE) 
[17:37:37.414]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:37.414]                     ...future.globalenv.names))
[17:37:37.414]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:37.414]         }, condition = base::local({
[17:37:37.414]             c <- base::c
[17:37:37.414]             inherits <- base::inherits
[17:37:37.414]             invokeRestart <- base::invokeRestart
[17:37:37.414]             length <- base::length
[17:37:37.414]             list <- base::list
[17:37:37.414]             seq.int <- base::seq.int
[17:37:37.414]             signalCondition <- base::signalCondition
[17:37:37.414]             sys.calls <- base::sys.calls
[17:37:37.414]             `[[` <- base::`[[`
[17:37:37.414]             `+` <- base::`+`
[17:37:37.414]             `<<-` <- base::`<<-`
[17:37:37.414]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:37.414]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:37.414]                   3L)]
[17:37:37.414]             }
[17:37:37.414]             function(cond) {
[17:37:37.414]                 is_error <- inherits(cond, "error")
[17:37:37.414]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:37.414]                   NULL)
[17:37:37.414]                 if (is_error) {
[17:37:37.414]                   sessionInformation <- function() {
[17:37:37.414]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:37.414]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:37.414]                       search = base::search(), system = base::Sys.info())
[17:37:37.414]                   }
[17:37:37.414]                   ...future.conditions[[length(...future.conditions) + 
[17:37:37.414]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:37.414]                     cond$call), session = sessionInformation(), 
[17:37:37.414]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:37.414]                   signalCondition(cond)
[17:37:37.414]                 }
[17:37:37.414]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:37.414]                 "immediateCondition"))) {
[17:37:37.414]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:37.414]                   ...future.conditions[[length(...future.conditions) + 
[17:37:37.414]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:37.414]                   if (TRUE && !signal) {
[17:37:37.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.414]                     {
[17:37:37.414]                       inherits <- base::inherits
[17:37:37.414]                       invokeRestart <- base::invokeRestart
[17:37:37.414]                       is.null <- base::is.null
[17:37:37.414]                       muffled <- FALSE
[17:37:37.414]                       if (inherits(cond, "message")) {
[17:37:37.414]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:37.414]                         if (muffled) 
[17:37:37.414]                           invokeRestart("muffleMessage")
[17:37:37.414]                       }
[17:37:37.414]                       else if (inherits(cond, "warning")) {
[17:37:37.414]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:37.414]                         if (muffled) 
[17:37:37.414]                           invokeRestart("muffleWarning")
[17:37:37.414]                       }
[17:37:37.414]                       else if (inherits(cond, "condition")) {
[17:37:37.414]                         if (!is.null(pattern)) {
[17:37:37.414]                           computeRestarts <- base::computeRestarts
[17:37:37.414]                           grepl <- base::grepl
[17:37:37.414]                           restarts <- computeRestarts(cond)
[17:37:37.414]                           for (restart in restarts) {
[17:37:37.414]                             name <- restart$name
[17:37:37.414]                             if (is.null(name)) 
[17:37:37.414]                               next
[17:37:37.414]                             if (!grepl(pattern, name)) 
[17:37:37.414]                               next
[17:37:37.414]                             invokeRestart(restart)
[17:37:37.414]                             muffled <- TRUE
[17:37:37.414]                             break
[17:37:37.414]                           }
[17:37:37.414]                         }
[17:37:37.414]                       }
[17:37:37.414]                       invisible(muffled)
[17:37:37.414]                     }
[17:37:37.414]                     muffleCondition(cond, pattern = "^muffle")
[17:37:37.414]                   }
[17:37:37.414]                 }
[17:37:37.414]                 else {
[17:37:37.414]                   if (TRUE) {
[17:37:37.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:37.414]                     {
[17:37:37.414]                       inherits <- base::inherits
[17:37:37.414]                       invokeRestart <- base::invokeRestart
[17:37:37.414]                       is.null <- base::is.null
[17:37:37.414]                       muffled <- FALSE
[17:37:37.414]                       if (inherits(cond, "message")) {
[17:37:37.414]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:37.414]                         if (muffled) 
[17:37:37.414]                           invokeRestart("muffleMessage")
[17:37:37.414]                       }
[17:37:37.414]                       else if (inherits(cond, "warning")) {
[17:37:37.414]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:37.414]                         if (muffled) 
[17:37:37.414]                           invokeRestart("muffleWarning")
[17:37:37.414]                       }
[17:37:37.414]                       else if (inherits(cond, "condition")) {
[17:37:37.414]                         if (!is.null(pattern)) {
[17:37:37.414]                           computeRestarts <- base::computeRestarts
[17:37:37.414]                           grepl <- base::grepl
[17:37:37.414]                           restarts <- computeRestarts(cond)
[17:37:37.414]                           for (restart in restarts) {
[17:37:37.414]                             name <- restart$name
[17:37:37.414]                             if (is.null(name)) 
[17:37:37.414]                               next
[17:37:37.414]                             if (!grepl(pattern, name)) 
[17:37:37.414]                               next
[17:37:37.414]                             invokeRestart(restart)
[17:37:37.414]                             muffled <- TRUE
[17:37:37.414]                             break
[17:37:37.414]                           }
[17:37:37.414]                         }
[17:37:37.414]                       }
[17:37:37.414]                       invisible(muffled)
[17:37:37.414]                     }
[17:37:37.414]                     muffleCondition(cond, pattern = "^muffle")
[17:37:37.414]                   }
[17:37:37.414]                 }
[17:37:37.414]             }
[17:37:37.414]         }))
[17:37:37.414]     }, error = function(ex) {
[17:37:37.414]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:37.414]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:37.414]                 ...future.rng), started = ...future.startTime, 
[17:37:37.414]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:37.414]             version = "1.8"), class = "FutureResult")
[17:37:37.414]     }, finally = {
[17:37:37.414]         if (!identical(...future.workdir, getwd())) 
[17:37:37.414]             setwd(...future.workdir)
[17:37:37.414]         {
[17:37:37.414]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:37.414]                 ...future.oldOptions$nwarnings <- NULL
[17:37:37.414]             }
[17:37:37.414]             base::options(...future.oldOptions)
[17:37:37.414]             if (.Platform$OS.type == "windows") {
[17:37:37.414]                 old_names <- names(...future.oldEnvVars)
[17:37:37.414]                 envs <- base::Sys.getenv()
[17:37:37.414]                 names <- names(envs)
[17:37:37.414]                 common <- intersect(names, old_names)
[17:37:37.414]                 added <- setdiff(names, old_names)
[17:37:37.414]                 removed <- setdiff(old_names, names)
[17:37:37.414]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:37.414]                   envs[common]]
[17:37:37.414]                 NAMES <- toupper(changed)
[17:37:37.414]                 args <- list()
[17:37:37.414]                 for (kk in seq_along(NAMES)) {
[17:37:37.414]                   name <- changed[[kk]]
[17:37:37.414]                   NAME <- NAMES[[kk]]
[17:37:37.414]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.414]                     next
[17:37:37.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:37.414]                 }
[17:37:37.414]                 NAMES <- toupper(added)
[17:37:37.414]                 for (kk in seq_along(NAMES)) {
[17:37:37.414]                   name <- added[[kk]]
[17:37:37.414]                   NAME <- NAMES[[kk]]
[17:37:37.414]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.414]                     next
[17:37:37.414]                   args[[name]] <- ""
[17:37:37.414]                 }
[17:37:37.414]                 NAMES <- toupper(removed)
[17:37:37.414]                 for (kk in seq_along(NAMES)) {
[17:37:37.414]                   name <- removed[[kk]]
[17:37:37.414]                   NAME <- NAMES[[kk]]
[17:37:37.414]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:37.414]                     next
[17:37:37.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:37.414]                 }
[17:37:37.414]                 if (length(args) > 0) 
[17:37:37.414]                   base::do.call(base::Sys.setenv, args = args)
[17:37:37.414]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:37.414]             }
[17:37:37.414]             else {
[17:37:37.414]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:37.414]             }
[17:37:37.414]             {
[17:37:37.414]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:37.414]                   0L) {
[17:37:37.414]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:37.414]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:37.414]                   base::options(opts)
[17:37:37.414]                 }
[17:37:37.414]                 {
[17:37:37.414]                   {
[17:37:37.414]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:37.414]                     NULL
[17:37:37.414]                   }
[17:37:37.414]                   options(future.plan = NULL)
[17:37:37.414]                   if (is.na(NA_character_)) 
[17:37:37.414]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:37.414]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:37.414]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:37.414]                     .init = FALSE)
[17:37:37.414]                 }
[17:37:37.414]             }
[17:37:37.414]         }
[17:37:37.414]     })
[17:37:37.414]     if (TRUE) {
[17:37:37.414]         base::sink(type = "output", split = FALSE)
[17:37:37.414]         if (TRUE) {
[17:37:37.414]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:37.414]         }
[17:37:37.414]         else {
[17:37:37.414]             ...future.result["stdout"] <- base::list(NULL)
[17:37:37.414]         }
[17:37:37.414]         base::close(...future.stdout)
[17:37:37.414]         ...future.stdout <- NULL
[17:37:37.414]     }
[17:37:37.414]     ...future.result$conditions <- ...future.conditions
[17:37:37.414]     ...future.result$finished <- base::Sys.time()
[17:37:37.414]     ...future.result
[17:37:37.414] }
[17:37:37.418] assign_globals() ...
[17:37:37.418] List of 5
[17:37:37.418]  $ ...future.FUN            :function (x)  
[17:37:37.418]  $ MoreArgs                 : NULL
[17:37:37.418]  $ ...future.elements_ii    :List of 1
[17:37:37.418]   ..$ :List of 1
[17:37:37.418]   .. ..$ b: num 0
[17:37:37.418]  $ ...future.seeds_ii       : NULL
[17:37:37.418]  $ ...future.globals.maxSize: NULL
[17:37:37.418]  - attr(*, "where")=List of 5
[17:37:37.418]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:37:37.418]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:37:37.418]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:37:37.418]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:37:37.418]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:37:37.418]  - attr(*, "resolved")= logi FALSE
[17:37:37.418]  - attr(*, "total_size")= num 904
[17:37:37.418]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:37.418]  - attr(*, "already-done")= logi TRUE
[17:37:37.430] - copied ‘...future.FUN’ to environment
[17:37:37.430] - copied ‘MoreArgs’ to environment
[17:37:37.430] - copied ‘...future.elements_ii’ to environment
[17:37:37.430] - copied ‘...future.seeds_ii’ to environment
[17:37:37.430] - copied ‘...future.globals.maxSize’ to environment
[17:37:37.430] assign_globals() ... done
[17:37:37.430] requestCore(): workers = 2
[17:37:37.433] MulticoreFuture started
[17:37:37.434] - Launch lazy future ... done
[17:37:37.435] plan(): Setting new future strategy stack:
[17:37:37.435] run() for ‘MulticoreFuture’ ... done
[17:37:37.435] Created future:
[17:37:37.435] List of future strategies:
[17:37:37.435] 1. sequential:
[17:37:37.435]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:37.435]    - tweaked: FALSE
[17:37:37.435]    - call: NULL
[17:37:37.437] plan(): nbrOfWorkers() = 1
[17:37:37.440] plan(): Setting new future strategy stack:
[17:37:37.440] List of future strategies:
[17:37:37.440] 1. multicore:
[17:37:37.440]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:37:37.440]    - tweaked: FALSE
[17:37:37.440]    - call: plan(strategy)
[17:37:37.448] plan(): nbrOfWorkers() = 2
[17:37:37.436] MulticoreFuture:
[17:37:37.436] Label: ‘future_mapply-2’
[17:37:37.436] Expression:
[17:37:37.436] {
[17:37:37.436]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:37.436]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:37.436]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:37.436]         on.exit(options(oopts), add = TRUE)
[17:37:37.436]     }
[17:37:37.436]     {
[17:37:37.436]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:37.436]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:37.436]         do.call(mapply, args = args)
[17:37:37.436]     }
[17:37:37.436] }
[17:37:37.436] Lazy evaluation: FALSE
[17:37:37.436] Asynchronous evaluation: TRUE
[17:37:37.436] Local evaluation: TRUE
[17:37:37.436] Environment: R_GlobalEnv
[17:37:37.436] Capture standard output: TRUE
[17:37:37.436] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:37.436] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:37.436] Packages: <none>
[17:37:37.436] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:37.436] Resolved: TRUE
[17:37:37.436] Value: <not collected>
[17:37:37.436] Conditions captured: <none>
[17:37:37.436] Early signaling: FALSE
[17:37:37.436] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:37.436] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:37.449] Chunk #2 of 2 ... DONE
[17:37:37.449] Launching 2 futures (chunks) ... DONE
[17:37:37.449] Resolving 2 futures (chunks) ...
[17:37:37.450] resolve() on list ...
[17:37:37.450]  recursive: 0
[17:37:37.450]  length: 2
[17:37:37.450] 
[17:37:37.451] Future #1
[17:37:37.451] result() for MulticoreFuture ...
[17:37:37.452] result() for MulticoreFuture ...
[17:37:37.452] result() for MulticoreFuture ... done
[17:37:37.453] result() for MulticoreFuture ... done
[17:37:37.453] result() for MulticoreFuture ...
[17:37:37.453] result() for MulticoreFuture ... done
[17:37:37.453] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:37:37.454] - nx: 2
[17:37:37.454] - relay: TRUE
[17:37:37.454] - stdout: TRUE
[17:37:37.454] - signal: TRUE
[17:37:37.454] - resignal: FALSE
[17:37:37.455] - force: TRUE
[17:37:37.455] - relayed: [n=2] FALSE, FALSE
[17:37:37.455] - queued futures: [n=2] FALSE, FALSE
[17:37:37.455]  - until=1
[17:37:37.455]  - relaying element #1
[17:37:37.456] result() for MulticoreFuture ...
[17:37:37.456] result() for MulticoreFuture ... done
[17:37:37.456] result() for MulticoreFuture ...
[17:37:37.456] result() for MulticoreFuture ... done
[17:37:37.457] result() for MulticoreFuture ...
[17:37:37.457] result() for MulticoreFuture ... done
[17:37:37.457] result() for MulticoreFuture ...
[17:37:37.457] result() for MulticoreFuture ... done
[17:37:37.458] - relayed: [n=2] TRUE, FALSE
[17:37:37.458] - queued futures: [n=2] TRUE, FALSE
[17:37:37.458] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:37:37.458]  length: 1 (resolved future 1)
[17:37:37.459] Future #2
[17:37:37.459] result() for MulticoreFuture ...
[17:37:37.460] result() for MulticoreFuture ...
[17:37:37.460] result() for MulticoreFuture ... done
[17:37:37.460] result() for MulticoreFuture ... done
[17:37:37.460] result() for MulticoreFuture ...
[17:37:37.460] result() for MulticoreFuture ... done
[17:37:37.460] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:37:37.460] - nx: 2
[17:37:37.461] - relay: TRUE
[17:37:37.461] - stdout: TRUE
[17:37:37.461] - signal: TRUE
[17:37:37.461] - resignal: FALSE
[17:37:37.461] - force: TRUE
[17:37:37.461] - relayed: [n=2] TRUE, FALSE
[17:37:37.461] - queued futures: [n=2] TRUE, FALSE
[17:37:37.461]  - until=2
[17:37:37.461]  - relaying element #2
[17:37:37.462] result() for MulticoreFuture ...
[17:37:37.462] result() for MulticoreFuture ... done
[17:37:37.462] result() for MulticoreFuture ...
[17:37:37.462] result() for MulticoreFuture ... done
[17:37:37.462] result() for MulticoreFuture ...
[17:37:37.462] result() for MulticoreFuture ... done
[17:37:37.462] result() for MulticoreFuture ...
[17:37:37.463] result() for MulticoreFuture ... done
[17:37:37.463] - relayed: [n=2] TRUE, TRUE
[17:37:37.463] - queued futures: [n=2] TRUE, TRUE
[17:37:37.463] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:37:37.463]  length: 0 (resolved future 2)
[17:37:37.463] Relaying remaining futures
[17:37:37.463] signalConditionsASAP(NULL, pos=0) ...
[17:37:37.463] - nx: 2
[17:37:37.463] - relay: TRUE
[17:37:37.463] - stdout: TRUE
[17:37:37.464] - signal: TRUE
[17:37:37.464] - resignal: FALSE
[17:37:37.464] - force: TRUE
[17:37:37.464] - relayed: [n=2] TRUE, TRUE
[17:37:37.464] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:37.464] - relayed: [n=2] TRUE, TRUE
[17:37:37.464] - queued futures: [n=2] TRUE, TRUE
[17:37:37.464] signalConditionsASAP(NULL, pos=0) ... done
[17:37:37.464] resolve() on list ... DONE
[17:37:37.465] result() for MulticoreFuture ...
[17:37:37.465] result() for MulticoreFuture ... done
[17:37:37.465] result() for MulticoreFuture ...
[17:37:37.465] result() for MulticoreFuture ... done
[17:37:37.465] result() for MulticoreFuture ...
[17:37:37.465] result() for MulticoreFuture ... done
[17:37:37.465] result() for MulticoreFuture ...
[17:37:37.465] result() for MulticoreFuture ... done
[17:37:37.465]  - Number of value chunks collected: 2
[17:37:37.466] Resolving 2 futures (chunks) ... DONE
[17:37:37.466] Reducing values from 2 chunks ...
[17:37:37.466]  - Number of values collected after concatenation: 2
[17:37:37.466]  - Number of values expected: 2
[17:37:37.466] Reducing values from 2 chunks ... DONE
[17:37:37.466] future_mapply() ... DONE
[17:37:37.466] plan(): Setting new future strategy stack:
[17:37:37.466] List of future strategies:
[17:37:37.466] 1. sequential:
[17:37:37.466]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:37.466]    - tweaked: FALSE
[17:37:37.466]    - call: plan(sequential)
[17:37:37.467] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[17:37:37.468] plan(): Setting new future strategy stack:
[17:37:37.468] List of future strategies:
[17:37:37.468] 1. multisession:
[17:37:37.468]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:37:37.468]    - tweaked: FALSE
[17:37:37.468]    - call: plan(strategy)
[17:37:37.468] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:37:37.468] multisession:
[17:37:37.468] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:37:37.468] - tweaked: FALSE
[17:37:37.468] - call: plan(strategy)
[17:37:37.475] getGlobalsAndPackages() ...
[17:37:37.475] Not searching for globals
[17:37:37.476] - globals: [0] <none>
[17:37:37.476] getGlobalsAndPackages() ... DONE
[17:37:37.476] [local output] makeClusterPSOCK() ...
[17:37:37.529] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:37:37.530] [local output] Base port: 11760
[17:37:37.531] [local output] Getting setup options for 2 cluster nodes ...
[17:37:37.531] [local output]  - Node 1 of 2 ...
[17:37:37.531] [local output] localMachine=TRUE => revtunnel=FALSE

[17:37:37.532] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpSKK1iF/worker.rank=1.parallelly.parent=34426.867a3af87834.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpSKK1iF/worker.rank=1.parallelly.parent=34426.867a3af87834.pid")'’
[17:37:37.724] - Possible to infer worker's PID: TRUE
[17:37:37.724] [local output] Rscript port: 11760

[17:37:37.724] [local output]  - Node 2 of 2 ...
[17:37:37.725] [local output] localMachine=TRUE => revtunnel=FALSE

[17:37:37.725] [local output] Rscript port: 11760

[17:37:37.726] [local output] Getting setup options for 2 cluster nodes ... done
[17:37:37.726] [local output]  - Parallel setup requested for some PSOCK nodes
[17:37:37.726] [local output] Setting up PSOCK nodes in parallel
[17:37:37.726] List of 36
[17:37:37.726]  $ worker          : chr "localhost"
[17:37:37.726]   ..- attr(*, "localhost")= logi TRUE
[17:37:37.726]  $ master          : chr "localhost"
[17:37:37.726]  $ port            : int 11760
[17:37:37.726]  $ connectTimeout  : num 120
[17:37:37.726]  $ timeout         : num 2592000
[17:37:37.726]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:37:37.726]  $ homogeneous     : logi TRUE
[17:37:37.726]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:37:37.726]  $ rscript_envs    : NULL
[17:37:37.726]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:37:37.726]  $ rscript_startup : NULL
[17:37:37.726]  $ rscript_sh      : chr "sh"
[17:37:37.726]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:37:37.726]  $ methods         : logi TRUE
[17:37:37.726]  $ socketOptions   : chr "no-delay"
[17:37:37.726]  $ useXDR          : logi FALSE
[17:37:37.726]  $ outfile         : chr "/dev/null"
[17:37:37.726]  $ renice          : int NA
[17:37:37.726]  $ rshcmd          : NULL
[17:37:37.726]  $ user            : chr(0) 
[17:37:37.726]  $ revtunnel       : logi FALSE
[17:37:37.726]  $ rshlogfile      : NULL
[17:37:37.726]  $ rshopts         : chr(0) 
[17:37:37.726]  $ rank            : int 1
[17:37:37.726]  $ manual          : logi FALSE
[17:37:37.726]  $ dryrun          : logi FALSE
[17:37:37.726]  $ quiet           : logi FALSE
[17:37:37.726]  $ setup_strategy  : chr "parallel"
[17:37:37.726]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:37:37.726]  $ pidfile         : chr "/tmp/RtmpSKK1iF/worker.rank=1.parallelly.parent=34426.867a3af87834.pid"
[17:37:37.726]  $ rshcmd_label    : NULL
[17:37:37.726]  $ rsh_call        : NULL
[17:37:37.726]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:37:37.726]  $ localMachine    : logi TRUE
[17:37:37.726]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:37:37.726]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:37:37.726]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:37:37.726]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:37:37.726]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:37:37.726]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:37:37.726]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:37:37.726]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:37:37.726]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:37:37.726]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:37:37.726]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:37:37.726]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:37:37.726]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:37:37.726]  $ arguments       :List of 28
[17:37:37.726]   ..$ worker          : chr "localhost"
[17:37:37.726]   ..$ master          : NULL
[17:37:37.726]   ..$ port            : int 11760
[17:37:37.726]   ..$ connectTimeout  : num 120
[17:37:37.726]   ..$ timeout         : num 2592000
[17:37:37.726]   ..$ rscript         : NULL
[17:37:37.726]   ..$ homogeneous     : NULL
[17:37:37.726]   ..$ rscript_args    : NULL
[17:37:37.726]   ..$ rscript_envs    : NULL
[17:37:37.726]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:37:37.726]   ..$ rscript_startup : NULL
[17:37:37.726]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:37:37.726]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:37:37.726]   ..$ methods         : logi TRUE
[17:37:37.726]   ..$ socketOptions   : chr "no-delay"
[17:37:37.726]   ..$ useXDR          : logi FALSE
[17:37:37.726]   ..$ outfile         : chr "/dev/null"
[17:37:37.726]   ..$ renice          : int NA
[17:37:37.726]   ..$ rshcmd          : NULL
[17:37:37.726]   ..$ user            : NULL
[17:37:37.726]   ..$ revtunnel       : logi NA
[17:37:37.726]   ..$ rshlogfile      : NULL
[17:37:37.726]   ..$ rshopts         : NULL
[17:37:37.726]   ..$ rank            : int 1
[17:37:37.726]   ..$ manual          : logi FALSE
[17:37:37.726]   ..$ dryrun          : logi FALSE
[17:37:37.726]   ..$ quiet           : logi FALSE
[17:37:37.726]   ..$ setup_strategy  : chr "parallel"
[17:37:37.726]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:37:37.743] [local output] System call to launch all workers:
[17:37:37.744] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpSKK1iF/worker.rank=1.parallelly.parent=34426.867a3af87834.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11760 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:37:37.744] [local output] Starting PSOCK main server
[17:37:37.750] [local output] Workers launched
[17:37:37.750] [local output] Waiting for workers to connect back
[17:37:37.750]  - [local output] 0 workers out of 2 ready
[17:37:37.992]  - [local output] 0 workers out of 2 ready
[17:37:37.992]  - [local output] 1 workers out of 2 ready
[17:37:37.996]  - [local output] 1 workers out of 2 ready
[17:37:37.996]  - [local output] 2 workers out of 2 ready
[17:37:37.997] [local output] Launching of workers completed
[17:37:37.997] [local output] Collecting session information from workers
[17:37:37.998] [local output]  - Worker #1 of 2
[17:37:37.998] [local output]  - Worker #2 of 2
[17:37:37.998] [local output] makeClusterPSOCK() ... done
[17:37:38.009] Packages needed by the future expression (n = 0): <none>
[17:37:38.009] Packages needed by future strategies (n = 0): <none>
[17:37:38.010] {
[17:37:38.010]     {
[17:37:38.010]         {
[17:37:38.010]             ...future.startTime <- base::Sys.time()
[17:37:38.010]             {
[17:37:38.010]                 {
[17:37:38.010]                   {
[17:37:38.010]                     {
[17:37:38.010]                       base::local({
[17:37:38.010]                         has_future <- base::requireNamespace("future", 
[17:37:38.010]                           quietly = TRUE)
[17:37:38.010]                         if (has_future) {
[17:37:38.010]                           ns <- base::getNamespace("future")
[17:37:38.010]                           version <- ns[[".package"]][["version"]]
[17:37:38.010]                           if (is.null(version)) 
[17:37:38.010]                             version <- utils::packageVersion("future")
[17:37:38.010]                         }
[17:37:38.010]                         else {
[17:37:38.010]                           version <- NULL
[17:37:38.010]                         }
[17:37:38.010]                         if (!has_future || version < "1.8.0") {
[17:37:38.010]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:38.010]                             "", base::R.version$version.string), 
[17:37:38.010]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:38.010]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:38.010]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:38.010]                               "release", "version")], collapse = " "), 
[17:37:38.010]                             hostname = base::Sys.info()[["nodename"]])
[17:37:38.010]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:38.010]                             info)
[17:37:38.010]                           info <- base::paste(info, collapse = "; ")
[17:37:38.010]                           if (!has_future) {
[17:37:38.010]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:38.010]                               info)
[17:37:38.010]                           }
[17:37:38.010]                           else {
[17:37:38.010]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:38.010]                               info, version)
[17:37:38.010]                           }
[17:37:38.010]                           base::stop(msg)
[17:37:38.010]                         }
[17:37:38.010]                       })
[17:37:38.010]                     }
[17:37:38.010]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:38.010]                     base::options(mc.cores = 1L)
[17:37:38.010]                   }
[17:37:38.010]                   ...future.strategy.old <- future::plan("list")
[17:37:38.010]                   options(future.plan = NULL)
[17:37:38.010]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.010]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:38.010]                 }
[17:37:38.010]                 ...future.workdir <- getwd()
[17:37:38.010]             }
[17:37:38.010]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:38.010]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:38.010]         }
[17:37:38.010]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:38.010]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:38.010]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:38.010]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:38.010]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:38.010]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:38.010]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:38.010]             base::names(...future.oldOptions))
[17:37:38.010]     }
[17:37:38.010]     if (FALSE) {
[17:37:38.010]     }
[17:37:38.010]     else {
[17:37:38.010]         if (TRUE) {
[17:37:38.010]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:38.010]                 open = "w")
[17:37:38.010]         }
[17:37:38.010]         else {
[17:37:38.010]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:38.010]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:38.010]         }
[17:37:38.010]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:38.010]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:38.010]             base::sink(type = "output", split = FALSE)
[17:37:38.010]             base::close(...future.stdout)
[17:37:38.010]         }, add = TRUE)
[17:37:38.010]     }
[17:37:38.010]     ...future.frame <- base::sys.nframe()
[17:37:38.010]     ...future.conditions <- base::list()
[17:37:38.010]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:38.010]     if (FALSE) {
[17:37:38.010]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:38.010]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:38.010]     }
[17:37:38.010]     ...future.result <- base::tryCatch({
[17:37:38.010]         base::withCallingHandlers({
[17:37:38.010]             ...future.value <- base::withVisible(base::local({
[17:37:38.010]                 ...future.makeSendCondition <- base::local({
[17:37:38.010]                   sendCondition <- NULL
[17:37:38.010]                   function(frame = 1L) {
[17:37:38.010]                     if (is.function(sendCondition)) 
[17:37:38.010]                       return(sendCondition)
[17:37:38.010]                     ns <- getNamespace("parallel")
[17:37:38.010]                     if (exists("sendData", mode = "function", 
[17:37:38.010]                       envir = ns)) {
[17:37:38.010]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:38.010]                         envir = ns)
[17:37:38.010]                       envir <- sys.frame(frame)
[17:37:38.010]                       master <- NULL
[17:37:38.010]                       while (!identical(envir, .GlobalEnv) && 
[17:37:38.010]                         !identical(envir, emptyenv())) {
[17:37:38.010]                         if (exists("master", mode = "list", envir = envir, 
[17:37:38.010]                           inherits = FALSE)) {
[17:37:38.010]                           master <- get("master", mode = "list", 
[17:37:38.010]                             envir = envir, inherits = FALSE)
[17:37:38.010]                           if (inherits(master, c("SOCKnode", 
[17:37:38.010]                             "SOCK0node"))) {
[17:37:38.010]                             sendCondition <<- function(cond) {
[17:37:38.010]                               data <- list(type = "VALUE", value = cond, 
[17:37:38.010]                                 success = TRUE)
[17:37:38.010]                               parallel_sendData(master, data)
[17:37:38.010]                             }
[17:37:38.010]                             return(sendCondition)
[17:37:38.010]                           }
[17:37:38.010]                         }
[17:37:38.010]                         frame <- frame + 1L
[17:37:38.010]                         envir <- sys.frame(frame)
[17:37:38.010]                       }
[17:37:38.010]                     }
[17:37:38.010]                     sendCondition <<- function(cond) NULL
[17:37:38.010]                   }
[17:37:38.010]                 })
[17:37:38.010]                 withCallingHandlers({
[17:37:38.010]                   NA
[17:37:38.010]                 }, immediateCondition = function(cond) {
[17:37:38.010]                   sendCondition <- ...future.makeSendCondition()
[17:37:38.010]                   sendCondition(cond)
[17:37:38.010]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.010]                   {
[17:37:38.010]                     inherits <- base::inherits
[17:37:38.010]                     invokeRestart <- base::invokeRestart
[17:37:38.010]                     is.null <- base::is.null
[17:37:38.010]                     muffled <- FALSE
[17:37:38.010]                     if (inherits(cond, "message")) {
[17:37:38.010]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:38.010]                       if (muffled) 
[17:37:38.010]                         invokeRestart("muffleMessage")
[17:37:38.010]                     }
[17:37:38.010]                     else if (inherits(cond, "warning")) {
[17:37:38.010]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:38.010]                       if (muffled) 
[17:37:38.010]                         invokeRestart("muffleWarning")
[17:37:38.010]                     }
[17:37:38.010]                     else if (inherits(cond, "condition")) {
[17:37:38.010]                       if (!is.null(pattern)) {
[17:37:38.010]                         computeRestarts <- base::computeRestarts
[17:37:38.010]                         grepl <- base::grepl
[17:37:38.010]                         restarts <- computeRestarts(cond)
[17:37:38.010]                         for (restart in restarts) {
[17:37:38.010]                           name <- restart$name
[17:37:38.010]                           if (is.null(name)) 
[17:37:38.010]                             next
[17:37:38.010]                           if (!grepl(pattern, name)) 
[17:37:38.010]                             next
[17:37:38.010]                           invokeRestart(restart)
[17:37:38.010]                           muffled <- TRUE
[17:37:38.010]                           break
[17:37:38.010]                         }
[17:37:38.010]                       }
[17:37:38.010]                     }
[17:37:38.010]                     invisible(muffled)
[17:37:38.010]                   }
[17:37:38.010]                   muffleCondition(cond)
[17:37:38.010]                 })
[17:37:38.010]             }))
[17:37:38.010]             future::FutureResult(value = ...future.value$value, 
[17:37:38.010]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.010]                   ...future.rng), globalenv = if (FALSE) 
[17:37:38.010]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:38.010]                     ...future.globalenv.names))
[17:37:38.010]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:38.010]         }, condition = base::local({
[17:37:38.010]             c <- base::c
[17:37:38.010]             inherits <- base::inherits
[17:37:38.010]             invokeRestart <- base::invokeRestart
[17:37:38.010]             length <- base::length
[17:37:38.010]             list <- base::list
[17:37:38.010]             seq.int <- base::seq.int
[17:37:38.010]             signalCondition <- base::signalCondition
[17:37:38.010]             sys.calls <- base::sys.calls
[17:37:38.010]             `[[` <- base::`[[`
[17:37:38.010]             `+` <- base::`+`
[17:37:38.010]             `<<-` <- base::`<<-`
[17:37:38.010]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:38.010]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:38.010]                   3L)]
[17:37:38.010]             }
[17:37:38.010]             function(cond) {
[17:37:38.010]                 is_error <- inherits(cond, "error")
[17:37:38.010]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:38.010]                   NULL)
[17:37:38.010]                 if (is_error) {
[17:37:38.010]                   sessionInformation <- function() {
[17:37:38.010]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:38.010]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:38.010]                       search = base::search(), system = base::Sys.info())
[17:37:38.010]                   }
[17:37:38.010]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.010]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:38.010]                     cond$call), session = sessionInformation(), 
[17:37:38.010]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:38.010]                   signalCondition(cond)
[17:37:38.010]                 }
[17:37:38.010]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:38.010]                 "immediateCondition"))) {
[17:37:38.010]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:38.010]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.010]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:38.010]                   if (TRUE && !signal) {
[17:37:38.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.010]                     {
[17:37:38.010]                       inherits <- base::inherits
[17:37:38.010]                       invokeRestart <- base::invokeRestart
[17:37:38.010]                       is.null <- base::is.null
[17:37:38.010]                       muffled <- FALSE
[17:37:38.010]                       if (inherits(cond, "message")) {
[17:37:38.010]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.010]                         if (muffled) 
[17:37:38.010]                           invokeRestart("muffleMessage")
[17:37:38.010]                       }
[17:37:38.010]                       else if (inherits(cond, "warning")) {
[17:37:38.010]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.010]                         if (muffled) 
[17:37:38.010]                           invokeRestart("muffleWarning")
[17:37:38.010]                       }
[17:37:38.010]                       else if (inherits(cond, "condition")) {
[17:37:38.010]                         if (!is.null(pattern)) {
[17:37:38.010]                           computeRestarts <- base::computeRestarts
[17:37:38.010]                           grepl <- base::grepl
[17:37:38.010]                           restarts <- computeRestarts(cond)
[17:37:38.010]                           for (restart in restarts) {
[17:37:38.010]                             name <- restart$name
[17:37:38.010]                             if (is.null(name)) 
[17:37:38.010]                               next
[17:37:38.010]                             if (!grepl(pattern, name)) 
[17:37:38.010]                               next
[17:37:38.010]                             invokeRestart(restart)
[17:37:38.010]                             muffled <- TRUE
[17:37:38.010]                             break
[17:37:38.010]                           }
[17:37:38.010]                         }
[17:37:38.010]                       }
[17:37:38.010]                       invisible(muffled)
[17:37:38.010]                     }
[17:37:38.010]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.010]                   }
[17:37:38.010]                 }
[17:37:38.010]                 else {
[17:37:38.010]                   if (TRUE) {
[17:37:38.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.010]                     {
[17:37:38.010]                       inherits <- base::inherits
[17:37:38.010]                       invokeRestart <- base::invokeRestart
[17:37:38.010]                       is.null <- base::is.null
[17:37:38.010]                       muffled <- FALSE
[17:37:38.010]                       if (inherits(cond, "message")) {
[17:37:38.010]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.010]                         if (muffled) 
[17:37:38.010]                           invokeRestart("muffleMessage")
[17:37:38.010]                       }
[17:37:38.010]                       else if (inherits(cond, "warning")) {
[17:37:38.010]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.010]                         if (muffled) 
[17:37:38.010]                           invokeRestart("muffleWarning")
[17:37:38.010]                       }
[17:37:38.010]                       else if (inherits(cond, "condition")) {
[17:37:38.010]                         if (!is.null(pattern)) {
[17:37:38.010]                           computeRestarts <- base::computeRestarts
[17:37:38.010]                           grepl <- base::grepl
[17:37:38.010]                           restarts <- computeRestarts(cond)
[17:37:38.010]                           for (restart in restarts) {
[17:37:38.010]                             name <- restart$name
[17:37:38.010]                             if (is.null(name)) 
[17:37:38.010]                               next
[17:37:38.010]                             if (!grepl(pattern, name)) 
[17:37:38.010]                               next
[17:37:38.010]                             invokeRestart(restart)
[17:37:38.010]                             muffled <- TRUE
[17:37:38.010]                             break
[17:37:38.010]                           }
[17:37:38.010]                         }
[17:37:38.010]                       }
[17:37:38.010]                       invisible(muffled)
[17:37:38.010]                     }
[17:37:38.010]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.010]                   }
[17:37:38.010]                 }
[17:37:38.010]             }
[17:37:38.010]         }))
[17:37:38.010]     }, error = function(ex) {
[17:37:38.010]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:38.010]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.010]                 ...future.rng), started = ...future.startTime, 
[17:37:38.010]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:38.010]             version = "1.8"), class = "FutureResult")
[17:37:38.010]     }, finally = {
[17:37:38.010]         if (!identical(...future.workdir, getwd())) 
[17:37:38.010]             setwd(...future.workdir)
[17:37:38.010]         {
[17:37:38.010]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:38.010]                 ...future.oldOptions$nwarnings <- NULL
[17:37:38.010]             }
[17:37:38.010]             base::options(...future.oldOptions)
[17:37:38.010]             if (.Platform$OS.type == "windows") {
[17:37:38.010]                 old_names <- names(...future.oldEnvVars)
[17:37:38.010]                 envs <- base::Sys.getenv()
[17:37:38.010]                 names <- names(envs)
[17:37:38.010]                 common <- intersect(names, old_names)
[17:37:38.010]                 added <- setdiff(names, old_names)
[17:37:38.010]                 removed <- setdiff(old_names, names)
[17:37:38.010]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:38.010]                   envs[common]]
[17:37:38.010]                 NAMES <- toupper(changed)
[17:37:38.010]                 args <- list()
[17:37:38.010]                 for (kk in seq_along(NAMES)) {
[17:37:38.010]                   name <- changed[[kk]]
[17:37:38.010]                   NAME <- NAMES[[kk]]
[17:37:38.010]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.010]                     next
[17:37:38.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.010]                 }
[17:37:38.010]                 NAMES <- toupper(added)
[17:37:38.010]                 for (kk in seq_along(NAMES)) {
[17:37:38.010]                   name <- added[[kk]]
[17:37:38.010]                   NAME <- NAMES[[kk]]
[17:37:38.010]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.010]                     next
[17:37:38.010]                   args[[name]] <- ""
[17:37:38.010]                 }
[17:37:38.010]                 NAMES <- toupper(removed)
[17:37:38.010]                 for (kk in seq_along(NAMES)) {
[17:37:38.010]                   name <- removed[[kk]]
[17:37:38.010]                   NAME <- NAMES[[kk]]
[17:37:38.010]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.010]                     next
[17:37:38.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.010]                 }
[17:37:38.010]                 if (length(args) > 0) 
[17:37:38.010]                   base::do.call(base::Sys.setenv, args = args)
[17:37:38.010]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:38.010]             }
[17:37:38.010]             else {
[17:37:38.010]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:38.010]             }
[17:37:38.010]             {
[17:37:38.010]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:38.010]                   0L) {
[17:37:38.010]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:38.010]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:38.010]                   base::options(opts)
[17:37:38.010]                 }
[17:37:38.010]                 {
[17:37:38.010]                   {
[17:37:38.010]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:38.010]                     NULL
[17:37:38.010]                   }
[17:37:38.010]                   options(future.plan = NULL)
[17:37:38.010]                   if (is.na(NA_character_)) 
[17:37:38.010]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.010]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:38.010]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:38.010]                     .init = FALSE)
[17:37:38.010]                 }
[17:37:38.010]             }
[17:37:38.010]         }
[17:37:38.010]     })
[17:37:38.010]     if (TRUE) {
[17:37:38.010]         base::sink(type = "output", split = FALSE)
[17:37:38.010]         if (TRUE) {
[17:37:38.010]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:38.010]         }
[17:37:38.010]         else {
[17:37:38.010]             ...future.result["stdout"] <- base::list(NULL)
[17:37:38.010]         }
[17:37:38.010]         base::close(...future.stdout)
[17:37:38.010]         ...future.stdout <- NULL
[17:37:38.010]     }
[17:37:38.010]     ...future.result$conditions <- ...future.conditions
[17:37:38.010]     ...future.result$finished <- base::Sys.time()
[17:37:38.010]     ...future.result
[17:37:38.010] }
[17:37:38.062] MultisessionFuture started
[17:37:38.063] result() for ClusterFuture ...
[17:37:38.063] receiveMessageFromWorker() for ClusterFuture ...
[17:37:38.063] - Validating connection of MultisessionFuture
[17:37:38.095] - received message: FutureResult
[17:37:38.095] - Received FutureResult
[17:37:38.095] - Erased future from FutureRegistry
[17:37:38.096] result() for ClusterFuture ...
[17:37:38.096] - result already collected: FutureResult
[17:37:38.096] result() for ClusterFuture ... done
[17:37:38.096] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:38.096] result() for ClusterFuture ... done
[17:37:38.096] result() for ClusterFuture ...
[17:37:38.096] - result already collected: FutureResult
[17:37:38.096] result() for ClusterFuture ... done
[17:37:38.096] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:37:38.100] plan(): nbrOfWorkers() = 2
- From example(mapply) ...
[17:37:38.100] future_mapply() ...
[17:37:38.104] Number of chunks: 2
[17:37:38.104] getGlobalsAndPackagesXApply() ...
[17:37:38.104]  - future.globals: TRUE
[17:37:38.104] getGlobalsAndPackages() ...
[17:37:38.104] Searching for globals...
[17:37:38.105] - globals found: [1] ‘FUN’
[17:37:38.105] Searching for globals ... DONE
[17:37:38.105] Resolving globals: FALSE
[17:37:38.105] The total size of the 1 globals is 56 bytes (56 bytes)
[17:37:38.106] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:37:38.106] - globals: [1] ‘FUN’
[17:37:38.106] 
[17:37:38.106] getGlobalsAndPackages() ... DONE
[17:37:38.106]  - globals found/used: [n=1] ‘FUN’
[17:37:38.106]  - needed namespaces: [n=0] 
[17:37:38.106] Finding globals ... DONE
[17:37:38.107] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:38.107] List of 2
[17:37:38.107]  $ ...future.FUN:function (x, ...)  
[17:37:38.107]  $ MoreArgs     : NULL
[17:37:38.107]  - attr(*, "where")=List of 2
[17:37:38.107]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:38.107]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:38.107]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:38.107]  - attr(*, "resolved")= logi FALSE
[17:37:38.107]  - attr(*, "total_size")= num NA
[17:37:38.110] Packages to be attached in all futures: [n=0] 
[17:37:38.110] getGlobalsAndPackagesXApply() ... DONE
[17:37:38.110] Number of futures (= number of chunks): 2
[17:37:38.110] Launching 2 futures (chunks) ...
[17:37:38.111] Chunk #1 of 2 ...
[17:37:38.111]  - Finding globals in '...' for chunk #1 ...
[17:37:38.111] getGlobalsAndPackages() ...
[17:37:38.111] Searching for globals...
[17:37:38.111] 
[17:37:38.111] Searching for globals ... DONE
[17:37:38.112] - globals: [0] <none>
[17:37:38.112] getGlobalsAndPackages() ... DONE
[17:37:38.112]    + additional globals found: [n=0] 
[17:37:38.112]    + additional namespaces needed: [n=0] 
[17:37:38.112]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:38.112]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:38.112]  - seeds: <none>
[17:37:38.112]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.113] getGlobalsAndPackages() ...
[17:37:38.113] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.113] Resolving globals: FALSE
[17:37:38.113] The total size of the 5 globals is 280 bytes (280 bytes)
[17:37:38.114] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:38.114] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.114] 
[17:37:38.114] getGlobalsAndPackages() ... DONE
[17:37:38.115] run() for ‘Future’ ...
[17:37:38.115] - state: ‘created’
[17:37:38.115] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:38.129] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.130] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:38.130]   - Field: ‘node’
[17:37:38.130]   - Field: ‘label’
[17:37:38.130]   - Field: ‘local’
[17:37:38.130]   - Field: ‘owner’
[17:37:38.130]   - Field: ‘envir’
[17:37:38.130]   - Field: ‘workers’
[17:37:38.130]   - Field: ‘packages’
[17:37:38.130]   - Field: ‘gc’
[17:37:38.130]   - Field: ‘conditions’
[17:37:38.131]   - Field: ‘persistent’
[17:37:38.131]   - Field: ‘expr’
[17:37:38.131]   - Field: ‘uuid’
[17:37:38.131]   - Field: ‘seed’
[17:37:38.131]   - Field: ‘version’
[17:37:38.131]   - Field: ‘result’
[17:37:38.131]   - Field: ‘asynchronous’
[17:37:38.131]   - Field: ‘calls’
[17:37:38.131]   - Field: ‘globals’
[17:37:38.132]   - Field: ‘stdout’
[17:37:38.132]   - Field: ‘earlySignal’
[17:37:38.132]   - Field: ‘lazy’
[17:37:38.132]   - Field: ‘state’
[17:37:38.132] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:38.132] - Launch lazy future ...
[17:37:38.133] Packages needed by the future expression (n = 0): <none>
[17:37:38.133] Packages needed by future strategies (n = 0): <none>
[17:37:38.133] {
[17:37:38.133]     {
[17:37:38.133]         {
[17:37:38.133]             ...future.startTime <- base::Sys.time()
[17:37:38.133]             {
[17:37:38.133]                 {
[17:37:38.133]                   {
[17:37:38.133]                     {
[17:37:38.133]                       base::local({
[17:37:38.133]                         has_future <- base::requireNamespace("future", 
[17:37:38.133]                           quietly = TRUE)
[17:37:38.133]                         if (has_future) {
[17:37:38.133]                           ns <- base::getNamespace("future")
[17:37:38.133]                           version <- ns[[".package"]][["version"]]
[17:37:38.133]                           if (is.null(version)) 
[17:37:38.133]                             version <- utils::packageVersion("future")
[17:37:38.133]                         }
[17:37:38.133]                         else {
[17:37:38.133]                           version <- NULL
[17:37:38.133]                         }
[17:37:38.133]                         if (!has_future || version < "1.8.0") {
[17:37:38.133]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:38.133]                             "", base::R.version$version.string), 
[17:37:38.133]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:38.133]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:38.133]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:38.133]                               "release", "version")], collapse = " "), 
[17:37:38.133]                             hostname = base::Sys.info()[["nodename"]])
[17:37:38.133]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:38.133]                             info)
[17:37:38.133]                           info <- base::paste(info, collapse = "; ")
[17:37:38.133]                           if (!has_future) {
[17:37:38.133]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:38.133]                               info)
[17:37:38.133]                           }
[17:37:38.133]                           else {
[17:37:38.133]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:38.133]                               info, version)
[17:37:38.133]                           }
[17:37:38.133]                           base::stop(msg)
[17:37:38.133]                         }
[17:37:38.133]                       })
[17:37:38.133]                     }
[17:37:38.133]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:38.133]                     base::options(mc.cores = 1L)
[17:37:38.133]                   }
[17:37:38.133]                   ...future.strategy.old <- future::plan("list")
[17:37:38.133]                   options(future.plan = NULL)
[17:37:38.133]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.133]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:38.133]                 }
[17:37:38.133]                 ...future.workdir <- getwd()
[17:37:38.133]             }
[17:37:38.133]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:38.133]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:38.133]         }
[17:37:38.133]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:38.133]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:38.133]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:38.133]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:38.133]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:38.133]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:38.133]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:38.133]             base::names(...future.oldOptions))
[17:37:38.133]     }
[17:37:38.133]     if (FALSE) {
[17:37:38.133]     }
[17:37:38.133]     else {
[17:37:38.133]         if (TRUE) {
[17:37:38.133]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:38.133]                 open = "w")
[17:37:38.133]         }
[17:37:38.133]         else {
[17:37:38.133]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:38.133]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:38.133]         }
[17:37:38.133]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:38.133]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:38.133]             base::sink(type = "output", split = FALSE)
[17:37:38.133]             base::close(...future.stdout)
[17:37:38.133]         }, add = TRUE)
[17:37:38.133]     }
[17:37:38.133]     ...future.frame <- base::sys.nframe()
[17:37:38.133]     ...future.conditions <- base::list()
[17:37:38.133]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:38.133]     if (FALSE) {
[17:37:38.133]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:38.133]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:38.133]     }
[17:37:38.133]     ...future.result <- base::tryCatch({
[17:37:38.133]         base::withCallingHandlers({
[17:37:38.133]             ...future.value <- base::withVisible(base::local({
[17:37:38.133]                 ...future.makeSendCondition <- base::local({
[17:37:38.133]                   sendCondition <- NULL
[17:37:38.133]                   function(frame = 1L) {
[17:37:38.133]                     if (is.function(sendCondition)) 
[17:37:38.133]                       return(sendCondition)
[17:37:38.133]                     ns <- getNamespace("parallel")
[17:37:38.133]                     if (exists("sendData", mode = "function", 
[17:37:38.133]                       envir = ns)) {
[17:37:38.133]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:38.133]                         envir = ns)
[17:37:38.133]                       envir <- sys.frame(frame)
[17:37:38.133]                       master <- NULL
[17:37:38.133]                       while (!identical(envir, .GlobalEnv) && 
[17:37:38.133]                         !identical(envir, emptyenv())) {
[17:37:38.133]                         if (exists("master", mode = "list", envir = envir, 
[17:37:38.133]                           inherits = FALSE)) {
[17:37:38.133]                           master <- get("master", mode = "list", 
[17:37:38.133]                             envir = envir, inherits = FALSE)
[17:37:38.133]                           if (inherits(master, c("SOCKnode", 
[17:37:38.133]                             "SOCK0node"))) {
[17:37:38.133]                             sendCondition <<- function(cond) {
[17:37:38.133]                               data <- list(type = "VALUE", value = cond, 
[17:37:38.133]                                 success = TRUE)
[17:37:38.133]                               parallel_sendData(master, data)
[17:37:38.133]                             }
[17:37:38.133]                             return(sendCondition)
[17:37:38.133]                           }
[17:37:38.133]                         }
[17:37:38.133]                         frame <- frame + 1L
[17:37:38.133]                         envir <- sys.frame(frame)
[17:37:38.133]                       }
[17:37:38.133]                     }
[17:37:38.133]                     sendCondition <<- function(cond) NULL
[17:37:38.133]                   }
[17:37:38.133]                 })
[17:37:38.133]                 withCallingHandlers({
[17:37:38.133]                   {
[17:37:38.133]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.133]                     if (!identical(...future.globals.maxSize.org, 
[17:37:38.133]                       ...future.globals.maxSize)) {
[17:37:38.133]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.133]                       on.exit(options(oopts), add = TRUE)
[17:37:38.133]                     }
[17:37:38.133]                     {
[17:37:38.133]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.133]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:38.133]                         USE.NAMES = FALSE)
[17:37:38.133]                       do.call(mapply, args = args)
[17:37:38.133]                     }
[17:37:38.133]                   }
[17:37:38.133]                 }, immediateCondition = function(cond) {
[17:37:38.133]                   sendCondition <- ...future.makeSendCondition()
[17:37:38.133]                   sendCondition(cond)
[17:37:38.133]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.133]                   {
[17:37:38.133]                     inherits <- base::inherits
[17:37:38.133]                     invokeRestart <- base::invokeRestart
[17:37:38.133]                     is.null <- base::is.null
[17:37:38.133]                     muffled <- FALSE
[17:37:38.133]                     if (inherits(cond, "message")) {
[17:37:38.133]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:38.133]                       if (muffled) 
[17:37:38.133]                         invokeRestart("muffleMessage")
[17:37:38.133]                     }
[17:37:38.133]                     else if (inherits(cond, "warning")) {
[17:37:38.133]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:38.133]                       if (muffled) 
[17:37:38.133]                         invokeRestart("muffleWarning")
[17:37:38.133]                     }
[17:37:38.133]                     else if (inherits(cond, "condition")) {
[17:37:38.133]                       if (!is.null(pattern)) {
[17:37:38.133]                         computeRestarts <- base::computeRestarts
[17:37:38.133]                         grepl <- base::grepl
[17:37:38.133]                         restarts <- computeRestarts(cond)
[17:37:38.133]                         for (restart in restarts) {
[17:37:38.133]                           name <- restart$name
[17:37:38.133]                           if (is.null(name)) 
[17:37:38.133]                             next
[17:37:38.133]                           if (!grepl(pattern, name)) 
[17:37:38.133]                             next
[17:37:38.133]                           invokeRestart(restart)
[17:37:38.133]                           muffled <- TRUE
[17:37:38.133]                           break
[17:37:38.133]                         }
[17:37:38.133]                       }
[17:37:38.133]                     }
[17:37:38.133]                     invisible(muffled)
[17:37:38.133]                   }
[17:37:38.133]                   muffleCondition(cond)
[17:37:38.133]                 })
[17:37:38.133]             }))
[17:37:38.133]             future::FutureResult(value = ...future.value$value, 
[17:37:38.133]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.133]                   ...future.rng), globalenv = if (FALSE) 
[17:37:38.133]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:38.133]                     ...future.globalenv.names))
[17:37:38.133]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:38.133]         }, condition = base::local({
[17:37:38.133]             c <- base::c
[17:37:38.133]             inherits <- base::inherits
[17:37:38.133]             invokeRestart <- base::invokeRestart
[17:37:38.133]             length <- base::length
[17:37:38.133]             list <- base::list
[17:37:38.133]             seq.int <- base::seq.int
[17:37:38.133]             signalCondition <- base::signalCondition
[17:37:38.133]             sys.calls <- base::sys.calls
[17:37:38.133]             `[[` <- base::`[[`
[17:37:38.133]             `+` <- base::`+`
[17:37:38.133]             `<<-` <- base::`<<-`
[17:37:38.133]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:38.133]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:38.133]                   3L)]
[17:37:38.133]             }
[17:37:38.133]             function(cond) {
[17:37:38.133]                 is_error <- inherits(cond, "error")
[17:37:38.133]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:38.133]                   NULL)
[17:37:38.133]                 if (is_error) {
[17:37:38.133]                   sessionInformation <- function() {
[17:37:38.133]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:38.133]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:38.133]                       search = base::search(), system = base::Sys.info())
[17:37:38.133]                   }
[17:37:38.133]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.133]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:38.133]                     cond$call), session = sessionInformation(), 
[17:37:38.133]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:38.133]                   signalCondition(cond)
[17:37:38.133]                 }
[17:37:38.133]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:38.133]                 "immediateCondition"))) {
[17:37:38.133]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:38.133]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.133]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:38.133]                   if (TRUE && !signal) {
[17:37:38.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.133]                     {
[17:37:38.133]                       inherits <- base::inherits
[17:37:38.133]                       invokeRestart <- base::invokeRestart
[17:37:38.133]                       is.null <- base::is.null
[17:37:38.133]                       muffled <- FALSE
[17:37:38.133]                       if (inherits(cond, "message")) {
[17:37:38.133]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.133]                         if (muffled) 
[17:37:38.133]                           invokeRestart("muffleMessage")
[17:37:38.133]                       }
[17:37:38.133]                       else if (inherits(cond, "warning")) {
[17:37:38.133]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.133]                         if (muffled) 
[17:37:38.133]                           invokeRestart("muffleWarning")
[17:37:38.133]                       }
[17:37:38.133]                       else if (inherits(cond, "condition")) {
[17:37:38.133]                         if (!is.null(pattern)) {
[17:37:38.133]                           computeRestarts <- base::computeRestarts
[17:37:38.133]                           grepl <- base::grepl
[17:37:38.133]                           restarts <- computeRestarts(cond)
[17:37:38.133]                           for (restart in restarts) {
[17:37:38.133]                             name <- restart$name
[17:37:38.133]                             if (is.null(name)) 
[17:37:38.133]                               next
[17:37:38.133]                             if (!grepl(pattern, name)) 
[17:37:38.133]                               next
[17:37:38.133]                             invokeRestart(restart)
[17:37:38.133]                             muffled <- TRUE
[17:37:38.133]                             break
[17:37:38.133]                           }
[17:37:38.133]                         }
[17:37:38.133]                       }
[17:37:38.133]                       invisible(muffled)
[17:37:38.133]                     }
[17:37:38.133]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.133]                   }
[17:37:38.133]                 }
[17:37:38.133]                 else {
[17:37:38.133]                   if (TRUE) {
[17:37:38.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.133]                     {
[17:37:38.133]                       inherits <- base::inherits
[17:37:38.133]                       invokeRestart <- base::invokeRestart
[17:37:38.133]                       is.null <- base::is.null
[17:37:38.133]                       muffled <- FALSE
[17:37:38.133]                       if (inherits(cond, "message")) {
[17:37:38.133]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.133]                         if (muffled) 
[17:37:38.133]                           invokeRestart("muffleMessage")
[17:37:38.133]                       }
[17:37:38.133]                       else if (inherits(cond, "warning")) {
[17:37:38.133]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.133]                         if (muffled) 
[17:37:38.133]                           invokeRestart("muffleWarning")
[17:37:38.133]                       }
[17:37:38.133]                       else if (inherits(cond, "condition")) {
[17:37:38.133]                         if (!is.null(pattern)) {
[17:37:38.133]                           computeRestarts <- base::computeRestarts
[17:37:38.133]                           grepl <- base::grepl
[17:37:38.133]                           restarts <- computeRestarts(cond)
[17:37:38.133]                           for (restart in restarts) {
[17:37:38.133]                             name <- restart$name
[17:37:38.133]                             if (is.null(name)) 
[17:37:38.133]                               next
[17:37:38.133]                             if (!grepl(pattern, name)) 
[17:37:38.133]                               next
[17:37:38.133]                             invokeRestart(restart)
[17:37:38.133]                             muffled <- TRUE
[17:37:38.133]                             break
[17:37:38.133]                           }
[17:37:38.133]                         }
[17:37:38.133]                       }
[17:37:38.133]                       invisible(muffled)
[17:37:38.133]                     }
[17:37:38.133]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.133]                   }
[17:37:38.133]                 }
[17:37:38.133]             }
[17:37:38.133]         }))
[17:37:38.133]     }, error = function(ex) {
[17:37:38.133]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:38.133]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.133]                 ...future.rng), started = ...future.startTime, 
[17:37:38.133]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:38.133]             version = "1.8"), class = "FutureResult")
[17:37:38.133]     }, finally = {
[17:37:38.133]         if (!identical(...future.workdir, getwd())) 
[17:37:38.133]             setwd(...future.workdir)
[17:37:38.133]         {
[17:37:38.133]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:38.133]                 ...future.oldOptions$nwarnings <- NULL
[17:37:38.133]             }
[17:37:38.133]             base::options(...future.oldOptions)
[17:37:38.133]             if (.Platform$OS.type == "windows") {
[17:37:38.133]                 old_names <- names(...future.oldEnvVars)
[17:37:38.133]                 envs <- base::Sys.getenv()
[17:37:38.133]                 names <- names(envs)
[17:37:38.133]                 common <- intersect(names, old_names)
[17:37:38.133]                 added <- setdiff(names, old_names)
[17:37:38.133]                 removed <- setdiff(old_names, names)
[17:37:38.133]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:38.133]                   envs[common]]
[17:37:38.133]                 NAMES <- toupper(changed)
[17:37:38.133]                 args <- list()
[17:37:38.133]                 for (kk in seq_along(NAMES)) {
[17:37:38.133]                   name <- changed[[kk]]
[17:37:38.133]                   NAME <- NAMES[[kk]]
[17:37:38.133]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.133]                     next
[17:37:38.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.133]                 }
[17:37:38.133]                 NAMES <- toupper(added)
[17:37:38.133]                 for (kk in seq_along(NAMES)) {
[17:37:38.133]                   name <- added[[kk]]
[17:37:38.133]                   NAME <- NAMES[[kk]]
[17:37:38.133]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.133]                     next
[17:37:38.133]                   args[[name]] <- ""
[17:37:38.133]                 }
[17:37:38.133]                 NAMES <- toupper(removed)
[17:37:38.133]                 for (kk in seq_along(NAMES)) {
[17:37:38.133]                   name <- removed[[kk]]
[17:37:38.133]                   NAME <- NAMES[[kk]]
[17:37:38.133]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.133]                     next
[17:37:38.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.133]                 }
[17:37:38.133]                 if (length(args) > 0) 
[17:37:38.133]                   base::do.call(base::Sys.setenv, args = args)
[17:37:38.133]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:38.133]             }
[17:37:38.133]             else {
[17:37:38.133]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:38.133]             }
[17:37:38.133]             {
[17:37:38.133]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:38.133]                   0L) {
[17:37:38.133]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:38.133]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:38.133]                   base::options(opts)
[17:37:38.133]                 }
[17:37:38.133]                 {
[17:37:38.133]                   {
[17:37:38.133]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:38.133]                     NULL
[17:37:38.133]                   }
[17:37:38.133]                   options(future.plan = NULL)
[17:37:38.133]                   if (is.na(NA_character_)) 
[17:37:38.133]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.133]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:38.133]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:38.133]                     .init = FALSE)
[17:37:38.133]                 }
[17:37:38.133]             }
[17:37:38.133]         }
[17:37:38.133]     })
[17:37:38.133]     if (TRUE) {
[17:37:38.133]         base::sink(type = "output", split = FALSE)
[17:37:38.133]         if (TRUE) {
[17:37:38.133]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:38.133]         }
[17:37:38.133]         else {
[17:37:38.133]             ...future.result["stdout"] <- base::list(NULL)
[17:37:38.133]         }
[17:37:38.133]         base::close(...future.stdout)
[17:37:38.133]         ...future.stdout <- NULL
[17:37:38.133]     }
[17:37:38.133]     ...future.result$conditions <- ...future.conditions
[17:37:38.133]     ...future.result$finished <- base::Sys.time()
[17:37:38.133]     ...future.result
[17:37:38.133] }
[17:37:38.136] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[17:37:38.137] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[17:37:38.137] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[17:37:38.137] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:37:38.138] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:37:38.138] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[17:37:38.138] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[17:37:38.138] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:38.139] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:38.139] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:38.139] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:38.139] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[17:37:38.140] MultisessionFuture started
[17:37:38.140] - Launch lazy future ... done
[17:37:38.140] run() for ‘MultisessionFuture’ ... done
[17:37:38.140] Created future:
[17:37:38.140] MultisessionFuture:
[17:37:38.140] Label: ‘future_mapply-1’
[17:37:38.140] Expression:
[17:37:38.140] {
[17:37:38.140]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.140]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:38.140]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.140]         on.exit(options(oopts), add = TRUE)
[17:37:38.140]     }
[17:37:38.140]     {
[17:37:38.140]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.140]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:38.140]         do.call(mapply, args = args)
[17:37:38.140]     }
[17:37:38.140] }
[17:37:38.140] Lazy evaluation: FALSE
[17:37:38.140] Asynchronous evaluation: TRUE
[17:37:38.140] Local evaluation: TRUE
[17:37:38.140] Environment: R_GlobalEnv
[17:37:38.140] Capture standard output: TRUE
[17:37:38.140] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:38.140] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:38.140] Packages: <none>
[17:37:38.140] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:38.140] Resolved: FALSE
[17:37:38.140] Value: <not collected>
[17:37:38.140] Conditions captured: <none>
[17:37:38.140] Early signaling: FALSE
[17:37:38.140] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:38.140] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.152] Chunk #1 of 2 ... DONE
[17:37:38.152] Chunk #2 of 2 ...
[17:37:38.153]  - Finding globals in '...' for chunk #2 ...
[17:37:38.153] getGlobalsAndPackages() ...
[17:37:38.153] Searching for globals...
[17:37:38.153] 
[17:37:38.154] Searching for globals ... DONE
[17:37:38.154] - globals: [0] <none>
[17:37:38.154] getGlobalsAndPackages() ... DONE
[17:37:38.154]    + additional globals found: [n=0] 
[17:37:38.154]    + additional namespaces needed: [n=0] 
[17:37:38.154]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:38.154]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:38.154]  - seeds: <none>
[17:37:38.154]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.155] getGlobalsAndPackages() ...
[17:37:38.155] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.155] Resolving globals: FALSE
[17:37:38.155] The total size of the 5 globals is 280 bytes (280 bytes)
[17:37:38.156] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:38.156] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.156] 
[17:37:38.156] getGlobalsAndPackages() ... DONE
[17:37:38.157] run() for ‘Future’ ...
[17:37:38.157] - state: ‘created’
[17:37:38.157] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:38.172] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.172] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:38.172]   - Field: ‘node’
[17:37:38.172]   - Field: ‘label’
[17:37:38.172]   - Field: ‘local’
[17:37:38.172]   - Field: ‘owner’
[17:37:38.172]   - Field: ‘envir’
[17:37:38.172]   - Field: ‘workers’
[17:37:38.173]   - Field: ‘packages’
[17:37:38.173]   - Field: ‘gc’
[17:37:38.173]   - Field: ‘conditions’
[17:37:38.173]   - Field: ‘persistent’
[17:37:38.173]   - Field: ‘expr’
[17:37:38.173]   - Field: ‘uuid’
[17:37:38.173]   - Field: ‘seed’
[17:37:38.173]   - Field: ‘version’
[17:37:38.173]   - Field: ‘result’
[17:37:38.174]   - Field: ‘asynchronous’
[17:37:38.174]   - Field: ‘calls’
[17:37:38.174]   - Field: ‘globals’
[17:37:38.174]   - Field: ‘stdout’
[17:37:38.174]   - Field: ‘earlySignal’
[17:37:38.174]   - Field: ‘lazy’
[17:37:38.174]   - Field: ‘state’
[17:37:38.174] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:38.174] - Launch lazy future ...
[17:37:38.175] Packages needed by the future expression (n = 0): <none>
[17:37:38.175] Packages needed by future strategies (n = 0): <none>
[17:37:38.175] {
[17:37:38.175]     {
[17:37:38.175]         {
[17:37:38.175]             ...future.startTime <- base::Sys.time()
[17:37:38.175]             {
[17:37:38.175]                 {
[17:37:38.175]                   {
[17:37:38.175]                     {
[17:37:38.175]                       base::local({
[17:37:38.175]                         has_future <- base::requireNamespace("future", 
[17:37:38.175]                           quietly = TRUE)
[17:37:38.175]                         if (has_future) {
[17:37:38.175]                           ns <- base::getNamespace("future")
[17:37:38.175]                           version <- ns[[".package"]][["version"]]
[17:37:38.175]                           if (is.null(version)) 
[17:37:38.175]                             version <- utils::packageVersion("future")
[17:37:38.175]                         }
[17:37:38.175]                         else {
[17:37:38.175]                           version <- NULL
[17:37:38.175]                         }
[17:37:38.175]                         if (!has_future || version < "1.8.0") {
[17:37:38.175]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:38.175]                             "", base::R.version$version.string), 
[17:37:38.175]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:38.175]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:38.175]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:38.175]                               "release", "version")], collapse = " "), 
[17:37:38.175]                             hostname = base::Sys.info()[["nodename"]])
[17:37:38.175]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:38.175]                             info)
[17:37:38.175]                           info <- base::paste(info, collapse = "; ")
[17:37:38.175]                           if (!has_future) {
[17:37:38.175]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:38.175]                               info)
[17:37:38.175]                           }
[17:37:38.175]                           else {
[17:37:38.175]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:38.175]                               info, version)
[17:37:38.175]                           }
[17:37:38.175]                           base::stop(msg)
[17:37:38.175]                         }
[17:37:38.175]                       })
[17:37:38.175]                     }
[17:37:38.175]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:38.175]                     base::options(mc.cores = 1L)
[17:37:38.175]                   }
[17:37:38.175]                   ...future.strategy.old <- future::plan("list")
[17:37:38.175]                   options(future.plan = NULL)
[17:37:38.175]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.175]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:38.175]                 }
[17:37:38.175]                 ...future.workdir <- getwd()
[17:37:38.175]             }
[17:37:38.175]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:38.175]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:38.175]         }
[17:37:38.175]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:38.175]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:38.175]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:38.175]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:38.175]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:38.175]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:38.175]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:38.175]             base::names(...future.oldOptions))
[17:37:38.175]     }
[17:37:38.175]     if (FALSE) {
[17:37:38.175]     }
[17:37:38.175]     else {
[17:37:38.175]         if (TRUE) {
[17:37:38.175]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:38.175]                 open = "w")
[17:37:38.175]         }
[17:37:38.175]         else {
[17:37:38.175]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:38.175]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:38.175]         }
[17:37:38.175]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:38.175]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:38.175]             base::sink(type = "output", split = FALSE)
[17:37:38.175]             base::close(...future.stdout)
[17:37:38.175]         }, add = TRUE)
[17:37:38.175]     }
[17:37:38.175]     ...future.frame <- base::sys.nframe()
[17:37:38.175]     ...future.conditions <- base::list()
[17:37:38.175]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:38.175]     if (FALSE) {
[17:37:38.175]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:38.175]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:38.175]     }
[17:37:38.175]     ...future.result <- base::tryCatch({
[17:37:38.175]         base::withCallingHandlers({
[17:37:38.175]             ...future.value <- base::withVisible(base::local({
[17:37:38.175]                 ...future.makeSendCondition <- base::local({
[17:37:38.175]                   sendCondition <- NULL
[17:37:38.175]                   function(frame = 1L) {
[17:37:38.175]                     if (is.function(sendCondition)) 
[17:37:38.175]                       return(sendCondition)
[17:37:38.175]                     ns <- getNamespace("parallel")
[17:37:38.175]                     if (exists("sendData", mode = "function", 
[17:37:38.175]                       envir = ns)) {
[17:37:38.175]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:38.175]                         envir = ns)
[17:37:38.175]                       envir <- sys.frame(frame)
[17:37:38.175]                       master <- NULL
[17:37:38.175]                       while (!identical(envir, .GlobalEnv) && 
[17:37:38.175]                         !identical(envir, emptyenv())) {
[17:37:38.175]                         if (exists("master", mode = "list", envir = envir, 
[17:37:38.175]                           inherits = FALSE)) {
[17:37:38.175]                           master <- get("master", mode = "list", 
[17:37:38.175]                             envir = envir, inherits = FALSE)
[17:37:38.175]                           if (inherits(master, c("SOCKnode", 
[17:37:38.175]                             "SOCK0node"))) {
[17:37:38.175]                             sendCondition <<- function(cond) {
[17:37:38.175]                               data <- list(type = "VALUE", value = cond, 
[17:37:38.175]                                 success = TRUE)
[17:37:38.175]                               parallel_sendData(master, data)
[17:37:38.175]                             }
[17:37:38.175]                             return(sendCondition)
[17:37:38.175]                           }
[17:37:38.175]                         }
[17:37:38.175]                         frame <- frame + 1L
[17:37:38.175]                         envir <- sys.frame(frame)
[17:37:38.175]                       }
[17:37:38.175]                     }
[17:37:38.175]                     sendCondition <<- function(cond) NULL
[17:37:38.175]                   }
[17:37:38.175]                 })
[17:37:38.175]                 withCallingHandlers({
[17:37:38.175]                   {
[17:37:38.175]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.175]                     if (!identical(...future.globals.maxSize.org, 
[17:37:38.175]                       ...future.globals.maxSize)) {
[17:37:38.175]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.175]                       on.exit(options(oopts), add = TRUE)
[17:37:38.175]                     }
[17:37:38.175]                     {
[17:37:38.175]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.175]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:38.175]                         USE.NAMES = FALSE)
[17:37:38.175]                       do.call(mapply, args = args)
[17:37:38.175]                     }
[17:37:38.175]                   }
[17:37:38.175]                 }, immediateCondition = function(cond) {
[17:37:38.175]                   sendCondition <- ...future.makeSendCondition()
[17:37:38.175]                   sendCondition(cond)
[17:37:38.175]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.175]                   {
[17:37:38.175]                     inherits <- base::inherits
[17:37:38.175]                     invokeRestart <- base::invokeRestart
[17:37:38.175]                     is.null <- base::is.null
[17:37:38.175]                     muffled <- FALSE
[17:37:38.175]                     if (inherits(cond, "message")) {
[17:37:38.175]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:38.175]                       if (muffled) 
[17:37:38.175]                         invokeRestart("muffleMessage")
[17:37:38.175]                     }
[17:37:38.175]                     else if (inherits(cond, "warning")) {
[17:37:38.175]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:38.175]                       if (muffled) 
[17:37:38.175]                         invokeRestart("muffleWarning")
[17:37:38.175]                     }
[17:37:38.175]                     else if (inherits(cond, "condition")) {
[17:37:38.175]                       if (!is.null(pattern)) {
[17:37:38.175]                         computeRestarts <- base::computeRestarts
[17:37:38.175]                         grepl <- base::grepl
[17:37:38.175]                         restarts <- computeRestarts(cond)
[17:37:38.175]                         for (restart in restarts) {
[17:37:38.175]                           name <- restart$name
[17:37:38.175]                           if (is.null(name)) 
[17:37:38.175]                             next
[17:37:38.175]                           if (!grepl(pattern, name)) 
[17:37:38.175]                             next
[17:37:38.175]                           invokeRestart(restart)
[17:37:38.175]                           muffled <- TRUE
[17:37:38.175]                           break
[17:37:38.175]                         }
[17:37:38.175]                       }
[17:37:38.175]                     }
[17:37:38.175]                     invisible(muffled)
[17:37:38.175]                   }
[17:37:38.175]                   muffleCondition(cond)
[17:37:38.175]                 })
[17:37:38.175]             }))
[17:37:38.175]             future::FutureResult(value = ...future.value$value, 
[17:37:38.175]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.175]                   ...future.rng), globalenv = if (FALSE) 
[17:37:38.175]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:38.175]                     ...future.globalenv.names))
[17:37:38.175]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:38.175]         }, condition = base::local({
[17:37:38.175]             c <- base::c
[17:37:38.175]             inherits <- base::inherits
[17:37:38.175]             invokeRestart <- base::invokeRestart
[17:37:38.175]             length <- base::length
[17:37:38.175]             list <- base::list
[17:37:38.175]             seq.int <- base::seq.int
[17:37:38.175]             signalCondition <- base::signalCondition
[17:37:38.175]             sys.calls <- base::sys.calls
[17:37:38.175]             `[[` <- base::`[[`
[17:37:38.175]             `+` <- base::`+`
[17:37:38.175]             `<<-` <- base::`<<-`
[17:37:38.175]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:38.175]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:38.175]                   3L)]
[17:37:38.175]             }
[17:37:38.175]             function(cond) {
[17:37:38.175]                 is_error <- inherits(cond, "error")
[17:37:38.175]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:38.175]                   NULL)
[17:37:38.175]                 if (is_error) {
[17:37:38.175]                   sessionInformation <- function() {
[17:37:38.175]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:38.175]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:38.175]                       search = base::search(), system = base::Sys.info())
[17:37:38.175]                   }
[17:37:38.175]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.175]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:38.175]                     cond$call), session = sessionInformation(), 
[17:37:38.175]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:38.175]                   signalCondition(cond)
[17:37:38.175]                 }
[17:37:38.175]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:38.175]                 "immediateCondition"))) {
[17:37:38.175]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:38.175]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.175]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:38.175]                   if (TRUE && !signal) {
[17:37:38.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.175]                     {
[17:37:38.175]                       inherits <- base::inherits
[17:37:38.175]                       invokeRestart <- base::invokeRestart
[17:37:38.175]                       is.null <- base::is.null
[17:37:38.175]                       muffled <- FALSE
[17:37:38.175]                       if (inherits(cond, "message")) {
[17:37:38.175]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.175]                         if (muffled) 
[17:37:38.175]                           invokeRestart("muffleMessage")
[17:37:38.175]                       }
[17:37:38.175]                       else if (inherits(cond, "warning")) {
[17:37:38.175]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.175]                         if (muffled) 
[17:37:38.175]                           invokeRestart("muffleWarning")
[17:37:38.175]                       }
[17:37:38.175]                       else if (inherits(cond, "condition")) {
[17:37:38.175]                         if (!is.null(pattern)) {
[17:37:38.175]                           computeRestarts <- base::computeRestarts
[17:37:38.175]                           grepl <- base::grepl
[17:37:38.175]                           restarts <- computeRestarts(cond)
[17:37:38.175]                           for (restart in restarts) {
[17:37:38.175]                             name <- restart$name
[17:37:38.175]                             if (is.null(name)) 
[17:37:38.175]                               next
[17:37:38.175]                             if (!grepl(pattern, name)) 
[17:37:38.175]                               next
[17:37:38.175]                             invokeRestart(restart)
[17:37:38.175]                             muffled <- TRUE
[17:37:38.175]                             break
[17:37:38.175]                           }
[17:37:38.175]                         }
[17:37:38.175]                       }
[17:37:38.175]                       invisible(muffled)
[17:37:38.175]                     }
[17:37:38.175]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.175]                   }
[17:37:38.175]                 }
[17:37:38.175]                 else {
[17:37:38.175]                   if (TRUE) {
[17:37:38.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.175]                     {
[17:37:38.175]                       inherits <- base::inherits
[17:37:38.175]                       invokeRestart <- base::invokeRestart
[17:37:38.175]                       is.null <- base::is.null
[17:37:38.175]                       muffled <- FALSE
[17:37:38.175]                       if (inherits(cond, "message")) {
[17:37:38.175]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.175]                         if (muffled) 
[17:37:38.175]                           invokeRestart("muffleMessage")
[17:37:38.175]                       }
[17:37:38.175]                       else if (inherits(cond, "warning")) {
[17:37:38.175]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.175]                         if (muffled) 
[17:37:38.175]                           invokeRestart("muffleWarning")
[17:37:38.175]                       }
[17:37:38.175]                       else if (inherits(cond, "condition")) {
[17:37:38.175]                         if (!is.null(pattern)) {
[17:37:38.175]                           computeRestarts <- base::computeRestarts
[17:37:38.175]                           grepl <- base::grepl
[17:37:38.175]                           restarts <- computeRestarts(cond)
[17:37:38.175]                           for (restart in restarts) {
[17:37:38.175]                             name <- restart$name
[17:37:38.175]                             if (is.null(name)) 
[17:37:38.175]                               next
[17:37:38.175]                             if (!grepl(pattern, name)) 
[17:37:38.175]                               next
[17:37:38.175]                             invokeRestart(restart)
[17:37:38.175]                             muffled <- TRUE
[17:37:38.175]                             break
[17:37:38.175]                           }
[17:37:38.175]                         }
[17:37:38.175]                       }
[17:37:38.175]                       invisible(muffled)
[17:37:38.175]                     }
[17:37:38.175]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.175]                   }
[17:37:38.175]                 }
[17:37:38.175]             }
[17:37:38.175]         }))
[17:37:38.175]     }, error = function(ex) {
[17:37:38.175]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:38.175]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.175]                 ...future.rng), started = ...future.startTime, 
[17:37:38.175]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:38.175]             version = "1.8"), class = "FutureResult")
[17:37:38.175]     }, finally = {
[17:37:38.175]         if (!identical(...future.workdir, getwd())) 
[17:37:38.175]             setwd(...future.workdir)
[17:37:38.175]         {
[17:37:38.175]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:38.175]                 ...future.oldOptions$nwarnings <- NULL
[17:37:38.175]             }
[17:37:38.175]             base::options(...future.oldOptions)
[17:37:38.175]             if (.Platform$OS.type == "windows") {
[17:37:38.175]                 old_names <- names(...future.oldEnvVars)
[17:37:38.175]                 envs <- base::Sys.getenv()
[17:37:38.175]                 names <- names(envs)
[17:37:38.175]                 common <- intersect(names, old_names)
[17:37:38.175]                 added <- setdiff(names, old_names)
[17:37:38.175]                 removed <- setdiff(old_names, names)
[17:37:38.175]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:38.175]                   envs[common]]
[17:37:38.175]                 NAMES <- toupper(changed)
[17:37:38.175]                 args <- list()
[17:37:38.175]                 for (kk in seq_along(NAMES)) {
[17:37:38.175]                   name <- changed[[kk]]
[17:37:38.175]                   NAME <- NAMES[[kk]]
[17:37:38.175]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.175]                     next
[17:37:38.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.175]                 }
[17:37:38.175]                 NAMES <- toupper(added)
[17:37:38.175]                 for (kk in seq_along(NAMES)) {
[17:37:38.175]                   name <- added[[kk]]
[17:37:38.175]                   NAME <- NAMES[[kk]]
[17:37:38.175]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.175]                     next
[17:37:38.175]                   args[[name]] <- ""
[17:37:38.175]                 }
[17:37:38.175]                 NAMES <- toupper(removed)
[17:37:38.175]                 for (kk in seq_along(NAMES)) {
[17:37:38.175]                   name <- removed[[kk]]
[17:37:38.175]                   NAME <- NAMES[[kk]]
[17:37:38.175]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.175]                     next
[17:37:38.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.175]                 }
[17:37:38.175]                 if (length(args) > 0) 
[17:37:38.175]                   base::do.call(base::Sys.setenv, args = args)
[17:37:38.175]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:38.175]             }
[17:37:38.175]             else {
[17:37:38.175]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:38.175]             }
[17:37:38.175]             {
[17:37:38.175]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:38.175]                   0L) {
[17:37:38.175]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:38.175]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:38.175]                   base::options(opts)
[17:37:38.175]                 }
[17:37:38.175]                 {
[17:37:38.175]                   {
[17:37:38.175]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:38.175]                     NULL
[17:37:38.175]                   }
[17:37:38.175]                   options(future.plan = NULL)
[17:37:38.175]                   if (is.na(NA_character_)) 
[17:37:38.175]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.175]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:38.175]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:38.175]                     .init = FALSE)
[17:37:38.175]                 }
[17:37:38.175]             }
[17:37:38.175]         }
[17:37:38.175]     })
[17:37:38.175]     if (TRUE) {
[17:37:38.175]         base::sink(type = "output", split = FALSE)
[17:37:38.175]         if (TRUE) {
[17:37:38.175]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:38.175]         }
[17:37:38.175]         else {
[17:37:38.175]             ...future.result["stdout"] <- base::list(NULL)
[17:37:38.175]         }
[17:37:38.175]         base::close(...future.stdout)
[17:37:38.175]         ...future.stdout <- NULL
[17:37:38.175]     }
[17:37:38.175]     ...future.result$conditions <- ...future.conditions
[17:37:38.175]     ...future.result$finished <- base::Sys.time()
[17:37:38.175]     ...future.result
[17:37:38.175] }
[17:37:38.228] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[17:37:38.228] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[17:37:38.228] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[17:37:38.229] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:37:38.229] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:37:38.229] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:37:38.230] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:37:38.230] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:37:38.230] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:37:38.230] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:37:38.231] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:37:38.231] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[17:37:38.232] MultisessionFuture started
[17:37:38.232] - Launch lazy future ... done
[17:37:38.232] run() for ‘MultisessionFuture’ ... done
[17:37:38.232] Created future:
[17:37:38.232] MultisessionFuture:
[17:37:38.232] Label: ‘future_mapply-2’
[17:37:38.232] Expression:
[17:37:38.232] {
[17:37:38.232]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.232]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:38.232]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.232]         on.exit(options(oopts), add = TRUE)
[17:37:38.232]     }
[17:37:38.232]     {
[17:37:38.232]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.232]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:38.232]         do.call(mapply, args = args)
[17:37:38.232]     }
[17:37:38.232] }
[17:37:38.232] Lazy evaluation: FALSE
[17:37:38.232] Asynchronous evaluation: TRUE
[17:37:38.232] Local evaluation: TRUE
[17:37:38.232] Environment: R_GlobalEnv
[17:37:38.232] Capture standard output: TRUE
[17:37:38.232] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:38.232] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:38.232] Packages: <none>
[17:37:38.232] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:38.232] Resolved: FALSE
[17:37:38.232] Value: <not collected>
[17:37:38.232] Conditions captured: <none>
[17:37:38.232] Early signaling: FALSE
[17:37:38.232] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:38.232] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.244] Chunk #2 of 2 ... DONE
[17:37:38.244] Launching 2 futures (chunks) ... DONE
[17:37:38.244] Resolving 2 futures (chunks) ...
[17:37:38.244] resolve() on list ...
[17:37:38.245]  recursive: 0
[17:37:38.245]  length: 2
[17:37:38.245] 
[17:37:38.245] receiveMessageFromWorker() for ClusterFuture ...
[17:37:38.245] - Validating connection of MultisessionFuture
[17:37:38.246] - received message: FutureResult
[17:37:38.246] - Received FutureResult
[17:37:38.246] - Erased future from FutureRegistry
[17:37:38.246] result() for ClusterFuture ...
[17:37:38.246] - result already collected: FutureResult
[17:37:38.246] result() for ClusterFuture ... done
[17:37:38.246] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:38.246] Future #1
[17:37:38.247] result() for ClusterFuture ...
[17:37:38.247] - result already collected: FutureResult
[17:37:38.247] result() for ClusterFuture ... done
[17:37:38.247] result() for ClusterFuture ...
[17:37:38.247] - result already collected: FutureResult
[17:37:38.247] result() for ClusterFuture ... done
[17:37:38.247] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:37:38.247] - nx: 2
[17:37:38.247] - relay: TRUE
[17:37:38.248] - stdout: TRUE
[17:37:38.248] - signal: TRUE
[17:37:38.248] - resignal: FALSE
[17:37:38.248] - force: TRUE
[17:37:38.248] - relayed: [n=2] FALSE, FALSE
[17:37:38.248] - queued futures: [n=2] FALSE, FALSE
[17:37:38.248]  - until=1
[17:37:38.248]  - relaying element #1
[17:37:38.248] result() for ClusterFuture ...
[17:37:38.249] - result already collected: FutureResult
[17:37:38.249] result() for ClusterFuture ... done
[17:37:38.249] result() for ClusterFuture ...
[17:37:38.249] - result already collected: FutureResult
[17:37:38.249] result() for ClusterFuture ... done
[17:37:38.249] result() for ClusterFuture ...
[17:37:38.249] - result already collected: FutureResult
[17:37:38.249] result() for ClusterFuture ... done
[17:37:38.250] result() for ClusterFuture ...
[17:37:38.250] - result already collected: FutureResult
[17:37:38.250] result() for ClusterFuture ... done
[17:37:38.250] - relayed: [n=2] TRUE, FALSE
[17:37:38.250] - queued futures: [n=2] TRUE, FALSE
[17:37:38.250] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:37:38.250]  length: 1 (resolved future 1)
[17:37:38.313] receiveMessageFromWorker() for ClusterFuture ...
[17:37:38.313] - Validating connection of MultisessionFuture
[17:37:38.313] - received message: FutureResult
[17:37:38.314] - Received FutureResult
[17:37:38.314] - Erased future from FutureRegistry
[17:37:38.314] result() for ClusterFuture ...
[17:37:38.314] - result already collected: FutureResult
[17:37:38.314] result() for ClusterFuture ... done
[17:37:38.314] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:38.314] Future #2
[17:37:38.314] result() for ClusterFuture ...
[17:37:38.314] - result already collected: FutureResult
[17:37:38.315] result() for ClusterFuture ... done
[17:37:38.315] result() for ClusterFuture ...
[17:37:38.315] - result already collected: FutureResult
[17:37:38.315] result() for ClusterFuture ... done
[17:37:38.315] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:37:38.315] - nx: 2
[17:37:38.315] - relay: TRUE
[17:37:38.315] - stdout: TRUE
[17:37:38.315] - signal: TRUE
[17:37:38.316] - resignal: FALSE
[17:37:38.316] - force: TRUE
[17:37:38.316] - relayed: [n=2] TRUE, FALSE
[17:37:38.318] - queued futures: [n=2] TRUE, FALSE
[17:37:38.318]  - until=2
[17:37:38.318]  - relaying element #2
[17:37:38.318] result() for ClusterFuture ...
[17:37:38.319] - result already collected: FutureResult
[17:37:38.319] result() for ClusterFuture ... done
[17:37:38.319] result() for ClusterFuture ...
[17:37:38.319] - result already collected: FutureResult
[17:37:38.319] result() for ClusterFuture ... done
[17:37:38.319] result() for ClusterFuture ...
[17:37:38.319] - result already collected: FutureResult
[17:37:38.319] result() for ClusterFuture ... done
[17:37:38.319] result() for ClusterFuture ...
[17:37:38.319] - result already collected: FutureResult
[17:37:38.319] result() for ClusterFuture ... done
[17:37:38.319] - relayed: [n=2] TRUE, TRUE
[17:37:38.320] - queued futures: [n=2] TRUE, TRUE
[17:37:38.320] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:37:38.320]  length: 0 (resolved future 2)
[17:37:38.320] Relaying remaining futures
[17:37:38.320] signalConditionsASAP(NULL, pos=0) ...
[17:37:38.320] - nx: 2
[17:37:38.320] - relay: TRUE
[17:37:38.320] - stdout: TRUE
[17:37:38.320] - signal: TRUE
[17:37:38.320] - resignal: FALSE
[17:37:38.320] - force: TRUE
[17:37:38.321] - relayed: [n=2] TRUE, TRUE
[17:37:38.321] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:38.321] - relayed: [n=2] TRUE, TRUE
[17:37:38.321] - queued futures: [n=2] TRUE, TRUE
[17:37:38.321] signalConditionsASAP(NULL, pos=0) ... done
[17:37:38.321] resolve() on list ... DONE
[17:37:38.321] result() for ClusterFuture ...
[17:37:38.321] - result already collected: FutureResult
[17:37:38.321] result() for ClusterFuture ... done
[17:37:38.321] result() for ClusterFuture ...
[17:37:38.321] - result already collected: FutureResult
[17:37:38.321] result() for ClusterFuture ... done
[17:37:38.322] result() for ClusterFuture ...
[17:37:38.322] - result already collected: FutureResult
[17:37:38.322] result() for ClusterFuture ... done
[17:37:38.322] result() for ClusterFuture ...
[17:37:38.322] - result already collected: FutureResult
[17:37:38.322] result() for ClusterFuture ... done
[17:37:38.322]  - Number of value chunks collected: 2
[17:37:38.322] Resolving 2 futures (chunks) ... DONE
[17:37:38.322] Reducing values from 2 chunks ...
[17:37:38.322]  - Number of values collected after concatenation: 4
[17:37:38.322]  - Number of values expected: 4
[17:37:38.323] Reducing values from 2 chunks ... DONE
[17:37:38.323] future_mapply() ... DONE
[17:37:38.323] future_mapply() ...
[17:37:38.327] Number of chunks: 2
[17:37:38.327] getGlobalsAndPackagesXApply() ...
[17:37:38.327]  - future.globals: TRUE
[17:37:38.327] getGlobalsAndPackages() ...
[17:37:38.327] Searching for globals...
[17:37:38.328] - globals found: [1] ‘FUN’
[17:37:38.328] Searching for globals ... DONE
[17:37:38.328] Resolving globals: FALSE
[17:37:38.328] The total size of the 1 globals is 56 bytes (56 bytes)
[17:37:38.328] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:37:38.329] - globals: [1] ‘FUN’
[17:37:38.329] 
[17:37:38.329] getGlobalsAndPackages() ... DONE
[17:37:38.329]  - globals found/used: [n=1] ‘FUN’
[17:37:38.329]  - needed namespaces: [n=0] 
[17:37:38.329] Finding globals ... DONE
[17:37:38.329] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:38.329] List of 2
[17:37:38.329]  $ ...future.FUN:function (x, ...)  
[17:37:38.329]  $ MoreArgs     : NULL
[17:37:38.329]  - attr(*, "where")=List of 2
[17:37:38.329]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:38.329]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:38.329]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:38.329]  - attr(*, "resolved")= logi FALSE
[17:37:38.329]  - attr(*, "total_size")= num NA
[17:37:38.332] Packages to be attached in all futures: [n=0] 
[17:37:38.332] getGlobalsAndPackagesXApply() ... DONE
[17:37:38.332] Number of futures (= number of chunks): 2
[17:37:38.332] Launching 2 futures (chunks) ...
[17:37:38.332] Chunk #1 of 2 ...
[17:37:38.332]  - Finding globals in '...' for chunk #1 ...
[17:37:38.332] getGlobalsAndPackages() ...
[17:37:38.333] Searching for globals...
[17:37:38.333] 
[17:37:38.333] Searching for globals ... DONE
[17:37:38.333] - globals: [0] <none>
[17:37:38.333] getGlobalsAndPackages() ... DONE
[17:37:38.333]    + additional globals found: [n=0] 
[17:37:38.333]    + additional namespaces needed: [n=0] 
[17:37:38.333]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:38.333]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:38.334]  - seeds: <none>
[17:37:38.334]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.334] getGlobalsAndPackages() ...
[17:37:38.334] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.334] Resolving globals: FALSE
[17:37:38.334] The total size of the 5 globals is 280 bytes (280 bytes)
[17:37:38.335] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:38.335] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.335] 
[17:37:38.335] getGlobalsAndPackages() ... DONE
[17:37:38.335] run() for ‘Future’ ...
[17:37:38.336] - state: ‘created’
[17:37:38.336] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:38.349] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.349] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:38.350]   - Field: ‘node’
[17:37:38.350]   - Field: ‘label’
[17:37:38.350]   - Field: ‘local’
[17:37:38.350]   - Field: ‘owner’
[17:37:38.350]   - Field: ‘envir’
[17:37:38.350]   - Field: ‘workers’
[17:37:38.350]   - Field: ‘packages’
[17:37:38.350]   - Field: ‘gc’
[17:37:38.350]   - Field: ‘conditions’
[17:37:38.350]   - Field: ‘persistent’
[17:37:38.351]   - Field: ‘expr’
[17:37:38.351]   - Field: ‘uuid’
[17:37:38.351]   - Field: ‘seed’
[17:37:38.351]   - Field: ‘version’
[17:37:38.351]   - Field: ‘result’
[17:37:38.351]   - Field: ‘asynchronous’
[17:37:38.351]   - Field: ‘calls’
[17:37:38.351]   - Field: ‘globals’
[17:37:38.351]   - Field: ‘stdout’
[17:37:38.351]   - Field: ‘earlySignal’
[17:37:38.351]   - Field: ‘lazy’
[17:37:38.352]   - Field: ‘state’
[17:37:38.352] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:38.352] - Launch lazy future ...
[17:37:38.352] Packages needed by the future expression (n = 0): <none>
[17:37:38.352] Packages needed by future strategies (n = 0): <none>
[17:37:38.353] {
[17:37:38.353]     {
[17:37:38.353]         {
[17:37:38.353]             ...future.startTime <- base::Sys.time()
[17:37:38.353]             {
[17:37:38.353]                 {
[17:37:38.353]                   {
[17:37:38.353]                     {
[17:37:38.353]                       base::local({
[17:37:38.353]                         has_future <- base::requireNamespace("future", 
[17:37:38.353]                           quietly = TRUE)
[17:37:38.353]                         if (has_future) {
[17:37:38.353]                           ns <- base::getNamespace("future")
[17:37:38.353]                           version <- ns[[".package"]][["version"]]
[17:37:38.353]                           if (is.null(version)) 
[17:37:38.353]                             version <- utils::packageVersion("future")
[17:37:38.353]                         }
[17:37:38.353]                         else {
[17:37:38.353]                           version <- NULL
[17:37:38.353]                         }
[17:37:38.353]                         if (!has_future || version < "1.8.0") {
[17:37:38.353]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:38.353]                             "", base::R.version$version.string), 
[17:37:38.353]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:38.353]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:38.353]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:38.353]                               "release", "version")], collapse = " "), 
[17:37:38.353]                             hostname = base::Sys.info()[["nodename"]])
[17:37:38.353]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:38.353]                             info)
[17:37:38.353]                           info <- base::paste(info, collapse = "; ")
[17:37:38.353]                           if (!has_future) {
[17:37:38.353]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:38.353]                               info)
[17:37:38.353]                           }
[17:37:38.353]                           else {
[17:37:38.353]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:38.353]                               info, version)
[17:37:38.353]                           }
[17:37:38.353]                           base::stop(msg)
[17:37:38.353]                         }
[17:37:38.353]                       })
[17:37:38.353]                     }
[17:37:38.353]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:38.353]                     base::options(mc.cores = 1L)
[17:37:38.353]                   }
[17:37:38.353]                   ...future.strategy.old <- future::plan("list")
[17:37:38.353]                   options(future.plan = NULL)
[17:37:38.353]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.353]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:38.353]                 }
[17:37:38.353]                 ...future.workdir <- getwd()
[17:37:38.353]             }
[17:37:38.353]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:38.353]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:38.353]         }
[17:37:38.353]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:38.353]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:38.353]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:38.353]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:38.353]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:38.353]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:38.353]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:38.353]             base::names(...future.oldOptions))
[17:37:38.353]     }
[17:37:38.353]     if (FALSE) {
[17:37:38.353]     }
[17:37:38.353]     else {
[17:37:38.353]         if (TRUE) {
[17:37:38.353]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:38.353]                 open = "w")
[17:37:38.353]         }
[17:37:38.353]         else {
[17:37:38.353]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:38.353]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:38.353]         }
[17:37:38.353]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:38.353]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:38.353]             base::sink(type = "output", split = FALSE)
[17:37:38.353]             base::close(...future.stdout)
[17:37:38.353]         }, add = TRUE)
[17:37:38.353]     }
[17:37:38.353]     ...future.frame <- base::sys.nframe()
[17:37:38.353]     ...future.conditions <- base::list()
[17:37:38.353]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:38.353]     if (FALSE) {
[17:37:38.353]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:38.353]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:38.353]     }
[17:37:38.353]     ...future.result <- base::tryCatch({
[17:37:38.353]         base::withCallingHandlers({
[17:37:38.353]             ...future.value <- base::withVisible(base::local({
[17:37:38.353]                 ...future.makeSendCondition <- base::local({
[17:37:38.353]                   sendCondition <- NULL
[17:37:38.353]                   function(frame = 1L) {
[17:37:38.353]                     if (is.function(sendCondition)) 
[17:37:38.353]                       return(sendCondition)
[17:37:38.353]                     ns <- getNamespace("parallel")
[17:37:38.353]                     if (exists("sendData", mode = "function", 
[17:37:38.353]                       envir = ns)) {
[17:37:38.353]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:38.353]                         envir = ns)
[17:37:38.353]                       envir <- sys.frame(frame)
[17:37:38.353]                       master <- NULL
[17:37:38.353]                       while (!identical(envir, .GlobalEnv) && 
[17:37:38.353]                         !identical(envir, emptyenv())) {
[17:37:38.353]                         if (exists("master", mode = "list", envir = envir, 
[17:37:38.353]                           inherits = FALSE)) {
[17:37:38.353]                           master <- get("master", mode = "list", 
[17:37:38.353]                             envir = envir, inherits = FALSE)
[17:37:38.353]                           if (inherits(master, c("SOCKnode", 
[17:37:38.353]                             "SOCK0node"))) {
[17:37:38.353]                             sendCondition <<- function(cond) {
[17:37:38.353]                               data <- list(type = "VALUE", value = cond, 
[17:37:38.353]                                 success = TRUE)
[17:37:38.353]                               parallel_sendData(master, data)
[17:37:38.353]                             }
[17:37:38.353]                             return(sendCondition)
[17:37:38.353]                           }
[17:37:38.353]                         }
[17:37:38.353]                         frame <- frame + 1L
[17:37:38.353]                         envir <- sys.frame(frame)
[17:37:38.353]                       }
[17:37:38.353]                     }
[17:37:38.353]                     sendCondition <<- function(cond) NULL
[17:37:38.353]                   }
[17:37:38.353]                 })
[17:37:38.353]                 withCallingHandlers({
[17:37:38.353]                   {
[17:37:38.353]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.353]                     if (!identical(...future.globals.maxSize.org, 
[17:37:38.353]                       ...future.globals.maxSize)) {
[17:37:38.353]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.353]                       on.exit(options(oopts), add = TRUE)
[17:37:38.353]                     }
[17:37:38.353]                     {
[17:37:38.353]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.353]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:38.353]                         USE.NAMES = FALSE)
[17:37:38.353]                       do.call(mapply, args = args)
[17:37:38.353]                     }
[17:37:38.353]                   }
[17:37:38.353]                 }, immediateCondition = function(cond) {
[17:37:38.353]                   sendCondition <- ...future.makeSendCondition()
[17:37:38.353]                   sendCondition(cond)
[17:37:38.353]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.353]                   {
[17:37:38.353]                     inherits <- base::inherits
[17:37:38.353]                     invokeRestart <- base::invokeRestart
[17:37:38.353]                     is.null <- base::is.null
[17:37:38.353]                     muffled <- FALSE
[17:37:38.353]                     if (inherits(cond, "message")) {
[17:37:38.353]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:38.353]                       if (muffled) 
[17:37:38.353]                         invokeRestart("muffleMessage")
[17:37:38.353]                     }
[17:37:38.353]                     else if (inherits(cond, "warning")) {
[17:37:38.353]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:38.353]                       if (muffled) 
[17:37:38.353]                         invokeRestart("muffleWarning")
[17:37:38.353]                     }
[17:37:38.353]                     else if (inherits(cond, "condition")) {
[17:37:38.353]                       if (!is.null(pattern)) {
[17:37:38.353]                         computeRestarts <- base::computeRestarts
[17:37:38.353]                         grepl <- base::grepl
[17:37:38.353]                         restarts <- computeRestarts(cond)
[17:37:38.353]                         for (restart in restarts) {
[17:37:38.353]                           name <- restart$name
[17:37:38.353]                           if (is.null(name)) 
[17:37:38.353]                             next
[17:37:38.353]                           if (!grepl(pattern, name)) 
[17:37:38.353]                             next
[17:37:38.353]                           invokeRestart(restart)
[17:37:38.353]                           muffled <- TRUE
[17:37:38.353]                           break
[17:37:38.353]                         }
[17:37:38.353]                       }
[17:37:38.353]                     }
[17:37:38.353]                     invisible(muffled)
[17:37:38.353]                   }
[17:37:38.353]                   muffleCondition(cond)
[17:37:38.353]                 })
[17:37:38.353]             }))
[17:37:38.353]             future::FutureResult(value = ...future.value$value, 
[17:37:38.353]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.353]                   ...future.rng), globalenv = if (FALSE) 
[17:37:38.353]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:38.353]                     ...future.globalenv.names))
[17:37:38.353]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:38.353]         }, condition = base::local({
[17:37:38.353]             c <- base::c
[17:37:38.353]             inherits <- base::inherits
[17:37:38.353]             invokeRestart <- base::invokeRestart
[17:37:38.353]             length <- base::length
[17:37:38.353]             list <- base::list
[17:37:38.353]             seq.int <- base::seq.int
[17:37:38.353]             signalCondition <- base::signalCondition
[17:37:38.353]             sys.calls <- base::sys.calls
[17:37:38.353]             `[[` <- base::`[[`
[17:37:38.353]             `+` <- base::`+`
[17:37:38.353]             `<<-` <- base::`<<-`
[17:37:38.353]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:38.353]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:38.353]                   3L)]
[17:37:38.353]             }
[17:37:38.353]             function(cond) {
[17:37:38.353]                 is_error <- inherits(cond, "error")
[17:37:38.353]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:38.353]                   NULL)
[17:37:38.353]                 if (is_error) {
[17:37:38.353]                   sessionInformation <- function() {
[17:37:38.353]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:38.353]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:38.353]                       search = base::search(), system = base::Sys.info())
[17:37:38.353]                   }
[17:37:38.353]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.353]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:38.353]                     cond$call), session = sessionInformation(), 
[17:37:38.353]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:38.353]                   signalCondition(cond)
[17:37:38.353]                 }
[17:37:38.353]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:38.353]                 "immediateCondition"))) {
[17:37:38.353]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:38.353]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.353]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:38.353]                   if (TRUE && !signal) {
[17:37:38.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.353]                     {
[17:37:38.353]                       inherits <- base::inherits
[17:37:38.353]                       invokeRestart <- base::invokeRestart
[17:37:38.353]                       is.null <- base::is.null
[17:37:38.353]                       muffled <- FALSE
[17:37:38.353]                       if (inherits(cond, "message")) {
[17:37:38.353]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.353]                         if (muffled) 
[17:37:38.353]                           invokeRestart("muffleMessage")
[17:37:38.353]                       }
[17:37:38.353]                       else if (inherits(cond, "warning")) {
[17:37:38.353]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.353]                         if (muffled) 
[17:37:38.353]                           invokeRestart("muffleWarning")
[17:37:38.353]                       }
[17:37:38.353]                       else if (inherits(cond, "condition")) {
[17:37:38.353]                         if (!is.null(pattern)) {
[17:37:38.353]                           computeRestarts <- base::computeRestarts
[17:37:38.353]                           grepl <- base::grepl
[17:37:38.353]                           restarts <- computeRestarts(cond)
[17:37:38.353]                           for (restart in restarts) {
[17:37:38.353]                             name <- restart$name
[17:37:38.353]                             if (is.null(name)) 
[17:37:38.353]                               next
[17:37:38.353]                             if (!grepl(pattern, name)) 
[17:37:38.353]                               next
[17:37:38.353]                             invokeRestart(restart)
[17:37:38.353]                             muffled <- TRUE
[17:37:38.353]                             break
[17:37:38.353]                           }
[17:37:38.353]                         }
[17:37:38.353]                       }
[17:37:38.353]                       invisible(muffled)
[17:37:38.353]                     }
[17:37:38.353]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.353]                   }
[17:37:38.353]                 }
[17:37:38.353]                 else {
[17:37:38.353]                   if (TRUE) {
[17:37:38.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.353]                     {
[17:37:38.353]                       inherits <- base::inherits
[17:37:38.353]                       invokeRestart <- base::invokeRestart
[17:37:38.353]                       is.null <- base::is.null
[17:37:38.353]                       muffled <- FALSE
[17:37:38.353]                       if (inherits(cond, "message")) {
[17:37:38.353]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.353]                         if (muffled) 
[17:37:38.353]                           invokeRestart("muffleMessage")
[17:37:38.353]                       }
[17:37:38.353]                       else if (inherits(cond, "warning")) {
[17:37:38.353]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.353]                         if (muffled) 
[17:37:38.353]                           invokeRestart("muffleWarning")
[17:37:38.353]                       }
[17:37:38.353]                       else if (inherits(cond, "condition")) {
[17:37:38.353]                         if (!is.null(pattern)) {
[17:37:38.353]                           computeRestarts <- base::computeRestarts
[17:37:38.353]                           grepl <- base::grepl
[17:37:38.353]                           restarts <- computeRestarts(cond)
[17:37:38.353]                           for (restart in restarts) {
[17:37:38.353]                             name <- restart$name
[17:37:38.353]                             if (is.null(name)) 
[17:37:38.353]                               next
[17:37:38.353]                             if (!grepl(pattern, name)) 
[17:37:38.353]                               next
[17:37:38.353]                             invokeRestart(restart)
[17:37:38.353]                             muffled <- TRUE
[17:37:38.353]                             break
[17:37:38.353]                           }
[17:37:38.353]                         }
[17:37:38.353]                       }
[17:37:38.353]                       invisible(muffled)
[17:37:38.353]                     }
[17:37:38.353]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.353]                   }
[17:37:38.353]                 }
[17:37:38.353]             }
[17:37:38.353]         }))
[17:37:38.353]     }, error = function(ex) {
[17:37:38.353]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:38.353]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.353]                 ...future.rng), started = ...future.startTime, 
[17:37:38.353]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:38.353]             version = "1.8"), class = "FutureResult")
[17:37:38.353]     }, finally = {
[17:37:38.353]         if (!identical(...future.workdir, getwd())) 
[17:37:38.353]             setwd(...future.workdir)
[17:37:38.353]         {
[17:37:38.353]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:38.353]                 ...future.oldOptions$nwarnings <- NULL
[17:37:38.353]             }
[17:37:38.353]             base::options(...future.oldOptions)
[17:37:38.353]             if (.Platform$OS.type == "windows") {
[17:37:38.353]                 old_names <- names(...future.oldEnvVars)
[17:37:38.353]                 envs <- base::Sys.getenv()
[17:37:38.353]                 names <- names(envs)
[17:37:38.353]                 common <- intersect(names, old_names)
[17:37:38.353]                 added <- setdiff(names, old_names)
[17:37:38.353]                 removed <- setdiff(old_names, names)
[17:37:38.353]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:38.353]                   envs[common]]
[17:37:38.353]                 NAMES <- toupper(changed)
[17:37:38.353]                 args <- list()
[17:37:38.353]                 for (kk in seq_along(NAMES)) {
[17:37:38.353]                   name <- changed[[kk]]
[17:37:38.353]                   NAME <- NAMES[[kk]]
[17:37:38.353]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.353]                     next
[17:37:38.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.353]                 }
[17:37:38.353]                 NAMES <- toupper(added)
[17:37:38.353]                 for (kk in seq_along(NAMES)) {
[17:37:38.353]                   name <- added[[kk]]
[17:37:38.353]                   NAME <- NAMES[[kk]]
[17:37:38.353]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.353]                     next
[17:37:38.353]                   args[[name]] <- ""
[17:37:38.353]                 }
[17:37:38.353]                 NAMES <- toupper(removed)
[17:37:38.353]                 for (kk in seq_along(NAMES)) {
[17:37:38.353]                   name <- removed[[kk]]
[17:37:38.353]                   NAME <- NAMES[[kk]]
[17:37:38.353]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.353]                     next
[17:37:38.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.353]                 }
[17:37:38.353]                 if (length(args) > 0) 
[17:37:38.353]                   base::do.call(base::Sys.setenv, args = args)
[17:37:38.353]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:38.353]             }
[17:37:38.353]             else {
[17:37:38.353]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:38.353]             }
[17:37:38.353]             {
[17:37:38.353]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:38.353]                   0L) {
[17:37:38.353]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:38.353]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:38.353]                   base::options(opts)
[17:37:38.353]                 }
[17:37:38.353]                 {
[17:37:38.353]                   {
[17:37:38.353]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:38.353]                     NULL
[17:37:38.353]                   }
[17:37:38.353]                   options(future.plan = NULL)
[17:37:38.353]                   if (is.na(NA_character_)) 
[17:37:38.353]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.353]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:38.353]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:38.353]                     .init = FALSE)
[17:37:38.353]                 }
[17:37:38.353]             }
[17:37:38.353]         }
[17:37:38.353]     })
[17:37:38.353]     if (TRUE) {
[17:37:38.353]         base::sink(type = "output", split = FALSE)
[17:37:38.353]         if (TRUE) {
[17:37:38.353]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:38.353]         }
[17:37:38.353]         else {
[17:37:38.353]             ...future.result["stdout"] <- base::list(NULL)
[17:37:38.353]         }
[17:37:38.353]         base::close(...future.stdout)
[17:37:38.353]         ...future.stdout <- NULL
[17:37:38.353]     }
[17:37:38.353]     ...future.result$conditions <- ...future.conditions
[17:37:38.353]     ...future.result$finished <- base::Sys.time()
[17:37:38.353]     ...future.result
[17:37:38.353] }
[17:37:38.355] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[17:37:38.355] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[17:37:38.356] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[17:37:38.356] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:37:38.356] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:37:38.356] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[17:37:38.357] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[17:37:38.357] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:38.357] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:38.357] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:38.358] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:38.358] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[17:37:38.358] MultisessionFuture started
[17:37:38.358] - Launch lazy future ... done
[17:37:38.358] run() for ‘MultisessionFuture’ ... done
[17:37:38.358] Created future:
[17:37:38.359] MultisessionFuture:
[17:37:38.359] Label: ‘future_mapply-1’
[17:37:38.359] Expression:
[17:37:38.359] {
[17:37:38.359]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.359]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:38.359]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.359]         on.exit(options(oopts), add = TRUE)
[17:37:38.359]     }
[17:37:38.359]     {
[17:37:38.359]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.359]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:38.359]         do.call(mapply, args = args)
[17:37:38.359]     }
[17:37:38.359] }
[17:37:38.359] Lazy evaluation: FALSE
[17:37:38.359] Asynchronous evaluation: TRUE
[17:37:38.359] Local evaluation: TRUE
[17:37:38.359] Environment: R_GlobalEnv
[17:37:38.359] Capture standard output: TRUE
[17:37:38.359] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:38.359] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:38.359] Packages: <none>
[17:37:38.359] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:38.359] Resolved: FALSE
[17:37:38.359] Value: <not collected>
[17:37:38.359] Conditions captured: <none>
[17:37:38.359] Early signaling: FALSE
[17:37:38.359] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:38.359] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.370] Chunk #1 of 2 ... DONE
[17:37:38.370] Chunk #2 of 2 ...
[17:37:38.370]  - Finding globals in '...' for chunk #2 ...
[17:37:38.370] getGlobalsAndPackages() ...
[17:37:38.370] Searching for globals...
[17:37:38.371] 
[17:37:38.371] Searching for globals ... DONE
[17:37:38.371] - globals: [0] <none>
[17:37:38.371] getGlobalsAndPackages() ... DONE
[17:37:38.371]    + additional globals found: [n=0] 
[17:37:38.371]    + additional namespaces needed: [n=0] 
[17:37:38.371]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:38.371]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:38.371]  - seeds: <none>
[17:37:38.372]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.372] getGlobalsAndPackages() ...
[17:37:38.372] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.372] Resolving globals: FALSE
[17:37:38.372] The total size of the 5 globals is 280 bytes (280 bytes)
[17:37:38.373] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:38.373] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.373] 
[17:37:38.373] getGlobalsAndPackages() ... DONE
[17:37:38.373] run() for ‘Future’ ...
[17:37:38.374] - state: ‘created’
[17:37:38.374] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:38.388] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.388] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:38.388]   - Field: ‘node’
[17:37:38.388]   - Field: ‘label’
[17:37:38.388]   - Field: ‘local’
[17:37:38.388]   - Field: ‘owner’
[17:37:38.388]   - Field: ‘envir’
[17:37:38.388]   - Field: ‘workers’
[17:37:38.388]   - Field: ‘packages’
[17:37:38.389]   - Field: ‘gc’
[17:37:38.389]   - Field: ‘conditions’
[17:37:38.389]   - Field: ‘persistent’
[17:37:38.389]   - Field: ‘expr’
[17:37:38.389]   - Field: ‘uuid’
[17:37:38.389]   - Field: ‘seed’
[17:37:38.389]   - Field: ‘version’
[17:37:38.389]   - Field: ‘result’
[17:37:38.389]   - Field: ‘asynchronous’
[17:37:38.389]   - Field: ‘calls’
[17:37:38.389]   - Field: ‘globals’
[17:37:38.389]   - Field: ‘stdout’
[17:37:38.390]   - Field: ‘earlySignal’
[17:37:38.390]   - Field: ‘lazy’
[17:37:38.390]   - Field: ‘state’
[17:37:38.390] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:38.390] - Launch lazy future ...
[17:37:38.390] Packages needed by the future expression (n = 0): <none>
[17:37:38.390] Packages needed by future strategies (n = 0): <none>
[17:37:38.391] {
[17:37:38.391]     {
[17:37:38.391]         {
[17:37:38.391]             ...future.startTime <- base::Sys.time()
[17:37:38.391]             {
[17:37:38.391]                 {
[17:37:38.391]                   {
[17:37:38.391]                     {
[17:37:38.391]                       base::local({
[17:37:38.391]                         has_future <- base::requireNamespace("future", 
[17:37:38.391]                           quietly = TRUE)
[17:37:38.391]                         if (has_future) {
[17:37:38.391]                           ns <- base::getNamespace("future")
[17:37:38.391]                           version <- ns[[".package"]][["version"]]
[17:37:38.391]                           if (is.null(version)) 
[17:37:38.391]                             version <- utils::packageVersion("future")
[17:37:38.391]                         }
[17:37:38.391]                         else {
[17:37:38.391]                           version <- NULL
[17:37:38.391]                         }
[17:37:38.391]                         if (!has_future || version < "1.8.0") {
[17:37:38.391]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:38.391]                             "", base::R.version$version.string), 
[17:37:38.391]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:38.391]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:38.391]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:38.391]                               "release", "version")], collapse = " "), 
[17:37:38.391]                             hostname = base::Sys.info()[["nodename"]])
[17:37:38.391]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:38.391]                             info)
[17:37:38.391]                           info <- base::paste(info, collapse = "; ")
[17:37:38.391]                           if (!has_future) {
[17:37:38.391]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:38.391]                               info)
[17:37:38.391]                           }
[17:37:38.391]                           else {
[17:37:38.391]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:38.391]                               info, version)
[17:37:38.391]                           }
[17:37:38.391]                           base::stop(msg)
[17:37:38.391]                         }
[17:37:38.391]                       })
[17:37:38.391]                     }
[17:37:38.391]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:38.391]                     base::options(mc.cores = 1L)
[17:37:38.391]                   }
[17:37:38.391]                   ...future.strategy.old <- future::plan("list")
[17:37:38.391]                   options(future.plan = NULL)
[17:37:38.391]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.391]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:38.391]                 }
[17:37:38.391]                 ...future.workdir <- getwd()
[17:37:38.391]             }
[17:37:38.391]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:38.391]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:38.391]         }
[17:37:38.391]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:38.391]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:38.391]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:38.391]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:38.391]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:38.391]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:38.391]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:38.391]             base::names(...future.oldOptions))
[17:37:38.391]     }
[17:37:38.391]     if (FALSE) {
[17:37:38.391]     }
[17:37:38.391]     else {
[17:37:38.391]         if (TRUE) {
[17:37:38.391]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:38.391]                 open = "w")
[17:37:38.391]         }
[17:37:38.391]         else {
[17:37:38.391]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:38.391]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:38.391]         }
[17:37:38.391]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:38.391]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:38.391]             base::sink(type = "output", split = FALSE)
[17:37:38.391]             base::close(...future.stdout)
[17:37:38.391]         }, add = TRUE)
[17:37:38.391]     }
[17:37:38.391]     ...future.frame <- base::sys.nframe()
[17:37:38.391]     ...future.conditions <- base::list()
[17:37:38.391]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:38.391]     if (FALSE) {
[17:37:38.391]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:38.391]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:38.391]     }
[17:37:38.391]     ...future.result <- base::tryCatch({
[17:37:38.391]         base::withCallingHandlers({
[17:37:38.391]             ...future.value <- base::withVisible(base::local({
[17:37:38.391]                 ...future.makeSendCondition <- base::local({
[17:37:38.391]                   sendCondition <- NULL
[17:37:38.391]                   function(frame = 1L) {
[17:37:38.391]                     if (is.function(sendCondition)) 
[17:37:38.391]                       return(sendCondition)
[17:37:38.391]                     ns <- getNamespace("parallel")
[17:37:38.391]                     if (exists("sendData", mode = "function", 
[17:37:38.391]                       envir = ns)) {
[17:37:38.391]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:38.391]                         envir = ns)
[17:37:38.391]                       envir <- sys.frame(frame)
[17:37:38.391]                       master <- NULL
[17:37:38.391]                       while (!identical(envir, .GlobalEnv) && 
[17:37:38.391]                         !identical(envir, emptyenv())) {
[17:37:38.391]                         if (exists("master", mode = "list", envir = envir, 
[17:37:38.391]                           inherits = FALSE)) {
[17:37:38.391]                           master <- get("master", mode = "list", 
[17:37:38.391]                             envir = envir, inherits = FALSE)
[17:37:38.391]                           if (inherits(master, c("SOCKnode", 
[17:37:38.391]                             "SOCK0node"))) {
[17:37:38.391]                             sendCondition <<- function(cond) {
[17:37:38.391]                               data <- list(type = "VALUE", value = cond, 
[17:37:38.391]                                 success = TRUE)
[17:37:38.391]                               parallel_sendData(master, data)
[17:37:38.391]                             }
[17:37:38.391]                             return(sendCondition)
[17:37:38.391]                           }
[17:37:38.391]                         }
[17:37:38.391]                         frame <- frame + 1L
[17:37:38.391]                         envir <- sys.frame(frame)
[17:37:38.391]                       }
[17:37:38.391]                     }
[17:37:38.391]                     sendCondition <<- function(cond) NULL
[17:37:38.391]                   }
[17:37:38.391]                 })
[17:37:38.391]                 withCallingHandlers({
[17:37:38.391]                   {
[17:37:38.391]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.391]                     if (!identical(...future.globals.maxSize.org, 
[17:37:38.391]                       ...future.globals.maxSize)) {
[17:37:38.391]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.391]                       on.exit(options(oopts), add = TRUE)
[17:37:38.391]                     }
[17:37:38.391]                     {
[17:37:38.391]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.391]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:38.391]                         USE.NAMES = FALSE)
[17:37:38.391]                       do.call(mapply, args = args)
[17:37:38.391]                     }
[17:37:38.391]                   }
[17:37:38.391]                 }, immediateCondition = function(cond) {
[17:37:38.391]                   sendCondition <- ...future.makeSendCondition()
[17:37:38.391]                   sendCondition(cond)
[17:37:38.391]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.391]                   {
[17:37:38.391]                     inherits <- base::inherits
[17:37:38.391]                     invokeRestart <- base::invokeRestart
[17:37:38.391]                     is.null <- base::is.null
[17:37:38.391]                     muffled <- FALSE
[17:37:38.391]                     if (inherits(cond, "message")) {
[17:37:38.391]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:38.391]                       if (muffled) 
[17:37:38.391]                         invokeRestart("muffleMessage")
[17:37:38.391]                     }
[17:37:38.391]                     else if (inherits(cond, "warning")) {
[17:37:38.391]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:38.391]                       if (muffled) 
[17:37:38.391]                         invokeRestart("muffleWarning")
[17:37:38.391]                     }
[17:37:38.391]                     else if (inherits(cond, "condition")) {
[17:37:38.391]                       if (!is.null(pattern)) {
[17:37:38.391]                         computeRestarts <- base::computeRestarts
[17:37:38.391]                         grepl <- base::grepl
[17:37:38.391]                         restarts <- computeRestarts(cond)
[17:37:38.391]                         for (restart in restarts) {
[17:37:38.391]                           name <- restart$name
[17:37:38.391]                           if (is.null(name)) 
[17:37:38.391]                             next
[17:37:38.391]                           if (!grepl(pattern, name)) 
[17:37:38.391]                             next
[17:37:38.391]                           invokeRestart(restart)
[17:37:38.391]                           muffled <- TRUE
[17:37:38.391]                           break
[17:37:38.391]                         }
[17:37:38.391]                       }
[17:37:38.391]                     }
[17:37:38.391]                     invisible(muffled)
[17:37:38.391]                   }
[17:37:38.391]                   muffleCondition(cond)
[17:37:38.391]                 })
[17:37:38.391]             }))
[17:37:38.391]             future::FutureResult(value = ...future.value$value, 
[17:37:38.391]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.391]                   ...future.rng), globalenv = if (FALSE) 
[17:37:38.391]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:38.391]                     ...future.globalenv.names))
[17:37:38.391]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:38.391]         }, condition = base::local({
[17:37:38.391]             c <- base::c
[17:37:38.391]             inherits <- base::inherits
[17:37:38.391]             invokeRestart <- base::invokeRestart
[17:37:38.391]             length <- base::length
[17:37:38.391]             list <- base::list
[17:37:38.391]             seq.int <- base::seq.int
[17:37:38.391]             signalCondition <- base::signalCondition
[17:37:38.391]             sys.calls <- base::sys.calls
[17:37:38.391]             `[[` <- base::`[[`
[17:37:38.391]             `+` <- base::`+`
[17:37:38.391]             `<<-` <- base::`<<-`
[17:37:38.391]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:38.391]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:38.391]                   3L)]
[17:37:38.391]             }
[17:37:38.391]             function(cond) {
[17:37:38.391]                 is_error <- inherits(cond, "error")
[17:37:38.391]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:38.391]                   NULL)
[17:37:38.391]                 if (is_error) {
[17:37:38.391]                   sessionInformation <- function() {
[17:37:38.391]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:38.391]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:38.391]                       search = base::search(), system = base::Sys.info())
[17:37:38.391]                   }
[17:37:38.391]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.391]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:38.391]                     cond$call), session = sessionInformation(), 
[17:37:38.391]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:38.391]                   signalCondition(cond)
[17:37:38.391]                 }
[17:37:38.391]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:38.391]                 "immediateCondition"))) {
[17:37:38.391]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:38.391]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.391]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:38.391]                   if (TRUE && !signal) {
[17:37:38.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.391]                     {
[17:37:38.391]                       inherits <- base::inherits
[17:37:38.391]                       invokeRestart <- base::invokeRestart
[17:37:38.391]                       is.null <- base::is.null
[17:37:38.391]                       muffled <- FALSE
[17:37:38.391]                       if (inherits(cond, "message")) {
[17:37:38.391]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.391]                         if (muffled) 
[17:37:38.391]                           invokeRestart("muffleMessage")
[17:37:38.391]                       }
[17:37:38.391]                       else if (inherits(cond, "warning")) {
[17:37:38.391]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.391]                         if (muffled) 
[17:37:38.391]                           invokeRestart("muffleWarning")
[17:37:38.391]                       }
[17:37:38.391]                       else if (inherits(cond, "condition")) {
[17:37:38.391]                         if (!is.null(pattern)) {
[17:37:38.391]                           computeRestarts <- base::computeRestarts
[17:37:38.391]                           grepl <- base::grepl
[17:37:38.391]                           restarts <- computeRestarts(cond)
[17:37:38.391]                           for (restart in restarts) {
[17:37:38.391]                             name <- restart$name
[17:37:38.391]                             if (is.null(name)) 
[17:37:38.391]                               next
[17:37:38.391]                             if (!grepl(pattern, name)) 
[17:37:38.391]                               next
[17:37:38.391]                             invokeRestart(restart)
[17:37:38.391]                             muffled <- TRUE
[17:37:38.391]                             break
[17:37:38.391]                           }
[17:37:38.391]                         }
[17:37:38.391]                       }
[17:37:38.391]                       invisible(muffled)
[17:37:38.391]                     }
[17:37:38.391]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.391]                   }
[17:37:38.391]                 }
[17:37:38.391]                 else {
[17:37:38.391]                   if (TRUE) {
[17:37:38.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.391]                     {
[17:37:38.391]                       inherits <- base::inherits
[17:37:38.391]                       invokeRestart <- base::invokeRestart
[17:37:38.391]                       is.null <- base::is.null
[17:37:38.391]                       muffled <- FALSE
[17:37:38.391]                       if (inherits(cond, "message")) {
[17:37:38.391]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.391]                         if (muffled) 
[17:37:38.391]                           invokeRestart("muffleMessage")
[17:37:38.391]                       }
[17:37:38.391]                       else if (inherits(cond, "warning")) {
[17:37:38.391]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.391]                         if (muffled) 
[17:37:38.391]                           invokeRestart("muffleWarning")
[17:37:38.391]                       }
[17:37:38.391]                       else if (inherits(cond, "condition")) {
[17:37:38.391]                         if (!is.null(pattern)) {
[17:37:38.391]                           computeRestarts <- base::computeRestarts
[17:37:38.391]                           grepl <- base::grepl
[17:37:38.391]                           restarts <- computeRestarts(cond)
[17:37:38.391]                           for (restart in restarts) {
[17:37:38.391]                             name <- restart$name
[17:37:38.391]                             if (is.null(name)) 
[17:37:38.391]                               next
[17:37:38.391]                             if (!grepl(pattern, name)) 
[17:37:38.391]                               next
[17:37:38.391]                             invokeRestart(restart)
[17:37:38.391]                             muffled <- TRUE
[17:37:38.391]                             break
[17:37:38.391]                           }
[17:37:38.391]                         }
[17:37:38.391]                       }
[17:37:38.391]                       invisible(muffled)
[17:37:38.391]                     }
[17:37:38.391]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.391]                   }
[17:37:38.391]                 }
[17:37:38.391]             }
[17:37:38.391]         }))
[17:37:38.391]     }, error = function(ex) {
[17:37:38.391]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:38.391]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.391]                 ...future.rng), started = ...future.startTime, 
[17:37:38.391]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:38.391]             version = "1.8"), class = "FutureResult")
[17:37:38.391]     }, finally = {
[17:37:38.391]         if (!identical(...future.workdir, getwd())) 
[17:37:38.391]             setwd(...future.workdir)
[17:37:38.391]         {
[17:37:38.391]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:38.391]                 ...future.oldOptions$nwarnings <- NULL
[17:37:38.391]             }
[17:37:38.391]             base::options(...future.oldOptions)
[17:37:38.391]             if (.Platform$OS.type == "windows") {
[17:37:38.391]                 old_names <- names(...future.oldEnvVars)
[17:37:38.391]                 envs <- base::Sys.getenv()
[17:37:38.391]                 names <- names(envs)
[17:37:38.391]                 common <- intersect(names, old_names)
[17:37:38.391]                 added <- setdiff(names, old_names)
[17:37:38.391]                 removed <- setdiff(old_names, names)
[17:37:38.391]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:38.391]                   envs[common]]
[17:37:38.391]                 NAMES <- toupper(changed)
[17:37:38.391]                 args <- list()
[17:37:38.391]                 for (kk in seq_along(NAMES)) {
[17:37:38.391]                   name <- changed[[kk]]
[17:37:38.391]                   NAME <- NAMES[[kk]]
[17:37:38.391]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.391]                     next
[17:37:38.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.391]                 }
[17:37:38.391]                 NAMES <- toupper(added)
[17:37:38.391]                 for (kk in seq_along(NAMES)) {
[17:37:38.391]                   name <- added[[kk]]
[17:37:38.391]                   NAME <- NAMES[[kk]]
[17:37:38.391]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.391]                     next
[17:37:38.391]                   args[[name]] <- ""
[17:37:38.391]                 }
[17:37:38.391]                 NAMES <- toupper(removed)
[17:37:38.391]                 for (kk in seq_along(NAMES)) {
[17:37:38.391]                   name <- removed[[kk]]
[17:37:38.391]                   NAME <- NAMES[[kk]]
[17:37:38.391]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.391]                     next
[17:37:38.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.391]                 }
[17:37:38.391]                 if (length(args) > 0) 
[17:37:38.391]                   base::do.call(base::Sys.setenv, args = args)
[17:37:38.391]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:38.391]             }
[17:37:38.391]             else {
[17:37:38.391]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:38.391]             }
[17:37:38.391]             {
[17:37:38.391]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:38.391]                   0L) {
[17:37:38.391]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:38.391]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:38.391]                   base::options(opts)
[17:37:38.391]                 }
[17:37:38.391]                 {
[17:37:38.391]                   {
[17:37:38.391]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:38.391]                     NULL
[17:37:38.391]                   }
[17:37:38.391]                   options(future.plan = NULL)
[17:37:38.391]                   if (is.na(NA_character_)) 
[17:37:38.391]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.391]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:38.391]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:38.391]                     .init = FALSE)
[17:37:38.391]                 }
[17:37:38.391]             }
[17:37:38.391]         }
[17:37:38.391]     })
[17:37:38.391]     if (TRUE) {
[17:37:38.391]         base::sink(type = "output", split = FALSE)
[17:37:38.391]         if (TRUE) {
[17:37:38.391]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:38.391]         }
[17:37:38.391]         else {
[17:37:38.391]             ...future.result["stdout"] <- base::list(NULL)
[17:37:38.391]         }
[17:37:38.391]         base::close(...future.stdout)
[17:37:38.391]         ...future.stdout <- NULL
[17:37:38.391]     }
[17:37:38.391]     ...future.result$conditions <- ...future.conditions
[17:37:38.391]     ...future.result$finished <- base::Sys.time()
[17:37:38.391]     ...future.result
[17:37:38.391] }
[17:37:38.394] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[17:37:38.394] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[17:37:38.394] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[17:37:38.394] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:37:38.395] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:37:38.395] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:37:38.395] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:37:38.395] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:37:38.396] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:37:38.396] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:37:38.396] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:37:38.396] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[17:37:38.397] MultisessionFuture started
[17:37:38.397] - Launch lazy future ... done
[17:37:38.397] run() for ‘MultisessionFuture’ ... done
[17:37:38.397] Created future:
[17:37:38.397] MultisessionFuture:
[17:37:38.397] Label: ‘future_mapply-2’
[17:37:38.397] Expression:
[17:37:38.397] {
[17:37:38.397]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.397]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:38.397]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.397]         on.exit(options(oopts), add = TRUE)
[17:37:38.397]     }
[17:37:38.397]     {
[17:37:38.397]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.397]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:38.397]         do.call(mapply, args = args)
[17:37:38.397]     }
[17:37:38.397] }
[17:37:38.397] Lazy evaluation: FALSE
[17:37:38.397] Asynchronous evaluation: TRUE
[17:37:38.397] Local evaluation: TRUE
[17:37:38.397] Environment: R_GlobalEnv
[17:37:38.397] Capture standard output: TRUE
[17:37:38.397] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:38.397] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:38.397] Packages: <none>
[17:37:38.397] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:38.397] Resolved: FALSE
[17:37:38.397] Value: <not collected>
[17:37:38.397] Conditions captured: <none>
[17:37:38.397] Early signaling: FALSE
[17:37:38.397] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:38.397] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.409] Chunk #2 of 2 ... DONE
[17:37:38.409] Launching 2 futures (chunks) ... DONE
[17:37:38.409] Resolving 2 futures (chunks) ...
[17:37:38.409] resolve() on list ...
[17:37:38.409]  recursive: 0
[17:37:38.409]  length: 2
[17:37:38.410] 
[17:37:38.410] receiveMessageFromWorker() for ClusterFuture ...
[17:37:38.410] - Validating connection of MultisessionFuture
[17:37:38.410] - received message: FutureResult
[17:37:38.410] - Received FutureResult
[17:37:38.410] - Erased future from FutureRegistry
[17:37:38.411] result() for ClusterFuture ...
[17:37:38.411] - result already collected: FutureResult
[17:37:38.411] result() for ClusterFuture ... done
[17:37:38.411] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:38.411] Future #1
[17:37:38.411] result() for ClusterFuture ...
[17:37:38.411] - result already collected: FutureResult
[17:37:38.411] result() for ClusterFuture ... done
[17:37:38.411] result() for ClusterFuture ...
[17:37:38.411] - result already collected: FutureResult
[17:37:38.411] result() for ClusterFuture ... done
[17:37:38.412] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:37:38.412] - nx: 2
[17:37:38.412] - relay: TRUE
[17:37:38.412] - stdout: TRUE
[17:37:38.412] - signal: TRUE
[17:37:38.412] - resignal: FALSE
[17:37:38.412] - force: TRUE
[17:37:38.412] - relayed: [n=2] FALSE, FALSE
[17:37:38.412] - queued futures: [n=2] FALSE, FALSE
[17:37:38.412]  - until=1
[17:37:38.413]  - relaying element #1
[17:37:38.413] result() for ClusterFuture ...
[17:37:38.413] - result already collected: FutureResult
[17:37:38.413] result() for ClusterFuture ... done
[17:37:38.413] result() for ClusterFuture ...
[17:37:38.413] - result already collected: FutureResult
[17:37:38.413] result() for ClusterFuture ... done
[17:37:38.413] result() for ClusterFuture ...
[17:37:38.413] - result already collected: FutureResult
[17:37:38.413] result() for ClusterFuture ... done
[17:37:38.413] result() for ClusterFuture ...
[17:37:38.414] - result already collected: FutureResult
[17:37:38.414] result() for ClusterFuture ... done
[17:37:38.414] - relayed: [n=2] TRUE, FALSE
[17:37:38.414] - queued futures: [n=2] TRUE, FALSE
[17:37:38.414] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:37:38.414]  length: 1 (resolved future 1)
[17:37:38.442] receiveMessageFromWorker() for ClusterFuture ...
[17:37:38.442] - Validating connection of MultisessionFuture
[17:37:38.442] - received message: FutureResult
[17:37:38.442] - Received FutureResult
[17:37:38.443] - Erased future from FutureRegistry
[17:37:38.443] result() for ClusterFuture ...
[17:37:38.443] - result already collected: FutureResult
[17:37:38.443] result() for ClusterFuture ... done
[17:37:38.443] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:38.443] Future #2
[17:37:38.443] result() for ClusterFuture ...
[17:37:38.443] - result already collected: FutureResult
[17:37:38.443] result() for ClusterFuture ... done
[17:37:38.443] result() for ClusterFuture ...
[17:37:38.443] - result already collected: FutureResult
[17:37:38.444] result() for ClusterFuture ... done
[17:37:38.444] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:37:38.444] - nx: 2
[17:37:38.444] - relay: TRUE
[17:37:38.444] - stdout: TRUE
[17:37:38.444] - signal: TRUE
[17:37:38.444] - resignal: FALSE
[17:37:38.444] - force: TRUE
[17:37:38.444] - relayed: [n=2] TRUE, FALSE
[17:37:38.444] - queued futures: [n=2] TRUE, FALSE
[17:37:38.444]  - until=2
[17:37:38.444]  - relaying element #2
[17:37:38.445] result() for ClusterFuture ...
[17:37:38.445] - result already collected: FutureResult
[17:37:38.445] result() for ClusterFuture ... done
[17:37:38.445] result() for ClusterFuture ...
[17:37:38.445] - result already collected: FutureResult
[17:37:38.445] result() for ClusterFuture ... done
[17:37:38.445] result() for ClusterFuture ...
[17:37:38.445] - result already collected: FutureResult
[17:37:38.445] result() for ClusterFuture ... done
[17:37:38.445] result() for ClusterFuture ...
[17:37:38.445] - result already collected: FutureResult
[17:37:38.446] result() for ClusterFuture ... done
[17:37:38.446] - relayed: [n=2] TRUE, TRUE
[17:37:38.446] - queued futures: [n=2] TRUE, TRUE
[17:37:38.446] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:37:38.446]  length: 0 (resolved future 2)
[17:37:38.446] Relaying remaining futures
[17:37:38.446] signalConditionsASAP(NULL, pos=0) ...
[17:37:38.446] - nx: 2
[17:37:38.446] - relay: TRUE
[17:37:38.446] - stdout: TRUE
[17:37:38.446] - signal: TRUE
[17:37:38.447] - resignal: FALSE
[17:37:38.447] - force: TRUE
[17:37:38.447] - relayed: [n=2] TRUE, TRUE
[17:37:38.447] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:38.447] - relayed: [n=2] TRUE, TRUE
[17:37:38.447] - queued futures: [n=2] TRUE, TRUE
[17:37:38.447] signalConditionsASAP(NULL, pos=0) ... done
[17:37:38.447] resolve() on list ... DONE
[17:37:38.447] result() for ClusterFuture ...
[17:37:38.447] - result already collected: FutureResult
[17:37:38.447] result() for ClusterFuture ... done
[17:37:38.448] result() for ClusterFuture ...
[17:37:38.448] - result already collected: FutureResult
[17:37:38.448] result() for ClusterFuture ... done
[17:37:38.448] result() for ClusterFuture ...
[17:37:38.448] - result already collected: FutureResult
[17:37:38.448] result() for ClusterFuture ... done
[17:37:38.448] result() for ClusterFuture ...
[17:37:38.448] - result already collected: FutureResult
[17:37:38.448] result() for ClusterFuture ... done
[17:37:38.448]  - Number of value chunks collected: 2
[17:37:38.448] Resolving 2 futures (chunks) ... DONE
[17:37:38.449] Reducing values from 2 chunks ...
[17:37:38.449]  - Number of values collected after concatenation: 4
[17:37:38.449]  - Number of values expected: 4
[17:37:38.449] Reducing values from 2 chunks ... DONE
[17:37:38.449] future_mapply() ... DONE
[17:37:38.449] future_mapply() ...
[17:37:38.453] Number of chunks: 2
[17:37:38.453] getGlobalsAndPackagesXApply() ...
[17:37:38.453]  - future.globals: TRUE
[17:37:38.453] getGlobalsAndPackages() ...
[17:37:38.453] Searching for globals...
[17:37:38.454] - globals found: [1] ‘FUN’
[17:37:38.454] Searching for globals ... DONE
[17:37:38.454] Resolving globals: FALSE
[17:37:38.454] The total size of the 1 globals is 56 bytes (56 bytes)
[17:37:38.455] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:37:38.455] - globals: [1] ‘FUN’
[17:37:38.455] 
[17:37:38.455] getGlobalsAndPackages() ... DONE
[17:37:38.455]  - globals found/used: [n=1] ‘FUN’
[17:37:38.455]  - needed namespaces: [n=0] 
[17:37:38.455] Finding globals ... DONE
[17:37:38.455] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:38.455] List of 2
[17:37:38.455]  $ ...future.FUN:function (x, ...)  
[17:37:38.455]  $ MoreArgs     : NULL
[17:37:38.455]  - attr(*, "where")=List of 2
[17:37:38.455]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:38.455]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:38.455]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:38.455]  - attr(*, "resolved")= logi FALSE
[17:37:38.455]  - attr(*, "total_size")= num NA
[17:37:38.458] Packages to be attached in all futures: [n=0] 
[17:37:38.458] getGlobalsAndPackagesXApply() ... DONE
[17:37:38.458] Number of futures (= number of chunks): 2
[17:37:38.458] Launching 2 futures (chunks) ...
[17:37:38.458] Chunk #1 of 2 ...
[17:37:38.459]  - Finding globals in '...' for chunk #1 ...
[17:37:38.459] getGlobalsAndPackages() ...
[17:37:38.459] Searching for globals...
[17:37:38.459] 
[17:37:38.459] Searching for globals ... DONE
[17:37:38.459] - globals: [0] <none>
[17:37:38.459] getGlobalsAndPackages() ... DONE
[17:37:38.459]    + additional globals found: [n=0] 
[17:37:38.459]    + additional namespaces needed: [n=0] 
[17:37:38.460]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:38.460]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:38.460]  - seeds: <none>
[17:37:38.460]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.460] getGlobalsAndPackages() ...
[17:37:38.460] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.460] Resolving globals: FALSE
[17:37:38.461] The total size of the 5 globals is 280 bytes (280 bytes)
[17:37:38.461] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:38.461] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.461] 
[17:37:38.461] getGlobalsAndPackages() ... DONE
[17:37:38.462] run() for ‘Future’ ...
[17:37:38.462] - state: ‘created’
[17:37:38.462] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:38.476] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.476] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:38.476]   - Field: ‘node’
[17:37:38.476]   - Field: ‘label’
[17:37:38.476]   - Field: ‘local’
[17:37:38.476]   - Field: ‘owner’
[17:37:38.476]   - Field: ‘envir’
[17:37:38.477]   - Field: ‘workers’
[17:37:38.477]   - Field: ‘packages’
[17:37:38.477]   - Field: ‘gc’
[17:37:38.477]   - Field: ‘conditions’
[17:37:38.477]   - Field: ‘persistent’
[17:37:38.477]   - Field: ‘expr’
[17:37:38.477]   - Field: ‘uuid’
[17:37:38.477]   - Field: ‘seed’
[17:37:38.477]   - Field: ‘version’
[17:37:38.477]   - Field: ‘result’
[17:37:38.477]   - Field: ‘asynchronous’
[17:37:38.478]   - Field: ‘calls’
[17:37:38.478]   - Field: ‘globals’
[17:37:38.478]   - Field: ‘stdout’
[17:37:38.478]   - Field: ‘earlySignal’
[17:37:38.478]   - Field: ‘lazy’
[17:37:38.478]   - Field: ‘state’
[17:37:38.478] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:38.478] - Launch lazy future ...
[17:37:38.478] Packages needed by the future expression (n = 0): <none>
[17:37:38.479] Packages needed by future strategies (n = 0): <none>
[17:37:38.479] {
[17:37:38.479]     {
[17:37:38.479]         {
[17:37:38.479]             ...future.startTime <- base::Sys.time()
[17:37:38.479]             {
[17:37:38.479]                 {
[17:37:38.479]                   {
[17:37:38.479]                     {
[17:37:38.479]                       base::local({
[17:37:38.479]                         has_future <- base::requireNamespace("future", 
[17:37:38.479]                           quietly = TRUE)
[17:37:38.479]                         if (has_future) {
[17:37:38.479]                           ns <- base::getNamespace("future")
[17:37:38.479]                           version <- ns[[".package"]][["version"]]
[17:37:38.479]                           if (is.null(version)) 
[17:37:38.479]                             version <- utils::packageVersion("future")
[17:37:38.479]                         }
[17:37:38.479]                         else {
[17:37:38.479]                           version <- NULL
[17:37:38.479]                         }
[17:37:38.479]                         if (!has_future || version < "1.8.0") {
[17:37:38.479]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:38.479]                             "", base::R.version$version.string), 
[17:37:38.479]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:38.479]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:38.479]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:38.479]                               "release", "version")], collapse = " "), 
[17:37:38.479]                             hostname = base::Sys.info()[["nodename"]])
[17:37:38.479]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:38.479]                             info)
[17:37:38.479]                           info <- base::paste(info, collapse = "; ")
[17:37:38.479]                           if (!has_future) {
[17:37:38.479]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:38.479]                               info)
[17:37:38.479]                           }
[17:37:38.479]                           else {
[17:37:38.479]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:38.479]                               info, version)
[17:37:38.479]                           }
[17:37:38.479]                           base::stop(msg)
[17:37:38.479]                         }
[17:37:38.479]                       })
[17:37:38.479]                     }
[17:37:38.479]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:38.479]                     base::options(mc.cores = 1L)
[17:37:38.479]                   }
[17:37:38.479]                   ...future.strategy.old <- future::plan("list")
[17:37:38.479]                   options(future.plan = NULL)
[17:37:38.479]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.479]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:38.479]                 }
[17:37:38.479]                 ...future.workdir <- getwd()
[17:37:38.479]             }
[17:37:38.479]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:38.479]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:38.479]         }
[17:37:38.479]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:38.479]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:38.479]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:38.479]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:38.479]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:38.479]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:38.479]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:38.479]             base::names(...future.oldOptions))
[17:37:38.479]     }
[17:37:38.479]     if (FALSE) {
[17:37:38.479]     }
[17:37:38.479]     else {
[17:37:38.479]         if (TRUE) {
[17:37:38.479]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:38.479]                 open = "w")
[17:37:38.479]         }
[17:37:38.479]         else {
[17:37:38.479]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:38.479]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:38.479]         }
[17:37:38.479]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:38.479]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:38.479]             base::sink(type = "output", split = FALSE)
[17:37:38.479]             base::close(...future.stdout)
[17:37:38.479]         }, add = TRUE)
[17:37:38.479]     }
[17:37:38.479]     ...future.frame <- base::sys.nframe()
[17:37:38.479]     ...future.conditions <- base::list()
[17:37:38.479]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:38.479]     if (FALSE) {
[17:37:38.479]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:38.479]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:38.479]     }
[17:37:38.479]     ...future.result <- base::tryCatch({
[17:37:38.479]         base::withCallingHandlers({
[17:37:38.479]             ...future.value <- base::withVisible(base::local({
[17:37:38.479]                 ...future.makeSendCondition <- base::local({
[17:37:38.479]                   sendCondition <- NULL
[17:37:38.479]                   function(frame = 1L) {
[17:37:38.479]                     if (is.function(sendCondition)) 
[17:37:38.479]                       return(sendCondition)
[17:37:38.479]                     ns <- getNamespace("parallel")
[17:37:38.479]                     if (exists("sendData", mode = "function", 
[17:37:38.479]                       envir = ns)) {
[17:37:38.479]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:38.479]                         envir = ns)
[17:37:38.479]                       envir <- sys.frame(frame)
[17:37:38.479]                       master <- NULL
[17:37:38.479]                       while (!identical(envir, .GlobalEnv) && 
[17:37:38.479]                         !identical(envir, emptyenv())) {
[17:37:38.479]                         if (exists("master", mode = "list", envir = envir, 
[17:37:38.479]                           inherits = FALSE)) {
[17:37:38.479]                           master <- get("master", mode = "list", 
[17:37:38.479]                             envir = envir, inherits = FALSE)
[17:37:38.479]                           if (inherits(master, c("SOCKnode", 
[17:37:38.479]                             "SOCK0node"))) {
[17:37:38.479]                             sendCondition <<- function(cond) {
[17:37:38.479]                               data <- list(type = "VALUE", value = cond, 
[17:37:38.479]                                 success = TRUE)
[17:37:38.479]                               parallel_sendData(master, data)
[17:37:38.479]                             }
[17:37:38.479]                             return(sendCondition)
[17:37:38.479]                           }
[17:37:38.479]                         }
[17:37:38.479]                         frame <- frame + 1L
[17:37:38.479]                         envir <- sys.frame(frame)
[17:37:38.479]                       }
[17:37:38.479]                     }
[17:37:38.479]                     sendCondition <<- function(cond) NULL
[17:37:38.479]                   }
[17:37:38.479]                 })
[17:37:38.479]                 withCallingHandlers({
[17:37:38.479]                   {
[17:37:38.479]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.479]                     if (!identical(...future.globals.maxSize.org, 
[17:37:38.479]                       ...future.globals.maxSize)) {
[17:37:38.479]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.479]                       on.exit(options(oopts), add = TRUE)
[17:37:38.479]                     }
[17:37:38.479]                     {
[17:37:38.479]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.479]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:38.479]                         USE.NAMES = FALSE)
[17:37:38.479]                       do.call(mapply, args = args)
[17:37:38.479]                     }
[17:37:38.479]                   }
[17:37:38.479]                 }, immediateCondition = function(cond) {
[17:37:38.479]                   sendCondition <- ...future.makeSendCondition()
[17:37:38.479]                   sendCondition(cond)
[17:37:38.479]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.479]                   {
[17:37:38.479]                     inherits <- base::inherits
[17:37:38.479]                     invokeRestart <- base::invokeRestart
[17:37:38.479]                     is.null <- base::is.null
[17:37:38.479]                     muffled <- FALSE
[17:37:38.479]                     if (inherits(cond, "message")) {
[17:37:38.479]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:38.479]                       if (muffled) 
[17:37:38.479]                         invokeRestart("muffleMessage")
[17:37:38.479]                     }
[17:37:38.479]                     else if (inherits(cond, "warning")) {
[17:37:38.479]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:38.479]                       if (muffled) 
[17:37:38.479]                         invokeRestart("muffleWarning")
[17:37:38.479]                     }
[17:37:38.479]                     else if (inherits(cond, "condition")) {
[17:37:38.479]                       if (!is.null(pattern)) {
[17:37:38.479]                         computeRestarts <- base::computeRestarts
[17:37:38.479]                         grepl <- base::grepl
[17:37:38.479]                         restarts <- computeRestarts(cond)
[17:37:38.479]                         for (restart in restarts) {
[17:37:38.479]                           name <- restart$name
[17:37:38.479]                           if (is.null(name)) 
[17:37:38.479]                             next
[17:37:38.479]                           if (!grepl(pattern, name)) 
[17:37:38.479]                             next
[17:37:38.479]                           invokeRestart(restart)
[17:37:38.479]                           muffled <- TRUE
[17:37:38.479]                           break
[17:37:38.479]                         }
[17:37:38.479]                       }
[17:37:38.479]                     }
[17:37:38.479]                     invisible(muffled)
[17:37:38.479]                   }
[17:37:38.479]                   muffleCondition(cond)
[17:37:38.479]                 })
[17:37:38.479]             }))
[17:37:38.479]             future::FutureResult(value = ...future.value$value, 
[17:37:38.479]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.479]                   ...future.rng), globalenv = if (FALSE) 
[17:37:38.479]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:38.479]                     ...future.globalenv.names))
[17:37:38.479]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:38.479]         }, condition = base::local({
[17:37:38.479]             c <- base::c
[17:37:38.479]             inherits <- base::inherits
[17:37:38.479]             invokeRestart <- base::invokeRestart
[17:37:38.479]             length <- base::length
[17:37:38.479]             list <- base::list
[17:37:38.479]             seq.int <- base::seq.int
[17:37:38.479]             signalCondition <- base::signalCondition
[17:37:38.479]             sys.calls <- base::sys.calls
[17:37:38.479]             `[[` <- base::`[[`
[17:37:38.479]             `+` <- base::`+`
[17:37:38.479]             `<<-` <- base::`<<-`
[17:37:38.479]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:38.479]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:38.479]                   3L)]
[17:37:38.479]             }
[17:37:38.479]             function(cond) {
[17:37:38.479]                 is_error <- inherits(cond, "error")
[17:37:38.479]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:38.479]                   NULL)
[17:37:38.479]                 if (is_error) {
[17:37:38.479]                   sessionInformation <- function() {
[17:37:38.479]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:38.479]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:38.479]                       search = base::search(), system = base::Sys.info())
[17:37:38.479]                   }
[17:37:38.479]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.479]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:38.479]                     cond$call), session = sessionInformation(), 
[17:37:38.479]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:38.479]                   signalCondition(cond)
[17:37:38.479]                 }
[17:37:38.479]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:38.479]                 "immediateCondition"))) {
[17:37:38.479]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:38.479]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.479]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:38.479]                   if (TRUE && !signal) {
[17:37:38.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.479]                     {
[17:37:38.479]                       inherits <- base::inherits
[17:37:38.479]                       invokeRestart <- base::invokeRestart
[17:37:38.479]                       is.null <- base::is.null
[17:37:38.479]                       muffled <- FALSE
[17:37:38.479]                       if (inherits(cond, "message")) {
[17:37:38.479]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.479]                         if (muffled) 
[17:37:38.479]                           invokeRestart("muffleMessage")
[17:37:38.479]                       }
[17:37:38.479]                       else if (inherits(cond, "warning")) {
[17:37:38.479]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.479]                         if (muffled) 
[17:37:38.479]                           invokeRestart("muffleWarning")
[17:37:38.479]                       }
[17:37:38.479]                       else if (inherits(cond, "condition")) {
[17:37:38.479]                         if (!is.null(pattern)) {
[17:37:38.479]                           computeRestarts <- base::computeRestarts
[17:37:38.479]                           grepl <- base::grepl
[17:37:38.479]                           restarts <- computeRestarts(cond)
[17:37:38.479]                           for (restart in restarts) {
[17:37:38.479]                             name <- restart$name
[17:37:38.479]                             if (is.null(name)) 
[17:37:38.479]                               next
[17:37:38.479]                             if (!grepl(pattern, name)) 
[17:37:38.479]                               next
[17:37:38.479]                             invokeRestart(restart)
[17:37:38.479]                             muffled <- TRUE
[17:37:38.479]                             break
[17:37:38.479]                           }
[17:37:38.479]                         }
[17:37:38.479]                       }
[17:37:38.479]                       invisible(muffled)
[17:37:38.479]                     }
[17:37:38.479]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.479]                   }
[17:37:38.479]                 }
[17:37:38.479]                 else {
[17:37:38.479]                   if (TRUE) {
[17:37:38.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.479]                     {
[17:37:38.479]                       inherits <- base::inherits
[17:37:38.479]                       invokeRestart <- base::invokeRestart
[17:37:38.479]                       is.null <- base::is.null
[17:37:38.479]                       muffled <- FALSE
[17:37:38.479]                       if (inherits(cond, "message")) {
[17:37:38.479]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.479]                         if (muffled) 
[17:37:38.479]                           invokeRestart("muffleMessage")
[17:37:38.479]                       }
[17:37:38.479]                       else if (inherits(cond, "warning")) {
[17:37:38.479]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.479]                         if (muffled) 
[17:37:38.479]                           invokeRestart("muffleWarning")
[17:37:38.479]                       }
[17:37:38.479]                       else if (inherits(cond, "condition")) {
[17:37:38.479]                         if (!is.null(pattern)) {
[17:37:38.479]                           computeRestarts <- base::computeRestarts
[17:37:38.479]                           grepl <- base::grepl
[17:37:38.479]                           restarts <- computeRestarts(cond)
[17:37:38.479]                           for (restart in restarts) {
[17:37:38.479]                             name <- restart$name
[17:37:38.479]                             if (is.null(name)) 
[17:37:38.479]                               next
[17:37:38.479]                             if (!grepl(pattern, name)) 
[17:37:38.479]                               next
[17:37:38.479]                             invokeRestart(restart)
[17:37:38.479]                             muffled <- TRUE
[17:37:38.479]                             break
[17:37:38.479]                           }
[17:37:38.479]                         }
[17:37:38.479]                       }
[17:37:38.479]                       invisible(muffled)
[17:37:38.479]                     }
[17:37:38.479]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.479]                   }
[17:37:38.479]                 }
[17:37:38.479]             }
[17:37:38.479]         }))
[17:37:38.479]     }, error = function(ex) {
[17:37:38.479]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:38.479]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.479]                 ...future.rng), started = ...future.startTime, 
[17:37:38.479]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:38.479]             version = "1.8"), class = "FutureResult")
[17:37:38.479]     }, finally = {
[17:37:38.479]         if (!identical(...future.workdir, getwd())) 
[17:37:38.479]             setwd(...future.workdir)
[17:37:38.479]         {
[17:37:38.479]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:38.479]                 ...future.oldOptions$nwarnings <- NULL
[17:37:38.479]             }
[17:37:38.479]             base::options(...future.oldOptions)
[17:37:38.479]             if (.Platform$OS.type == "windows") {
[17:37:38.479]                 old_names <- names(...future.oldEnvVars)
[17:37:38.479]                 envs <- base::Sys.getenv()
[17:37:38.479]                 names <- names(envs)
[17:37:38.479]                 common <- intersect(names, old_names)
[17:37:38.479]                 added <- setdiff(names, old_names)
[17:37:38.479]                 removed <- setdiff(old_names, names)
[17:37:38.479]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:38.479]                   envs[common]]
[17:37:38.479]                 NAMES <- toupper(changed)
[17:37:38.479]                 args <- list()
[17:37:38.479]                 for (kk in seq_along(NAMES)) {
[17:37:38.479]                   name <- changed[[kk]]
[17:37:38.479]                   NAME <- NAMES[[kk]]
[17:37:38.479]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.479]                     next
[17:37:38.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.479]                 }
[17:37:38.479]                 NAMES <- toupper(added)
[17:37:38.479]                 for (kk in seq_along(NAMES)) {
[17:37:38.479]                   name <- added[[kk]]
[17:37:38.479]                   NAME <- NAMES[[kk]]
[17:37:38.479]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.479]                     next
[17:37:38.479]                   args[[name]] <- ""
[17:37:38.479]                 }
[17:37:38.479]                 NAMES <- toupper(removed)
[17:37:38.479]                 for (kk in seq_along(NAMES)) {
[17:37:38.479]                   name <- removed[[kk]]
[17:37:38.479]                   NAME <- NAMES[[kk]]
[17:37:38.479]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.479]                     next
[17:37:38.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.479]                 }
[17:37:38.479]                 if (length(args) > 0) 
[17:37:38.479]                   base::do.call(base::Sys.setenv, args = args)
[17:37:38.479]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:38.479]             }
[17:37:38.479]             else {
[17:37:38.479]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:38.479]             }
[17:37:38.479]             {
[17:37:38.479]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:38.479]                   0L) {
[17:37:38.479]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:38.479]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:38.479]                   base::options(opts)
[17:37:38.479]                 }
[17:37:38.479]                 {
[17:37:38.479]                   {
[17:37:38.479]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:38.479]                     NULL
[17:37:38.479]                   }
[17:37:38.479]                   options(future.plan = NULL)
[17:37:38.479]                   if (is.na(NA_character_)) 
[17:37:38.479]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.479]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:38.479]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:38.479]                     .init = FALSE)
[17:37:38.479]                 }
[17:37:38.479]             }
[17:37:38.479]         }
[17:37:38.479]     })
[17:37:38.479]     if (TRUE) {
[17:37:38.479]         base::sink(type = "output", split = FALSE)
[17:37:38.479]         if (TRUE) {
[17:37:38.479]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:38.479]         }
[17:37:38.479]         else {
[17:37:38.479]             ...future.result["stdout"] <- base::list(NULL)
[17:37:38.479]         }
[17:37:38.479]         base::close(...future.stdout)
[17:37:38.479]         ...future.stdout <- NULL
[17:37:38.479]     }
[17:37:38.479]     ...future.result$conditions <- ...future.conditions
[17:37:38.479]     ...future.result$finished <- base::Sys.time()
[17:37:38.479]     ...future.result
[17:37:38.479] }
[17:37:38.482] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[17:37:38.482] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[17:37:38.482] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[17:37:38.482] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:37:38.483] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:37:38.483] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[17:37:38.483] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[17:37:38.483] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:38.484] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:38.484] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:38.484] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:38.484] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[17:37:38.485] MultisessionFuture started
[17:37:38.485] - Launch lazy future ... done
[17:37:38.485] run() for ‘MultisessionFuture’ ... done
[17:37:38.485] Created future:
[17:37:38.485] MultisessionFuture:
[17:37:38.485] Label: ‘future_mapply-1’
[17:37:38.485] Expression:
[17:37:38.485] {
[17:37:38.485]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.485]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:38.485]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.485]         on.exit(options(oopts), add = TRUE)
[17:37:38.485]     }
[17:37:38.485]     {
[17:37:38.485]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.485]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:38.485]         do.call(mapply, args = args)
[17:37:38.485]     }
[17:37:38.485] }
[17:37:38.485] Lazy evaluation: FALSE
[17:37:38.485] Asynchronous evaluation: TRUE
[17:37:38.485] Local evaluation: TRUE
[17:37:38.485] Environment: R_GlobalEnv
[17:37:38.485] Capture standard output: TRUE
[17:37:38.485] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:38.485] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:38.485] Packages: <none>
[17:37:38.485] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:38.485] Resolved: FALSE
[17:37:38.485] Value: <not collected>
[17:37:38.485] Conditions captured: <none>
[17:37:38.485] Early signaling: FALSE
[17:37:38.485] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:38.485] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.497] Chunk #1 of 2 ... DONE
[17:37:38.497] Chunk #2 of 2 ...
[17:37:38.497]  - Finding globals in '...' for chunk #2 ...
[17:37:38.497] getGlobalsAndPackages() ...
[17:37:38.497] Searching for globals...
[17:37:38.498] 
[17:37:38.498] Searching for globals ... DONE
[17:37:38.498] - globals: [0] <none>
[17:37:38.498] getGlobalsAndPackages() ... DONE
[17:37:38.498]    + additional globals found: [n=0] 
[17:37:38.498]    + additional namespaces needed: [n=0] 
[17:37:38.498]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:38.498]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:38.498]  - seeds: <none>
[17:37:38.499]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.499] getGlobalsAndPackages() ...
[17:37:38.499] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.499] Resolving globals: FALSE
[17:37:38.499] The total size of the 5 globals is 280 bytes (280 bytes)
[17:37:38.536] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:38.536] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.537] 
[17:37:38.537] getGlobalsAndPackages() ... DONE
[17:37:38.537] run() for ‘Future’ ...
[17:37:38.537] - state: ‘created’
[17:37:38.537] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:38.551] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.551] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:38.551]   - Field: ‘node’
[17:37:38.551]   - Field: ‘label’
[17:37:38.551]   - Field: ‘local’
[17:37:38.552]   - Field: ‘owner’
[17:37:38.552]   - Field: ‘envir’
[17:37:38.552]   - Field: ‘workers’
[17:37:38.552]   - Field: ‘packages’
[17:37:38.552]   - Field: ‘gc’
[17:37:38.552]   - Field: ‘conditions’
[17:37:38.552]   - Field: ‘persistent’
[17:37:38.552]   - Field: ‘expr’
[17:37:38.552]   - Field: ‘uuid’
[17:37:38.552]   - Field: ‘seed’
[17:37:38.552]   - Field: ‘version’
[17:37:38.553]   - Field: ‘result’
[17:37:38.553]   - Field: ‘asynchronous’
[17:37:38.553]   - Field: ‘calls’
[17:37:38.553]   - Field: ‘globals’
[17:37:38.553]   - Field: ‘stdout’
[17:37:38.553]   - Field: ‘earlySignal’
[17:37:38.553]   - Field: ‘lazy’
[17:37:38.553]   - Field: ‘state’
[17:37:38.553] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:38.553] - Launch lazy future ...
[17:37:38.554] Packages needed by the future expression (n = 0): <none>
[17:37:38.554] Packages needed by future strategies (n = 0): <none>
[17:37:38.554] {
[17:37:38.554]     {
[17:37:38.554]         {
[17:37:38.554]             ...future.startTime <- base::Sys.time()
[17:37:38.554]             {
[17:37:38.554]                 {
[17:37:38.554]                   {
[17:37:38.554]                     {
[17:37:38.554]                       base::local({
[17:37:38.554]                         has_future <- base::requireNamespace("future", 
[17:37:38.554]                           quietly = TRUE)
[17:37:38.554]                         if (has_future) {
[17:37:38.554]                           ns <- base::getNamespace("future")
[17:37:38.554]                           version <- ns[[".package"]][["version"]]
[17:37:38.554]                           if (is.null(version)) 
[17:37:38.554]                             version <- utils::packageVersion("future")
[17:37:38.554]                         }
[17:37:38.554]                         else {
[17:37:38.554]                           version <- NULL
[17:37:38.554]                         }
[17:37:38.554]                         if (!has_future || version < "1.8.0") {
[17:37:38.554]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:38.554]                             "", base::R.version$version.string), 
[17:37:38.554]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:38.554]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:38.554]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:38.554]                               "release", "version")], collapse = " "), 
[17:37:38.554]                             hostname = base::Sys.info()[["nodename"]])
[17:37:38.554]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:38.554]                             info)
[17:37:38.554]                           info <- base::paste(info, collapse = "; ")
[17:37:38.554]                           if (!has_future) {
[17:37:38.554]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:38.554]                               info)
[17:37:38.554]                           }
[17:37:38.554]                           else {
[17:37:38.554]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:38.554]                               info, version)
[17:37:38.554]                           }
[17:37:38.554]                           base::stop(msg)
[17:37:38.554]                         }
[17:37:38.554]                       })
[17:37:38.554]                     }
[17:37:38.554]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:38.554]                     base::options(mc.cores = 1L)
[17:37:38.554]                   }
[17:37:38.554]                   ...future.strategy.old <- future::plan("list")
[17:37:38.554]                   options(future.plan = NULL)
[17:37:38.554]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.554]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:38.554]                 }
[17:37:38.554]                 ...future.workdir <- getwd()
[17:37:38.554]             }
[17:37:38.554]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:38.554]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:38.554]         }
[17:37:38.554]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:38.554]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:38.554]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:38.554]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:38.554]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:38.554]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:38.554]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:38.554]             base::names(...future.oldOptions))
[17:37:38.554]     }
[17:37:38.554]     if (FALSE) {
[17:37:38.554]     }
[17:37:38.554]     else {
[17:37:38.554]         if (TRUE) {
[17:37:38.554]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:38.554]                 open = "w")
[17:37:38.554]         }
[17:37:38.554]         else {
[17:37:38.554]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:38.554]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:38.554]         }
[17:37:38.554]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:38.554]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:38.554]             base::sink(type = "output", split = FALSE)
[17:37:38.554]             base::close(...future.stdout)
[17:37:38.554]         }, add = TRUE)
[17:37:38.554]     }
[17:37:38.554]     ...future.frame <- base::sys.nframe()
[17:37:38.554]     ...future.conditions <- base::list()
[17:37:38.554]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:38.554]     if (FALSE) {
[17:37:38.554]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:38.554]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:38.554]     }
[17:37:38.554]     ...future.result <- base::tryCatch({
[17:37:38.554]         base::withCallingHandlers({
[17:37:38.554]             ...future.value <- base::withVisible(base::local({
[17:37:38.554]                 ...future.makeSendCondition <- base::local({
[17:37:38.554]                   sendCondition <- NULL
[17:37:38.554]                   function(frame = 1L) {
[17:37:38.554]                     if (is.function(sendCondition)) 
[17:37:38.554]                       return(sendCondition)
[17:37:38.554]                     ns <- getNamespace("parallel")
[17:37:38.554]                     if (exists("sendData", mode = "function", 
[17:37:38.554]                       envir = ns)) {
[17:37:38.554]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:38.554]                         envir = ns)
[17:37:38.554]                       envir <- sys.frame(frame)
[17:37:38.554]                       master <- NULL
[17:37:38.554]                       while (!identical(envir, .GlobalEnv) && 
[17:37:38.554]                         !identical(envir, emptyenv())) {
[17:37:38.554]                         if (exists("master", mode = "list", envir = envir, 
[17:37:38.554]                           inherits = FALSE)) {
[17:37:38.554]                           master <- get("master", mode = "list", 
[17:37:38.554]                             envir = envir, inherits = FALSE)
[17:37:38.554]                           if (inherits(master, c("SOCKnode", 
[17:37:38.554]                             "SOCK0node"))) {
[17:37:38.554]                             sendCondition <<- function(cond) {
[17:37:38.554]                               data <- list(type = "VALUE", value = cond, 
[17:37:38.554]                                 success = TRUE)
[17:37:38.554]                               parallel_sendData(master, data)
[17:37:38.554]                             }
[17:37:38.554]                             return(sendCondition)
[17:37:38.554]                           }
[17:37:38.554]                         }
[17:37:38.554]                         frame <- frame + 1L
[17:37:38.554]                         envir <- sys.frame(frame)
[17:37:38.554]                       }
[17:37:38.554]                     }
[17:37:38.554]                     sendCondition <<- function(cond) NULL
[17:37:38.554]                   }
[17:37:38.554]                 })
[17:37:38.554]                 withCallingHandlers({
[17:37:38.554]                   {
[17:37:38.554]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.554]                     if (!identical(...future.globals.maxSize.org, 
[17:37:38.554]                       ...future.globals.maxSize)) {
[17:37:38.554]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.554]                       on.exit(options(oopts), add = TRUE)
[17:37:38.554]                     }
[17:37:38.554]                     {
[17:37:38.554]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.554]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:38.554]                         USE.NAMES = FALSE)
[17:37:38.554]                       do.call(mapply, args = args)
[17:37:38.554]                     }
[17:37:38.554]                   }
[17:37:38.554]                 }, immediateCondition = function(cond) {
[17:37:38.554]                   sendCondition <- ...future.makeSendCondition()
[17:37:38.554]                   sendCondition(cond)
[17:37:38.554]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.554]                   {
[17:37:38.554]                     inherits <- base::inherits
[17:37:38.554]                     invokeRestart <- base::invokeRestart
[17:37:38.554]                     is.null <- base::is.null
[17:37:38.554]                     muffled <- FALSE
[17:37:38.554]                     if (inherits(cond, "message")) {
[17:37:38.554]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:38.554]                       if (muffled) 
[17:37:38.554]                         invokeRestart("muffleMessage")
[17:37:38.554]                     }
[17:37:38.554]                     else if (inherits(cond, "warning")) {
[17:37:38.554]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:38.554]                       if (muffled) 
[17:37:38.554]                         invokeRestart("muffleWarning")
[17:37:38.554]                     }
[17:37:38.554]                     else if (inherits(cond, "condition")) {
[17:37:38.554]                       if (!is.null(pattern)) {
[17:37:38.554]                         computeRestarts <- base::computeRestarts
[17:37:38.554]                         grepl <- base::grepl
[17:37:38.554]                         restarts <- computeRestarts(cond)
[17:37:38.554]                         for (restart in restarts) {
[17:37:38.554]                           name <- restart$name
[17:37:38.554]                           if (is.null(name)) 
[17:37:38.554]                             next
[17:37:38.554]                           if (!grepl(pattern, name)) 
[17:37:38.554]                             next
[17:37:38.554]                           invokeRestart(restart)
[17:37:38.554]                           muffled <- TRUE
[17:37:38.554]                           break
[17:37:38.554]                         }
[17:37:38.554]                       }
[17:37:38.554]                     }
[17:37:38.554]                     invisible(muffled)
[17:37:38.554]                   }
[17:37:38.554]                   muffleCondition(cond)
[17:37:38.554]                 })
[17:37:38.554]             }))
[17:37:38.554]             future::FutureResult(value = ...future.value$value, 
[17:37:38.554]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.554]                   ...future.rng), globalenv = if (FALSE) 
[17:37:38.554]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:38.554]                     ...future.globalenv.names))
[17:37:38.554]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:38.554]         }, condition = base::local({
[17:37:38.554]             c <- base::c
[17:37:38.554]             inherits <- base::inherits
[17:37:38.554]             invokeRestart <- base::invokeRestart
[17:37:38.554]             length <- base::length
[17:37:38.554]             list <- base::list
[17:37:38.554]             seq.int <- base::seq.int
[17:37:38.554]             signalCondition <- base::signalCondition
[17:37:38.554]             sys.calls <- base::sys.calls
[17:37:38.554]             `[[` <- base::`[[`
[17:37:38.554]             `+` <- base::`+`
[17:37:38.554]             `<<-` <- base::`<<-`
[17:37:38.554]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:38.554]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:38.554]                   3L)]
[17:37:38.554]             }
[17:37:38.554]             function(cond) {
[17:37:38.554]                 is_error <- inherits(cond, "error")
[17:37:38.554]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:38.554]                   NULL)
[17:37:38.554]                 if (is_error) {
[17:37:38.554]                   sessionInformation <- function() {
[17:37:38.554]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:38.554]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:38.554]                       search = base::search(), system = base::Sys.info())
[17:37:38.554]                   }
[17:37:38.554]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.554]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:38.554]                     cond$call), session = sessionInformation(), 
[17:37:38.554]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:38.554]                   signalCondition(cond)
[17:37:38.554]                 }
[17:37:38.554]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:38.554]                 "immediateCondition"))) {
[17:37:38.554]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:38.554]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.554]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:38.554]                   if (TRUE && !signal) {
[17:37:38.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.554]                     {
[17:37:38.554]                       inherits <- base::inherits
[17:37:38.554]                       invokeRestart <- base::invokeRestart
[17:37:38.554]                       is.null <- base::is.null
[17:37:38.554]                       muffled <- FALSE
[17:37:38.554]                       if (inherits(cond, "message")) {
[17:37:38.554]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.554]                         if (muffled) 
[17:37:38.554]                           invokeRestart("muffleMessage")
[17:37:38.554]                       }
[17:37:38.554]                       else if (inherits(cond, "warning")) {
[17:37:38.554]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.554]                         if (muffled) 
[17:37:38.554]                           invokeRestart("muffleWarning")
[17:37:38.554]                       }
[17:37:38.554]                       else if (inherits(cond, "condition")) {
[17:37:38.554]                         if (!is.null(pattern)) {
[17:37:38.554]                           computeRestarts <- base::computeRestarts
[17:37:38.554]                           grepl <- base::grepl
[17:37:38.554]                           restarts <- computeRestarts(cond)
[17:37:38.554]                           for (restart in restarts) {
[17:37:38.554]                             name <- restart$name
[17:37:38.554]                             if (is.null(name)) 
[17:37:38.554]                               next
[17:37:38.554]                             if (!grepl(pattern, name)) 
[17:37:38.554]                               next
[17:37:38.554]                             invokeRestart(restart)
[17:37:38.554]                             muffled <- TRUE
[17:37:38.554]                             break
[17:37:38.554]                           }
[17:37:38.554]                         }
[17:37:38.554]                       }
[17:37:38.554]                       invisible(muffled)
[17:37:38.554]                     }
[17:37:38.554]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.554]                   }
[17:37:38.554]                 }
[17:37:38.554]                 else {
[17:37:38.554]                   if (TRUE) {
[17:37:38.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.554]                     {
[17:37:38.554]                       inherits <- base::inherits
[17:37:38.554]                       invokeRestart <- base::invokeRestart
[17:37:38.554]                       is.null <- base::is.null
[17:37:38.554]                       muffled <- FALSE
[17:37:38.554]                       if (inherits(cond, "message")) {
[17:37:38.554]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.554]                         if (muffled) 
[17:37:38.554]                           invokeRestart("muffleMessage")
[17:37:38.554]                       }
[17:37:38.554]                       else if (inherits(cond, "warning")) {
[17:37:38.554]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.554]                         if (muffled) 
[17:37:38.554]                           invokeRestart("muffleWarning")
[17:37:38.554]                       }
[17:37:38.554]                       else if (inherits(cond, "condition")) {
[17:37:38.554]                         if (!is.null(pattern)) {
[17:37:38.554]                           computeRestarts <- base::computeRestarts
[17:37:38.554]                           grepl <- base::grepl
[17:37:38.554]                           restarts <- computeRestarts(cond)
[17:37:38.554]                           for (restart in restarts) {
[17:37:38.554]                             name <- restart$name
[17:37:38.554]                             if (is.null(name)) 
[17:37:38.554]                               next
[17:37:38.554]                             if (!grepl(pattern, name)) 
[17:37:38.554]                               next
[17:37:38.554]                             invokeRestart(restart)
[17:37:38.554]                             muffled <- TRUE
[17:37:38.554]                             break
[17:37:38.554]                           }
[17:37:38.554]                         }
[17:37:38.554]                       }
[17:37:38.554]                       invisible(muffled)
[17:37:38.554]                     }
[17:37:38.554]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.554]                   }
[17:37:38.554]                 }
[17:37:38.554]             }
[17:37:38.554]         }))
[17:37:38.554]     }, error = function(ex) {
[17:37:38.554]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:38.554]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.554]                 ...future.rng), started = ...future.startTime, 
[17:37:38.554]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:38.554]             version = "1.8"), class = "FutureResult")
[17:37:38.554]     }, finally = {
[17:37:38.554]         if (!identical(...future.workdir, getwd())) 
[17:37:38.554]             setwd(...future.workdir)
[17:37:38.554]         {
[17:37:38.554]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:38.554]                 ...future.oldOptions$nwarnings <- NULL
[17:37:38.554]             }
[17:37:38.554]             base::options(...future.oldOptions)
[17:37:38.554]             if (.Platform$OS.type == "windows") {
[17:37:38.554]                 old_names <- names(...future.oldEnvVars)
[17:37:38.554]                 envs <- base::Sys.getenv()
[17:37:38.554]                 names <- names(envs)
[17:37:38.554]                 common <- intersect(names, old_names)
[17:37:38.554]                 added <- setdiff(names, old_names)
[17:37:38.554]                 removed <- setdiff(old_names, names)
[17:37:38.554]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:38.554]                   envs[common]]
[17:37:38.554]                 NAMES <- toupper(changed)
[17:37:38.554]                 args <- list()
[17:37:38.554]                 for (kk in seq_along(NAMES)) {
[17:37:38.554]                   name <- changed[[kk]]
[17:37:38.554]                   NAME <- NAMES[[kk]]
[17:37:38.554]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.554]                     next
[17:37:38.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.554]                 }
[17:37:38.554]                 NAMES <- toupper(added)
[17:37:38.554]                 for (kk in seq_along(NAMES)) {
[17:37:38.554]                   name <- added[[kk]]
[17:37:38.554]                   NAME <- NAMES[[kk]]
[17:37:38.554]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.554]                     next
[17:37:38.554]                   args[[name]] <- ""
[17:37:38.554]                 }
[17:37:38.554]                 NAMES <- toupper(removed)
[17:37:38.554]                 for (kk in seq_along(NAMES)) {
[17:37:38.554]                   name <- removed[[kk]]
[17:37:38.554]                   NAME <- NAMES[[kk]]
[17:37:38.554]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.554]                     next
[17:37:38.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.554]                 }
[17:37:38.554]                 if (length(args) > 0) 
[17:37:38.554]                   base::do.call(base::Sys.setenv, args = args)
[17:37:38.554]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:38.554]             }
[17:37:38.554]             else {
[17:37:38.554]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:38.554]             }
[17:37:38.554]             {
[17:37:38.554]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:38.554]                   0L) {
[17:37:38.554]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:38.554]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:38.554]                   base::options(opts)
[17:37:38.554]                 }
[17:37:38.554]                 {
[17:37:38.554]                   {
[17:37:38.554]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:38.554]                     NULL
[17:37:38.554]                   }
[17:37:38.554]                   options(future.plan = NULL)
[17:37:38.554]                   if (is.na(NA_character_)) 
[17:37:38.554]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.554]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:38.554]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:38.554]                     .init = FALSE)
[17:37:38.554]                 }
[17:37:38.554]             }
[17:37:38.554]         }
[17:37:38.554]     })
[17:37:38.554]     if (TRUE) {
[17:37:38.554]         base::sink(type = "output", split = FALSE)
[17:37:38.554]         if (TRUE) {
[17:37:38.554]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:38.554]         }
[17:37:38.554]         else {
[17:37:38.554]             ...future.result["stdout"] <- base::list(NULL)
[17:37:38.554]         }
[17:37:38.554]         base::close(...future.stdout)
[17:37:38.554]         ...future.stdout <- NULL
[17:37:38.554]     }
[17:37:38.554]     ...future.result$conditions <- ...future.conditions
[17:37:38.554]     ...future.result$finished <- base::Sys.time()
[17:37:38.554]     ...future.result
[17:37:38.554] }
[17:37:38.557] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[17:37:38.557] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[17:37:38.557] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[17:37:38.558] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:37:38.561] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:37:38.561] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:37:38.562] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:37:38.562] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:37:38.562] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:37:38.563] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:37:38.563] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:37:38.563] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[17:37:38.564] MultisessionFuture started
[17:37:38.564] - Launch lazy future ... done
[17:37:38.564] run() for ‘MultisessionFuture’ ... done
[17:37:38.564] Created future:
[17:37:38.564] MultisessionFuture:
[17:37:38.564] Label: ‘future_mapply-2’
[17:37:38.564] Expression:
[17:37:38.564] {
[17:37:38.564]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.564]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:38.564]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.564]         on.exit(options(oopts), add = TRUE)
[17:37:38.564]     }
[17:37:38.564]     {
[17:37:38.564]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.564]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:38.564]         do.call(mapply, args = args)
[17:37:38.564]     }
[17:37:38.564] }
[17:37:38.564] Lazy evaluation: FALSE
[17:37:38.564] Asynchronous evaluation: TRUE
[17:37:38.564] Local evaluation: TRUE
[17:37:38.564] Environment: R_GlobalEnv
[17:37:38.564] Capture standard output: TRUE
[17:37:38.564] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:38.564] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:38.564] Packages: <none>
[17:37:38.564] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:38.564] Resolved: FALSE
[17:37:38.564] Value: <not collected>
[17:37:38.564] Conditions captured: <none>
[17:37:38.564] Early signaling: FALSE
[17:37:38.564] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:38.564] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.576] Chunk #2 of 2 ... DONE
[17:37:38.576] Launching 2 futures (chunks) ... DONE
[17:37:38.576] Resolving 2 futures (chunks) ...
[17:37:38.576] resolve() on list ...
[17:37:38.576]  recursive: 0
[17:37:38.576]  length: 2
[17:37:38.576] 
[17:37:38.577] receiveMessageFromWorker() for ClusterFuture ...
[17:37:38.577] - Validating connection of MultisessionFuture
[17:37:38.577] - received message: FutureResult
[17:37:38.577] - Received FutureResult
[17:37:38.577] - Erased future from FutureRegistry
[17:37:38.577] result() for ClusterFuture ...
[17:37:38.577] - result already collected: FutureResult
[17:37:38.577] result() for ClusterFuture ... done
[17:37:38.577] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:38.578] Future #1
[17:37:38.578] result() for ClusterFuture ...
[17:37:38.578] - result already collected: FutureResult
[17:37:38.578] result() for ClusterFuture ... done
[17:37:38.578] result() for ClusterFuture ...
[17:37:38.578] - result already collected: FutureResult
[17:37:38.578] result() for ClusterFuture ... done
[17:37:38.578] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:37:38.578] - nx: 2
[17:37:38.578] - relay: TRUE
[17:37:38.578] - stdout: TRUE
[17:37:38.578] - signal: TRUE
[17:37:38.578] - resignal: FALSE
[17:37:38.579] - force: TRUE
[17:37:38.579] - relayed: [n=2] FALSE, FALSE
[17:37:38.579] - queued futures: [n=2] FALSE, FALSE
[17:37:38.579]  - until=1
[17:37:38.579]  - relaying element #1
[17:37:38.579] result() for ClusterFuture ...
[17:37:38.579] - result already collected: FutureResult
[17:37:38.579] result() for ClusterFuture ... done
[17:37:38.579] result() for ClusterFuture ...
[17:37:38.579] - result already collected: FutureResult
[17:37:38.579] result() for ClusterFuture ... done
[17:37:38.580] result() for ClusterFuture ...
[17:37:38.580] - result already collected: FutureResult
[17:37:38.580] result() for ClusterFuture ... done
[17:37:38.580] result() for ClusterFuture ...
[17:37:38.580] - result already collected: FutureResult
[17:37:38.580] result() for ClusterFuture ... done
[17:37:38.580] - relayed: [n=2] TRUE, FALSE
[17:37:38.580] - queued futures: [n=2] TRUE, FALSE
[17:37:38.580] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:37:38.580]  length: 1 (resolved future 1)
[17:37:38.606] receiveMessageFromWorker() for ClusterFuture ...
[17:37:38.607] - Validating connection of MultisessionFuture
[17:37:38.607] - received message: FutureResult
[17:37:38.607] - Received FutureResult
[17:37:38.607] - Erased future from FutureRegistry
[17:37:38.607] result() for ClusterFuture ...
[17:37:38.608] - result already collected: FutureResult
[17:37:38.608] result() for ClusterFuture ... done
[17:37:38.608] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:38.608] Future #2
[17:37:38.608] result() for ClusterFuture ...
[17:37:38.608] - result already collected: FutureResult
[17:37:38.608] result() for ClusterFuture ... done
[17:37:38.609] result() for ClusterFuture ...
[17:37:38.609] - result already collected: FutureResult
[17:37:38.609] result() for ClusterFuture ... done
[17:37:38.609] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:37:38.609] - nx: 2
[17:37:38.609] - relay: TRUE
[17:37:38.609] - stdout: TRUE
[17:37:38.610] - signal: TRUE
[17:37:38.610] - resignal: FALSE
[17:37:38.610] - force: TRUE
[17:37:38.610] - relayed: [n=2] TRUE, FALSE
[17:37:38.610] - queued futures: [n=2] TRUE, FALSE
[17:37:38.610]  - until=2
[17:37:38.610]  - relaying element #2
[17:37:38.610] result() for ClusterFuture ...
[17:37:38.611] - result already collected: FutureResult
[17:37:38.611] result() for ClusterFuture ... done
[17:37:38.611] result() for ClusterFuture ...
[17:37:38.611] - result already collected: FutureResult
[17:37:38.611] result() for ClusterFuture ... done
[17:37:38.611] result() for ClusterFuture ...
[17:37:38.611] - result already collected: FutureResult
[17:37:38.612] result() for ClusterFuture ... done
[17:37:38.612] result() for ClusterFuture ...
[17:37:38.612] - result already collected: FutureResult
[17:37:38.612] result() for ClusterFuture ... done
[17:37:38.612] - relayed: [n=2] TRUE, TRUE
[17:37:38.612] - queued futures: [n=2] TRUE, TRUE
[17:37:38.612] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:37:38.612]  length: 0 (resolved future 2)
[17:37:38.613] Relaying remaining futures
[17:37:38.613] signalConditionsASAP(NULL, pos=0) ...
[17:37:38.613] - nx: 2
[17:37:38.613] - relay: TRUE
[17:37:38.613] - stdout: TRUE
[17:37:38.613] - signal: TRUE
[17:37:38.613] - resignal: FALSE
[17:37:38.613] - force: TRUE
[17:37:38.614] - relayed: [n=2] TRUE, TRUE
[17:37:38.614] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:38.614] - relayed: [n=2] TRUE, TRUE
[17:37:38.614] - queued futures: [n=2] TRUE, TRUE
[17:37:38.614] signalConditionsASAP(NULL, pos=0) ... done
[17:37:38.614] resolve() on list ... DONE
[17:37:38.614] result() for ClusterFuture ...
[17:37:38.615] - result already collected: FutureResult
[17:37:38.615] result() for ClusterFuture ... done
[17:37:38.615] result() for ClusterFuture ...
[17:37:38.615] - result already collected: FutureResult
[17:37:38.615] result() for ClusterFuture ... done
[17:37:38.615] result() for ClusterFuture ...
[17:37:38.615] - result already collected: FutureResult
[17:37:38.615] result() for ClusterFuture ... done
[17:37:38.616] result() for ClusterFuture ...
[17:37:38.616] - result already collected: FutureResult
[17:37:38.616] result() for ClusterFuture ... done
[17:37:38.616]  - Number of value chunks collected: 2
[17:37:38.616] Resolving 2 futures (chunks) ... DONE
[17:37:38.616] Reducing values from 2 chunks ...
[17:37:38.616]  - Number of values collected after concatenation: 4
[17:37:38.617]  - Number of values expected: 4
[17:37:38.617] Reducing values from 2 chunks ... DONE
[17:37:38.617] future_mapply() ... DONE
[17:37:38.617] future_mapply() ...
[17:37:38.622] Number of chunks: 2
[17:37:38.622] getGlobalsAndPackagesXApply() ...
[17:37:38.622]  - future.globals: TRUE
[17:37:38.622] getGlobalsAndPackages() ...
[17:37:38.623] Searching for globals...
[17:37:38.623] - globals found: [1] ‘FUN’
[17:37:38.624] Searching for globals ... DONE
[17:37:38.624] Resolving globals: FALSE
[17:37:38.624] The total size of the 1 globals is 56 bytes (56 bytes)
[17:37:38.625] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:37:38.625] - globals: [1] ‘FUN’
[17:37:38.625] 
[17:37:38.625] getGlobalsAndPackages() ... DONE
[17:37:38.625]  - globals found/used: [n=1] ‘FUN’
[17:37:38.625]  - needed namespaces: [n=0] 
[17:37:38.625] Finding globals ... DONE
[17:37:38.626] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:38.626] List of 2
[17:37:38.626]  $ ...future.FUN:function (x, ...)  
[17:37:38.626]  $ MoreArgs     :List of 1
[17:37:38.626]   ..$ x: num 42
[17:37:38.626]  - attr(*, "where")=List of 2
[17:37:38.626]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:38.626]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:38.626]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:38.626]  - attr(*, "resolved")= logi FALSE
[17:37:38.626]  - attr(*, "total_size")= num NA
[17:37:38.630] Packages to be attached in all futures: [n=0] 
[17:37:38.630] getGlobalsAndPackagesXApply() ... DONE
[17:37:38.630] Number of futures (= number of chunks): 2
[17:37:38.630] Launching 2 futures (chunks) ...
[17:37:38.630] Chunk #1 of 2 ...
[17:37:38.631]  - Finding globals in '...' for chunk #1 ...
[17:37:38.631] getGlobalsAndPackages() ...
[17:37:38.631] Searching for globals...
[17:37:38.631] 
[17:37:38.631] Searching for globals ... DONE
[17:37:38.632] - globals: [0] <none>
[17:37:38.632] getGlobalsAndPackages() ... DONE
[17:37:38.632]    + additional globals found: [n=0] 
[17:37:38.632]    + additional namespaces needed: [n=0] 
[17:37:38.632]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:38.632]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:38.632]  - seeds: <none>
[17:37:38.632]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.633] getGlobalsAndPackages() ...
[17:37:38.633] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.633] Resolving globals: FALSE
[17:37:38.633] The total size of the 5 globals is 224 bytes (224 bytes)
[17:37:38.634] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:37:38.634] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.634] 
[17:37:38.634] getGlobalsAndPackages() ... DONE
[17:37:38.635] run() for ‘Future’ ...
[17:37:38.635] - state: ‘created’
[17:37:38.635] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:38.648] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.648] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:38.649]   - Field: ‘node’
[17:37:38.649]   - Field: ‘label’
[17:37:38.649]   - Field: ‘local’
[17:37:38.649]   - Field: ‘owner’
[17:37:38.649]   - Field: ‘envir’
[17:37:38.649]   - Field: ‘workers’
[17:37:38.649]   - Field: ‘packages’
[17:37:38.649]   - Field: ‘gc’
[17:37:38.649]   - Field: ‘conditions’
[17:37:38.649]   - Field: ‘persistent’
[17:37:38.650]   - Field: ‘expr’
[17:37:38.650]   - Field: ‘uuid’
[17:37:38.650]   - Field: ‘seed’
[17:37:38.650]   - Field: ‘version’
[17:37:38.650]   - Field: ‘result’
[17:37:38.650]   - Field: ‘asynchronous’
[17:37:38.650]   - Field: ‘calls’
[17:37:38.650]   - Field: ‘globals’
[17:37:38.650]   - Field: ‘stdout’
[17:37:38.650]   - Field: ‘earlySignal’
[17:37:38.650]   - Field: ‘lazy’
[17:37:38.650]   - Field: ‘state’
[17:37:38.651] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:38.651] - Launch lazy future ...
[17:37:38.651] Packages needed by the future expression (n = 0): <none>
[17:37:38.651] Packages needed by future strategies (n = 0): <none>
[17:37:38.651] {
[17:37:38.651]     {
[17:37:38.651]         {
[17:37:38.651]             ...future.startTime <- base::Sys.time()
[17:37:38.651]             {
[17:37:38.651]                 {
[17:37:38.651]                   {
[17:37:38.651]                     {
[17:37:38.651]                       base::local({
[17:37:38.651]                         has_future <- base::requireNamespace("future", 
[17:37:38.651]                           quietly = TRUE)
[17:37:38.651]                         if (has_future) {
[17:37:38.651]                           ns <- base::getNamespace("future")
[17:37:38.651]                           version <- ns[[".package"]][["version"]]
[17:37:38.651]                           if (is.null(version)) 
[17:37:38.651]                             version <- utils::packageVersion("future")
[17:37:38.651]                         }
[17:37:38.651]                         else {
[17:37:38.651]                           version <- NULL
[17:37:38.651]                         }
[17:37:38.651]                         if (!has_future || version < "1.8.0") {
[17:37:38.651]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:38.651]                             "", base::R.version$version.string), 
[17:37:38.651]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:38.651]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:38.651]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:38.651]                               "release", "version")], collapse = " "), 
[17:37:38.651]                             hostname = base::Sys.info()[["nodename"]])
[17:37:38.651]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:38.651]                             info)
[17:37:38.651]                           info <- base::paste(info, collapse = "; ")
[17:37:38.651]                           if (!has_future) {
[17:37:38.651]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:38.651]                               info)
[17:37:38.651]                           }
[17:37:38.651]                           else {
[17:37:38.651]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:38.651]                               info, version)
[17:37:38.651]                           }
[17:37:38.651]                           base::stop(msg)
[17:37:38.651]                         }
[17:37:38.651]                       })
[17:37:38.651]                     }
[17:37:38.651]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:38.651]                     base::options(mc.cores = 1L)
[17:37:38.651]                   }
[17:37:38.651]                   ...future.strategy.old <- future::plan("list")
[17:37:38.651]                   options(future.plan = NULL)
[17:37:38.651]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.651]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:38.651]                 }
[17:37:38.651]                 ...future.workdir <- getwd()
[17:37:38.651]             }
[17:37:38.651]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:38.651]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:38.651]         }
[17:37:38.651]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:38.651]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:38.651]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:38.651]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:38.651]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:38.651]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:38.651]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:38.651]             base::names(...future.oldOptions))
[17:37:38.651]     }
[17:37:38.651]     if (FALSE) {
[17:37:38.651]     }
[17:37:38.651]     else {
[17:37:38.651]         if (TRUE) {
[17:37:38.651]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:38.651]                 open = "w")
[17:37:38.651]         }
[17:37:38.651]         else {
[17:37:38.651]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:38.651]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:38.651]         }
[17:37:38.651]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:38.651]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:38.651]             base::sink(type = "output", split = FALSE)
[17:37:38.651]             base::close(...future.stdout)
[17:37:38.651]         }, add = TRUE)
[17:37:38.651]     }
[17:37:38.651]     ...future.frame <- base::sys.nframe()
[17:37:38.651]     ...future.conditions <- base::list()
[17:37:38.651]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:38.651]     if (FALSE) {
[17:37:38.651]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:38.651]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:38.651]     }
[17:37:38.651]     ...future.result <- base::tryCatch({
[17:37:38.651]         base::withCallingHandlers({
[17:37:38.651]             ...future.value <- base::withVisible(base::local({
[17:37:38.651]                 ...future.makeSendCondition <- base::local({
[17:37:38.651]                   sendCondition <- NULL
[17:37:38.651]                   function(frame = 1L) {
[17:37:38.651]                     if (is.function(sendCondition)) 
[17:37:38.651]                       return(sendCondition)
[17:37:38.651]                     ns <- getNamespace("parallel")
[17:37:38.651]                     if (exists("sendData", mode = "function", 
[17:37:38.651]                       envir = ns)) {
[17:37:38.651]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:38.651]                         envir = ns)
[17:37:38.651]                       envir <- sys.frame(frame)
[17:37:38.651]                       master <- NULL
[17:37:38.651]                       while (!identical(envir, .GlobalEnv) && 
[17:37:38.651]                         !identical(envir, emptyenv())) {
[17:37:38.651]                         if (exists("master", mode = "list", envir = envir, 
[17:37:38.651]                           inherits = FALSE)) {
[17:37:38.651]                           master <- get("master", mode = "list", 
[17:37:38.651]                             envir = envir, inherits = FALSE)
[17:37:38.651]                           if (inherits(master, c("SOCKnode", 
[17:37:38.651]                             "SOCK0node"))) {
[17:37:38.651]                             sendCondition <<- function(cond) {
[17:37:38.651]                               data <- list(type = "VALUE", value = cond, 
[17:37:38.651]                                 success = TRUE)
[17:37:38.651]                               parallel_sendData(master, data)
[17:37:38.651]                             }
[17:37:38.651]                             return(sendCondition)
[17:37:38.651]                           }
[17:37:38.651]                         }
[17:37:38.651]                         frame <- frame + 1L
[17:37:38.651]                         envir <- sys.frame(frame)
[17:37:38.651]                       }
[17:37:38.651]                     }
[17:37:38.651]                     sendCondition <<- function(cond) NULL
[17:37:38.651]                   }
[17:37:38.651]                 })
[17:37:38.651]                 withCallingHandlers({
[17:37:38.651]                   {
[17:37:38.651]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.651]                     if (!identical(...future.globals.maxSize.org, 
[17:37:38.651]                       ...future.globals.maxSize)) {
[17:37:38.651]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.651]                       on.exit(options(oopts), add = TRUE)
[17:37:38.651]                     }
[17:37:38.651]                     {
[17:37:38.651]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.651]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:38.651]                         USE.NAMES = FALSE)
[17:37:38.651]                       do.call(mapply, args = args)
[17:37:38.651]                     }
[17:37:38.651]                   }
[17:37:38.651]                 }, immediateCondition = function(cond) {
[17:37:38.651]                   sendCondition <- ...future.makeSendCondition()
[17:37:38.651]                   sendCondition(cond)
[17:37:38.651]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.651]                   {
[17:37:38.651]                     inherits <- base::inherits
[17:37:38.651]                     invokeRestart <- base::invokeRestart
[17:37:38.651]                     is.null <- base::is.null
[17:37:38.651]                     muffled <- FALSE
[17:37:38.651]                     if (inherits(cond, "message")) {
[17:37:38.651]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:38.651]                       if (muffled) 
[17:37:38.651]                         invokeRestart("muffleMessage")
[17:37:38.651]                     }
[17:37:38.651]                     else if (inherits(cond, "warning")) {
[17:37:38.651]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:38.651]                       if (muffled) 
[17:37:38.651]                         invokeRestart("muffleWarning")
[17:37:38.651]                     }
[17:37:38.651]                     else if (inherits(cond, "condition")) {
[17:37:38.651]                       if (!is.null(pattern)) {
[17:37:38.651]                         computeRestarts <- base::computeRestarts
[17:37:38.651]                         grepl <- base::grepl
[17:37:38.651]                         restarts <- computeRestarts(cond)
[17:37:38.651]                         for (restart in restarts) {
[17:37:38.651]                           name <- restart$name
[17:37:38.651]                           if (is.null(name)) 
[17:37:38.651]                             next
[17:37:38.651]                           if (!grepl(pattern, name)) 
[17:37:38.651]                             next
[17:37:38.651]                           invokeRestart(restart)
[17:37:38.651]                           muffled <- TRUE
[17:37:38.651]                           break
[17:37:38.651]                         }
[17:37:38.651]                       }
[17:37:38.651]                     }
[17:37:38.651]                     invisible(muffled)
[17:37:38.651]                   }
[17:37:38.651]                   muffleCondition(cond)
[17:37:38.651]                 })
[17:37:38.651]             }))
[17:37:38.651]             future::FutureResult(value = ...future.value$value, 
[17:37:38.651]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.651]                   ...future.rng), globalenv = if (FALSE) 
[17:37:38.651]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:38.651]                     ...future.globalenv.names))
[17:37:38.651]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:38.651]         }, condition = base::local({
[17:37:38.651]             c <- base::c
[17:37:38.651]             inherits <- base::inherits
[17:37:38.651]             invokeRestart <- base::invokeRestart
[17:37:38.651]             length <- base::length
[17:37:38.651]             list <- base::list
[17:37:38.651]             seq.int <- base::seq.int
[17:37:38.651]             signalCondition <- base::signalCondition
[17:37:38.651]             sys.calls <- base::sys.calls
[17:37:38.651]             `[[` <- base::`[[`
[17:37:38.651]             `+` <- base::`+`
[17:37:38.651]             `<<-` <- base::`<<-`
[17:37:38.651]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:38.651]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:38.651]                   3L)]
[17:37:38.651]             }
[17:37:38.651]             function(cond) {
[17:37:38.651]                 is_error <- inherits(cond, "error")
[17:37:38.651]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:38.651]                   NULL)
[17:37:38.651]                 if (is_error) {
[17:37:38.651]                   sessionInformation <- function() {
[17:37:38.651]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:38.651]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:38.651]                       search = base::search(), system = base::Sys.info())
[17:37:38.651]                   }
[17:37:38.651]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.651]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:38.651]                     cond$call), session = sessionInformation(), 
[17:37:38.651]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:38.651]                   signalCondition(cond)
[17:37:38.651]                 }
[17:37:38.651]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:38.651]                 "immediateCondition"))) {
[17:37:38.651]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:38.651]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.651]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:38.651]                   if (TRUE && !signal) {
[17:37:38.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.651]                     {
[17:37:38.651]                       inherits <- base::inherits
[17:37:38.651]                       invokeRestart <- base::invokeRestart
[17:37:38.651]                       is.null <- base::is.null
[17:37:38.651]                       muffled <- FALSE
[17:37:38.651]                       if (inherits(cond, "message")) {
[17:37:38.651]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.651]                         if (muffled) 
[17:37:38.651]                           invokeRestart("muffleMessage")
[17:37:38.651]                       }
[17:37:38.651]                       else if (inherits(cond, "warning")) {
[17:37:38.651]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.651]                         if (muffled) 
[17:37:38.651]                           invokeRestart("muffleWarning")
[17:37:38.651]                       }
[17:37:38.651]                       else if (inherits(cond, "condition")) {
[17:37:38.651]                         if (!is.null(pattern)) {
[17:37:38.651]                           computeRestarts <- base::computeRestarts
[17:37:38.651]                           grepl <- base::grepl
[17:37:38.651]                           restarts <- computeRestarts(cond)
[17:37:38.651]                           for (restart in restarts) {
[17:37:38.651]                             name <- restart$name
[17:37:38.651]                             if (is.null(name)) 
[17:37:38.651]                               next
[17:37:38.651]                             if (!grepl(pattern, name)) 
[17:37:38.651]                               next
[17:37:38.651]                             invokeRestart(restart)
[17:37:38.651]                             muffled <- TRUE
[17:37:38.651]                             break
[17:37:38.651]                           }
[17:37:38.651]                         }
[17:37:38.651]                       }
[17:37:38.651]                       invisible(muffled)
[17:37:38.651]                     }
[17:37:38.651]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.651]                   }
[17:37:38.651]                 }
[17:37:38.651]                 else {
[17:37:38.651]                   if (TRUE) {
[17:37:38.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.651]                     {
[17:37:38.651]                       inherits <- base::inherits
[17:37:38.651]                       invokeRestart <- base::invokeRestart
[17:37:38.651]                       is.null <- base::is.null
[17:37:38.651]                       muffled <- FALSE
[17:37:38.651]                       if (inherits(cond, "message")) {
[17:37:38.651]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.651]                         if (muffled) 
[17:37:38.651]                           invokeRestart("muffleMessage")
[17:37:38.651]                       }
[17:37:38.651]                       else if (inherits(cond, "warning")) {
[17:37:38.651]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.651]                         if (muffled) 
[17:37:38.651]                           invokeRestart("muffleWarning")
[17:37:38.651]                       }
[17:37:38.651]                       else if (inherits(cond, "condition")) {
[17:37:38.651]                         if (!is.null(pattern)) {
[17:37:38.651]                           computeRestarts <- base::computeRestarts
[17:37:38.651]                           grepl <- base::grepl
[17:37:38.651]                           restarts <- computeRestarts(cond)
[17:37:38.651]                           for (restart in restarts) {
[17:37:38.651]                             name <- restart$name
[17:37:38.651]                             if (is.null(name)) 
[17:37:38.651]                               next
[17:37:38.651]                             if (!grepl(pattern, name)) 
[17:37:38.651]                               next
[17:37:38.651]                             invokeRestart(restart)
[17:37:38.651]                             muffled <- TRUE
[17:37:38.651]                             break
[17:37:38.651]                           }
[17:37:38.651]                         }
[17:37:38.651]                       }
[17:37:38.651]                       invisible(muffled)
[17:37:38.651]                     }
[17:37:38.651]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.651]                   }
[17:37:38.651]                 }
[17:37:38.651]             }
[17:37:38.651]         }))
[17:37:38.651]     }, error = function(ex) {
[17:37:38.651]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:38.651]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.651]                 ...future.rng), started = ...future.startTime, 
[17:37:38.651]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:38.651]             version = "1.8"), class = "FutureResult")
[17:37:38.651]     }, finally = {
[17:37:38.651]         if (!identical(...future.workdir, getwd())) 
[17:37:38.651]             setwd(...future.workdir)
[17:37:38.651]         {
[17:37:38.651]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:38.651]                 ...future.oldOptions$nwarnings <- NULL
[17:37:38.651]             }
[17:37:38.651]             base::options(...future.oldOptions)
[17:37:38.651]             if (.Platform$OS.type == "windows") {
[17:37:38.651]                 old_names <- names(...future.oldEnvVars)
[17:37:38.651]                 envs <- base::Sys.getenv()
[17:37:38.651]                 names <- names(envs)
[17:37:38.651]                 common <- intersect(names, old_names)
[17:37:38.651]                 added <- setdiff(names, old_names)
[17:37:38.651]                 removed <- setdiff(old_names, names)
[17:37:38.651]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:38.651]                   envs[common]]
[17:37:38.651]                 NAMES <- toupper(changed)
[17:37:38.651]                 args <- list()
[17:37:38.651]                 for (kk in seq_along(NAMES)) {
[17:37:38.651]                   name <- changed[[kk]]
[17:37:38.651]                   NAME <- NAMES[[kk]]
[17:37:38.651]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.651]                     next
[17:37:38.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.651]                 }
[17:37:38.651]                 NAMES <- toupper(added)
[17:37:38.651]                 for (kk in seq_along(NAMES)) {
[17:37:38.651]                   name <- added[[kk]]
[17:37:38.651]                   NAME <- NAMES[[kk]]
[17:37:38.651]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.651]                     next
[17:37:38.651]                   args[[name]] <- ""
[17:37:38.651]                 }
[17:37:38.651]                 NAMES <- toupper(removed)
[17:37:38.651]                 for (kk in seq_along(NAMES)) {
[17:37:38.651]                   name <- removed[[kk]]
[17:37:38.651]                   NAME <- NAMES[[kk]]
[17:37:38.651]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.651]                     next
[17:37:38.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.651]                 }
[17:37:38.651]                 if (length(args) > 0) 
[17:37:38.651]                   base::do.call(base::Sys.setenv, args = args)
[17:37:38.651]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:38.651]             }
[17:37:38.651]             else {
[17:37:38.651]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:38.651]             }
[17:37:38.651]             {
[17:37:38.651]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:38.651]                   0L) {
[17:37:38.651]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:38.651]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:38.651]                   base::options(opts)
[17:37:38.651]                 }
[17:37:38.651]                 {
[17:37:38.651]                   {
[17:37:38.651]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:38.651]                     NULL
[17:37:38.651]                   }
[17:37:38.651]                   options(future.plan = NULL)
[17:37:38.651]                   if (is.na(NA_character_)) 
[17:37:38.651]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.651]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:38.651]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:38.651]                     .init = FALSE)
[17:37:38.651]                 }
[17:37:38.651]             }
[17:37:38.651]         }
[17:37:38.651]     })
[17:37:38.651]     if (TRUE) {
[17:37:38.651]         base::sink(type = "output", split = FALSE)
[17:37:38.651]         if (TRUE) {
[17:37:38.651]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:38.651]         }
[17:37:38.651]         else {
[17:37:38.651]             ...future.result["stdout"] <- base::list(NULL)
[17:37:38.651]         }
[17:37:38.651]         base::close(...future.stdout)
[17:37:38.651]         ...future.stdout <- NULL
[17:37:38.651]     }
[17:37:38.651]     ...future.result$conditions <- ...future.conditions
[17:37:38.651]     ...future.result$finished <- base::Sys.time()
[17:37:38.651]     ...future.result
[17:37:38.651] }
[17:37:38.654] Exporting 5 global objects (224 bytes) to cluster node #1 ...
[17:37:38.654] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[17:37:38.655] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[17:37:38.655] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[17:37:38.655] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[17:37:38.655] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:37:38.656] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:37:38.656] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:38.656] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:38.656] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:38.657] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:38.657] Exporting 5 global objects (224 bytes) to cluster node #1 ... DONE
[17:37:38.657] MultisessionFuture started
[17:37:38.658] - Launch lazy future ... done
[17:37:38.658] run() for ‘MultisessionFuture’ ... done
[17:37:38.658] Created future:
[17:37:38.658] MultisessionFuture:
[17:37:38.658] Label: ‘future_mapply-1’
[17:37:38.658] Expression:
[17:37:38.658] {
[17:37:38.658]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.658]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:38.658]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.658]         on.exit(options(oopts), add = TRUE)
[17:37:38.658]     }
[17:37:38.658]     {
[17:37:38.658]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.658]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:38.658]         do.call(mapply, args = args)
[17:37:38.658]     }
[17:37:38.658] }
[17:37:38.658] Lazy evaluation: FALSE
[17:37:38.658] Asynchronous evaluation: TRUE
[17:37:38.658] Local evaluation: TRUE
[17:37:38.658] Environment: R_GlobalEnv
[17:37:38.658] Capture standard output: TRUE
[17:37:38.658] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:38.658] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:38.658] Packages: <none>
[17:37:38.658] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:38.658] Resolved: FALSE
[17:37:38.658] Value: <not collected>
[17:37:38.658] Conditions captured: <none>
[17:37:38.658] Early signaling: FALSE
[17:37:38.658] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:38.658] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.669] Chunk #1 of 2 ... DONE
[17:37:38.669] Chunk #2 of 2 ...
[17:37:38.670]  - Finding globals in '...' for chunk #2 ...
[17:37:38.670] getGlobalsAndPackages() ...
[17:37:38.670] Searching for globals...
[17:37:38.670] 
[17:37:38.670] Searching for globals ... DONE
[17:37:38.670] - globals: [0] <none>
[17:37:38.670] getGlobalsAndPackages() ... DONE
[17:37:38.670]    + additional globals found: [n=0] 
[17:37:38.671]    + additional namespaces needed: [n=0] 
[17:37:38.671]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:38.671]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:38.671]  - seeds: <none>
[17:37:38.671]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.671] getGlobalsAndPackages() ...
[17:37:38.671] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.671] Resolving globals: FALSE
[17:37:38.672] The total size of the 5 globals is 224 bytes (224 bytes)
[17:37:38.672] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:37:38.672] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.672] 
[17:37:38.673] getGlobalsAndPackages() ... DONE
[17:37:38.673] run() for ‘Future’ ...
[17:37:38.673] - state: ‘created’
[17:37:38.673] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:38.686] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.686] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:38.687]   - Field: ‘node’
[17:37:38.687]   - Field: ‘label’
[17:37:38.687]   - Field: ‘local’
[17:37:38.687]   - Field: ‘owner’
[17:37:38.687]   - Field: ‘envir’
[17:37:38.687]   - Field: ‘workers’
[17:37:38.687]   - Field: ‘packages’
[17:37:38.687]   - Field: ‘gc’
[17:37:38.687]   - Field: ‘conditions’
[17:37:38.687]   - Field: ‘persistent’
[17:37:38.688]   - Field: ‘expr’
[17:37:38.688]   - Field: ‘uuid’
[17:37:38.688]   - Field: ‘seed’
[17:37:38.688]   - Field: ‘version’
[17:37:38.688]   - Field: ‘result’
[17:37:38.688]   - Field: ‘asynchronous’
[17:37:38.688]   - Field: ‘calls’
[17:37:38.688]   - Field: ‘globals’
[17:37:38.688]   - Field: ‘stdout’
[17:37:38.688]   - Field: ‘earlySignal’
[17:37:38.688]   - Field: ‘lazy’
[17:37:38.688]   - Field: ‘state’
[17:37:38.689] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:38.689] - Launch lazy future ...
[17:37:38.689] Packages needed by the future expression (n = 0): <none>
[17:37:38.689] Packages needed by future strategies (n = 0): <none>
[17:37:38.689] {
[17:37:38.689]     {
[17:37:38.689]         {
[17:37:38.689]             ...future.startTime <- base::Sys.time()
[17:37:38.689]             {
[17:37:38.689]                 {
[17:37:38.689]                   {
[17:37:38.689]                     {
[17:37:38.689]                       base::local({
[17:37:38.689]                         has_future <- base::requireNamespace("future", 
[17:37:38.689]                           quietly = TRUE)
[17:37:38.689]                         if (has_future) {
[17:37:38.689]                           ns <- base::getNamespace("future")
[17:37:38.689]                           version <- ns[[".package"]][["version"]]
[17:37:38.689]                           if (is.null(version)) 
[17:37:38.689]                             version <- utils::packageVersion("future")
[17:37:38.689]                         }
[17:37:38.689]                         else {
[17:37:38.689]                           version <- NULL
[17:37:38.689]                         }
[17:37:38.689]                         if (!has_future || version < "1.8.0") {
[17:37:38.689]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:38.689]                             "", base::R.version$version.string), 
[17:37:38.689]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:38.689]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:38.689]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:38.689]                               "release", "version")], collapse = " "), 
[17:37:38.689]                             hostname = base::Sys.info()[["nodename"]])
[17:37:38.689]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:38.689]                             info)
[17:37:38.689]                           info <- base::paste(info, collapse = "; ")
[17:37:38.689]                           if (!has_future) {
[17:37:38.689]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:38.689]                               info)
[17:37:38.689]                           }
[17:37:38.689]                           else {
[17:37:38.689]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:38.689]                               info, version)
[17:37:38.689]                           }
[17:37:38.689]                           base::stop(msg)
[17:37:38.689]                         }
[17:37:38.689]                       })
[17:37:38.689]                     }
[17:37:38.689]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:38.689]                     base::options(mc.cores = 1L)
[17:37:38.689]                   }
[17:37:38.689]                   ...future.strategy.old <- future::plan("list")
[17:37:38.689]                   options(future.plan = NULL)
[17:37:38.689]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.689]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:38.689]                 }
[17:37:38.689]                 ...future.workdir <- getwd()
[17:37:38.689]             }
[17:37:38.689]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:38.689]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:38.689]         }
[17:37:38.689]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:38.689]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:38.689]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:38.689]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:38.689]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:38.689]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:38.689]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:38.689]             base::names(...future.oldOptions))
[17:37:38.689]     }
[17:37:38.689]     if (FALSE) {
[17:37:38.689]     }
[17:37:38.689]     else {
[17:37:38.689]         if (TRUE) {
[17:37:38.689]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:38.689]                 open = "w")
[17:37:38.689]         }
[17:37:38.689]         else {
[17:37:38.689]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:38.689]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:38.689]         }
[17:37:38.689]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:38.689]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:38.689]             base::sink(type = "output", split = FALSE)
[17:37:38.689]             base::close(...future.stdout)
[17:37:38.689]         }, add = TRUE)
[17:37:38.689]     }
[17:37:38.689]     ...future.frame <- base::sys.nframe()
[17:37:38.689]     ...future.conditions <- base::list()
[17:37:38.689]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:38.689]     if (FALSE) {
[17:37:38.689]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:38.689]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:38.689]     }
[17:37:38.689]     ...future.result <- base::tryCatch({
[17:37:38.689]         base::withCallingHandlers({
[17:37:38.689]             ...future.value <- base::withVisible(base::local({
[17:37:38.689]                 ...future.makeSendCondition <- base::local({
[17:37:38.689]                   sendCondition <- NULL
[17:37:38.689]                   function(frame = 1L) {
[17:37:38.689]                     if (is.function(sendCondition)) 
[17:37:38.689]                       return(sendCondition)
[17:37:38.689]                     ns <- getNamespace("parallel")
[17:37:38.689]                     if (exists("sendData", mode = "function", 
[17:37:38.689]                       envir = ns)) {
[17:37:38.689]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:38.689]                         envir = ns)
[17:37:38.689]                       envir <- sys.frame(frame)
[17:37:38.689]                       master <- NULL
[17:37:38.689]                       while (!identical(envir, .GlobalEnv) && 
[17:37:38.689]                         !identical(envir, emptyenv())) {
[17:37:38.689]                         if (exists("master", mode = "list", envir = envir, 
[17:37:38.689]                           inherits = FALSE)) {
[17:37:38.689]                           master <- get("master", mode = "list", 
[17:37:38.689]                             envir = envir, inherits = FALSE)
[17:37:38.689]                           if (inherits(master, c("SOCKnode", 
[17:37:38.689]                             "SOCK0node"))) {
[17:37:38.689]                             sendCondition <<- function(cond) {
[17:37:38.689]                               data <- list(type = "VALUE", value = cond, 
[17:37:38.689]                                 success = TRUE)
[17:37:38.689]                               parallel_sendData(master, data)
[17:37:38.689]                             }
[17:37:38.689]                             return(sendCondition)
[17:37:38.689]                           }
[17:37:38.689]                         }
[17:37:38.689]                         frame <- frame + 1L
[17:37:38.689]                         envir <- sys.frame(frame)
[17:37:38.689]                       }
[17:37:38.689]                     }
[17:37:38.689]                     sendCondition <<- function(cond) NULL
[17:37:38.689]                   }
[17:37:38.689]                 })
[17:37:38.689]                 withCallingHandlers({
[17:37:38.689]                   {
[17:37:38.689]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.689]                     if (!identical(...future.globals.maxSize.org, 
[17:37:38.689]                       ...future.globals.maxSize)) {
[17:37:38.689]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.689]                       on.exit(options(oopts), add = TRUE)
[17:37:38.689]                     }
[17:37:38.689]                     {
[17:37:38.689]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.689]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:38.689]                         USE.NAMES = FALSE)
[17:37:38.689]                       do.call(mapply, args = args)
[17:37:38.689]                     }
[17:37:38.689]                   }
[17:37:38.689]                 }, immediateCondition = function(cond) {
[17:37:38.689]                   sendCondition <- ...future.makeSendCondition()
[17:37:38.689]                   sendCondition(cond)
[17:37:38.689]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.689]                   {
[17:37:38.689]                     inherits <- base::inherits
[17:37:38.689]                     invokeRestart <- base::invokeRestart
[17:37:38.689]                     is.null <- base::is.null
[17:37:38.689]                     muffled <- FALSE
[17:37:38.689]                     if (inherits(cond, "message")) {
[17:37:38.689]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:38.689]                       if (muffled) 
[17:37:38.689]                         invokeRestart("muffleMessage")
[17:37:38.689]                     }
[17:37:38.689]                     else if (inherits(cond, "warning")) {
[17:37:38.689]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:38.689]                       if (muffled) 
[17:37:38.689]                         invokeRestart("muffleWarning")
[17:37:38.689]                     }
[17:37:38.689]                     else if (inherits(cond, "condition")) {
[17:37:38.689]                       if (!is.null(pattern)) {
[17:37:38.689]                         computeRestarts <- base::computeRestarts
[17:37:38.689]                         grepl <- base::grepl
[17:37:38.689]                         restarts <- computeRestarts(cond)
[17:37:38.689]                         for (restart in restarts) {
[17:37:38.689]                           name <- restart$name
[17:37:38.689]                           if (is.null(name)) 
[17:37:38.689]                             next
[17:37:38.689]                           if (!grepl(pattern, name)) 
[17:37:38.689]                             next
[17:37:38.689]                           invokeRestart(restart)
[17:37:38.689]                           muffled <- TRUE
[17:37:38.689]                           break
[17:37:38.689]                         }
[17:37:38.689]                       }
[17:37:38.689]                     }
[17:37:38.689]                     invisible(muffled)
[17:37:38.689]                   }
[17:37:38.689]                   muffleCondition(cond)
[17:37:38.689]                 })
[17:37:38.689]             }))
[17:37:38.689]             future::FutureResult(value = ...future.value$value, 
[17:37:38.689]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.689]                   ...future.rng), globalenv = if (FALSE) 
[17:37:38.689]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:38.689]                     ...future.globalenv.names))
[17:37:38.689]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:38.689]         }, condition = base::local({
[17:37:38.689]             c <- base::c
[17:37:38.689]             inherits <- base::inherits
[17:37:38.689]             invokeRestart <- base::invokeRestart
[17:37:38.689]             length <- base::length
[17:37:38.689]             list <- base::list
[17:37:38.689]             seq.int <- base::seq.int
[17:37:38.689]             signalCondition <- base::signalCondition
[17:37:38.689]             sys.calls <- base::sys.calls
[17:37:38.689]             `[[` <- base::`[[`
[17:37:38.689]             `+` <- base::`+`
[17:37:38.689]             `<<-` <- base::`<<-`
[17:37:38.689]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:38.689]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:38.689]                   3L)]
[17:37:38.689]             }
[17:37:38.689]             function(cond) {
[17:37:38.689]                 is_error <- inherits(cond, "error")
[17:37:38.689]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:38.689]                   NULL)
[17:37:38.689]                 if (is_error) {
[17:37:38.689]                   sessionInformation <- function() {
[17:37:38.689]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:38.689]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:38.689]                       search = base::search(), system = base::Sys.info())
[17:37:38.689]                   }
[17:37:38.689]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.689]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:38.689]                     cond$call), session = sessionInformation(), 
[17:37:38.689]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:38.689]                   signalCondition(cond)
[17:37:38.689]                 }
[17:37:38.689]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:38.689]                 "immediateCondition"))) {
[17:37:38.689]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:38.689]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.689]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:38.689]                   if (TRUE && !signal) {
[17:37:38.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.689]                     {
[17:37:38.689]                       inherits <- base::inherits
[17:37:38.689]                       invokeRestart <- base::invokeRestart
[17:37:38.689]                       is.null <- base::is.null
[17:37:38.689]                       muffled <- FALSE
[17:37:38.689]                       if (inherits(cond, "message")) {
[17:37:38.689]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.689]                         if (muffled) 
[17:37:38.689]                           invokeRestart("muffleMessage")
[17:37:38.689]                       }
[17:37:38.689]                       else if (inherits(cond, "warning")) {
[17:37:38.689]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.689]                         if (muffled) 
[17:37:38.689]                           invokeRestart("muffleWarning")
[17:37:38.689]                       }
[17:37:38.689]                       else if (inherits(cond, "condition")) {
[17:37:38.689]                         if (!is.null(pattern)) {
[17:37:38.689]                           computeRestarts <- base::computeRestarts
[17:37:38.689]                           grepl <- base::grepl
[17:37:38.689]                           restarts <- computeRestarts(cond)
[17:37:38.689]                           for (restart in restarts) {
[17:37:38.689]                             name <- restart$name
[17:37:38.689]                             if (is.null(name)) 
[17:37:38.689]                               next
[17:37:38.689]                             if (!grepl(pattern, name)) 
[17:37:38.689]                               next
[17:37:38.689]                             invokeRestart(restart)
[17:37:38.689]                             muffled <- TRUE
[17:37:38.689]                             break
[17:37:38.689]                           }
[17:37:38.689]                         }
[17:37:38.689]                       }
[17:37:38.689]                       invisible(muffled)
[17:37:38.689]                     }
[17:37:38.689]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.689]                   }
[17:37:38.689]                 }
[17:37:38.689]                 else {
[17:37:38.689]                   if (TRUE) {
[17:37:38.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.689]                     {
[17:37:38.689]                       inherits <- base::inherits
[17:37:38.689]                       invokeRestart <- base::invokeRestart
[17:37:38.689]                       is.null <- base::is.null
[17:37:38.689]                       muffled <- FALSE
[17:37:38.689]                       if (inherits(cond, "message")) {
[17:37:38.689]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.689]                         if (muffled) 
[17:37:38.689]                           invokeRestart("muffleMessage")
[17:37:38.689]                       }
[17:37:38.689]                       else if (inherits(cond, "warning")) {
[17:37:38.689]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.689]                         if (muffled) 
[17:37:38.689]                           invokeRestart("muffleWarning")
[17:37:38.689]                       }
[17:37:38.689]                       else if (inherits(cond, "condition")) {
[17:37:38.689]                         if (!is.null(pattern)) {
[17:37:38.689]                           computeRestarts <- base::computeRestarts
[17:37:38.689]                           grepl <- base::grepl
[17:37:38.689]                           restarts <- computeRestarts(cond)
[17:37:38.689]                           for (restart in restarts) {
[17:37:38.689]                             name <- restart$name
[17:37:38.689]                             if (is.null(name)) 
[17:37:38.689]                               next
[17:37:38.689]                             if (!grepl(pattern, name)) 
[17:37:38.689]                               next
[17:37:38.689]                             invokeRestart(restart)
[17:37:38.689]                             muffled <- TRUE
[17:37:38.689]                             break
[17:37:38.689]                           }
[17:37:38.689]                         }
[17:37:38.689]                       }
[17:37:38.689]                       invisible(muffled)
[17:37:38.689]                     }
[17:37:38.689]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.689]                   }
[17:37:38.689]                 }
[17:37:38.689]             }
[17:37:38.689]         }))
[17:37:38.689]     }, error = function(ex) {
[17:37:38.689]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:38.689]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.689]                 ...future.rng), started = ...future.startTime, 
[17:37:38.689]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:38.689]             version = "1.8"), class = "FutureResult")
[17:37:38.689]     }, finally = {
[17:37:38.689]         if (!identical(...future.workdir, getwd())) 
[17:37:38.689]             setwd(...future.workdir)
[17:37:38.689]         {
[17:37:38.689]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:38.689]                 ...future.oldOptions$nwarnings <- NULL
[17:37:38.689]             }
[17:37:38.689]             base::options(...future.oldOptions)
[17:37:38.689]             if (.Platform$OS.type == "windows") {
[17:37:38.689]                 old_names <- names(...future.oldEnvVars)
[17:37:38.689]                 envs <- base::Sys.getenv()
[17:37:38.689]                 names <- names(envs)
[17:37:38.689]                 common <- intersect(names, old_names)
[17:37:38.689]                 added <- setdiff(names, old_names)
[17:37:38.689]                 removed <- setdiff(old_names, names)
[17:37:38.689]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:38.689]                   envs[common]]
[17:37:38.689]                 NAMES <- toupper(changed)
[17:37:38.689]                 args <- list()
[17:37:38.689]                 for (kk in seq_along(NAMES)) {
[17:37:38.689]                   name <- changed[[kk]]
[17:37:38.689]                   NAME <- NAMES[[kk]]
[17:37:38.689]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.689]                     next
[17:37:38.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.689]                 }
[17:37:38.689]                 NAMES <- toupper(added)
[17:37:38.689]                 for (kk in seq_along(NAMES)) {
[17:37:38.689]                   name <- added[[kk]]
[17:37:38.689]                   NAME <- NAMES[[kk]]
[17:37:38.689]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.689]                     next
[17:37:38.689]                   args[[name]] <- ""
[17:37:38.689]                 }
[17:37:38.689]                 NAMES <- toupper(removed)
[17:37:38.689]                 for (kk in seq_along(NAMES)) {
[17:37:38.689]                   name <- removed[[kk]]
[17:37:38.689]                   NAME <- NAMES[[kk]]
[17:37:38.689]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.689]                     next
[17:37:38.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.689]                 }
[17:37:38.689]                 if (length(args) > 0) 
[17:37:38.689]                   base::do.call(base::Sys.setenv, args = args)
[17:37:38.689]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:38.689]             }
[17:37:38.689]             else {
[17:37:38.689]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:38.689]             }
[17:37:38.689]             {
[17:37:38.689]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:38.689]                   0L) {
[17:37:38.689]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:38.689]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:38.689]                   base::options(opts)
[17:37:38.689]                 }
[17:37:38.689]                 {
[17:37:38.689]                   {
[17:37:38.689]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:38.689]                     NULL
[17:37:38.689]                   }
[17:37:38.689]                   options(future.plan = NULL)
[17:37:38.689]                   if (is.na(NA_character_)) 
[17:37:38.689]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.689]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:38.689]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:38.689]                     .init = FALSE)
[17:37:38.689]                 }
[17:37:38.689]             }
[17:37:38.689]         }
[17:37:38.689]     })
[17:37:38.689]     if (TRUE) {
[17:37:38.689]         base::sink(type = "output", split = FALSE)
[17:37:38.689]         if (TRUE) {
[17:37:38.689]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:38.689]         }
[17:37:38.689]         else {
[17:37:38.689]             ...future.result["stdout"] <- base::list(NULL)
[17:37:38.689]         }
[17:37:38.689]         base::close(...future.stdout)
[17:37:38.689]         ...future.stdout <- NULL
[17:37:38.689]     }
[17:37:38.689]     ...future.result$conditions <- ...future.conditions
[17:37:38.689]     ...future.result$finished <- base::Sys.time()
[17:37:38.689]     ...future.result
[17:37:38.689] }
[17:37:38.692] Exporting 5 global objects (224 bytes) to cluster node #2 ...
[17:37:38.692] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[17:37:38.693] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[17:37:38.693] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[17:37:38.693] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[17:37:38.693] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:37:38.693] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:37:38.694] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:37:38.694] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:37:38.694] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:37:38.694] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:37:38.694] Exporting 5 global objects (224 bytes) to cluster node #2 ... DONE
[17:37:38.695] MultisessionFuture started
[17:37:38.695] - Launch lazy future ... done
[17:37:38.695] run() for ‘MultisessionFuture’ ... done
[17:37:38.695] Created future:
[17:37:38.695] MultisessionFuture:
[17:37:38.695] Label: ‘future_mapply-2’
[17:37:38.695] Expression:
[17:37:38.695] {
[17:37:38.695]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.695]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:38.695]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.695]         on.exit(options(oopts), add = TRUE)
[17:37:38.695]     }
[17:37:38.695]     {
[17:37:38.695]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.695]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:38.695]         do.call(mapply, args = args)
[17:37:38.695]     }
[17:37:38.695] }
[17:37:38.695] Lazy evaluation: FALSE
[17:37:38.695] Asynchronous evaluation: TRUE
[17:37:38.695] Local evaluation: TRUE
[17:37:38.695] Environment: R_GlobalEnv
[17:37:38.695] Capture standard output: TRUE
[17:37:38.695] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:38.695] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:38.695] Packages: <none>
[17:37:38.695] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:38.695] Resolved: FALSE
[17:37:38.695] Value: <not collected>
[17:37:38.695] Conditions captured: <none>
[17:37:38.695] Early signaling: FALSE
[17:37:38.695] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:38.695] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.707] Chunk #2 of 2 ... DONE
[17:37:38.707] Launching 2 futures (chunks) ... DONE
[17:37:38.707] Resolving 2 futures (chunks) ...
[17:37:38.707] resolve() on list ...
[17:37:38.707]  recursive: 0
[17:37:38.707]  length: 2
[17:37:38.707] 
[17:37:38.708] receiveMessageFromWorker() for ClusterFuture ...
[17:37:38.708] - Validating connection of MultisessionFuture
[17:37:38.708] - received message: FutureResult
[17:37:38.708] - Received FutureResult
[17:37:38.708] - Erased future from FutureRegistry
[17:37:38.708] result() for ClusterFuture ...
[17:37:38.708] - result already collected: FutureResult
[17:37:38.709] result() for ClusterFuture ... done
[17:37:38.709] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:38.709] Future #1
[17:37:38.709] result() for ClusterFuture ...
[17:37:38.709] - result already collected: FutureResult
[17:37:38.709] result() for ClusterFuture ... done
[17:37:38.709] result() for ClusterFuture ...
[17:37:38.709] - result already collected: FutureResult
[17:37:38.709] result() for ClusterFuture ... done
[17:37:38.709] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:37:38.709] - nx: 2
[17:37:38.710] - relay: TRUE
[17:37:38.710] - stdout: TRUE
[17:37:38.710] - signal: TRUE
[17:37:38.710] - resignal: FALSE
[17:37:38.710] - force: TRUE
[17:37:38.710] - relayed: [n=2] FALSE, FALSE
[17:37:38.710] - queued futures: [n=2] FALSE, FALSE
[17:37:38.710]  - until=1
[17:37:38.710]  - relaying element #1
[17:37:38.710] result() for ClusterFuture ...
[17:37:38.710] - result already collected: FutureResult
[17:37:38.710] result() for ClusterFuture ... done
[17:37:38.711] result() for ClusterFuture ...
[17:37:38.711] - result already collected: FutureResult
[17:37:38.711] result() for ClusterFuture ... done
[17:37:38.711] result() for ClusterFuture ...
[17:37:38.711] - result already collected: FutureResult
[17:37:38.711] result() for ClusterFuture ... done
[17:37:38.711] result() for ClusterFuture ...
[17:37:38.711] - result already collected: FutureResult
[17:37:38.711] result() for ClusterFuture ... done
[17:37:38.711] - relayed: [n=2] TRUE, FALSE
[17:37:38.711] - queued futures: [n=2] TRUE, FALSE
[17:37:38.711] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:37:38.712]  length: 1 (resolved future 1)
[17:37:38.738] receiveMessageFromWorker() for ClusterFuture ...
[17:37:38.738] - Validating connection of MultisessionFuture
[17:37:38.738] - received message: FutureResult
[17:37:38.738] - Received FutureResult
[17:37:38.738] - Erased future from FutureRegistry
[17:37:38.739] result() for ClusterFuture ...
[17:37:38.739] - result already collected: FutureResult
[17:37:38.739] result() for ClusterFuture ... done
[17:37:38.739] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:38.739] Future #2
[17:37:38.739] result() for ClusterFuture ...
[17:37:38.739] - result already collected: FutureResult
[17:37:38.739] result() for ClusterFuture ... done
[17:37:38.739] result() for ClusterFuture ...
[17:37:38.739] - result already collected: FutureResult
[17:37:38.740] result() for ClusterFuture ... done
[17:37:38.740] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:37:38.740] - nx: 2
[17:37:38.740] - relay: TRUE
[17:37:38.740] - stdout: TRUE
[17:37:38.740] - signal: TRUE
[17:37:38.740] - resignal: FALSE
[17:37:38.740] - force: TRUE
[17:37:38.740] - relayed: [n=2] TRUE, FALSE
[17:37:38.740] - queued futures: [n=2] TRUE, FALSE
[17:37:38.741]  - until=2
[17:37:38.741]  - relaying element #2
[17:37:38.741] result() for ClusterFuture ...
[17:37:38.741] - result already collected: FutureResult
[17:37:38.741] result() for ClusterFuture ... done
[17:37:38.741] result() for ClusterFuture ...
[17:37:38.741] - result already collected: FutureResult
[17:37:38.741] result() for ClusterFuture ... done
[17:37:38.741] result() for ClusterFuture ...
[17:37:38.741] - result already collected: FutureResult
[17:37:38.741] result() for ClusterFuture ... done
[17:37:38.741] result() for ClusterFuture ...
[17:37:38.742] - result already collected: FutureResult
[17:37:38.742] result() for ClusterFuture ... done
[17:37:38.742] - relayed: [n=2] TRUE, TRUE
[17:37:38.742] - queued futures: [n=2] TRUE, TRUE
[17:37:38.742] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:37:38.742]  length: 0 (resolved future 2)
[17:37:38.742] Relaying remaining futures
[17:37:38.742] signalConditionsASAP(NULL, pos=0) ...
[17:37:38.742] - nx: 2
[17:37:38.742] - relay: TRUE
[17:37:38.742] - stdout: TRUE
[17:37:38.742] - signal: TRUE
[17:37:38.743] - resignal: FALSE
[17:37:38.743] - force: TRUE
[17:37:38.743] - relayed: [n=2] TRUE, TRUE
[17:37:38.743] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:38.743] - relayed: [n=2] TRUE, TRUE
[17:37:38.743] - queued futures: [n=2] TRUE, TRUE
[17:37:38.743] signalConditionsASAP(NULL, pos=0) ... done
[17:37:38.743] resolve() on list ... DONE
[17:37:38.743] result() for ClusterFuture ...
[17:37:38.743] - result already collected: FutureResult
[17:37:38.743] result() for ClusterFuture ... done
[17:37:38.744] result() for ClusterFuture ...
[17:37:38.744] - result already collected: FutureResult
[17:37:38.744] result() for ClusterFuture ... done
[17:37:38.744] result() for ClusterFuture ...
[17:37:38.744] - result already collected: FutureResult
[17:37:38.744] result() for ClusterFuture ... done
[17:37:38.744] result() for ClusterFuture ...
[17:37:38.744] - result already collected: FutureResult
[17:37:38.744] result() for ClusterFuture ... done
[17:37:38.744]  - Number of value chunks collected: 2
[17:37:38.744] Resolving 2 futures (chunks) ... DONE
[17:37:38.745] Reducing values from 2 chunks ...
[17:37:38.745]  - Number of values collected after concatenation: 4
[17:37:38.745]  - Number of values expected: 4
[17:37:38.745] Reducing values from 2 chunks ... DONE
[17:37:38.745] future_mapply() ... DONE
[17:37:38.745] future_mapply() ...
[17:37:38.749] Number of chunks: 2
[17:37:38.749] getGlobalsAndPackagesXApply() ...
[17:37:38.749]  - future.globals: TRUE
[17:37:38.749] getGlobalsAndPackages() ...
[17:37:38.749] Searching for globals...
[17:37:38.751] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[17:37:38.751] Searching for globals ... DONE
[17:37:38.751] Resolving globals: FALSE
[17:37:38.751] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[17:37:38.752] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[17:37:38.752] - globals: [1] ‘FUN’
[17:37:38.752] 
[17:37:38.752] getGlobalsAndPackages() ... DONE
[17:37:38.752]  - globals found/used: [n=1] ‘FUN’
[17:37:38.754]  - needed namespaces: [n=0] 
[17:37:38.754] Finding globals ... DONE
[17:37:38.754] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:38.754] List of 2
[17:37:38.754]  $ ...future.FUN:function (x, y)  
[17:37:38.754]  $ MoreArgs     : NULL
[17:37:38.754]  - attr(*, "where")=List of 2
[17:37:38.754]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:38.754]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:38.754]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:38.754]  - attr(*, "resolved")= logi FALSE
[17:37:38.754]  - attr(*, "total_size")= num NA
[17:37:38.757] Packages to be attached in all futures: [n=0] 
[17:37:38.757] getGlobalsAndPackagesXApply() ... DONE
[17:37:38.757] Number of futures (= number of chunks): 2
[17:37:38.757] Launching 2 futures (chunks) ...
[17:37:38.757] Chunk #1 of 2 ...
[17:37:38.757]  - Finding globals in '...' for chunk #1 ...
[17:37:38.757] getGlobalsAndPackages() ...
[17:37:38.758] Searching for globals...
[17:37:38.758] 
[17:37:38.758] Searching for globals ... DONE
[17:37:38.758] - globals: [0] <none>
[17:37:38.758] getGlobalsAndPackages() ... DONE
[17:37:38.758]    + additional globals found: [n=0] 
[17:37:38.758]    + additional namespaces needed: [n=0] 
[17:37:38.758]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:38.758]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:38.759]  - seeds: <none>
[17:37:38.759]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.759] getGlobalsAndPackages() ...
[17:37:38.759] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.759] Resolving globals: FALSE
[17:37:38.759] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[17:37:38.760] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:38.760] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.760] 
[17:37:38.760] getGlobalsAndPackages() ... DONE
[17:37:38.760] run() for ‘Future’ ...
[17:37:38.761] - state: ‘created’
[17:37:38.761] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:38.774] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.774] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:38.775]   - Field: ‘node’
[17:37:38.775]   - Field: ‘label’
[17:37:38.775]   - Field: ‘local’
[17:37:38.775]   - Field: ‘owner’
[17:37:38.775]   - Field: ‘envir’
[17:37:38.775]   - Field: ‘workers’
[17:37:38.775]   - Field: ‘packages’
[17:37:38.775]   - Field: ‘gc’
[17:37:38.775]   - Field: ‘conditions’
[17:37:38.775]   - Field: ‘persistent’
[17:37:38.775]   - Field: ‘expr’
[17:37:38.775]   - Field: ‘uuid’
[17:37:38.776]   - Field: ‘seed’
[17:37:38.776]   - Field: ‘version’
[17:37:38.776]   - Field: ‘result’
[17:37:38.776]   - Field: ‘asynchronous’
[17:37:38.776]   - Field: ‘calls’
[17:37:38.776]   - Field: ‘globals’
[17:37:38.776]   - Field: ‘stdout’
[17:37:38.776]   - Field: ‘earlySignal’
[17:37:38.776]   - Field: ‘lazy’
[17:37:38.776]   - Field: ‘state’
[17:37:38.776] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:38.777] - Launch lazy future ...
[17:37:38.777] Packages needed by the future expression (n = 0): <none>
[17:37:38.777] Packages needed by future strategies (n = 0): <none>
[17:37:38.777] {
[17:37:38.777]     {
[17:37:38.777]         {
[17:37:38.777]             ...future.startTime <- base::Sys.time()
[17:37:38.777]             {
[17:37:38.777]                 {
[17:37:38.777]                   {
[17:37:38.777]                     {
[17:37:38.777]                       base::local({
[17:37:38.777]                         has_future <- base::requireNamespace("future", 
[17:37:38.777]                           quietly = TRUE)
[17:37:38.777]                         if (has_future) {
[17:37:38.777]                           ns <- base::getNamespace("future")
[17:37:38.777]                           version <- ns[[".package"]][["version"]]
[17:37:38.777]                           if (is.null(version)) 
[17:37:38.777]                             version <- utils::packageVersion("future")
[17:37:38.777]                         }
[17:37:38.777]                         else {
[17:37:38.777]                           version <- NULL
[17:37:38.777]                         }
[17:37:38.777]                         if (!has_future || version < "1.8.0") {
[17:37:38.777]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:38.777]                             "", base::R.version$version.string), 
[17:37:38.777]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:38.777]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:38.777]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:38.777]                               "release", "version")], collapse = " "), 
[17:37:38.777]                             hostname = base::Sys.info()[["nodename"]])
[17:37:38.777]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:38.777]                             info)
[17:37:38.777]                           info <- base::paste(info, collapse = "; ")
[17:37:38.777]                           if (!has_future) {
[17:37:38.777]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:38.777]                               info)
[17:37:38.777]                           }
[17:37:38.777]                           else {
[17:37:38.777]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:38.777]                               info, version)
[17:37:38.777]                           }
[17:37:38.777]                           base::stop(msg)
[17:37:38.777]                         }
[17:37:38.777]                       })
[17:37:38.777]                     }
[17:37:38.777]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:38.777]                     base::options(mc.cores = 1L)
[17:37:38.777]                   }
[17:37:38.777]                   ...future.strategy.old <- future::plan("list")
[17:37:38.777]                   options(future.plan = NULL)
[17:37:38.777]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.777]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:38.777]                 }
[17:37:38.777]                 ...future.workdir <- getwd()
[17:37:38.777]             }
[17:37:38.777]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:38.777]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:38.777]         }
[17:37:38.777]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:38.777]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:38.777]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:38.777]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:38.777]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:38.777]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:38.777]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:38.777]             base::names(...future.oldOptions))
[17:37:38.777]     }
[17:37:38.777]     if (FALSE) {
[17:37:38.777]     }
[17:37:38.777]     else {
[17:37:38.777]         if (TRUE) {
[17:37:38.777]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:38.777]                 open = "w")
[17:37:38.777]         }
[17:37:38.777]         else {
[17:37:38.777]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:38.777]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:38.777]         }
[17:37:38.777]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:38.777]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:38.777]             base::sink(type = "output", split = FALSE)
[17:37:38.777]             base::close(...future.stdout)
[17:37:38.777]         }, add = TRUE)
[17:37:38.777]     }
[17:37:38.777]     ...future.frame <- base::sys.nframe()
[17:37:38.777]     ...future.conditions <- base::list()
[17:37:38.777]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:38.777]     if (FALSE) {
[17:37:38.777]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:38.777]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:38.777]     }
[17:37:38.777]     ...future.result <- base::tryCatch({
[17:37:38.777]         base::withCallingHandlers({
[17:37:38.777]             ...future.value <- base::withVisible(base::local({
[17:37:38.777]                 ...future.makeSendCondition <- base::local({
[17:37:38.777]                   sendCondition <- NULL
[17:37:38.777]                   function(frame = 1L) {
[17:37:38.777]                     if (is.function(sendCondition)) 
[17:37:38.777]                       return(sendCondition)
[17:37:38.777]                     ns <- getNamespace("parallel")
[17:37:38.777]                     if (exists("sendData", mode = "function", 
[17:37:38.777]                       envir = ns)) {
[17:37:38.777]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:38.777]                         envir = ns)
[17:37:38.777]                       envir <- sys.frame(frame)
[17:37:38.777]                       master <- NULL
[17:37:38.777]                       while (!identical(envir, .GlobalEnv) && 
[17:37:38.777]                         !identical(envir, emptyenv())) {
[17:37:38.777]                         if (exists("master", mode = "list", envir = envir, 
[17:37:38.777]                           inherits = FALSE)) {
[17:37:38.777]                           master <- get("master", mode = "list", 
[17:37:38.777]                             envir = envir, inherits = FALSE)
[17:37:38.777]                           if (inherits(master, c("SOCKnode", 
[17:37:38.777]                             "SOCK0node"))) {
[17:37:38.777]                             sendCondition <<- function(cond) {
[17:37:38.777]                               data <- list(type = "VALUE", value = cond, 
[17:37:38.777]                                 success = TRUE)
[17:37:38.777]                               parallel_sendData(master, data)
[17:37:38.777]                             }
[17:37:38.777]                             return(sendCondition)
[17:37:38.777]                           }
[17:37:38.777]                         }
[17:37:38.777]                         frame <- frame + 1L
[17:37:38.777]                         envir <- sys.frame(frame)
[17:37:38.777]                       }
[17:37:38.777]                     }
[17:37:38.777]                     sendCondition <<- function(cond) NULL
[17:37:38.777]                   }
[17:37:38.777]                 })
[17:37:38.777]                 withCallingHandlers({
[17:37:38.777]                   {
[17:37:38.777]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.777]                     if (!identical(...future.globals.maxSize.org, 
[17:37:38.777]                       ...future.globals.maxSize)) {
[17:37:38.777]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.777]                       on.exit(options(oopts), add = TRUE)
[17:37:38.777]                     }
[17:37:38.777]                     {
[17:37:38.777]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.777]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:38.777]                         USE.NAMES = FALSE)
[17:37:38.777]                       do.call(mapply, args = args)
[17:37:38.777]                     }
[17:37:38.777]                   }
[17:37:38.777]                 }, immediateCondition = function(cond) {
[17:37:38.777]                   sendCondition <- ...future.makeSendCondition()
[17:37:38.777]                   sendCondition(cond)
[17:37:38.777]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.777]                   {
[17:37:38.777]                     inherits <- base::inherits
[17:37:38.777]                     invokeRestart <- base::invokeRestart
[17:37:38.777]                     is.null <- base::is.null
[17:37:38.777]                     muffled <- FALSE
[17:37:38.777]                     if (inherits(cond, "message")) {
[17:37:38.777]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:38.777]                       if (muffled) 
[17:37:38.777]                         invokeRestart("muffleMessage")
[17:37:38.777]                     }
[17:37:38.777]                     else if (inherits(cond, "warning")) {
[17:37:38.777]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:38.777]                       if (muffled) 
[17:37:38.777]                         invokeRestart("muffleWarning")
[17:37:38.777]                     }
[17:37:38.777]                     else if (inherits(cond, "condition")) {
[17:37:38.777]                       if (!is.null(pattern)) {
[17:37:38.777]                         computeRestarts <- base::computeRestarts
[17:37:38.777]                         grepl <- base::grepl
[17:37:38.777]                         restarts <- computeRestarts(cond)
[17:37:38.777]                         for (restart in restarts) {
[17:37:38.777]                           name <- restart$name
[17:37:38.777]                           if (is.null(name)) 
[17:37:38.777]                             next
[17:37:38.777]                           if (!grepl(pattern, name)) 
[17:37:38.777]                             next
[17:37:38.777]                           invokeRestart(restart)
[17:37:38.777]                           muffled <- TRUE
[17:37:38.777]                           break
[17:37:38.777]                         }
[17:37:38.777]                       }
[17:37:38.777]                     }
[17:37:38.777]                     invisible(muffled)
[17:37:38.777]                   }
[17:37:38.777]                   muffleCondition(cond)
[17:37:38.777]                 })
[17:37:38.777]             }))
[17:37:38.777]             future::FutureResult(value = ...future.value$value, 
[17:37:38.777]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.777]                   ...future.rng), globalenv = if (FALSE) 
[17:37:38.777]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:38.777]                     ...future.globalenv.names))
[17:37:38.777]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:38.777]         }, condition = base::local({
[17:37:38.777]             c <- base::c
[17:37:38.777]             inherits <- base::inherits
[17:37:38.777]             invokeRestart <- base::invokeRestart
[17:37:38.777]             length <- base::length
[17:37:38.777]             list <- base::list
[17:37:38.777]             seq.int <- base::seq.int
[17:37:38.777]             signalCondition <- base::signalCondition
[17:37:38.777]             sys.calls <- base::sys.calls
[17:37:38.777]             `[[` <- base::`[[`
[17:37:38.777]             `+` <- base::`+`
[17:37:38.777]             `<<-` <- base::`<<-`
[17:37:38.777]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:38.777]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:38.777]                   3L)]
[17:37:38.777]             }
[17:37:38.777]             function(cond) {
[17:37:38.777]                 is_error <- inherits(cond, "error")
[17:37:38.777]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:38.777]                   NULL)
[17:37:38.777]                 if (is_error) {
[17:37:38.777]                   sessionInformation <- function() {
[17:37:38.777]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:38.777]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:38.777]                       search = base::search(), system = base::Sys.info())
[17:37:38.777]                   }
[17:37:38.777]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.777]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:38.777]                     cond$call), session = sessionInformation(), 
[17:37:38.777]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:38.777]                   signalCondition(cond)
[17:37:38.777]                 }
[17:37:38.777]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:38.777]                 "immediateCondition"))) {
[17:37:38.777]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:38.777]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.777]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:38.777]                   if (TRUE && !signal) {
[17:37:38.777]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.777]                     {
[17:37:38.777]                       inherits <- base::inherits
[17:37:38.777]                       invokeRestart <- base::invokeRestart
[17:37:38.777]                       is.null <- base::is.null
[17:37:38.777]                       muffled <- FALSE
[17:37:38.777]                       if (inherits(cond, "message")) {
[17:37:38.777]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.777]                         if (muffled) 
[17:37:38.777]                           invokeRestart("muffleMessage")
[17:37:38.777]                       }
[17:37:38.777]                       else if (inherits(cond, "warning")) {
[17:37:38.777]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.777]                         if (muffled) 
[17:37:38.777]                           invokeRestart("muffleWarning")
[17:37:38.777]                       }
[17:37:38.777]                       else if (inherits(cond, "condition")) {
[17:37:38.777]                         if (!is.null(pattern)) {
[17:37:38.777]                           computeRestarts <- base::computeRestarts
[17:37:38.777]                           grepl <- base::grepl
[17:37:38.777]                           restarts <- computeRestarts(cond)
[17:37:38.777]                           for (restart in restarts) {
[17:37:38.777]                             name <- restart$name
[17:37:38.777]                             if (is.null(name)) 
[17:37:38.777]                               next
[17:37:38.777]                             if (!grepl(pattern, name)) 
[17:37:38.777]                               next
[17:37:38.777]                             invokeRestart(restart)
[17:37:38.777]                             muffled <- TRUE
[17:37:38.777]                             break
[17:37:38.777]                           }
[17:37:38.777]                         }
[17:37:38.777]                       }
[17:37:38.777]                       invisible(muffled)
[17:37:38.777]                     }
[17:37:38.777]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.777]                   }
[17:37:38.777]                 }
[17:37:38.777]                 else {
[17:37:38.777]                   if (TRUE) {
[17:37:38.777]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.777]                     {
[17:37:38.777]                       inherits <- base::inherits
[17:37:38.777]                       invokeRestart <- base::invokeRestart
[17:37:38.777]                       is.null <- base::is.null
[17:37:38.777]                       muffled <- FALSE
[17:37:38.777]                       if (inherits(cond, "message")) {
[17:37:38.777]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.777]                         if (muffled) 
[17:37:38.777]                           invokeRestart("muffleMessage")
[17:37:38.777]                       }
[17:37:38.777]                       else if (inherits(cond, "warning")) {
[17:37:38.777]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.777]                         if (muffled) 
[17:37:38.777]                           invokeRestart("muffleWarning")
[17:37:38.777]                       }
[17:37:38.777]                       else if (inherits(cond, "condition")) {
[17:37:38.777]                         if (!is.null(pattern)) {
[17:37:38.777]                           computeRestarts <- base::computeRestarts
[17:37:38.777]                           grepl <- base::grepl
[17:37:38.777]                           restarts <- computeRestarts(cond)
[17:37:38.777]                           for (restart in restarts) {
[17:37:38.777]                             name <- restart$name
[17:37:38.777]                             if (is.null(name)) 
[17:37:38.777]                               next
[17:37:38.777]                             if (!grepl(pattern, name)) 
[17:37:38.777]                               next
[17:37:38.777]                             invokeRestart(restart)
[17:37:38.777]                             muffled <- TRUE
[17:37:38.777]                             break
[17:37:38.777]                           }
[17:37:38.777]                         }
[17:37:38.777]                       }
[17:37:38.777]                       invisible(muffled)
[17:37:38.777]                     }
[17:37:38.777]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.777]                   }
[17:37:38.777]                 }
[17:37:38.777]             }
[17:37:38.777]         }))
[17:37:38.777]     }, error = function(ex) {
[17:37:38.777]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:38.777]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.777]                 ...future.rng), started = ...future.startTime, 
[17:37:38.777]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:38.777]             version = "1.8"), class = "FutureResult")
[17:37:38.777]     }, finally = {
[17:37:38.777]         if (!identical(...future.workdir, getwd())) 
[17:37:38.777]             setwd(...future.workdir)
[17:37:38.777]         {
[17:37:38.777]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:38.777]                 ...future.oldOptions$nwarnings <- NULL
[17:37:38.777]             }
[17:37:38.777]             base::options(...future.oldOptions)
[17:37:38.777]             if (.Platform$OS.type == "windows") {
[17:37:38.777]                 old_names <- names(...future.oldEnvVars)
[17:37:38.777]                 envs <- base::Sys.getenv()
[17:37:38.777]                 names <- names(envs)
[17:37:38.777]                 common <- intersect(names, old_names)
[17:37:38.777]                 added <- setdiff(names, old_names)
[17:37:38.777]                 removed <- setdiff(old_names, names)
[17:37:38.777]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:38.777]                   envs[common]]
[17:37:38.777]                 NAMES <- toupper(changed)
[17:37:38.777]                 args <- list()
[17:37:38.777]                 for (kk in seq_along(NAMES)) {
[17:37:38.777]                   name <- changed[[kk]]
[17:37:38.777]                   NAME <- NAMES[[kk]]
[17:37:38.777]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.777]                     next
[17:37:38.777]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.777]                 }
[17:37:38.777]                 NAMES <- toupper(added)
[17:37:38.777]                 for (kk in seq_along(NAMES)) {
[17:37:38.777]                   name <- added[[kk]]
[17:37:38.777]                   NAME <- NAMES[[kk]]
[17:37:38.777]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.777]                     next
[17:37:38.777]                   args[[name]] <- ""
[17:37:38.777]                 }
[17:37:38.777]                 NAMES <- toupper(removed)
[17:37:38.777]                 for (kk in seq_along(NAMES)) {
[17:37:38.777]                   name <- removed[[kk]]
[17:37:38.777]                   NAME <- NAMES[[kk]]
[17:37:38.777]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.777]                     next
[17:37:38.777]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.777]                 }
[17:37:38.777]                 if (length(args) > 0) 
[17:37:38.777]                   base::do.call(base::Sys.setenv, args = args)
[17:37:38.777]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:38.777]             }
[17:37:38.777]             else {
[17:37:38.777]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:38.777]             }
[17:37:38.777]             {
[17:37:38.777]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:38.777]                   0L) {
[17:37:38.777]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:38.777]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:38.777]                   base::options(opts)
[17:37:38.777]                 }
[17:37:38.777]                 {
[17:37:38.777]                   {
[17:37:38.777]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:38.777]                     NULL
[17:37:38.777]                   }
[17:37:38.777]                   options(future.plan = NULL)
[17:37:38.777]                   if (is.na(NA_character_)) 
[17:37:38.777]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.777]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:38.777]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:38.777]                     .init = FALSE)
[17:37:38.777]                 }
[17:37:38.777]             }
[17:37:38.777]         }
[17:37:38.777]     })
[17:37:38.777]     if (TRUE) {
[17:37:38.777]         base::sink(type = "output", split = FALSE)
[17:37:38.777]         if (TRUE) {
[17:37:38.777]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:38.777]         }
[17:37:38.777]         else {
[17:37:38.777]             ...future.result["stdout"] <- base::list(NULL)
[17:37:38.777]         }
[17:37:38.777]         base::close(...future.stdout)
[17:37:38.777]         ...future.stdout <- NULL
[17:37:38.777]     }
[17:37:38.777]     ...future.result$conditions <- ...future.conditions
[17:37:38.777]     ...future.result$finished <- base::Sys.time()
[17:37:38.777]     ...future.result
[17:37:38.777] }
[17:37:38.780] Exporting 5 global objects (2.04 KiB) to cluster node #1 ...
[17:37:38.780] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ...
[17:37:38.781] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ... DONE
[17:37:38.781] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:37:38.781] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:37:38.781] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:37:38.781] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:37:38.782] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:38.782] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:38.782] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:38.782] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:38.782] Exporting 5 global objects (2.04 KiB) to cluster node #1 ... DONE
[17:37:38.783] MultisessionFuture started
[17:37:38.783] - Launch lazy future ... done
[17:37:38.783] run() for ‘MultisessionFuture’ ... done
[17:37:38.783] Created future:
[17:37:38.783] MultisessionFuture:
[17:37:38.783] Label: ‘future_mapply-1’
[17:37:38.783] Expression:
[17:37:38.783] {
[17:37:38.783]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.783]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:38.783]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.783]         on.exit(options(oopts), add = TRUE)
[17:37:38.783]     }
[17:37:38.783]     {
[17:37:38.783]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.783]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:38.783]         do.call(mapply, args = args)
[17:37:38.783]     }
[17:37:38.783] }
[17:37:38.783] Lazy evaluation: FALSE
[17:37:38.783] Asynchronous evaluation: TRUE
[17:37:38.783] Local evaluation: TRUE
[17:37:38.783] Environment: R_GlobalEnv
[17:37:38.783] Capture standard output: TRUE
[17:37:38.783] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:38.783] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:38.783] Packages: <none>
[17:37:38.783] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:38.783] Resolved: FALSE
[17:37:38.783] Value: <not collected>
[17:37:38.783] Conditions captured: <none>
[17:37:38.783] Early signaling: FALSE
[17:37:38.783] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:38.783] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.795] Chunk #1 of 2 ... DONE
[17:37:38.795] Chunk #2 of 2 ...
[17:37:38.795]  - Finding globals in '...' for chunk #2 ...
[17:37:38.795] getGlobalsAndPackages() ...
[17:37:38.795] Searching for globals...
[17:37:38.795] 
[17:37:38.795] Searching for globals ... DONE
[17:37:38.795] - globals: [0] <none>
[17:37:38.796] getGlobalsAndPackages() ... DONE
[17:37:38.796]    + additional globals found: [n=0] 
[17:37:38.796]    + additional namespaces needed: [n=0] 
[17:37:38.796]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:38.796]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:38.796]  - seeds: <none>
[17:37:38.796]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.796] getGlobalsAndPackages() ...
[17:37:38.796] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.796] Resolving globals: FALSE
[17:37:38.797] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[17:37:38.797] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:38.797] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.798] 
[17:37:38.798] getGlobalsAndPackages() ... DONE
[17:37:38.798] run() for ‘Future’ ...
[17:37:38.798] - state: ‘created’
[17:37:38.798] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:38.812] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.812] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:38.812]   - Field: ‘node’
[17:37:38.812]   - Field: ‘label’
[17:37:38.812]   - Field: ‘local’
[17:37:38.812]   - Field: ‘owner’
[17:37:38.812]   - Field: ‘envir’
[17:37:38.812]   - Field: ‘workers’
[17:37:38.812]   - Field: ‘packages’
[17:37:38.813]   - Field: ‘gc’
[17:37:38.813]   - Field: ‘conditions’
[17:37:38.813]   - Field: ‘persistent’
[17:37:38.813]   - Field: ‘expr’
[17:37:38.813]   - Field: ‘uuid’
[17:37:38.813]   - Field: ‘seed’
[17:37:38.813]   - Field: ‘version’
[17:37:38.813]   - Field: ‘result’
[17:37:38.813]   - Field: ‘asynchronous’
[17:37:38.813]   - Field: ‘calls’
[17:37:38.813]   - Field: ‘globals’
[17:37:38.813]   - Field: ‘stdout’
[17:37:38.814]   - Field: ‘earlySignal’
[17:37:38.814]   - Field: ‘lazy’
[17:37:38.814]   - Field: ‘state’
[17:37:38.814] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:38.814] - Launch lazy future ...
[17:37:38.814] Packages needed by the future expression (n = 0): <none>
[17:37:38.814] Packages needed by future strategies (n = 0): <none>
[17:37:38.815] {
[17:37:38.815]     {
[17:37:38.815]         {
[17:37:38.815]             ...future.startTime <- base::Sys.time()
[17:37:38.815]             {
[17:37:38.815]                 {
[17:37:38.815]                   {
[17:37:38.815]                     {
[17:37:38.815]                       base::local({
[17:37:38.815]                         has_future <- base::requireNamespace("future", 
[17:37:38.815]                           quietly = TRUE)
[17:37:38.815]                         if (has_future) {
[17:37:38.815]                           ns <- base::getNamespace("future")
[17:37:38.815]                           version <- ns[[".package"]][["version"]]
[17:37:38.815]                           if (is.null(version)) 
[17:37:38.815]                             version <- utils::packageVersion("future")
[17:37:38.815]                         }
[17:37:38.815]                         else {
[17:37:38.815]                           version <- NULL
[17:37:38.815]                         }
[17:37:38.815]                         if (!has_future || version < "1.8.0") {
[17:37:38.815]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:38.815]                             "", base::R.version$version.string), 
[17:37:38.815]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:38.815]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:38.815]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:38.815]                               "release", "version")], collapse = " "), 
[17:37:38.815]                             hostname = base::Sys.info()[["nodename"]])
[17:37:38.815]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:38.815]                             info)
[17:37:38.815]                           info <- base::paste(info, collapse = "; ")
[17:37:38.815]                           if (!has_future) {
[17:37:38.815]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:38.815]                               info)
[17:37:38.815]                           }
[17:37:38.815]                           else {
[17:37:38.815]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:38.815]                               info, version)
[17:37:38.815]                           }
[17:37:38.815]                           base::stop(msg)
[17:37:38.815]                         }
[17:37:38.815]                       })
[17:37:38.815]                     }
[17:37:38.815]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:38.815]                     base::options(mc.cores = 1L)
[17:37:38.815]                   }
[17:37:38.815]                   ...future.strategy.old <- future::plan("list")
[17:37:38.815]                   options(future.plan = NULL)
[17:37:38.815]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.815]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:38.815]                 }
[17:37:38.815]                 ...future.workdir <- getwd()
[17:37:38.815]             }
[17:37:38.815]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:38.815]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:38.815]         }
[17:37:38.815]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:38.815]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:38.815]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:38.815]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:38.815]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:38.815]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:38.815]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:38.815]             base::names(...future.oldOptions))
[17:37:38.815]     }
[17:37:38.815]     if (FALSE) {
[17:37:38.815]     }
[17:37:38.815]     else {
[17:37:38.815]         if (TRUE) {
[17:37:38.815]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:38.815]                 open = "w")
[17:37:38.815]         }
[17:37:38.815]         else {
[17:37:38.815]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:38.815]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:38.815]         }
[17:37:38.815]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:38.815]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:38.815]             base::sink(type = "output", split = FALSE)
[17:37:38.815]             base::close(...future.stdout)
[17:37:38.815]         }, add = TRUE)
[17:37:38.815]     }
[17:37:38.815]     ...future.frame <- base::sys.nframe()
[17:37:38.815]     ...future.conditions <- base::list()
[17:37:38.815]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:38.815]     if (FALSE) {
[17:37:38.815]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:38.815]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:38.815]     }
[17:37:38.815]     ...future.result <- base::tryCatch({
[17:37:38.815]         base::withCallingHandlers({
[17:37:38.815]             ...future.value <- base::withVisible(base::local({
[17:37:38.815]                 ...future.makeSendCondition <- base::local({
[17:37:38.815]                   sendCondition <- NULL
[17:37:38.815]                   function(frame = 1L) {
[17:37:38.815]                     if (is.function(sendCondition)) 
[17:37:38.815]                       return(sendCondition)
[17:37:38.815]                     ns <- getNamespace("parallel")
[17:37:38.815]                     if (exists("sendData", mode = "function", 
[17:37:38.815]                       envir = ns)) {
[17:37:38.815]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:38.815]                         envir = ns)
[17:37:38.815]                       envir <- sys.frame(frame)
[17:37:38.815]                       master <- NULL
[17:37:38.815]                       while (!identical(envir, .GlobalEnv) && 
[17:37:38.815]                         !identical(envir, emptyenv())) {
[17:37:38.815]                         if (exists("master", mode = "list", envir = envir, 
[17:37:38.815]                           inherits = FALSE)) {
[17:37:38.815]                           master <- get("master", mode = "list", 
[17:37:38.815]                             envir = envir, inherits = FALSE)
[17:37:38.815]                           if (inherits(master, c("SOCKnode", 
[17:37:38.815]                             "SOCK0node"))) {
[17:37:38.815]                             sendCondition <<- function(cond) {
[17:37:38.815]                               data <- list(type = "VALUE", value = cond, 
[17:37:38.815]                                 success = TRUE)
[17:37:38.815]                               parallel_sendData(master, data)
[17:37:38.815]                             }
[17:37:38.815]                             return(sendCondition)
[17:37:38.815]                           }
[17:37:38.815]                         }
[17:37:38.815]                         frame <- frame + 1L
[17:37:38.815]                         envir <- sys.frame(frame)
[17:37:38.815]                       }
[17:37:38.815]                     }
[17:37:38.815]                     sendCondition <<- function(cond) NULL
[17:37:38.815]                   }
[17:37:38.815]                 })
[17:37:38.815]                 withCallingHandlers({
[17:37:38.815]                   {
[17:37:38.815]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.815]                     if (!identical(...future.globals.maxSize.org, 
[17:37:38.815]                       ...future.globals.maxSize)) {
[17:37:38.815]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.815]                       on.exit(options(oopts), add = TRUE)
[17:37:38.815]                     }
[17:37:38.815]                     {
[17:37:38.815]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.815]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:38.815]                         USE.NAMES = FALSE)
[17:37:38.815]                       do.call(mapply, args = args)
[17:37:38.815]                     }
[17:37:38.815]                   }
[17:37:38.815]                 }, immediateCondition = function(cond) {
[17:37:38.815]                   sendCondition <- ...future.makeSendCondition()
[17:37:38.815]                   sendCondition(cond)
[17:37:38.815]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.815]                   {
[17:37:38.815]                     inherits <- base::inherits
[17:37:38.815]                     invokeRestart <- base::invokeRestart
[17:37:38.815]                     is.null <- base::is.null
[17:37:38.815]                     muffled <- FALSE
[17:37:38.815]                     if (inherits(cond, "message")) {
[17:37:38.815]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:38.815]                       if (muffled) 
[17:37:38.815]                         invokeRestart("muffleMessage")
[17:37:38.815]                     }
[17:37:38.815]                     else if (inherits(cond, "warning")) {
[17:37:38.815]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:38.815]                       if (muffled) 
[17:37:38.815]                         invokeRestart("muffleWarning")
[17:37:38.815]                     }
[17:37:38.815]                     else if (inherits(cond, "condition")) {
[17:37:38.815]                       if (!is.null(pattern)) {
[17:37:38.815]                         computeRestarts <- base::computeRestarts
[17:37:38.815]                         grepl <- base::grepl
[17:37:38.815]                         restarts <- computeRestarts(cond)
[17:37:38.815]                         for (restart in restarts) {
[17:37:38.815]                           name <- restart$name
[17:37:38.815]                           if (is.null(name)) 
[17:37:38.815]                             next
[17:37:38.815]                           if (!grepl(pattern, name)) 
[17:37:38.815]                             next
[17:37:38.815]                           invokeRestart(restart)
[17:37:38.815]                           muffled <- TRUE
[17:37:38.815]                           break
[17:37:38.815]                         }
[17:37:38.815]                       }
[17:37:38.815]                     }
[17:37:38.815]                     invisible(muffled)
[17:37:38.815]                   }
[17:37:38.815]                   muffleCondition(cond)
[17:37:38.815]                 })
[17:37:38.815]             }))
[17:37:38.815]             future::FutureResult(value = ...future.value$value, 
[17:37:38.815]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.815]                   ...future.rng), globalenv = if (FALSE) 
[17:37:38.815]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:38.815]                     ...future.globalenv.names))
[17:37:38.815]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:38.815]         }, condition = base::local({
[17:37:38.815]             c <- base::c
[17:37:38.815]             inherits <- base::inherits
[17:37:38.815]             invokeRestart <- base::invokeRestart
[17:37:38.815]             length <- base::length
[17:37:38.815]             list <- base::list
[17:37:38.815]             seq.int <- base::seq.int
[17:37:38.815]             signalCondition <- base::signalCondition
[17:37:38.815]             sys.calls <- base::sys.calls
[17:37:38.815]             `[[` <- base::`[[`
[17:37:38.815]             `+` <- base::`+`
[17:37:38.815]             `<<-` <- base::`<<-`
[17:37:38.815]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:38.815]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:38.815]                   3L)]
[17:37:38.815]             }
[17:37:38.815]             function(cond) {
[17:37:38.815]                 is_error <- inherits(cond, "error")
[17:37:38.815]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:38.815]                   NULL)
[17:37:38.815]                 if (is_error) {
[17:37:38.815]                   sessionInformation <- function() {
[17:37:38.815]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:38.815]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:38.815]                       search = base::search(), system = base::Sys.info())
[17:37:38.815]                   }
[17:37:38.815]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.815]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:38.815]                     cond$call), session = sessionInformation(), 
[17:37:38.815]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:38.815]                   signalCondition(cond)
[17:37:38.815]                 }
[17:37:38.815]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:38.815]                 "immediateCondition"))) {
[17:37:38.815]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:38.815]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.815]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:38.815]                   if (TRUE && !signal) {
[17:37:38.815]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.815]                     {
[17:37:38.815]                       inherits <- base::inherits
[17:37:38.815]                       invokeRestart <- base::invokeRestart
[17:37:38.815]                       is.null <- base::is.null
[17:37:38.815]                       muffled <- FALSE
[17:37:38.815]                       if (inherits(cond, "message")) {
[17:37:38.815]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.815]                         if (muffled) 
[17:37:38.815]                           invokeRestart("muffleMessage")
[17:37:38.815]                       }
[17:37:38.815]                       else if (inherits(cond, "warning")) {
[17:37:38.815]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.815]                         if (muffled) 
[17:37:38.815]                           invokeRestart("muffleWarning")
[17:37:38.815]                       }
[17:37:38.815]                       else if (inherits(cond, "condition")) {
[17:37:38.815]                         if (!is.null(pattern)) {
[17:37:38.815]                           computeRestarts <- base::computeRestarts
[17:37:38.815]                           grepl <- base::grepl
[17:37:38.815]                           restarts <- computeRestarts(cond)
[17:37:38.815]                           for (restart in restarts) {
[17:37:38.815]                             name <- restart$name
[17:37:38.815]                             if (is.null(name)) 
[17:37:38.815]                               next
[17:37:38.815]                             if (!grepl(pattern, name)) 
[17:37:38.815]                               next
[17:37:38.815]                             invokeRestart(restart)
[17:37:38.815]                             muffled <- TRUE
[17:37:38.815]                             break
[17:37:38.815]                           }
[17:37:38.815]                         }
[17:37:38.815]                       }
[17:37:38.815]                       invisible(muffled)
[17:37:38.815]                     }
[17:37:38.815]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.815]                   }
[17:37:38.815]                 }
[17:37:38.815]                 else {
[17:37:38.815]                   if (TRUE) {
[17:37:38.815]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.815]                     {
[17:37:38.815]                       inherits <- base::inherits
[17:37:38.815]                       invokeRestart <- base::invokeRestart
[17:37:38.815]                       is.null <- base::is.null
[17:37:38.815]                       muffled <- FALSE
[17:37:38.815]                       if (inherits(cond, "message")) {
[17:37:38.815]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.815]                         if (muffled) 
[17:37:38.815]                           invokeRestart("muffleMessage")
[17:37:38.815]                       }
[17:37:38.815]                       else if (inherits(cond, "warning")) {
[17:37:38.815]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.815]                         if (muffled) 
[17:37:38.815]                           invokeRestart("muffleWarning")
[17:37:38.815]                       }
[17:37:38.815]                       else if (inherits(cond, "condition")) {
[17:37:38.815]                         if (!is.null(pattern)) {
[17:37:38.815]                           computeRestarts <- base::computeRestarts
[17:37:38.815]                           grepl <- base::grepl
[17:37:38.815]                           restarts <- computeRestarts(cond)
[17:37:38.815]                           for (restart in restarts) {
[17:37:38.815]                             name <- restart$name
[17:37:38.815]                             if (is.null(name)) 
[17:37:38.815]                               next
[17:37:38.815]                             if (!grepl(pattern, name)) 
[17:37:38.815]                               next
[17:37:38.815]                             invokeRestart(restart)
[17:37:38.815]                             muffled <- TRUE
[17:37:38.815]                             break
[17:37:38.815]                           }
[17:37:38.815]                         }
[17:37:38.815]                       }
[17:37:38.815]                       invisible(muffled)
[17:37:38.815]                     }
[17:37:38.815]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.815]                   }
[17:37:38.815]                 }
[17:37:38.815]             }
[17:37:38.815]         }))
[17:37:38.815]     }, error = function(ex) {
[17:37:38.815]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:38.815]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.815]                 ...future.rng), started = ...future.startTime, 
[17:37:38.815]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:38.815]             version = "1.8"), class = "FutureResult")
[17:37:38.815]     }, finally = {
[17:37:38.815]         if (!identical(...future.workdir, getwd())) 
[17:37:38.815]             setwd(...future.workdir)
[17:37:38.815]         {
[17:37:38.815]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:38.815]                 ...future.oldOptions$nwarnings <- NULL
[17:37:38.815]             }
[17:37:38.815]             base::options(...future.oldOptions)
[17:37:38.815]             if (.Platform$OS.type == "windows") {
[17:37:38.815]                 old_names <- names(...future.oldEnvVars)
[17:37:38.815]                 envs <- base::Sys.getenv()
[17:37:38.815]                 names <- names(envs)
[17:37:38.815]                 common <- intersect(names, old_names)
[17:37:38.815]                 added <- setdiff(names, old_names)
[17:37:38.815]                 removed <- setdiff(old_names, names)
[17:37:38.815]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:38.815]                   envs[common]]
[17:37:38.815]                 NAMES <- toupper(changed)
[17:37:38.815]                 args <- list()
[17:37:38.815]                 for (kk in seq_along(NAMES)) {
[17:37:38.815]                   name <- changed[[kk]]
[17:37:38.815]                   NAME <- NAMES[[kk]]
[17:37:38.815]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.815]                     next
[17:37:38.815]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.815]                 }
[17:37:38.815]                 NAMES <- toupper(added)
[17:37:38.815]                 for (kk in seq_along(NAMES)) {
[17:37:38.815]                   name <- added[[kk]]
[17:37:38.815]                   NAME <- NAMES[[kk]]
[17:37:38.815]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.815]                     next
[17:37:38.815]                   args[[name]] <- ""
[17:37:38.815]                 }
[17:37:38.815]                 NAMES <- toupper(removed)
[17:37:38.815]                 for (kk in seq_along(NAMES)) {
[17:37:38.815]                   name <- removed[[kk]]
[17:37:38.815]                   NAME <- NAMES[[kk]]
[17:37:38.815]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.815]                     next
[17:37:38.815]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.815]                 }
[17:37:38.815]                 if (length(args) > 0) 
[17:37:38.815]                   base::do.call(base::Sys.setenv, args = args)
[17:37:38.815]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:38.815]             }
[17:37:38.815]             else {
[17:37:38.815]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:38.815]             }
[17:37:38.815]             {
[17:37:38.815]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:38.815]                   0L) {
[17:37:38.815]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:38.815]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:38.815]                   base::options(opts)
[17:37:38.815]                 }
[17:37:38.815]                 {
[17:37:38.815]                   {
[17:37:38.815]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:38.815]                     NULL
[17:37:38.815]                   }
[17:37:38.815]                   options(future.plan = NULL)
[17:37:38.815]                   if (is.na(NA_character_)) 
[17:37:38.815]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.815]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:38.815]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:38.815]                     .init = FALSE)
[17:37:38.815]                 }
[17:37:38.815]             }
[17:37:38.815]         }
[17:37:38.815]     })
[17:37:38.815]     if (TRUE) {
[17:37:38.815]         base::sink(type = "output", split = FALSE)
[17:37:38.815]         if (TRUE) {
[17:37:38.815]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:38.815]         }
[17:37:38.815]         else {
[17:37:38.815]             ...future.result["stdout"] <- base::list(NULL)
[17:37:38.815]         }
[17:37:38.815]         base::close(...future.stdout)
[17:37:38.815]         ...future.stdout <- NULL
[17:37:38.815]     }
[17:37:38.815]     ...future.result$conditions <- ...future.conditions
[17:37:38.815]     ...future.result$finished <- base::Sys.time()
[17:37:38.815]     ...future.result
[17:37:38.815] }
[17:37:38.817] Exporting 5 global objects (2.15 KiB) to cluster node #2 ...
[17:37:38.817] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ...
[17:37:38.818] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ... DONE
[17:37:38.818] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:37:38.818] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:37:38.818] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:37:38.819] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:37:38.819] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:37:38.819] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:37:38.819] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:37:38.820] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:37:38.820] Exporting 5 global objects (2.15 KiB) to cluster node #2 ... DONE
[17:37:38.820] MultisessionFuture started
[17:37:38.820] - Launch lazy future ... done
[17:37:38.820] run() for ‘MultisessionFuture’ ... done
[17:37:38.820] Created future:
[17:37:38.821] MultisessionFuture:
[17:37:38.821] Label: ‘future_mapply-2’
[17:37:38.821] Expression:
[17:37:38.821] {
[17:37:38.821]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.821]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:38.821]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.821]         on.exit(options(oopts), add = TRUE)
[17:37:38.821]     }
[17:37:38.821]     {
[17:37:38.821]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.821]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:38.821]         do.call(mapply, args = args)
[17:37:38.821]     }
[17:37:38.821] }
[17:37:38.821] Lazy evaluation: FALSE
[17:37:38.821] Asynchronous evaluation: TRUE
[17:37:38.821] Local evaluation: TRUE
[17:37:38.821] Environment: R_GlobalEnv
[17:37:38.821] Capture standard output: TRUE
[17:37:38.821] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:38.821] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:38.821] Packages: <none>
[17:37:38.821] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:38.821] Resolved: FALSE
[17:37:38.821] Value: <not collected>
[17:37:38.821] Conditions captured: <none>
[17:37:38.821] Early signaling: FALSE
[17:37:38.821] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:38.821] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.832] Chunk #2 of 2 ... DONE
[17:37:38.832] Launching 2 futures (chunks) ... DONE
[17:37:38.832] Resolving 2 futures (chunks) ...
[17:37:38.832] resolve() on list ...
[17:37:38.832]  recursive: 0
[17:37:38.833]  length: 2
[17:37:38.833] 
[17:37:38.833] receiveMessageFromWorker() for ClusterFuture ...
[17:37:38.833] - Validating connection of MultisessionFuture
[17:37:38.833] - received message: FutureResult
[17:37:38.833] - Received FutureResult
[17:37:38.834] - Erased future from FutureRegistry
[17:37:38.834] result() for ClusterFuture ...
[17:37:38.834] - result already collected: FutureResult
[17:37:38.834] result() for ClusterFuture ... done
[17:37:38.834] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:38.834] Future #1
[17:37:38.834] result() for ClusterFuture ...
[17:37:38.834] - result already collected: FutureResult
[17:37:38.834] result() for ClusterFuture ... done
[17:37:38.834] result() for ClusterFuture ...
[17:37:38.834] - result already collected: FutureResult
[17:37:38.834] result() for ClusterFuture ... done
[17:37:38.835] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:37:38.835] - nx: 2
[17:37:38.835] - relay: TRUE
[17:37:38.835] - stdout: TRUE
[17:37:38.835] - signal: TRUE
[17:37:38.835] - resignal: FALSE
[17:37:38.835] - force: TRUE
[17:37:38.835] - relayed: [n=2] FALSE, FALSE
[17:37:38.835] - queued futures: [n=2] FALSE, FALSE
[17:37:38.835]  - until=1
[17:37:38.835]  - relaying element #1
[17:37:38.835] result() for ClusterFuture ...
[17:37:38.836] - result already collected: FutureResult
[17:37:38.836] result() for ClusterFuture ... done
[17:37:38.836] result() for ClusterFuture ...
[17:37:38.836] - result already collected: FutureResult
[17:37:38.836] result() for ClusterFuture ... done
[17:37:38.836] result() for ClusterFuture ...
[17:37:38.836] - result already collected: FutureResult
[17:37:38.836] result() for ClusterFuture ... done
[17:37:38.836] result() for ClusterFuture ...
[17:37:38.836] - result already collected: FutureResult
[17:37:38.836] result() for ClusterFuture ... done
[17:37:38.837] - relayed: [n=2] TRUE, FALSE
[17:37:38.837] - queued futures: [n=2] TRUE, FALSE
[17:37:38.837] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:37:38.837]  length: 1 (resolved future 1)
[17:37:38.862] receiveMessageFromWorker() for ClusterFuture ...
[17:37:38.862] - Validating connection of MultisessionFuture
[17:37:38.862] - received message: FutureResult
[17:37:38.862] - Received FutureResult
[17:37:38.862] - Erased future from FutureRegistry
[17:37:38.862] result() for ClusterFuture ...
[17:37:38.863] - result already collected: FutureResult
[17:37:38.863] result() for ClusterFuture ... done
[17:37:38.863] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:38.863] Future #2
[17:37:38.863] result() for ClusterFuture ...
[17:37:38.863] - result already collected: FutureResult
[17:37:38.863] result() for ClusterFuture ... done
[17:37:38.863] result() for ClusterFuture ...
[17:37:38.863] - result already collected: FutureResult
[17:37:38.863] result() for ClusterFuture ... done
[17:37:38.863] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:37:38.863] - nx: 2
[17:37:38.864] - relay: TRUE
[17:37:38.864] - stdout: TRUE
[17:37:38.864] - signal: TRUE
[17:37:38.864] - resignal: FALSE
[17:37:38.864] - force: TRUE
[17:37:38.864] - relayed: [n=2] TRUE, FALSE
[17:37:38.864] - queued futures: [n=2] TRUE, FALSE
[17:37:38.864]  - until=2
[17:37:38.864]  - relaying element #2
[17:37:38.864] result() for ClusterFuture ...
[17:37:38.864] - result already collected: FutureResult
[17:37:38.865] result() for ClusterFuture ... done
[17:37:38.865] result() for ClusterFuture ...
[17:37:38.865] - result already collected: FutureResult
[17:37:38.865] result() for ClusterFuture ... done
[17:37:38.865] result() for ClusterFuture ...
[17:37:38.865] - result already collected: FutureResult
[17:37:38.865] result() for ClusterFuture ... done
[17:37:38.865] result() for ClusterFuture ...
[17:37:38.865] - result already collected: FutureResult
[17:37:38.865] result() for ClusterFuture ... done
[17:37:38.865] - relayed: [n=2] TRUE, TRUE
[17:37:38.865] - queued futures: [n=2] TRUE, TRUE
[17:37:38.866] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:37:38.866]  length: 0 (resolved future 2)
[17:37:38.866] Relaying remaining futures
[17:37:38.866] signalConditionsASAP(NULL, pos=0) ...
[17:37:38.866] - nx: 2
[17:37:38.866] - relay: TRUE
[17:37:38.866] - stdout: TRUE
[17:37:38.866] - signal: TRUE
[17:37:38.866] - resignal: FALSE
[17:37:38.866] - force: TRUE
[17:37:38.866] - relayed: [n=2] TRUE, TRUE
[17:37:38.866] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:38.867] - relayed: [n=2] TRUE, TRUE
[17:37:38.867] - queued futures: [n=2] TRUE, TRUE
[17:37:38.867] signalConditionsASAP(NULL, pos=0) ... done
[17:37:38.867] resolve() on list ... DONE
[17:37:38.867] result() for ClusterFuture ...
[17:37:38.867] - result already collected: FutureResult
[17:37:38.867] result() for ClusterFuture ... done
[17:37:38.867] result() for ClusterFuture ...
[17:37:38.867] - result already collected: FutureResult
[17:37:38.867] result() for ClusterFuture ... done
[17:37:38.867] result() for ClusterFuture ...
[17:37:38.867] - result already collected: FutureResult
[17:37:38.868] result() for ClusterFuture ... done
[17:37:38.868] result() for ClusterFuture ...
[17:37:38.868] - result already collected: FutureResult
[17:37:38.868] result() for ClusterFuture ... done
[17:37:38.868]  - Number of value chunks collected: 2
[17:37:38.868] Resolving 2 futures (chunks) ... DONE
[17:37:38.868] Reducing values from 2 chunks ...
[17:37:38.868]  - Number of values collected after concatenation: 3
[17:37:38.868]  - Number of values expected: 3
[17:37:38.868] Reducing values from 2 chunks ... DONE
[17:37:38.868] future_mapply() ... DONE
- future_.mapply()
[17:37:38.869] future_mapply() ...
[17:37:38.872] Number of chunks: 2
[17:37:38.873] getGlobalsAndPackagesXApply() ...
[17:37:38.873]  - future.globals: TRUE
[17:37:38.873] getGlobalsAndPackages() ...
[17:37:38.873] Searching for globals...
[17:37:38.874] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[17:37:38.874] Searching for globals ... DONE
[17:37:38.874] Resolving globals: FALSE
[17:37:38.875] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[17:37:38.875] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[17:37:38.875] - globals: [1] ‘FUN’
[17:37:38.875] 
[17:37:38.875] getGlobalsAndPackages() ... DONE
[17:37:38.875]  - globals found/used: [n=1] ‘FUN’
[17:37:38.876]  - needed namespaces: [n=0] 
[17:37:38.876] Finding globals ... DONE
[17:37:38.876] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:38.876] List of 2
[17:37:38.876]  $ ...future.FUN:function (x, y)  
[17:37:38.876]  $ MoreArgs     : list()
[17:37:38.876]  - attr(*, "where")=List of 2
[17:37:38.876]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:38.876]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:38.876]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:38.876]  - attr(*, "resolved")= logi FALSE
[17:37:38.876]  - attr(*, "total_size")= num NA
[17:37:38.878] Packages to be attached in all futures: [n=0] 
[17:37:38.878] getGlobalsAndPackagesXApply() ... DONE
[17:37:38.879] Number of futures (= number of chunks): 2
[17:37:38.879] Launching 2 futures (chunks) ...
[17:37:38.879] Chunk #1 of 2 ...
[17:37:38.879]  - Finding globals in '...' for chunk #1 ...
[17:37:38.879] getGlobalsAndPackages() ...
[17:37:38.879] Searching for globals...
[17:37:38.879] 
[17:37:38.879] Searching for globals ... DONE
[17:37:38.880] - globals: [0] <none>
[17:37:38.880] getGlobalsAndPackages() ... DONE
[17:37:38.880]    + additional globals found: [n=0] 
[17:37:38.880]    + additional namespaces needed: [n=0] 
[17:37:38.880]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:38.880]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:38.880]  - seeds: <none>
[17:37:38.880]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.880] getGlobalsAndPackages() ...
[17:37:38.880] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.880] Resolving globals: FALSE
[17:37:38.881] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[17:37:38.881] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:38.881] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.882] 
[17:37:38.882] getGlobalsAndPackages() ... DONE
[17:37:38.882] run() for ‘Future’ ...
[17:37:38.882] - state: ‘created’
[17:37:38.882] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:38.897] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.897] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:38.897]   - Field: ‘node’
[17:37:38.897]   - Field: ‘label’
[17:37:38.897]   - Field: ‘local’
[17:37:38.897]   - Field: ‘owner’
[17:37:38.897]   - Field: ‘envir’
[17:37:38.897]   - Field: ‘workers’
[17:37:38.898]   - Field: ‘packages’
[17:37:38.898]   - Field: ‘gc’
[17:37:38.898]   - Field: ‘conditions’
[17:37:38.898]   - Field: ‘persistent’
[17:37:38.898]   - Field: ‘expr’
[17:37:38.898]   - Field: ‘uuid’
[17:37:38.898]   - Field: ‘seed’
[17:37:38.898]   - Field: ‘version’
[17:37:38.898]   - Field: ‘result’
[17:37:38.898]   - Field: ‘asynchronous’
[17:37:38.898]   - Field: ‘calls’
[17:37:38.899]   - Field: ‘globals’
[17:37:38.899]   - Field: ‘stdout’
[17:37:38.899]   - Field: ‘earlySignal’
[17:37:38.899]   - Field: ‘lazy’
[17:37:38.899]   - Field: ‘state’
[17:37:38.899] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:38.899] - Launch lazy future ...
[17:37:38.899] Packages needed by the future expression (n = 0): <none>
[17:37:38.899] Packages needed by future strategies (n = 0): <none>
[17:37:38.900] {
[17:37:38.900]     {
[17:37:38.900]         {
[17:37:38.900]             ...future.startTime <- base::Sys.time()
[17:37:38.900]             {
[17:37:38.900]                 {
[17:37:38.900]                   {
[17:37:38.900]                     {
[17:37:38.900]                       base::local({
[17:37:38.900]                         has_future <- base::requireNamespace("future", 
[17:37:38.900]                           quietly = TRUE)
[17:37:38.900]                         if (has_future) {
[17:37:38.900]                           ns <- base::getNamespace("future")
[17:37:38.900]                           version <- ns[[".package"]][["version"]]
[17:37:38.900]                           if (is.null(version)) 
[17:37:38.900]                             version <- utils::packageVersion("future")
[17:37:38.900]                         }
[17:37:38.900]                         else {
[17:37:38.900]                           version <- NULL
[17:37:38.900]                         }
[17:37:38.900]                         if (!has_future || version < "1.8.0") {
[17:37:38.900]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:38.900]                             "", base::R.version$version.string), 
[17:37:38.900]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:38.900]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:38.900]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:38.900]                               "release", "version")], collapse = " "), 
[17:37:38.900]                             hostname = base::Sys.info()[["nodename"]])
[17:37:38.900]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:38.900]                             info)
[17:37:38.900]                           info <- base::paste(info, collapse = "; ")
[17:37:38.900]                           if (!has_future) {
[17:37:38.900]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:38.900]                               info)
[17:37:38.900]                           }
[17:37:38.900]                           else {
[17:37:38.900]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:38.900]                               info, version)
[17:37:38.900]                           }
[17:37:38.900]                           base::stop(msg)
[17:37:38.900]                         }
[17:37:38.900]                       })
[17:37:38.900]                     }
[17:37:38.900]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:38.900]                     base::options(mc.cores = 1L)
[17:37:38.900]                   }
[17:37:38.900]                   ...future.strategy.old <- future::plan("list")
[17:37:38.900]                   options(future.plan = NULL)
[17:37:38.900]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.900]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:38.900]                 }
[17:37:38.900]                 ...future.workdir <- getwd()
[17:37:38.900]             }
[17:37:38.900]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:38.900]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:38.900]         }
[17:37:38.900]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:38.900]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:38.900]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:38.900]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:38.900]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:38.900]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:38.900]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:38.900]             base::names(...future.oldOptions))
[17:37:38.900]     }
[17:37:38.900]     if (FALSE) {
[17:37:38.900]     }
[17:37:38.900]     else {
[17:37:38.900]         if (TRUE) {
[17:37:38.900]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:38.900]                 open = "w")
[17:37:38.900]         }
[17:37:38.900]         else {
[17:37:38.900]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:38.900]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:38.900]         }
[17:37:38.900]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:38.900]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:38.900]             base::sink(type = "output", split = FALSE)
[17:37:38.900]             base::close(...future.stdout)
[17:37:38.900]         }, add = TRUE)
[17:37:38.900]     }
[17:37:38.900]     ...future.frame <- base::sys.nframe()
[17:37:38.900]     ...future.conditions <- base::list()
[17:37:38.900]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:38.900]     if (FALSE) {
[17:37:38.900]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:38.900]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:38.900]     }
[17:37:38.900]     ...future.result <- base::tryCatch({
[17:37:38.900]         base::withCallingHandlers({
[17:37:38.900]             ...future.value <- base::withVisible(base::local({
[17:37:38.900]                 ...future.makeSendCondition <- base::local({
[17:37:38.900]                   sendCondition <- NULL
[17:37:38.900]                   function(frame = 1L) {
[17:37:38.900]                     if (is.function(sendCondition)) 
[17:37:38.900]                       return(sendCondition)
[17:37:38.900]                     ns <- getNamespace("parallel")
[17:37:38.900]                     if (exists("sendData", mode = "function", 
[17:37:38.900]                       envir = ns)) {
[17:37:38.900]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:38.900]                         envir = ns)
[17:37:38.900]                       envir <- sys.frame(frame)
[17:37:38.900]                       master <- NULL
[17:37:38.900]                       while (!identical(envir, .GlobalEnv) && 
[17:37:38.900]                         !identical(envir, emptyenv())) {
[17:37:38.900]                         if (exists("master", mode = "list", envir = envir, 
[17:37:38.900]                           inherits = FALSE)) {
[17:37:38.900]                           master <- get("master", mode = "list", 
[17:37:38.900]                             envir = envir, inherits = FALSE)
[17:37:38.900]                           if (inherits(master, c("SOCKnode", 
[17:37:38.900]                             "SOCK0node"))) {
[17:37:38.900]                             sendCondition <<- function(cond) {
[17:37:38.900]                               data <- list(type = "VALUE", value = cond, 
[17:37:38.900]                                 success = TRUE)
[17:37:38.900]                               parallel_sendData(master, data)
[17:37:38.900]                             }
[17:37:38.900]                             return(sendCondition)
[17:37:38.900]                           }
[17:37:38.900]                         }
[17:37:38.900]                         frame <- frame + 1L
[17:37:38.900]                         envir <- sys.frame(frame)
[17:37:38.900]                       }
[17:37:38.900]                     }
[17:37:38.900]                     sendCondition <<- function(cond) NULL
[17:37:38.900]                   }
[17:37:38.900]                 })
[17:37:38.900]                 withCallingHandlers({
[17:37:38.900]                   {
[17:37:38.900]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.900]                     if (!identical(...future.globals.maxSize.org, 
[17:37:38.900]                       ...future.globals.maxSize)) {
[17:37:38.900]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.900]                       on.exit(options(oopts), add = TRUE)
[17:37:38.900]                     }
[17:37:38.900]                     {
[17:37:38.900]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.900]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:38.900]                         USE.NAMES = FALSE)
[17:37:38.900]                       do.call(mapply, args = args)
[17:37:38.900]                     }
[17:37:38.900]                   }
[17:37:38.900]                 }, immediateCondition = function(cond) {
[17:37:38.900]                   sendCondition <- ...future.makeSendCondition()
[17:37:38.900]                   sendCondition(cond)
[17:37:38.900]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.900]                   {
[17:37:38.900]                     inherits <- base::inherits
[17:37:38.900]                     invokeRestart <- base::invokeRestart
[17:37:38.900]                     is.null <- base::is.null
[17:37:38.900]                     muffled <- FALSE
[17:37:38.900]                     if (inherits(cond, "message")) {
[17:37:38.900]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:38.900]                       if (muffled) 
[17:37:38.900]                         invokeRestart("muffleMessage")
[17:37:38.900]                     }
[17:37:38.900]                     else if (inherits(cond, "warning")) {
[17:37:38.900]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:38.900]                       if (muffled) 
[17:37:38.900]                         invokeRestart("muffleWarning")
[17:37:38.900]                     }
[17:37:38.900]                     else if (inherits(cond, "condition")) {
[17:37:38.900]                       if (!is.null(pattern)) {
[17:37:38.900]                         computeRestarts <- base::computeRestarts
[17:37:38.900]                         grepl <- base::grepl
[17:37:38.900]                         restarts <- computeRestarts(cond)
[17:37:38.900]                         for (restart in restarts) {
[17:37:38.900]                           name <- restart$name
[17:37:38.900]                           if (is.null(name)) 
[17:37:38.900]                             next
[17:37:38.900]                           if (!grepl(pattern, name)) 
[17:37:38.900]                             next
[17:37:38.900]                           invokeRestart(restart)
[17:37:38.900]                           muffled <- TRUE
[17:37:38.900]                           break
[17:37:38.900]                         }
[17:37:38.900]                       }
[17:37:38.900]                     }
[17:37:38.900]                     invisible(muffled)
[17:37:38.900]                   }
[17:37:38.900]                   muffleCondition(cond)
[17:37:38.900]                 })
[17:37:38.900]             }))
[17:37:38.900]             future::FutureResult(value = ...future.value$value, 
[17:37:38.900]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.900]                   ...future.rng), globalenv = if (FALSE) 
[17:37:38.900]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:38.900]                     ...future.globalenv.names))
[17:37:38.900]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:38.900]         }, condition = base::local({
[17:37:38.900]             c <- base::c
[17:37:38.900]             inherits <- base::inherits
[17:37:38.900]             invokeRestart <- base::invokeRestart
[17:37:38.900]             length <- base::length
[17:37:38.900]             list <- base::list
[17:37:38.900]             seq.int <- base::seq.int
[17:37:38.900]             signalCondition <- base::signalCondition
[17:37:38.900]             sys.calls <- base::sys.calls
[17:37:38.900]             `[[` <- base::`[[`
[17:37:38.900]             `+` <- base::`+`
[17:37:38.900]             `<<-` <- base::`<<-`
[17:37:38.900]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:38.900]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:38.900]                   3L)]
[17:37:38.900]             }
[17:37:38.900]             function(cond) {
[17:37:38.900]                 is_error <- inherits(cond, "error")
[17:37:38.900]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:38.900]                   NULL)
[17:37:38.900]                 if (is_error) {
[17:37:38.900]                   sessionInformation <- function() {
[17:37:38.900]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:38.900]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:38.900]                       search = base::search(), system = base::Sys.info())
[17:37:38.900]                   }
[17:37:38.900]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.900]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:38.900]                     cond$call), session = sessionInformation(), 
[17:37:38.900]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:38.900]                   signalCondition(cond)
[17:37:38.900]                 }
[17:37:38.900]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:38.900]                 "immediateCondition"))) {
[17:37:38.900]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:38.900]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.900]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:38.900]                   if (TRUE && !signal) {
[17:37:38.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.900]                     {
[17:37:38.900]                       inherits <- base::inherits
[17:37:38.900]                       invokeRestart <- base::invokeRestart
[17:37:38.900]                       is.null <- base::is.null
[17:37:38.900]                       muffled <- FALSE
[17:37:38.900]                       if (inherits(cond, "message")) {
[17:37:38.900]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.900]                         if (muffled) 
[17:37:38.900]                           invokeRestart("muffleMessage")
[17:37:38.900]                       }
[17:37:38.900]                       else if (inherits(cond, "warning")) {
[17:37:38.900]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.900]                         if (muffled) 
[17:37:38.900]                           invokeRestart("muffleWarning")
[17:37:38.900]                       }
[17:37:38.900]                       else if (inherits(cond, "condition")) {
[17:37:38.900]                         if (!is.null(pattern)) {
[17:37:38.900]                           computeRestarts <- base::computeRestarts
[17:37:38.900]                           grepl <- base::grepl
[17:37:38.900]                           restarts <- computeRestarts(cond)
[17:37:38.900]                           for (restart in restarts) {
[17:37:38.900]                             name <- restart$name
[17:37:38.900]                             if (is.null(name)) 
[17:37:38.900]                               next
[17:37:38.900]                             if (!grepl(pattern, name)) 
[17:37:38.900]                               next
[17:37:38.900]                             invokeRestart(restart)
[17:37:38.900]                             muffled <- TRUE
[17:37:38.900]                             break
[17:37:38.900]                           }
[17:37:38.900]                         }
[17:37:38.900]                       }
[17:37:38.900]                       invisible(muffled)
[17:37:38.900]                     }
[17:37:38.900]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.900]                   }
[17:37:38.900]                 }
[17:37:38.900]                 else {
[17:37:38.900]                   if (TRUE) {
[17:37:38.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.900]                     {
[17:37:38.900]                       inherits <- base::inherits
[17:37:38.900]                       invokeRestart <- base::invokeRestart
[17:37:38.900]                       is.null <- base::is.null
[17:37:38.900]                       muffled <- FALSE
[17:37:38.900]                       if (inherits(cond, "message")) {
[17:37:38.900]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.900]                         if (muffled) 
[17:37:38.900]                           invokeRestart("muffleMessage")
[17:37:38.900]                       }
[17:37:38.900]                       else if (inherits(cond, "warning")) {
[17:37:38.900]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.900]                         if (muffled) 
[17:37:38.900]                           invokeRestart("muffleWarning")
[17:37:38.900]                       }
[17:37:38.900]                       else if (inherits(cond, "condition")) {
[17:37:38.900]                         if (!is.null(pattern)) {
[17:37:38.900]                           computeRestarts <- base::computeRestarts
[17:37:38.900]                           grepl <- base::grepl
[17:37:38.900]                           restarts <- computeRestarts(cond)
[17:37:38.900]                           for (restart in restarts) {
[17:37:38.900]                             name <- restart$name
[17:37:38.900]                             if (is.null(name)) 
[17:37:38.900]                               next
[17:37:38.900]                             if (!grepl(pattern, name)) 
[17:37:38.900]                               next
[17:37:38.900]                             invokeRestart(restart)
[17:37:38.900]                             muffled <- TRUE
[17:37:38.900]                             break
[17:37:38.900]                           }
[17:37:38.900]                         }
[17:37:38.900]                       }
[17:37:38.900]                       invisible(muffled)
[17:37:38.900]                     }
[17:37:38.900]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.900]                   }
[17:37:38.900]                 }
[17:37:38.900]             }
[17:37:38.900]         }))
[17:37:38.900]     }, error = function(ex) {
[17:37:38.900]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:38.900]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.900]                 ...future.rng), started = ...future.startTime, 
[17:37:38.900]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:38.900]             version = "1.8"), class = "FutureResult")
[17:37:38.900]     }, finally = {
[17:37:38.900]         if (!identical(...future.workdir, getwd())) 
[17:37:38.900]             setwd(...future.workdir)
[17:37:38.900]         {
[17:37:38.900]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:38.900]                 ...future.oldOptions$nwarnings <- NULL
[17:37:38.900]             }
[17:37:38.900]             base::options(...future.oldOptions)
[17:37:38.900]             if (.Platform$OS.type == "windows") {
[17:37:38.900]                 old_names <- names(...future.oldEnvVars)
[17:37:38.900]                 envs <- base::Sys.getenv()
[17:37:38.900]                 names <- names(envs)
[17:37:38.900]                 common <- intersect(names, old_names)
[17:37:38.900]                 added <- setdiff(names, old_names)
[17:37:38.900]                 removed <- setdiff(old_names, names)
[17:37:38.900]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:38.900]                   envs[common]]
[17:37:38.900]                 NAMES <- toupper(changed)
[17:37:38.900]                 args <- list()
[17:37:38.900]                 for (kk in seq_along(NAMES)) {
[17:37:38.900]                   name <- changed[[kk]]
[17:37:38.900]                   NAME <- NAMES[[kk]]
[17:37:38.900]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.900]                     next
[17:37:38.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.900]                 }
[17:37:38.900]                 NAMES <- toupper(added)
[17:37:38.900]                 for (kk in seq_along(NAMES)) {
[17:37:38.900]                   name <- added[[kk]]
[17:37:38.900]                   NAME <- NAMES[[kk]]
[17:37:38.900]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.900]                     next
[17:37:38.900]                   args[[name]] <- ""
[17:37:38.900]                 }
[17:37:38.900]                 NAMES <- toupper(removed)
[17:37:38.900]                 for (kk in seq_along(NAMES)) {
[17:37:38.900]                   name <- removed[[kk]]
[17:37:38.900]                   NAME <- NAMES[[kk]]
[17:37:38.900]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.900]                     next
[17:37:38.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.900]                 }
[17:37:38.900]                 if (length(args) > 0) 
[17:37:38.900]                   base::do.call(base::Sys.setenv, args = args)
[17:37:38.900]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:38.900]             }
[17:37:38.900]             else {
[17:37:38.900]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:38.900]             }
[17:37:38.900]             {
[17:37:38.900]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:38.900]                   0L) {
[17:37:38.900]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:38.900]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:38.900]                   base::options(opts)
[17:37:38.900]                 }
[17:37:38.900]                 {
[17:37:38.900]                   {
[17:37:38.900]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:38.900]                     NULL
[17:37:38.900]                   }
[17:37:38.900]                   options(future.plan = NULL)
[17:37:38.900]                   if (is.na(NA_character_)) 
[17:37:38.900]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.900]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:38.900]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:38.900]                     .init = FALSE)
[17:37:38.900]                 }
[17:37:38.900]             }
[17:37:38.900]         }
[17:37:38.900]     })
[17:37:38.900]     if (TRUE) {
[17:37:38.900]         base::sink(type = "output", split = FALSE)
[17:37:38.900]         if (TRUE) {
[17:37:38.900]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:38.900]         }
[17:37:38.900]         else {
[17:37:38.900]             ...future.result["stdout"] <- base::list(NULL)
[17:37:38.900]         }
[17:37:38.900]         base::close(...future.stdout)
[17:37:38.900]         ...future.stdout <- NULL
[17:37:38.900]     }
[17:37:38.900]     ...future.result$conditions <- ...future.conditions
[17:37:38.900]     ...future.result$finished <- base::Sys.time()
[17:37:38.900]     ...future.result
[17:37:38.900] }
[17:37:38.903] Exporting 5 global objects (2.04 KiB) to cluster node #1 ...
[17:37:38.903] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ...
[17:37:38.903] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ... DONE
[17:37:38.903] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:37:38.904] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:37:38.904] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:37:38.904] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:37:38.904] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:38.904] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:38.905] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:38.905] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:38.905] Exporting 5 global objects (2.04 KiB) to cluster node #1 ... DONE
[17:37:38.905] MultisessionFuture started
[17:37:38.906] - Launch lazy future ... done
[17:37:38.906] run() for ‘MultisessionFuture’ ... done
[17:37:38.906] Created future:
[17:37:38.906] MultisessionFuture:
[17:37:38.906] Label: ‘future_.mapply-1’
[17:37:38.906] Expression:
[17:37:38.906] {
[17:37:38.906]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.906]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:38.906]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.906]         on.exit(options(oopts), add = TRUE)
[17:37:38.906]     }
[17:37:38.906]     {
[17:37:38.906]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.906]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:38.906]         do.call(mapply, args = args)
[17:37:38.906]     }
[17:37:38.906] }
[17:37:38.906] Lazy evaluation: FALSE
[17:37:38.906] Asynchronous evaluation: TRUE
[17:37:38.906] Local evaluation: TRUE
[17:37:38.906] Environment: R_GlobalEnv
[17:37:38.906] Capture standard output: TRUE
[17:37:38.906] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:38.906] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:38.906] Packages: <none>
[17:37:38.906] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:38.906] Resolved: FALSE
[17:37:38.906] Value: <not collected>
[17:37:38.906] Conditions captured: <none>
[17:37:38.906] Early signaling: FALSE
[17:37:38.906] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:38.906] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.917] Chunk #1 of 2 ... DONE
[17:37:38.917] Chunk #2 of 2 ...
[17:37:38.918]  - Finding globals in '...' for chunk #2 ...
[17:37:38.918] getGlobalsAndPackages() ...
[17:37:38.918] Searching for globals...
[17:37:38.918] 
[17:37:38.918] Searching for globals ... DONE
[17:37:38.918] - globals: [0] <none>
[17:37:38.918] getGlobalsAndPackages() ... DONE
[17:37:38.918]    + additional globals found: [n=0] 
[17:37:38.919]    + additional namespaces needed: [n=0] 
[17:37:38.919]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:38.919]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:38.919]  - seeds: <none>
[17:37:38.919]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.919] getGlobalsAndPackages() ...
[17:37:38.919] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.919] Resolving globals: FALSE
[17:37:38.920] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[17:37:38.920] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:38.920] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:38.920] 
[17:37:38.920] getGlobalsAndPackages() ... DONE
[17:37:38.921] run() for ‘Future’ ...
[17:37:38.921] - state: ‘created’
[17:37:38.921] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:38.935] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.936] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:38.936]   - Field: ‘node’
[17:37:38.936]   - Field: ‘label’
[17:37:38.936]   - Field: ‘local’
[17:37:38.936]   - Field: ‘owner’
[17:37:38.936]   - Field: ‘envir’
[17:37:38.936]   - Field: ‘workers’
[17:37:38.936]   - Field: ‘packages’
[17:37:38.936]   - Field: ‘gc’
[17:37:38.936]   - Field: ‘conditions’
[17:37:38.937]   - Field: ‘persistent’
[17:37:38.937]   - Field: ‘expr’
[17:37:38.937]   - Field: ‘uuid’
[17:37:38.937]   - Field: ‘seed’
[17:37:38.937]   - Field: ‘version’
[17:37:38.937]   - Field: ‘result’
[17:37:38.937]   - Field: ‘asynchronous’
[17:37:38.937]   - Field: ‘calls’
[17:37:38.937]   - Field: ‘globals’
[17:37:38.937]   - Field: ‘stdout’
[17:37:38.938]   - Field: ‘earlySignal’
[17:37:38.938]   - Field: ‘lazy’
[17:37:38.938]   - Field: ‘state’
[17:37:38.938] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:38.938] - Launch lazy future ...
[17:37:38.938] Packages needed by the future expression (n = 0): <none>
[17:37:38.938] Packages needed by future strategies (n = 0): <none>
[17:37:38.939] {
[17:37:38.939]     {
[17:37:38.939]         {
[17:37:38.939]             ...future.startTime <- base::Sys.time()
[17:37:38.939]             {
[17:37:38.939]                 {
[17:37:38.939]                   {
[17:37:38.939]                     {
[17:37:38.939]                       base::local({
[17:37:38.939]                         has_future <- base::requireNamespace("future", 
[17:37:38.939]                           quietly = TRUE)
[17:37:38.939]                         if (has_future) {
[17:37:38.939]                           ns <- base::getNamespace("future")
[17:37:38.939]                           version <- ns[[".package"]][["version"]]
[17:37:38.939]                           if (is.null(version)) 
[17:37:38.939]                             version <- utils::packageVersion("future")
[17:37:38.939]                         }
[17:37:38.939]                         else {
[17:37:38.939]                           version <- NULL
[17:37:38.939]                         }
[17:37:38.939]                         if (!has_future || version < "1.8.0") {
[17:37:38.939]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:38.939]                             "", base::R.version$version.string), 
[17:37:38.939]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:38.939]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:38.939]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:38.939]                               "release", "version")], collapse = " "), 
[17:37:38.939]                             hostname = base::Sys.info()[["nodename"]])
[17:37:38.939]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:38.939]                             info)
[17:37:38.939]                           info <- base::paste(info, collapse = "; ")
[17:37:38.939]                           if (!has_future) {
[17:37:38.939]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:38.939]                               info)
[17:37:38.939]                           }
[17:37:38.939]                           else {
[17:37:38.939]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:38.939]                               info, version)
[17:37:38.939]                           }
[17:37:38.939]                           base::stop(msg)
[17:37:38.939]                         }
[17:37:38.939]                       })
[17:37:38.939]                     }
[17:37:38.939]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:38.939]                     base::options(mc.cores = 1L)
[17:37:38.939]                   }
[17:37:38.939]                   ...future.strategy.old <- future::plan("list")
[17:37:38.939]                   options(future.plan = NULL)
[17:37:38.939]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.939]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:38.939]                 }
[17:37:38.939]                 ...future.workdir <- getwd()
[17:37:38.939]             }
[17:37:38.939]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:38.939]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:38.939]         }
[17:37:38.939]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:38.939]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:38.939]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:38.939]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:38.939]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:38.939]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:38.939]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:38.939]             base::names(...future.oldOptions))
[17:37:38.939]     }
[17:37:38.939]     if (FALSE) {
[17:37:38.939]     }
[17:37:38.939]     else {
[17:37:38.939]         if (TRUE) {
[17:37:38.939]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:38.939]                 open = "w")
[17:37:38.939]         }
[17:37:38.939]         else {
[17:37:38.939]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:38.939]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:38.939]         }
[17:37:38.939]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:38.939]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:38.939]             base::sink(type = "output", split = FALSE)
[17:37:38.939]             base::close(...future.stdout)
[17:37:38.939]         }, add = TRUE)
[17:37:38.939]     }
[17:37:38.939]     ...future.frame <- base::sys.nframe()
[17:37:38.939]     ...future.conditions <- base::list()
[17:37:38.939]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:38.939]     if (FALSE) {
[17:37:38.939]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:38.939]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:38.939]     }
[17:37:38.939]     ...future.result <- base::tryCatch({
[17:37:38.939]         base::withCallingHandlers({
[17:37:38.939]             ...future.value <- base::withVisible(base::local({
[17:37:38.939]                 ...future.makeSendCondition <- base::local({
[17:37:38.939]                   sendCondition <- NULL
[17:37:38.939]                   function(frame = 1L) {
[17:37:38.939]                     if (is.function(sendCondition)) 
[17:37:38.939]                       return(sendCondition)
[17:37:38.939]                     ns <- getNamespace("parallel")
[17:37:38.939]                     if (exists("sendData", mode = "function", 
[17:37:38.939]                       envir = ns)) {
[17:37:38.939]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:38.939]                         envir = ns)
[17:37:38.939]                       envir <- sys.frame(frame)
[17:37:38.939]                       master <- NULL
[17:37:38.939]                       while (!identical(envir, .GlobalEnv) && 
[17:37:38.939]                         !identical(envir, emptyenv())) {
[17:37:38.939]                         if (exists("master", mode = "list", envir = envir, 
[17:37:38.939]                           inherits = FALSE)) {
[17:37:38.939]                           master <- get("master", mode = "list", 
[17:37:38.939]                             envir = envir, inherits = FALSE)
[17:37:38.939]                           if (inherits(master, c("SOCKnode", 
[17:37:38.939]                             "SOCK0node"))) {
[17:37:38.939]                             sendCondition <<- function(cond) {
[17:37:38.939]                               data <- list(type = "VALUE", value = cond, 
[17:37:38.939]                                 success = TRUE)
[17:37:38.939]                               parallel_sendData(master, data)
[17:37:38.939]                             }
[17:37:38.939]                             return(sendCondition)
[17:37:38.939]                           }
[17:37:38.939]                         }
[17:37:38.939]                         frame <- frame + 1L
[17:37:38.939]                         envir <- sys.frame(frame)
[17:37:38.939]                       }
[17:37:38.939]                     }
[17:37:38.939]                     sendCondition <<- function(cond) NULL
[17:37:38.939]                   }
[17:37:38.939]                 })
[17:37:38.939]                 withCallingHandlers({
[17:37:38.939]                   {
[17:37:38.939]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.939]                     if (!identical(...future.globals.maxSize.org, 
[17:37:38.939]                       ...future.globals.maxSize)) {
[17:37:38.939]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.939]                       on.exit(options(oopts), add = TRUE)
[17:37:38.939]                     }
[17:37:38.939]                     {
[17:37:38.939]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.939]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:38.939]                         USE.NAMES = FALSE)
[17:37:38.939]                       do.call(mapply, args = args)
[17:37:38.939]                     }
[17:37:38.939]                   }
[17:37:38.939]                 }, immediateCondition = function(cond) {
[17:37:38.939]                   sendCondition <- ...future.makeSendCondition()
[17:37:38.939]                   sendCondition(cond)
[17:37:38.939]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.939]                   {
[17:37:38.939]                     inherits <- base::inherits
[17:37:38.939]                     invokeRestart <- base::invokeRestart
[17:37:38.939]                     is.null <- base::is.null
[17:37:38.939]                     muffled <- FALSE
[17:37:38.939]                     if (inherits(cond, "message")) {
[17:37:38.939]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:38.939]                       if (muffled) 
[17:37:38.939]                         invokeRestart("muffleMessage")
[17:37:38.939]                     }
[17:37:38.939]                     else if (inherits(cond, "warning")) {
[17:37:38.939]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:38.939]                       if (muffled) 
[17:37:38.939]                         invokeRestart("muffleWarning")
[17:37:38.939]                     }
[17:37:38.939]                     else if (inherits(cond, "condition")) {
[17:37:38.939]                       if (!is.null(pattern)) {
[17:37:38.939]                         computeRestarts <- base::computeRestarts
[17:37:38.939]                         grepl <- base::grepl
[17:37:38.939]                         restarts <- computeRestarts(cond)
[17:37:38.939]                         for (restart in restarts) {
[17:37:38.939]                           name <- restart$name
[17:37:38.939]                           if (is.null(name)) 
[17:37:38.939]                             next
[17:37:38.939]                           if (!grepl(pattern, name)) 
[17:37:38.939]                             next
[17:37:38.939]                           invokeRestart(restart)
[17:37:38.939]                           muffled <- TRUE
[17:37:38.939]                           break
[17:37:38.939]                         }
[17:37:38.939]                       }
[17:37:38.939]                     }
[17:37:38.939]                     invisible(muffled)
[17:37:38.939]                   }
[17:37:38.939]                   muffleCondition(cond)
[17:37:38.939]                 })
[17:37:38.939]             }))
[17:37:38.939]             future::FutureResult(value = ...future.value$value, 
[17:37:38.939]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.939]                   ...future.rng), globalenv = if (FALSE) 
[17:37:38.939]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:38.939]                     ...future.globalenv.names))
[17:37:38.939]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:38.939]         }, condition = base::local({
[17:37:38.939]             c <- base::c
[17:37:38.939]             inherits <- base::inherits
[17:37:38.939]             invokeRestart <- base::invokeRestart
[17:37:38.939]             length <- base::length
[17:37:38.939]             list <- base::list
[17:37:38.939]             seq.int <- base::seq.int
[17:37:38.939]             signalCondition <- base::signalCondition
[17:37:38.939]             sys.calls <- base::sys.calls
[17:37:38.939]             `[[` <- base::`[[`
[17:37:38.939]             `+` <- base::`+`
[17:37:38.939]             `<<-` <- base::`<<-`
[17:37:38.939]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:38.939]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:38.939]                   3L)]
[17:37:38.939]             }
[17:37:38.939]             function(cond) {
[17:37:38.939]                 is_error <- inherits(cond, "error")
[17:37:38.939]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:38.939]                   NULL)
[17:37:38.939]                 if (is_error) {
[17:37:38.939]                   sessionInformation <- function() {
[17:37:38.939]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:38.939]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:38.939]                       search = base::search(), system = base::Sys.info())
[17:37:38.939]                   }
[17:37:38.939]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.939]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:38.939]                     cond$call), session = sessionInformation(), 
[17:37:38.939]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:38.939]                   signalCondition(cond)
[17:37:38.939]                 }
[17:37:38.939]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:38.939]                 "immediateCondition"))) {
[17:37:38.939]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:38.939]                   ...future.conditions[[length(...future.conditions) + 
[17:37:38.939]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:38.939]                   if (TRUE && !signal) {
[17:37:38.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.939]                     {
[17:37:38.939]                       inherits <- base::inherits
[17:37:38.939]                       invokeRestart <- base::invokeRestart
[17:37:38.939]                       is.null <- base::is.null
[17:37:38.939]                       muffled <- FALSE
[17:37:38.939]                       if (inherits(cond, "message")) {
[17:37:38.939]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.939]                         if (muffled) 
[17:37:38.939]                           invokeRestart("muffleMessage")
[17:37:38.939]                       }
[17:37:38.939]                       else if (inherits(cond, "warning")) {
[17:37:38.939]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.939]                         if (muffled) 
[17:37:38.939]                           invokeRestart("muffleWarning")
[17:37:38.939]                       }
[17:37:38.939]                       else if (inherits(cond, "condition")) {
[17:37:38.939]                         if (!is.null(pattern)) {
[17:37:38.939]                           computeRestarts <- base::computeRestarts
[17:37:38.939]                           grepl <- base::grepl
[17:37:38.939]                           restarts <- computeRestarts(cond)
[17:37:38.939]                           for (restart in restarts) {
[17:37:38.939]                             name <- restart$name
[17:37:38.939]                             if (is.null(name)) 
[17:37:38.939]                               next
[17:37:38.939]                             if (!grepl(pattern, name)) 
[17:37:38.939]                               next
[17:37:38.939]                             invokeRestart(restart)
[17:37:38.939]                             muffled <- TRUE
[17:37:38.939]                             break
[17:37:38.939]                           }
[17:37:38.939]                         }
[17:37:38.939]                       }
[17:37:38.939]                       invisible(muffled)
[17:37:38.939]                     }
[17:37:38.939]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.939]                   }
[17:37:38.939]                 }
[17:37:38.939]                 else {
[17:37:38.939]                   if (TRUE) {
[17:37:38.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:38.939]                     {
[17:37:38.939]                       inherits <- base::inherits
[17:37:38.939]                       invokeRestart <- base::invokeRestart
[17:37:38.939]                       is.null <- base::is.null
[17:37:38.939]                       muffled <- FALSE
[17:37:38.939]                       if (inherits(cond, "message")) {
[17:37:38.939]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:38.939]                         if (muffled) 
[17:37:38.939]                           invokeRestart("muffleMessage")
[17:37:38.939]                       }
[17:37:38.939]                       else if (inherits(cond, "warning")) {
[17:37:38.939]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:38.939]                         if (muffled) 
[17:37:38.939]                           invokeRestart("muffleWarning")
[17:37:38.939]                       }
[17:37:38.939]                       else if (inherits(cond, "condition")) {
[17:37:38.939]                         if (!is.null(pattern)) {
[17:37:38.939]                           computeRestarts <- base::computeRestarts
[17:37:38.939]                           grepl <- base::grepl
[17:37:38.939]                           restarts <- computeRestarts(cond)
[17:37:38.939]                           for (restart in restarts) {
[17:37:38.939]                             name <- restart$name
[17:37:38.939]                             if (is.null(name)) 
[17:37:38.939]                               next
[17:37:38.939]                             if (!grepl(pattern, name)) 
[17:37:38.939]                               next
[17:37:38.939]                             invokeRestart(restart)
[17:37:38.939]                             muffled <- TRUE
[17:37:38.939]                             break
[17:37:38.939]                           }
[17:37:38.939]                         }
[17:37:38.939]                       }
[17:37:38.939]                       invisible(muffled)
[17:37:38.939]                     }
[17:37:38.939]                     muffleCondition(cond, pattern = "^muffle")
[17:37:38.939]                   }
[17:37:38.939]                 }
[17:37:38.939]             }
[17:37:38.939]         }))
[17:37:38.939]     }, error = function(ex) {
[17:37:38.939]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:38.939]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:38.939]                 ...future.rng), started = ...future.startTime, 
[17:37:38.939]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:38.939]             version = "1.8"), class = "FutureResult")
[17:37:38.939]     }, finally = {
[17:37:38.939]         if (!identical(...future.workdir, getwd())) 
[17:37:38.939]             setwd(...future.workdir)
[17:37:38.939]         {
[17:37:38.939]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:38.939]                 ...future.oldOptions$nwarnings <- NULL
[17:37:38.939]             }
[17:37:38.939]             base::options(...future.oldOptions)
[17:37:38.939]             if (.Platform$OS.type == "windows") {
[17:37:38.939]                 old_names <- names(...future.oldEnvVars)
[17:37:38.939]                 envs <- base::Sys.getenv()
[17:37:38.939]                 names <- names(envs)
[17:37:38.939]                 common <- intersect(names, old_names)
[17:37:38.939]                 added <- setdiff(names, old_names)
[17:37:38.939]                 removed <- setdiff(old_names, names)
[17:37:38.939]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:38.939]                   envs[common]]
[17:37:38.939]                 NAMES <- toupper(changed)
[17:37:38.939]                 args <- list()
[17:37:38.939]                 for (kk in seq_along(NAMES)) {
[17:37:38.939]                   name <- changed[[kk]]
[17:37:38.939]                   NAME <- NAMES[[kk]]
[17:37:38.939]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.939]                     next
[17:37:38.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.939]                 }
[17:37:38.939]                 NAMES <- toupper(added)
[17:37:38.939]                 for (kk in seq_along(NAMES)) {
[17:37:38.939]                   name <- added[[kk]]
[17:37:38.939]                   NAME <- NAMES[[kk]]
[17:37:38.939]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.939]                     next
[17:37:38.939]                   args[[name]] <- ""
[17:37:38.939]                 }
[17:37:38.939]                 NAMES <- toupper(removed)
[17:37:38.939]                 for (kk in seq_along(NAMES)) {
[17:37:38.939]                   name <- removed[[kk]]
[17:37:38.939]                   NAME <- NAMES[[kk]]
[17:37:38.939]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:38.939]                     next
[17:37:38.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:38.939]                 }
[17:37:38.939]                 if (length(args) > 0) 
[17:37:38.939]                   base::do.call(base::Sys.setenv, args = args)
[17:37:38.939]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:38.939]             }
[17:37:38.939]             else {
[17:37:38.939]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:38.939]             }
[17:37:38.939]             {
[17:37:38.939]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:38.939]                   0L) {
[17:37:38.939]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:38.939]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:38.939]                   base::options(opts)
[17:37:38.939]                 }
[17:37:38.939]                 {
[17:37:38.939]                   {
[17:37:38.939]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:38.939]                     NULL
[17:37:38.939]                   }
[17:37:38.939]                   options(future.plan = NULL)
[17:37:38.939]                   if (is.na(NA_character_)) 
[17:37:38.939]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:38.939]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:38.939]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:38.939]                     .init = FALSE)
[17:37:38.939]                 }
[17:37:38.939]             }
[17:37:38.939]         }
[17:37:38.939]     })
[17:37:38.939]     if (TRUE) {
[17:37:38.939]         base::sink(type = "output", split = FALSE)
[17:37:38.939]         if (TRUE) {
[17:37:38.939]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:38.939]         }
[17:37:38.939]         else {
[17:37:38.939]             ...future.result["stdout"] <- base::list(NULL)
[17:37:38.939]         }
[17:37:38.939]         base::close(...future.stdout)
[17:37:38.939]         ...future.stdout <- NULL
[17:37:38.939]     }
[17:37:38.939]     ...future.result$conditions <- ...future.conditions
[17:37:38.939]     ...future.result$finished <- base::Sys.time()
[17:37:38.939]     ...future.result
[17:37:38.939] }
[17:37:38.942] Exporting 5 global objects (2.15 KiB) to cluster node #2 ...
[17:37:38.942] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ...
[17:37:38.942] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ... DONE
[17:37:38.944] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:37:38.945] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:37:38.945] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:37:38.945] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:37:38.945] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:37:38.946] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:37:38.946] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:37:38.946] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:37:38.946] Exporting 5 global objects (2.15 KiB) to cluster node #2 ... DONE
[17:37:38.947] MultisessionFuture started
[17:37:38.947] - Launch lazy future ... done
[17:37:38.947] run() for ‘MultisessionFuture’ ... done
[17:37:38.947] Created future:
[17:37:38.947] MultisessionFuture:
[17:37:38.947] Label: ‘future_.mapply-2’
[17:37:38.947] Expression:
[17:37:38.947] {
[17:37:38.947]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:38.947]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:38.947]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:38.947]         on.exit(options(oopts), add = TRUE)
[17:37:38.947]     }
[17:37:38.947]     {
[17:37:38.947]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:38.947]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:38.947]         do.call(mapply, args = args)
[17:37:38.947]     }
[17:37:38.947] }
[17:37:38.947] Lazy evaluation: FALSE
[17:37:38.947] Asynchronous evaluation: TRUE
[17:37:38.947] Local evaluation: TRUE
[17:37:38.947] Environment: R_GlobalEnv
[17:37:38.947] Capture standard output: TRUE
[17:37:38.947] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:38.947] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:38.947] Packages: <none>
[17:37:38.947] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:38.947] Resolved: FALSE
[17:37:38.947] Value: <not collected>
[17:37:38.947] Conditions captured: <none>
[17:37:38.947] Early signaling: FALSE
[17:37:38.947] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:38.947] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:38.958] Chunk #2 of 2 ... DONE
[17:37:38.958] Launching 2 futures (chunks) ... DONE
[17:37:38.958] Resolving 2 futures (chunks) ...
[17:37:38.959] resolve() on list ...
[17:37:38.959]  recursive: 0
[17:37:38.959]  length: 2
[17:37:38.959] 
[17:37:38.959] receiveMessageFromWorker() for ClusterFuture ...
[17:37:38.959] - Validating connection of MultisessionFuture
[17:37:38.960] - received message: FutureResult
[17:37:38.960] - Received FutureResult
[17:37:38.960] - Erased future from FutureRegistry
[17:37:38.960] result() for ClusterFuture ...
[17:37:38.960] - result already collected: FutureResult
[17:37:38.960] result() for ClusterFuture ... done
[17:37:38.960] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:38.960] Future #1
[17:37:38.960] result() for ClusterFuture ...
[17:37:38.960] - result already collected: FutureResult
[17:37:38.960] result() for ClusterFuture ... done
[17:37:38.961] result() for ClusterFuture ...
[17:37:38.961] - result already collected: FutureResult
[17:37:38.961] result() for ClusterFuture ... done
[17:37:38.961] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:37:38.961] - nx: 2
[17:37:38.961] - relay: TRUE
[17:37:38.961] - stdout: TRUE
[17:37:38.961] - signal: TRUE
[17:37:38.961] - resignal: FALSE
[17:37:38.961] - force: TRUE
[17:37:38.961] - relayed: [n=2] FALSE, FALSE
[17:37:38.961] - queued futures: [n=2] FALSE, FALSE
[17:37:38.962]  - until=1
[17:37:38.962]  - relaying element #1
[17:37:38.962] result() for ClusterFuture ...
[17:37:38.962] - result already collected: FutureResult
[17:37:38.962] result() for ClusterFuture ... done
[17:37:38.962] result() for ClusterFuture ...
[17:37:38.962] - result already collected: FutureResult
[17:37:38.962] result() for ClusterFuture ... done
[17:37:38.962] result() for ClusterFuture ...
[17:37:38.962] - result already collected: FutureResult
[17:37:38.962] result() for ClusterFuture ... done
[17:37:38.963] result() for ClusterFuture ...
[17:37:38.963] - result already collected: FutureResult
[17:37:38.963] result() for ClusterFuture ... done
[17:37:38.963] - relayed: [n=2] TRUE, FALSE
[17:37:38.963] - queued futures: [n=2] TRUE, FALSE
[17:37:38.963] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:37:38.963]  length: 1 (resolved future 1)
[17:37:38.990] receiveMessageFromWorker() for ClusterFuture ...
[17:37:38.990] - Validating connection of MultisessionFuture
[17:37:38.990] - received message: FutureResult
[17:37:38.990] - Received FutureResult
[17:37:38.990] - Erased future from FutureRegistry
[17:37:38.991] result() for ClusterFuture ...
[17:37:38.991] - result already collected: FutureResult
[17:37:38.991] result() for ClusterFuture ... done
[17:37:38.991] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:38.991] Future #2
[17:37:38.991] result() for ClusterFuture ...
[17:37:38.991] - result already collected: FutureResult
[17:37:38.991] result() for ClusterFuture ... done
[17:37:38.991] result() for ClusterFuture ...
[17:37:38.991] - result already collected: FutureResult
[17:37:38.991] result() for ClusterFuture ... done
[17:37:38.992] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:37:38.992] - nx: 2
[17:37:38.992] - relay: TRUE
[17:37:38.992] - stdout: TRUE
[17:37:38.992] - signal: TRUE
[17:37:38.992] - resignal: FALSE
[17:37:38.992] - force: TRUE
[17:37:38.992] - relayed: [n=2] TRUE, FALSE
[17:37:38.992] - queued futures: [n=2] TRUE, FALSE
[17:37:38.992]  - until=2
[17:37:38.992]  - relaying element #2
[17:37:38.992] result() for ClusterFuture ...
[17:37:38.993] - result already collected: FutureResult
[17:37:38.993] result() for ClusterFuture ... done
[17:37:38.993] result() for ClusterFuture ...
[17:37:38.993] - result already collected: FutureResult
[17:37:38.993] result() for ClusterFuture ... done
[17:37:38.993] result() for ClusterFuture ...
[17:37:38.993] - result already collected: FutureResult
[17:37:38.993] result() for ClusterFuture ... done
[17:37:38.993] result() for ClusterFuture ...
[17:37:38.993] - result already collected: FutureResult
[17:37:38.993] result() for ClusterFuture ... done
[17:37:38.993] - relayed: [n=2] TRUE, TRUE
[17:37:38.994] - queued futures: [n=2] TRUE, TRUE
[17:37:38.994] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:37:38.994]  length: 0 (resolved future 2)
[17:37:38.994] Relaying remaining futures
[17:37:38.994] signalConditionsASAP(NULL, pos=0) ...
[17:37:38.994] - nx: 2
[17:37:38.994] - relay: TRUE
[17:37:38.994] - stdout: TRUE
[17:37:38.994] - signal: TRUE
[17:37:38.994] - resignal: FALSE
[17:37:38.994] - force: TRUE
[17:37:38.994] - relayed: [n=2] TRUE, TRUE
[17:37:38.995] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:38.995] - relayed: [n=2] TRUE, TRUE
[17:37:38.995] - queued futures: [n=2] TRUE, TRUE
[17:37:38.995] signalConditionsASAP(NULL, pos=0) ... done
[17:37:38.995] resolve() on list ... DONE
[17:37:38.995] result() for ClusterFuture ...
[17:37:38.995] - result already collected: FutureResult
[17:37:38.995] result() for ClusterFuture ... done
[17:37:38.995] result() for ClusterFuture ...
[17:37:38.995] - result already collected: FutureResult
[17:37:38.995] result() for ClusterFuture ... done
[17:37:38.996] result() for ClusterFuture ...
[17:37:38.996] - result already collected: FutureResult
[17:37:38.996] result() for ClusterFuture ... done
[17:37:38.996] result() for ClusterFuture ...
[17:37:38.996] - result already collected: FutureResult
[17:37:38.996] result() for ClusterFuture ... done
[17:37:38.996]  - Number of value chunks collected: 2
[17:37:38.996] Resolving 2 futures (chunks) ... DONE
[17:37:38.996] Reducing values from 2 chunks ...
[17:37:38.996]  - Number of values collected after concatenation: 3
[17:37:38.996]  - Number of values expected: 3
[17:37:38.996] Reducing values from 2 chunks ... DONE
[17:37:38.997] future_mapply() ... DONE
[17:37:38.997] future_mapply() ...
[17:37:39.001] Number of chunks: 5
[17:37:39.001] getGlobalsAndPackagesXApply() ...
[17:37:39.001]  - future.globals: TRUE
[17:37:39.001] getGlobalsAndPackages() ...
[17:37:39.001] Searching for globals...
[17:37:39.002] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:37:39.002] Searching for globals ... DONE
[17:37:39.003] Resolving globals: FALSE
[17:37:39.003] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:37:39.003] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:37:39.003] - globals: [1] ‘FUN’
[17:37:39.003] 
[17:37:39.004] getGlobalsAndPackages() ... DONE
[17:37:39.004]  - globals found/used: [n=1] ‘FUN’
[17:37:39.004]  - needed namespaces: [n=0] 
[17:37:39.004] Finding globals ... DONE
[17:37:39.004] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:39.004] List of 2
[17:37:39.004]  $ ...future.FUN:function (C, k)  
[17:37:39.004]  $ MoreArgs     : NULL
[17:37:39.004]  - attr(*, "where")=List of 2
[17:37:39.004]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:39.004]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:39.004]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:39.004]  - attr(*, "resolved")= logi FALSE
[17:37:39.004]  - attr(*, "total_size")= num NA
[17:37:39.006] Packages to be attached in all futures: [n=0] 
[17:37:39.007] getGlobalsAndPackagesXApply() ... DONE
[17:37:39.007] Number of futures (= number of chunks): 5
[17:37:39.007] Launching 5 futures (chunks) ...
[17:37:39.007] Chunk #1 of 5 ...
[17:37:39.007]  - Finding globals in '...' for chunk #1 ...
[17:37:39.007] getGlobalsAndPackages() ...
[17:37:39.007] Searching for globals...
[17:37:39.008] 
[17:37:39.008] Searching for globals ... DONE
[17:37:39.008] - globals: [0] <none>
[17:37:39.008] getGlobalsAndPackages() ... DONE
[17:37:39.008]    + additional globals found: [n=0] 
[17:37:39.008]    + additional namespaces needed: [n=0] 
[17:37:39.008]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:39.008]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:37:39.008]  - seeds: <none>
[17:37:39.008]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.009] getGlobalsAndPackages() ...
[17:37:39.009] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.009] Resolving globals: FALSE
[17:37:39.009] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:37:39.010] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:39.010] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.010] 
[17:37:39.010] getGlobalsAndPackages() ... DONE
[17:37:39.010] run() for ‘Future’ ...
[17:37:39.010] - state: ‘created’
[17:37:39.010] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:39.024] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.024] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:39.024]   - Field: ‘node’
[17:37:39.024]   - Field: ‘label’
[17:37:39.024]   - Field: ‘local’
[17:37:39.024]   - Field: ‘owner’
[17:37:39.024]   - Field: ‘envir’
[17:37:39.024]   - Field: ‘workers’
[17:37:39.024]   - Field: ‘packages’
[17:37:39.025]   - Field: ‘gc’
[17:37:39.025]   - Field: ‘conditions’
[17:37:39.025]   - Field: ‘persistent’
[17:37:39.025]   - Field: ‘expr’
[17:37:39.025]   - Field: ‘uuid’
[17:37:39.025]   - Field: ‘seed’
[17:37:39.025]   - Field: ‘version’
[17:37:39.025]   - Field: ‘result’
[17:37:39.025]   - Field: ‘asynchronous’
[17:37:39.025]   - Field: ‘calls’
[17:37:39.025]   - Field: ‘globals’
[17:37:39.025]   - Field: ‘stdout’
[17:37:39.026]   - Field: ‘earlySignal’
[17:37:39.026]   - Field: ‘lazy’
[17:37:39.026]   - Field: ‘state’
[17:37:39.026] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:39.026] - Launch lazy future ...
[17:37:39.026] Packages needed by the future expression (n = 0): <none>
[17:37:39.026] Packages needed by future strategies (n = 0): <none>
[17:37:39.027] {
[17:37:39.027]     {
[17:37:39.027]         {
[17:37:39.027]             ...future.startTime <- base::Sys.time()
[17:37:39.027]             {
[17:37:39.027]                 {
[17:37:39.027]                   {
[17:37:39.027]                     {
[17:37:39.027]                       base::local({
[17:37:39.027]                         has_future <- base::requireNamespace("future", 
[17:37:39.027]                           quietly = TRUE)
[17:37:39.027]                         if (has_future) {
[17:37:39.027]                           ns <- base::getNamespace("future")
[17:37:39.027]                           version <- ns[[".package"]][["version"]]
[17:37:39.027]                           if (is.null(version)) 
[17:37:39.027]                             version <- utils::packageVersion("future")
[17:37:39.027]                         }
[17:37:39.027]                         else {
[17:37:39.027]                           version <- NULL
[17:37:39.027]                         }
[17:37:39.027]                         if (!has_future || version < "1.8.0") {
[17:37:39.027]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:39.027]                             "", base::R.version$version.string), 
[17:37:39.027]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:39.027]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:39.027]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:39.027]                               "release", "version")], collapse = " "), 
[17:37:39.027]                             hostname = base::Sys.info()[["nodename"]])
[17:37:39.027]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:39.027]                             info)
[17:37:39.027]                           info <- base::paste(info, collapse = "; ")
[17:37:39.027]                           if (!has_future) {
[17:37:39.027]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:39.027]                               info)
[17:37:39.027]                           }
[17:37:39.027]                           else {
[17:37:39.027]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:39.027]                               info, version)
[17:37:39.027]                           }
[17:37:39.027]                           base::stop(msg)
[17:37:39.027]                         }
[17:37:39.027]                       })
[17:37:39.027]                     }
[17:37:39.027]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:39.027]                     base::options(mc.cores = 1L)
[17:37:39.027]                   }
[17:37:39.027]                   ...future.strategy.old <- future::plan("list")
[17:37:39.027]                   options(future.plan = NULL)
[17:37:39.027]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.027]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:39.027]                 }
[17:37:39.027]                 ...future.workdir <- getwd()
[17:37:39.027]             }
[17:37:39.027]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:39.027]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:39.027]         }
[17:37:39.027]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:39.027]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:37:39.027]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:39.027]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:39.027]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:39.027]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:39.027]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:39.027]             base::names(...future.oldOptions))
[17:37:39.027]     }
[17:37:39.027]     if (FALSE) {
[17:37:39.027]     }
[17:37:39.027]     else {
[17:37:39.027]         if (TRUE) {
[17:37:39.027]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:39.027]                 open = "w")
[17:37:39.027]         }
[17:37:39.027]         else {
[17:37:39.027]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:39.027]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:39.027]         }
[17:37:39.027]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:39.027]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:39.027]             base::sink(type = "output", split = FALSE)
[17:37:39.027]             base::close(...future.stdout)
[17:37:39.027]         }, add = TRUE)
[17:37:39.027]     }
[17:37:39.027]     ...future.frame <- base::sys.nframe()
[17:37:39.027]     ...future.conditions <- base::list()
[17:37:39.027]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:39.027]     if (FALSE) {
[17:37:39.027]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:39.027]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:39.027]     }
[17:37:39.027]     ...future.result <- base::tryCatch({
[17:37:39.027]         base::withCallingHandlers({
[17:37:39.027]             ...future.value <- base::withVisible(base::local({
[17:37:39.027]                 ...future.makeSendCondition <- base::local({
[17:37:39.027]                   sendCondition <- NULL
[17:37:39.027]                   function(frame = 1L) {
[17:37:39.027]                     if (is.function(sendCondition)) 
[17:37:39.027]                       return(sendCondition)
[17:37:39.027]                     ns <- getNamespace("parallel")
[17:37:39.027]                     if (exists("sendData", mode = "function", 
[17:37:39.027]                       envir = ns)) {
[17:37:39.027]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:39.027]                         envir = ns)
[17:37:39.027]                       envir <- sys.frame(frame)
[17:37:39.027]                       master <- NULL
[17:37:39.027]                       while (!identical(envir, .GlobalEnv) && 
[17:37:39.027]                         !identical(envir, emptyenv())) {
[17:37:39.027]                         if (exists("master", mode = "list", envir = envir, 
[17:37:39.027]                           inherits = FALSE)) {
[17:37:39.027]                           master <- get("master", mode = "list", 
[17:37:39.027]                             envir = envir, inherits = FALSE)
[17:37:39.027]                           if (inherits(master, c("SOCKnode", 
[17:37:39.027]                             "SOCK0node"))) {
[17:37:39.027]                             sendCondition <<- function(cond) {
[17:37:39.027]                               data <- list(type = "VALUE", value = cond, 
[17:37:39.027]                                 success = TRUE)
[17:37:39.027]                               parallel_sendData(master, data)
[17:37:39.027]                             }
[17:37:39.027]                             return(sendCondition)
[17:37:39.027]                           }
[17:37:39.027]                         }
[17:37:39.027]                         frame <- frame + 1L
[17:37:39.027]                         envir <- sys.frame(frame)
[17:37:39.027]                       }
[17:37:39.027]                     }
[17:37:39.027]                     sendCondition <<- function(cond) NULL
[17:37:39.027]                   }
[17:37:39.027]                 })
[17:37:39.027]                 withCallingHandlers({
[17:37:39.027]                   {
[17:37:39.027]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.027]                     if (!identical(...future.globals.maxSize.org, 
[17:37:39.027]                       ...future.globals.maxSize)) {
[17:37:39.027]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.027]                       on.exit(options(oopts), add = TRUE)
[17:37:39.027]                     }
[17:37:39.027]                     {
[17:37:39.027]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.027]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:39.027]                         USE.NAMES = FALSE)
[17:37:39.027]                       do.call(mapply, args = args)
[17:37:39.027]                     }
[17:37:39.027]                   }
[17:37:39.027]                 }, immediateCondition = function(cond) {
[17:37:39.027]                   sendCondition <- ...future.makeSendCondition()
[17:37:39.027]                   sendCondition(cond)
[17:37:39.027]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.027]                   {
[17:37:39.027]                     inherits <- base::inherits
[17:37:39.027]                     invokeRestart <- base::invokeRestart
[17:37:39.027]                     is.null <- base::is.null
[17:37:39.027]                     muffled <- FALSE
[17:37:39.027]                     if (inherits(cond, "message")) {
[17:37:39.027]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:39.027]                       if (muffled) 
[17:37:39.027]                         invokeRestart("muffleMessage")
[17:37:39.027]                     }
[17:37:39.027]                     else if (inherits(cond, "warning")) {
[17:37:39.027]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:39.027]                       if (muffled) 
[17:37:39.027]                         invokeRestart("muffleWarning")
[17:37:39.027]                     }
[17:37:39.027]                     else if (inherits(cond, "condition")) {
[17:37:39.027]                       if (!is.null(pattern)) {
[17:37:39.027]                         computeRestarts <- base::computeRestarts
[17:37:39.027]                         grepl <- base::grepl
[17:37:39.027]                         restarts <- computeRestarts(cond)
[17:37:39.027]                         for (restart in restarts) {
[17:37:39.027]                           name <- restart$name
[17:37:39.027]                           if (is.null(name)) 
[17:37:39.027]                             next
[17:37:39.027]                           if (!grepl(pattern, name)) 
[17:37:39.027]                             next
[17:37:39.027]                           invokeRestart(restart)
[17:37:39.027]                           muffled <- TRUE
[17:37:39.027]                           break
[17:37:39.027]                         }
[17:37:39.027]                       }
[17:37:39.027]                     }
[17:37:39.027]                     invisible(muffled)
[17:37:39.027]                   }
[17:37:39.027]                   muffleCondition(cond)
[17:37:39.027]                 })
[17:37:39.027]             }))
[17:37:39.027]             future::FutureResult(value = ...future.value$value, 
[17:37:39.027]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.027]                   ...future.rng), globalenv = if (FALSE) 
[17:37:39.027]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:39.027]                     ...future.globalenv.names))
[17:37:39.027]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:39.027]         }, condition = base::local({
[17:37:39.027]             c <- base::c
[17:37:39.027]             inherits <- base::inherits
[17:37:39.027]             invokeRestart <- base::invokeRestart
[17:37:39.027]             length <- base::length
[17:37:39.027]             list <- base::list
[17:37:39.027]             seq.int <- base::seq.int
[17:37:39.027]             signalCondition <- base::signalCondition
[17:37:39.027]             sys.calls <- base::sys.calls
[17:37:39.027]             `[[` <- base::`[[`
[17:37:39.027]             `+` <- base::`+`
[17:37:39.027]             `<<-` <- base::`<<-`
[17:37:39.027]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:39.027]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:39.027]                   3L)]
[17:37:39.027]             }
[17:37:39.027]             function(cond) {
[17:37:39.027]                 is_error <- inherits(cond, "error")
[17:37:39.027]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:39.027]                   NULL)
[17:37:39.027]                 if (is_error) {
[17:37:39.027]                   sessionInformation <- function() {
[17:37:39.027]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:39.027]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:39.027]                       search = base::search(), system = base::Sys.info())
[17:37:39.027]                   }
[17:37:39.027]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.027]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:39.027]                     cond$call), session = sessionInformation(), 
[17:37:39.027]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:39.027]                   signalCondition(cond)
[17:37:39.027]                 }
[17:37:39.027]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:39.027]                 "immediateCondition"))) {
[17:37:39.027]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:39.027]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.027]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:39.027]                   if (TRUE && !signal) {
[17:37:39.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.027]                     {
[17:37:39.027]                       inherits <- base::inherits
[17:37:39.027]                       invokeRestart <- base::invokeRestart
[17:37:39.027]                       is.null <- base::is.null
[17:37:39.027]                       muffled <- FALSE
[17:37:39.027]                       if (inherits(cond, "message")) {
[17:37:39.027]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.027]                         if (muffled) 
[17:37:39.027]                           invokeRestart("muffleMessage")
[17:37:39.027]                       }
[17:37:39.027]                       else if (inherits(cond, "warning")) {
[17:37:39.027]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.027]                         if (muffled) 
[17:37:39.027]                           invokeRestart("muffleWarning")
[17:37:39.027]                       }
[17:37:39.027]                       else if (inherits(cond, "condition")) {
[17:37:39.027]                         if (!is.null(pattern)) {
[17:37:39.027]                           computeRestarts <- base::computeRestarts
[17:37:39.027]                           grepl <- base::grepl
[17:37:39.027]                           restarts <- computeRestarts(cond)
[17:37:39.027]                           for (restart in restarts) {
[17:37:39.027]                             name <- restart$name
[17:37:39.027]                             if (is.null(name)) 
[17:37:39.027]                               next
[17:37:39.027]                             if (!grepl(pattern, name)) 
[17:37:39.027]                               next
[17:37:39.027]                             invokeRestart(restart)
[17:37:39.027]                             muffled <- TRUE
[17:37:39.027]                             break
[17:37:39.027]                           }
[17:37:39.027]                         }
[17:37:39.027]                       }
[17:37:39.027]                       invisible(muffled)
[17:37:39.027]                     }
[17:37:39.027]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.027]                   }
[17:37:39.027]                 }
[17:37:39.027]                 else {
[17:37:39.027]                   if (TRUE) {
[17:37:39.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.027]                     {
[17:37:39.027]                       inherits <- base::inherits
[17:37:39.027]                       invokeRestart <- base::invokeRestart
[17:37:39.027]                       is.null <- base::is.null
[17:37:39.027]                       muffled <- FALSE
[17:37:39.027]                       if (inherits(cond, "message")) {
[17:37:39.027]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.027]                         if (muffled) 
[17:37:39.027]                           invokeRestart("muffleMessage")
[17:37:39.027]                       }
[17:37:39.027]                       else if (inherits(cond, "warning")) {
[17:37:39.027]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.027]                         if (muffled) 
[17:37:39.027]                           invokeRestart("muffleWarning")
[17:37:39.027]                       }
[17:37:39.027]                       else if (inherits(cond, "condition")) {
[17:37:39.027]                         if (!is.null(pattern)) {
[17:37:39.027]                           computeRestarts <- base::computeRestarts
[17:37:39.027]                           grepl <- base::grepl
[17:37:39.027]                           restarts <- computeRestarts(cond)
[17:37:39.027]                           for (restart in restarts) {
[17:37:39.027]                             name <- restart$name
[17:37:39.027]                             if (is.null(name)) 
[17:37:39.027]                               next
[17:37:39.027]                             if (!grepl(pattern, name)) 
[17:37:39.027]                               next
[17:37:39.027]                             invokeRestart(restart)
[17:37:39.027]                             muffled <- TRUE
[17:37:39.027]                             break
[17:37:39.027]                           }
[17:37:39.027]                         }
[17:37:39.027]                       }
[17:37:39.027]                       invisible(muffled)
[17:37:39.027]                     }
[17:37:39.027]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.027]                   }
[17:37:39.027]                 }
[17:37:39.027]             }
[17:37:39.027]         }))
[17:37:39.027]     }, error = function(ex) {
[17:37:39.027]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:39.027]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.027]                 ...future.rng), started = ...future.startTime, 
[17:37:39.027]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:39.027]             version = "1.8"), class = "FutureResult")
[17:37:39.027]     }, finally = {
[17:37:39.027]         if (!identical(...future.workdir, getwd())) 
[17:37:39.027]             setwd(...future.workdir)
[17:37:39.027]         {
[17:37:39.027]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:39.027]                 ...future.oldOptions$nwarnings <- NULL
[17:37:39.027]             }
[17:37:39.027]             base::options(...future.oldOptions)
[17:37:39.027]             if (.Platform$OS.type == "windows") {
[17:37:39.027]                 old_names <- names(...future.oldEnvVars)
[17:37:39.027]                 envs <- base::Sys.getenv()
[17:37:39.027]                 names <- names(envs)
[17:37:39.027]                 common <- intersect(names, old_names)
[17:37:39.027]                 added <- setdiff(names, old_names)
[17:37:39.027]                 removed <- setdiff(old_names, names)
[17:37:39.027]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:39.027]                   envs[common]]
[17:37:39.027]                 NAMES <- toupper(changed)
[17:37:39.027]                 args <- list()
[17:37:39.027]                 for (kk in seq_along(NAMES)) {
[17:37:39.027]                   name <- changed[[kk]]
[17:37:39.027]                   NAME <- NAMES[[kk]]
[17:37:39.027]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.027]                     next
[17:37:39.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.027]                 }
[17:37:39.027]                 NAMES <- toupper(added)
[17:37:39.027]                 for (kk in seq_along(NAMES)) {
[17:37:39.027]                   name <- added[[kk]]
[17:37:39.027]                   NAME <- NAMES[[kk]]
[17:37:39.027]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.027]                     next
[17:37:39.027]                   args[[name]] <- ""
[17:37:39.027]                 }
[17:37:39.027]                 NAMES <- toupper(removed)
[17:37:39.027]                 for (kk in seq_along(NAMES)) {
[17:37:39.027]                   name <- removed[[kk]]
[17:37:39.027]                   NAME <- NAMES[[kk]]
[17:37:39.027]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.027]                     next
[17:37:39.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.027]                 }
[17:37:39.027]                 if (length(args) > 0) 
[17:37:39.027]                   base::do.call(base::Sys.setenv, args = args)
[17:37:39.027]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:39.027]             }
[17:37:39.027]             else {
[17:37:39.027]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:39.027]             }
[17:37:39.027]             {
[17:37:39.027]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:39.027]                   0L) {
[17:37:39.027]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:39.027]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:39.027]                   base::options(opts)
[17:37:39.027]                 }
[17:37:39.027]                 {
[17:37:39.027]                   {
[17:37:39.027]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:39.027]                     NULL
[17:37:39.027]                   }
[17:37:39.027]                   options(future.plan = NULL)
[17:37:39.027]                   if (is.na(NA_character_)) 
[17:37:39.027]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.027]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:39.027]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:39.027]                     .init = FALSE)
[17:37:39.027]                 }
[17:37:39.027]             }
[17:37:39.027]         }
[17:37:39.027]     })
[17:37:39.027]     if (TRUE) {
[17:37:39.027]         base::sink(type = "output", split = FALSE)
[17:37:39.027]         if (TRUE) {
[17:37:39.027]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:39.027]         }
[17:37:39.027]         else {
[17:37:39.027]             ...future.result["stdout"] <- base::list(NULL)
[17:37:39.027]         }
[17:37:39.027]         base::close(...future.stdout)
[17:37:39.027]         ...future.stdout <- NULL
[17:37:39.027]     }
[17:37:39.027]     ...future.result$conditions <- ...future.conditions
[17:37:39.027]     ...future.result$finished <- base::Sys.time()
[17:37:39.027]     ...future.result
[17:37:39.027] }
[17:37:39.029] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[17:37:39.030] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:37:39.030] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:37:39.030] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:37:39.031] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.031] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[17:37:39.031] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[17:37:39.031] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:39.032] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.032] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:39.032] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.032] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[17:37:39.033] MultisessionFuture started
[17:37:39.033] - Launch lazy future ... done
[17:37:39.033] run() for ‘MultisessionFuture’ ... done
[17:37:39.033] Created future:
[17:37:39.033] MultisessionFuture:
[17:37:39.033] Label: ‘future_mapply-1’
[17:37:39.033] Expression:
[17:37:39.033] {
[17:37:39.033]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.033]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:39.033]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.033]         on.exit(options(oopts), add = TRUE)
[17:37:39.033]     }
[17:37:39.033]     {
[17:37:39.033]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.033]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:39.033]         do.call(mapply, args = args)
[17:37:39.033]     }
[17:37:39.033] }
[17:37:39.033] Lazy evaluation: FALSE
[17:37:39.033] Asynchronous evaluation: TRUE
[17:37:39.033] Local evaluation: TRUE
[17:37:39.033] Environment: R_GlobalEnv
[17:37:39.033] Capture standard output: TRUE
[17:37:39.033] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:39.033] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:39.033] Packages: <none>
[17:37:39.033] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:39.033] Resolved: FALSE
[17:37:39.033] Value: <not collected>
[17:37:39.033] Conditions captured: <none>
[17:37:39.033] Early signaling: FALSE
[17:37:39.033] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:39.033] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.045] Chunk #1 of 5 ... DONE
[17:37:39.045] Chunk #2 of 5 ...
[17:37:39.045]  - Finding globals in '...' for chunk #2 ...
[17:37:39.045] getGlobalsAndPackages() ...
[17:37:39.045] Searching for globals...
[17:37:39.046] 
[17:37:39.046] Searching for globals ... DONE
[17:37:39.046] - globals: [0] <none>
[17:37:39.046] getGlobalsAndPackages() ... DONE
[17:37:39.046]    + additional globals found: [n=0] 
[17:37:39.046]    + additional namespaces needed: [n=0] 
[17:37:39.046]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:39.046]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:37:39.046]  - seeds: <none>
[17:37:39.046]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.047] getGlobalsAndPackages() ...
[17:37:39.047] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.047] Resolving globals: FALSE
[17:37:39.047] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:37:39.048] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:39.048] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.048] 
[17:37:39.048] getGlobalsAndPackages() ... DONE
[17:37:39.048] run() for ‘Future’ ...
[17:37:39.048] - state: ‘created’
[17:37:39.048] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:39.062] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.062] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:39.062]   - Field: ‘node’
[17:37:39.062]   - Field: ‘label’
[17:37:39.062]   - Field: ‘local’
[17:37:39.062]   - Field: ‘owner’
[17:37:39.062]   - Field: ‘envir’
[17:37:39.063]   - Field: ‘workers’
[17:37:39.063]   - Field: ‘packages’
[17:37:39.063]   - Field: ‘gc’
[17:37:39.063]   - Field: ‘conditions’
[17:37:39.063]   - Field: ‘persistent’
[17:37:39.063]   - Field: ‘expr’
[17:37:39.063]   - Field: ‘uuid’
[17:37:39.063]   - Field: ‘seed’
[17:37:39.063]   - Field: ‘version’
[17:37:39.063]   - Field: ‘result’
[17:37:39.063]   - Field: ‘asynchronous’
[17:37:39.064]   - Field: ‘calls’
[17:37:39.064]   - Field: ‘globals’
[17:37:39.064]   - Field: ‘stdout’
[17:37:39.064]   - Field: ‘earlySignal’
[17:37:39.064]   - Field: ‘lazy’
[17:37:39.064]   - Field: ‘state’
[17:37:39.064] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:39.064] - Launch lazy future ...
[17:37:39.064] Packages needed by the future expression (n = 0): <none>
[17:37:39.065] Packages needed by future strategies (n = 0): <none>
[17:37:39.065] {
[17:37:39.065]     {
[17:37:39.065]         {
[17:37:39.065]             ...future.startTime <- base::Sys.time()
[17:37:39.065]             {
[17:37:39.065]                 {
[17:37:39.065]                   {
[17:37:39.065]                     {
[17:37:39.065]                       base::local({
[17:37:39.065]                         has_future <- base::requireNamespace("future", 
[17:37:39.065]                           quietly = TRUE)
[17:37:39.065]                         if (has_future) {
[17:37:39.065]                           ns <- base::getNamespace("future")
[17:37:39.065]                           version <- ns[[".package"]][["version"]]
[17:37:39.065]                           if (is.null(version)) 
[17:37:39.065]                             version <- utils::packageVersion("future")
[17:37:39.065]                         }
[17:37:39.065]                         else {
[17:37:39.065]                           version <- NULL
[17:37:39.065]                         }
[17:37:39.065]                         if (!has_future || version < "1.8.0") {
[17:37:39.065]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:39.065]                             "", base::R.version$version.string), 
[17:37:39.065]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:39.065]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:39.065]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:39.065]                               "release", "version")], collapse = " "), 
[17:37:39.065]                             hostname = base::Sys.info()[["nodename"]])
[17:37:39.065]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:39.065]                             info)
[17:37:39.065]                           info <- base::paste(info, collapse = "; ")
[17:37:39.065]                           if (!has_future) {
[17:37:39.065]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:39.065]                               info)
[17:37:39.065]                           }
[17:37:39.065]                           else {
[17:37:39.065]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:39.065]                               info, version)
[17:37:39.065]                           }
[17:37:39.065]                           base::stop(msg)
[17:37:39.065]                         }
[17:37:39.065]                       })
[17:37:39.065]                     }
[17:37:39.065]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:39.065]                     base::options(mc.cores = 1L)
[17:37:39.065]                   }
[17:37:39.065]                   ...future.strategy.old <- future::plan("list")
[17:37:39.065]                   options(future.plan = NULL)
[17:37:39.065]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.065]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:39.065]                 }
[17:37:39.065]                 ...future.workdir <- getwd()
[17:37:39.065]             }
[17:37:39.065]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:39.065]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:39.065]         }
[17:37:39.065]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:39.065]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:37:39.065]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:39.065]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:39.065]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:39.065]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:39.065]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:39.065]             base::names(...future.oldOptions))
[17:37:39.065]     }
[17:37:39.065]     if (FALSE) {
[17:37:39.065]     }
[17:37:39.065]     else {
[17:37:39.065]         if (TRUE) {
[17:37:39.065]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:39.065]                 open = "w")
[17:37:39.065]         }
[17:37:39.065]         else {
[17:37:39.065]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:39.065]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:39.065]         }
[17:37:39.065]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:39.065]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:39.065]             base::sink(type = "output", split = FALSE)
[17:37:39.065]             base::close(...future.stdout)
[17:37:39.065]         }, add = TRUE)
[17:37:39.065]     }
[17:37:39.065]     ...future.frame <- base::sys.nframe()
[17:37:39.065]     ...future.conditions <- base::list()
[17:37:39.065]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:39.065]     if (FALSE) {
[17:37:39.065]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:39.065]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:39.065]     }
[17:37:39.065]     ...future.result <- base::tryCatch({
[17:37:39.065]         base::withCallingHandlers({
[17:37:39.065]             ...future.value <- base::withVisible(base::local({
[17:37:39.065]                 ...future.makeSendCondition <- base::local({
[17:37:39.065]                   sendCondition <- NULL
[17:37:39.065]                   function(frame = 1L) {
[17:37:39.065]                     if (is.function(sendCondition)) 
[17:37:39.065]                       return(sendCondition)
[17:37:39.065]                     ns <- getNamespace("parallel")
[17:37:39.065]                     if (exists("sendData", mode = "function", 
[17:37:39.065]                       envir = ns)) {
[17:37:39.065]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:39.065]                         envir = ns)
[17:37:39.065]                       envir <- sys.frame(frame)
[17:37:39.065]                       master <- NULL
[17:37:39.065]                       while (!identical(envir, .GlobalEnv) && 
[17:37:39.065]                         !identical(envir, emptyenv())) {
[17:37:39.065]                         if (exists("master", mode = "list", envir = envir, 
[17:37:39.065]                           inherits = FALSE)) {
[17:37:39.065]                           master <- get("master", mode = "list", 
[17:37:39.065]                             envir = envir, inherits = FALSE)
[17:37:39.065]                           if (inherits(master, c("SOCKnode", 
[17:37:39.065]                             "SOCK0node"))) {
[17:37:39.065]                             sendCondition <<- function(cond) {
[17:37:39.065]                               data <- list(type = "VALUE", value = cond, 
[17:37:39.065]                                 success = TRUE)
[17:37:39.065]                               parallel_sendData(master, data)
[17:37:39.065]                             }
[17:37:39.065]                             return(sendCondition)
[17:37:39.065]                           }
[17:37:39.065]                         }
[17:37:39.065]                         frame <- frame + 1L
[17:37:39.065]                         envir <- sys.frame(frame)
[17:37:39.065]                       }
[17:37:39.065]                     }
[17:37:39.065]                     sendCondition <<- function(cond) NULL
[17:37:39.065]                   }
[17:37:39.065]                 })
[17:37:39.065]                 withCallingHandlers({
[17:37:39.065]                   {
[17:37:39.065]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.065]                     if (!identical(...future.globals.maxSize.org, 
[17:37:39.065]                       ...future.globals.maxSize)) {
[17:37:39.065]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.065]                       on.exit(options(oopts), add = TRUE)
[17:37:39.065]                     }
[17:37:39.065]                     {
[17:37:39.065]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.065]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:39.065]                         USE.NAMES = FALSE)
[17:37:39.065]                       do.call(mapply, args = args)
[17:37:39.065]                     }
[17:37:39.065]                   }
[17:37:39.065]                 }, immediateCondition = function(cond) {
[17:37:39.065]                   sendCondition <- ...future.makeSendCondition()
[17:37:39.065]                   sendCondition(cond)
[17:37:39.065]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.065]                   {
[17:37:39.065]                     inherits <- base::inherits
[17:37:39.065]                     invokeRestart <- base::invokeRestart
[17:37:39.065]                     is.null <- base::is.null
[17:37:39.065]                     muffled <- FALSE
[17:37:39.065]                     if (inherits(cond, "message")) {
[17:37:39.065]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:39.065]                       if (muffled) 
[17:37:39.065]                         invokeRestart("muffleMessage")
[17:37:39.065]                     }
[17:37:39.065]                     else if (inherits(cond, "warning")) {
[17:37:39.065]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:39.065]                       if (muffled) 
[17:37:39.065]                         invokeRestart("muffleWarning")
[17:37:39.065]                     }
[17:37:39.065]                     else if (inherits(cond, "condition")) {
[17:37:39.065]                       if (!is.null(pattern)) {
[17:37:39.065]                         computeRestarts <- base::computeRestarts
[17:37:39.065]                         grepl <- base::grepl
[17:37:39.065]                         restarts <- computeRestarts(cond)
[17:37:39.065]                         for (restart in restarts) {
[17:37:39.065]                           name <- restart$name
[17:37:39.065]                           if (is.null(name)) 
[17:37:39.065]                             next
[17:37:39.065]                           if (!grepl(pattern, name)) 
[17:37:39.065]                             next
[17:37:39.065]                           invokeRestart(restart)
[17:37:39.065]                           muffled <- TRUE
[17:37:39.065]                           break
[17:37:39.065]                         }
[17:37:39.065]                       }
[17:37:39.065]                     }
[17:37:39.065]                     invisible(muffled)
[17:37:39.065]                   }
[17:37:39.065]                   muffleCondition(cond)
[17:37:39.065]                 })
[17:37:39.065]             }))
[17:37:39.065]             future::FutureResult(value = ...future.value$value, 
[17:37:39.065]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.065]                   ...future.rng), globalenv = if (FALSE) 
[17:37:39.065]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:39.065]                     ...future.globalenv.names))
[17:37:39.065]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:39.065]         }, condition = base::local({
[17:37:39.065]             c <- base::c
[17:37:39.065]             inherits <- base::inherits
[17:37:39.065]             invokeRestart <- base::invokeRestart
[17:37:39.065]             length <- base::length
[17:37:39.065]             list <- base::list
[17:37:39.065]             seq.int <- base::seq.int
[17:37:39.065]             signalCondition <- base::signalCondition
[17:37:39.065]             sys.calls <- base::sys.calls
[17:37:39.065]             `[[` <- base::`[[`
[17:37:39.065]             `+` <- base::`+`
[17:37:39.065]             `<<-` <- base::`<<-`
[17:37:39.065]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:39.065]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:39.065]                   3L)]
[17:37:39.065]             }
[17:37:39.065]             function(cond) {
[17:37:39.065]                 is_error <- inherits(cond, "error")
[17:37:39.065]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:39.065]                   NULL)
[17:37:39.065]                 if (is_error) {
[17:37:39.065]                   sessionInformation <- function() {
[17:37:39.065]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:39.065]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:39.065]                       search = base::search(), system = base::Sys.info())
[17:37:39.065]                   }
[17:37:39.065]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.065]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:39.065]                     cond$call), session = sessionInformation(), 
[17:37:39.065]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:39.065]                   signalCondition(cond)
[17:37:39.065]                 }
[17:37:39.065]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:39.065]                 "immediateCondition"))) {
[17:37:39.065]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:39.065]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.065]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:39.065]                   if (TRUE && !signal) {
[17:37:39.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.065]                     {
[17:37:39.065]                       inherits <- base::inherits
[17:37:39.065]                       invokeRestart <- base::invokeRestart
[17:37:39.065]                       is.null <- base::is.null
[17:37:39.065]                       muffled <- FALSE
[17:37:39.065]                       if (inherits(cond, "message")) {
[17:37:39.065]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.065]                         if (muffled) 
[17:37:39.065]                           invokeRestart("muffleMessage")
[17:37:39.065]                       }
[17:37:39.065]                       else if (inherits(cond, "warning")) {
[17:37:39.065]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.065]                         if (muffled) 
[17:37:39.065]                           invokeRestart("muffleWarning")
[17:37:39.065]                       }
[17:37:39.065]                       else if (inherits(cond, "condition")) {
[17:37:39.065]                         if (!is.null(pattern)) {
[17:37:39.065]                           computeRestarts <- base::computeRestarts
[17:37:39.065]                           grepl <- base::grepl
[17:37:39.065]                           restarts <- computeRestarts(cond)
[17:37:39.065]                           for (restart in restarts) {
[17:37:39.065]                             name <- restart$name
[17:37:39.065]                             if (is.null(name)) 
[17:37:39.065]                               next
[17:37:39.065]                             if (!grepl(pattern, name)) 
[17:37:39.065]                               next
[17:37:39.065]                             invokeRestart(restart)
[17:37:39.065]                             muffled <- TRUE
[17:37:39.065]                             break
[17:37:39.065]                           }
[17:37:39.065]                         }
[17:37:39.065]                       }
[17:37:39.065]                       invisible(muffled)
[17:37:39.065]                     }
[17:37:39.065]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.065]                   }
[17:37:39.065]                 }
[17:37:39.065]                 else {
[17:37:39.065]                   if (TRUE) {
[17:37:39.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.065]                     {
[17:37:39.065]                       inherits <- base::inherits
[17:37:39.065]                       invokeRestart <- base::invokeRestart
[17:37:39.065]                       is.null <- base::is.null
[17:37:39.065]                       muffled <- FALSE
[17:37:39.065]                       if (inherits(cond, "message")) {
[17:37:39.065]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.065]                         if (muffled) 
[17:37:39.065]                           invokeRestart("muffleMessage")
[17:37:39.065]                       }
[17:37:39.065]                       else if (inherits(cond, "warning")) {
[17:37:39.065]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.065]                         if (muffled) 
[17:37:39.065]                           invokeRestart("muffleWarning")
[17:37:39.065]                       }
[17:37:39.065]                       else if (inherits(cond, "condition")) {
[17:37:39.065]                         if (!is.null(pattern)) {
[17:37:39.065]                           computeRestarts <- base::computeRestarts
[17:37:39.065]                           grepl <- base::grepl
[17:37:39.065]                           restarts <- computeRestarts(cond)
[17:37:39.065]                           for (restart in restarts) {
[17:37:39.065]                             name <- restart$name
[17:37:39.065]                             if (is.null(name)) 
[17:37:39.065]                               next
[17:37:39.065]                             if (!grepl(pattern, name)) 
[17:37:39.065]                               next
[17:37:39.065]                             invokeRestart(restart)
[17:37:39.065]                             muffled <- TRUE
[17:37:39.065]                             break
[17:37:39.065]                           }
[17:37:39.065]                         }
[17:37:39.065]                       }
[17:37:39.065]                       invisible(muffled)
[17:37:39.065]                     }
[17:37:39.065]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.065]                   }
[17:37:39.065]                 }
[17:37:39.065]             }
[17:37:39.065]         }))
[17:37:39.065]     }, error = function(ex) {
[17:37:39.065]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:39.065]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.065]                 ...future.rng), started = ...future.startTime, 
[17:37:39.065]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:39.065]             version = "1.8"), class = "FutureResult")
[17:37:39.065]     }, finally = {
[17:37:39.065]         if (!identical(...future.workdir, getwd())) 
[17:37:39.065]             setwd(...future.workdir)
[17:37:39.065]         {
[17:37:39.065]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:39.065]                 ...future.oldOptions$nwarnings <- NULL
[17:37:39.065]             }
[17:37:39.065]             base::options(...future.oldOptions)
[17:37:39.065]             if (.Platform$OS.type == "windows") {
[17:37:39.065]                 old_names <- names(...future.oldEnvVars)
[17:37:39.065]                 envs <- base::Sys.getenv()
[17:37:39.065]                 names <- names(envs)
[17:37:39.065]                 common <- intersect(names, old_names)
[17:37:39.065]                 added <- setdiff(names, old_names)
[17:37:39.065]                 removed <- setdiff(old_names, names)
[17:37:39.065]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:39.065]                   envs[common]]
[17:37:39.065]                 NAMES <- toupper(changed)
[17:37:39.065]                 args <- list()
[17:37:39.065]                 for (kk in seq_along(NAMES)) {
[17:37:39.065]                   name <- changed[[kk]]
[17:37:39.065]                   NAME <- NAMES[[kk]]
[17:37:39.065]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.065]                     next
[17:37:39.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.065]                 }
[17:37:39.065]                 NAMES <- toupper(added)
[17:37:39.065]                 for (kk in seq_along(NAMES)) {
[17:37:39.065]                   name <- added[[kk]]
[17:37:39.065]                   NAME <- NAMES[[kk]]
[17:37:39.065]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.065]                     next
[17:37:39.065]                   args[[name]] <- ""
[17:37:39.065]                 }
[17:37:39.065]                 NAMES <- toupper(removed)
[17:37:39.065]                 for (kk in seq_along(NAMES)) {
[17:37:39.065]                   name <- removed[[kk]]
[17:37:39.065]                   NAME <- NAMES[[kk]]
[17:37:39.065]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.065]                     next
[17:37:39.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.065]                 }
[17:37:39.065]                 if (length(args) > 0) 
[17:37:39.065]                   base::do.call(base::Sys.setenv, args = args)
[17:37:39.065]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:39.065]             }
[17:37:39.065]             else {
[17:37:39.065]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:39.065]             }
[17:37:39.065]             {
[17:37:39.065]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:39.065]                   0L) {
[17:37:39.065]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:39.065]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:39.065]                   base::options(opts)
[17:37:39.065]                 }
[17:37:39.065]                 {
[17:37:39.065]                   {
[17:37:39.065]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:39.065]                     NULL
[17:37:39.065]                   }
[17:37:39.065]                   options(future.plan = NULL)
[17:37:39.065]                   if (is.na(NA_character_)) 
[17:37:39.065]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.065]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:39.065]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:39.065]                     .init = FALSE)
[17:37:39.065]                 }
[17:37:39.065]             }
[17:37:39.065]         }
[17:37:39.065]     })
[17:37:39.065]     if (TRUE) {
[17:37:39.065]         base::sink(type = "output", split = FALSE)
[17:37:39.065]         if (TRUE) {
[17:37:39.065]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:39.065]         }
[17:37:39.065]         else {
[17:37:39.065]             ...future.result["stdout"] <- base::list(NULL)
[17:37:39.065]         }
[17:37:39.065]         base::close(...future.stdout)
[17:37:39.065]         ...future.stdout <- NULL
[17:37:39.065]     }
[17:37:39.065]     ...future.result$conditions <- ...future.conditions
[17:37:39.065]     ...future.result$finished <- base::Sys.time()
[17:37:39.065]     ...future.result
[17:37:39.065] }
[17:37:39.068] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[17:37:39.068] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[17:37:39.068] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[17:37:39.068] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:37:39.069] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:37:39.069] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[17:37:39.069] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[17:37:39.069] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:37:39.070] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:37:39.070] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:37:39.070] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:37:39.070] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[17:37:39.071] MultisessionFuture started
[17:37:39.071] - Launch lazy future ... done
[17:37:39.071] run() for ‘MultisessionFuture’ ... done
[17:37:39.071] Created future:
[17:37:39.071] MultisessionFuture:
[17:37:39.071] Label: ‘future_mapply-2’
[17:37:39.071] Expression:
[17:37:39.071] {
[17:37:39.071]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.071]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:39.071]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.071]         on.exit(options(oopts), add = TRUE)
[17:37:39.071]     }
[17:37:39.071]     {
[17:37:39.071]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.071]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:39.071]         do.call(mapply, args = args)
[17:37:39.071]     }
[17:37:39.071] }
[17:37:39.071] Lazy evaluation: FALSE
[17:37:39.071] Asynchronous evaluation: TRUE
[17:37:39.071] Local evaluation: TRUE
[17:37:39.071] Environment: R_GlobalEnv
[17:37:39.071] Capture standard output: TRUE
[17:37:39.071] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:39.071] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:39.071] Packages: <none>
[17:37:39.071] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:39.071] Resolved: FALSE
[17:37:39.071] Value: <not collected>
[17:37:39.071] Conditions captured: <none>
[17:37:39.071] Early signaling: FALSE
[17:37:39.071] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:39.071] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.083] Chunk #2 of 5 ... DONE
[17:37:39.083] Chunk #3 of 5 ...
[17:37:39.083]  - Finding globals in '...' for chunk #3 ...
[17:37:39.083] getGlobalsAndPackages() ...
[17:37:39.083] Searching for globals...
[17:37:39.084] 
[17:37:39.084] Searching for globals ... DONE
[17:37:39.084] - globals: [0] <none>
[17:37:39.084] getGlobalsAndPackages() ... DONE
[17:37:39.084]    + additional globals found: [n=0] 
[17:37:39.084]    + additional namespaces needed: [n=0] 
[17:37:39.084]  - Finding globals in '...' for chunk #3 ... DONE
[17:37:39.084]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:37:39.085]  - seeds: <none>
[17:37:39.085]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.085] getGlobalsAndPackages() ...
[17:37:39.085] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.085] Resolving globals: FALSE
[17:37:39.085] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:37:39.086] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:39.086] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.086] 
[17:37:39.086] getGlobalsAndPackages() ... DONE
[17:37:39.087] run() for ‘Future’ ...
[17:37:39.087] - state: ‘created’
[17:37:39.087] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:39.101] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.101] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:39.101]   - Field: ‘node’
[17:37:39.101]   - Field: ‘label’
[17:37:39.101]   - Field: ‘local’
[17:37:39.101]   - Field: ‘owner’
[17:37:39.101]   - Field: ‘envir’
[17:37:39.102]   - Field: ‘workers’
[17:37:39.102]   - Field: ‘packages’
[17:37:39.102]   - Field: ‘gc’
[17:37:39.102]   - Field: ‘conditions’
[17:37:39.102]   - Field: ‘persistent’
[17:37:39.102]   - Field: ‘expr’
[17:37:39.102]   - Field: ‘uuid’
[17:37:39.102]   - Field: ‘seed’
[17:37:39.102]   - Field: ‘version’
[17:37:39.102]   - Field: ‘result’
[17:37:39.102]   - Field: ‘asynchronous’
[17:37:39.103]   - Field: ‘calls’
[17:37:39.103]   - Field: ‘globals’
[17:37:39.103]   - Field: ‘stdout’
[17:37:39.103]   - Field: ‘earlySignal’
[17:37:39.103]   - Field: ‘lazy’
[17:37:39.103]   - Field: ‘state’
[17:37:39.103] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:39.103] - Launch lazy future ...
[17:37:39.103] Packages needed by the future expression (n = 0): <none>
[17:37:39.104] Packages needed by future strategies (n = 0): <none>
[17:37:39.104] {
[17:37:39.104]     {
[17:37:39.104]         {
[17:37:39.104]             ...future.startTime <- base::Sys.time()
[17:37:39.104]             {
[17:37:39.104]                 {
[17:37:39.104]                   {
[17:37:39.104]                     {
[17:37:39.104]                       base::local({
[17:37:39.104]                         has_future <- base::requireNamespace("future", 
[17:37:39.104]                           quietly = TRUE)
[17:37:39.104]                         if (has_future) {
[17:37:39.104]                           ns <- base::getNamespace("future")
[17:37:39.104]                           version <- ns[[".package"]][["version"]]
[17:37:39.104]                           if (is.null(version)) 
[17:37:39.104]                             version <- utils::packageVersion("future")
[17:37:39.104]                         }
[17:37:39.104]                         else {
[17:37:39.104]                           version <- NULL
[17:37:39.104]                         }
[17:37:39.104]                         if (!has_future || version < "1.8.0") {
[17:37:39.104]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:39.104]                             "", base::R.version$version.string), 
[17:37:39.104]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:39.104]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:39.104]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:39.104]                               "release", "version")], collapse = " "), 
[17:37:39.104]                             hostname = base::Sys.info()[["nodename"]])
[17:37:39.104]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:39.104]                             info)
[17:37:39.104]                           info <- base::paste(info, collapse = "; ")
[17:37:39.104]                           if (!has_future) {
[17:37:39.104]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:39.104]                               info)
[17:37:39.104]                           }
[17:37:39.104]                           else {
[17:37:39.104]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:39.104]                               info, version)
[17:37:39.104]                           }
[17:37:39.104]                           base::stop(msg)
[17:37:39.104]                         }
[17:37:39.104]                       })
[17:37:39.104]                     }
[17:37:39.104]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:39.104]                     base::options(mc.cores = 1L)
[17:37:39.104]                   }
[17:37:39.104]                   ...future.strategy.old <- future::plan("list")
[17:37:39.104]                   options(future.plan = NULL)
[17:37:39.104]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.104]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:39.104]                 }
[17:37:39.104]                 ...future.workdir <- getwd()
[17:37:39.104]             }
[17:37:39.104]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:39.104]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:39.104]         }
[17:37:39.104]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:39.104]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:37:39.104]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:39.104]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:39.104]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:39.104]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:39.104]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:39.104]             base::names(...future.oldOptions))
[17:37:39.104]     }
[17:37:39.104]     if (FALSE) {
[17:37:39.104]     }
[17:37:39.104]     else {
[17:37:39.104]         if (TRUE) {
[17:37:39.104]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:39.104]                 open = "w")
[17:37:39.104]         }
[17:37:39.104]         else {
[17:37:39.104]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:39.104]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:39.104]         }
[17:37:39.104]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:39.104]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:39.104]             base::sink(type = "output", split = FALSE)
[17:37:39.104]             base::close(...future.stdout)
[17:37:39.104]         }, add = TRUE)
[17:37:39.104]     }
[17:37:39.104]     ...future.frame <- base::sys.nframe()
[17:37:39.104]     ...future.conditions <- base::list()
[17:37:39.104]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:39.104]     if (FALSE) {
[17:37:39.104]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:39.104]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:39.104]     }
[17:37:39.104]     ...future.result <- base::tryCatch({
[17:37:39.104]         base::withCallingHandlers({
[17:37:39.104]             ...future.value <- base::withVisible(base::local({
[17:37:39.104]                 ...future.makeSendCondition <- base::local({
[17:37:39.104]                   sendCondition <- NULL
[17:37:39.104]                   function(frame = 1L) {
[17:37:39.104]                     if (is.function(sendCondition)) 
[17:37:39.104]                       return(sendCondition)
[17:37:39.104]                     ns <- getNamespace("parallel")
[17:37:39.104]                     if (exists("sendData", mode = "function", 
[17:37:39.104]                       envir = ns)) {
[17:37:39.104]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:39.104]                         envir = ns)
[17:37:39.104]                       envir <- sys.frame(frame)
[17:37:39.104]                       master <- NULL
[17:37:39.104]                       while (!identical(envir, .GlobalEnv) && 
[17:37:39.104]                         !identical(envir, emptyenv())) {
[17:37:39.104]                         if (exists("master", mode = "list", envir = envir, 
[17:37:39.104]                           inherits = FALSE)) {
[17:37:39.104]                           master <- get("master", mode = "list", 
[17:37:39.104]                             envir = envir, inherits = FALSE)
[17:37:39.104]                           if (inherits(master, c("SOCKnode", 
[17:37:39.104]                             "SOCK0node"))) {
[17:37:39.104]                             sendCondition <<- function(cond) {
[17:37:39.104]                               data <- list(type = "VALUE", value = cond, 
[17:37:39.104]                                 success = TRUE)
[17:37:39.104]                               parallel_sendData(master, data)
[17:37:39.104]                             }
[17:37:39.104]                             return(sendCondition)
[17:37:39.104]                           }
[17:37:39.104]                         }
[17:37:39.104]                         frame <- frame + 1L
[17:37:39.104]                         envir <- sys.frame(frame)
[17:37:39.104]                       }
[17:37:39.104]                     }
[17:37:39.104]                     sendCondition <<- function(cond) NULL
[17:37:39.104]                   }
[17:37:39.104]                 })
[17:37:39.104]                 withCallingHandlers({
[17:37:39.104]                   {
[17:37:39.104]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.104]                     if (!identical(...future.globals.maxSize.org, 
[17:37:39.104]                       ...future.globals.maxSize)) {
[17:37:39.104]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.104]                       on.exit(options(oopts), add = TRUE)
[17:37:39.104]                     }
[17:37:39.104]                     {
[17:37:39.104]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.104]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:39.104]                         USE.NAMES = FALSE)
[17:37:39.104]                       do.call(mapply, args = args)
[17:37:39.104]                     }
[17:37:39.104]                   }
[17:37:39.104]                 }, immediateCondition = function(cond) {
[17:37:39.104]                   sendCondition <- ...future.makeSendCondition()
[17:37:39.104]                   sendCondition(cond)
[17:37:39.104]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.104]                   {
[17:37:39.104]                     inherits <- base::inherits
[17:37:39.104]                     invokeRestart <- base::invokeRestart
[17:37:39.104]                     is.null <- base::is.null
[17:37:39.104]                     muffled <- FALSE
[17:37:39.104]                     if (inherits(cond, "message")) {
[17:37:39.104]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:39.104]                       if (muffled) 
[17:37:39.104]                         invokeRestart("muffleMessage")
[17:37:39.104]                     }
[17:37:39.104]                     else if (inherits(cond, "warning")) {
[17:37:39.104]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:39.104]                       if (muffled) 
[17:37:39.104]                         invokeRestart("muffleWarning")
[17:37:39.104]                     }
[17:37:39.104]                     else if (inherits(cond, "condition")) {
[17:37:39.104]                       if (!is.null(pattern)) {
[17:37:39.104]                         computeRestarts <- base::computeRestarts
[17:37:39.104]                         grepl <- base::grepl
[17:37:39.104]                         restarts <- computeRestarts(cond)
[17:37:39.104]                         for (restart in restarts) {
[17:37:39.104]                           name <- restart$name
[17:37:39.104]                           if (is.null(name)) 
[17:37:39.104]                             next
[17:37:39.104]                           if (!grepl(pattern, name)) 
[17:37:39.104]                             next
[17:37:39.104]                           invokeRestart(restart)
[17:37:39.104]                           muffled <- TRUE
[17:37:39.104]                           break
[17:37:39.104]                         }
[17:37:39.104]                       }
[17:37:39.104]                     }
[17:37:39.104]                     invisible(muffled)
[17:37:39.104]                   }
[17:37:39.104]                   muffleCondition(cond)
[17:37:39.104]                 })
[17:37:39.104]             }))
[17:37:39.104]             future::FutureResult(value = ...future.value$value, 
[17:37:39.104]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.104]                   ...future.rng), globalenv = if (FALSE) 
[17:37:39.104]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:39.104]                     ...future.globalenv.names))
[17:37:39.104]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:39.104]         }, condition = base::local({
[17:37:39.104]             c <- base::c
[17:37:39.104]             inherits <- base::inherits
[17:37:39.104]             invokeRestart <- base::invokeRestart
[17:37:39.104]             length <- base::length
[17:37:39.104]             list <- base::list
[17:37:39.104]             seq.int <- base::seq.int
[17:37:39.104]             signalCondition <- base::signalCondition
[17:37:39.104]             sys.calls <- base::sys.calls
[17:37:39.104]             `[[` <- base::`[[`
[17:37:39.104]             `+` <- base::`+`
[17:37:39.104]             `<<-` <- base::`<<-`
[17:37:39.104]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:39.104]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:39.104]                   3L)]
[17:37:39.104]             }
[17:37:39.104]             function(cond) {
[17:37:39.104]                 is_error <- inherits(cond, "error")
[17:37:39.104]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:39.104]                   NULL)
[17:37:39.104]                 if (is_error) {
[17:37:39.104]                   sessionInformation <- function() {
[17:37:39.104]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:39.104]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:39.104]                       search = base::search(), system = base::Sys.info())
[17:37:39.104]                   }
[17:37:39.104]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.104]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:39.104]                     cond$call), session = sessionInformation(), 
[17:37:39.104]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:39.104]                   signalCondition(cond)
[17:37:39.104]                 }
[17:37:39.104]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:39.104]                 "immediateCondition"))) {
[17:37:39.104]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:39.104]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.104]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:39.104]                   if (TRUE && !signal) {
[17:37:39.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.104]                     {
[17:37:39.104]                       inherits <- base::inherits
[17:37:39.104]                       invokeRestart <- base::invokeRestart
[17:37:39.104]                       is.null <- base::is.null
[17:37:39.104]                       muffled <- FALSE
[17:37:39.104]                       if (inherits(cond, "message")) {
[17:37:39.104]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.104]                         if (muffled) 
[17:37:39.104]                           invokeRestart("muffleMessage")
[17:37:39.104]                       }
[17:37:39.104]                       else if (inherits(cond, "warning")) {
[17:37:39.104]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.104]                         if (muffled) 
[17:37:39.104]                           invokeRestart("muffleWarning")
[17:37:39.104]                       }
[17:37:39.104]                       else if (inherits(cond, "condition")) {
[17:37:39.104]                         if (!is.null(pattern)) {
[17:37:39.104]                           computeRestarts <- base::computeRestarts
[17:37:39.104]                           grepl <- base::grepl
[17:37:39.104]                           restarts <- computeRestarts(cond)
[17:37:39.104]                           for (restart in restarts) {
[17:37:39.104]                             name <- restart$name
[17:37:39.104]                             if (is.null(name)) 
[17:37:39.104]                               next
[17:37:39.104]                             if (!grepl(pattern, name)) 
[17:37:39.104]                               next
[17:37:39.104]                             invokeRestart(restart)
[17:37:39.104]                             muffled <- TRUE
[17:37:39.104]                             break
[17:37:39.104]                           }
[17:37:39.104]                         }
[17:37:39.104]                       }
[17:37:39.104]                       invisible(muffled)
[17:37:39.104]                     }
[17:37:39.104]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.104]                   }
[17:37:39.104]                 }
[17:37:39.104]                 else {
[17:37:39.104]                   if (TRUE) {
[17:37:39.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.104]                     {
[17:37:39.104]                       inherits <- base::inherits
[17:37:39.104]                       invokeRestart <- base::invokeRestart
[17:37:39.104]                       is.null <- base::is.null
[17:37:39.104]                       muffled <- FALSE
[17:37:39.104]                       if (inherits(cond, "message")) {
[17:37:39.104]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.104]                         if (muffled) 
[17:37:39.104]                           invokeRestart("muffleMessage")
[17:37:39.104]                       }
[17:37:39.104]                       else if (inherits(cond, "warning")) {
[17:37:39.104]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.104]                         if (muffled) 
[17:37:39.104]                           invokeRestart("muffleWarning")
[17:37:39.104]                       }
[17:37:39.104]                       else if (inherits(cond, "condition")) {
[17:37:39.104]                         if (!is.null(pattern)) {
[17:37:39.104]                           computeRestarts <- base::computeRestarts
[17:37:39.104]                           grepl <- base::grepl
[17:37:39.104]                           restarts <- computeRestarts(cond)
[17:37:39.104]                           for (restart in restarts) {
[17:37:39.104]                             name <- restart$name
[17:37:39.104]                             if (is.null(name)) 
[17:37:39.104]                               next
[17:37:39.104]                             if (!grepl(pattern, name)) 
[17:37:39.104]                               next
[17:37:39.104]                             invokeRestart(restart)
[17:37:39.104]                             muffled <- TRUE
[17:37:39.104]                             break
[17:37:39.104]                           }
[17:37:39.104]                         }
[17:37:39.104]                       }
[17:37:39.104]                       invisible(muffled)
[17:37:39.104]                     }
[17:37:39.104]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.104]                   }
[17:37:39.104]                 }
[17:37:39.104]             }
[17:37:39.104]         }))
[17:37:39.104]     }, error = function(ex) {
[17:37:39.104]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:39.104]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.104]                 ...future.rng), started = ...future.startTime, 
[17:37:39.104]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:39.104]             version = "1.8"), class = "FutureResult")
[17:37:39.104]     }, finally = {
[17:37:39.104]         if (!identical(...future.workdir, getwd())) 
[17:37:39.104]             setwd(...future.workdir)
[17:37:39.104]         {
[17:37:39.104]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:39.104]                 ...future.oldOptions$nwarnings <- NULL
[17:37:39.104]             }
[17:37:39.104]             base::options(...future.oldOptions)
[17:37:39.104]             if (.Platform$OS.type == "windows") {
[17:37:39.104]                 old_names <- names(...future.oldEnvVars)
[17:37:39.104]                 envs <- base::Sys.getenv()
[17:37:39.104]                 names <- names(envs)
[17:37:39.104]                 common <- intersect(names, old_names)
[17:37:39.104]                 added <- setdiff(names, old_names)
[17:37:39.104]                 removed <- setdiff(old_names, names)
[17:37:39.104]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:39.104]                   envs[common]]
[17:37:39.104]                 NAMES <- toupper(changed)
[17:37:39.104]                 args <- list()
[17:37:39.104]                 for (kk in seq_along(NAMES)) {
[17:37:39.104]                   name <- changed[[kk]]
[17:37:39.104]                   NAME <- NAMES[[kk]]
[17:37:39.104]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.104]                     next
[17:37:39.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.104]                 }
[17:37:39.104]                 NAMES <- toupper(added)
[17:37:39.104]                 for (kk in seq_along(NAMES)) {
[17:37:39.104]                   name <- added[[kk]]
[17:37:39.104]                   NAME <- NAMES[[kk]]
[17:37:39.104]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.104]                     next
[17:37:39.104]                   args[[name]] <- ""
[17:37:39.104]                 }
[17:37:39.104]                 NAMES <- toupper(removed)
[17:37:39.104]                 for (kk in seq_along(NAMES)) {
[17:37:39.104]                   name <- removed[[kk]]
[17:37:39.104]                   NAME <- NAMES[[kk]]
[17:37:39.104]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.104]                     next
[17:37:39.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.104]                 }
[17:37:39.104]                 if (length(args) > 0) 
[17:37:39.104]                   base::do.call(base::Sys.setenv, args = args)
[17:37:39.104]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:39.104]             }
[17:37:39.104]             else {
[17:37:39.104]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:39.104]             }
[17:37:39.104]             {
[17:37:39.104]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:39.104]                   0L) {
[17:37:39.104]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:39.104]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:39.104]                   base::options(opts)
[17:37:39.104]                 }
[17:37:39.104]                 {
[17:37:39.104]                   {
[17:37:39.104]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:39.104]                     NULL
[17:37:39.104]                   }
[17:37:39.104]                   options(future.plan = NULL)
[17:37:39.104]                   if (is.na(NA_character_)) 
[17:37:39.104]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.104]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:39.104]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:39.104]                     .init = FALSE)
[17:37:39.104]                 }
[17:37:39.104]             }
[17:37:39.104]         }
[17:37:39.104]     })
[17:37:39.104]     if (TRUE) {
[17:37:39.104]         base::sink(type = "output", split = FALSE)
[17:37:39.104]         if (TRUE) {
[17:37:39.104]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:39.104]         }
[17:37:39.104]         else {
[17:37:39.104]             ...future.result["stdout"] <- base::list(NULL)
[17:37:39.104]         }
[17:37:39.104]         base::close(...future.stdout)
[17:37:39.104]         ...future.stdout <- NULL
[17:37:39.104]     }
[17:37:39.104]     ...future.result$conditions <- ...future.conditions
[17:37:39.104]     ...future.result$finished <- base::Sys.time()
[17:37:39.104]     ...future.result
[17:37:39.104] }
[17:37:39.106] Poll #1 (0): usedNodes() = 2, workers = 2
[17:37:39.117] receiveMessageFromWorker() for ClusterFuture ...
[17:37:39.117] - Validating connection of MultisessionFuture
[17:37:39.117] - received message: FutureResult
[17:37:39.118] - Received FutureResult
[17:37:39.118] - Erased future from FutureRegistry
[17:37:39.118] result() for ClusterFuture ...
[17:37:39.118] - result already collected: FutureResult
[17:37:39.118] result() for ClusterFuture ... done
[17:37:39.118] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:39.118] result() for ClusterFuture ...
[17:37:39.118] - result already collected: FutureResult
[17:37:39.118] result() for ClusterFuture ... done
[17:37:39.118] result() for ClusterFuture ...
[17:37:39.119] - result already collected: FutureResult
[17:37:39.119] result() for ClusterFuture ... done
[17:37:39.119] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[17:37:39.120] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:37:39.120] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:37:39.120] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:37:39.120] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.121] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[17:37:39.121] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[17:37:39.121] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:39.121] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.122] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:39.122] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.122] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[17:37:39.123] MultisessionFuture started
[17:37:39.123] - Launch lazy future ... done
[17:37:39.123] run() for ‘MultisessionFuture’ ... done
[17:37:39.123] Created future:
[17:37:39.123] MultisessionFuture:
[17:37:39.123] Label: ‘future_mapply-3’
[17:37:39.123] Expression:
[17:37:39.123] {
[17:37:39.123]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.123]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:39.123]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.123]         on.exit(options(oopts), add = TRUE)
[17:37:39.123]     }
[17:37:39.123]     {
[17:37:39.123]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.123]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:39.123]         do.call(mapply, args = args)
[17:37:39.123]     }
[17:37:39.123] }
[17:37:39.123] Lazy evaluation: FALSE
[17:37:39.123] Asynchronous evaluation: TRUE
[17:37:39.123] Local evaluation: TRUE
[17:37:39.123] Environment: R_GlobalEnv
[17:37:39.123] Capture standard output: TRUE
[17:37:39.123] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:39.123] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:39.123] Packages: <none>
[17:37:39.123] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:39.123] Resolved: FALSE
[17:37:39.123] Value: <not collected>
[17:37:39.123] Conditions captured: <none>
[17:37:39.123] Early signaling: FALSE
[17:37:39.123] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:39.123] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.135] Chunk #3 of 5 ... DONE
[17:37:39.135] Chunk #4 of 5 ...
[17:37:39.135]  - Finding globals in '...' for chunk #4 ...
[17:37:39.135] getGlobalsAndPackages() ...
[17:37:39.135] Searching for globals...
[17:37:39.135] 
[17:37:39.136] Searching for globals ... DONE
[17:37:39.136] - globals: [0] <none>
[17:37:39.136] getGlobalsAndPackages() ... DONE
[17:37:39.136]    + additional globals found: [n=0] 
[17:37:39.136]    + additional namespaces needed: [n=0] 
[17:37:39.136]  - Finding globals in '...' for chunk #4 ... DONE
[17:37:39.136]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:37:39.136]  - seeds: <none>
[17:37:39.136]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.136] getGlobalsAndPackages() ...
[17:37:39.137] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.137] Resolving globals: FALSE
[17:37:39.137] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:37:39.138] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:39.138] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.138] 
[17:37:39.138] getGlobalsAndPackages() ... DONE
[17:37:39.138] run() for ‘Future’ ...
[17:37:39.138] - state: ‘created’
[17:37:39.138] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:39.153] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.153] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:39.153]   - Field: ‘node’
[17:37:39.153]   - Field: ‘label’
[17:37:39.153]   - Field: ‘local’
[17:37:39.153]   - Field: ‘owner’
[17:37:39.153]   - Field: ‘envir’
[17:37:39.153]   - Field: ‘workers’
[17:37:39.154]   - Field: ‘packages’
[17:37:39.154]   - Field: ‘gc’
[17:37:39.154]   - Field: ‘conditions’
[17:37:39.154]   - Field: ‘persistent’
[17:37:39.154]   - Field: ‘expr’
[17:37:39.154]   - Field: ‘uuid’
[17:37:39.154]   - Field: ‘seed’
[17:37:39.154]   - Field: ‘version’
[17:37:39.154]   - Field: ‘result’
[17:37:39.154]   - Field: ‘asynchronous’
[17:37:39.154]   - Field: ‘calls’
[17:37:39.155]   - Field: ‘globals’
[17:37:39.155]   - Field: ‘stdout’
[17:37:39.155]   - Field: ‘earlySignal’
[17:37:39.155]   - Field: ‘lazy’
[17:37:39.155]   - Field: ‘state’
[17:37:39.155] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:39.157] - Launch lazy future ...
[17:37:39.157] Packages needed by the future expression (n = 0): <none>
[17:37:39.158] Packages needed by future strategies (n = 0): <none>
[17:37:39.158] {
[17:37:39.158]     {
[17:37:39.158]         {
[17:37:39.158]             ...future.startTime <- base::Sys.time()
[17:37:39.158]             {
[17:37:39.158]                 {
[17:37:39.158]                   {
[17:37:39.158]                     {
[17:37:39.158]                       base::local({
[17:37:39.158]                         has_future <- base::requireNamespace("future", 
[17:37:39.158]                           quietly = TRUE)
[17:37:39.158]                         if (has_future) {
[17:37:39.158]                           ns <- base::getNamespace("future")
[17:37:39.158]                           version <- ns[[".package"]][["version"]]
[17:37:39.158]                           if (is.null(version)) 
[17:37:39.158]                             version <- utils::packageVersion("future")
[17:37:39.158]                         }
[17:37:39.158]                         else {
[17:37:39.158]                           version <- NULL
[17:37:39.158]                         }
[17:37:39.158]                         if (!has_future || version < "1.8.0") {
[17:37:39.158]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:39.158]                             "", base::R.version$version.string), 
[17:37:39.158]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:39.158]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:39.158]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:39.158]                               "release", "version")], collapse = " "), 
[17:37:39.158]                             hostname = base::Sys.info()[["nodename"]])
[17:37:39.158]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:39.158]                             info)
[17:37:39.158]                           info <- base::paste(info, collapse = "; ")
[17:37:39.158]                           if (!has_future) {
[17:37:39.158]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:39.158]                               info)
[17:37:39.158]                           }
[17:37:39.158]                           else {
[17:37:39.158]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:39.158]                               info, version)
[17:37:39.158]                           }
[17:37:39.158]                           base::stop(msg)
[17:37:39.158]                         }
[17:37:39.158]                       })
[17:37:39.158]                     }
[17:37:39.158]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:39.158]                     base::options(mc.cores = 1L)
[17:37:39.158]                   }
[17:37:39.158]                   ...future.strategy.old <- future::plan("list")
[17:37:39.158]                   options(future.plan = NULL)
[17:37:39.158]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.158]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:39.158]                 }
[17:37:39.158]                 ...future.workdir <- getwd()
[17:37:39.158]             }
[17:37:39.158]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:39.158]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:39.158]         }
[17:37:39.158]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:39.158]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:37:39.158]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:39.158]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:39.158]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:39.158]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:39.158]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:39.158]             base::names(...future.oldOptions))
[17:37:39.158]     }
[17:37:39.158]     if (FALSE) {
[17:37:39.158]     }
[17:37:39.158]     else {
[17:37:39.158]         if (TRUE) {
[17:37:39.158]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:39.158]                 open = "w")
[17:37:39.158]         }
[17:37:39.158]         else {
[17:37:39.158]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:39.158]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:39.158]         }
[17:37:39.158]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:39.158]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:39.158]             base::sink(type = "output", split = FALSE)
[17:37:39.158]             base::close(...future.stdout)
[17:37:39.158]         }, add = TRUE)
[17:37:39.158]     }
[17:37:39.158]     ...future.frame <- base::sys.nframe()
[17:37:39.158]     ...future.conditions <- base::list()
[17:37:39.158]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:39.158]     if (FALSE) {
[17:37:39.158]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:39.158]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:39.158]     }
[17:37:39.158]     ...future.result <- base::tryCatch({
[17:37:39.158]         base::withCallingHandlers({
[17:37:39.158]             ...future.value <- base::withVisible(base::local({
[17:37:39.158]                 ...future.makeSendCondition <- base::local({
[17:37:39.158]                   sendCondition <- NULL
[17:37:39.158]                   function(frame = 1L) {
[17:37:39.158]                     if (is.function(sendCondition)) 
[17:37:39.158]                       return(sendCondition)
[17:37:39.158]                     ns <- getNamespace("parallel")
[17:37:39.158]                     if (exists("sendData", mode = "function", 
[17:37:39.158]                       envir = ns)) {
[17:37:39.158]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:39.158]                         envir = ns)
[17:37:39.158]                       envir <- sys.frame(frame)
[17:37:39.158]                       master <- NULL
[17:37:39.158]                       while (!identical(envir, .GlobalEnv) && 
[17:37:39.158]                         !identical(envir, emptyenv())) {
[17:37:39.158]                         if (exists("master", mode = "list", envir = envir, 
[17:37:39.158]                           inherits = FALSE)) {
[17:37:39.158]                           master <- get("master", mode = "list", 
[17:37:39.158]                             envir = envir, inherits = FALSE)
[17:37:39.158]                           if (inherits(master, c("SOCKnode", 
[17:37:39.158]                             "SOCK0node"))) {
[17:37:39.158]                             sendCondition <<- function(cond) {
[17:37:39.158]                               data <- list(type = "VALUE", value = cond, 
[17:37:39.158]                                 success = TRUE)
[17:37:39.158]                               parallel_sendData(master, data)
[17:37:39.158]                             }
[17:37:39.158]                             return(sendCondition)
[17:37:39.158]                           }
[17:37:39.158]                         }
[17:37:39.158]                         frame <- frame + 1L
[17:37:39.158]                         envir <- sys.frame(frame)
[17:37:39.158]                       }
[17:37:39.158]                     }
[17:37:39.158]                     sendCondition <<- function(cond) NULL
[17:37:39.158]                   }
[17:37:39.158]                 })
[17:37:39.158]                 withCallingHandlers({
[17:37:39.158]                   {
[17:37:39.158]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.158]                     if (!identical(...future.globals.maxSize.org, 
[17:37:39.158]                       ...future.globals.maxSize)) {
[17:37:39.158]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.158]                       on.exit(options(oopts), add = TRUE)
[17:37:39.158]                     }
[17:37:39.158]                     {
[17:37:39.158]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.158]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:39.158]                         USE.NAMES = FALSE)
[17:37:39.158]                       do.call(mapply, args = args)
[17:37:39.158]                     }
[17:37:39.158]                   }
[17:37:39.158]                 }, immediateCondition = function(cond) {
[17:37:39.158]                   sendCondition <- ...future.makeSendCondition()
[17:37:39.158]                   sendCondition(cond)
[17:37:39.158]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.158]                   {
[17:37:39.158]                     inherits <- base::inherits
[17:37:39.158]                     invokeRestart <- base::invokeRestart
[17:37:39.158]                     is.null <- base::is.null
[17:37:39.158]                     muffled <- FALSE
[17:37:39.158]                     if (inherits(cond, "message")) {
[17:37:39.158]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:39.158]                       if (muffled) 
[17:37:39.158]                         invokeRestart("muffleMessage")
[17:37:39.158]                     }
[17:37:39.158]                     else if (inherits(cond, "warning")) {
[17:37:39.158]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:39.158]                       if (muffled) 
[17:37:39.158]                         invokeRestart("muffleWarning")
[17:37:39.158]                     }
[17:37:39.158]                     else if (inherits(cond, "condition")) {
[17:37:39.158]                       if (!is.null(pattern)) {
[17:37:39.158]                         computeRestarts <- base::computeRestarts
[17:37:39.158]                         grepl <- base::grepl
[17:37:39.158]                         restarts <- computeRestarts(cond)
[17:37:39.158]                         for (restart in restarts) {
[17:37:39.158]                           name <- restart$name
[17:37:39.158]                           if (is.null(name)) 
[17:37:39.158]                             next
[17:37:39.158]                           if (!grepl(pattern, name)) 
[17:37:39.158]                             next
[17:37:39.158]                           invokeRestart(restart)
[17:37:39.158]                           muffled <- TRUE
[17:37:39.158]                           break
[17:37:39.158]                         }
[17:37:39.158]                       }
[17:37:39.158]                     }
[17:37:39.158]                     invisible(muffled)
[17:37:39.158]                   }
[17:37:39.158]                   muffleCondition(cond)
[17:37:39.158]                 })
[17:37:39.158]             }))
[17:37:39.158]             future::FutureResult(value = ...future.value$value, 
[17:37:39.158]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.158]                   ...future.rng), globalenv = if (FALSE) 
[17:37:39.158]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:39.158]                     ...future.globalenv.names))
[17:37:39.158]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:39.158]         }, condition = base::local({
[17:37:39.158]             c <- base::c
[17:37:39.158]             inherits <- base::inherits
[17:37:39.158]             invokeRestart <- base::invokeRestart
[17:37:39.158]             length <- base::length
[17:37:39.158]             list <- base::list
[17:37:39.158]             seq.int <- base::seq.int
[17:37:39.158]             signalCondition <- base::signalCondition
[17:37:39.158]             sys.calls <- base::sys.calls
[17:37:39.158]             `[[` <- base::`[[`
[17:37:39.158]             `+` <- base::`+`
[17:37:39.158]             `<<-` <- base::`<<-`
[17:37:39.158]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:39.158]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:39.158]                   3L)]
[17:37:39.158]             }
[17:37:39.158]             function(cond) {
[17:37:39.158]                 is_error <- inherits(cond, "error")
[17:37:39.158]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:39.158]                   NULL)
[17:37:39.158]                 if (is_error) {
[17:37:39.158]                   sessionInformation <- function() {
[17:37:39.158]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:39.158]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:39.158]                       search = base::search(), system = base::Sys.info())
[17:37:39.158]                   }
[17:37:39.158]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.158]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:39.158]                     cond$call), session = sessionInformation(), 
[17:37:39.158]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:39.158]                   signalCondition(cond)
[17:37:39.158]                 }
[17:37:39.158]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:39.158]                 "immediateCondition"))) {
[17:37:39.158]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:39.158]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.158]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:39.158]                   if (TRUE && !signal) {
[17:37:39.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.158]                     {
[17:37:39.158]                       inherits <- base::inherits
[17:37:39.158]                       invokeRestart <- base::invokeRestart
[17:37:39.158]                       is.null <- base::is.null
[17:37:39.158]                       muffled <- FALSE
[17:37:39.158]                       if (inherits(cond, "message")) {
[17:37:39.158]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.158]                         if (muffled) 
[17:37:39.158]                           invokeRestart("muffleMessage")
[17:37:39.158]                       }
[17:37:39.158]                       else if (inherits(cond, "warning")) {
[17:37:39.158]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.158]                         if (muffled) 
[17:37:39.158]                           invokeRestart("muffleWarning")
[17:37:39.158]                       }
[17:37:39.158]                       else if (inherits(cond, "condition")) {
[17:37:39.158]                         if (!is.null(pattern)) {
[17:37:39.158]                           computeRestarts <- base::computeRestarts
[17:37:39.158]                           grepl <- base::grepl
[17:37:39.158]                           restarts <- computeRestarts(cond)
[17:37:39.158]                           for (restart in restarts) {
[17:37:39.158]                             name <- restart$name
[17:37:39.158]                             if (is.null(name)) 
[17:37:39.158]                               next
[17:37:39.158]                             if (!grepl(pattern, name)) 
[17:37:39.158]                               next
[17:37:39.158]                             invokeRestart(restart)
[17:37:39.158]                             muffled <- TRUE
[17:37:39.158]                             break
[17:37:39.158]                           }
[17:37:39.158]                         }
[17:37:39.158]                       }
[17:37:39.158]                       invisible(muffled)
[17:37:39.158]                     }
[17:37:39.158]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.158]                   }
[17:37:39.158]                 }
[17:37:39.158]                 else {
[17:37:39.158]                   if (TRUE) {
[17:37:39.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.158]                     {
[17:37:39.158]                       inherits <- base::inherits
[17:37:39.158]                       invokeRestart <- base::invokeRestart
[17:37:39.158]                       is.null <- base::is.null
[17:37:39.158]                       muffled <- FALSE
[17:37:39.158]                       if (inherits(cond, "message")) {
[17:37:39.158]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.158]                         if (muffled) 
[17:37:39.158]                           invokeRestart("muffleMessage")
[17:37:39.158]                       }
[17:37:39.158]                       else if (inherits(cond, "warning")) {
[17:37:39.158]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.158]                         if (muffled) 
[17:37:39.158]                           invokeRestart("muffleWarning")
[17:37:39.158]                       }
[17:37:39.158]                       else if (inherits(cond, "condition")) {
[17:37:39.158]                         if (!is.null(pattern)) {
[17:37:39.158]                           computeRestarts <- base::computeRestarts
[17:37:39.158]                           grepl <- base::grepl
[17:37:39.158]                           restarts <- computeRestarts(cond)
[17:37:39.158]                           for (restart in restarts) {
[17:37:39.158]                             name <- restart$name
[17:37:39.158]                             if (is.null(name)) 
[17:37:39.158]                               next
[17:37:39.158]                             if (!grepl(pattern, name)) 
[17:37:39.158]                               next
[17:37:39.158]                             invokeRestart(restart)
[17:37:39.158]                             muffled <- TRUE
[17:37:39.158]                             break
[17:37:39.158]                           }
[17:37:39.158]                         }
[17:37:39.158]                       }
[17:37:39.158]                       invisible(muffled)
[17:37:39.158]                     }
[17:37:39.158]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.158]                   }
[17:37:39.158]                 }
[17:37:39.158]             }
[17:37:39.158]         }))
[17:37:39.158]     }, error = function(ex) {
[17:37:39.158]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:39.158]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.158]                 ...future.rng), started = ...future.startTime, 
[17:37:39.158]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:39.158]             version = "1.8"), class = "FutureResult")
[17:37:39.158]     }, finally = {
[17:37:39.158]         if (!identical(...future.workdir, getwd())) 
[17:37:39.158]             setwd(...future.workdir)
[17:37:39.158]         {
[17:37:39.158]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:39.158]                 ...future.oldOptions$nwarnings <- NULL
[17:37:39.158]             }
[17:37:39.158]             base::options(...future.oldOptions)
[17:37:39.158]             if (.Platform$OS.type == "windows") {
[17:37:39.158]                 old_names <- names(...future.oldEnvVars)
[17:37:39.158]                 envs <- base::Sys.getenv()
[17:37:39.158]                 names <- names(envs)
[17:37:39.158]                 common <- intersect(names, old_names)
[17:37:39.158]                 added <- setdiff(names, old_names)
[17:37:39.158]                 removed <- setdiff(old_names, names)
[17:37:39.158]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:39.158]                   envs[common]]
[17:37:39.158]                 NAMES <- toupper(changed)
[17:37:39.158]                 args <- list()
[17:37:39.158]                 for (kk in seq_along(NAMES)) {
[17:37:39.158]                   name <- changed[[kk]]
[17:37:39.158]                   NAME <- NAMES[[kk]]
[17:37:39.158]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.158]                     next
[17:37:39.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.158]                 }
[17:37:39.158]                 NAMES <- toupper(added)
[17:37:39.158]                 for (kk in seq_along(NAMES)) {
[17:37:39.158]                   name <- added[[kk]]
[17:37:39.158]                   NAME <- NAMES[[kk]]
[17:37:39.158]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.158]                     next
[17:37:39.158]                   args[[name]] <- ""
[17:37:39.158]                 }
[17:37:39.158]                 NAMES <- toupper(removed)
[17:37:39.158]                 for (kk in seq_along(NAMES)) {
[17:37:39.158]                   name <- removed[[kk]]
[17:37:39.158]                   NAME <- NAMES[[kk]]
[17:37:39.158]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.158]                     next
[17:37:39.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.158]                 }
[17:37:39.158]                 if (length(args) > 0) 
[17:37:39.158]                   base::do.call(base::Sys.setenv, args = args)
[17:37:39.158]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:39.158]             }
[17:37:39.158]             else {
[17:37:39.158]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:39.158]             }
[17:37:39.158]             {
[17:37:39.158]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:39.158]                   0L) {
[17:37:39.158]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:39.158]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:39.158]                   base::options(opts)
[17:37:39.158]                 }
[17:37:39.158]                 {
[17:37:39.158]                   {
[17:37:39.158]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:39.158]                     NULL
[17:37:39.158]                   }
[17:37:39.158]                   options(future.plan = NULL)
[17:37:39.158]                   if (is.na(NA_character_)) 
[17:37:39.158]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.158]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:39.158]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:39.158]                     .init = FALSE)
[17:37:39.158]                 }
[17:37:39.158]             }
[17:37:39.158]         }
[17:37:39.158]     })
[17:37:39.158]     if (TRUE) {
[17:37:39.158]         base::sink(type = "output", split = FALSE)
[17:37:39.158]         if (TRUE) {
[17:37:39.158]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:39.158]         }
[17:37:39.158]         else {
[17:37:39.158]             ...future.result["stdout"] <- base::list(NULL)
[17:37:39.158]         }
[17:37:39.158]         base::close(...future.stdout)
[17:37:39.158]         ...future.stdout <- NULL
[17:37:39.158]     }
[17:37:39.158]     ...future.result$conditions <- ...future.conditions
[17:37:39.158]     ...future.result$finished <- base::Sys.time()
[17:37:39.158]     ...future.result
[17:37:39.158] }
[17:37:39.160] Poll #1 (0): usedNodes() = 2, workers = 2
[17:37:39.171] receiveMessageFromWorker() for ClusterFuture ...
[17:37:39.171] - Validating connection of MultisessionFuture
[17:37:39.171] - received message: FutureResult
[17:37:39.171] - Received FutureResult
[17:37:39.171] - Erased future from FutureRegistry
[17:37:39.171] result() for ClusterFuture ...
[17:37:39.172] - result already collected: FutureResult
[17:37:39.172] result() for ClusterFuture ... done
[17:37:39.172] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:39.172] result() for ClusterFuture ...
[17:37:39.172] - result already collected: FutureResult
[17:37:39.172] result() for ClusterFuture ... done
[17:37:39.172] result() for ClusterFuture ...
[17:37:39.172] - result already collected: FutureResult
[17:37:39.172] result() for ClusterFuture ... done
[17:37:39.173] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[17:37:39.173] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[17:37:39.174] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[17:37:39.174] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:37:39.174] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:37:39.174] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[17:37:39.175] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[17:37:39.175] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:37:39.175] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:37:39.175] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:37:39.176] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:37:39.176] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[17:37:39.176] MultisessionFuture started
[17:37:39.176] - Launch lazy future ... done
[17:37:39.177] run() for ‘MultisessionFuture’ ... done
[17:37:39.177] Created future:
[17:37:39.177] MultisessionFuture:
[17:37:39.177] Label: ‘future_mapply-4’
[17:37:39.177] Expression:
[17:37:39.177] {
[17:37:39.177]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.177]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:39.177]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.177]         on.exit(options(oopts), add = TRUE)
[17:37:39.177]     }
[17:37:39.177]     {
[17:37:39.177]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.177]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:39.177]         do.call(mapply, args = args)
[17:37:39.177]     }
[17:37:39.177] }
[17:37:39.177] Lazy evaluation: FALSE
[17:37:39.177] Asynchronous evaluation: TRUE
[17:37:39.177] Local evaluation: TRUE
[17:37:39.177] Environment: R_GlobalEnv
[17:37:39.177] Capture standard output: TRUE
[17:37:39.177] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:39.177] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:39.177] Packages: <none>
[17:37:39.177] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:39.177] Resolved: FALSE
[17:37:39.177] Value: <not collected>
[17:37:39.177] Conditions captured: <none>
[17:37:39.177] Early signaling: FALSE
[17:37:39.177] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:39.177] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.188] Chunk #4 of 5 ... DONE
[17:37:39.188] Chunk #5 of 5 ...
[17:37:39.189]  - Finding globals in '...' for chunk #5 ...
[17:37:39.189] getGlobalsAndPackages() ...
[17:37:39.189] Searching for globals...
[17:37:39.189] 
[17:37:39.189] Searching for globals ... DONE
[17:37:39.189] - globals: [0] <none>
[17:37:39.189] getGlobalsAndPackages() ... DONE
[17:37:39.189]    + additional globals found: [n=0] 
[17:37:39.190]    + additional namespaces needed: [n=0] 
[17:37:39.190]  - Finding globals in '...' for chunk #5 ... DONE
[17:37:39.190]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:37:39.190]  - seeds: <none>
[17:37:39.190]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.190] getGlobalsAndPackages() ...
[17:37:39.190] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.190] Resolving globals: FALSE
[17:37:39.191] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:37:39.191] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:39.191] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.191] 
[17:37:39.191] getGlobalsAndPackages() ... DONE
[17:37:39.192] run() for ‘Future’ ...
[17:37:39.192] - state: ‘created’
[17:37:39.192] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:39.206] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.206] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:39.206]   - Field: ‘node’
[17:37:39.206]   - Field: ‘label’
[17:37:39.206]   - Field: ‘local’
[17:37:39.206]   - Field: ‘owner’
[17:37:39.206]   - Field: ‘envir’
[17:37:39.206]   - Field: ‘workers’
[17:37:39.206]   - Field: ‘packages’
[17:37:39.206]   - Field: ‘gc’
[17:37:39.207]   - Field: ‘conditions’
[17:37:39.207]   - Field: ‘persistent’
[17:37:39.207]   - Field: ‘expr’
[17:37:39.207]   - Field: ‘uuid’
[17:37:39.207]   - Field: ‘seed’
[17:37:39.207]   - Field: ‘version’
[17:37:39.207]   - Field: ‘result’
[17:37:39.207]   - Field: ‘asynchronous’
[17:37:39.207]   - Field: ‘calls’
[17:37:39.207]   - Field: ‘globals’
[17:37:39.207]   - Field: ‘stdout’
[17:37:39.207]   - Field: ‘earlySignal’
[17:37:39.208]   - Field: ‘lazy’
[17:37:39.208]   - Field: ‘state’
[17:37:39.208] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:39.208] - Launch lazy future ...
[17:37:39.208] Packages needed by the future expression (n = 0): <none>
[17:37:39.208] Packages needed by future strategies (n = 0): <none>
[17:37:39.209] {
[17:37:39.209]     {
[17:37:39.209]         {
[17:37:39.209]             ...future.startTime <- base::Sys.time()
[17:37:39.209]             {
[17:37:39.209]                 {
[17:37:39.209]                   {
[17:37:39.209]                     {
[17:37:39.209]                       base::local({
[17:37:39.209]                         has_future <- base::requireNamespace("future", 
[17:37:39.209]                           quietly = TRUE)
[17:37:39.209]                         if (has_future) {
[17:37:39.209]                           ns <- base::getNamespace("future")
[17:37:39.209]                           version <- ns[[".package"]][["version"]]
[17:37:39.209]                           if (is.null(version)) 
[17:37:39.209]                             version <- utils::packageVersion("future")
[17:37:39.209]                         }
[17:37:39.209]                         else {
[17:37:39.209]                           version <- NULL
[17:37:39.209]                         }
[17:37:39.209]                         if (!has_future || version < "1.8.0") {
[17:37:39.209]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:39.209]                             "", base::R.version$version.string), 
[17:37:39.209]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:39.209]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:39.209]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:39.209]                               "release", "version")], collapse = " "), 
[17:37:39.209]                             hostname = base::Sys.info()[["nodename"]])
[17:37:39.209]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:39.209]                             info)
[17:37:39.209]                           info <- base::paste(info, collapse = "; ")
[17:37:39.209]                           if (!has_future) {
[17:37:39.209]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:39.209]                               info)
[17:37:39.209]                           }
[17:37:39.209]                           else {
[17:37:39.209]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:39.209]                               info, version)
[17:37:39.209]                           }
[17:37:39.209]                           base::stop(msg)
[17:37:39.209]                         }
[17:37:39.209]                       })
[17:37:39.209]                     }
[17:37:39.209]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:39.209]                     base::options(mc.cores = 1L)
[17:37:39.209]                   }
[17:37:39.209]                   ...future.strategy.old <- future::plan("list")
[17:37:39.209]                   options(future.plan = NULL)
[17:37:39.209]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.209]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:39.209]                 }
[17:37:39.209]                 ...future.workdir <- getwd()
[17:37:39.209]             }
[17:37:39.209]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:39.209]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:39.209]         }
[17:37:39.209]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:39.209]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:37:39.209]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:39.209]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:39.209]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:39.209]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:39.209]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:39.209]             base::names(...future.oldOptions))
[17:37:39.209]     }
[17:37:39.209]     if (FALSE) {
[17:37:39.209]     }
[17:37:39.209]     else {
[17:37:39.209]         if (TRUE) {
[17:37:39.209]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:39.209]                 open = "w")
[17:37:39.209]         }
[17:37:39.209]         else {
[17:37:39.209]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:39.209]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:39.209]         }
[17:37:39.209]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:39.209]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:39.209]             base::sink(type = "output", split = FALSE)
[17:37:39.209]             base::close(...future.stdout)
[17:37:39.209]         }, add = TRUE)
[17:37:39.209]     }
[17:37:39.209]     ...future.frame <- base::sys.nframe()
[17:37:39.209]     ...future.conditions <- base::list()
[17:37:39.209]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:39.209]     if (FALSE) {
[17:37:39.209]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:39.209]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:39.209]     }
[17:37:39.209]     ...future.result <- base::tryCatch({
[17:37:39.209]         base::withCallingHandlers({
[17:37:39.209]             ...future.value <- base::withVisible(base::local({
[17:37:39.209]                 ...future.makeSendCondition <- base::local({
[17:37:39.209]                   sendCondition <- NULL
[17:37:39.209]                   function(frame = 1L) {
[17:37:39.209]                     if (is.function(sendCondition)) 
[17:37:39.209]                       return(sendCondition)
[17:37:39.209]                     ns <- getNamespace("parallel")
[17:37:39.209]                     if (exists("sendData", mode = "function", 
[17:37:39.209]                       envir = ns)) {
[17:37:39.209]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:39.209]                         envir = ns)
[17:37:39.209]                       envir <- sys.frame(frame)
[17:37:39.209]                       master <- NULL
[17:37:39.209]                       while (!identical(envir, .GlobalEnv) && 
[17:37:39.209]                         !identical(envir, emptyenv())) {
[17:37:39.209]                         if (exists("master", mode = "list", envir = envir, 
[17:37:39.209]                           inherits = FALSE)) {
[17:37:39.209]                           master <- get("master", mode = "list", 
[17:37:39.209]                             envir = envir, inherits = FALSE)
[17:37:39.209]                           if (inherits(master, c("SOCKnode", 
[17:37:39.209]                             "SOCK0node"))) {
[17:37:39.209]                             sendCondition <<- function(cond) {
[17:37:39.209]                               data <- list(type = "VALUE", value = cond, 
[17:37:39.209]                                 success = TRUE)
[17:37:39.209]                               parallel_sendData(master, data)
[17:37:39.209]                             }
[17:37:39.209]                             return(sendCondition)
[17:37:39.209]                           }
[17:37:39.209]                         }
[17:37:39.209]                         frame <- frame + 1L
[17:37:39.209]                         envir <- sys.frame(frame)
[17:37:39.209]                       }
[17:37:39.209]                     }
[17:37:39.209]                     sendCondition <<- function(cond) NULL
[17:37:39.209]                   }
[17:37:39.209]                 })
[17:37:39.209]                 withCallingHandlers({
[17:37:39.209]                   {
[17:37:39.209]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.209]                     if (!identical(...future.globals.maxSize.org, 
[17:37:39.209]                       ...future.globals.maxSize)) {
[17:37:39.209]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.209]                       on.exit(options(oopts), add = TRUE)
[17:37:39.209]                     }
[17:37:39.209]                     {
[17:37:39.209]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.209]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:39.209]                         USE.NAMES = FALSE)
[17:37:39.209]                       do.call(mapply, args = args)
[17:37:39.209]                     }
[17:37:39.209]                   }
[17:37:39.209]                 }, immediateCondition = function(cond) {
[17:37:39.209]                   sendCondition <- ...future.makeSendCondition()
[17:37:39.209]                   sendCondition(cond)
[17:37:39.209]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.209]                   {
[17:37:39.209]                     inherits <- base::inherits
[17:37:39.209]                     invokeRestart <- base::invokeRestart
[17:37:39.209]                     is.null <- base::is.null
[17:37:39.209]                     muffled <- FALSE
[17:37:39.209]                     if (inherits(cond, "message")) {
[17:37:39.209]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:39.209]                       if (muffled) 
[17:37:39.209]                         invokeRestart("muffleMessage")
[17:37:39.209]                     }
[17:37:39.209]                     else if (inherits(cond, "warning")) {
[17:37:39.209]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:39.209]                       if (muffled) 
[17:37:39.209]                         invokeRestart("muffleWarning")
[17:37:39.209]                     }
[17:37:39.209]                     else if (inherits(cond, "condition")) {
[17:37:39.209]                       if (!is.null(pattern)) {
[17:37:39.209]                         computeRestarts <- base::computeRestarts
[17:37:39.209]                         grepl <- base::grepl
[17:37:39.209]                         restarts <- computeRestarts(cond)
[17:37:39.209]                         for (restart in restarts) {
[17:37:39.209]                           name <- restart$name
[17:37:39.209]                           if (is.null(name)) 
[17:37:39.209]                             next
[17:37:39.209]                           if (!grepl(pattern, name)) 
[17:37:39.209]                             next
[17:37:39.209]                           invokeRestart(restart)
[17:37:39.209]                           muffled <- TRUE
[17:37:39.209]                           break
[17:37:39.209]                         }
[17:37:39.209]                       }
[17:37:39.209]                     }
[17:37:39.209]                     invisible(muffled)
[17:37:39.209]                   }
[17:37:39.209]                   muffleCondition(cond)
[17:37:39.209]                 })
[17:37:39.209]             }))
[17:37:39.209]             future::FutureResult(value = ...future.value$value, 
[17:37:39.209]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.209]                   ...future.rng), globalenv = if (FALSE) 
[17:37:39.209]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:39.209]                     ...future.globalenv.names))
[17:37:39.209]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:39.209]         }, condition = base::local({
[17:37:39.209]             c <- base::c
[17:37:39.209]             inherits <- base::inherits
[17:37:39.209]             invokeRestart <- base::invokeRestart
[17:37:39.209]             length <- base::length
[17:37:39.209]             list <- base::list
[17:37:39.209]             seq.int <- base::seq.int
[17:37:39.209]             signalCondition <- base::signalCondition
[17:37:39.209]             sys.calls <- base::sys.calls
[17:37:39.209]             `[[` <- base::`[[`
[17:37:39.209]             `+` <- base::`+`
[17:37:39.209]             `<<-` <- base::`<<-`
[17:37:39.209]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:39.209]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:39.209]                   3L)]
[17:37:39.209]             }
[17:37:39.209]             function(cond) {
[17:37:39.209]                 is_error <- inherits(cond, "error")
[17:37:39.209]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:39.209]                   NULL)
[17:37:39.209]                 if (is_error) {
[17:37:39.209]                   sessionInformation <- function() {
[17:37:39.209]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:39.209]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:39.209]                       search = base::search(), system = base::Sys.info())
[17:37:39.209]                   }
[17:37:39.209]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.209]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:39.209]                     cond$call), session = sessionInformation(), 
[17:37:39.209]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:39.209]                   signalCondition(cond)
[17:37:39.209]                 }
[17:37:39.209]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:39.209]                 "immediateCondition"))) {
[17:37:39.209]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:39.209]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.209]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:39.209]                   if (TRUE && !signal) {
[17:37:39.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.209]                     {
[17:37:39.209]                       inherits <- base::inherits
[17:37:39.209]                       invokeRestart <- base::invokeRestart
[17:37:39.209]                       is.null <- base::is.null
[17:37:39.209]                       muffled <- FALSE
[17:37:39.209]                       if (inherits(cond, "message")) {
[17:37:39.209]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.209]                         if (muffled) 
[17:37:39.209]                           invokeRestart("muffleMessage")
[17:37:39.209]                       }
[17:37:39.209]                       else if (inherits(cond, "warning")) {
[17:37:39.209]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.209]                         if (muffled) 
[17:37:39.209]                           invokeRestart("muffleWarning")
[17:37:39.209]                       }
[17:37:39.209]                       else if (inherits(cond, "condition")) {
[17:37:39.209]                         if (!is.null(pattern)) {
[17:37:39.209]                           computeRestarts <- base::computeRestarts
[17:37:39.209]                           grepl <- base::grepl
[17:37:39.209]                           restarts <- computeRestarts(cond)
[17:37:39.209]                           for (restart in restarts) {
[17:37:39.209]                             name <- restart$name
[17:37:39.209]                             if (is.null(name)) 
[17:37:39.209]                               next
[17:37:39.209]                             if (!grepl(pattern, name)) 
[17:37:39.209]                               next
[17:37:39.209]                             invokeRestart(restart)
[17:37:39.209]                             muffled <- TRUE
[17:37:39.209]                             break
[17:37:39.209]                           }
[17:37:39.209]                         }
[17:37:39.209]                       }
[17:37:39.209]                       invisible(muffled)
[17:37:39.209]                     }
[17:37:39.209]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.209]                   }
[17:37:39.209]                 }
[17:37:39.209]                 else {
[17:37:39.209]                   if (TRUE) {
[17:37:39.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.209]                     {
[17:37:39.209]                       inherits <- base::inherits
[17:37:39.209]                       invokeRestart <- base::invokeRestart
[17:37:39.209]                       is.null <- base::is.null
[17:37:39.209]                       muffled <- FALSE
[17:37:39.209]                       if (inherits(cond, "message")) {
[17:37:39.209]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.209]                         if (muffled) 
[17:37:39.209]                           invokeRestart("muffleMessage")
[17:37:39.209]                       }
[17:37:39.209]                       else if (inherits(cond, "warning")) {
[17:37:39.209]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.209]                         if (muffled) 
[17:37:39.209]                           invokeRestart("muffleWarning")
[17:37:39.209]                       }
[17:37:39.209]                       else if (inherits(cond, "condition")) {
[17:37:39.209]                         if (!is.null(pattern)) {
[17:37:39.209]                           computeRestarts <- base::computeRestarts
[17:37:39.209]                           grepl <- base::grepl
[17:37:39.209]                           restarts <- computeRestarts(cond)
[17:37:39.209]                           for (restart in restarts) {
[17:37:39.209]                             name <- restart$name
[17:37:39.209]                             if (is.null(name)) 
[17:37:39.209]                               next
[17:37:39.209]                             if (!grepl(pattern, name)) 
[17:37:39.209]                               next
[17:37:39.209]                             invokeRestart(restart)
[17:37:39.209]                             muffled <- TRUE
[17:37:39.209]                             break
[17:37:39.209]                           }
[17:37:39.209]                         }
[17:37:39.209]                       }
[17:37:39.209]                       invisible(muffled)
[17:37:39.209]                     }
[17:37:39.209]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.209]                   }
[17:37:39.209]                 }
[17:37:39.209]             }
[17:37:39.209]         }))
[17:37:39.209]     }, error = function(ex) {
[17:37:39.209]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:39.209]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.209]                 ...future.rng), started = ...future.startTime, 
[17:37:39.209]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:39.209]             version = "1.8"), class = "FutureResult")
[17:37:39.209]     }, finally = {
[17:37:39.209]         if (!identical(...future.workdir, getwd())) 
[17:37:39.209]             setwd(...future.workdir)
[17:37:39.209]         {
[17:37:39.209]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:39.209]                 ...future.oldOptions$nwarnings <- NULL
[17:37:39.209]             }
[17:37:39.209]             base::options(...future.oldOptions)
[17:37:39.209]             if (.Platform$OS.type == "windows") {
[17:37:39.209]                 old_names <- names(...future.oldEnvVars)
[17:37:39.209]                 envs <- base::Sys.getenv()
[17:37:39.209]                 names <- names(envs)
[17:37:39.209]                 common <- intersect(names, old_names)
[17:37:39.209]                 added <- setdiff(names, old_names)
[17:37:39.209]                 removed <- setdiff(old_names, names)
[17:37:39.209]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:39.209]                   envs[common]]
[17:37:39.209]                 NAMES <- toupper(changed)
[17:37:39.209]                 args <- list()
[17:37:39.209]                 for (kk in seq_along(NAMES)) {
[17:37:39.209]                   name <- changed[[kk]]
[17:37:39.209]                   NAME <- NAMES[[kk]]
[17:37:39.209]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.209]                     next
[17:37:39.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.209]                 }
[17:37:39.209]                 NAMES <- toupper(added)
[17:37:39.209]                 for (kk in seq_along(NAMES)) {
[17:37:39.209]                   name <- added[[kk]]
[17:37:39.209]                   NAME <- NAMES[[kk]]
[17:37:39.209]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.209]                     next
[17:37:39.209]                   args[[name]] <- ""
[17:37:39.209]                 }
[17:37:39.209]                 NAMES <- toupper(removed)
[17:37:39.209]                 for (kk in seq_along(NAMES)) {
[17:37:39.209]                   name <- removed[[kk]]
[17:37:39.209]                   NAME <- NAMES[[kk]]
[17:37:39.209]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.209]                     next
[17:37:39.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.209]                 }
[17:37:39.209]                 if (length(args) > 0) 
[17:37:39.209]                   base::do.call(base::Sys.setenv, args = args)
[17:37:39.209]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:39.209]             }
[17:37:39.209]             else {
[17:37:39.209]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:39.209]             }
[17:37:39.209]             {
[17:37:39.209]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:39.209]                   0L) {
[17:37:39.209]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:39.209]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:39.209]                   base::options(opts)
[17:37:39.209]                 }
[17:37:39.209]                 {
[17:37:39.209]                   {
[17:37:39.209]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:39.209]                     NULL
[17:37:39.209]                   }
[17:37:39.209]                   options(future.plan = NULL)
[17:37:39.209]                   if (is.na(NA_character_)) 
[17:37:39.209]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.209]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:39.209]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:39.209]                     .init = FALSE)
[17:37:39.209]                 }
[17:37:39.209]             }
[17:37:39.209]         }
[17:37:39.209]     })
[17:37:39.209]     if (TRUE) {
[17:37:39.209]         base::sink(type = "output", split = FALSE)
[17:37:39.209]         if (TRUE) {
[17:37:39.209]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:39.209]         }
[17:37:39.209]         else {
[17:37:39.209]             ...future.result["stdout"] <- base::list(NULL)
[17:37:39.209]         }
[17:37:39.209]         base::close(...future.stdout)
[17:37:39.209]         ...future.stdout <- NULL
[17:37:39.209]     }
[17:37:39.209]     ...future.result$conditions <- ...future.conditions
[17:37:39.209]     ...future.result$finished <- base::Sys.time()
[17:37:39.209]     ...future.result
[17:37:39.209] }
[17:37:39.211] Poll #1 (0): usedNodes() = 2, workers = 2
[17:37:39.222] receiveMessageFromWorker() for ClusterFuture ...
[17:37:39.222] - Validating connection of MultisessionFuture
[17:37:39.222] - received message: FutureResult
[17:37:39.222] - Received FutureResult
[17:37:39.222] - Erased future from FutureRegistry
[17:37:39.222] result() for ClusterFuture ...
[17:37:39.222] - result already collected: FutureResult
[17:37:39.222] result() for ClusterFuture ... done
[17:37:39.222] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:39.223] result() for ClusterFuture ...
[17:37:39.223] - result already collected: FutureResult
[17:37:39.223] result() for ClusterFuture ... done
[17:37:39.223] result() for ClusterFuture ...
[17:37:39.223] - result already collected: FutureResult
[17:37:39.223] result() for ClusterFuture ... done
[17:37:39.224] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[17:37:39.224] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:37:39.224] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:37:39.224] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:37:39.225] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.225] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[17:37:39.225] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[17:37:39.225] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:39.226] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.226] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:39.226] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.226] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[17:37:39.227] MultisessionFuture started
[17:37:39.227] - Launch lazy future ... done
[17:37:39.227] run() for ‘MultisessionFuture’ ... done
[17:37:39.227] Created future:
[17:37:39.228] MultisessionFuture:
[17:37:39.228] Label: ‘future_mapply-5’
[17:37:39.228] Expression:
[17:37:39.228] {
[17:37:39.228]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.228]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:39.228]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.228]         on.exit(options(oopts), add = TRUE)
[17:37:39.228]     }
[17:37:39.228]     {
[17:37:39.228]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.228]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:39.228]         do.call(mapply, args = args)
[17:37:39.228]     }
[17:37:39.228] }
[17:37:39.228] Lazy evaluation: FALSE
[17:37:39.228] Asynchronous evaluation: TRUE
[17:37:39.228] Local evaluation: TRUE
[17:37:39.228] Environment: R_GlobalEnv
[17:37:39.228] Capture standard output: TRUE
[17:37:39.228] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:39.228] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:39.228] Packages: <none>
[17:37:39.228] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:39.228] Resolved: FALSE
[17:37:39.228] Value: <not collected>
[17:37:39.228] Conditions captured: <none>
[17:37:39.228] Early signaling: FALSE
[17:37:39.228] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:39.228] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.239] Chunk #5 of 5 ... DONE
[17:37:39.239] Launching 5 futures (chunks) ... DONE
[17:37:39.239] Resolving 5 futures (chunks) ...
[17:37:39.239] resolve() on list ...
[17:37:39.239]  recursive: 0
[17:37:39.239]  length: 5
[17:37:39.240] 
[17:37:39.240] Future #1
[17:37:39.240] result() for ClusterFuture ...
[17:37:39.240] - result already collected: FutureResult
[17:37:39.240] result() for ClusterFuture ... done
[17:37:39.240] result() for ClusterFuture ...
[17:37:39.240] - result already collected: FutureResult
[17:37:39.240] result() for ClusterFuture ... done
[17:37:39.240] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:37:39.241] - nx: 5
[17:37:39.241] - relay: TRUE
[17:37:39.241] - stdout: TRUE
[17:37:39.241] - signal: TRUE
[17:37:39.241] - resignal: FALSE
[17:37:39.241] - force: TRUE
[17:37:39.241] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[17:37:39.241] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[17:37:39.241]  - until=1
[17:37:39.241]  - relaying element #1
[17:37:39.241] result() for ClusterFuture ...
[17:37:39.241] - result already collected: FutureResult
[17:37:39.242] result() for ClusterFuture ... done
[17:37:39.242] result() for ClusterFuture ...
[17:37:39.242] - result already collected: FutureResult
[17:37:39.242] result() for ClusterFuture ... done
[17:37:39.242] result() for ClusterFuture ...
[17:37:39.242] - result already collected: FutureResult
[17:37:39.242] result() for ClusterFuture ... done
[17:37:39.242] result() for ClusterFuture ...
[17:37:39.242] - result already collected: FutureResult
[17:37:39.242] result() for ClusterFuture ... done
[17:37:39.242] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:37:39.242] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:37:39.243] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:37:39.243]  length: 4 (resolved future 1)
[17:37:39.243] Future #2
[17:37:39.243] result() for ClusterFuture ...
[17:37:39.243] - result already collected: FutureResult
[17:37:39.243] result() for ClusterFuture ... done
[17:37:39.243] result() for ClusterFuture ...
[17:37:39.243] - result already collected: FutureResult
[17:37:39.243] result() for ClusterFuture ... done
[17:37:39.243] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:37:39.243] - nx: 5
[17:37:39.244] - relay: TRUE
[17:37:39.244] - stdout: TRUE
[17:37:39.244] - signal: TRUE
[17:37:39.244] - resignal: FALSE
[17:37:39.244] - force: TRUE
[17:37:39.244] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:37:39.244] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:37:39.244]  - until=2
[17:37:39.244]  - relaying element #2
[17:37:39.244] result() for ClusterFuture ...
[17:37:39.244] - result already collected: FutureResult
[17:37:39.244] result() for ClusterFuture ... done
[17:37:39.245] result() for ClusterFuture ...
[17:37:39.245] - result already collected: FutureResult
[17:37:39.245] result() for ClusterFuture ... done
[17:37:39.245] result() for ClusterFuture ...
[17:37:39.245] - result already collected: FutureResult
[17:37:39.245] result() for ClusterFuture ... done
[17:37:39.245] result() for ClusterFuture ...
[17:37:39.245] - result already collected: FutureResult
[17:37:39.245] result() for ClusterFuture ... done
[17:37:39.245] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:37:39.245] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:37:39.245] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:37:39.246]  length: 3 (resolved future 2)
[17:37:39.246] Future #3
[17:37:39.246] result() for ClusterFuture ...
[17:37:39.246] - result already collected: FutureResult
[17:37:39.246] result() for ClusterFuture ... done
[17:37:39.246] result() for ClusterFuture ...
[17:37:39.246] - result already collected: FutureResult
[17:37:39.246] result() for ClusterFuture ... done
[17:37:39.246] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:37:39.246] - nx: 5
[17:37:39.246] - relay: TRUE
[17:37:39.246] - stdout: TRUE
[17:37:39.247] - signal: TRUE
[17:37:39.247] - resignal: FALSE
[17:37:39.247] - force: TRUE
[17:37:39.247] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:37:39.247] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:37:39.247]  - until=3
[17:37:39.247]  - relaying element #3
[17:37:39.247] result() for ClusterFuture ...
[17:37:39.247] - result already collected: FutureResult
[17:37:39.247] result() for ClusterFuture ... done
[17:37:39.247] result() for ClusterFuture ...
[17:37:39.247] - result already collected: FutureResult
[17:37:39.248] result() for ClusterFuture ... done
[17:37:39.248] result() for ClusterFuture ...
[17:37:39.248] - result already collected: FutureResult
[17:37:39.248] result() for ClusterFuture ... done
[17:37:39.248] result() for ClusterFuture ...
[17:37:39.248] - result already collected: FutureResult
[17:37:39.248] result() for ClusterFuture ... done
[17:37:39.248] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:37:39.248] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:37:39.248] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:37:39.248]  length: 2 (resolved future 3)
[17:37:39.249] receiveMessageFromWorker() for ClusterFuture ...
[17:37:39.249] - Validating connection of MultisessionFuture
[17:37:39.249] - received message: FutureResult
[17:37:39.249] - Received FutureResult
[17:37:39.250] - Erased future from FutureRegistry
[17:37:39.250] result() for ClusterFuture ...
[17:37:39.250] - result already collected: FutureResult
[17:37:39.250] result() for ClusterFuture ... done
[17:37:39.250] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:39.250] Future #4
[17:37:39.250] result() for ClusterFuture ...
[17:37:39.250] - result already collected: FutureResult
[17:37:39.250] result() for ClusterFuture ... done
[17:37:39.250] result() for ClusterFuture ...
[17:37:39.250] - result already collected: FutureResult
[17:37:39.250] result() for ClusterFuture ... done
[17:37:39.251] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:37:39.251] - nx: 5
[17:37:39.251] - relay: TRUE
[17:37:39.251] - stdout: TRUE
[17:37:39.251] - signal: TRUE
[17:37:39.251] - resignal: FALSE
[17:37:39.251] - force: TRUE
[17:37:39.251] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:37:39.251] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:37:39.251]  - until=4
[17:37:39.251]  - relaying element #4
[17:37:39.251] result() for ClusterFuture ...
[17:37:39.252] - result already collected: FutureResult
[17:37:39.252] result() for ClusterFuture ... done
[17:37:39.252] result() for ClusterFuture ...
[17:37:39.252] - result already collected: FutureResult
[17:37:39.252] result() for ClusterFuture ... done
[17:37:39.252] result() for ClusterFuture ...
[17:37:39.252] - result already collected: FutureResult
[17:37:39.252] result() for ClusterFuture ... done
[17:37:39.252] result() for ClusterFuture ...
[17:37:39.252] - result already collected: FutureResult
[17:37:39.252] result() for ClusterFuture ... done
[17:37:39.252] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:37:39.253] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:37:39.253] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:37:39.253]  length: 1 (resolved future 4)
[17:37:39.274] receiveMessageFromWorker() for ClusterFuture ...
[17:37:39.274] - Validating connection of MultisessionFuture
[17:37:39.274] - received message: FutureResult
[17:37:39.274] - Received FutureResult
[17:37:39.274] - Erased future from FutureRegistry
[17:37:39.275] result() for ClusterFuture ...
[17:37:39.275] - result already collected: FutureResult
[17:37:39.275] result() for ClusterFuture ... done
[17:37:39.275] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:39.275] Future #5
[17:37:39.275] result() for ClusterFuture ...
[17:37:39.275] - result already collected: FutureResult
[17:37:39.275] result() for ClusterFuture ... done
[17:37:39.275] result() for ClusterFuture ...
[17:37:39.275] - result already collected: FutureResult
[17:37:39.275] result() for ClusterFuture ... done
[17:37:39.276] signalConditionsASAP(MultisessionFuture, pos=5) ...
[17:37:39.276] - nx: 5
[17:37:39.276] - relay: TRUE
[17:37:39.276] - stdout: TRUE
[17:37:39.276] - signal: TRUE
[17:37:39.276] - resignal: FALSE
[17:37:39.276] - force: TRUE
[17:37:39.276] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:37:39.276] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:37:39.276]  - until=5
[17:37:39.276]  - relaying element #5
[17:37:39.277] result() for ClusterFuture ...
[17:37:39.277] - result already collected: FutureResult
[17:37:39.277] result() for ClusterFuture ... done
[17:37:39.277] result() for ClusterFuture ...
[17:37:39.277] - result already collected: FutureResult
[17:37:39.277] result() for ClusterFuture ... done
[17:37:39.277] result() for ClusterFuture ...
[17:37:39.277] - result already collected: FutureResult
[17:37:39.277] result() for ClusterFuture ... done
[17:37:39.277] result() for ClusterFuture ...
[17:37:39.277] - result already collected: FutureResult
[17:37:39.277] result() for ClusterFuture ... done
[17:37:39.278] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:37:39.278] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:37:39.278] signalConditionsASAP(MultisessionFuture, pos=5) ... done
[17:37:39.278]  length: 0 (resolved future 5)
[17:37:39.278] Relaying remaining futures
[17:37:39.278] signalConditionsASAP(NULL, pos=0) ...
[17:37:39.278] - nx: 5
[17:37:39.278] - relay: TRUE
[17:37:39.278] - stdout: TRUE
[17:37:39.278] - signal: TRUE
[17:37:39.278] - resignal: FALSE
[17:37:39.278] - force: TRUE
[17:37:39.279] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:37:39.279] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[17:37:39.279] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:37:39.279] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:37:39.279] signalConditionsASAP(NULL, pos=0) ... done
[17:37:39.279] resolve() on list ... DONE
[17:37:39.279] result() for ClusterFuture ...
[17:37:39.279] - result already collected: FutureResult
[17:37:39.279] result() for ClusterFuture ... done
[17:37:39.279] result() for ClusterFuture ...
[17:37:39.279] - result already collected: FutureResult
[17:37:39.280] result() for ClusterFuture ... done
[17:37:39.280] result() for ClusterFuture ...
[17:37:39.280] - result already collected: FutureResult
[17:37:39.280] result() for ClusterFuture ... done
[17:37:39.280] result() for ClusterFuture ...
[17:37:39.280] - result already collected: FutureResult
[17:37:39.280] result() for ClusterFuture ... done
[17:37:39.280] result() for ClusterFuture ...
[17:37:39.280] - result already collected: FutureResult
[17:37:39.280] result() for ClusterFuture ... done
[17:37:39.280] result() for ClusterFuture ...
[17:37:39.281] - result already collected: FutureResult
[17:37:39.281] result() for ClusterFuture ... done
[17:37:39.281] result() for ClusterFuture ...
[17:37:39.281] - result already collected: FutureResult
[17:37:39.281] result() for ClusterFuture ... done
[17:37:39.281] result() for ClusterFuture ...
[17:37:39.281] - result already collected: FutureResult
[17:37:39.281] result() for ClusterFuture ... done
[17:37:39.281] result() for ClusterFuture ...
[17:37:39.281] - result already collected: FutureResult
[17:37:39.281] result() for ClusterFuture ... done
[17:37:39.281] result() for ClusterFuture ...
[17:37:39.282] - result already collected: FutureResult
[17:37:39.282] result() for ClusterFuture ... done
[17:37:39.282]  - Number of value chunks collected: 5
[17:37:39.282] Resolving 5 futures (chunks) ... DONE
[17:37:39.282] Reducing values from 5 chunks ...
[17:37:39.282]  - Number of values collected after concatenation: 5
[17:37:39.282]  - Number of values expected: 5
[17:37:39.282] Reducing values from 5 chunks ... DONE
[17:37:39.282] future_mapply() ... DONE
[17:37:39.282] future_mapply() ...
[17:37:39.286] Number of chunks: 2
[17:37:39.287] getGlobalsAndPackagesXApply() ...
[17:37:39.287]  - future.globals: TRUE
[17:37:39.287] getGlobalsAndPackages() ...
[17:37:39.287] Searching for globals...
[17:37:39.289] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:37:39.289] Searching for globals ... DONE
[17:37:39.289] Resolving globals: FALSE
[17:37:39.289] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:37:39.290] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:37:39.290] - globals: [1] ‘FUN’
[17:37:39.290] 
[17:37:39.290] getGlobalsAndPackages() ... DONE
[17:37:39.290]  - globals found/used: [n=1] ‘FUN’
[17:37:39.290]  - needed namespaces: [n=0] 
[17:37:39.290] Finding globals ... DONE
[17:37:39.290] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:39.290] List of 2
[17:37:39.290]  $ ...future.FUN:function (C, k)  
[17:37:39.290]  $ MoreArgs     : list()
[17:37:39.290]  - attr(*, "where")=List of 2
[17:37:39.290]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:39.290]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:39.290]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:39.290]  - attr(*, "resolved")= logi FALSE
[17:37:39.290]  - attr(*, "total_size")= num NA
[17:37:39.293] Packages to be attached in all futures: [n=0] 
[17:37:39.293] getGlobalsAndPackagesXApply() ... DONE
[17:37:39.293] Number of futures (= number of chunks): 2
[17:37:39.293] Launching 2 futures (chunks) ...
[17:37:39.293] Chunk #1 of 2 ...
[17:37:39.294]  - Finding globals in '...' for chunk #1 ...
[17:37:39.294] getGlobalsAndPackages() ...
[17:37:39.294] Searching for globals...
[17:37:39.294] 
[17:37:39.294] Searching for globals ... DONE
[17:37:39.294] - globals: [0] <none>
[17:37:39.294] getGlobalsAndPackages() ... DONE
[17:37:39.294]    + additional globals found: [n=0] 
[17:37:39.295]    + additional namespaces needed: [n=0] 
[17:37:39.295]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:39.295]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:39.295]  - seeds: <none>
[17:37:39.295]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.295] getGlobalsAndPackages() ...
[17:37:39.295] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.295] Resolving globals: FALSE
[17:37:39.296] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:37:39.296] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:39.296] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.297] 
[17:37:39.297] getGlobalsAndPackages() ... DONE
[17:37:39.297] run() for ‘Future’ ...
[17:37:39.297] - state: ‘created’
[17:37:39.297] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:39.311] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.311] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:39.311]   - Field: ‘node’
[17:37:39.311]   - Field: ‘label’
[17:37:39.312]   - Field: ‘local’
[17:37:39.312]   - Field: ‘owner’
[17:37:39.312]   - Field: ‘envir’
[17:37:39.312]   - Field: ‘workers’
[17:37:39.312]   - Field: ‘packages’
[17:37:39.312]   - Field: ‘gc’
[17:37:39.312]   - Field: ‘conditions’
[17:37:39.312]   - Field: ‘persistent’
[17:37:39.312]   - Field: ‘expr’
[17:37:39.312]   - Field: ‘uuid’
[17:37:39.313]   - Field: ‘seed’
[17:37:39.313]   - Field: ‘version’
[17:37:39.313]   - Field: ‘result’
[17:37:39.313]   - Field: ‘asynchronous’
[17:37:39.313]   - Field: ‘calls’
[17:37:39.313]   - Field: ‘globals’
[17:37:39.313]   - Field: ‘stdout’
[17:37:39.313]   - Field: ‘earlySignal’
[17:37:39.313]   - Field: ‘lazy’
[17:37:39.313]   - Field: ‘state’
[17:37:39.313] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:39.313] - Launch lazy future ...
[17:37:39.314] Packages needed by the future expression (n = 0): <none>
[17:37:39.314] Packages needed by future strategies (n = 0): <none>
[17:37:39.314] {
[17:37:39.314]     {
[17:37:39.314]         {
[17:37:39.314]             ...future.startTime <- base::Sys.time()
[17:37:39.314]             {
[17:37:39.314]                 {
[17:37:39.314]                   {
[17:37:39.314]                     {
[17:37:39.314]                       base::local({
[17:37:39.314]                         has_future <- base::requireNamespace("future", 
[17:37:39.314]                           quietly = TRUE)
[17:37:39.314]                         if (has_future) {
[17:37:39.314]                           ns <- base::getNamespace("future")
[17:37:39.314]                           version <- ns[[".package"]][["version"]]
[17:37:39.314]                           if (is.null(version)) 
[17:37:39.314]                             version <- utils::packageVersion("future")
[17:37:39.314]                         }
[17:37:39.314]                         else {
[17:37:39.314]                           version <- NULL
[17:37:39.314]                         }
[17:37:39.314]                         if (!has_future || version < "1.8.0") {
[17:37:39.314]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:39.314]                             "", base::R.version$version.string), 
[17:37:39.314]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:39.314]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:39.314]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:39.314]                               "release", "version")], collapse = " "), 
[17:37:39.314]                             hostname = base::Sys.info()[["nodename"]])
[17:37:39.314]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:39.314]                             info)
[17:37:39.314]                           info <- base::paste(info, collapse = "; ")
[17:37:39.314]                           if (!has_future) {
[17:37:39.314]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:39.314]                               info)
[17:37:39.314]                           }
[17:37:39.314]                           else {
[17:37:39.314]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:39.314]                               info, version)
[17:37:39.314]                           }
[17:37:39.314]                           base::stop(msg)
[17:37:39.314]                         }
[17:37:39.314]                       })
[17:37:39.314]                     }
[17:37:39.314]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:39.314]                     base::options(mc.cores = 1L)
[17:37:39.314]                   }
[17:37:39.314]                   ...future.strategy.old <- future::plan("list")
[17:37:39.314]                   options(future.plan = NULL)
[17:37:39.314]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.314]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:39.314]                 }
[17:37:39.314]                 ...future.workdir <- getwd()
[17:37:39.314]             }
[17:37:39.314]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:39.314]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:39.314]         }
[17:37:39.314]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:39.314]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:39.314]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:39.314]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:39.314]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:39.314]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:39.314]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:39.314]             base::names(...future.oldOptions))
[17:37:39.314]     }
[17:37:39.314]     if (FALSE) {
[17:37:39.314]     }
[17:37:39.314]     else {
[17:37:39.314]         if (TRUE) {
[17:37:39.314]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:39.314]                 open = "w")
[17:37:39.314]         }
[17:37:39.314]         else {
[17:37:39.314]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:39.314]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:39.314]         }
[17:37:39.314]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:39.314]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:39.314]             base::sink(type = "output", split = FALSE)
[17:37:39.314]             base::close(...future.stdout)
[17:37:39.314]         }, add = TRUE)
[17:37:39.314]     }
[17:37:39.314]     ...future.frame <- base::sys.nframe()
[17:37:39.314]     ...future.conditions <- base::list()
[17:37:39.314]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:39.314]     if (FALSE) {
[17:37:39.314]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:39.314]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:39.314]     }
[17:37:39.314]     ...future.result <- base::tryCatch({
[17:37:39.314]         base::withCallingHandlers({
[17:37:39.314]             ...future.value <- base::withVisible(base::local({
[17:37:39.314]                 ...future.makeSendCondition <- base::local({
[17:37:39.314]                   sendCondition <- NULL
[17:37:39.314]                   function(frame = 1L) {
[17:37:39.314]                     if (is.function(sendCondition)) 
[17:37:39.314]                       return(sendCondition)
[17:37:39.314]                     ns <- getNamespace("parallel")
[17:37:39.314]                     if (exists("sendData", mode = "function", 
[17:37:39.314]                       envir = ns)) {
[17:37:39.314]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:39.314]                         envir = ns)
[17:37:39.314]                       envir <- sys.frame(frame)
[17:37:39.314]                       master <- NULL
[17:37:39.314]                       while (!identical(envir, .GlobalEnv) && 
[17:37:39.314]                         !identical(envir, emptyenv())) {
[17:37:39.314]                         if (exists("master", mode = "list", envir = envir, 
[17:37:39.314]                           inherits = FALSE)) {
[17:37:39.314]                           master <- get("master", mode = "list", 
[17:37:39.314]                             envir = envir, inherits = FALSE)
[17:37:39.314]                           if (inherits(master, c("SOCKnode", 
[17:37:39.314]                             "SOCK0node"))) {
[17:37:39.314]                             sendCondition <<- function(cond) {
[17:37:39.314]                               data <- list(type = "VALUE", value = cond, 
[17:37:39.314]                                 success = TRUE)
[17:37:39.314]                               parallel_sendData(master, data)
[17:37:39.314]                             }
[17:37:39.314]                             return(sendCondition)
[17:37:39.314]                           }
[17:37:39.314]                         }
[17:37:39.314]                         frame <- frame + 1L
[17:37:39.314]                         envir <- sys.frame(frame)
[17:37:39.314]                       }
[17:37:39.314]                     }
[17:37:39.314]                     sendCondition <<- function(cond) NULL
[17:37:39.314]                   }
[17:37:39.314]                 })
[17:37:39.314]                 withCallingHandlers({
[17:37:39.314]                   {
[17:37:39.314]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.314]                     if (!identical(...future.globals.maxSize.org, 
[17:37:39.314]                       ...future.globals.maxSize)) {
[17:37:39.314]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.314]                       on.exit(options(oopts), add = TRUE)
[17:37:39.314]                     }
[17:37:39.314]                     {
[17:37:39.314]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.314]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:39.314]                         USE.NAMES = FALSE)
[17:37:39.314]                       do.call(mapply, args = args)
[17:37:39.314]                     }
[17:37:39.314]                   }
[17:37:39.314]                 }, immediateCondition = function(cond) {
[17:37:39.314]                   sendCondition <- ...future.makeSendCondition()
[17:37:39.314]                   sendCondition(cond)
[17:37:39.314]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.314]                   {
[17:37:39.314]                     inherits <- base::inherits
[17:37:39.314]                     invokeRestart <- base::invokeRestart
[17:37:39.314]                     is.null <- base::is.null
[17:37:39.314]                     muffled <- FALSE
[17:37:39.314]                     if (inherits(cond, "message")) {
[17:37:39.314]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:39.314]                       if (muffled) 
[17:37:39.314]                         invokeRestart("muffleMessage")
[17:37:39.314]                     }
[17:37:39.314]                     else if (inherits(cond, "warning")) {
[17:37:39.314]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:39.314]                       if (muffled) 
[17:37:39.314]                         invokeRestart("muffleWarning")
[17:37:39.314]                     }
[17:37:39.314]                     else if (inherits(cond, "condition")) {
[17:37:39.314]                       if (!is.null(pattern)) {
[17:37:39.314]                         computeRestarts <- base::computeRestarts
[17:37:39.314]                         grepl <- base::grepl
[17:37:39.314]                         restarts <- computeRestarts(cond)
[17:37:39.314]                         for (restart in restarts) {
[17:37:39.314]                           name <- restart$name
[17:37:39.314]                           if (is.null(name)) 
[17:37:39.314]                             next
[17:37:39.314]                           if (!grepl(pattern, name)) 
[17:37:39.314]                             next
[17:37:39.314]                           invokeRestart(restart)
[17:37:39.314]                           muffled <- TRUE
[17:37:39.314]                           break
[17:37:39.314]                         }
[17:37:39.314]                       }
[17:37:39.314]                     }
[17:37:39.314]                     invisible(muffled)
[17:37:39.314]                   }
[17:37:39.314]                   muffleCondition(cond)
[17:37:39.314]                 })
[17:37:39.314]             }))
[17:37:39.314]             future::FutureResult(value = ...future.value$value, 
[17:37:39.314]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.314]                   ...future.rng), globalenv = if (FALSE) 
[17:37:39.314]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:39.314]                     ...future.globalenv.names))
[17:37:39.314]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:39.314]         }, condition = base::local({
[17:37:39.314]             c <- base::c
[17:37:39.314]             inherits <- base::inherits
[17:37:39.314]             invokeRestart <- base::invokeRestart
[17:37:39.314]             length <- base::length
[17:37:39.314]             list <- base::list
[17:37:39.314]             seq.int <- base::seq.int
[17:37:39.314]             signalCondition <- base::signalCondition
[17:37:39.314]             sys.calls <- base::sys.calls
[17:37:39.314]             `[[` <- base::`[[`
[17:37:39.314]             `+` <- base::`+`
[17:37:39.314]             `<<-` <- base::`<<-`
[17:37:39.314]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:39.314]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:39.314]                   3L)]
[17:37:39.314]             }
[17:37:39.314]             function(cond) {
[17:37:39.314]                 is_error <- inherits(cond, "error")
[17:37:39.314]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:39.314]                   NULL)
[17:37:39.314]                 if (is_error) {
[17:37:39.314]                   sessionInformation <- function() {
[17:37:39.314]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:39.314]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:39.314]                       search = base::search(), system = base::Sys.info())
[17:37:39.314]                   }
[17:37:39.314]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.314]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:39.314]                     cond$call), session = sessionInformation(), 
[17:37:39.314]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:39.314]                   signalCondition(cond)
[17:37:39.314]                 }
[17:37:39.314]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:39.314]                 "immediateCondition"))) {
[17:37:39.314]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:39.314]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.314]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:39.314]                   if (TRUE && !signal) {
[17:37:39.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.314]                     {
[17:37:39.314]                       inherits <- base::inherits
[17:37:39.314]                       invokeRestart <- base::invokeRestart
[17:37:39.314]                       is.null <- base::is.null
[17:37:39.314]                       muffled <- FALSE
[17:37:39.314]                       if (inherits(cond, "message")) {
[17:37:39.314]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.314]                         if (muffled) 
[17:37:39.314]                           invokeRestart("muffleMessage")
[17:37:39.314]                       }
[17:37:39.314]                       else if (inherits(cond, "warning")) {
[17:37:39.314]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.314]                         if (muffled) 
[17:37:39.314]                           invokeRestart("muffleWarning")
[17:37:39.314]                       }
[17:37:39.314]                       else if (inherits(cond, "condition")) {
[17:37:39.314]                         if (!is.null(pattern)) {
[17:37:39.314]                           computeRestarts <- base::computeRestarts
[17:37:39.314]                           grepl <- base::grepl
[17:37:39.314]                           restarts <- computeRestarts(cond)
[17:37:39.314]                           for (restart in restarts) {
[17:37:39.314]                             name <- restart$name
[17:37:39.314]                             if (is.null(name)) 
[17:37:39.314]                               next
[17:37:39.314]                             if (!grepl(pattern, name)) 
[17:37:39.314]                               next
[17:37:39.314]                             invokeRestart(restart)
[17:37:39.314]                             muffled <- TRUE
[17:37:39.314]                             break
[17:37:39.314]                           }
[17:37:39.314]                         }
[17:37:39.314]                       }
[17:37:39.314]                       invisible(muffled)
[17:37:39.314]                     }
[17:37:39.314]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.314]                   }
[17:37:39.314]                 }
[17:37:39.314]                 else {
[17:37:39.314]                   if (TRUE) {
[17:37:39.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.314]                     {
[17:37:39.314]                       inherits <- base::inherits
[17:37:39.314]                       invokeRestart <- base::invokeRestart
[17:37:39.314]                       is.null <- base::is.null
[17:37:39.314]                       muffled <- FALSE
[17:37:39.314]                       if (inherits(cond, "message")) {
[17:37:39.314]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.314]                         if (muffled) 
[17:37:39.314]                           invokeRestart("muffleMessage")
[17:37:39.314]                       }
[17:37:39.314]                       else if (inherits(cond, "warning")) {
[17:37:39.314]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.314]                         if (muffled) 
[17:37:39.314]                           invokeRestart("muffleWarning")
[17:37:39.314]                       }
[17:37:39.314]                       else if (inherits(cond, "condition")) {
[17:37:39.314]                         if (!is.null(pattern)) {
[17:37:39.314]                           computeRestarts <- base::computeRestarts
[17:37:39.314]                           grepl <- base::grepl
[17:37:39.314]                           restarts <- computeRestarts(cond)
[17:37:39.314]                           for (restart in restarts) {
[17:37:39.314]                             name <- restart$name
[17:37:39.314]                             if (is.null(name)) 
[17:37:39.314]                               next
[17:37:39.314]                             if (!grepl(pattern, name)) 
[17:37:39.314]                               next
[17:37:39.314]                             invokeRestart(restart)
[17:37:39.314]                             muffled <- TRUE
[17:37:39.314]                             break
[17:37:39.314]                           }
[17:37:39.314]                         }
[17:37:39.314]                       }
[17:37:39.314]                       invisible(muffled)
[17:37:39.314]                     }
[17:37:39.314]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.314]                   }
[17:37:39.314]                 }
[17:37:39.314]             }
[17:37:39.314]         }))
[17:37:39.314]     }, error = function(ex) {
[17:37:39.314]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:39.314]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.314]                 ...future.rng), started = ...future.startTime, 
[17:37:39.314]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:39.314]             version = "1.8"), class = "FutureResult")
[17:37:39.314]     }, finally = {
[17:37:39.314]         if (!identical(...future.workdir, getwd())) 
[17:37:39.314]             setwd(...future.workdir)
[17:37:39.314]         {
[17:37:39.314]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:39.314]                 ...future.oldOptions$nwarnings <- NULL
[17:37:39.314]             }
[17:37:39.314]             base::options(...future.oldOptions)
[17:37:39.314]             if (.Platform$OS.type == "windows") {
[17:37:39.314]                 old_names <- names(...future.oldEnvVars)
[17:37:39.314]                 envs <- base::Sys.getenv()
[17:37:39.314]                 names <- names(envs)
[17:37:39.314]                 common <- intersect(names, old_names)
[17:37:39.314]                 added <- setdiff(names, old_names)
[17:37:39.314]                 removed <- setdiff(old_names, names)
[17:37:39.314]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:39.314]                   envs[common]]
[17:37:39.314]                 NAMES <- toupper(changed)
[17:37:39.314]                 args <- list()
[17:37:39.314]                 for (kk in seq_along(NAMES)) {
[17:37:39.314]                   name <- changed[[kk]]
[17:37:39.314]                   NAME <- NAMES[[kk]]
[17:37:39.314]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.314]                     next
[17:37:39.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.314]                 }
[17:37:39.314]                 NAMES <- toupper(added)
[17:37:39.314]                 for (kk in seq_along(NAMES)) {
[17:37:39.314]                   name <- added[[kk]]
[17:37:39.314]                   NAME <- NAMES[[kk]]
[17:37:39.314]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.314]                     next
[17:37:39.314]                   args[[name]] <- ""
[17:37:39.314]                 }
[17:37:39.314]                 NAMES <- toupper(removed)
[17:37:39.314]                 for (kk in seq_along(NAMES)) {
[17:37:39.314]                   name <- removed[[kk]]
[17:37:39.314]                   NAME <- NAMES[[kk]]
[17:37:39.314]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.314]                     next
[17:37:39.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.314]                 }
[17:37:39.314]                 if (length(args) > 0) 
[17:37:39.314]                   base::do.call(base::Sys.setenv, args = args)
[17:37:39.314]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:39.314]             }
[17:37:39.314]             else {
[17:37:39.314]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:39.314]             }
[17:37:39.314]             {
[17:37:39.314]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:39.314]                   0L) {
[17:37:39.314]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:39.314]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:39.314]                   base::options(opts)
[17:37:39.314]                 }
[17:37:39.314]                 {
[17:37:39.314]                   {
[17:37:39.314]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:39.314]                     NULL
[17:37:39.314]                   }
[17:37:39.314]                   options(future.plan = NULL)
[17:37:39.314]                   if (is.na(NA_character_)) 
[17:37:39.314]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.314]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:39.314]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:39.314]                     .init = FALSE)
[17:37:39.314]                 }
[17:37:39.314]             }
[17:37:39.314]         }
[17:37:39.314]     })
[17:37:39.314]     if (TRUE) {
[17:37:39.314]         base::sink(type = "output", split = FALSE)
[17:37:39.314]         if (TRUE) {
[17:37:39.314]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:39.314]         }
[17:37:39.314]         else {
[17:37:39.314]             ...future.result["stdout"] <- base::list(NULL)
[17:37:39.314]         }
[17:37:39.314]         base::close(...future.stdout)
[17:37:39.314]         ...future.stdout <- NULL
[17:37:39.314]     }
[17:37:39.314]     ...future.result$conditions <- ...future.conditions
[17:37:39.314]     ...future.result$finished <- base::Sys.time()
[17:37:39.314]     ...future.result
[17:37:39.314] }
[17:37:39.317] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[17:37:39.317] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:37:39.318] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:37:39.318] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:37:39.318] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.318] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[17:37:39.319] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[17:37:39.319] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:39.319] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.319] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:39.320] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.320] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[17:37:39.320] MultisessionFuture started
[17:37:39.321] - Launch lazy future ... done
[17:37:39.321] run() for ‘MultisessionFuture’ ... done
[17:37:39.321] Created future:
[17:37:39.321] MultisessionFuture:
[17:37:39.321] Label: ‘future_.mapply-1’
[17:37:39.321] Expression:
[17:37:39.321] {
[17:37:39.321]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.321]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:39.321]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.321]         on.exit(options(oopts), add = TRUE)
[17:37:39.321]     }
[17:37:39.321]     {
[17:37:39.321]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.321]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:39.321]         do.call(mapply, args = args)
[17:37:39.321]     }
[17:37:39.321] }
[17:37:39.321] Lazy evaluation: FALSE
[17:37:39.321] Asynchronous evaluation: TRUE
[17:37:39.321] Local evaluation: TRUE
[17:37:39.321] Environment: R_GlobalEnv
[17:37:39.321] Capture standard output: TRUE
[17:37:39.321] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:39.321] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:39.321] Packages: <none>
[17:37:39.321] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:39.321] Resolved: FALSE
[17:37:39.321] Value: <not collected>
[17:37:39.321] Conditions captured: <none>
[17:37:39.321] Early signaling: FALSE
[17:37:39.321] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:39.321] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.332] Chunk #1 of 2 ... DONE
[17:37:39.333] Chunk #2 of 2 ...
[17:37:39.333]  - Finding globals in '...' for chunk #2 ...
[17:37:39.333] getGlobalsAndPackages() ...
[17:37:39.333] Searching for globals...
[17:37:39.333] 
[17:37:39.333] Searching for globals ... DONE
[17:37:39.334] - globals: [0] <none>
[17:37:39.334] getGlobalsAndPackages() ... DONE
[17:37:39.334]    + additional globals found: [n=0] 
[17:37:39.334]    + additional namespaces needed: [n=0] 
[17:37:39.334]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:39.334]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:39.334]  - seeds: <none>
[17:37:39.334]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.334] getGlobalsAndPackages() ...
[17:37:39.334] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.334] Resolving globals: FALSE
[17:37:39.335] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:37:39.335] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:39.336] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.336] 
[17:37:39.336] getGlobalsAndPackages() ... DONE
[17:37:39.336] run() for ‘Future’ ...
[17:37:39.336] - state: ‘created’
[17:37:39.336] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:39.352] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.352] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:39.353]   - Field: ‘node’
[17:37:39.353]   - Field: ‘label’
[17:37:39.353]   - Field: ‘local’
[17:37:39.353]   - Field: ‘owner’
[17:37:39.353]   - Field: ‘envir’
[17:37:39.353]   - Field: ‘workers’
[17:37:39.353]   - Field: ‘packages’
[17:37:39.353]   - Field: ‘gc’
[17:37:39.353]   - Field: ‘conditions’
[17:37:39.353]   - Field: ‘persistent’
[17:37:39.353]   - Field: ‘expr’
[17:37:39.354]   - Field: ‘uuid’
[17:37:39.354]   - Field: ‘seed’
[17:37:39.354]   - Field: ‘version’
[17:37:39.354]   - Field: ‘result’
[17:37:39.354]   - Field: ‘asynchronous’
[17:37:39.354]   - Field: ‘calls’
[17:37:39.354]   - Field: ‘globals’
[17:37:39.354]   - Field: ‘stdout’
[17:37:39.354]   - Field: ‘earlySignal’
[17:37:39.354]   - Field: ‘lazy’
[17:37:39.354]   - Field: ‘state’
[17:37:39.354] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:39.355] - Launch lazy future ...
[17:37:39.355] Packages needed by the future expression (n = 0): <none>
[17:37:39.355] Packages needed by future strategies (n = 0): <none>
[17:37:39.355] {
[17:37:39.355]     {
[17:37:39.355]         {
[17:37:39.355]             ...future.startTime <- base::Sys.time()
[17:37:39.355]             {
[17:37:39.355]                 {
[17:37:39.355]                   {
[17:37:39.355]                     {
[17:37:39.355]                       base::local({
[17:37:39.355]                         has_future <- base::requireNamespace("future", 
[17:37:39.355]                           quietly = TRUE)
[17:37:39.355]                         if (has_future) {
[17:37:39.355]                           ns <- base::getNamespace("future")
[17:37:39.355]                           version <- ns[[".package"]][["version"]]
[17:37:39.355]                           if (is.null(version)) 
[17:37:39.355]                             version <- utils::packageVersion("future")
[17:37:39.355]                         }
[17:37:39.355]                         else {
[17:37:39.355]                           version <- NULL
[17:37:39.355]                         }
[17:37:39.355]                         if (!has_future || version < "1.8.0") {
[17:37:39.355]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:39.355]                             "", base::R.version$version.string), 
[17:37:39.355]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:39.355]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:39.355]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:39.355]                               "release", "version")], collapse = " "), 
[17:37:39.355]                             hostname = base::Sys.info()[["nodename"]])
[17:37:39.355]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:39.355]                             info)
[17:37:39.355]                           info <- base::paste(info, collapse = "; ")
[17:37:39.355]                           if (!has_future) {
[17:37:39.355]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:39.355]                               info)
[17:37:39.355]                           }
[17:37:39.355]                           else {
[17:37:39.355]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:39.355]                               info, version)
[17:37:39.355]                           }
[17:37:39.355]                           base::stop(msg)
[17:37:39.355]                         }
[17:37:39.355]                       })
[17:37:39.355]                     }
[17:37:39.355]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:39.355]                     base::options(mc.cores = 1L)
[17:37:39.355]                   }
[17:37:39.355]                   ...future.strategy.old <- future::plan("list")
[17:37:39.355]                   options(future.plan = NULL)
[17:37:39.355]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.355]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:39.355]                 }
[17:37:39.355]                 ...future.workdir <- getwd()
[17:37:39.355]             }
[17:37:39.355]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:39.355]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:39.355]         }
[17:37:39.355]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:39.355]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:39.355]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:39.355]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:39.355]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:39.355]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:39.355]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:39.355]             base::names(...future.oldOptions))
[17:37:39.355]     }
[17:37:39.355]     if (FALSE) {
[17:37:39.355]     }
[17:37:39.355]     else {
[17:37:39.355]         if (TRUE) {
[17:37:39.355]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:39.355]                 open = "w")
[17:37:39.355]         }
[17:37:39.355]         else {
[17:37:39.355]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:39.355]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:39.355]         }
[17:37:39.355]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:39.355]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:39.355]             base::sink(type = "output", split = FALSE)
[17:37:39.355]             base::close(...future.stdout)
[17:37:39.355]         }, add = TRUE)
[17:37:39.355]     }
[17:37:39.355]     ...future.frame <- base::sys.nframe()
[17:37:39.355]     ...future.conditions <- base::list()
[17:37:39.355]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:39.355]     if (FALSE) {
[17:37:39.355]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:39.355]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:39.355]     }
[17:37:39.355]     ...future.result <- base::tryCatch({
[17:37:39.355]         base::withCallingHandlers({
[17:37:39.355]             ...future.value <- base::withVisible(base::local({
[17:37:39.355]                 ...future.makeSendCondition <- base::local({
[17:37:39.355]                   sendCondition <- NULL
[17:37:39.355]                   function(frame = 1L) {
[17:37:39.355]                     if (is.function(sendCondition)) 
[17:37:39.355]                       return(sendCondition)
[17:37:39.355]                     ns <- getNamespace("parallel")
[17:37:39.355]                     if (exists("sendData", mode = "function", 
[17:37:39.355]                       envir = ns)) {
[17:37:39.355]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:39.355]                         envir = ns)
[17:37:39.355]                       envir <- sys.frame(frame)
[17:37:39.355]                       master <- NULL
[17:37:39.355]                       while (!identical(envir, .GlobalEnv) && 
[17:37:39.355]                         !identical(envir, emptyenv())) {
[17:37:39.355]                         if (exists("master", mode = "list", envir = envir, 
[17:37:39.355]                           inherits = FALSE)) {
[17:37:39.355]                           master <- get("master", mode = "list", 
[17:37:39.355]                             envir = envir, inherits = FALSE)
[17:37:39.355]                           if (inherits(master, c("SOCKnode", 
[17:37:39.355]                             "SOCK0node"))) {
[17:37:39.355]                             sendCondition <<- function(cond) {
[17:37:39.355]                               data <- list(type = "VALUE", value = cond, 
[17:37:39.355]                                 success = TRUE)
[17:37:39.355]                               parallel_sendData(master, data)
[17:37:39.355]                             }
[17:37:39.355]                             return(sendCondition)
[17:37:39.355]                           }
[17:37:39.355]                         }
[17:37:39.355]                         frame <- frame + 1L
[17:37:39.355]                         envir <- sys.frame(frame)
[17:37:39.355]                       }
[17:37:39.355]                     }
[17:37:39.355]                     sendCondition <<- function(cond) NULL
[17:37:39.355]                   }
[17:37:39.355]                 })
[17:37:39.355]                 withCallingHandlers({
[17:37:39.355]                   {
[17:37:39.355]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.355]                     if (!identical(...future.globals.maxSize.org, 
[17:37:39.355]                       ...future.globals.maxSize)) {
[17:37:39.355]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.355]                       on.exit(options(oopts), add = TRUE)
[17:37:39.355]                     }
[17:37:39.355]                     {
[17:37:39.355]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.355]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:39.355]                         USE.NAMES = FALSE)
[17:37:39.355]                       do.call(mapply, args = args)
[17:37:39.355]                     }
[17:37:39.355]                   }
[17:37:39.355]                 }, immediateCondition = function(cond) {
[17:37:39.355]                   sendCondition <- ...future.makeSendCondition()
[17:37:39.355]                   sendCondition(cond)
[17:37:39.355]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.355]                   {
[17:37:39.355]                     inherits <- base::inherits
[17:37:39.355]                     invokeRestart <- base::invokeRestart
[17:37:39.355]                     is.null <- base::is.null
[17:37:39.355]                     muffled <- FALSE
[17:37:39.355]                     if (inherits(cond, "message")) {
[17:37:39.355]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:39.355]                       if (muffled) 
[17:37:39.355]                         invokeRestart("muffleMessage")
[17:37:39.355]                     }
[17:37:39.355]                     else if (inherits(cond, "warning")) {
[17:37:39.355]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:39.355]                       if (muffled) 
[17:37:39.355]                         invokeRestart("muffleWarning")
[17:37:39.355]                     }
[17:37:39.355]                     else if (inherits(cond, "condition")) {
[17:37:39.355]                       if (!is.null(pattern)) {
[17:37:39.355]                         computeRestarts <- base::computeRestarts
[17:37:39.355]                         grepl <- base::grepl
[17:37:39.355]                         restarts <- computeRestarts(cond)
[17:37:39.355]                         for (restart in restarts) {
[17:37:39.355]                           name <- restart$name
[17:37:39.355]                           if (is.null(name)) 
[17:37:39.355]                             next
[17:37:39.355]                           if (!grepl(pattern, name)) 
[17:37:39.355]                             next
[17:37:39.355]                           invokeRestart(restart)
[17:37:39.355]                           muffled <- TRUE
[17:37:39.355]                           break
[17:37:39.355]                         }
[17:37:39.355]                       }
[17:37:39.355]                     }
[17:37:39.355]                     invisible(muffled)
[17:37:39.355]                   }
[17:37:39.355]                   muffleCondition(cond)
[17:37:39.355]                 })
[17:37:39.355]             }))
[17:37:39.355]             future::FutureResult(value = ...future.value$value, 
[17:37:39.355]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.355]                   ...future.rng), globalenv = if (FALSE) 
[17:37:39.355]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:39.355]                     ...future.globalenv.names))
[17:37:39.355]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:39.355]         }, condition = base::local({
[17:37:39.355]             c <- base::c
[17:37:39.355]             inherits <- base::inherits
[17:37:39.355]             invokeRestart <- base::invokeRestart
[17:37:39.355]             length <- base::length
[17:37:39.355]             list <- base::list
[17:37:39.355]             seq.int <- base::seq.int
[17:37:39.355]             signalCondition <- base::signalCondition
[17:37:39.355]             sys.calls <- base::sys.calls
[17:37:39.355]             `[[` <- base::`[[`
[17:37:39.355]             `+` <- base::`+`
[17:37:39.355]             `<<-` <- base::`<<-`
[17:37:39.355]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:39.355]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:39.355]                   3L)]
[17:37:39.355]             }
[17:37:39.355]             function(cond) {
[17:37:39.355]                 is_error <- inherits(cond, "error")
[17:37:39.355]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:39.355]                   NULL)
[17:37:39.355]                 if (is_error) {
[17:37:39.355]                   sessionInformation <- function() {
[17:37:39.355]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:39.355]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:39.355]                       search = base::search(), system = base::Sys.info())
[17:37:39.355]                   }
[17:37:39.355]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.355]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:39.355]                     cond$call), session = sessionInformation(), 
[17:37:39.355]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:39.355]                   signalCondition(cond)
[17:37:39.355]                 }
[17:37:39.355]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:39.355]                 "immediateCondition"))) {
[17:37:39.355]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:39.355]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.355]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:39.355]                   if (TRUE && !signal) {
[17:37:39.355]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.355]                     {
[17:37:39.355]                       inherits <- base::inherits
[17:37:39.355]                       invokeRestart <- base::invokeRestart
[17:37:39.355]                       is.null <- base::is.null
[17:37:39.355]                       muffled <- FALSE
[17:37:39.355]                       if (inherits(cond, "message")) {
[17:37:39.355]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.355]                         if (muffled) 
[17:37:39.355]                           invokeRestart("muffleMessage")
[17:37:39.355]                       }
[17:37:39.355]                       else if (inherits(cond, "warning")) {
[17:37:39.355]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.355]                         if (muffled) 
[17:37:39.355]                           invokeRestart("muffleWarning")
[17:37:39.355]                       }
[17:37:39.355]                       else if (inherits(cond, "condition")) {
[17:37:39.355]                         if (!is.null(pattern)) {
[17:37:39.355]                           computeRestarts <- base::computeRestarts
[17:37:39.355]                           grepl <- base::grepl
[17:37:39.355]                           restarts <- computeRestarts(cond)
[17:37:39.355]                           for (restart in restarts) {
[17:37:39.355]                             name <- restart$name
[17:37:39.355]                             if (is.null(name)) 
[17:37:39.355]                               next
[17:37:39.355]                             if (!grepl(pattern, name)) 
[17:37:39.355]                               next
[17:37:39.355]                             invokeRestart(restart)
[17:37:39.355]                             muffled <- TRUE
[17:37:39.355]                             break
[17:37:39.355]                           }
[17:37:39.355]                         }
[17:37:39.355]                       }
[17:37:39.355]                       invisible(muffled)
[17:37:39.355]                     }
[17:37:39.355]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.355]                   }
[17:37:39.355]                 }
[17:37:39.355]                 else {
[17:37:39.355]                   if (TRUE) {
[17:37:39.355]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.355]                     {
[17:37:39.355]                       inherits <- base::inherits
[17:37:39.355]                       invokeRestart <- base::invokeRestart
[17:37:39.355]                       is.null <- base::is.null
[17:37:39.355]                       muffled <- FALSE
[17:37:39.355]                       if (inherits(cond, "message")) {
[17:37:39.355]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.355]                         if (muffled) 
[17:37:39.355]                           invokeRestart("muffleMessage")
[17:37:39.355]                       }
[17:37:39.355]                       else if (inherits(cond, "warning")) {
[17:37:39.355]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.355]                         if (muffled) 
[17:37:39.355]                           invokeRestart("muffleWarning")
[17:37:39.355]                       }
[17:37:39.355]                       else if (inherits(cond, "condition")) {
[17:37:39.355]                         if (!is.null(pattern)) {
[17:37:39.355]                           computeRestarts <- base::computeRestarts
[17:37:39.355]                           grepl <- base::grepl
[17:37:39.355]                           restarts <- computeRestarts(cond)
[17:37:39.355]                           for (restart in restarts) {
[17:37:39.355]                             name <- restart$name
[17:37:39.355]                             if (is.null(name)) 
[17:37:39.355]                               next
[17:37:39.355]                             if (!grepl(pattern, name)) 
[17:37:39.355]                               next
[17:37:39.355]                             invokeRestart(restart)
[17:37:39.355]                             muffled <- TRUE
[17:37:39.355]                             break
[17:37:39.355]                           }
[17:37:39.355]                         }
[17:37:39.355]                       }
[17:37:39.355]                       invisible(muffled)
[17:37:39.355]                     }
[17:37:39.355]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.355]                   }
[17:37:39.355]                 }
[17:37:39.355]             }
[17:37:39.355]         }))
[17:37:39.355]     }, error = function(ex) {
[17:37:39.355]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:39.355]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.355]                 ...future.rng), started = ...future.startTime, 
[17:37:39.355]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:39.355]             version = "1.8"), class = "FutureResult")
[17:37:39.355]     }, finally = {
[17:37:39.355]         if (!identical(...future.workdir, getwd())) 
[17:37:39.355]             setwd(...future.workdir)
[17:37:39.355]         {
[17:37:39.355]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:39.355]                 ...future.oldOptions$nwarnings <- NULL
[17:37:39.355]             }
[17:37:39.355]             base::options(...future.oldOptions)
[17:37:39.355]             if (.Platform$OS.type == "windows") {
[17:37:39.355]                 old_names <- names(...future.oldEnvVars)
[17:37:39.355]                 envs <- base::Sys.getenv()
[17:37:39.355]                 names <- names(envs)
[17:37:39.355]                 common <- intersect(names, old_names)
[17:37:39.355]                 added <- setdiff(names, old_names)
[17:37:39.355]                 removed <- setdiff(old_names, names)
[17:37:39.355]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:39.355]                   envs[common]]
[17:37:39.355]                 NAMES <- toupper(changed)
[17:37:39.355]                 args <- list()
[17:37:39.355]                 for (kk in seq_along(NAMES)) {
[17:37:39.355]                   name <- changed[[kk]]
[17:37:39.355]                   NAME <- NAMES[[kk]]
[17:37:39.355]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.355]                     next
[17:37:39.355]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.355]                 }
[17:37:39.355]                 NAMES <- toupper(added)
[17:37:39.355]                 for (kk in seq_along(NAMES)) {
[17:37:39.355]                   name <- added[[kk]]
[17:37:39.355]                   NAME <- NAMES[[kk]]
[17:37:39.355]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.355]                     next
[17:37:39.355]                   args[[name]] <- ""
[17:37:39.355]                 }
[17:37:39.355]                 NAMES <- toupper(removed)
[17:37:39.355]                 for (kk in seq_along(NAMES)) {
[17:37:39.355]                   name <- removed[[kk]]
[17:37:39.355]                   NAME <- NAMES[[kk]]
[17:37:39.355]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.355]                     next
[17:37:39.355]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.355]                 }
[17:37:39.355]                 if (length(args) > 0) 
[17:37:39.355]                   base::do.call(base::Sys.setenv, args = args)
[17:37:39.355]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:39.355]             }
[17:37:39.355]             else {
[17:37:39.355]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:39.355]             }
[17:37:39.355]             {
[17:37:39.355]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:39.355]                   0L) {
[17:37:39.355]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:39.355]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:39.355]                   base::options(opts)
[17:37:39.355]                 }
[17:37:39.355]                 {
[17:37:39.355]                   {
[17:37:39.355]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:39.355]                     NULL
[17:37:39.355]                   }
[17:37:39.355]                   options(future.plan = NULL)
[17:37:39.355]                   if (is.na(NA_character_)) 
[17:37:39.355]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.355]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:39.355]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:39.355]                     .init = FALSE)
[17:37:39.355]                 }
[17:37:39.355]             }
[17:37:39.355]         }
[17:37:39.355]     })
[17:37:39.355]     if (TRUE) {
[17:37:39.355]         base::sink(type = "output", split = FALSE)
[17:37:39.355]         if (TRUE) {
[17:37:39.355]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:39.355]         }
[17:37:39.355]         else {
[17:37:39.355]             ...future.result["stdout"] <- base::list(NULL)
[17:37:39.355]         }
[17:37:39.355]         base::close(...future.stdout)
[17:37:39.355]         ...future.stdout <- NULL
[17:37:39.355]     }
[17:37:39.355]     ...future.result$conditions <- ...future.conditions
[17:37:39.355]     ...future.result$finished <- base::Sys.time()
[17:37:39.355]     ...future.result
[17:37:39.355] }
[17:37:39.358] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[17:37:39.358] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[17:37:39.359] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[17:37:39.359] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:37:39.359] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:37:39.359] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[17:37:39.359] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[17:37:39.360] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:37:39.360] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:37:39.360] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:37:39.360] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:37:39.360] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[17:37:39.361] MultisessionFuture started
[17:37:39.361] - Launch lazy future ... done
[17:37:39.361] run() for ‘MultisessionFuture’ ... done
[17:37:39.361] Created future:
[17:37:39.361] MultisessionFuture:
[17:37:39.361] Label: ‘future_.mapply-2’
[17:37:39.361] Expression:
[17:37:39.361] {
[17:37:39.361]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.361]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:39.361]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.361]         on.exit(options(oopts), add = TRUE)
[17:37:39.361]     }
[17:37:39.361]     {
[17:37:39.361]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.361]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:39.361]         do.call(mapply, args = args)
[17:37:39.361]     }
[17:37:39.361] }
[17:37:39.361] Lazy evaluation: FALSE
[17:37:39.361] Asynchronous evaluation: TRUE
[17:37:39.361] Local evaluation: TRUE
[17:37:39.361] Environment: R_GlobalEnv
[17:37:39.361] Capture standard output: TRUE
[17:37:39.361] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:39.361] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:39.361] Packages: <none>
[17:37:39.361] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:39.361] Resolved: FALSE
[17:37:39.361] Value: <not collected>
[17:37:39.361] Conditions captured: <none>
[17:37:39.361] Early signaling: FALSE
[17:37:39.361] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:39.361] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.373] Chunk #2 of 2 ... DONE
[17:37:39.373] Launching 2 futures (chunks) ... DONE
[17:37:39.373] Resolving 2 futures (chunks) ...
[17:37:39.373] resolve() on list ...
[17:37:39.373]  recursive: 0
[17:37:39.373]  length: 2
[17:37:39.373] 
[17:37:39.374] receiveMessageFromWorker() for ClusterFuture ...
[17:37:39.374] - Validating connection of MultisessionFuture
[17:37:39.374] - received message: FutureResult
[17:37:39.374] - Received FutureResult
[17:37:39.374] - Erased future from FutureRegistry
[17:37:39.375] result() for ClusterFuture ...
[17:37:39.375] - result already collected: FutureResult
[17:37:39.375] result() for ClusterFuture ... done
[17:37:39.375] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:39.375] Future #1
[17:37:39.375] result() for ClusterFuture ...
[17:37:39.375] - result already collected: FutureResult
[17:37:39.375] result() for ClusterFuture ... done
[17:37:39.375] result() for ClusterFuture ...
[17:37:39.375] - result already collected: FutureResult
[17:37:39.375] result() for ClusterFuture ... done
[17:37:39.375] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:37:39.376] - nx: 2
[17:37:39.376] - relay: TRUE
[17:37:39.376] - stdout: TRUE
[17:37:39.376] - signal: TRUE
[17:37:39.376] - resignal: FALSE
[17:37:39.376] - force: TRUE
[17:37:39.376] - relayed: [n=2] FALSE, FALSE
[17:37:39.376] - queued futures: [n=2] FALSE, FALSE
[17:37:39.376]  - until=1
[17:37:39.376]  - relaying element #1
[17:37:39.376] result() for ClusterFuture ...
[17:37:39.377] - result already collected: FutureResult
[17:37:39.377] result() for ClusterFuture ... done
[17:37:39.377] result() for ClusterFuture ...
[17:37:39.377] - result already collected: FutureResult
[17:37:39.377] result() for ClusterFuture ... done
[17:37:39.377] result() for ClusterFuture ...
[17:37:39.377] - result already collected: FutureResult
[17:37:39.377] result() for ClusterFuture ... done
[17:37:39.377] result() for ClusterFuture ...
[17:37:39.377] - result already collected: FutureResult
[17:37:39.377] result() for ClusterFuture ... done
[17:37:39.377] - relayed: [n=2] TRUE, FALSE
[17:37:39.378] - queued futures: [n=2] TRUE, FALSE
[17:37:39.378] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:37:39.378]  length: 1 (resolved future 1)
[17:37:39.406] receiveMessageFromWorker() for ClusterFuture ...
[17:37:39.406] - Validating connection of MultisessionFuture
[17:37:39.407] - received message: FutureResult
[17:37:39.407] - Received FutureResult
[17:37:39.407] - Erased future from FutureRegistry
[17:37:39.407] result() for ClusterFuture ...
[17:37:39.407] - result already collected: FutureResult
[17:37:39.407] result() for ClusterFuture ... done
[17:37:39.407] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:39.407] Future #2
[17:37:39.407] result() for ClusterFuture ...
[17:37:39.407] - result already collected: FutureResult
[17:37:39.408] result() for ClusterFuture ... done
[17:37:39.408] result() for ClusterFuture ...
[17:37:39.408] - result already collected: FutureResult
[17:37:39.408] result() for ClusterFuture ... done
[17:37:39.408] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:37:39.408] - nx: 2
[17:37:39.408] - relay: TRUE
[17:37:39.408] - stdout: TRUE
[17:37:39.408] - signal: TRUE
[17:37:39.408] - resignal: FALSE
[17:37:39.408] - force: TRUE
[17:37:39.409] - relayed: [n=2] TRUE, FALSE
[17:37:39.409] - queued futures: [n=2] TRUE, FALSE
[17:37:39.409]  - until=2
[17:37:39.409]  - relaying element #2
[17:37:39.409] result() for ClusterFuture ...
[17:37:39.409] - result already collected: FutureResult
[17:37:39.409] result() for ClusterFuture ... done
[17:37:39.409] result() for ClusterFuture ...
[17:37:39.409] - result already collected: FutureResult
[17:37:39.409] result() for ClusterFuture ... done
[17:37:39.409] result() for ClusterFuture ...
[17:37:39.409] - result already collected: FutureResult
[17:37:39.410] result() for ClusterFuture ... done
[17:37:39.410] result() for ClusterFuture ...
[17:37:39.410] - result already collected: FutureResult
[17:37:39.410] result() for ClusterFuture ... done
[17:37:39.410] - relayed: [n=2] TRUE, TRUE
[17:37:39.410] - queued futures: [n=2] TRUE, TRUE
[17:37:39.410] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:37:39.410]  length: 0 (resolved future 2)
[17:37:39.410] Relaying remaining futures
[17:37:39.410] signalConditionsASAP(NULL, pos=0) ...
[17:37:39.410] - nx: 2
[17:37:39.410] - relay: TRUE
[17:37:39.411] - stdout: TRUE
[17:37:39.411] - signal: TRUE
[17:37:39.411] - resignal: FALSE
[17:37:39.411] - force: TRUE
[17:37:39.411] - relayed: [n=2] TRUE, TRUE
[17:37:39.411] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:39.411] - relayed: [n=2] TRUE, TRUE
[17:37:39.411] - queued futures: [n=2] TRUE, TRUE
[17:37:39.411] signalConditionsASAP(NULL, pos=0) ... done
[17:37:39.411] resolve() on list ... DONE
[17:37:39.411] result() for ClusterFuture ...
[17:37:39.411] - result already collected: FutureResult
[17:37:39.412] result() for ClusterFuture ... done
[17:37:39.412] result() for ClusterFuture ...
[17:37:39.412] - result already collected: FutureResult
[17:37:39.412] result() for ClusterFuture ... done
[17:37:39.412] result() for ClusterFuture ...
[17:37:39.412] - result already collected: FutureResult
[17:37:39.412] result() for ClusterFuture ... done
[17:37:39.412] result() for ClusterFuture ...
[17:37:39.412] - result already collected: FutureResult
[17:37:39.412] result() for ClusterFuture ... done
[17:37:39.412]  - Number of value chunks collected: 2
[17:37:39.413] Resolving 2 futures (chunks) ... DONE
[17:37:39.413] Reducing values from 2 chunks ...
[17:37:39.413]  - Number of values collected after concatenation: 5
[17:37:39.413]  - Number of values expected: 5
[17:37:39.413] Reducing values from 2 chunks ... DONE
[17:37:39.413] future_mapply() ... DONE
[17:37:39.413] future_mapply() ...
[17:37:39.417] Number of chunks: 3
[17:37:39.417] Index remapping (attribute 'ordering'): [n = 5] 3, 1, 4, 5, 2
[17:37:39.417] getGlobalsAndPackagesXApply() ...
[17:37:39.417]  - future.globals: TRUE
[17:37:39.418] getGlobalsAndPackages() ...
[17:37:39.418] Searching for globals...
[17:37:39.419] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:37:39.419] Searching for globals ... DONE
[17:37:39.419] Resolving globals: FALSE
[17:37:39.419] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:37:39.420] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:37:39.420] - globals: [1] ‘FUN’
[17:37:39.420] 
[17:37:39.420] getGlobalsAndPackages() ... DONE
[17:37:39.420]  - globals found/used: [n=1] ‘FUN’
[17:37:39.420]  - needed namespaces: [n=0] 
[17:37:39.420] Finding globals ... DONE
[17:37:39.421] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:39.421] List of 2
[17:37:39.421]  $ ...future.FUN:function (C, k)  
[17:37:39.421]  $ MoreArgs     : NULL
[17:37:39.421]  - attr(*, "where")=List of 2
[17:37:39.421]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:39.421]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:39.421]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:39.421]  - attr(*, "resolved")= logi FALSE
[17:37:39.421]  - attr(*, "total_size")= num NA
[17:37:39.423] Packages to be attached in all futures: [n=0] 
[17:37:39.423] getGlobalsAndPackagesXApply() ... DONE
[17:37:39.423] Number of futures (= number of chunks): 3
[17:37:39.423] Launching 3 futures (chunks) ...
[17:37:39.423] Chunk #1 of 3 ...
[17:37:39.424]  - Finding globals in '...' for chunk #1 ...
[17:37:39.424] getGlobalsAndPackages() ...
[17:37:39.424] Searching for globals...
[17:37:39.424] 
[17:37:39.424] Searching for globals ... DONE
[17:37:39.424] - globals: [0] <none>
[17:37:39.424] getGlobalsAndPackages() ... DONE
[17:37:39.424]    + additional globals found: [n=0] 
[17:37:39.425]    + additional namespaces needed: [n=0] 
[17:37:39.425]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:39.425]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:37:39.425]  - seeds: <none>
[17:37:39.425]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.425] getGlobalsAndPackages() ...
[17:37:39.425] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.425] Resolving globals: FALSE
[17:37:39.426] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:37:39.426] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:39.426] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.426] 
[17:37:39.426] getGlobalsAndPackages() ... DONE
[17:37:39.427] run() for ‘Future’ ...
[17:37:39.427] - state: ‘created’
[17:37:39.427] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:39.440] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.440] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:39.440]   - Field: ‘node’
[17:37:39.441]   - Field: ‘label’
[17:37:39.441]   - Field: ‘local’
[17:37:39.441]   - Field: ‘owner’
[17:37:39.441]   - Field: ‘envir’
[17:37:39.441]   - Field: ‘workers’
[17:37:39.441]   - Field: ‘packages’
[17:37:39.441]   - Field: ‘gc’
[17:37:39.441]   - Field: ‘conditions’
[17:37:39.441]   - Field: ‘persistent’
[17:37:39.441]   - Field: ‘expr’
[17:37:39.441]   - Field: ‘uuid’
[17:37:39.441]   - Field: ‘seed’
[17:37:39.442]   - Field: ‘version’
[17:37:39.442]   - Field: ‘result’
[17:37:39.442]   - Field: ‘asynchronous’
[17:37:39.442]   - Field: ‘calls’
[17:37:39.442]   - Field: ‘globals’
[17:37:39.442]   - Field: ‘stdout’
[17:37:39.442]   - Field: ‘earlySignal’
[17:37:39.442]   - Field: ‘lazy’
[17:37:39.442]   - Field: ‘state’
[17:37:39.442] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:39.442] - Launch lazy future ...
[17:37:39.443] Packages needed by the future expression (n = 0): <none>
[17:37:39.443] Packages needed by future strategies (n = 0): <none>
[17:37:39.443] {
[17:37:39.443]     {
[17:37:39.443]         {
[17:37:39.443]             ...future.startTime <- base::Sys.time()
[17:37:39.443]             {
[17:37:39.443]                 {
[17:37:39.443]                   {
[17:37:39.443]                     {
[17:37:39.443]                       base::local({
[17:37:39.443]                         has_future <- base::requireNamespace("future", 
[17:37:39.443]                           quietly = TRUE)
[17:37:39.443]                         if (has_future) {
[17:37:39.443]                           ns <- base::getNamespace("future")
[17:37:39.443]                           version <- ns[[".package"]][["version"]]
[17:37:39.443]                           if (is.null(version)) 
[17:37:39.443]                             version <- utils::packageVersion("future")
[17:37:39.443]                         }
[17:37:39.443]                         else {
[17:37:39.443]                           version <- NULL
[17:37:39.443]                         }
[17:37:39.443]                         if (!has_future || version < "1.8.0") {
[17:37:39.443]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:39.443]                             "", base::R.version$version.string), 
[17:37:39.443]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:39.443]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:39.443]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:39.443]                               "release", "version")], collapse = " "), 
[17:37:39.443]                             hostname = base::Sys.info()[["nodename"]])
[17:37:39.443]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:39.443]                             info)
[17:37:39.443]                           info <- base::paste(info, collapse = "; ")
[17:37:39.443]                           if (!has_future) {
[17:37:39.443]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:39.443]                               info)
[17:37:39.443]                           }
[17:37:39.443]                           else {
[17:37:39.443]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:39.443]                               info, version)
[17:37:39.443]                           }
[17:37:39.443]                           base::stop(msg)
[17:37:39.443]                         }
[17:37:39.443]                       })
[17:37:39.443]                     }
[17:37:39.443]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:39.443]                     base::options(mc.cores = 1L)
[17:37:39.443]                   }
[17:37:39.443]                   ...future.strategy.old <- future::plan("list")
[17:37:39.443]                   options(future.plan = NULL)
[17:37:39.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:39.443]                 }
[17:37:39.443]                 ...future.workdir <- getwd()
[17:37:39.443]             }
[17:37:39.443]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:39.443]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:39.443]         }
[17:37:39.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:39.443]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:37:39.443]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:39.443]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:39.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:39.443]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:39.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:39.443]             base::names(...future.oldOptions))
[17:37:39.443]     }
[17:37:39.443]     if (FALSE) {
[17:37:39.443]     }
[17:37:39.443]     else {
[17:37:39.443]         if (TRUE) {
[17:37:39.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:39.443]                 open = "w")
[17:37:39.443]         }
[17:37:39.443]         else {
[17:37:39.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:39.443]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:39.443]         }
[17:37:39.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:39.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:39.443]             base::sink(type = "output", split = FALSE)
[17:37:39.443]             base::close(...future.stdout)
[17:37:39.443]         }, add = TRUE)
[17:37:39.443]     }
[17:37:39.443]     ...future.frame <- base::sys.nframe()
[17:37:39.443]     ...future.conditions <- base::list()
[17:37:39.443]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:39.443]     if (FALSE) {
[17:37:39.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:39.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:39.443]     }
[17:37:39.443]     ...future.result <- base::tryCatch({
[17:37:39.443]         base::withCallingHandlers({
[17:37:39.443]             ...future.value <- base::withVisible(base::local({
[17:37:39.443]                 ...future.makeSendCondition <- base::local({
[17:37:39.443]                   sendCondition <- NULL
[17:37:39.443]                   function(frame = 1L) {
[17:37:39.443]                     if (is.function(sendCondition)) 
[17:37:39.443]                       return(sendCondition)
[17:37:39.443]                     ns <- getNamespace("parallel")
[17:37:39.443]                     if (exists("sendData", mode = "function", 
[17:37:39.443]                       envir = ns)) {
[17:37:39.443]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:39.443]                         envir = ns)
[17:37:39.443]                       envir <- sys.frame(frame)
[17:37:39.443]                       master <- NULL
[17:37:39.443]                       while (!identical(envir, .GlobalEnv) && 
[17:37:39.443]                         !identical(envir, emptyenv())) {
[17:37:39.443]                         if (exists("master", mode = "list", envir = envir, 
[17:37:39.443]                           inherits = FALSE)) {
[17:37:39.443]                           master <- get("master", mode = "list", 
[17:37:39.443]                             envir = envir, inherits = FALSE)
[17:37:39.443]                           if (inherits(master, c("SOCKnode", 
[17:37:39.443]                             "SOCK0node"))) {
[17:37:39.443]                             sendCondition <<- function(cond) {
[17:37:39.443]                               data <- list(type = "VALUE", value = cond, 
[17:37:39.443]                                 success = TRUE)
[17:37:39.443]                               parallel_sendData(master, data)
[17:37:39.443]                             }
[17:37:39.443]                             return(sendCondition)
[17:37:39.443]                           }
[17:37:39.443]                         }
[17:37:39.443]                         frame <- frame + 1L
[17:37:39.443]                         envir <- sys.frame(frame)
[17:37:39.443]                       }
[17:37:39.443]                     }
[17:37:39.443]                     sendCondition <<- function(cond) NULL
[17:37:39.443]                   }
[17:37:39.443]                 })
[17:37:39.443]                 withCallingHandlers({
[17:37:39.443]                   {
[17:37:39.443]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.443]                     if (!identical(...future.globals.maxSize.org, 
[17:37:39.443]                       ...future.globals.maxSize)) {
[17:37:39.443]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.443]                       on.exit(options(oopts), add = TRUE)
[17:37:39.443]                     }
[17:37:39.443]                     {
[17:37:39.443]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.443]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:39.443]                         USE.NAMES = FALSE)
[17:37:39.443]                       do.call(mapply, args = args)
[17:37:39.443]                     }
[17:37:39.443]                   }
[17:37:39.443]                 }, immediateCondition = function(cond) {
[17:37:39.443]                   sendCondition <- ...future.makeSendCondition()
[17:37:39.443]                   sendCondition(cond)
[17:37:39.443]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.443]                   {
[17:37:39.443]                     inherits <- base::inherits
[17:37:39.443]                     invokeRestart <- base::invokeRestart
[17:37:39.443]                     is.null <- base::is.null
[17:37:39.443]                     muffled <- FALSE
[17:37:39.443]                     if (inherits(cond, "message")) {
[17:37:39.443]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:39.443]                       if (muffled) 
[17:37:39.443]                         invokeRestart("muffleMessage")
[17:37:39.443]                     }
[17:37:39.443]                     else if (inherits(cond, "warning")) {
[17:37:39.443]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:39.443]                       if (muffled) 
[17:37:39.443]                         invokeRestart("muffleWarning")
[17:37:39.443]                     }
[17:37:39.443]                     else if (inherits(cond, "condition")) {
[17:37:39.443]                       if (!is.null(pattern)) {
[17:37:39.443]                         computeRestarts <- base::computeRestarts
[17:37:39.443]                         grepl <- base::grepl
[17:37:39.443]                         restarts <- computeRestarts(cond)
[17:37:39.443]                         for (restart in restarts) {
[17:37:39.443]                           name <- restart$name
[17:37:39.443]                           if (is.null(name)) 
[17:37:39.443]                             next
[17:37:39.443]                           if (!grepl(pattern, name)) 
[17:37:39.443]                             next
[17:37:39.443]                           invokeRestart(restart)
[17:37:39.443]                           muffled <- TRUE
[17:37:39.443]                           break
[17:37:39.443]                         }
[17:37:39.443]                       }
[17:37:39.443]                     }
[17:37:39.443]                     invisible(muffled)
[17:37:39.443]                   }
[17:37:39.443]                   muffleCondition(cond)
[17:37:39.443]                 })
[17:37:39.443]             }))
[17:37:39.443]             future::FutureResult(value = ...future.value$value, 
[17:37:39.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.443]                   ...future.rng), globalenv = if (FALSE) 
[17:37:39.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:39.443]                     ...future.globalenv.names))
[17:37:39.443]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:39.443]         }, condition = base::local({
[17:37:39.443]             c <- base::c
[17:37:39.443]             inherits <- base::inherits
[17:37:39.443]             invokeRestart <- base::invokeRestart
[17:37:39.443]             length <- base::length
[17:37:39.443]             list <- base::list
[17:37:39.443]             seq.int <- base::seq.int
[17:37:39.443]             signalCondition <- base::signalCondition
[17:37:39.443]             sys.calls <- base::sys.calls
[17:37:39.443]             `[[` <- base::`[[`
[17:37:39.443]             `+` <- base::`+`
[17:37:39.443]             `<<-` <- base::`<<-`
[17:37:39.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:39.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:39.443]                   3L)]
[17:37:39.443]             }
[17:37:39.443]             function(cond) {
[17:37:39.443]                 is_error <- inherits(cond, "error")
[17:37:39.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:39.443]                   NULL)
[17:37:39.443]                 if (is_error) {
[17:37:39.443]                   sessionInformation <- function() {
[17:37:39.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:39.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:39.443]                       search = base::search(), system = base::Sys.info())
[17:37:39.443]                   }
[17:37:39.443]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:39.443]                     cond$call), session = sessionInformation(), 
[17:37:39.443]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:39.443]                   signalCondition(cond)
[17:37:39.443]                 }
[17:37:39.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:39.443]                 "immediateCondition"))) {
[17:37:39.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:39.443]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:39.443]                   if (TRUE && !signal) {
[17:37:39.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.443]                     {
[17:37:39.443]                       inherits <- base::inherits
[17:37:39.443]                       invokeRestart <- base::invokeRestart
[17:37:39.443]                       is.null <- base::is.null
[17:37:39.443]                       muffled <- FALSE
[17:37:39.443]                       if (inherits(cond, "message")) {
[17:37:39.443]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.443]                         if (muffled) 
[17:37:39.443]                           invokeRestart("muffleMessage")
[17:37:39.443]                       }
[17:37:39.443]                       else if (inherits(cond, "warning")) {
[17:37:39.443]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.443]                         if (muffled) 
[17:37:39.443]                           invokeRestart("muffleWarning")
[17:37:39.443]                       }
[17:37:39.443]                       else if (inherits(cond, "condition")) {
[17:37:39.443]                         if (!is.null(pattern)) {
[17:37:39.443]                           computeRestarts <- base::computeRestarts
[17:37:39.443]                           grepl <- base::grepl
[17:37:39.443]                           restarts <- computeRestarts(cond)
[17:37:39.443]                           for (restart in restarts) {
[17:37:39.443]                             name <- restart$name
[17:37:39.443]                             if (is.null(name)) 
[17:37:39.443]                               next
[17:37:39.443]                             if (!grepl(pattern, name)) 
[17:37:39.443]                               next
[17:37:39.443]                             invokeRestart(restart)
[17:37:39.443]                             muffled <- TRUE
[17:37:39.443]                             break
[17:37:39.443]                           }
[17:37:39.443]                         }
[17:37:39.443]                       }
[17:37:39.443]                       invisible(muffled)
[17:37:39.443]                     }
[17:37:39.443]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.443]                   }
[17:37:39.443]                 }
[17:37:39.443]                 else {
[17:37:39.443]                   if (TRUE) {
[17:37:39.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.443]                     {
[17:37:39.443]                       inherits <- base::inherits
[17:37:39.443]                       invokeRestart <- base::invokeRestart
[17:37:39.443]                       is.null <- base::is.null
[17:37:39.443]                       muffled <- FALSE
[17:37:39.443]                       if (inherits(cond, "message")) {
[17:37:39.443]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.443]                         if (muffled) 
[17:37:39.443]                           invokeRestart("muffleMessage")
[17:37:39.443]                       }
[17:37:39.443]                       else if (inherits(cond, "warning")) {
[17:37:39.443]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.443]                         if (muffled) 
[17:37:39.443]                           invokeRestart("muffleWarning")
[17:37:39.443]                       }
[17:37:39.443]                       else if (inherits(cond, "condition")) {
[17:37:39.443]                         if (!is.null(pattern)) {
[17:37:39.443]                           computeRestarts <- base::computeRestarts
[17:37:39.443]                           grepl <- base::grepl
[17:37:39.443]                           restarts <- computeRestarts(cond)
[17:37:39.443]                           for (restart in restarts) {
[17:37:39.443]                             name <- restart$name
[17:37:39.443]                             if (is.null(name)) 
[17:37:39.443]                               next
[17:37:39.443]                             if (!grepl(pattern, name)) 
[17:37:39.443]                               next
[17:37:39.443]                             invokeRestart(restart)
[17:37:39.443]                             muffled <- TRUE
[17:37:39.443]                             break
[17:37:39.443]                           }
[17:37:39.443]                         }
[17:37:39.443]                       }
[17:37:39.443]                       invisible(muffled)
[17:37:39.443]                     }
[17:37:39.443]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.443]                   }
[17:37:39.443]                 }
[17:37:39.443]             }
[17:37:39.443]         }))
[17:37:39.443]     }, error = function(ex) {
[17:37:39.443]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:39.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.443]                 ...future.rng), started = ...future.startTime, 
[17:37:39.443]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:39.443]             version = "1.8"), class = "FutureResult")
[17:37:39.443]     }, finally = {
[17:37:39.443]         if (!identical(...future.workdir, getwd())) 
[17:37:39.443]             setwd(...future.workdir)
[17:37:39.443]         {
[17:37:39.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:39.443]                 ...future.oldOptions$nwarnings <- NULL
[17:37:39.443]             }
[17:37:39.443]             base::options(...future.oldOptions)
[17:37:39.443]             if (.Platform$OS.type == "windows") {
[17:37:39.443]                 old_names <- names(...future.oldEnvVars)
[17:37:39.443]                 envs <- base::Sys.getenv()
[17:37:39.443]                 names <- names(envs)
[17:37:39.443]                 common <- intersect(names, old_names)
[17:37:39.443]                 added <- setdiff(names, old_names)
[17:37:39.443]                 removed <- setdiff(old_names, names)
[17:37:39.443]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:39.443]                   envs[common]]
[17:37:39.443]                 NAMES <- toupper(changed)
[17:37:39.443]                 args <- list()
[17:37:39.443]                 for (kk in seq_along(NAMES)) {
[17:37:39.443]                   name <- changed[[kk]]
[17:37:39.443]                   NAME <- NAMES[[kk]]
[17:37:39.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.443]                     next
[17:37:39.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.443]                 }
[17:37:39.443]                 NAMES <- toupper(added)
[17:37:39.443]                 for (kk in seq_along(NAMES)) {
[17:37:39.443]                   name <- added[[kk]]
[17:37:39.443]                   NAME <- NAMES[[kk]]
[17:37:39.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.443]                     next
[17:37:39.443]                   args[[name]] <- ""
[17:37:39.443]                 }
[17:37:39.443]                 NAMES <- toupper(removed)
[17:37:39.443]                 for (kk in seq_along(NAMES)) {
[17:37:39.443]                   name <- removed[[kk]]
[17:37:39.443]                   NAME <- NAMES[[kk]]
[17:37:39.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.443]                     next
[17:37:39.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.443]                 }
[17:37:39.443]                 if (length(args) > 0) 
[17:37:39.443]                   base::do.call(base::Sys.setenv, args = args)
[17:37:39.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:39.443]             }
[17:37:39.443]             else {
[17:37:39.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:39.443]             }
[17:37:39.443]             {
[17:37:39.443]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:39.443]                   0L) {
[17:37:39.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:39.443]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:39.443]                   base::options(opts)
[17:37:39.443]                 }
[17:37:39.443]                 {
[17:37:39.443]                   {
[17:37:39.443]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:39.443]                     NULL
[17:37:39.443]                   }
[17:37:39.443]                   options(future.plan = NULL)
[17:37:39.443]                   if (is.na(NA_character_)) 
[17:37:39.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:39.443]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:39.443]                     .init = FALSE)
[17:37:39.443]                 }
[17:37:39.443]             }
[17:37:39.443]         }
[17:37:39.443]     })
[17:37:39.443]     if (TRUE) {
[17:37:39.443]         base::sink(type = "output", split = FALSE)
[17:37:39.443]         if (TRUE) {
[17:37:39.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:39.443]         }
[17:37:39.443]         else {
[17:37:39.443]             ...future.result["stdout"] <- base::list(NULL)
[17:37:39.443]         }
[17:37:39.443]         base::close(...future.stdout)
[17:37:39.443]         ...future.stdout <- NULL
[17:37:39.443]     }
[17:37:39.443]     ...future.result$conditions <- ...future.conditions
[17:37:39.443]     ...future.result$finished <- base::Sys.time()
[17:37:39.443]     ...future.result
[17:37:39.443] }
[17:37:39.446] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[17:37:39.446] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:37:39.447] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:37:39.447] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:37:39.447] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.447] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[17:37:39.448] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[17:37:39.448] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:39.448] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.448] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:39.449] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.449] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[17:37:39.449] MultisessionFuture started
[17:37:39.449] - Launch lazy future ... done
[17:37:39.450] run() for ‘MultisessionFuture’ ... done
[17:37:39.450] Created future:
[17:37:39.450] MultisessionFuture:
[17:37:39.450] Label: ‘future_mapply-1’
[17:37:39.450] Expression:
[17:37:39.450] {
[17:37:39.450]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.450]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:39.450]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.450]         on.exit(options(oopts), add = TRUE)
[17:37:39.450]     }
[17:37:39.450]     {
[17:37:39.450]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.450]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:39.450]         do.call(mapply, args = args)
[17:37:39.450]     }
[17:37:39.450] }
[17:37:39.450] Lazy evaluation: FALSE
[17:37:39.450] Asynchronous evaluation: TRUE
[17:37:39.450] Local evaluation: TRUE
[17:37:39.450] Environment: R_GlobalEnv
[17:37:39.450] Capture standard output: TRUE
[17:37:39.450] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:39.450] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:39.450] Packages: <none>
[17:37:39.450] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:39.450] Resolved: FALSE
[17:37:39.450] Value: <not collected>
[17:37:39.450] Conditions captured: <none>
[17:37:39.450] Early signaling: FALSE
[17:37:39.450] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:39.450] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.461] Chunk #1 of 3 ... DONE
[17:37:39.461] Chunk #2 of 3 ...
[17:37:39.462]  - Finding globals in '...' for chunk #2 ...
[17:37:39.462] getGlobalsAndPackages() ...
[17:37:39.462] Searching for globals...
[17:37:39.462] 
[17:37:39.462] Searching for globals ... DONE
[17:37:39.462] - globals: [0] <none>
[17:37:39.462] getGlobalsAndPackages() ... DONE
[17:37:39.462]    + additional globals found: [n=0] 
[17:37:39.462]    + additional namespaces needed: [n=0] 
[17:37:39.463]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:39.463]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:37:39.463]  - seeds: <none>
[17:37:39.463]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.463] getGlobalsAndPackages() ...
[17:37:39.463] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.463] Resolving globals: FALSE
[17:37:39.464] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:37:39.464] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:39.464] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.464] 
[17:37:39.464] getGlobalsAndPackages() ... DONE
[17:37:39.465] run() for ‘Future’ ...
[17:37:39.465] - state: ‘created’
[17:37:39.465] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:39.478] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.478] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:39.478]   - Field: ‘node’
[17:37:39.479]   - Field: ‘label’
[17:37:39.479]   - Field: ‘local’
[17:37:39.479]   - Field: ‘owner’
[17:37:39.479]   - Field: ‘envir’
[17:37:39.479]   - Field: ‘workers’
[17:37:39.479]   - Field: ‘packages’
[17:37:39.479]   - Field: ‘gc’
[17:37:39.479]   - Field: ‘conditions’
[17:37:39.479]   - Field: ‘persistent’
[17:37:39.479]   - Field: ‘expr’
[17:37:39.479]   - Field: ‘uuid’
[17:37:39.480]   - Field: ‘seed’
[17:37:39.480]   - Field: ‘version’
[17:37:39.480]   - Field: ‘result’
[17:37:39.480]   - Field: ‘asynchronous’
[17:37:39.480]   - Field: ‘calls’
[17:37:39.480]   - Field: ‘globals’
[17:37:39.480]   - Field: ‘stdout’
[17:37:39.480]   - Field: ‘earlySignal’
[17:37:39.480]   - Field: ‘lazy’
[17:37:39.480]   - Field: ‘state’
[17:37:39.480] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:39.481] - Launch lazy future ...
[17:37:39.481] Packages needed by the future expression (n = 0): <none>
[17:37:39.481] Packages needed by future strategies (n = 0): <none>
[17:37:39.481] {
[17:37:39.481]     {
[17:37:39.481]         {
[17:37:39.481]             ...future.startTime <- base::Sys.time()
[17:37:39.481]             {
[17:37:39.481]                 {
[17:37:39.481]                   {
[17:37:39.481]                     {
[17:37:39.481]                       base::local({
[17:37:39.481]                         has_future <- base::requireNamespace("future", 
[17:37:39.481]                           quietly = TRUE)
[17:37:39.481]                         if (has_future) {
[17:37:39.481]                           ns <- base::getNamespace("future")
[17:37:39.481]                           version <- ns[[".package"]][["version"]]
[17:37:39.481]                           if (is.null(version)) 
[17:37:39.481]                             version <- utils::packageVersion("future")
[17:37:39.481]                         }
[17:37:39.481]                         else {
[17:37:39.481]                           version <- NULL
[17:37:39.481]                         }
[17:37:39.481]                         if (!has_future || version < "1.8.0") {
[17:37:39.481]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:39.481]                             "", base::R.version$version.string), 
[17:37:39.481]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:39.481]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:39.481]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:39.481]                               "release", "version")], collapse = " "), 
[17:37:39.481]                             hostname = base::Sys.info()[["nodename"]])
[17:37:39.481]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:39.481]                             info)
[17:37:39.481]                           info <- base::paste(info, collapse = "; ")
[17:37:39.481]                           if (!has_future) {
[17:37:39.481]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:39.481]                               info)
[17:37:39.481]                           }
[17:37:39.481]                           else {
[17:37:39.481]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:39.481]                               info, version)
[17:37:39.481]                           }
[17:37:39.481]                           base::stop(msg)
[17:37:39.481]                         }
[17:37:39.481]                       })
[17:37:39.481]                     }
[17:37:39.481]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:39.481]                     base::options(mc.cores = 1L)
[17:37:39.481]                   }
[17:37:39.481]                   ...future.strategy.old <- future::plan("list")
[17:37:39.481]                   options(future.plan = NULL)
[17:37:39.481]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.481]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:39.481]                 }
[17:37:39.481]                 ...future.workdir <- getwd()
[17:37:39.481]             }
[17:37:39.481]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:39.481]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:39.481]         }
[17:37:39.481]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:39.481]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:37:39.481]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:39.481]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:39.481]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:39.481]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:39.481]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:39.481]             base::names(...future.oldOptions))
[17:37:39.481]     }
[17:37:39.481]     if (FALSE) {
[17:37:39.481]     }
[17:37:39.481]     else {
[17:37:39.481]         if (TRUE) {
[17:37:39.481]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:39.481]                 open = "w")
[17:37:39.481]         }
[17:37:39.481]         else {
[17:37:39.481]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:39.481]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:39.481]         }
[17:37:39.481]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:39.481]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:39.481]             base::sink(type = "output", split = FALSE)
[17:37:39.481]             base::close(...future.stdout)
[17:37:39.481]         }, add = TRUE)
[17:37:39.481]     }
[17:37:39.481]     ...future.frame <- base::sys.nframe()
[17:37:39.481]     ...future.conditions <- base::list()
[17:37:39.481]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:39.481]     if (FALSE) {
[17:37:39.481]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:39.481]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:39.481]     }
[17:37:39.481]     ...future.result <- base::tryCatch({
[17:37:39.481]         base::withCallingHandlers({
[17:37:39.481]             ...future.value <- base::withVisible(base::local({
[17:37:39.481]                 ...future.makeSendCondition <- base::local({
[17:37:39.481]                   sendCondition <- NULL
[17:37:39.481]                   function(frame = 1L) {
[17:37:39.481]                     if (is.function(sendCondition)) 
[17:37:39.481]                       return(sendCondition)
[17:37:39.481]                     ns <- getNamespace("parallel")
[17:37:39.481]                     if (exists("sendData", mode = "function", 
[17:37:39.481]                       envir = ns)) {
[17:37:39.481]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:39.481]                         envir = ns)
[17:37:39.481]                       envir <- sys.frame(frame)
[17:37:39.481]                       master <- NULL
[17:37:39.481]                       while (!identical(envir, .GlobalEnv) && 
[17:37:39.481]                         !identical(envir, emptyenv())) {
[17:37:39.481]                         if (exists("master", mode = "list", envir = envir, 
[17:37:39.481]                           inherits = FALSE)) {
[17:37:39.481]                           master <- get("master", mode = "list", 
[17:37:39.481]                             envir = envir, inherits = FALSE)
[17:37:39.481]                           if (inherits(master, c("SOCKnode", 
[17:37:39.481]                             "SOCK0node"))) {
[17:37:39.481]                             sendCondition <<- function(cond) {
[17:37:39.481]                               data <- list(type = "VALUE", value = cond, 
[17:37:39.481]                                 success = TRUE)
[17:37:39.481]                               parallel_sendData(master, data)
[17:37:39.481]                             }
[17:37:39.481]                             return(sendCondition)
[17:37:39.481]                           }
[17:37:39.481]                         }
[17:37:39.481]                         frame <- frame + 1L
[17:37:39.481]                         envir <- sys.frame(frame)
[17:37:39.481]                       }
[17:37:39.481]                     }
[17:37:39.481]                     sendCondition <<- function(cond) NULL
[17:37:39.481]                   }
[17:37:39.481]                 })
[17:37:39.481]                 withCallingHandlers({
[17:37:39.481]                   {
[17:37:39.481]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.481]                     if (!identical(...future.globals.maxSize.org, 
[17:37:39.481]                       ...future.globals.maxSize)) {
[17:37:39.481]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.481]                       on.exit(options(oopts), add = TRUE)
[17:37:39.481]                     }
[17:37:39.481]                     {
[17:37:39.481]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.481]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:39.481]                         USE.NAMES = FALSE)
[17:37:39.481]                       do.call(mapply, args = args)
[17:37:39.481]                     }
[17:37:39.481]                   }
[17:37:39.481]                 }, immediateCondition = function(cond) {
[17:37:39.481]                   sendCondition <- ...future.makeSendCondition()
[17:37:39.481]                   sendCondition(cond)
[17:37:39.481]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.481]                   {
[17:37:39.481]                     inherits <- base::inherits
[17:37:39.481]                     invokeRestart <- base::invokeRestart
[17:37:39.481]                     is.null <- base::is.null
[17:37:39.481]                     muffled <- FALSE
[17:37:39.481]                     if (inherits(cond, "message")) {
[17:37:39.481]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:39.481]                       if (muffled) 
[17:37:39.481]                         invokeRestart("muffleMessage")
[17:37:39.481]                     }
[17:37:39.481]                     else if (inherits(cond, "warning")) {
[17:37:39.481]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:39.481]                       if (muffled) 
[17:37:39.481]                         invokeRestart("muffleWarning")
[17:37:39.481]                     }
[17:37:39.481]                     else if (inherits(cond, "condition")) {
[17:37:39.481]                       if (!is.null(pattern)) {
[17:37:39.481]                         computeRestarts <- base::computeRestarts
[17:37:39.481]                         grepl <- base::grepl
[17:37:39.481]                         restarts <- computeRestarts(cond)
[17:37:39.481]                         for (restart in restarts) {
[17:37:39.481]                           name <- restart$name
[17:37:39.481]                           if (is.null(name)) 
[17:37:39.481]                             next
[17:37:39.481]                           if (!grepl(pattern, name)) 
[17:37:39.481]                             next
[17:37:39.481]                           invokeRestart(restart)
[17:37:39.481]                           muffled <- TRUE
[17:37:39.481]                           break
[17:37:39.481]                         }
[17:37:39.481]                       }
[17:37:39.481]                     }
[17:37:39.481]                     invisible(muffled)
[17:37:39.481]                   }
[17:37:39.481]                   muffleCondition(cond)
[17:37:39.481]                 })
[17:37:39.481]             }))
[17:37:39.481]             future::FutureResult(value = ...future.value$value, 
[17:37:39.481]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.481]                   ...future.rng), globalenv = if (FALSE) 
[17:37:39.481]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:39.481]                     ...future.globalenv.names))
[17:37:39.481]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:39.481]         }, condition = base::local({
[17:37:39.481]             c <- base::c
[17:37:39.481]             inherits <- base::inherits
[17:37:39.481]             invokeRestart <- base::invokeRestart
[17:37:39.481]             length <- base::length
[17:37:39.481]             list <- base::list
[17:37:39.481]             seq.int <- base::seq.int
[17:37:39.481]             signalCondition <- base::signalCondition
[17:37:39.481]             sys.calls <- base::sys.calls
[17:37:39.481]             `[[` <- base::`[[`
[17:37:39.481]             `+` <- base::`+`
[17:37:39.481]             `<<-` <- base::`<<-`
[17:37:39.481]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:39.481]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:39.481]                   3L)]
[17:37:39.481]             }
[17:37:39.481]             function(cond) {
[17:37:39.481]                 is_error <- inherits(cond, "error")
[17:37:39.481]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:39.481]                   NULL)
[17:37:39.481]                 if (is_error) {
[17:37:39.481]                   sessionInformation <- function() {
[17:37:39.481]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:39.481]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:39.481]                       search = base::search(), system = base::Sys.info())
[17:37:39.481]                   }
[17:37:39.481]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.481]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:39.481]                     cond$call), session = sessionInformation(), 
[17:37:39.481]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:39.481]                   signalCondition(cond)
[17:37:39.481]                 }
[17:37:39.481]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:39.481]                 "immediateCondition"))) {
[17:37:39.481]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:39.481]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.481]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:39.481]                   if (TRUE && !signal) {
[17:37:39.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.481]                     {
[17:37:39.481]                       inherits <- base::inherits
[17:37:39.481]                       invokeRestart <- base::invokeRestart
[17:37:39.481]                       is.null <- base::is.null
[17:37:39.481]                       muffled <- FALSE
[17:37:39.481]                       if (inherits(cond, "message")) {
[17:37:39.481]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.481]                         if (muffled) 
[17:37:39.481]                           invokeRestart("muffleMessage")
[17:37:39.481]                       }
[17:37:39.481]                       else if (inherits(cond, "warning")) {
[17:37:39.481]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.481]                         if (muffled) 
[17:37:39.481]                           invokeRestart("muffleWarning")
[17:37:39.481]                       }
[17:37:39.481]                       else if (inherits(cond, "condition")) {
[17:37:39.481]                         if (!is.null(pattern)) {
[17:37:39.481]                           computeRestarts <- base::computeRestarts
[17:37:39.481]                           grepl <- base::grepl
[17:37:39.481]                           restarts <- computeRestarts(cond)
[17:37:39.481]                           for (restart in restarts) {
[17:37:39.481]                             name <- restart$name
[17:37:39.481]                             if (is.null(name)) 
[17:37:39.481]                               next
[17:37:39.481]                             if (!grepl(pattern, name)) 
[17:37:39.481]                               next
[17:37:39.481]                             invokeRestart(restart)
[17:37:39.481]                             muffled <- TRUE
[17:37:39.481]                             break
[17:37:39.481]                           }
[17:37:39.481]                         }
[17:37:39.481]                       }
[17:37:39.481]                       invisible(muffled)
[17:37:39.481]                     }
[17:37:39.481]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.481]                   }
[17:37:39.481]                 }
[17:37:39.481]                 else {
[17:37:39.481]                   if (TRUE) {
[17:37:39.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.481]                     {
[17:37:39.481]                       inherits <- base::inherits
[17:37:39.481]                       invokeRestart <- base::invokeRestart
[17:37:39.481]                       is.null <- base::is.null
[17:37:39.481]                       muffled <- FALSE
[17:37:39.481]                       if (inherits(cond, "message")) {
[17:37:39.481]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.481]                         if (muffled) 
[17:37:39.481]                           invokeRestart("muffleMessage")
[17:37:39.481]                       }
[17:37:39.481]                       else if (inherits(cond, "warning")) {
[17:37:39.481]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.481]                         if (muffled) 
[17:37:39.481]                           invokeRestart("muffleWarning")
[17:37:39.481]                       }
[17:37:39.481]                       else if (inherits(cond, "condition")) {
[17:37:39.481]                         if (!is.null(pattern)) {
[17:37:39.481]                           computeRestarts <- base::computeRestarts
[17:37:39.481]                           grepl <- base::grepl
[17:37:39.481]                           restarts <- computeRestarts(cond)
[17:37:39.481]                           for (restart in restarts) {
[17:37:39.481]                             name <- restart$name
[17:37:39.481]                             if (is.null(name)) 
[17:37:39.481]                               next
[17:37:39.481]                             if (!grepl(pattern, name)) 
[17:37:39.481]                               next
[17:37:39.481]                             invokeRestart(restart)
[17:37:39.481]                             muffled <- TRUE
[17:37:39.481]                             break
[17:37:39.481]                           }
[17:37:39.481]                         }
[17:37:39.481]                       }
[17:37:39.481]                       invisible(muffled)
[17:37:39.481]                     }
[17:37:39.481]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.481]                   }
[17:37:39.481]                 }
[17:37:39.481]             }
[17:37:39.481]         }))
[17:37:39.481]     }, error = function(ex) {
[17:37:39.481]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:39.481]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.481]                 ...future.rng), started = ...future.startTime, 
[17:37:39.481]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:39.481]             version = "1.8"), class = "FutureResult")
[17:37:39.481]     }, finally = {
[17:37:39.481]         if (!identical(...future.workdir, getwd())) 
[17:37:39.481]             setwd(...future.workdir)
[17:37:39.481]         {
[17:37:39.481]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:39.481]                 ...future.oldOptions$nwarnings <- NULL
[17:37:39.481]             }
[17:37:39.481]             base::options(...future.oldOptions)
[17:37:39.481]             if (.Platform$OS.type == "windows") {
[17:37:39.481]                 old_names <- names(...future.oldEnvVars)
[17:37:39.481]                 envs <- base::Sys.getenv()
[17:37:39.481]                 names <- names(envs)
[17:37:39.481]                 common <- intersect(names, old_names)
[17:37:39.481]                 added <- setdiff(names, old_names)
[17:37:39.481]                 removed <- setdiff(old_names, names)
[17:37:39.481]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:39.481]                   envs[common]]
[17:37:39.481]                 NAMES <- toupper(changed)
[17:37:39.481]                 args <- list()
[17:37:39.481]                 for (kk in seq_along(NAMES)) {
[17:37:39.481]                   name <- changed[[kk]]
[17:37:39.481]                   NAME <- NAMES[[kk]]
[17:37:39.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.481]                     next
[17:37:39.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.481]                 }
[17:37:39.481]                 NAMES <- toupper(added)
[17:37:39.481]                 for (kk in seq_along(NAMES)) {
[17:37:39.481]                   name <- added[[kk]]
[17:37:39.481]                   NAME <- NAMES[[kk]]
[17:37:39.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.481]                     next
[17:37:39.481]                   args[[name]] <- ""
[17:37:39.481]                 }
[17:37:39.481]                 NAMES <- toupper(removed)
[17:37:39.481]                 for (kk in seq_along(NAMES)) {
[17:37:39.481]                   name <- removed[[kk]]
[17:37:39.481]                   NAME <- NAMES[[kk]]
[17:37:39.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.481]                     next
[17:37:39.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.481]                 }
[17:37:39.481]                 if (length(args) > 0) 
[17:37:39.481]                   base::do.call(base::Sys.setenv, args = args)
[17:37:39.481]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:39.481]             }
[17:37:39.481]             else {
[17:37:39.481]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:39.481]             }
[17:37:39.481]             {
[17:37:39.481]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:39.481]                   0L) {
[17:37:39.481]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:39.481]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:39.481]                   base::options(opts)
[17:37:39.481]                 }
[17:37:39.481]                 {
[17:37:39.481]                   {
[17:37:39.481]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:39.481]                     NULL
[17:37:39.481]                   }
[17:37:39.481]                   options(future.plan = NULL)
[17:37:39.481]                   if (is.na(NA_character_)) 
[17:37:39.481]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.481]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:39.481]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:39.481]                     .init = FALSE)
[17:37:39.481]                 }
[17:37:39.481]             }
[17:37:39.481]         }
[17:37:39.481]     })
[17:37:39.481]     if (TRUE) {
[17:37:39.481]         base::sink(type = "output", split = FALSE)
[17:37:39.481]         if (TRUE) {
[17:37:39.481]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:39.481]         }
[17:37:39.481]         else {
[17:37:39.481]             ...future.result["stdout"] <- base::list(NULL)
[17:37:39.481]         }
[17:37:39.481]         base::close(...future.stdout)
[17:37:39.481]         ...future.stdout <- NULL
[17:37:39.481]     }
[17:37:39.481]     ...future.result$conditions <- ...future.conditions
[17:37:39.481]     ...future.result$finished <- base::Sys.time()
[17:37:39.481]     ...future.result
[17:37:39.481] }
[17:37:39.484] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[17:37:39.484] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[17:37:39.484] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[17:37:39.485] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:37:39.485] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:37:39.485] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[17:37:39.485] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[17:37:39.485] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:37:39.486] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:37:39.486] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:37:39.486] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:37:39.486] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[17:37:39.487] MultisessionFuture started
[17:37:39.487] - Launch lazy future ... done
[17:37:39.487] run() for ‘MultisessionFuture’ ... done
[17:37:39.487] Created future:
[17:37:39.487] MultisessionFuture:
[17:37:39.487] Label: ‘future_mapply-2’
[17:37:39.487] Expression:
[17:37:39.487] {
[17:37:39.487]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.487]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:39.487]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.487]         on.exit(options(oopts), add = TRUE)
[17:37:39.487]     }
[17:37:39.487]     {
[17:37:39.487]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.487]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:39.487]         do.call(mapply, args = args)
[17:37:39.487]     }
[17:37:39.487] }
[17:37:39.487] Lazy evaluation: FALSE
[17:37:39.487] Asynchronous evaluation: TRUE
[17:37:39.487] Local evaluation: TRUE
[17:37:39.487] Environment: R_GlobalEnv
[17:37:39.487] Capture standard output: TRUE
[17:37:39.487] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:39.487] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:39.487] Packages: <none>
[17:37:39.487] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:39.487] Resolved: FALSE
[17:37:39.487] Value: <not collected>
[17:37:39.487] Conditions captured: <none>
[17:37:39.487] Early signaling: FALSE
[17:37:39.487] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:39.487] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.498] Chunk #2 of 3 ... DONE
[17:37:39.499] Chunk #3 of 3 ...
[17:37:39.499]  - Finding globals in '...' for chunk #3 ...
[17:37:39.499] getGlobalsAndPackages() ...
[17:37:39.499] Searching for globals...
[17:37:39.499] 
[17:37:39.500] Searching for globals ... DONE
[17:37:39.500] - globals: [0] <none>
[17:37:39.500] getGlobalsAndPackages() ... DONE
[17:37:39.500]    + additional globals found: [n=0] 
[17:37:39.500]    + additional namespaces needed: [n=0] 
[17:37:39.500]  - Finding globals in '...' for chunk #3 ... DONE
[17:37:39.500]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:37:39.500]  - seeds: <none>
[17:37:39.500]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.500] getGlobalsAndPackages() ...
[17:37:39.501] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.501] Resolving globals: FALSE
[17:37:39.501] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:37:39.502] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:39.502] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.502] 
[17:37:39.502] getGlobalsAndPackages() ... DONE
[17:37:39.502] run() for ‘Future’ ...
[17:37:39.502] - state: ‘created’
[17:37:39.502] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:39.516] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.516] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:39.516]   - Field: ‘node’
[17:37:39.517]   - Field: ‘label’
[17:37:39.517]   - Field: ‘local’
[17:37:39.517]   - Field: ‘owner’
[17:37:39.517]   - Field: ‘envir’
[17:37:39.517]   - Field: ‘workers’
[17:37:39.517]   - Field: ‘packages’
[17:37:39.517]   - Field: ‘gc’
[17:37:39.517]   - Field: ‘conditions’
[17:37:39.517]   - Field: ‘persistent’
[17:37:39.517]   - Field: ‘expr’
[17:37:39.517]   - Field: ‘uuid’
[17:37:39.518]   - Field: ‘seed’
[17:37:39.518]   - Field: ‘version’
[17:37:39.518]   - Field: ‘result’
[17:37:39.518]   - Field: ‘asynchronous’
[17:37:39.518]   - Field: ‘calls’
[17:37:39.518]   - Field: ‘globals’
[17:37:39.518]   - Field: ‘stdout’
[17:37:39.518]   - Field: ‘earlySignal’
[17:37:39.518]   - Field: ‘lazy’
[17:37:39.518]   - Field: ‘state’
[17:37:39.518] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:39.518] - Launch lazy future ...
[17:37:39.519] Packages needed by the future expression (n = 0): <none>
[17:37:39.519] Packages needed by future strategies (n = 0): <none>
[17:37:39.519] {
[17:37:39.519]     {
[17:37:39.519]         {
[17:37:39.519]             ...future.startTime <- base::Sys.time()
[17:37:39.519]             {
[17:37:39.519]                 {
[17:37:39.519]                   {
[17:37:39.519]                     {
[17:37:39.519]                       base::local({
[17:37:39.519]                         has_future <- base::requireNamespace("future", 
[17:37:39.519]                           quietly = TRUE)
[17:37:39.519]                         if (has_future) {
[17:37:39.519]                           ns <- base::getNamespace("future")
[17:37:39.519]                           version <- ns[[".package"]][["version"]]
[17:37:39.519]                           if (is.null(version)) 
[17:37:39.519]                             version <- utils::packageVersion("future")
[17:37:39.519]                         }
[17:37:39.519]                         else {
[17:37:39.519]                           version <- NULL
[17:37:39.519]                         }
[17:37:39.519]                         if (!has_future || version < "1.8.0") {
[17:37:39.519]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:39.519]                             "", base::R.version$version.string), 
[17:37:39.519]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:39.519]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:39.519]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:39.519]                               "release", "version")], collapse = " "), 
[17:37:39.519]                             hostname = base::Sys.info()[["nodename"]])
[17:37:39.519]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:39.519]                             info)
[17:37:39.519]                           info <- base::paste(info, collapse = "; ")
[17:37:39.519]                           if (!has_future) {
[17:37:39.519]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:39.519]                               info)
[17:37:39.519]                           }
[17:37:39.519]                           else {
[17:37:39.519]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:39.519]                               info, version)
[17:37:39.519]                           }
[17:37:39.519]                           base::stop(msg)
[17:37:39.519]                         }
[17:37:39.519]                       })
[17:37:39.519]                     }
[17:37:39.519]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:39.519]                     base::options(mc.cores = 1L)
[17:37:39.519]                   }
[17:37:39.519]                   ...future.strategy.old <- future::plan("list")
[17:37:39.519]                   options(future.plan = NULL)
[17:37:39.519]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.519]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:39.519]                 }
[17:37:39.519]                 ...future.workdir <- getwd()
[17:37:39.519]             }
[17:37:39.519]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:39.519]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:39.519]         }
[17:37:39.519]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:39.519]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:37:39.519]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:39.519]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:39.519]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:39.519]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:39.519]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:39.519]             base::names(...future.oldOptions))
[17:37:39.519]     }
[17:37:39.519]     if (FALSE) {
[17:37:39.519]     }
[17:37:39.519]     else {
[17:37:39.519]         if (TRUE) {
[17:37:39.519]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:39.519]                 open = "w")
[17:37:39.519]         }
[17:37:39.519]         else {
[17:37:39.519]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:39.519]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:39.519]         }
[17:37:39.519]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:39.519]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:39.519]             base::sink(type = "output", split = FALSE)
[17:37:39.519]             base::close(...future.stdout)
[17:37:39.519]         }, add = TRUE)
[17:37:39.519]     }
[17:37:39.519]     ...future.frame <- base::sys.nframe()
[17:37:39.519]     ...future.conditions <- base::list()
[17:37:39.519]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:39.519]     if (FALSE) {
[17:37:39.519]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:39.519]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:39.519]     }
[17:37:39.519]     ...future.result <- base::tryCatch({
[17:37:39.519]         base::withCallingHandlers({
[17:37:39.519]             ...future.value <- base::withVisible(base::local({
[17:37:39.519]                 ...future.makeSendCondition <- base::local({
[17:37:39.519]                   sendCondition <- NULL
[17:37:39.519]                   function(frame = 1L) {
[17:37:39.519]                     if (is.function(sendCondition)) 
[17:37:39.519]                       return(sendCondition)
[17:37:39.519]                     ns <- getNamespace("parallel")
[17:37:39.519]                     if (exists("sendData", mode = "function", 
[17:37:39.519]                       envir = ns)) {
[17:37:39.519]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:39.519]                         envir = ns)
[17:37:39.519]                       envir <- sys.frame(frame)
[17:37:39.519]                       master <- NULL
[17:37:39.519]                       while (!identical(envir, .GlobalEnv) && 
[17:37:39.519]                         !identical(envir, emptyenv())) {
[17:37:39.519]                         if (exists("master", mode = "list", envir = envir, 
[17:37:39.519]                           inherits = FALSE)) {
[17:37:39.519]                           master <- get("master", mode = "list", 
[17:37:39.519]                             envir = envir, inherits = FALSE)
[17:37:39.519]                           if (inherits(master, c("SOCKnode", 
[17:37:39.519]                             "SOCK0node"))) {
[17:37:39.519]                             sendCondition <<- function(cond) {
[17:37:39.519]                               data <- list(type = "VALUE", value = cond, 
[17:37:39.519]                                 success = TRUE)
[17:37:39.519]                               parallel_sendData(master, data)
[17:37:39.519]                             }
[17:37:39.519]                             return(sendCondition)
[17:37:39.519]                           }
[17:37:39.519]                         }
[17:37:39.519]                         frame <- frame + 1L
[17:37:39.519]                         envir <- sys.frame(frame)
[17:37:39.519]                       }
[17:37:39.519]                     }
[17:37:39.519]                     sendCondition <<- function(cond) NULL
[17:37:39.519]                   }
[17:37:39.519]                 })
[17:37:39.519]                 withCallingHandlers({
[17:37:39.519]                   {
[17:37:39.519]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.519]                     if (!identical(...future.globals.maxSize.org, 
[17:37:39.519]                       ...future.globals.maxSize)) {
[17:37:39.519]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.519]                       on.exit(options(oopts), add = TRUE)
[17:37:39.519]                     }
[17:37:39.519]                     {
[17:37:39.519]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.519]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:39.519]                         USE.NAMES = FALSE)
[17:37:39.519]                       do.call(mapply, args = args)
[17:37:39.519]                     }
[17:37:39.519]                   }
[17:37:39.519]                 }, immediateCondition = function(cond) {
[17:37:39.519]                   sendCondition <- ...future.makeSendCondition()
[17:37:39.519]                   sendCondition(cond)
[17:37:39.519]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.519]                   {
[17:37:39.519]                     inherits <- base::inherits
[17:37:39.519]                     invokeRestart <- base::invokeRestart
[17:37:39.519]                     is.null <- base::is.null
[17:37:39.519]                     muffled <- FALSE
[17:37:39.519]                     if (inherits(cond, "message")) {
[17:37:39.519]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:39.519]                       if (muffled) 
[17:37:39.519]                         invokeRestart("muffleMessage")
[17:37:39.519]                     }
[17:37:39.519]                     else if (inherits(cond, "warning")) {
[17:37:39.519]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:39.519]                       if (muffled) 
[17:37:39.519]                         invokeRestart("muffleWarning")
[17:37:39.519]                     }
[17:37:39.519]                     else if (inherits(cond, "condition")) {
[17:37:39.519]                       if (!is.null(pattern)) {
[17:37:39.519]                         computeRestarts <- base::computeRestarts
[17:37:39.519]                         grepl <- base::grepl
[17:37:39.519]                         restarts <- computeRestarts(cond)
[17:37:39.519]                         for (restart in restarts) {
[17:37:39.519]                           name <- restart$name
[17:37:39.519]                           if (is.null(name)) 
[17:37:39.519]                             next
[17:37:39.519]                           if (!grepl(pattern, name)) 
[17:37:39.519]                             next
[17:37:39.519]                           invokeRestart(restart)
[17:37:39.519]                           muffled <- TRUE
[17:37:39.519]                           break
[17:37:39.519]                         }
[17:37:39.519]                       }
[17:37:39.519]                     }
[17:37:39.519]                     invisible(muffled)
[17:37:39.519]                   }
[17:37:39.519]                   muffleCondition(cond)
[17:37:39.519]                 })
[17:37:39.519]             }))
[17:37:39.519]             future::FutureResult(value = ...future.value$value, 
[17:37:39.519]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.519]                   ...future.rng), globalenv = if (FALSE) 
[17:37:39.519]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:39.519]                     ...future.globalenv.names))
[17:37:39.519]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:39.519]         }, condition = base::local({
[17:37:39.519]             c <- base::c
[17:37:39.519]             inherits <- base::inherits
[17:37:39.519]             invokeRestart <- base::invokeRestart
[17:37:39.519]             length <- base::length
[17:37:39.519]             list <- base::list
[17:37:39.519]             seq.int <- base::seq.int
[17:37:39.519]             signalCondition <- base::signalCondition
[17:37:39.519]             sys.calls <- base::sys.calls
[17:37:39.519]             `[[` <- base::`[[`
[17:37:39.519]             `+` <- base::`+`
[17:37:39.519]             `<<-` <- base::`<<-`
[17:37:39.519]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:39.519]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:39.519]                   3L)]
[17:37:39.519]             }
[17:37:39.519]             function(cond) {
[17:37:39.519]                 is_error <- inherits(cond, "error")
[17:37:39.519]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:39.519]                   NULL)
[17:37:39.519]                 if (is_error) {
[17:37:39.519]                   sessionInformation <- function() {
[17:37:39.519]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:39.519]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:39.519]                       search = base::search(), system = base::Sys.info())
[17:37:39.519]                   }
[17:37:39.519]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.519]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:39.519]                     cond$call), session = sessionInformation(), 
[17:37:39.519]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:39.519]                   signalCondition(cond)
[17:37:39.519]                 }
[17:37:39.519]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:39.519]                 "immediateCondition"))) {
[17:37:39.519]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:39.519]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.519]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:39.519]                   if (TRUE && !signal) {
[17:37:39.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.519]                     {
[17:37:39.519]                       inherits <- base::inherits
[17:37:39.519]                       invokeRestart <- base::invokeRestart
[17:37:39.519]                       is.null <- base::is.null
[17:37:39.519]                       muffled <- FALSE
[17:37:39.519]                       if (inherits(cond, "message")) {
[17:37:39.519]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.519]                         if (muffled) 
[17:37:39.519]                           invokeRestart("muffleMessage")
[17:37:39.519]                       }
[17:37:39.519]                       else if (inherits(cond, "warning")) {
[17:37:39.519]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.519]                         if (muffled) 
[17:37:39.519]                           invokeRestart("muffleWarning")
[17:37:39.519]                       }
[17:37:39.519]                       else if (inherits(cond, "condition")) {
[17:37:39.519]                         if (!is.null(pattern)) {
[17:37:39.519]                           computeRestarts <- base::computeRestarts
[17:37:39.519]                           grepl <- base::grepl
[17:37:39.519]                           restarts <- computeRestarts(cond)
[17:37:39.519]                           for (restart in restarts) {
[17:37:39.519]                             name <- restart$name
[17:37:39.519]                             if (is.null(name)) 
[17:37:39.519]                               next
[17:37:39.519]                             if (!grepl(pattern, name)) 
[17:37:39.519]                               next
[17:37:39.519]                             invokeRestart(restart)
[17:37:39.519]                             muffled <- TRUE
[17:37:39.519]                             break
[17:37:39.519]                           }
[17:37:39.519]                         }
[17:37:39.519]                       }
[17:37:39.519]                       invisible(muffled)
[17:37:39.519]                     }
[17:37:39.519]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.519]                   }
[17:37:39.519]                 }
[17:37:39.519]                 else {
[17:37:39.519]                   if (TRUE) {
[17:37:39.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.519]                     {
[17:37:39.519]                       inherits <- base::inherits
[17:37:39.519]                       invokeRestart <- base::invokeRestart
[17:37:39.519]                       is.null <- base::is.null
[17:37:39.519]                       muffled <- FALSE
[17:37:39.519]                       if (inherits(cond, "message")) {
[17:37:39.519]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.519]                         if (muffled) 
[17:37:39.519]                           invokeRestart("muffleMessage")
[17:37:39.519]                       }
[17:37:39.519]                       else if (inherits(cond, "warning")) {
[17:37:39.519]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.519]                         if (muffled) 
[17:37:39.519]                           invokeRestart("muffleWarning")
[17:37:39.519]                       }
[17:37:39.519]                       else if (inherits(cond, "condition")) {
[17:37:39.519]                         if (!is.null(pattern)) {
[17:37:39.519]                           computeRestarts <- base::computeRestarts
[17:37:39.519]                           grepl <- base::grepl
[17:37:39.519]                           restarts <- computeRestarts(cond)
[17:37:39.519]                           for (restart in restarts) {
[17:37:39.519]                             name <- restart$name
[17:37:39.519]                             if (is.null(name)) 
[17:37:39.519]                               next
[17:37:39.519]                             if (!grepl(pattern, name)) 
[17:37:39.519]                               next
[17:37:39.519]                             invokeRestart(restart)
[17:37:39.519]                             muffled <- TRUE
[17:37:39.519]                             break
[17:37:39.519]                           }
[17:37:39.519]                         }
[17:37:39.519]                       }
[17:37:39.519]                       invisible(muffled)
[17:37:39.519]                     }
[17:37:39.519]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.519]                   }
[17:37:39.519]                 }
[17:37:39.519]             }
[17:37:39.519]         }))
[17:37:39.519]     }, error = function(ex) {
[17:37:39.519]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:39.519]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.519]                 ...future.rng), started = ...future.startTime, 
[17:37:39.519]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:39.519]             version = "1.8"), class = "FutureResult")
[17:37:39.519]     }, finally = {
[17:37:39.519]         if (!identical(...future.workdir, getwd())) 
[17:37:39.519]             setwd(...future.workdir)
[17:37:39.519]         {
[17:37:39.519]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:39.519]                 ...future.oldOptions$nwarnings <- NULL
[17:37:39.519]             }
[17:37:39.519]             base::options(...future.oldOptions)
[17:37:39.519]             if (.Platform$OS.type == "windows") {
[17:37:39.519]                 old_names <- names(...future.oldEnvVars)
[17:37:39.519]                 envs <- base::Sys.getenv()
[17:37:39.519]                 names <- names(envs)
[17:37:39.519]                 common <- intersect(names, old_names)
[17:37:39.519]                 added <- setdiff(names, old_names)
[17:37:39.519]                 removed <- setdiff(old_names, names)
[17:37:39.519]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:39.519]                   envs[common]]
[17:37:39.519]                 NAMES <- toupper(changed)
[17:37:39.519]                 args <- list()
[17:37:39.519]                 for (kk in seq_along(NAMES)) {
[17:37:39.519]                   name <- changed[[kk]]
[17:37:39.519]                   NAME <- NAMES[[kk]]
[17:37:39.519]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.519]                     next
[17:37:39.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.519]                 }
[17:37:39.519]                 NAMES <- toupper(added)
[17:37:39.519]                 for (kk in seq_along(NAMES)) {
[17:37:39.519]                   name <- added[[kk]]
[17:37:39.519]                   NAME <- NAMES[[kk]]
[17:37:39.519]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.519]                     next
[17:37:39.519]                   args[[name]] <- ""
[17:37:39.519]                 }
[17:37:39.519]                 NAMES <- toupper(removed)
[17:37:39.519]                 for (kk in seq_along(NAMES)) {
[17:37:39.519]                   name <- removed[[kk]]
[17:37:39.519]                   NAME <- NAMES[[kk]]
[17:37:39.519]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.519]                     next
[17:37:39.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.519]                 }
[17:37:39.519]                 if (length(args) > 0) 
[17:37:39.519]                   base::do.call(base::Sys.setenv, args = args)
[17:37:39.519]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:39.519]             }
[17:37:39.519]             else {
[17:37:39.519]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:39.519]             }
[17:37:39.519]             {
[17:37:39.519]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:39.519]                   0L) {
[17:37:39.519]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:39.519]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:39.519]                   base::options(opts)
[17:37:39.519]                 }
[17:37:39.519]                 {
[17:37:39.519]                   {
[17:37:39.519]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:39.519]                     NULL
[17:37:39.519]                   }
[17:37:39.519]                   options(future.plan = NULL)
[17:37:39.519]                   if (is.na(NA_character_)) 
[17:37:39.519]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.519]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:39.519]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:39.519]                     .init = FALSE)
[17:37:39.519]                 }
[17:37:39.519]             }
[17:37:39.519]         }
[17:37:39.519]     })
[17:37:39.519]     if (TRUE) {
[17:37:39.519]         base::sink(type = "output", split = FALSE)
[17:37:39.519]         if (TRUE) {
[17:37:39.519]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:39.519]         }
[17:37:39.519]         else {
[17:37:39.519]             ...future.result["stdout"] <- base::list(NULL)
[17:37:39.519]         }
[17:37:39.519]         base::close(...future.stdout)
[17:37:39.519]         ...future.stdout <- NULL
[17:37:39.519]     }
[17:37:39.519]     ...future.result$conditions <- ...future.conditions
[17:37:39.519]     ...future.result$finished <- base::Sys.time()
[17:37:39.519]     ...future.result
[17:37:39.519] }
[17:37:39.522] Poll #1 (0): usedNodes() = 2, workers = 2
[17:37:39.532] receiveMessageFromWorker() for ClusterFuture ...
[17:37:39.533] - Validating connection of MultisessionFuture
[17:37:39.533] - received message: FutureResult
[17:37:39.533] - Received FutureResult
[17:37:39.533] - Erased future from FutureRegistry
[17:37:39.533] result() for ClusterFuture ...
[17:37:39.533] - result already collected: FutureResult
[17:37:39.533] result() for ClusterFuture ... done
[17:37:39.533] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:39.533] result() for ClusterFuture ...
[17:37:39.534] - result already collected: FutureResult
[17:37:39.534] result() for ClusterFuture ... done
[17:37:39.534] result() for ClusterFuture ...
[17:37:39.534] - result already collected: FutureResult
[17:37:39.534] result() for ClusterFuture ... done
[17:37:39.535] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[17:37:39.535] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:37:39.535] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:37:39.535] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:37:39.536] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.536] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[17:37:39.536] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[17:37:39.536] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:39.537] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.537] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:39.537] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.537] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[17:37:39.538] MultisessionFuture started
[17:37:39.538] - Launch lazy future ... done
[17:37:39.538] run() for ‘MultisessionFuture’ ... done
[17:37:39.538] Created future:
[17:37:39.539] MultisessionFuture:
[17:37:39.539] Label: ‘future_mapply-3’
[17:37:39.539] Expression:
[17:37:39.539] {
[17:37:39.539]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.539]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:39.539]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.539]         on.exit(options(oopts), add = TRUE)
[17:37:39.539]     }
[17:37:39.539]     {
[17:37:39.539]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.539]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:39.539]         do.call(mapply, args = args)
[17:37:39.539]     }
[17:37:39.539] }
[17:37:39.539] Lazy evaluation: FALSE
[17:37:39.539] Asynchronous evaluation: TRUE
[17:37:39.539] Local evaluation: TRUE
[17:37:39.539] Environment: R_GlobalEnv
[17:37:39.539] Capture standard output: TRUE
[17:37:39.539] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:39.539] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:39.539] Packages: <none>
[17:37:39.539] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:39.539] Resolved: FALSE
[17:37:39.539] Value: <not collected>
[17:37:39.539] Conditions captured: <none>
[17:37:39.539] Early signaling: FALSE
[17:37:39.539] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:39.539] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.550] Chunk #3 of 3 ... DONE
[17:37:39.550] Launching 3 futures (chunks) ... DONE
[17:37:39.550] Resolving 3 futures (chunks) ...
[17:37:39.550] resolve() on list ...
[17:37:39.550]  recursive: 0
[17:37:39.550]  length: 3
[17:37:39.550] 
[17:37:39.551] Future #1
[17:37:39.551] result() for ClusterFuture ...
[17:37:39.551] - result already collected: FutureResult
[17:37:39.551] result() for ClusterFuture ... done
[17:37:39.551] result() for ClusterFuture ...
[17:37:39.551] - result already collected: FutureResult
[17:37:39.551] result() for ClusterFuture ... done
[17:37:39.551] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:37:39.551] - nx: 3
[17:37:39.551] - relay: TRUE
[17:37:39.552] - stdout: TRUE
[17:37:39.552] - signal: TRUE
[17:37:39.552] - resignal: FALSE
[17:37:39.552] - force: TRUE
[17:37:39.552] - relayed: [n=3] FALSE, FALSE, FALSE
[17:37:39.552] - queued futures: [n=3] FALSE, FALSE, FALSE
[17:37:39.552]  - until=1
[17:37:39.552]  - relaying element #1
[17:37:39.552] result() for ClusterFuture ...
[17:37:39.552] - result already collected: FutureResult
[17:37:39.555] result() for ClusterFuture ... done
[17:37:39.555] result() for ClusterFuture ...
[17:37:39.555] - result already collected: FutureResult
[17:37:39.555] result() for ClusterFuture ... done
[17:37:39.555] result() for ClusterFuture ...
[17:37:39.555] - result already collected: FutureResult
[17:37:39.555] result() for ClusterFuture ... done
[17:37:39.555] result() for ClusterFuture ...
[17:37:39.555] - result already collected: FutureResult
[17:37:39.555] result() for ClusterFuture ... done
[17:37:39.556] - relayed: [n=3] TRUE, FALSE, FALSE
[17:37:39.556] - queued futures: [n=3] TRUE, FALSE, FALSE
[17:37:39.556] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:37:39.556]  length: 2 (resolved future 1)
[17:37:39.556] receiveMessageFromWorker() for ClusterFuture ...
[17:37:39.556] - Validating connection of MultisessionFuture
[17:37:39.557] - received message: FutureResult
[17:37:39.557] - Received FutureResult
[17:37:39.557] - Erased future from FutureRegistry
[17:37:39.557] result() for ClusterFuture ...
[17:37:39.557] - result already collected: FutureResult
[17:37:39.557] result() for ClusterFuture ... done
[17:37:39.557] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:39.557] Future #2
[17:37:39.557] result() for ClusterFuture ...
[17:37:39.557] - result already collected: FutureResult
[17:37:39.558] result() for ClusterFuture ... done
[17:37:39.558] result() for ClusterFuture ...
[17:37:39.558] - result already collected: FutureResult
[17:37:39.558] result() for ClusterFuture ... done
[17:37:39.558] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:37:39.558] - nx: 3
[17:37:39.558] - relay: TRUE
[17:37:39.558] - stdout: TRUE
[17:37:39.558] - signal: TRUE
[17:37:39.558] - resignal: FALSE
[17:37:39.558] - force: TRUE
[17:37:39.558] - relayed: [n=3] TRUE, FALSE, FALSE
[17:37:39.559] - queued futures: [n=3] TRUE, FALSE, FALSE
[17:37:39.559]  - until=2
[17:37:39.559]  - relaying element #2
[17:37:39.559] result() for ClusterFuture ...
[17:37:39.559] - result already collected: FutureResult
[17:37:39.559] result() for ClusterFuture ... done
[17:37:39.559] result() for ClusterFuture ...
[17:37:39.559] - result already collected: FutureResult
[17:37:39.559] result() for ClusterFuture ... done
[17:37:39.559] result() for ClusterFuture ...
[17:37:39.559] - result already collected: FutureResult
[17:37:39.559] result() for ClusterFuture ... done
[17:37:39.560] result() for ClusterFuture ...
[17:37:39.560] - result already collected: FutureResult
[17:37:39.560] result() for ClusterFuture ... done
[17:37:39.560] - relayed: [n=3] TRUE, TRUE, FALSE
[17:37:39.560] - queued futures: [n=3] TRUE, TRUE, FALSE
[17:37:39.560] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:37:39.560]  length: 1 (resolved future 2)
[17:37:39.582] receiveMessageFromWorker() for ClusterFuture ...
[17:37:39.583] - Validating connection of MultisessionFuture
[17:37:39.583] - received message: FutureResult
[17:37:39.583] - Received FutureResult
[17:37:39.583] - Erased future from FutureRegistry
[17:37:39.583] result() for ClusterFuture ...
[17:37:39.583] - result already collected: FutureResult
[17:37:39.583] result() for ClusterFuture ... done
[17:37:39.583] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:39.584] Future #3
[17:37:39.584] result() for ClusterFuture ...
[17:37:39.584] - result already collected: FutureResult
[17:37:39.584] result() for ClusterFuture ... done
[17:37:39.584] result() for ClusterFuture ...
[17:37:39.584] - result already collected: FutureResult
[17:37:39.584] result() for ClusterFuture ... done
[17:37:39.584] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:37:39.584] - nx: 3
[17:37:39.584] - relay: TRUE
[17:37:39.584] - stdout: TRUE
[17:37:39.585] - signal: TRUE
[17:37:39.585] - resignal: FALSE
[17:37:39.585] - force: TRUE
[17:37:39.585] - relayed: [n=3] TRUE, TRUE, FALSE
[17:37:39.585] - queued futures: [n=3] TRUE, TRUE, FALSE
[17:37:39.585]  - until=3
[17:37:39.585]  - relaying element #3
[17:37:39.585] result() for ClusterFuture ...
[17:37:39.585] - result already collected: FutureResult
[17:37:39.585] result() for ClusterFuture ... done
[17:37:39.585] result() for ClusterFuture ...
[17:37:39.585] - result already collected: FutureResult
[17:37:39.586] result() for ClusterFuture ... done
[17:37:39.586] result() for ClusterFuture ...
[17:37:39.586] - result already collected: FutureResult
[17:37:39.586] result() for ClusterFuture ... done
[17:37:39.586] result() for ClusterFuture ...
[17:37:39.586] - result already collected: FutureResult
[17:37:39.586] result() for ClusterFuture ... done
[17:37:39.586] - relayed: [n=3] TRUE, TRUE, TRUE
[17:37:39.586] - queued futures: [n=3] TRUE, TRUE, TRUE
[17:37:39.586] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:37:39.587]  length: 0 (resolved future 3)
[17:37:39.587] Relaying remaining futures
[17:37:39.587] signalConditionsASAP(NULL, pos=0) ...
[17:37:39.587] - nx: 3
[17:37:39.587] - relay: TRUE
[17:37:39.587] - stdout: TRUE
[17:37:39.587] - signal: TRUE
[17:37:39.587] - resignal: FALSE
[17:37:39.587] - force: TRUE
[17:37:39.587] - relayed: [n=3] TRUE, TRUE, TRUE
[17:37:39.587] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[17:37:39.587] - relayed: [n=3] TRUE, TRUE, TRUE
[17:37:39.588] - queued futures: [n=3] TRUE, TRUE, TRUE
[17:37:39.588] signalConditionsASAP(NULL, pos=0) ... done
[17:37:39.588] resolve() on list ... DONE
[17:37:39.588] result() for ClusterFuture ...
[17:37:39.588] - result already collected: FutureResult
[17:37:39.588] result() for ClusterFuture ... done
[17:37:39.588] result() for ClusterFuture ...
[17:37:39.588] - result already collected: FutureResult
[17:37:39.588] result() for ClusterFuture ... done
[17:37:39.588] result() for ClusterFuture ...
[17:37:39.588] - result already collected: FutureResult
[17:37:39.589] result() for ClusterFuture ... done
[17:37:39.589] result() for ClusterFuture ...
[17:37:39.589] - result already collected: FutureResult
[17:37:39.589] result() for ClusterFuture ... done
[17:37:39.589] result() for ClusterFuture ...
[17:37:39.589] - result already collected: FutureResult
[17:37:39.589] result() for ClusterFuture ... done
[17:37:39.589] result() for ClusterFuture ...
[17:37:39.589] - result already collected: FutureResult
[17:37:39.589] result() for ClusterFuture ... done
[17:37:39.589]  - Number of value chunks collected: 3
[17:37:39.589] Resolving 3 futures (chunks) ... DONE
[17:37:39.590] Reducing values from 3 chunks ...
[17:37:39.590]  - Number of values collected after concatenation: 5
[17:37:39.590]  - Number of values expected: 5
[17:37:39.590] Reverse index remapping (attribute 'ordering'): [n = 5] 2, 5, 1, 3, 4
[17:37:39.590] Reducing values from 3 chunks ... DONE
[17:37:39.590] future_mapply() ... DONE
[17:37:39.590] future_mapply() ...
[17:37:39.594] Number of chunks: 2
[17:37:39.595] getGlobalsAndPackagesXApply() ...
[17:37:39.595]  - future.globals: TRUE
[17:37:39.595] getGlobalsAndPackages() ...
[17:37:39.595] Searching for globals...
[17:37:39.596] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:37:39.596] Searching for globals ... DONE
[17:37:39.597] Resolving globals: FALSE
[17:37:39.597] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:37:39.597] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:37:39.597] - globals: [1] ‘FUN’
[17:37:39.598] 
[17:37:39.598] getGlobalsAndPackages() ... DONE
[17:37:39.598]  - globals found/used: [n=1] ‘FUN’
[17:37:39.598]  - needed namespaces: [n=0] 
[17:37:39.598] Finding globals ... DONE
[17:37:39.598] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:39.598] List of 2
[17:37:39.598]  $ ...future.FUN:function (C, k)  
[17:37:39.598]  $ MoreArgs     : list()
[17:37:39.598]  - attr(*, "where")=List of 2
[17:37:39.598]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:39.598]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:39.598]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:39.598]  - attr(*, "resolved")= logi FALSE
[17:37:39.598]  - attr(*, "total_size")= num NA
[17:37:39.601] Packages to be attached in all futures: [n=0] 
[17:37:39.601] getGlobalsAndPackagesXApply() ... DONE
[17:37:39.601] Number of futures (= number of chunks): 2
[17:37:39.601] Launching 2 futures (chunks) ...
[17:37:39.601] Chunk #1 of 2 ...
[17:37:39.601]  - Finding globals in '...' for chunk #1 ...
[17:37:39.601] getGlobalsAndPackages() ...
[17:37:39.601] Searching for globals...
[17:37:39.602] 
[17:37:39.602] Searching for globals ... DONE
[17:37:39.602] - globals: [0] <none>
[17:37:39.602] getGlobalsAndPackages() ... DONE
[17:37:39.602]    + additional globals found: [n=0] 
[17:37:39.602]    + additional namespaces needed: [n=0] 
[17:37:39.602]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:39.602]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:39.602]  - seeds: <none>
[17:37:39.602]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.603] getGlobalsAndPackages() ...
[17:37:39.603] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.603] Resolving globals: FALSE
[17:37:39.603] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:37:39.604] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:39.604] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.604] 
[17:37:39.604] getGlobalsAndPackages() ... DONE
[17:37:39.604] run() for ‘Future’ ...
[17:37:39.604] - state: ‘created’
[17:37:39.605] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:39.618] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.618] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:39.618]   - Field: ‘node’
[17:37:39.618]   - Field: ‘label’
[17:37:39.618]   - Field: ‘local’
[17:37:39.618]   - Field: ‘owner’
[17:37:39.618]   - Field: ‘envir’
[17:37:39.619]   - Field: ‘workers’
[17:37:39.619]   - Field: ‘packages’
[17:37:39.619]   - Field: ‘gc’
[17:37:39.619]   - Field: ‘conditions’
[17:37:39.619]   - Field: ‘persistent’
[17:37:39.619]   - Field: ‘expr’
[17:37:39.619]   - Field: ‘uuid’
[17:37:39.619]   - Field: ‘seed’
[17:37:39.619]   - Field: ‘version’
[17:37:39.619]   - Field: ‘result’
[17:37:39.619]   - Field: ‘asynchronous’
[17:37:39.620]   - Field: ‘calls’
[17:37:39.620]   - Field: ‘globals’
[17:37:39.620]   - Field: ‘stdout’
[17:37:39.620]   - Field: ‘earlySignal’
[17:37:39.620]   - Field: ‘lazy’
[17:37:39.620]   - Field: ‘state’
[17:37:39.620] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:39.620] - Launch lazy future ...
[17:37:39.620] Packages needed by the future expression (n = 0): <none>
[17:37:39.621] Packages needed by future strategies (n = 0): <none>
[17:37:39.621] {
[17:37:39.621]     {
[17:37:39.621]         {
[17:37:39.621]             ...future.startTime <- base::Sys.time()
[17:37:39.621]             {
[17:37:39.621]                 {
[17:37:39.621]                   {
[17:37:39.621]                     {
[17:37:39.621]                       base::local({
[17:37:39.621]                         has_future <- base::requireNamespace("future", 
[17:37:39.621]                           quietly = TRUE)
[17:37:39.621]                         if (has_future) {
[17:37:39.621]                           ns <- base::getNamespace("future")
[17:37:39.621]                           version <- ns[[".package"]][["version"]]
[17:37:39.621]                           if (is.null(version)) 
[17:37:39.621]                             version <- utils::packageVersion("future")
[17:37:39.621]                         }
[17:37:39.621]                         else {
[17:37:39.621]                           version <- NULL
[17:37:39.621]                         }
[17:37:39.621]                         if (!has_future || version < "1.8.0") {
[17:37:39.621]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:39.621]                             "", base::R.version$version.string), 
[17:37:39.621]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:39.621]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:39.621]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:39.621]                               "release", "version")], collapse = " "), 
[17:37:39.621]                             hostname = base::Sys.info()[["nodename"]])
[17:37:39.621]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:39.621]                             info)
[17:37:39.621]                           info <- base::paste(info, collapse = "; ")
[17:37:39.621]                           if (!has_future) {
[17:37:39.621]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:39.621]                               info)
[17:37:39.621]                           }
[17:37:39.621]                           else {
[17:37:39.621]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:39.621]                               info, version)
[17:37:39.621]                           }
[17:37:39.621]                           base::stop(msg)
[17:37:39.621]                         }
[17:37:39.621]                       })
[17:37:39.621]                     }
[17:37:39.621]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:39.621]                     base::options(mc.cores = 1L)
[17:37:39.621]                   }
[17:37:39.621]                   ...future.strategy.old <- future::plan("list")
[17:37:39.621]                   options(future.plan = NULL)
[17:37:39.621]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.621]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:39.621]                 }
[17:37:39.621]                 ...future.workdir <- getwd()
[17:37:39.621]             }
[17:37:39.621]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:39.621]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:39.621]         }
[17:37:39.621]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:39.621]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:39.621]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:39.621]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:39.621]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:39.621]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:39.621]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:39.621]             base::names(...future.oldOptions))
[17:37:39.621]     }
[17:37:39.621]     if (FALSE) {
[17:37:39.621]     }
[17:37:39.621]     else {
[17:37:39.621]         if (TRUE) {
[17:37:39.621]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:39.621]                 open = "w")
[17:37:39.621]         }
[17:37:39.621]         else {
[17:37:39.621]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:39.621]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:39.621]         }
[17:37:39.621]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:39.621]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:39.621]             base::sink(type = "output", split = FALSE)
[17:37:39.621]             base::close(...future.stdout)
[17:37:39.621]         }, add = TRUE)
[17:37:39.621]     }
[17:37:39.621]     ...future.frame <- base::sys.nframe()
[17:37:39.621]     ...future.conditions <- base::list()
[17:37:39.621]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:39.621]     if (FALSE) {
[17:37:39.621]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:39.621]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:39.621]     }
[17:37:39.621]     ...future.result <- base::tryCatch({
[17:37:39.621]         base::withCallingHandlers({
[17:37:39.621]             ...future.value <- base::withVisible(base::local({
[17:37:39.621]                 ...future.makeSendCondition <- base::local({
[17:37:39.621]                   sendCondition <- NULL
[17:37:39.621]                   function(frame = 1L) {
[17:37:39.621]                     if (is.function(sendCondition)) 
[17:37:39.621]                       return(sendCondition)
[17:37:39.621]                     ns <- getNamespace("parallel")
[17:37:39.621]                     if (exists("sendData", mode = "function", 
[17:37:39.621]                       envir = ns)) {
[17:37:39.621]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:39.621]                         envir = ns)
[17:37:39.621]                       envir <- sys.frame(frame)
[17:37:39.621]                       master <- NULL
[17:37:39.621]                       while (!identical(envir, .GlobalEnv) && 
[17:37:39.621]                         !identical(envir, emptyenv())) {
[17:37:39.621]                         if (exists("master", mode = "list", envir = envir, 
[17:37:39.621]                           inherits = FALSE)) {
[17:37:39.621]                           master <- get("master", mode = "list", 
[17:37:39.621]                             envir = envir, inherits = FALSE)
[17:37:39.621]                           if (inherits(master, c("SOCKnode", 
[17:37:39.621]                             "SOCK0node"))) {
[17:37:39.621]                             sendCondition <<- function(cond) {
[17:37:39.621]                               data <- list(type = "VALUE", value = cond, 
[17:37:39.621]                                 success = TRUE)
[17:37:39.621]                               parallel_sendData(master, data)
[17:37:39.621]                             }
[17:37:39.621]                             return(sendCondition)
[17:37:39.621]                           }
[17:37:39.621]                         }
[17:37:39.621]                         frame <- frame + 1L
[17:37:39.621]                         envir <- sys.frame(frame)
[17:37:39.621]                       }
[17:37:39.621]                     }
[17:37:39.621]                     sendCondition <<- function(cond) NULL
[17:37:39.621]                   }
[17:37:39.621]                 })
[17:37:39.621]                 withCallingHandlers({
[17:37:39.621]                   {
[17:37:39.621]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.621]                     if (!identical(...future.globals.maxSize.org, 
[17:37:39.621]                       ...future.globals.maxSize)) {
[17:37:39.621]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.621]                       on.exit(options(oopts), add = TRUE)
[17:37:39.621]                     }
[17:37:39.621]                     {
[17:37:39.621]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.621]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:39.621]                         USE.NAMES = FALSE)
[17:37:39.621]                       do.call(mapply, args = args)
[17:37:39.621]                     }
[17:37:39.621]                   }
[17:37:39.621]                 }, immediateCondition = function(cond) {
[17:37:39.621]                   sendCondition <- ...future.makeSendCondition()
[17:37:39.621]                   sendCondition(cond)
[17:37:39.621]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.621]                   {
[17:37:39.621]                     inherits <- base::inherits
[17:37:39.621]                     invokeRestart <- base::invokeRestart
[17:37:39.621]                     is.null <- base::is.null
[17:37:39.621]                     muffled <- FALSE
[17:37:39.621]                     if (inherits(cond, "message")) {
[17:37:39.621]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:39.621]                       if (muffled) 
[17:37:39.621]                         invokeRestart("muffleMessage")
[17:37:39.621]                     }
[17:37:39.621]                     else if (inherits(cond, "warning")) {
[17:37:39.621]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:39.621]                       if (muffled) 
[17:37:39.621]                         invokeRestart("muffleWarning")
[17:37:39.621]                     }
[17:37:39.621]                     else if (inherits(cond, "condition")) {
[17:37:39.621]                       if (!is.null(pattern)) {
[17:37:39.621]                         computeRestarts <- base::computeRestarts
[17:37:39.621]                         grepl <- base::grepl
[17:37:39.621]                         restarts <- computeRestarts(cond)
[17:37:39.621]                         for (restart in restarts) {
[17:37:39.621]                           name <- restart$name
[17:37:39.621]                           if (is.null(name)) 
[17:37:39.621]                             next
[17:37:39.621]                           if (!grepl(pattern, name)) 
[17:37:39.621]                             next
[17:37:39.621]                           invokeRestart(restart)
[17:37:39.621]                           muffled <- TRUE
[17:37:39.621]                           break
[17:37:39.621]                         }
[17:37:39.621]                       }
[17:37:39.621]                     }
[17:37:39.621]                     invisible(muffled)
[17:37:39.621]                   }
[17:37:39.621]                   muffleCondition(cond)
[17:37:39.621]                 })
[17:37:39.621]             }))
[17:37:39.621]             future::FutureResult(value = ...future.value$value, 
[17:37:39.621]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.621]                   ...future.rng), globalenv = if (FALSE) 
[17:37:39.621]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:39.621]                     ...future.globalenv.names))
[17:37:39.621]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:39.621]         }, condition = base::local({
[17:37:39.621]             c <- base::c
[17:37:39.621]             inherits <- base::inherits
[17:37:39.621]             invokeRestart <- base::invokeRestart
[17:37:39.621]             length <- base::length
[17:37:39.621]             list <- base::list
[17:37:39.621]             seq.int <- base::seq.int
[17:37:39.621]             signalCondition <- base::signalCondition
[17:37:39.621]             sys.calls <- base::sys.calls
[17:37:39.621]             `[[` <- base::`[[`
[17:37:39.621]             `+` <- base::`+`
[17:37:39.621]             `<<-` <- base::`<<-`
[17:37:39.621]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:39.621]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:39.621]                   3L)]
[17:37:39.621]             }
[17:37:39.621]             function(cond) {
[17:37:39.621]                 is_error <- inherits(cond, "error")
[17:37:39.621]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:39.621]                   NULL)
[17:37:39.621]                 if (is_error) {
[17:37:39.621]                   sessionInformation <- function() {
[17:37:39.621]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:39.621]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:39.621]                       search = base::search(), system = base::Sys.info())
[17:37:39.621]                   }
[17:37:39.621]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.621]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:39.621]                     cond$call), session = sessionInformation(), 
[17:37:39.621]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:39.621]                   signalCondition(cond)
[17:37:39.621]                 }
[17:37:39.621]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:39.621]                 "immediateCondition"))) {
[17:37:39.621]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:39.621]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.621]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:39.621]                   if (TRUE && !signal) {
[17:37:39.621]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.621]                     {
[17:37:39.621]                       inherits <- base::inherits
[17:37:39.621]                       invokeRestart <- base::invokeRestart
[17:37:39.621]                       is.null <- base::is.null
[17:37:39.621]                       muffled <- FALSE
[17:37:39.621]                       if (inherits(cond, "message")) {
[17:37:39.621]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.621]                         if (muffled) 
[17:37:39.621]                           invokeRestart("muffleMessage")
[17:37:39.621]                       }
[17:37:39.621]                       else if (inherits(cond, "warning")) {
[17:37:39.621]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.621]                         if (muffled) 
[17:37:39.621]                           invokeRestart("muffleWarning")
[17:37:39.621]                       }
[17:37:39.621]                       else if (inherits(cond, "condition")) {
[17:37:39.621]                         if (!is.null(pattern)) {
[17:37:39.621]                           computeRestarts <- base::computeRestarts
[17:37:39.621]                           grepl <- base::grepl
[17:37:39.621]                           restarts <- computeRestarts(cond)
[17:37:39.621]                           for (restart in restarts) {
[17:37:39.621]                             name <- restart$name
[17:37:39.621]                             if (is.null(name)) 
[17:37:39.621]                               next
[17:37:39.621]                             if (!grepl(pattern, name)) 
[17:37:39.621]                               next
[17:37:39.621]                             invokeRestart(restart)
[17:37:39.621]                             muffled <- TRUE
[17:37:39.621]                             break
[17:37:39.621]                           }
[17:37:39.621]                         }
[17:37:39.621]                       }
[17:37:39.621]                       invisible(muffled)
[17:37:39.621]                     }
[17:37:39.621]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.621]                   }
[17:37:39.621]                 }
[17:37:39.621]                 else {
[17:37:39.621]                   if (TRUE) {
[17:37:39.621]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.621]                     {
[17:37:39.621]                       inherits <- base::inherits
[17:37:39.621]                       invokeRestart <- base::invokeRestart
[17:37:39.621]                       is.null <- base::is.null
[17:37:39.621]                       muffled <- FALSE
[17:37:39.621]                       if (inherits(cond, "message")) {
[17:37:39.621]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.621]                         if (muffled) 
[17:37:39.621]                           invokeRestart("muffleMessage")
[17:37:39.621]                       }
[17:37:39.621]                       else if (inherits(cond, "warning")) {
[17:37:39.621]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.621]                         if (muffled) 
[17:37:39.621]                           invokeRestart("muffleWarning")
[17:37:39.621]                       }
[17:37:39.621]                       else if (inherits(cond, "condition")) {
[17:37:39.621]                         if (!is.null(pattern)) {
[17:37:39.621]                           computeRestarts <- base::computeRestarts
[17:37:39.621]                           grepl <- base::grepl
[17:37:39.621]                           restarts <- computeRestarts(cond)
[17:37:39.621]                           for (restart in restarts) {
[17:37:39.621]                             name <- restart$name
[17:37:39.621]                             if (is.null(name)) 
[17:37:39.621]                               next
[17:37:39.621]                             if (!grepl(pattern, name)) 
[17:37:39.621]                               next
[17:37:39.621]                             invokeRestart(restart)
[17:37:39.621]                             muffled <- TRUE
[17:37:39.621]                             break
[17:37:39.621]                           }
[17:37:39.621]                         }
[17:37:39.621]                       }
[17:37:39.621]                       invisible(muffled)
[17:37:39.621]                     }
[17:37:39.621]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.621]                   }
[17:37:39.621]                 }
[17:37:39.621]             }
[17:37:39.621]         }))
[17:37:39.621]     }, error = function(ex) {
[17:37:39.621]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:39.621]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.621]                 ...future.rng), started = ...future.startTime, 
[17:37:39.621]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:39.621]             version = "1.8"), class = "FutureResult")
[17:37:39.621]     }, finally = {
[17:37:39.621]         if (!identical(...future.workdir, getwd())) 
[17:37:39.621]             setwd(...future.workdir)
[17:37:39.621]         {
[17:37:39.621]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:39.621]                 ...future.oldOptions$nwarnings <- NULL
[17:37:39.621]             }
[17:37:39.621]             base::options(...future.oldOptions)
[17:37:39.621]             if (.Platform$OS.type == "windows") {
[17:37:39.621]                 old_names <- names(...future.oldEnvVars)
[17:37:39.621]                 envs <- base::Sys.getenv()
[17:37:39.621]                 names <- names(envs)
[17:37:39.621]                 common <- intersect(names, old_names)
[17:37:39.621]                 added <- setdiff(names, old_names)
[17:37:39.621]                 removed <- setdiff(old_names, names)
[17:37:39.621]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:39.621]                   envs[common]]
[17:37:39.621]                 NAMES <- toupper(changed)
[17:37:39.621]                 args <- list()
[17:37:39.621]                 for (kk in seq_along(NAMES)) {
[17:37:39.621]                   name <- changed[[kk]]
[17:37:39.621]                   NAME <- NAMES[[kk]]
[17:37:39.621]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.621]                     next
[17:37:39.621]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.621]                 }
[17:37:39.621]                 NAMES <- toupper(added)
[17:37:39.621]                 for (kk in seq_along(NAMES)) {
[17:37:39.621]                   name <- added[[kk]]
[17:37:39.621]                   NAME <- NAMES[[kk]]
[17:37:39.621]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.621]                     next
[17:37:39.621]                   args[[name]] <- ""
[17:37:39.621]                 }
[17:37:39.621]                 NAMES <- toupper(removed)
[17:37:39.621]                 for (kk in seq_along(NAMES)) {
[17:37:39.621]                   name <- removed[[kk]]
[17:37:39.621]                   NAME <- NAMES[[kk]]
[17:37:39.621]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.621]                     next
[17:37:39.621]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.621]                 }
[17:37:39.621]                 if (length(args) > 0) 
[17:37:39.621]                   base::do.call(base::Sys.setenv, args = args)
[17:37:39.621]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:39.621]             }
[17:37:39.621]             else {
[17:37:39.621]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:39.621]             }
[17:37:39.621]             {
[17:37:39.621]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:39.621]                   0L) {
[17:37:39.621]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:39.621]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:39.621]                   base::options(opts)
[17:37:39.621]                 }
[17:37:39.621]                 {
[17:37:39.621]                   {
[17:37:39.621]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:39.621]                     NULL
[17:37:39.621]                   }
[17:37:39.621]                   options(future.plan = NULL)
[17:37:39.621]                   if (is.na(NA_character_)) 
[17:37:39.621]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.621]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:39.621]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:39.621]                     .init = FALSE)
[17:37:39.621]                 }
[17:37:39.621]             }
[17:37:39.621]         }
[17:37:39.621]     })
[17:37:39.621]     if (TRUE) {
[17:37:39.621]         base::sink(type = "output", split = FALSE)
[17:37:39.621]         if (TRUE) {
[17:37:39.621]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:39.621]         }
[17:37:39.621]         else {
[17:37:39.621]             ...future.result["stdout"] <- base::list(NULL)
[17:37:39.621]         }
[17:37:39.621]         base::close(...future.stdout)
[17:37:39.621]         ...future.stdout <- NULL
[17:37:39.621]     }
[17:37:39.621]     ...future.result$conditions <- ...future.conditions
[17:37:39.621]     ...future.result$finished <- base::Sys.time()
[17:37:39.621]     ...future.result
[17:37:39.621] }
[17:37:39.624] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[17:37:39.624] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:37:39.624] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:37:39.625] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:37:39.625] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.625] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[17:37:39.625] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[17:37:39.626] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:39.626] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.626] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:39.626] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.627] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[17:37:39.627] MultisessionFuture started
[17:37:39.627] - Launch lazy future ... done
[17:37:39.627] run() for ‘MultisessionFuture’ ... done
[17:37:39.628] Created future:
[17:37:39.628] MultisessionFuture:
[17:37:39.628] Label: ‘future_.mapply-1’
[17:37:39.628] Expression:
[17:37:39.628] {
[17:37:39.628]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.628]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:39.628]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.628]         on.exit(options(oopts), add = TRUE)
[17:37:39.628]     }
[17:37:39.628]     {
[17:37:39.628]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.628]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:39.628]         do.call(mapply, args = args)
[17:37:39.628]     }
[17:37:39.628] }
[17:37:39.628] Lazy evaluation: FALSE
[17:37:39.628] Asynchronous evaluation: TRUE
[17:37:39.628] Local evaluation: TRUE
[17:37:39.628] Environment: R_GlobalEnv
[17:37:39.628] Capture standard output: TRUE
[17:37:39.628] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:39.628] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:39.628] Packages: <none>
[17:37:39.628] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:39.628] Resolved: FALSE
[17:37:39.628] Value: <not collected>
[17:37:39.628] Conditions captured: <none>
[17:37:39.628] Early signaling: FALSE
[17:37:39.628] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:39.628] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.639] Chunk #1 of 2 ... DONE
[17:37:39.639] Chunk #2 of 2 ...
[17:37:39.639]  - Finding globals in '...' for chunk #2 ...
[17:37:39.640] getGlobalsAndPackages() ...
[17:37:39.640] Searching for globals...
[17:37:39.640] 
[17:37:39.640] Searching for globals ... DONE
[17:37:39.640] - globals: [0] <none>
[17:37:39.640] getGlobalsAndPackages() ... DONE
[17:37:39.640]    + additional globals found: [n=0] 
[17:37:39.641]    + additional namespaces needed: [n=0] 
[17:37:39.641]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:39.641]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:39.641]  - seeds: <none>
[17:37:39.641]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.641] getGlobalsAndPackages() ...
[17:37:39.641] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.641] Resolving globals: FALSE
[17:37:39.642] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:37:39.642] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:39.642] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.642] 
[17:37:39.642] getGlobalsAndPackages() ... DONE
[17:37:39.643] run() for ‘Future’ ...
[17:37:39.643] - state: ‘created’
[17:37:39.643] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:39.657] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.657] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:39.657]   - Field: ‘node’
[17:37:39.657]   - Field: ‘label’
[17:37:39.657]   - Field: ‘local’
[17:37:39.657]   - Field: ‘owner’
[17:37:39.657]   - Field: ‘envir’
[17:37:39.657]   - Field: ‘workers’
[17:37:39.657]   - Field: ‘packages’
[17:37:39.657]   - Field: ‘gc’
[17:37:39.658]   - Field: ‘conditions’
[17:37:39.658]   - Field: ‘persistent’
[17:37:39.658]   - Field: ‘expr’
[17:37:39.658]   - Field: ‘uuid’
[17:37:39.658]   - Field: ‘seed’
[17:37:39.658]   - Field: ‘version’
[17:37:39.658]   - Field: ‘result’
[17:37:39.658]   - Field: ‘asynchronous’
[17:37:39.658]   - Field: ‘calls’
[17:37:39.658]   - Field: ‘globals’
[17:37:39.658]   - Field: ‘stdout’
[17:37:39.658]   - Field: ‘earlySignal’
[17:37:39.659]   - Field: ‘lazy’
[17:37:39.659]   - Field: ‘state’
[17:37:39.659] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:39.659] - Launch lazy future ...
[17:37:39.659] Packages needed by the future expression (n = 0): <none>
[17:37:39.659] Packages needed by future strategies (n = 0): <none>
[17:37:39.660] {
[17:37:39.660]     {
[17:37:39.660]         {
[17:37:39.660]             ...future.startTime <- base::Sys.time()
[17:37:39.660]             {
[17:37:39.660]                 {
[17:37:39.660]                   {
[17:37:39.660]                     {
[17:37:39.660]                       base::local({
[17:37:39.660]                         has_future <- base::requireNamespace("future", 
[17:37:39.660]                           quietly = TRUE)
[17:37:39.660]                         if (has_future) {
[17:37:39.660]                           ns <- base::getNamespace("future")
[17:37:39.660]                           version <- ns[[".package"]][["version"]]
[17:37:39.660]                           if (is.null(version)) 
[17:37:39.660]                             version <- utils::packageVersion("future")
[17:37:39.660]                         }
[17:37:39.660]                         else {
[17:37:39.660]                           version <- NULL
[17:37:39.660]                         }
[17:37:39.660]                         if (!has_future || version < "1.8.0") {
[17:37:39.660]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:39.660]                             "", base::R.version$version.string), 
[17:37:39.660]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:39.660]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:39.660]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:39.660]                               "release", "version")], collapse = " "), 
[17:37:39.660]                             hostname = base::Sys.info()[["nodename"]])
[17:37:39.660]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:39.660]                             info)
[17:37:39.660]                           info <- base::paste(info, collapse = "; ")
[17:37:39.660]                           if (!has_future) {
[17:37:39.660]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:39.660]                               info)
[17:37:39.660]                           }
[17:37:39.660]                           else {
[17:37:39.660]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:39.660]                               info, version)
[17:37:39.660]                           }
[17:37:39.660]                           base::stop(msg)
[17:37:39.660]                         }
[17:37:39.660]                       })
[17:37:39.660]                     }
[17:37:39.660]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:39.660]                     base::options(mc.cores = 1L)
[17:37:39.660]                   }
[17:37:39.660]                   ...future.strategy.old <- future::plan("list")
[17:37:39.660]                   options(future.plan = NULL)
[17:37:39.660]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.660]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:39.660]                 }
[17:37:39.660]                 ...future.workdir <- getwd()
[17:37:39.660]             }
[17:37:39.660]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:39.660]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:39.660]         }
[17:37:39.660]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:39.660]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:39.660]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:39.660]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:39.660]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:39.660]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:39.660]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:39.660]             base::names(...future.oldOptions))
[17:37:39.660]     }
[17:37:39.660]     if (FALSE) {
[17:37:39.660]     }
[17:37:39.660]     else {
[17:37:39.660]         if (TRUE) {
[17:37:39.660]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:39.660]                 open = "w")
[17:37:39.660]         }
[17:37:39.660]         else {
[17:37:39.660]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:39.660]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:39.660]         }
[17:37:39.660]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:39.660]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:39.660]             base::sink(type = "output", split = FALSE)
[17:37:39.660]             base::close(...future.stdout)
[17:37:39.660]         }, add = TRUE)
[17:37:39.660]     }
[17:37:39.660]     ...future.frame <- base::sys.nframe()
[17:37:39.660]     ...future.conditions <- base::list()
[17:37:39.660]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:39.660]     if (FALSE) {
[17:37:39.660]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:39.660]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:39.660]     }
[17:37:39.660]     ...future.result <- base::tryCatch({
[17:37:39.660]         base::withCallingHandlers({
[17:37:39.660]             ...future.value <- base::withVisible(base::local({
[17:37:39.660]                 ...future.makeSendCondition <- base::local({
[17:37:39.660]                   sendCondition <- NULL
[17:37:39.660]                   function(frame = 1L) {
[17:37:39.660]                     if (is.function(sendCondition)) 
[17:37:39.660]                       return(sendCondition)
[17:37:39.660]                     ns <- getNamespace("parallel")
[17:37:39.660]                     if (exists("sendData", mode = "function", 
[17:37:39.660]                       envir = ns)) {
[17:37:39.660]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:39.660]                         envir = ns)
[17:37:39.660]                       envir <- sys.frame(frame)
[17:37:39.660]                       master <- NULL
[17:37:39.660]                       while (!identical(envir, .GlobalEnv) && 
[17:37:39.660]                         !identical(envir, emptyenv())) {
[17:37:39.660]                         if (exists("master", mode = "list", envir = envir, 
[17:37:39.660]                           inherits = FALSE)) {
[17:37:39.660]                           master <- get("master", mode = "list", 
[17:37:39.660]                             envir = envir, inherits = FALSE)
[17:37:39.660]                           if (inherits(master, c("SOCKnode", 
[17:37:39.660]                             "SOCK0node"))) {
[17:37:39.660]                             sendCondition <<- function(cond) {
[17:37:39.660]                               data <- list(type = "VALUE", value = cond, 
[17:37:39.660]                                 success = TRUE)
[17:37:39.660]                               parallel_sendData(master, data)
[17:37:39.660]                             }
[17:37:39.660]                             return(sendCondition)
[17:37:39.660]                           }
[17:37:39.660]                         }
[17:37:39.660]                         frame <- frame + 1L
[17:37:39.660]                         envir <- sys.frame(frame)
[17:37:39.660]                       }
[17:37:39.660]                     }
[17:37:39.660]                     sendCondition <<- function(cond) NULL
[17:37:39.660]                   }
[17:37:39.660]                 })
[17:37:39.660]                 withCallingHandlers({
[17:37:39.660]                   {
[17:37:39.660]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.660]                     if (!identical(...future.globals.maxSize.org, 
[17:37:39.660]                       ...future.globals.maxSize)) {
[17:37:39.660]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.660]                       on.exit(options(oopts), add = TRUE)
[17:37:39.660]                     }
[17:37:39.660]                     {
[17:37:39.660]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.660]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:39.660]                         USE.NAMES = FALSE)
[17:37:39.660]                       do.call(mapply, args = args)
[17:37:39.660]                     }
[17:37:39.660]                   }
[17:37:39.660]                 }, immediateCondition = function(cond) {
[17:37:39.660]                   sendCondition <- ...future.makeSendCondition()
[17:37:39.660]                   sendCondition(cond)
[17:37:39.660]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.660]                   {
[17:37:39.660]                     inherits <- base::inherits
[17:37:39.660]                     invokeRestart <- base::invokeRestart
[17:37:39.660]                     is.null <- base::is.null
[17:37:39.660]                     muffled <- FALSE
[17:37:39.660]                     if (inherits(cond, "message")) {
[17:37:39.660]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:39.660]                       if (muffled) 
[17:37:39.660]                         invokeRestart("muffleMessage")
[17:37:39.660]                     }
[17:37:39.660]                     else if (inherits(cond, "warning")) {
[17:37:39.660]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:39.660]                       if (muffled) 
[17:37:39.660]                         invokeRestart("muffleWarning")
[17:37:39.660]                     }
[17:37:39.660]                     else if (inherits(cond, "condition")) {
[17:37:39.660]                       if (!is.null(pattern)) {
[17:37:39.660]                         computeRestarts <- base::computeRestarts
[17:37:39.660]                         grepl <- base::grepl
[17:37:39.660]                         restarts <- computeRestarts(cond)
[17:37:39.660]                         for (restart in restarts) {
[17:37:39.660]                           name <- restart$name
[17:37:39.660]                           if (is.null(name)) 
[17:37:39.660]                             next
[17:37:39.660]                           if (!grepl(pattern, name)) 
[17:37:39.660]                             next
[17:37:39.660]                           invokeRestart(restart)
[17:37:39.660]                           muffled <- TRUE
[17:37:39.660]                           break
[17:37:39.660]                         }
[17:37:39.660]                       }
[17:37:39.660]                     }
[17:37:39.660]                     invisible(muffled)
[17:37:39.660]                   }
[17:37:39.660]                   muffleCondition(cond)
[17:37:39.660]                 })
[17:37:39.660]             }))
[17:37:39.660]             future::FutureResult(value = ...future.value$value, 
[17:37:39.660]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.660]                   ...future.rng), globalenv = if (FALSE) 
[17:37:39.660]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:39.660]                     ...future.globalenv.names))
[17:37:39.660]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:39.660]         }, condition = base::local({
[17:37:39.660]             c <- base::c
[17:37:39.660]             inherits <- base::inherits
[17:37:39.660]             invokeRestart <- base::invokeRestart
[17:37:39.660]             length <- base::length
[17:37:39.660]             list <- base::list
[17:37:39.660]             seq.int <- base::seq.int
[17:37:39.660]             signalCondition <- base::signalCondition
[17:37:39.660]             sys.calls <- base::sys.calls
[17:37:39.660]             `[[` <- base::`[[`
[17:37:39.660]             `+` <- base::`+`
[17:37:39.660]             `<<-` <- base::`<<-`
[17:37:39.660]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:39.660]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:39.660]                   3L)]
[17:37:39.660]             }
[17:37:39.660]             function(cond) {
[17:37:39.660]                 is_error <- inherits(cond, "error")
[17:37:39.660]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:39.660]                   NULL)
[17:37:39.660]                 if (is_error) {
[17:37:39.660]                   sessionInformation <- function() {
[17:37:39.660]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:39.660]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:39.660]                       search = base::search(), system = base::Sys.info())
[17:37:39.660]                   }
[17:37:39.660]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.660]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:39.660]                     cond$call), session = sessionInformation(), 
[17:37:39.660]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:39.660]                   signalCondition(cond)
[17:37:39.660]                 }
[17:37:39.660]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:39.660]                 "immediateCondition"))) {
[17:37:39.660]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:39.660]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.660]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:39.660]                   if (TRUE && !signal) {
[17:37:39.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.660]                     {
[17:37:39.660]                       inherits <- base::inherits
[17:37:39.660]                       invokeRestart <- base::invokeRestart
[17:37:39.660]                       is.null <- base::is.null
[17:37:39.660]                       muffled <- FALSE
[17:37:39.660]                       if (inherits(cond, "message")) {
[17:37:39.660]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.660]                         if (muffled) 
[17:37:39.660]                           invokeRestart("muffleMessage")
[17:37:39.660]                       }
[17:37:39.660]                       else if (inherits(cond, "warning")) {
[17:37:39.660]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.660]                         if (muffled) 
[17:37:39.660]                           invokeRestart("muffleWarning")
[17:37:39.660]                       }
[17:37:39.660]                       else if (inherits(cond, "condition")) {
[17:37:39.660]                         if (!is.null(pattern)) {
[17:37:39.660]                           computeRestarts <- base::computeRestarts
[17:37:39.660]                           grepl <- base::grepl
[17:37:39.660]                           restarts <- computeRestarts(cond)
[17:37:39.660]                           for (restart in restarts) {
[17:37:39.660]                             name <- restart$name
[17:37:39.660]                             if (is.null(name)) 
[17:37:39.660]                               next
[17:37:39.660]                             if (!grepl(pattern, name)) 
[17:37:39.660]                               next
[17:37:39.660]                             invokeRestart(restart)
[17:37:39.660]                             muffled <- TRUE
[17:37:39.660]                             break
[17:37:39.660]                           }
[17:37:39.660]                         }
[17:37:39.660]                       }
[17:37:39.660]                       invisible(muffled)
[17:37:39.660]                     }
[17:37:39.660]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.660]                   }
[17:37:39.660]                 }
[17:37:39.660]                 else {
[17:37:39.660]                   if (TRUE) {
[17:37:39.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.660]                     {
[17:37:39.660]                       inherits <- base::inherits
[17:37:39.660]                       invokeRestart <- base::invokeRestart
[17:37:39.660]                       is.null <- base::is.null
[17:37:39.660]                       muffled <- FALSE
[17:37:39.660]                       if (inherits(cond, "message")) {
[17:37:39.660]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.660]                         if (muffled) 
[17:37:39.660]                           invokeRestart("muffleMessage")
[17:37:39.660]                       }
[17:37:39.660]                       else if (inherits(cond, "warning")) {
[17:37:39.660]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.660]                         if (muffled) 
[17:37:39.660]                           invokeRestart("muffleWarning")
[17:37:39.660]                       }
[17:37:39.660]                       else if (inherits(cond, "condition")) {
[17:37:39.660]                         if (!is.null(pattern)) {
[17:37:39.660]                           computeRestarts <- base::computeRestarts
[17:37:39.660]                           grepl <- base::grepl
[17:37:39.660]                           restarts <- computeRestarts(cond)
[17:37:39.660]                           for (restart in restarts) {
[17:37:39.660]                             name <- restart$name
[17:37:39.660]                             if (is.null(name)) 
[17:37:39.660]                               next
[17:37:39.660]                             if (!grepl(pattern, name)) 
[17:37:39.660]                               next
[17:37:39.660]                             invokeRestart(restart)
[17:37:39.660]                             muffled <- TRUE
[17:37:39.660]                             break
[17:37:39.660]                           }
[17:37:39.660]                         }
[17:37:39.660]                       }
[17:37:39.660]                       invisible(muffled)
[17:37:39.660]                     }
[17:37:39.660]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.660]                   }
[17:37:39.660]                 }
[17:37:39.660]             }
[17:37:39.660]         }))
[17:37:39.660]     }, error = function(ex) {
[17:37:39.660]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:39.660]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.660]                 ...future.rng), started = ...future.startTime, 
[17:37:39.660]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:39.660]             version = "1.8"), class = "FutureResult")
[17:37:39.660]     }, finally = {
[17:37:39.660]         if (!identical(...future.workdir, getwd())) 
[17:37:39.660]             setwd(...future.workdir)
[17:37:39.660]         {
[17:37:39.660]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:39.660]                 ...future.oldOptions$nwarnings <- NULL
[17:37:39.660]             }
[17:37:39.660]             base::options(...future.oldOptions)
[17:37:39.660]             if (.Platform$OS.type == "windows") {
[17:37:39.660]                 old_names <- names(...future.oldEnvVars)
[17:37:39.660]                 envs <- base::Sys.getenv()
[17:37:39.660]                 names <- names(envs)
[17:37:39.660]                 common <- intersect(names, old_names)
[17:37:39.660]                 added <- setdiff(names, old_names)
[17:37:39.660]                 removed <- setdiff(old_names, names)
[17:37:39.660]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:39.660]                   envs[common]]
[17:37:39.660]                 NAMES <- toupper(changed)
[17:37:39.660]                 args <- list()
[17:37:39.660]                 for (kk in seq_along(NAMES)) {
[17:37:39.660]                   name <- changed[[kk]]
[17:37:39.660]                   NAME <- NAMES[[kk]]
[17:37:39.660]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.660]                     next
[17:37:39.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.660]                 }
[17:37:39.660]                 NAMES <- toupper(added)
[17:37:39.660]                 for (kk in seq_along(NAMES)) {
[17:37:39.660]                   name <- added[[kk]]
[17:37:39.660]                   NAME <- NAMES[[kk]]
[17:37:39.660]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.660]                     next
[17:37:39.660]                   args[[name]] <- ""
[17:37:39.660]                 }
[17:37:39.660]                 NAMES <- toupper(removed)
[17:37:39.660]                 for (kk in seq_along(NAMES)) {
[17:37:39.660]                   name <- removed[[kk]]
[17:37:39.660]                   NAME <- NAMES[[kk]]
[17:37:39.660]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.660]                     next
[17:37:39.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.660]                 }
[17:37:39.660]                 if (length(args) > 0) 
[17:37:39.660]                   base::do.call(base::Sys.setenv, args = args)
[17:37:39.660]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:39.660]             }
[17:37:39.660]             else {
[17:37:39.660]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:39.660]             }
[17:37:39.660]             {
[17:37:39.660]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:39.660]                   0L) {
[17:37:39.660]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:39.660]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:39.660]                   base::options(opts)
[17:37:39.660]                 }
[17:37:39.660]                 {
[17:37:39.660]                   {
[17:37:39.660]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:39.660]                     NULL
[17:37:39.660]                   }
[17:37:39.660]                   options(future.plan = NULL)
[17:37:39.660]                   if (is.na(NA_character_)) 
[17:37:39.660]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.660]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:39.660]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:39.660]                     .init = FALSE)
[17:37:39.660]                 }
[17:37:39.660]             }
[17:37:39.660]         }
[17:37:39.660]     })
[17:37:39.660]     if (TRUE) {
[17:37:39.660]         base::sink(type = "output", split = FALSE)
[17:37:39.660]         if (TRUE) {
[17:37:39.660]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:39.660]         }
[17:37:39.660]         else {
[17:37:39.660]             ...future.result["stdout"] <- base::list(NULL)
[17:37:39.660]         }
[17:37:39.660]         base::close(...future.stdout)
[17:37:39.660]         ...future.stdout <- NULL
[17:37:39.660]     }
[17:37:39.660]     ...future.result$conditions <- ...future.conditions
[17:37:39.660]     ...future.result$finished <- base::Sys.time()
[17:37:39.660]     ...future.result
[17:37:39.660] }
[17:37:39.662] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[17:37:39.663] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[17:37:39.663] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[17:37:39.663] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:37:39.663] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:37:39.663] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[17:37:39.664] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[17:37:39.664] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:37:39.664] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:37:39.664] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:37:39.665] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:37:39.665] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[17:37:39.665] MultisessionFuture started
[17:37:39.665] - Launch lazy future ... done
[17:37:39.665] run() for ‘MultisessionFuture’ ... done
[17:37:39.666] Created future:
[17:37:39.666] MultisessionFuture:
[17:37:39.666] Label: ‘future_.mapply-2’
[17:37:39.666] Expression:
[17:37:39.666] {
[17:37:39.666]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.666]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:39.666]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.666]         on.exit(options(oopts), add = TRUE)
[17:37:39.666]     }
[17:37:39.666]     {
[17:37:39.666]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.666]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:39.666]         do.call(mapply, args = args)
[17:37:39.666]     }
[17:37:39.666] }
[17:37:39.666] Lazy evaluation: FALSE
[17:37:39.666] Asynchronous evaluation: TRUE
[17:37:39.666] Local evaluation: TRUE
[17:37:39.666] Environment: R_GlobalEnv
[17:37:39.666] Capture standard output: TRUE
[17:37:39.666] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:39.666] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:39.666] Packages: <none>
[17:37:39.666] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:39.666] Resolved: FALSE
[17:37:39.666] Value: <not collected>
[17:37:39.666] Conditions captured: <none>
[17:37:39.666] Early signaling: FALSE
[17:37:39.666] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:39.666] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.677] Chunk #2 of 2 ... DONE
[17:37:39.677] Launching 2 futures (chunks) ... DONE
[17:37:39.677] Resolving 2 futures (chunks) ...
[17:37:39.677] resolve() on list ...
[17:37:39.677]  recursive: 0
[17:37:39.677]  length: 2
[17:37:39.678] 
[17:37:39.678] receiveMessageFromWorker() for ClusterFuture ...
[17:37:39.678] - Validating connection of MultisessionFuture
[17:37:39.678] - received message: FutureResult
[17:37:39.678] - Received FutureResult
[17:37:39.678] - Erased future from FutureRegistry
[17:37:39.679] result() for ClusterFuture ...
[17:37:39.679] - result already collected: FutureResult
[17:37:39.679] result() for ClusterFuture ... done
[17:37:39.679] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:39.679] Future #1
[17:37:39.679] result() for ClusterFuture ...
[17:37:39.679] - result already collected: FutureResult
[17:37:39.679] result() for ClusterFuture ... done
[17:37:39.679] result() for ClusterFuture ...
[17:37:39.679] - result already collected: FutureResult
[17:37:39.679] result() for ClusterFuture ... done
[17:37:39.680] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:37:39.680] - nx: 2
[17:37:39.680] - relay: TRUE
[17:37:39.680] - stdout: TRUE
[17:37:39.680] - signal: TRUE
[17:37:39.680] - resignal: FALSE
[17:37:39.680] - force: TRUE
[17:37:39.680] - relayed: [n=2] FALSE, FALSE
[17:37:39.680] - queued futures: [n=2] FALSE, FALSE
[17:37:39.680]  - until=1
[17:37:39.680]  - relaying element #1
[17:37:39.681] result() for ClusterFuture ...
[17:37:39.681] - result already collected: FutureResult
[17:37:39.681] result() for ClusterFuture ... done
[17:37:39.681] result() for ClusterFuture ...
[17:37:39.681] - result already collected: FutureResult
[17:37:39.681] result() for ClusterFuture ... done
[17:37:39.681] result() for ClusterFuture ...
[17:37:39.681] - result already collected: FutureResult
[17:37:39.681] result() for ClusterFuture ... done
[17:37:39.681] result() for ClusterFuture ...
[17:37:39.681] - result already collected: FutureResult
[17:37:39.681] result() for ClusterFuture ... done
[17:37:39.682] - relayed: [n=2] TRUE, FALSE
[17:37:39.682] - queued futures: [n=2] TRUE, FALSE
[17:37:39.682] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:37:39.682]  length: 1 (resolved future 1)
[17:37:39.710] receiveMessageFromWorker() for ClusterFuture ...
[17:37:39.710] - Validating connection of MultisessionFuture
[17:37:39.710] - received message: FutureResult
[17:37:39.711] - Received FutureResult
[17:37:39.711] - Erased future from FutureRegistry
[17:37:39.711] result() for ClusterFuture ...
[17:37:39.711] - result already collected: FutureResult
[17:37:39.711] result() for ClusterFuture ... done
[17:37:39.711] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:39.711] Future #2
[17:37:39.711] result() for ClusterFuture ...
[17:37:39.711] - result already collected: FutureResult
[17:37:39.711] result() for ClusterFuture ... done
[17:37:39.712] result() for ClusterFuture ...
[17:37:39.712] - result already collected: FutureResult
[17:37:39.712] result() for ClusterFuture ... done
[17:37:39.712] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:37:39.712] - nx: 2
[17:37:39.712] - relay: TRUE
[17:37:39.712] - stdout: TRUE
[17:37:39.712] - signal: TRUE
[17:37:39.712] - resignal: FALSE
[17:37:39.712] - force: TRUE
[17:37:39.713] - relayed: [n=2] TRUE, FALSE
[17:37:39.713] - queued futures: [n=2] TRUE, FALSE
[17:37:39.713]  - until=2
[17:37:39.713]  - relaying element #2
[17:37:39.713] result() for ClusterFuture ...
[17:37:39.713] - result already collected: FutureResult
[17:37:39.713] result() for ClusterFuture ... done
[17:37:39.713] result() for ClusterFuture ...
[17:37:39.713] - result already collected: FutureResult
[17:37:39.713] result() for ClusterFuture ... done
[17:37:39.713] result() for ClusterFuture ...
[17:37:39.714] - result already collected: FutureResult
[17:37:39.714] result() for ClusterFuture ... done
[17:37:39.714] result() for ClusterFuture ...
[17:37:39.714] - result already collected: FutureResult
[17:37:39.714] result() for ClusterFuture ... done
[17:37:39.714] - relayed: [n=2] TRUE, TRUE
[17:37:39.714] - queued futures: [n=2] TRUE, TRUE
[17:37:39.714] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:37:39.714]  length: 0 (resolved future 2)
[17:37:39.714] Relaying remaining futures
[17:37:39.714] signalConditionsASAP(NULL, pos=0) ...
[17:37:39.715] - nx: 2
[17:37:39.715] - relay: TRUE
[17:37:39.715] - stdout: TRUE
[17:37:39.715] - signal: TRUE
[17:37:39.715] - resignal: FALSE
[17:37:39.715] - force: TRUE
[17:37:39.715] - relayed: [n=2] TRUE, TRUE
[17:37:39.715] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:39.715] - relayed: [n=2] TRUE, TRUE
[17:37:39.715] - queued futures: [n=2] TRUE, TRUE
[17:37:39.715] signalConditionsASAP(NULL, pos=0) ... done
[17:37:39.716] resolve() on list ... DONE
[17:37:39.716] result() for ClusterFuture ...
[17:37:39.716] - result already collected: FutureResult
[17:37:39.716] result() for ClusterFuture ... done
[17:37:39.716] result() for ClusterFuture ...
[17:37:39.716] - result already collected: FutureResult
[17:37:39.716] result() for ClusterFuture ... done
[17:37:39.716] result() for ClusterFuture ...
[17:37:39.716] - result already collected: FutureResult
[17:37:39.716] result() for ClusterFuture ... done
[17:37:39.716] result() for ClusterFuture ...
[17:37:39.717] - result already collected: FutureResult
[17:37:39.717] result() for ClusterFuture ... done
[17:37:39.717]  - Number of value chunks collected: 2
[17:37:39.717] Resolving 2 futures (chunks) ... DONE
[17:37:39.717] Reducing values from 2 chunks ...
[17:37:39.717]  - Number of values collected after concatenation: 5
[17:37:39.717]  - Number of values expected: 5
[17:37:39.717] Reducing values from 2 chunks ... DONE
[17:37:39.717] future_mapply() ... DONE
[17:37:39.718] future_mapply() ...
[17:37:39.722] Number of chunks: 2
[17:37:39.722] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[17:37:39.722] getGlobalsAndPackagesXApply() ...
[17:37:39.722]  - future.globals: TRUE
[17:37:39.722] getGlobalsAndPackages() ...
[17:37:39.722] Searching for globals...
[17:37:39.723] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:37:39.724] Searching for globals ... DONE
[17:37:39.724] Resolving globals: FALSE
[17:37:39.724] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:37:39.724] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:37:39.724] - globals: [1] ‘FUN’
[17:37:39.725] 
[17:37:39.725] getGlobalsAndPackages() ... DONE
[17:37:39.725]  - globals found/used: [n=1] ‘FUN’
[17:37:39.725]  - needed namespaces: [n=0] 
[17:37:39.725] Finding globals ... DONE
[17:37:39.725] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:39.725] List of 2
[17:37:39.725]  $ ...future.FUN:function (C, k)  
[17:37:39.725]  $ MoreArgs     : NULL
[17:37:39.725]  - attr(*, "where")=List of 2
[17:37:39.725]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:39.725]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:39.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:39.725]  - attr(*, "resolved")= logi FALSE
[17:37:39.725]  - attr(*, "total_size")= num NA
[17:37:39.728] Packages to be attached in all futures: [n=0] 
[17:37:39.728] getGlobalsAndPackagesXApply() ... DONE
[17:37:39.728] Number of futures (= number of chunks): 2
[17:37:39.728] Launching 2 futures (chunks) ...
[17:37:39.728] Chunk #1 of 2 ...
[17:37:39.728]  - Finding globals in '...' for chunk #1 ...
[17:37:39.728] getGlobalsAndPackages() ...
[17:37:39.729] Searching for globals...
[17:37:39.729] 
[17:37:39.729] Searching for globals ... DONE
[17:37:39.729] - globals: [0] <none>
[17:37:39.729] getGlobalsAndPackages() ... DONE
[17:37:39.729]    + additional globals found: [n=0] 
[17:37:39.729]    + additional namespaces needed: [n=0] 
[17:37:39.729]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:39.729]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:39.730]  - seeds: <none>
[17:37:39.730]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.730] getGlobalsAndPackages() ...
[17:37:39.730] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.730] Resolving globals: FALSE
[17:37:39.733] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:37:39.733] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:39.733] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.734] 
[17:37:39.734] getGlobalsAndPackages() ... DONE
[17:37:39.734] run() for ‘Future’ ...
[17:37:39.734] - state: ‘created’
[17:37:39.734] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:39.748] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.748] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:39.748]   - Field: ‘node’
[17:37:39.748]   - Field: ‘label’
[17:37:39.748]   - Field: ‘local’
[17:37:39.748]   - Field: ‘owner’
[17:37:39.749]   - Field: ‘envir’
[17:37:39.749]   - Field: ‘workers’
[17:37:39.749]   - Field: ‘packages’
[17:37:39.749]   - Field: ‘gc’
[17:37:39.749]   - Field: ‘conditions’
[17:37:39.749]   - Field: ‘persistent’
[17:37:39.749]   - Field: ‘expr’
[17:37:39.749]   - Field: ‘uuid’
[17:37:39.749]   - Field: ‘seed’
[17:37:39.749]   - Field: ‘version’
[17:37:39.750]   - Field: ‘result’
[17:37:39.750]   - Field: ‘asynchronous’
[17:37:39.750]   - Field: ‘calls’
[17:37:39.750]   - Field: ‘globals’
[17:37:39.750]   - Field: ‘stdout’
[17:37:39.750]   - Field: ‘earlySignal’
[17:37:39.750]   - Field: ‘lazy’
[17:37:39.750]   - Field: ‘state’
[17:37:39.750] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:39.751] - Launch lazy future ...
[17:37:39.751] Packages needed by the future expression (n = 0): <none>
[17:37:39.751] Packages needed by future strategies (n = 0): <none>
[17:37:39.751] {
[17:37:39.751]     {
[17:37:39.751]         {
[17:37:39.751]             ...future.startTime <- base::Sys.time()
[17:37:39.751]             {
[17:37:39.751]                 {
[17:37:39.751]                   {
[17:37:39.751]                     {
[17:37:39.751]                       base::local({
[17:37:39.751]                         has_future <- base::requireNamespace("future", 
[17:37:39.751]                           quietly = TRUE)
[17:37:39.751]                         if (has_future) {
[17:37:39.751]                           ns <- base::getNamespace("future")
[17:37:39.751]                           version <- ns[[".package"]][["version"]]
[17:37:39.751]                           if (is.null(version)) 
[17:37:39.751]                             version <- utils::packageVersion("future")
[17:37:39.751]                         }
[17:37:39.751]                         else {
[17:37:39.751]                           version <- NULL
[17:37:39.751]                         }
[17:37:39.751]                         if (!has_future || version < "1.8.0") {
[17:37:39.751]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:39.751]                             "", base::R.version$version.string), 
[17:37:39.751]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:39.751]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:39.751]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:39.751]                               "release", "version")], collapse = " "), 
[17:37:39.751]                             hostname = base::Sys.info()[["nodename"]])
[17:37:39.751]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:39.751]                             info)
[17:37:39.751]                           info <- base::paste(info, collapse = "; ")
[17:37:39.751]                           if (!has_future) {
[17:37:39.751]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:39.751]                               info)
[17:37:39.751]                           }
[17:37:39.751]                           else {
[17:37:39.751]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:39.751]                               info, version)
[17:37:39.751]                           }
[17:37:39.751]                           base::stop(msg)
[17:37:39.751]                         }
[17:37:39.751]                       })
[17:37:39.751]                     }
[17:37:39.751]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:39.751]                     base::options(mc.cores = 1L)
[17:37:39.751]                   }
[17:37:39.751]                   ...future.strategy.old <- future::plan("list")
[17:37:39.751]                   options(future.plan = NULL)
[17:37:39.751]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.751]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:39.751]                 }
[17:37:39.751]                 ...future.workdir <- getwd()
[17:37:39.751]             }
[17:37:39.751]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:39.751]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:39.751]         }
[17:37:39.751]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:39.751]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:39.751]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:39.751]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:39.751]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:39.751]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:39.751]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:39.751]             base::names(...future.oldOptions))
[17:37:39.751]     }
[17:37:39.751]     if (FALSE) {
[17:37:39.751]     }
[17:37:39.751]     else {
[17:37:39.751]         if (TRUE) {
[17:37:39.751]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:39.751]                 open = "w")
[17:37:39.751]         }
[17:37:39.751]         else {
[17:37:39.751]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:39.751]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:39.751]         }
[17:37:39.751]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:39.751]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:39.751]             base::sink(type = "output", split = FALSE)
[17:37:39.751]             base::close(...future.stdout)
[17:37:39.751]         }, add = TRUE)
[17:37:39.751]     }
[17:37:39.751]     ...future.frame <- base::sys.nframe()
[17:37:39.751]     ...future.conditions <- base::list()
[17:37:39.751]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:39.751]     if (FALSE) {
[17:37:39.751]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:39.751]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:39.751]     }
[17:37:39.751]     ...future.result <- base::tryCatch({
[17:37:39.751]         base::withCallingHandlers({
[17:37:39.751]             ...future.value <- base::withVisible(base::local({
[17:37:39.751]                 ...future.makeSendCondition <- base::local({
[17:37:39.751]                   sendCondition <- NULL
[17:37:39.751]                   function(frame = 1L) {
[17:37:39.751]                     if (is.function(sendCondition)) 
[17:37:39.751]                       return(sendCondition)
[17:37:39.751]                     ns <- getNamespace("parallel")
[17:37:39.751]                     if (exists("sendData", mode = "function", 
[17:37:39.751]                       envir = ns)) {
[17:37:39.751]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:39.751]                         envir = ns)
[17:37:39.751]                       envir <- sys.frame(frame)
[17:37:39.751]                       master <- NULL
[17:37:39.751]                       while (!identical(envir, .GlobalEnv) && 
[17:37:39.751]                         !identical(envir, emptyenv())) {
[17:37:39.751]                         if (exists("master", mode = "list", envir = envir, 
[17:37:39.751]                           inherits = FALSE)) {
[17:37:39.751]                           master <- get("master", mode = "list", 
[17:37:39.751]                             envir = envir, inherits = FALSE)
[17:37:39.751]                           if (inherits(master, c("SOCKnode", 
[17:37:39.751]                             "SOCK0node"))) {
[17:37:39.751]                             sendCondition <<- function(cond) {
[17:37:39.751]                               data <- list(type = "VALUE", value = cond, 
[17:37:39.751]                                 success = TRUE)
[17:37:39.751]                               parallel_sendData(master, data)
[17:37:39.751]                             }
[17:37:39.751]                             return(sendCondition)
[17:37:39.751]                           }
[17:37:39.751]                         }
[17:37:39.751]                         frame <- frame + 1L
[17:37:39.751]                         envir <- sys.frame(frame)
[17:37:39.751]                       }
[17:37:39.751]                     }
[17:37:39.751]                     sendCondition <<- function(cond) NULL
[17:37:39.751]                   }
[17:37:39.751]                 })
[17:37:39.751]                 withCallingHandlers({
[17:37:39.751]                   {
[17:37:39.751]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.751]                     if (!identical(...future.globals.maxSize.org, 
[17:37:39.751]                       ...future.globals.maxSize)) {
[17:37:39.751]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.751]                       on.exit(options(oopts), add = TRUE)
[17:37:39.751]                     }
[17:37:39.751]                     {
[17:37:39.751]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.751]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:39.751]                         USE.NAMES = FALSE)
[17:37:39.751]                       do.call(mapply, args = args)
[17:37:39.751]                     }
[17:37:39.751]                   }
[17:37:39.751]                 }, immediateCondition = function(cond) {
[17:37:39.751]                   sendCondition <- ...future.makeSendCondition()
[17:37:39.751]                   sendCondition(cond)
[17:37:39.751]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.751]                   {
[17:37:39.751]                     inherits <- base::inherits
[17:37:39.751]                     invokeRestart <- base::invokeRestart
[17:37:39.751]                     is.null <- base::is.null
[17:37:39.751]                     muffled <- FALSE
[17:37:39.751]                     if (inherits(cond, "message")) {
[17:37:39.751]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:39.751]                       if (muffled) 
[17:37:39.751]                         invokeRestart("muffleMessage")
[17:37:39.751]                     }
[17:37:39.751]                     else if (inherits(cond, "warning")) {
[17:37:39.751]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:39.751]                       if (muffled) 
[17:37:39.751]                         invokeRestart("muffleWarning")
[17:37:39.751]                     }
[17:37:39.751]                     else if (inherits(cond, "condition")) {
[17:37:39.751]                       if (!is.null(pattern)) {
[17:37:39.751]                         computeRestarts <- base::computeRestarts
[17:37:39.751]                         grepl <- base::grepl
[17:37:39.751]                         restarts <- computeRestarts(cond)
[17:37:39.751]                         for (restart in restarts) {
[17:37:39.751]                           name <- restart$name
[17:37:39.751]                           if (is.null(name)) 
[17:37:39.751]                             next
[17:37:39.751]                           if (!grepl(pattern, name)) 
[17:37:39.751]                             next
[17:37:39.751]                           invokeRestart(restart)
[17:37:39.751]                           muffled <- TRUE
[17:37:39.751]                           break
[17:37:39.751]                         }
[17:37:39.751]                       }
[17:37:39.751]                     }
[17:37:39.751]                     invisible(muffled)
[17:37:39.751]                   }
[17:37:39.751]                   muffleCondition(cond)
[17:37:39.751]                 })
[17:37:39.751]             }))
[17:37:39.751]             future::FutureResult(value = ...future.value$value, 
[17:37:39.751]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.751]                   ...future.rng), globalenv = if (FALSE) 
[17:37:39.751]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:39.751]                     ...future.globalenv.names))
[17:37:39.751]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:39.751]         }, condition = base::local({
[17:37:39.751]             c <- base::c
[17:37:39.751]             inherits <- base::inherits
[17:37:39.751]             invokeRestart <- base::invokeRestart
[17:37:39.751]             length <- base::length
[17:37:39.751]             list <- base::list
[17:37:39.751]             seq.int <- base::seq.int
[17:37:39.751]             signalCondition <- base::signalCondition
[17:37:39.751]             sys.calls <- base::sys.calls
[17:37:39.751]             `[[` <- base::`[[`
[17:37:39.751]             `+` <- base::`+`
[17:37:39.751]             `<<-` <- base::`<<-`
[17:37:39.751]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:39.751]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:39.751]                   3L)]
[17:37:39.751]             }
[17:37:39.751]             function(cond) {
[17:37:39.751]                 is_error <- inherits(cond, "error")
[17:37:39.751]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:39.751]                   NULL)
[17:37:39.751]                 if (is_error) {
[17:37:39.751]                   sessionInformation <- function() {
[17:37:39.751]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:39.751]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:39.751]                       search = base::search(), system = base::Sys.info())
[17:37:39.751]                   }
[17:37:39.751]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.751]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:39.751]                     cond$call), session = sessionInformation(), 
[17:37:39.751]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:39.751]                   signalCondition(cond)
[17:37:39.751]                 }
[17:37:39.751]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:39.751]                 "immediateCondition"))) {
[17:37:39.751]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:39.751]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.751]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:39.751]                   if (TRUE && !signal) {
[17:37:39.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.751]                     {
[17:37:39.751]                       inherits <- base::inherits
[17:37:39.751]                       invokeRestart <- base::invokeRestart
[17:37:39.751]                       is.null <- base::is.null
[17:37:39.751]                       muffled <- FALSE
[17:37:39.751]                       if (inherits(cond, "message")) {
[17:37:39.751]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.751]                         if (muffled) 
[17:37:39.751]                           invokeRestart("muffleMessage")
[17:37:39.751]                       }
[17:37:39.751]                       else if (inherits(cond, "warning")) {
[17:37:39.751]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.751]                         if (muffled) 
[17:37:39.751]                           invokeRestart("muffleWarning")
[17:37:39.751]                       }
[17:37:39.751]                       else if (inherits(cond, "condition")) {
[17:37:39.751]                         if (!is.null(pattern)) {
[17:37:39.751]                           computeRestarts <- base::computeRestarts
[17:37:39.751]                           grepl <- base::grepl
[17:37:39.751]                           restarts <- computeRestarts(cond)
[17:37:39.751]                           for (restart in restarts) {
[17:37:39.751]                             name <- restart$name
[17:37:39.751]                             if (is.null(name)) 
[17:37:39.751]                               next
[17:37:39.751]                             if (!grepl(pattern, name)) 
[17:37:39.751]                               next
[17:37:39.751]                             invokeRestart(restart)
[17:37:39.751]                             muffled <- TRUE
[17:37:39.751]                             break
[17:37:39.751]                           }
[17:37:39.751]                         }
[17:37:39.751]                       }
[17:37:39.751]                       invisible(muffled)
[17:37:39.751]                     }
[17:37:39.751]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.751]                   }
[17:37:39.751]                 }
[17:37:39.751]                 else {
[17:37:39.751]                   if (TRUE) {
[17:37:39.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.751]                     {
[17:37:39.751]                       inherits <- base::inherits
[17:37:39.751]                       invokeRestart <- base::invokeRestart
[17:37:39.751]                       is.null <- base::is.null
[17:37:39.751]                       muffled <- FALSE
[17:37:39.751]                       if (inherits(cond, "message")) {
[17:37:39.751]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.751]                         if (muffled) 
[17:37:39.751]                           invokeRestart("muffleMessage")
[17:37:39.751]                       }
[17:37:39.751]                       else if (inherits(cond, "warning")) {
[17:37:39.751]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.751]                         if (muffled) 
[17:37:39.751]                           invokeRestart("muffleWarning")
[17:37:39.751]                       }
[17:37:39.751]                       else if (inherits(cond, "condition")) {
[17:37:39.751]                         if (!is.null(pattern)) {
[17:37:39.751]                           computeRestarts <- base::computeRestarts
[17:37:39.751]                           grepl <- base::grepl
[17:37:39.751]                           restarts <- computeRestarts(cond)
[17:37:39.751]                           for (restart in restarts) {
[17:37:39.751]                             name <- restart$name
[17:37:39.751]                             if (is.null(name)) 
[17:37:39.751]                               next
[17:37:39.751]                             if (!grepl(pattern, name)) 
[17:37:39.751]                               next
[17:37:39.751]                             invokeRestart(restart)
[17:37:39.751]                             muffled <- TRUE
[17:37:39.751]                             break
[17:37:39.751]                           }
[17:37:39.751]                         }
[17:37:39.751]                       }
[17:37:39.751]                       invisible(muffled)
[17:37:39.751]                     }
[17:37:39.751]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.751]                   }
[17:37:39.751]                 }
[17:37:39.751]             }
[17:37:39.751]         }))
[17:37:39.751]     }, error = function(ex) {
[17:37:39.751]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:39.751]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.751]                 ...future.rng), started = ...future.startTime, 
[17:37:39.751]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:39.751]             version = "1.8"), class = "FutureResult")
[17:37:39.751]     }, finally = {
[17:37:39.751]         if (!identical(...future.workdir, getwd())) 
[17:37:39.751]             setwd(...future.workdir)
[17:37:39.751]         {
[17:37:39.751]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:39.751]                 ...future.oldOptions$nwarnings <- NULL
[17:37:39.751]             }
[17:37:39.751]             base::options(...future.oldOptions)
[17:37:39.751]             if (.Platform$OS.type == "windows") {
[17:37:39.751]                 old_names <- names(...future.oldEnvVars)
[17:37:39.751]                 envs <- base::Sys.getenv()
[17:37:39.751]                 names <- names(envs)
[17:37:39.751]                 common <- intersect(names, old_names)
[17:37:39.751]                 added <- setdiff(names, old_names)
[17:37:39.751]                 removed <- setdiff(old_names, names)
[17:37:39.751]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:39.751]                   envs[common]]
[17:37:39.751]                 NAMES <- toupper(changed)
[17:37:39.751]                 args <- list()
[17:37:39.751]                 for (kk in seq_along(NAMES)) {
[17:37:39.751]                   name <- changed[[kk]]
[17:37:39.751]                   NAME <- NAMES[[kk]]
[17:37:39.751]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.751]                     next
[17:37:39.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.751]                 }
[17:37:39.751]                 NAMES <- toupper(added)
[17:37:39.751]                 for (kk in seq_along(NAMES)) {
[17:37:39.751]                   name <- added[[kk]]
[17:37:39.751]                   NAME <- NAMES[[kk]]
[17:37:39.751]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.751]                     next
[17:37:39.751]                   args[[name]] <- ""
[17:37:39.751]                 }
[17:37:39.751]                 NAMES <- toupper(removed)
[17:37:39.751]                 for (kk in seq_along(NAMES)) {
[17:37:39.751]                   name <- removed[[kk]]
[17:37:39.751]                   NAME <- NAMES[[kk]]
[17:37:39.751]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.751]                     next
[17:37:39.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.751]                 }
[17:37:39.751]                 if (length(args) > 0) 
[17:37:39.751]                   base::do.call(base::Sys.setenv, args = args)
[17:37:39.751]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:39.751]             }
[17:37:39.751]             else {
[17:37:39.751]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:39.751]             }
[17:37:39.751]             {
[17:37:39.751]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:39.751]                   0L) {
[17:37:39.751]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:39.751]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:39.751]                   base::options(opts)
[17:37:39.751]                 }
[17:37:39.751]                 {
[17:37:39.751]                   {
[17:37:39.751]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:39.751]                     NULL
[17:37:39.751]                   }
[17:37:39.751]                   options(future.plan = NULL)
[17:37:39.751]                   if (is.na(NA_character_)) 
[17:37:39.751]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.751]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:39.751]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:39.751]                     .init = FALSE)
[17:37:39.751]                 }
[17:37:39.751]             }
[17:37:39.751]         }
[17:37:39.751]     })
[17:37:39.751]     if (TRUE) {
[17:37:39.751]         base::sink(type = "output", split = FALSE)
[17:37:39.751]         if (TRUE) {
[17:37:39.751]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:39.751]         }
[17:37:39.751]         else {
[17:37:39.751]             ...future.result["stdout"] <- base::list(NULL)
[17:37:39.751]         }
[17:37:39.751]         base::close(...future.stdout)
[17:37:39.751]         ...future.stdout <- NULL
[17:37:39.751]     }
[17:37:39.751]     ...future.result$conditions <- ...future.conditions
[17:37:39.751]     ...future.result$finished <- base::Sys.time()
[17:37:39.751]     ...future.result
[17:37:39.751] }
[17:37:39.754] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[17:37:39.754] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:37:39.755] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:37:39.755] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:37:39.755] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.756] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[17:37:39.756] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[17:37:39.756] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:39.757] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.757] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:39.757] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.757] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[17:37:39.758] MultisessionFuture started
[17:37:39.758] - Launch lazy future ... done
[17:37:39.758] run() for ‘MultisessionFuture’ ... done
[17:37:39.758] Created future:
[17:37:39.758] MultisessionFuture:
[17:37:39.758] Label: ‘future_mapply-1’
[17:37:39.758] Expression:
[17:37:39.758] {
[17:37:39.758]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.758]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:39.758]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.758]         on.exit(options(oopts), add = TRUE)
[17:37:39.758]     }
[17:37:39.758]     {
[17:37:39.758]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.758]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:39.758]         do.call(mapply, args = args)
[17:37:39.758]     }
[17:37:39.758] }
[17:37:39.758] Lazy evaluation: FALSE
[17:37:39.758] Asynchronous evaluation: TRUE
[17:37:39.758] Local evaluation: TRUE
[17:37:39.758] Environment: R_GlobalEnv
[17:37:39.758] Capture standard output: TRUE
[17:37:39.758] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:39.758] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:39.758] Packages: <none>
[17:37:39.758] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:39.758] Resolved: FALSE
[17:37:39.758] Value: <not collected>
[17:37:39.758] Conditions captured: <none>
[17:37:39.758] Early signaling: FALSE
[17:37:39.758] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:39.758] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.770] Chunk #1 of 2 ... DONE
[17:37:39.770] Chunk #2 of 2 ...
[17:37:39.770]  - Finding globals in '...' for chunk #2 ...
[17:37:39.770] getGlobalsAndPackages() ...
[17:37:39.770] Searching for globals...
[17:37:39.771] 
[17:37:39.771] Searching for globals ... DONE
[17:37:39.771] - globals: [0] <none>
[17:37:39.771] getGlobalsAndPackages() ... DONE
[17:37:39.771]    + additional globals found: [n=0] 
[17:37:39.771]    + additional namespaces needed: [n=0] 
[17:37:39.771]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:39.771]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:39.771]  - seeds: <none>
[17:37:39.771]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.772] getGlobalsAndPackages() ...
[17:37:39.772] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.772] Resolving globals: FALSE
[17:37:39.772] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:37:39.773] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:39.773] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.773] 
[17:37:39.773] getGlobalsAndPackages() ... DONE
[17:37:39.773] run() for ‘Future’ ...
[17:37:39.774] - state: ‘created’
[17:37:39.774] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:39.787] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.787] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:39.788]   - Field: ‘node’
[17:37:39.788]   - Field: ‘label’
[17:37:39.788]   - Field: ‘local’
[17:37:39.788]   - Field: ‘owner’
[17:37:39.788]   - Field: ‘envir’
[17:37:39.788]   - Field: ‘workers’
[17:37:39.788]   - Field: ‘packages’
[17:37:39.788]   - Field: ‘gc’
[17:37:39.788]   - Field: ‘conditions’
[17:37:39.788]   - Field: ‘persistent’
[17:37:39.789]   - Field: ‘expr’
[17:37:39.789]   - Field: ‘uuid’
[17:37:39.789]   - Field: ‘seed’
[17:37:39.789]   - Field: ‘version’
[17:37:39.789]   - Field: ‘result’
[17:37:39.789]   - Field: ‘asynchronous’
[17:37:39.789]   - Field: ‘calls’
[17:37:39.789]   - Field: ‘globals’
[17:37:39.789]   - Field: ‘stdout’
[17:37:39.789]   - Field: ‘earlySignal’
[17:37:39.789]   - Field: ‘lazy’
[17:37:39.789]   - Field: ‘state’
[17:37:39.790] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:39.790] - Launch lazy future ...
[17:37:39.790] Packages needed by the future expression (n = 0): <none>
[17:37:39.790] Packages needed by future strategies (n = 0): <none>
[17:37:39.790] {
[17:37:39.790]     {
[17:37:39.790]         {
[17:37:39.790]             ...future.startTime <- base::Sys.time()
[17:37:39.790]             {
[17:37:39.790]                 {
[17:37:39.790]                   {
[17:37:39.790]                     {
[17:37:39.790]                       base::local({
[17:37:39.790]                         has_future <- base::requireNamespace("future", 
[17:37:39.790]                           quietly = TRUE)
[17:37:39.790]                         if (has_future) {
[17:37:39.790]                           ns <- base::getNamespace("future")
[17:37:39.790]                           version <- ns[[".package"]][["version"]]
[17:37:39.790]                           if (is.null(version)) 
[17:37:39.790]                             version <- utils::packageVersion("future")
[17:37:39.790]                         }
[17:37:39.790]                         else {
[17:37:39.790]                           version <- NULL
[17:37:39.790]                         }
[17:37:39.790]                         if (!has_future || version < "1.8.0") {
[17:37:39.790]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:39.790]                             "", base::R.version$version.string), 
[17:37:39.790]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:39.790]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:39.790]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:39.790]                               "release", "version")], collapse = " "), 
[17:37:39.790]                             hostname = base::Sys.info()[["nodename"]])
[17:37:39.790]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:39.790]                             info)
[17:37:39.790]                           info <- base::paste(info, collapse = "; ")
[17:37:39.790]                           if (!has_future) {
[17:37:39.790]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:39.790]                               info)
[17:37:39.790]                           }
[17:37:39.790]                           else {
[17:37:39.790]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:39.790]                               info, version)
[17:37:39.790]                           }
[17:37:39.790]                           base::stop(msg)
[17:37:39.790]                         }
[17:37:39.790]                       })
[17:37:39.790]                     }
[17:37:39.790]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:39.790]                     base::options(mc.cores = 1L)
[17:37:39.790]                   }
[17:37:39.790]                   ...future.strategy.old <- future::plan("list")
[17:37:39.790]                   options(future.plan = NULL)
[17:37:39.790]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.790]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:39.790]                 }
[17:37:39.790]                 ...future.workdir <- getwd()
[17:37:39.790]             }
[17:37:39.790]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:39.790]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:39.790]         }
[17:37:39.790]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:39.790]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:39.790]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:39.790]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:39.790]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:39.790]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:39.790]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:39.790]             base::names(...future.oldOptions))
[17:37:39.790]     }
[17:37:39.790]     if (FALSE) {
[17:37:39.790]     }
[17:37:39.790]     else {
[17:37:39.790]         if (TRUE) {
[17:37:39.790]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:39.790]                 open = "w")
[17:37:39.790]         }
[17:37:39.790]         else {
[17:37:39.790]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:39.790]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:39.790]         }
[17:37:39.790]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:39.790]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:39.790]             base::sink(type = "output", split = FALSE)
[17:37:39.790]             base::close(...future.stdout)
[17:37:39.790]         }, add = TRUE)
[17:37:39.790]     }
[17:37:39.790]     ...future.frame <- base::sys.nframe()
[17:37:39.790]     ...future.conditions <- base::list()
[17:37:39.790]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:39.790]     if (FALSE) {
[17:37:39.790]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:39.790]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:39.790]     }
[17:37:39.790]     ...future.result <- base::tryCatch({
[17:37:39.790]         base::withCallingHandlers({
[17:37:39.790]             ...future.value <- base::withVisible(base::local({
[17:37:39.790]                 ...future.makeSendCondition <- base::local({
[17:37:39.790]                   sendCondition <- NULL
[17:37:39.790]                   function(frame = 1L) {
[17:37:39.790]                     if (is.function(sendCondition)) 
[17:37:39.790]                       return(sendCondition)
[17:37:39.790]                     ns <- getNamespace("parallel")
[17:37:39.790]                     if (exists("sendData", mode = "function", 
[17:37:39.790]                       envir = ns)) {
[17:37:39.790]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:39.790]                         envir = ns)
[17:37:39.790]                       envir <- sys.frame(frame)
[17:37:39.790]                       master <- NULL
[17:37:39.790]                       while (!identical(envir, .GlobalEnv) && 
[17:37:39.790]                         !identical(envir, emptyenv())) {
[17:37:39.790]                         if (exists("master", mode = "list", envir = envir, 
[17:37:39.790]                           inherits = FALSE)) {
[17:37:39.790]                           master <- get("master", mode = "list", 
[17:37:39.790]                             envir = envir, inherits = FALSE)
[17:37:39.790]                           if (inherits(master, c("SOCKnode", 
[17:37:39.790]                             "SOCK0node"))) {
[17:37:39.790]                             sendCondition <<- function(cond) {
[17:37:39.790]                               data <- list(type = "VALUE", value = cond, 
[17:37:39.790]                                 success = TRUE)
[17:37:39.790]                               parallel_sendData(master, data)
[17:37:39.790]                             }
[17:37:39.790]                             return(sendCondition)
[17:37:39.790]                           }
[17:37:39.790]                         }
[17:37:39.790]                         frame <- frame + 1L
[17:37:39.790]                         envir <- sys.frame(frame)
[17:37:39.790]                       }
[17:37:39.790]                     }
[17:37:39.790]                     sendCondition <<- function(cond) NULL
[17:37:39.790]                   }
[17:37:39.790]                 })
[17:37:39.790]                 withCallingHandlers({
[17:37:39.790]                   {
[17:37:39.790]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.790]                     if (!identical(...future.globals.maxSize.org, 
[17:37:39.790]                       ...future.globals.maxSize)) {
[17:37:39.790]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.790]                       on.exit(options(oopts), add = TRUE)
[17:37:39.790]                     }
[17:37:39.790]                     {
[17:37:39.790]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.790]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:39.790]                         USE.NAMES = FALSE)
[17:37:39.790]                       do.call(mapply, args = args)
[17:37:39.790]                     }
[17:37:39.790]                   }
[17:37:39.790]                 }, immediateCondition = function(cond) {
[17:37:39.790]                   sendCondition <- ...future.makeSendCondition()
[17:37:39.790]                   sendCondition(cond)
[17:37:39.790]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.790]                   {
[17:37:39.790]                     inherits <- base::inherits
[17:37:39.790]                     invokeRestart <- base::invokeRestart
[17:37:39.790]                     is.null <- base::is.null
[17:37:39.790]                     muffled <- FALSE
[17:37:39.790]                     if (inherits(cond, "message")) {
[17:37:39.790]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:39.790]                       if (muffled) 
[17:37:39.790]                         invokeRestart("muffleMessage")
[17:37:39.790]                     }
[17:37:39.790]                     else if (inherits(cond, "warning")) {
[17:37:39.790]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:39.790]                       if (muffled) 
[17:37:39.790]                         invokeRestart("muffleWarning")
[17:37:39.790]                     }
[17:37:39.790]                     else if (inherits(cond, "condition")) {
[17:37:39.790]                       if (!is.null(pattern)) {
[17:37:39.790]                         computeRestarts <- base::computeRestarts
[17:37:39.790]                         grepl <- base::grepl
[17:37:39.790]                         restarts <- computeRestarts(cond)
[17:37:39.790]                         for (restart in restarts) {
[17:37:39.790]                           name <- restart$name
[17:37:39.790]                           if (is.null(name)) 
[17:37:39.790]                             next
[17:37:39.790]                           if (!grepl(pattern, name)) 
[17:37:39.790]                             next
[17:37:39.790]                           invokeRestart(restart)
[17:37:39.790]                           muffled <- TRUE
[17:37:39.790]                           break
[17:37:39.790]                         }
[17:37:39.790]                       }
[17:37:39.790]                     }
[17:37:39.790]                     invisible(muffled)
[17:37:39.790]                   }
[17:37:39.790]                   muffleCondition(cond)
[17:37:39.790]                 })
[17:37:39.790]             }))
[17:37:39.790]             future::FutureResult(value = ...future.value$value, 
[17:37:39.790]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.790]                   ...future.rng), globalenv = if (FALSE) 
[17:37:39.790]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:39.790]                     ...future.globalenv.names))
[17:37:39.790]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:39.790]         }, condition = base::local({
[17:37:39.790]             c <- base::c
[17:37:39.790]             inherits <- base::inherits
[17:37:39.790]             invokeRestart <- base::invokeRestart
[17:37:39.790]             length <- base::length
[17:37:39.790]             list <- base::list
[17:37:39.790]             seq.int <- base::seq.int
[17:37:39.790]             signalCondition <- base::signalCondition
[17:37:39.790]             sys.calls <- base::sys.calls
[17:37:39.790]             `[[` <- base::`[[`
[17:37:39.790]             `+` <- base::`+`
[17:37:39.790]             `<<-` <- base::`<<-`
[17:37:39.790]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:39.790]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:39.790]                   3L)]
[17:37:39.790]             }
[17:37:39.790]             function(cond) {
[17:37:39.790]                 is_error <- inherits(cond, "error")
[17:37:39.790]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:39.790]                   NULL)
[17:37:39.790]                 if (is_error) {
[17:37:39.790]                   sessionInformation <- function() {
[17:37:39.790]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:39.790]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:39.790]                       search = base::search(), system = base::Sys.info())
[17:37:39.790]                   }
[17:37:39.790]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.790]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:39.790]                     cond$call), session = sessionInformation(), 
[17:37:39.790]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:39.790]                   signalCondition(cond)
[17:37:39.790]                 }
[17:37:39.790]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:39.790]                 "immediateCondition"))) {
[17:37:39.790]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:39.790]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.790]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:39.790]                   if (TRUE && !signal) {
[17:37:39.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.790]                     {
[17:37:39.790]                       inherits <- base::inherits
[17:37:39.790]                       invokeRestart <- base::invokeRestart
[17:37:39.790]                       is.null <- base::is.null
[17:37:39.790]                       muffled <- FALSE
[17:37:39.790]                       if (inherits(cond, "message")) {
[17:37:39.790]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.790]                         if (muffled) 
[17:37:39.790]                           invokeRestart("muffleMessage")
[17:37:39.790]                       }
[17:37:39.790]                       else if (inherits(cond, "warning")) {
[17:37:39.790]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.790]                         if (muffled) 
[17:37:39.790]                           invokeRestart("muffleWarning")
[17:37:39.790]                       }
[17:37:39.790]                       else if (inherits(cond, "condition")) {
[17:37:39.790]                         if (!is.null(pattern)) {
[17:37:39.790]                           computeRestarts <- base::computeRestarts
[17:37:39.790]                           grepl <- base::grepl
[17:37:39.790]                           restarts <- computeRestarts(cond)
[17:37:39.790]                           for (restart in restarts) {
[17:37:39.790]                             name <- restart$name
[17:37:39.790]                             if (is.null(name)) 
[17:37:39.790]                               next
[17:37:39.790]                             if (!grepl(pattern, name)) 
[17:37:39.790]                               next
[17:37:39.790]                             invokeRestart(restart)
[17:37:39.790]                             muffled <- TRUE
[17:37:39.790]                             break
[17:37:39.790]                           }
[17:37:39.790]                         }
[17:37:39.790]                       }
[17:37:39.790]                       invisible(muffled)
[17:37:39.790]                     }
[17:37:39.790]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.790]                   }
[17:37:39.790]                 }
[17:37:39.790]                 else {
[17:37:39.790]                   if (TRUE) {
[17:37:39.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.790]                     {
[17:37:39.790]                       inherits <- base::inherits
[17:37:39.790]                       invokeRestart <- base::invokeRestart
[17:37:39.790]                       is.null <- base::is.null
[17:37:39.790]                       muffled <- FALSE
[17:37:39.790]                       if (inherits(cond, "message")) {
[17:37:39.790]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.790]                         if (muffled) 
[17:37:39.790]                           invokeRestart("muffleMessage")
[17:37:39.790]                       }
[17:37:39.790]                       else if (inherits(cond, "warning")) {
[17:37:39.790]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.790]                         if (muffled) 
[17:37:39.790]                           invokeRestart("muffleWarning")
[17:37:39.790]                       }
[17:37:39.790]                       else if (inherits(cond, "condition")) {
[17:37:39.790]                         if (!is.null(pattern)) {
[17:37:39.790]                           computeRestarts <- base::computeRestarts
[17:37:39.790]                           grepl <- base::grepl
[17:37:39.790]                           restarts <- computeRestarts(cond)
[17:37:39.790]                           for (restart in restarts) {
[17:37:39.790]                             name <- restart$name
[17:37:39.790]                             if (is.null(name)) 
[17:37:39.790]                               next
[17:37:39.790]                             if (!grepl(pattern, name)) 
[17:37:39.790]                               next
[17:37:39.790]                             invokeRestart(restart)
[17:37:39.790]                             muffled <- TRUE
[17:37:39.790]                             break
[17:37:39.790]                           }
[17:37:39.790]                         }
[17:37:39.790]                       }
[17:37:39.790]                       invisible(muffled)
[17:37:39.790]                     }
[17:37:39.790]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.790]                   }
[17:37:39.790]                 }
[17:37:39.790]             }
[17:37:39.790]         }))
[17:37:39.790]     }, error = function(ex) {
[17:37:39.790]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:39.790]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.790]                 ...future.rng), started = ...future.startTime, 
[17:37:39.790]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:39.790]             version = "1.8"), class = "FutureResult")
[17:37:39.790]     }, finally = {
[17:37:39.790]         if (!identical(...future.workdir, getwd())) 
[17:37:39.790]             setwd(...future.workdir)
[17:37:39.790]         {
[17:37:39.790]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:39.790]                 ...future.oldOptions$nwarnings <- NULL
[17:37:39.790]             }
[17:37:39.790]             base::options(...future.oldOptions)
[17:37:39.790]             if (.Platform$OS.type == "windows") {
[17:37:39.790]                 old_names <- names(...future.oldEnvVars)
[17:37:39.790]                 envs <- base::Sys.getenv()
[17:37:39.790]                 names <- names(envs)
[17:37:39.790]                 common <- intersect(names, old_names)
[17:37:39.790]                 added <- setdiff(names, old_names)
[17:37:39.790]                 removed <- setdiff(old_names, names)
[17:37:39.790]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:39.790]                   envs[common]]
[17:37:39.790]                 NAMES <- toupper(changed)
[17:37:39.790]                 args <- list()
[17:37:39.790]                 for (kk in seq_along(NAMES)) {
[17:37:39.790]                   name <- changed[[kk]]
[17:37:39.790]                   NAME <- NAMES[[kk]]
[17:37:39.790]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.790]                     next
[17:37:39.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.790]                 }
[17:37:39.790]                 NAMES <- toupper(added)
[17:37:39.790]                 for (kk in seq_along(NAMES)) {
[17:37:39.790]                   name <- added[[kk]]
[17:37:39.790]                   NAME <- NAMES[[kk]]
[17:37:39.790]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.790]                     next
[17:37:39.790]                   args[[name]] <- ""
[17:37:39.790]                 }
[17:37:39.790]                 NAMES <- toupper(removed)
[17:37:39.790]                 for (kk in seq_along(NAMES)) {
[17:37:39.790]                   name <- removed[[kk]]
[17:37:39.790]                   NAME <- NAMES[[kk]]
[17:37:39.790]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.790]                     next
[17:37:39.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.790]                 }
[17:37:39.790]                 if (length(args) > 0) 
[17:37:39.790]                   base::do.call(base::Sys.setenv, args = args)
[17:37:39.790]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:39.790]             }
[17:37:39.790]             else {
[17:37:39.790]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:39.790]             }
[17:37:39.790]             {
[17:37:39.790]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:39.790]                   0L) {
[17:37:39.790]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:39.790]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:39.790]                   base::options(opts)
[17:37:39.790]                 }
[17:37:39.790]                 {
[17:37:39.790]                   {
[17:37:39.790]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:39.790]                     NULL
[17:37:39.790]                   }
[17:37:39.790]                   options(future.plan = NULL)
[17:37:39.790]                   if (is.na(NA_character_)) 
[17:37:39.790]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.790]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:39.790]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:39.790]                     .init = FALSE)
[17:37:39.790]                 }
[17:37:39.790]             }
[17:37:39.790]         }
[17:37:39.790]     })
[17:37:39.790]     if (TRUE) {
[17:37:39.790]         base::sink(type = "output", split = FALSE)
[17:37:39.790]         if (TRUE) {
[17:37:39.790]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:39.790]         }
[17:37:39.790]         else {
[17:37:39.790]             ...future.result["stdout"] <- base::list(NULL)
[17:37:39.790]         }
[17:37:39.790]         base::close(...future.stdout)
[17:37:39.790]         ...future.stdout <- NULL
[17:37:39.790]     }
[17:37:39.790]     ...future.result$conditions <- ...future.conditions
[17:37:39.790]     ...future.result$finished <- base::Sys.time()
[17:37:39.790]     ...future.result
[17:37:39.790] }
[17:37:39.793] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[17:37:39.793] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[17:37:39.794] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[17:37:39.794] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:37:39.794] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:37:39.794] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[17:37:39.795] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[17:37:39.795] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:37:39.795] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:37:39.795] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:37:39.795] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:37:39.796] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[17:37:39.796] MultisessionFuture started
[17:37:39.796] - Launch lazy future ... done
[17:37:39.796] run() for ‘MultisessionFuture’ ... done
[17:37:39.796] Created future:
[17:37:39.796] MultisessionFuture:
[17:37:39.796] Label: ‘future_mapply-2’
[17:37:39.796] Expression:
[17:37:39.796] {
[17:37:39.796]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.796]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:39.796]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.796]         on.exit(options(oopts), add = TRUE)
[17:37:39.796]     }
[17:37:39.796]     {
[17:37:39.796]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.796]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:39.796]         do.call(mapply, args = args)
[17:37:39.796]     }
[17:37:39.796] }
[17:37:39.796] Lazy evaluation: FALSE
[17:37:39.796] Asynchronous evaluation: TRUE
[17:37:39.796] Local evaluation: TRUE
[17:37:39.796] Environment: R_GlobalEnv
[17:37:39.796] Capture standard output: TRUE
[17:37:39.796] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:39.796] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:39.796] Packages: <none>
[17:37:39.796] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:39.796] Resolved: FALSE
[17:37:39.796] Value: <not collected>
[17:37:39.796] Conditions captured: <none>
[17:37:39.796] Early signaling: FALSE
[17:37:39.796] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:39.796] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.808] Chunk #2 of 2 ... DONE
[17:37:39.808] Launching 2 futures (chunks) ... DONE
[17:37:39.808] Resolving 2 futures (chunks) ...
[17:37:39.808] resolve() on list ...
[17:37:39.808]  recursive: 0
[17:37:39.808]  length: 2
[17:37:39.808] 
[17:37:39.809] receiveMessageFromWorker() for ClusterFuture ...
[17:37:39.809] - Validating connection of MultisessionFuture
[17:37:39.809] - received message: FutureResult
[17:37:39.809] - Received FutureResult
[17:37:39.809] - Erased future from FutureRegistry
[17:37:39.810] result() for ClusterFuture ...
[17:37:39.810] - result already collected: FutureResult
[17:37:39.810] result() for ClusterFuture ... done
[17:37:39.810] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:39.810] Future #1
[17:37:39.810] result() for ClusterFuture ...
[17:37:39.810] - result already collected: FutureResult
[17:37:39.810] result() for ClusterFuture ... done
[17:37:39.810] result() for ClusterFuture ...
[17:37:39.810] - result already collected: FutureResult
[17:37:39.810] result() for ClusterFuture ... done
[17:37:39.810] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:37:39.811] - nx: 2
[17:37:39.811] - relay: TRUE
[17:37:39.811] - stdout: TRUE
[17:37:39.811] - signal: TRUE
[17:37:39.811] - resignal: FALSE
[17:37:39.811] - force: TRUE
[17:37:39.811] - relayed: [n=2] FALSE, FALSE
[17:37:39.811] - queued futures: [n=2] FALSE, FALSE
[17:37:39.811]  - until=1
[17:37:39.811]  - relaying element #1
[17:37:39.811] result() for ClusterFuture ...
[17:37:39.811] - result already collected: FutureResult
[17:37:39.812] result() for ClusterFuture ... done
[17:37:39.812] result() for ClusterFuture ...
[17:37:39.812] - result already collected: FutureResult
[17:37:39.812] result() for ClusterFuture ... done
[17:37:39.812] result() for ClusterFuture ...
[17:37:39.812] - result already collected: FutureResult
[17:37:39.812] result() for ClusterFuture ... done
[17:37:39.812] result() for ClusterFuture ...
[17:37:39.812] - result already collected: FutureResult
[17:37:39.812] result() for ClusterFuture ... done
[17:37:39.812] - relayed: [n=2] TRUE, FALSE
[17:37:39.812] - queued futures: [n=2] TRUE, FALSE
[17:37:39.813] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:37:39.813]  length: 1 (resolved future 1)
[17:37:39.842] receiveMessageFromWorker() for ClusterFuture ...
[17:37:39.842] - Validating connection of MultisessionFuture
[17:37:39.842] - received message: FutureResult
[17:37:39.842] - Received FutureResult
[17:37:39.842] - Erased future from FutureRegistry
[17:37:39.842] result() for ClusterFuture ...
[17:37:39.842] - result already collected: FutureResult
[17:37:39.843] result() for ClusterFuture ... done
[17:37:39.843] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:39.843] Future #2
[17:37:39.843] result() for ClusterFuture ...
[17:37:39.843] - result already collected: FutureResult
[17:37:39.843] result() for ClusterFuture ... done
[17:37:39.843] result() for ClusterFuture ...
[17:37:39.843] - result already collected: FutureResult
[17:37:39.843] result() for ClusterFuture ... done
[17:37:39.843] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:37:39.843] - nx: 2
[17:37:39.843] - relay: TRUE
[17:37:39.844] - stdout: TRUE
[17:37:39.844] - signal: TRUE
[17:37:39.844] - resignal: FALSE
[17:37:39.844] - force: TRUE
[17:37:39.844] - relayed: [n=2] TRUE, FALSE
[17:37:39.844] - queued futures: [n=2] TRUE, FALSE
[17:37:39.844]  - until=2
[17:37:39.844]  - relaying element #2
[17:37:39.844] result() for ClusterFuture ...
[17:37:39.844] - result already collected: FutureResult
[17:37:39.844] result() for ClusterFuture ... done
[17:37:39.845] result() for ClusterFuture ...
[17:37:39.845] - result already collected: FutureResult
[17:37:39.845] result() for ClusterFuture ... done
[17:37:39.845] result() for ClusterFuture ...
[17:37:39.845] - result already collected: FutureResult
[17:37:39.845] result() for ClusterFuture ... done
[17:37:39.845] result() for ClusterFuture ...
[17:37:39.845] - result already collected: FutureResult
[17:37:39.845] result() for ClusterFuture ... done
[17:37:39.845] - relayed: [n=2] TRUE, TRUE
[17:37:39.845] - queued futures: [n=2] TRUE, TRUE
[17:37:39.846] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:37:39.846]  length: 0 (resolved future 2)
[17:37:39.846] Relaying remaining futures
[17:37:39.846] signalConditionsASAP(NULL, pos=0) ...
[17:37:39.846] - nx: 2
[17:37:39.846] - relay: TRUE
[17:37:39.846] - stdout: TRUE
[17:37:39.846] - signal: TRUE
[17:37:39.846] - resignal: FALSE
[17:37:39.846] - force: TRUE
[17:37:39.846] - relayed: [n=2] TRUE, TRUE
[17:37:39.846] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:39.847] - relayed: [n=2] TRUE, TRUE
[17:37:39.847] - queued futures: [n=2] TRUE, TRUE
[17:37:39.847] signalConditionsASAP(NULL, pos=0) ... done
[17:37:39.847] resolve() on list ... DONE
[17:37:39.847] result() for ClusterFuture ...
[17:37:39.847] - result already collected: FutureResult
[17:37:39.847] result() for ClusterFuture ... done
[17:37:39.847] result() for ClusterFuture ...
[17:37:39.847] - result already collected: FutureResult
[17:37:39.847] result() for ClusterFuture ... done
[17:37:39.847] result() for ClusterFuture ...
[17:37:39.848] - result already collected: FutureResult
[17:37:39.848] result() for ClusterFuture ... done
[17:37:39.848] result() for ClusterFuture ...
[17:37:39.848] - result already collected: FutureResult
[17:37:39.848] result() for ClusterFuture ... done
[17:37:39.848]  - Number of value chunks collected: 2
[17:37:39.848] Resolving 2 futures (chunks) ... DONE
[17:37:39.848] Reducing values from 2 chunks ...
[17:37:39.848]  - Number of values collected after concatenation: 5
[17:37:39.848]  - Number of values expected: 5
[17:37:39.848] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[17:37:39.848] Reducing values from 2 chunks ... DONE
[17:37:39.849] future_mapply() ... DONE
[17:37:39.849] future_mapply() ...
[17:37:39.853] Number of chunks: 2
[17:37:39.853] getGlobalsAndPackagesXApply() ...
[17:37:39.853]  - future.globals: TRUE
[17:37:39.853] getGlobalsAndPackages() ...
[17:37:39.853] Searching for globals...
[17:37:39.854] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:37:39.854] Searching for globals ... DONE
[17:37:39.854] Resolving globals: FALSE
[17:37:39.855] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:37:39.855] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:37:39.855] - globals: [1] ‘FUN’
[17:37:39.855] 
[17:37:39.855] getGlobalsAndPackages() ... DONE
[17:37:39.856]  - globals found/used: [n=1] ‘FUN’
[17:37:39.856]  - needed namespaces: [n=0] 
[17:37:39.856] Finding globals ... DONE
[17:37:39.856] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:39.856] List of 2
[17:37:39.856]  $ ...future.FUN:function (C, k)  
[17:37:39.856]  $ MoreArgs     : list()
[17:37:39.856]  - attr(*, "where")=List of 2
[17:37:39.856]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:39.856]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:39.856]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:39.856]  - attr(*, "resolved")= logi FALSE
[17:37:39.856]  - attr(*, "total_size")= num NA
[17:37:39.858] Packages to be attached in all futures: [n=0] 
[17:37:39.858] getGlobalsAndPackagesXApply() ... DONE
[17:37:39.859] Number of futures (= number of chunks): 2
[17:37:39.859] Launching 2 futures (chunks) ...
[17:37:39.859] Chunk #1 of 2 ...
[17:37:39.859]  - Finding globals in '...' for chunk #1 ...
[17:37:39.859] getGlobalsAndPackages() ...
[17:37:39.859] Searching for globals...
[17:37:39.859] 
[17:37:39.860] Searching for globals ... DONE
[17:37:39.860] - globals: [0] <none>
[17:37:39.860] getGlobalsAndPackages() ... DONE
[17:37:39.860]    + additional globals found: [n=0] 
[17:37:39.860]    + additional namespaces needed: [n=0] 
[17:37:39.860]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:39.860]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:39.860]  - seeds: <none>
[17:37:39.860]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.860] getGlobalsAndPackages() ...
[17:37:39.861] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.861] Resolving globals: FALSE
[17:37:39.861] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:37:39.861] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:39.862] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.862] 
[17:37:39.862] getGlobalsAndPackages() ... DONE
[17:37:39.862] run() for ‘Future’ ...
[17:37:39.862] - state: ‘created’
[17:37:39.862] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:39.876] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.876] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:39.876]   - Field: ‘node’
[17:37:39.876]   - Field: ‘label’
[17:37:39.876]   - Field: ‘local’
[17:37:39.876]   - Field: ‘owner’
[17:37:39.876]   - Field: ‘envir’
[17:37:39.877]   - Field: ‘workers’
[17:37:39.877]   - Field: ‘packages’
[17:37:39.877]   - Field: ‘gc’
[17:37:39.877]   - Field: ‘conditions’
[17:37:39.877]   - Field: ‘persistent’
[17:37:39.877]   - Field: ‘expr’
[17:37:39.877]   - Field: ‘uuid’
[17:37:39.877]   - Field: ‘seed’
[17:37:39.877]   - Field: ‘version’
[17:37:39.877]   - Field: ‘result’
[17:37:39.877]   - Field: ‘asynchronous’
[17:37:39.877]   - Field: ‘calls’
[17:37:39.878]   - Field: ‘globals’
[17:37:39.878]   - Field: ‘stdout’
[17:37:39.878]   - Field: ‘earlySignal’
[17:37:39.878]   - Field: ‘lazy’
[17:37:39.878]   - Field: ‘state’
[17:37:39.878] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:39.878] - Launch lazy future ...
[17:37:39.878] Packages needed by the future expression (n = 0): <none>
[17:37:39.879] Packages needed by future strategies (n = 0): <none>
[17:37:39.879] {
[17:37:39.879]     {
[17:37:39.879]         {
[17:37:39.879]             ...future.startTime <- base::Sys.time()
[17:37:39.879]             {
[17:37:39.879]                 {
[17:37:39.879]                   {
[17:37:39.879]                     {
[17:37:39.879]                       base::local({
[17:37:39.879]                         has_future <- base::requireNamespace("future", 
[17:37:39.879]                           quietly = TRUE)
[17:37:39.879]                         if (has_future) {
[17:37:39.879]                           ns <- base::getNamespace("future")
[17:37:39.879]                           version <- ns[[".package"]][["version"]]
[17:37:39.879]                           if (is.null(version)) 
[17:37:39.879]                             version <- utils::packageVersion("future")
[17:37:39.879]                         }
[17:37:39.879]                         else {
[17:37:39.879]                           version <- NULL
[17:37:39.879]                         }
[17:37:39.879]                         if (!has_future || version < "1.8.0") {
[17:37:39.879]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:39.879]                             "", base::R.version$version.string), 
[17:37:39.879]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:39.879]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:39.879]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:39.879]                               "release", "version")], collapse = " "), 
[17:37:39.879]                             hostname = base::Sys.info()[["nodename"]])
[17:37:39.879]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:39.879]                             info)
[17:37:39.879]                           info <- base::paste(info, collapse = "; ")
[17:37:39.879]                           if (!has_future) {
[17:37:39.879]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:39.879]                               info)
[17:37:39.879]                           }
[17:37:39.879]                           else {
[17:37:39.879]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:39.879]                               info, version)
[17:37:39.879]                           }
[17:37:39.879]                           base::stop(msg)
[17:37:39.879]                         }
[17:37:39.879]                       })
[17:37:39.879]                     }
[17:37:39.879]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:39.879]                     base::options(mc.cores = 1L)
[17:37:39.879]                   }
[17:37:39.879]                   ...future.strategy.old <- future::plan("list")
[17:37:39.879]                   options(future.plan = NULL)
[17:37:39.879]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.879]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:39.879]                 }
[17:37:39.879]                 ...future.workdir <- getwd()
[17:37:39.879]             }
[17:37:39.879]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:39.879]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:39.879]         }
[17:37:39.879]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:39.879]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:39.879]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:39.879]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:39.879]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:39.879]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:39.879]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:39.879]             base::names(...future.oldOptions))
[17:37:39.879]     }
[17:37:39.879]     if (FALSE) {
[17:37:39.879]     }
[17:37:39.879]     else {
[17:37:39.879]         if (TRUE) {
[17:37:39.879]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:39.879]                 open = "w")
[17:37:39.879]         }
[17:37:39.879]         else {
[17:37:39.879]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:39.879]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:39.879]         }
[17:37:39.879]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:39.879]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:39.879]             base::sink(type = "output", split = FALSE)
[17:37:39.879]             base::close(...future.stdout)
[17:37:39.879]         }, add = TRUE)
[17:37:39.879]     }
[17:37:39.879]     ...future.frame <- base::sys.nframe()
[17:37:39.879]     ...future.conditions <- base::list()
[17:37:39.879]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:39.879]     if (FALSE) {
[17:37:39.879]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:39.879]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:39.879]     }
[17:37:39.879]     ...future.result <- base::tryCatch({
[17:37:39.879]         base::withCallingHandlers({
[17:37:39.879]             ...future.value <- base::withVisible(base::local({
[17:37:39.879]                 ...future.makeSendCondition <- base::local({
[17:37:39.879]                   sendCondition <- NULL
[17:37:39.879]                   function(frame = 1L) {
[17:37:39.879]                     if (is.function(sendCondition)) 
[17:37:39.879]                       return(sendCondition)
[17:37:39.879]                     ns <- getNamespace("parallel")
[17:37:39.879]                     if (exists("sendData", mode = "function", 
[17:37:39.879]                       envir = ns)) {
[17:37:39.879]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:39.879]                         envir = ns)
[17:37:39.879]                       envir <- sys.frame(frame)
[17:37:39.879]                       master <- NULL
[17:37:39.879]                       while (!identical(envir, .GlobalEnv) && 
[17:37:39.879]                         !identical(envir, emptyenv())) {
[17:37:39.879]                         if (exists("master", mode = "list", envir = envir, 
[17:37:39.879]                           inherits = FALSE)) {
[17:37:39.879]                           master <- get("master", mode = "list", 
[17:37:39.879]                             envir = envir, inherits = FALSE)
[17:37:39.879]                           if (inherits(master, c("SOCKnode", 
[17:37:39.879]                             "SOCK0node"))) {
[17:37:39.879]                             sendCondition <<- function(cond) {
[17:37:39.879]                               data <- list(type = "VALUE", value = cond, 
[17:37:39.879]                                 success = TRUE)
[17:37:39.879]                               parallel_sendData(master, data)
[17:37:39.879]                             }
[17:37:39.879]                             return(sendCondition)
[17:37:39.879]                           }
[17:37:39.879]                         }
[17:37:39.879]                         frame <- frame + 1L
[17:37:39.879]                         envir <- sys.frame(frame)
[17:37:39.879]                       }
[17:37:39.879]                     }
[17:37:39.879]                     sendCondition <<- function(cond) NULL
[17:37:39.879]                   }
[17:37:39.879]                 })
[17:37:39.879]                 withCallingHandlers({
[17:37:39.879]                   {
[17:37:39.879]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.879]                     if (!identical(...future.globals.maxSize.org, 
[17:37:39.879]                       ...future.globals.maxSize)) {
[17:37:39.879]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.879]                       on.exit(options(oopts), add = TRUE)
[17:37:39.879]                     }
[17:37:39.879]                     {
[17:37:39.879]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.879]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:39.879]                         USE.NAMES = FALSE)
[17:37:39.879]                       do.call(mapply, args = args)
[17:37:39.879]                     }
[17:37:39.879]                   }
[17:37:39.879]                 }, immediateCondition = function(cond) {
[17:37:39.879]                   sendCondition <- ...future.makeSendCondition()
[17:37:39.879]                   sendCondition(cond)
[17:37:39.879]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.879]                   {
[17:37:39.879]                     inherits <- base::inherits
[17:37:39.879]                     invokeRestart <- base::invokeRestart
[17:37:39.879]                     is.null <- base::is.null
[17:37:39.879]                     muffled <- FALSE
[17:37:39.879]                     if (inherits(cond, "message")) {
[17:37:39.879]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:39.879]                       if (muffled) 
[17:37:39.879]                         invokeRestart("muffleMessage")
[17:37:39.879]                     }
[17:37:39.879]                     else if (inherits(cond, "warning")) {
[17:37:39.879]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:39.879]                       if (muffled) 
[17:37:39.879]                         invokeRestart("muffleWarning")
[17:37:39.879]                     }
[17:37:39.879]                     else if (inherits(cond, "condition")) {
[17:37:39.879]                       if (!is.null(pattern)) {
[17:37:39.879]                         computeRestarts <- base::computeRestarts
[17:37:39.879]                         grepl <- base::grepl
[17:37:39.879]                         restarts <- computeRestarts(cond)
[17:37:39.879]                         for (restart in restarts) {
[17:37:39.879]                           name <- restart$name
[17:37:39.879]                           if (is.null(name)) 
[17:37:39.879]                             next
[17:37:39.879]                           if (!grepl(pattern, name)) 
[17:37:39.879]                             next
[17:37:39.879]                           invokeRestart(restart)
[17:37:39.879]                           muffled <- TRUE
[17:37:39.879]                           break
[17:37:39.879]                         }
[17:37:39.879]                       }
[17:37:39.879]                     }
[17:37:39.879]                     invisible(muffled)
[17:37:39.879]                   }
[17:37:39.879]                   muffleCondition(cond)
[17:37:39.879]                 })
[17:37:39.879]             }))
[17:37:39.879]             future::FutureResult(value = ...future.value$value, 
[17:37:39.879]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.879]                   ...future.rng), globalenv = if (FALSE) 
[17:37:39.879]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:39.879]                     ...future.globalenv.names))
[17:37:39.879]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:39.879]         }, condition = base::local({
[17:37:39.879]             c <- base::c
[17:37:39.879]             inherits <- base::inherits
[17:37:39.879]             invokeRestart <- base::invokeRestart
[17:37:39.879]             length <- base::length
[17:37:39.879]             list <- base::list
[17:37:39.879]             seq.int <- base::seq.int
[17:37:39.879]             signalCondition <- base::signalCondition
[17:37:39.879]             sys.calls <- base::sys.calls
[17:37:39.879]             `[[` <- base::`[[`
[17:37:39.879]             `+` <- base::`+`
[17:37:39.879]             `<<-` <- base::`<<-`
[17:37:39.879]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:39.879]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:39.879]                   3L)]
[17:37:39.879]             }
[17:37:39.879]             function(cond) {
[17:37:39.879]                 is_error <- inherits(cond, "error")
[17:37:39.879]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:39.879]                   NULL)
[17:37:39.879]                 if (is_error) {
[17:37:39.879]                   sessionInformation <- function() {
[17:37:39.879]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:39.879]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:39.879]                       search = base::search(), system = base::Sys.info())
[17:37:39.879]                   }
[17:37:39.879]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.879]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:39.879]                     cond$call), session = sessionInformation(), 
[17:37:39.879]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:39.879]                   signalCondition(cond)
[17:37:39.879]                 }
[17:37:39.879]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:39.879]                 "immediateCondition"))) {
[17:37:39.879]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:39.879]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.879]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:39.879]                   if (TRUE && !signal) {
[17:37:39.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.879]                     {
[17:37:39.879]                       inherits <- base::inherits
[17:37:39.879]                       invokeRestart <- base::invokeRestart
[17:37:39.879]                       is.null <- base::is.null
[17:37:39.879]                       muffled <- FALSE
[17:37:39.879]                       if (inherits(cond, "message")) {
[17:37:39.879]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.879]                         if (muffled) 
[17:37:39.879]                           invokeRestart("muffleMessage")
[17:37:39.879]                       }
[17:37:39.879]                       else if (inherits(cond, "warning")) {
[17:37:39.879]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.879]                         if (muffled) 
[17:37:39.879]                           invokeRestart("muffleWarning")
[17:37:39.879]                       }
[17:37:39.879]                       else if (inherits(cond, "condition")) {
[17:37:39.879]                         if (!is.null(pattern)) {
[17:37:39.879]                           computeRestarts <- base::computeRestarts
[17:37:39.879]                           grepl <- base::grepl
[17:37:39.879]                           restarts <- computeRestarts(cond)
[17:37:39.879]                           for (restart in restarts) {
[17:37:39.879]                             name <- restart$name
[17:37:39.879]                             if (is.null(name)) 
[17:37:39.879]                               next
[17:37:39.879]                             if (!grepl(pattern, name)) 
[17:37:39.879]                               next
[17:37:39.879]                             invokeRestart(restart)
[17:37:39.879]                             muffled <- TRUE
[17:37:39.879]                             break
[17:37:39.879]                           }
[17:37:39.879]                         }
[17:37:39.879]                       }
[17:37:39.879]                       invisible(muffled)
[17:37:39.879]                     }
[17:37:39.879]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.879]                   }
[17:37:39.879]                 }
[17:37:39.879]                 else {
[17:37:39.879]                   if (TRUE) {
[17:37:39.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.879]                     {
[17:37:39.879]                       inherits <- base::inherits
[17:37:39.879]                       invokeRestart <- base::invokeRestart
[17:37:39.879]                       is.null <- base::is.null
[17:37:39.879]                       muffled <- FALSE
[17:37:39.879]                       if (inherits(cond, "message")) {
[17:37:39.879]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.879]                         if (muffled) 
[17:37:39.879]                           invokeRestart("muffleMessage")
[17:37:39.879]                       }
[17:37:39.879]                       else if (inherits(cond, "warning")) {
[17:37:39.879]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.879]                         if (muffled) 
[17:37:39.879]                           invokeRestart("muffleWarning")
[17:37:39.879]                       }
[17:37:39.879]                       else if (inherits(cond, "condition")) {
[17:37:39.879]                         if (!is.null(pattern)) {
[17:37:39.879]                           computeRestarts <- base::computeRestarts
[17:37:39.879]                           grepl <- base::grepl
[17:37:39.879]                           restarts <- computeRestarts(cond)
[17:37:39.879]                           for (restart in restarts) {
[17:37:39.879]                             name <- restart$name
[17:37:39.879]                             if (is.null(name)) 
[17:37:39.879]                               next
[17:37:39.879]                             if (!grepl(pattern, name)) 
[17:37:39.879]                               next
[17:37:39.879]                             invokeRestart(restart)
[17:37:39.879]                             muffled <- TRUE
[17:37:39.879]                             break
[17:37:39.879]                           }
[17:37:39.879]                         }
[17:37:39.879]                       }
[17:37:39.879]                       invisible(muffled)
[17:37:39.879]                     }
[17:37:39.879]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.879]                   }
[17:37:39.879]                 }
[17:37:39.879]             }
[17:37:39.879]         }))
[17:37:39.879]     }, error = function(ex) {
[17:37:39.879]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:39.879]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.879]                 ...future.rng), started = ...future.startTime, 
[17:37:39.879]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:39.879]             version = "1.8"), class = "FutureResult")
[17:37:39.879]     }, finally = {
[17:37:39.879]         if (!identical(...future.workdir, getwd())) 
[17:37:39.879]             setwd(...future.workdir)
[17:37:39.879]         {
[17:37:39.879]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:39.879]                 ...future.oldOptions$nwarnings <- NULL
[17:37:39.879]             }
[17:37:39.879]             base::options(...future.oldOptions)
[17:37:39.879]             if (.Platform$OS.type == "windows") {
[17:37:39.879]                 old_names <- names(...future.oldEnvVars)
[17:37:39.879]                 envs <- base::Sys.getenv()
[17:37:39.879]                 names <- names(envs)
[17:37:39.879]                 common <- intersect(names, old_names)
[17:37:39.879]                 added <- setdiff(names, old_names)
[17:37:39.879]                 removed <- setdiff(old_names, names)
[17:37:39.879]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:39.879]                   envs[common]]
[17:37:39.879]                 NAMES <- toupper(changed)
[17:37:39.879]                 args <- list()
[17:37:39.879]                 for (kk in seq_along(NAMES)) {
[17:37:39.879]                   name <- changed[[kk]]
[17:37:39.879]                   NAME <- NAMES[[kk]]
[17:37:39.879]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.879]                     next
[17:37:39.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.879]                 }
[17:37:39.879]                 NAMES <- toupper(added)
[17:37:39.879]                 for (kk in seq_along(NAMES)) {
[17:37:39.879]                   name <- added[[kk]]
[17:37:39.879]                   NAME <- NAMES[[kk]]
[17:37:39.879]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.879]                     next
[17:37:39.879]                   args[[name]] <- ""
[17:37:39.879]                 }
[17:37:39.879]                 NAMES <- toupper(removed)
[17:37:39.879]                 for (kk in seq_along(NAMES)) {
[17:37:39.879]                   name <- removed[[kk]]
[17:37:39.879]                   NAME <- NAMES[[kk]]
[17:37:39.879]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.879]                     next
[17:37:39.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.879]                 }
[17:37:39.879]                 if (length(args) > 0) 
[17:37:39.879]                   base::do.call(base::Sys.setenv, args = args)
[17:37:39.879]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:39.879]             }
[17:37:39.879]             else {
[17:37:39.879]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:39.879]             }
[17:37:39.879]             {
[17:37:39.879]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:39.879]                   0L) {
[17:37:39.879]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:39.879]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:39.879]                   base::options(opts)
[17:37:39.879]                 }
[17:37:39.879]                 {
[17:37:39.879]                   {
[17:37:39.879]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:39.879]                     NULL
[17:37:39.879]                   }
[17:37:39.879]                   options(future.plan = NULL)
[17:37:39.879]                   if (is.na(NA_character_)) 
[17:37:39.879]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.879]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:39.879]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:39.879]                     .init = FALSE)
[17:37:39.879]                 }
[17:37:39.879]             }
[17:37:39.879]         }
[17:37:39.879]     })
[17:37:39.879]     if (TRUE) {
[17:37:39.879]         base::sink(type = "output", split = FALSE)
[17:37:39.879]         if (TRUE) {
[17:37:39.879]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:39.879]         }
[17:37:39.879]         else {
[17:37:39.879]             ...future.result["stdout"] <- base::list(NULL)
[17:37:39.879]         }
[17:37:39.879]         base::close(...future.stdout)
[17:37:39.879]         ...future.stdout <- NULL
[17:37:39.879]     }
[17:37:39.879]     ...future.result$conditions <- ...future.conditions
[17:37:39.879]     ...future.result$finished <- base::Sys.time()
[17:37:39.879]     ...future.result
[17:37:39.879] }
[17:37:39.882] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[17:37:39.882] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:37:39.882] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:37:39.882] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:37:39.883] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.883] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[17:37:39.883] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[17:37:39.883] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:39.884] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.884] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:39.884] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:39.884] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[17:37:39.885] MultisessionFuture started
[17:37:39.885] - Launch lazy future ... done
[17:37:39.885] run() for ‘MultisessionFuture’ ... done
[17:37:39.885] Created future:
[17:37:39.885] MultisessionFuture:
[17:37:39.885] Label: ‘future_.mapply-1’
[17:37:39.885] Expression:
[17:37:39.885] {
[17:37:39.885]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.885]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:39.885]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.885]         on.exit(options(oopts), add = TRUE)
[17:37:39.885]     }
[17:37:39.885]     {
[17:37:39.885]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.885]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:39.885]         do.call(mapply, args = args)
[17:37:39.885]     }
[17:37:39.885] }
[17:37:39.885] Lazy evaluation: FALSE
[17:37:39.885] Asynchronous evaluation: TRUE
[17:37:39.885] Local evaluation: TRUE
[17:37:39.885] Environment: R_GlobalEnv
[17:37:39.885] Capture standard output: TRUE
[17:37:39.885] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:39.885] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:39.885] Packages: <none>
[17:37:39.885] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:39.885] Resolved: FALSE
[17:37:39.885] Value: <not collected>
[17:37:39.885] Conditions captured: <none>
[17:37:39.885] Early signaling: FALSE
[17:37:39.885] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:39.885] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.897] Chunk #1 of 2 ... DONE
[17:37:39.897] Chunk #2 of 2 ...
[17:37:39.897]  - Finding globals in '...' for chunk #2 ...
[17:37:39.897] getGlobalsAndPackages() ...
[17:37:39.897] Searching for globals...
[17:37:39.898] 
[17:37:39.898] Searching for globals ... DONE
[17:37:39.898] - globals: [0] <none>
[17:37:39.898] getGlobalsAndPackages() ... DONE
[17:37:39.898]    + additional globals found: [n=0] 
[17:37:39.898]    + additional namespaces needed: [n=0] 
[17:37:39.898]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:39.898]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:39.898]  - seeds: <none>
[17:37:39.898]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.899] getGlobalsAndPackages() ...
[17:37:39.899] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.899] Resolving globals: FALSE
[17:37:39.899] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:37:39.900] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:39.900] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.900] 
[17:37:39.900] getGlobalsAndPackages() ... DONE
[17:37:39.900] run() for ‘Future’ ...
[17:37:39.900] - state: ‘created’
[17:37:39.901] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:39.916] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.916] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:39.916]   - Field: ‘node’
[17:37:39.916]   - Field: ‘label’
[17:37:39.916]   - Field: ‘local’
[17:37:39.916]   - Field: ‘owner’
[17:37:39.916]   - Field: ‘envir’
[17:37:39.917]   - Field: ‘workers’
[17:37:39.917]   - Field: ‘packages’
[17:37:39.917]   - Field: ‘gc’
[17:37:39.917]   - Field: ‘conditions’
[17:37:39.917]   - Field: ‘persistent’
[17:37:39.917]   - Field: ‘expr’
[17:37:39.917]   - Field: ‘uuid’
[17:37:39.917]   - Field: ‘seed’
[17:37:39.917]   - Field: ‘version’
[17:37:39.917]   - Field: ‘result’
[17:37:39.917]   - Field: ‘asynchronous’
[17:37:39.917]   - Field: ‘calls’
[17:37:39.918]   - Field: ‘globals’
[17:37:39.918]   - Field: ‘stdout’
[17:37:39.918]   - Field: ‘earlySignal’
[17:37:39.918]   - Field: ‘lazy’
[17:37:39.918]   - Field: ‘state’
[17:37:39.918] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:39.918] - Launch lazy future ...
[17:37:39.918] Packages needed by the future expression (n = 0): <none>
[17:37:39.918] Packages needed by future strategies (n = 0): <none>
[17:37:39.919] {
[17:37:39.919]     {
[17:37:39.919]         {
[17:37:39.919]             ...future.startTime <- base::Sys.time()
[17:37:39.919]             {
[17:37:39.919]                 {
[17:37:39.919]                   {
[17:37:39.919]                     {
[17:37:39.919]                       base::local({
[17:37:39.919]                         has_future <- base::requireNamespace("future", 
[17:37:39.919]                           quietly = TRUE)
[17:37:39.919]                         if (has_future) {
[17:37:39.919]                           ns <- base::getNamespace("future")
[17:37:39.919]                           version <- ns[[".package"]][["version"]]
[17:37:39.919]                           if (is.null(version)) 
[17:37:39.919]                             version <- utils::packageVersion("future")
[17:37:39.919]                         }
[17:37:39.919]                         else {
[17:37:39.919]                           version <- NULL
[17:37:39.919]                         }
[17:37:39.919]                         if (!has_future || version < "1.8.0") {
[17:37:39.919]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:39.919]                             "", base::R.version$version.string), 
[17:37:39.919]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:39.919]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:39.919]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:39.919]                               "release", "version")], collapse = " "), 
[17:37:39.919]                             hostname = base::Sys.info()[["nodename"]])
[17:37:39.919]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:39.919]                             info)
[17:37:39.919]                           info <- base::paste(info, collapse = "; ")
[17:37:39.919]                           if (!has_future) {
[17:37:39.919]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:39.919]                               info)
[17:37:39.919]                           }
[17:37:39.919]                           else {
[17:37:39.919]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:39.919]                               info, version)
[17:37:39.919]                           }
[17:37:39.919]                           base::stop(msg)
[17:37:39.919]                         }
[17:37:39.919]                       })
[17:37:39.919]                     }
[17:37:39.919]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:39.919]                     base::options(mc.cores = 1L)
[17:37:39.919]                   }
[17:37:39.919]                   ...future.strategy.old <- future::plan("list")
[17:37:39.919]                   options(future.plan = NULL)
[17:37:39.919]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.919]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:39.919]                 }
[17:37:39.919]                 ...future.workdir <- getwd()
[17:37:39.919]             }
[17:37:39.919]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:39.919]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:39.919]         }
[17:37:39.919]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:39.919]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:39.919]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:39.919]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:39.919]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:39.919]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:39.919]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:39.919]             base::names(...future.oldOptions))
[17:37:39.919]     }
[17:37:39.919]     if (FALSE) {
[17:37:39.919]     }
[17:37:39.919]     else {
[17:37:39.919]         if (TRUE) {
[17:37:39.919]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:39.919]                 open = "w")
[17:37:39.919]         }
[17:37:39.919]         else {
[17:37:39.919]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:39.919]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:39.919]         }
[17:37:39.919]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:39.919]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:39.919]             base::sink(type = "output", split = FALSE)
[17:37:39.919]             base::close(...future.stdout)
[17:37:39.919]         }, add = TRUE)
[17:37:39.919]     }
[17:37:39.919]     ...future.frame <- base::sys.nframe()
[17:37:39.919]     ...future.conditions <- base::list()
[17:37:39.919]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:39.919]     if (FALSE) {
[17:37:39.919]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:39.919]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:39.919]     }
[17:37:39.919]     ...future.result <- base::tryCatch({
[17:37:39.919]         base::withCallingHandlers({
[17:37:39.919]             ...future.value <- base::withVisible(base::local({
[17:37:39.919]                 ...future.makeSendCondition <- base::local({
[17:37:39.919]                   sendCondition <- NULL
[17:37:39.919]                   function(frame = 1L) {
[17:37:39.919]                     if (is.function(sendCondition)) 
[17:37:39.919]                       return(sendCondition)
[17:37:39.919]                     ns <- getNamespace("parallel")
[17:37:39.919]                     if (exists("sendData", mode = "function", 
[17:37:39.919]                       envir = ns)) {
[17:37:39.919]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:39.919]                         envir = ns)
[17:37:39.919]                       envir <- sys.frame(frame)
[17:37:39.919]                       master <- NULL
[17:37:39.919]                       while (!identical(envir, .GlobalEnv) && 
[17:37:39.919]                         !identical(envir, emptyenv())) {
[17:37:39.919]                         if (exists("master", mode = "list", envir = envir, 
[17:37:39.919]                           inherits = FALSE)) {
[17:37:39.919]                           master <- get("master", mode = "list", 
[17:37:39.919]                             envir = envir, inherits = FALSE)
[17:37:39.919]                           if (inherits(master, c("SOCKnode", 
[17:37:39.919]                             "SOCK0node"))) {
[17:37:39.919]                             sendCondition <<- function(cond) {
[17:37:39.919]                               data <- list(type = "VALUE", value = cond, 
[17:37:39.919]                                 success = TRUE)
[17:37:39.919]                               parallel_sendData(master, data)
[17:37:39.919]                             }
[17:37:39.919]                             return(sendCondition)
[17:37:39.919]                           }
[17:37:39.919]                         }
[17:37:39.919]                         frame <- frame + 1L
[17:37:39.919]                         envir <- sys.frame(frame)
[17:37:39.919]                       }
[17:37:39.919]                     }
[17:37:39.919]                     sendCondition <<- function(cond) NULL
[17:37:39.919]                   }
[17:37:39.919]                 })
[17:37:39.919]                 withCallingHandlers({
[17:37:39.919]                   {
[17:37:39.919]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.919]                     if (!identical(...future.globals.maxSize.org, 
[17:37:39.919]                       ...future.globals.maxSize)) {
[17:37:39.919]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.919]                       on.exit(options(oopts), add = TRUE)
[17:37:39.919]                     }
[17:37:39.919]                     {
[17:37:39.919]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.919]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:39.919]                         USE.NAMES = FALSE)
[17:37:39.919]                       do.call(mapply, args = args)
[17:37:39.919]                     }
[17:37:39.919]                   }
[17:37:39.919]                 }, immediateCondition = function(cond) {
[17:37:39.919]                   sendCondition <- ...future.makeSendCondition()
[17:37:39.919]                   sendCondition(cond)
[17:37:39.919]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.919]                   {
[17:37:39.919]                     inherits <- base::inherits
[17:37:39.919]                     invokeRestart <- base::invokeRestart
[17:37:39.919]                     is.null <- base::is.null
[17:37:39.919]                     muffled <- FALSE
[17:37:39.919]                     if (inherits(cond, "message")) {
[17:37:39.919]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:39.919]                       if (muffled) 
[17:37:39.919]                         invokeRestart("muffleMessage")
[17:37:39.919]                     }
[17:37:39.919]                     else if (inherits(cond, "warning")) {
[17:37:39.919]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:39.919]                       if (muffled) 
[17:37:39.919]                         invokeRestart("muffleWarning")
[17:37:39.919]                     }
[17:37:39.919]                     else if (inherits(cond, "condition")) {
[17:37:39.919]                       if (!is.null(pattern)) {
[17:37:39.919]                         computeRestarts <- base::computeRestarts
[17:37:39.919]                         grepl <- base::grepl
[17:37:39.919]                         restarts <- computeRestarts(cond)
[17:37:39.919]                         for (restart in restarts) {
[17:37:39.919]                           name <- restart$name
[17:37:39.919]                           if (is.null(name)) 
[17:37:39.919]                             next
[17:37:39.919]                           if (!grepl(pattern, name)) 
[17:37:39.919]                             next
[17:37:39.919]                           invokeRestart(restart)
[17:37:39.919]                           muffled <- TRUE
[17:37:39.919]                           break
[17:37:39.919]                         }
[17:37:39.919]                       }
[17:37:39.919]                     }
[17:37:39.919]                     invisible(muffled)
[17:37:39.919]                   }
[17:37:39.919]                   muffleCondition(cond)
[17:37:39.919]                 })
[17:37:39.919]             }))
[17:37:39.919]             future::FutureResult(value = ...future.value$value, 
[17:37:39.919]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.919]                   ...future.rng), globalenv = if (FALSE) 
[17:37:39.919]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:39.919]                     ...future.globalenv.names))
[17:37:39.919]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:39.919]         }, condition = base::local({
[17:37:39.919]             c <- base::c
[17:37:39.919]             inherits <- base::inherits
[17:37:39.919]             invokeRestart <- base::invokeRestart
[17:37:39.919]             length <- base::length
[17:37:39.919]             list <- base::list
[17:37:39.919]             seq.int <- base::seq.int
[17:37:39.919]             signalCondition <- base::signalCondition
[17:37:39.919]             sys.calls <- base::sys.calls
[17:37:39.919]             `[[` <- base::`[[`
[17:37:39.919]             `+` <- base::`+`
[17:37:39.919]             `<<-` <- base::`<<-`
[17:37:39.919]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:39.919]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:39.919]                   3L)]
[17:37:39.919]             }
[17:37:39.919]             function(cond) {
[17:37:39.919]                 is_error <- inherits(cond, "error")
[17:37:39.919]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:39.919]                   NULL)
[17:37:39.919]                 if (is_error) {
[17:37:39.919]                   sessionInformation <- function() {
[17:37:39.919]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:39.919]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:39.919]                       search = base::search(), system = base::Sys.info())
[17:37:39.919]                   }
[17:37:39.919]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.919]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:39.919]                     cond$call), session = sessionInformation(), 
[17:37:39.919]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:39.919]                   signalCondition(cond)
[17:37:39.919]                 }
[17:37:39.919]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:39.919]                 "immediateCondition"))) {
[17:37:39.919]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:39.919]                   ...future.conditions[[length(...future.conditions) + 
[17:37:39.919]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:39.919]                   if (TRUE && !signal) {
[17:37:39.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.919]                     {
[17:37:39.919]                       inherits <- base::inherits
[17:37:39.919]                       invokeRestart <- base::invokeRestart
[17:37:39.919]                       is.null <- base::is.null
[17:37:39.919]                       muffled <- FALSE
[17:37:39.919]                       if (inherits(cond, "message")) {
[17:37:39.919]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.919]                         if (muffled) 
[17:37:39.919]                           invokeRestart("muffleMessage")
[17:37:39.919]                       }
[17:37:39.919]                       else if (inherits(cond, "warning")) {
[17:37:39.919]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.919]                         if (muffled) 
[17:37:39.919]                           invokeRestart("muffleWarning")
[17:37:39.919]                       }
[17:37:39.919]                       else if (inherits(cond, "condition")) {
[17:37:39.919]                         if (!is.null(pattern)) {
[17:37:39.919]                           computeRestarts <- base::computeRestarts
[17:37:39.919]                           grepl <- base::grepl
[17:37:39.919]                           restarts <- computeRestarts(cond)
[17:37:39.919]                           for (restart in restarts) {
[17:37:39.919]                             name <- restart$name
[17:37:39.919]                             if (is.null(name)) 
[17:37:39.919]                               next
[17:37:39.919]                             if (!grepl(pattern, name)) 
[17:37:39.919]                               next
[17:37:39.919]                             invokeRestart(restart)
[17:37:39.919]                             muffled <- TRUE
[17:37:39.919]                             break
[17:37:39.919]                           }
[17:37:39.919]                         }
[17:37:39.919]                       }
[17:37:39.919]                       invisible(muffled)
[17:37:39.919]                     }
[17:37:39.919]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.919]                   }
[17:37:39.919]                 }
[17:37:39.919]                 else {
[17:37:39.919]                   if (TRUE) {
[17:37:39.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:39.919]                     {
[17:37:39.919]                       inherits <- base::inherits
[17:37:39.919]                       invokeRestart <- base::invokeRestart
[17:37:39.919]                       is.null <- base::is.null
[17:37:39.919]                       muffled <- FALSE
[17:37:39.919]                       if (inherits(cond, "message")) {
[17:37:39.919]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:39.919]                         if (muffled) 
[17:37:39.919]                           invokeRestart("muffleMessage")
[17:37:39.919]                       }
[17:37:39.919]                       else if (inherits(cond, "warning")) {
[17:37:39.919]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:39.919]                         if (muffled) 
[17:37:39.919]                           invokeRestart("muffleWarning")
[17:37:39.919]                       }
[17:37:39.919]                       else if (inherits(cond, "condition")) {
[17:37:39.919]                         if (!is.null(pattern)) {
[17:37:39.919]                           computeRestarts <- base::computeRestarts
[17:37:39.919]                           grepl <- base::grepl
[17:37:39.919]                           restarts <- computeRestarts(cond)
[17:37:39.919]                           for (restart in restarts) {
[17:37:39.919]                             name <- restart$name
[17:37:39.919]                             if (is.null(name)) 
[17:37:39.919]                               next
[17:37:39.919]                             if (!grepl(pattern, name)) 
[17:37:39.919]                               next
[17:37:39.919]                             invokeRestart(restart)
[17:37:39.919]                             muffled <- TRUE
[17:37:39.919]                             break
[17:37:39.919]                           }
[17:37:39.919]                         }
[17:37:39.919]                       }
[17:37:39.919]                       invisible(muffled)
[17:37:39.919]                     }
[17:37:39.919]                     muffleCondition(cond, pattern = "^muffle")
[17:37:39.919]                   }
[17:37:39.919]                 }
[17:37:39.919]             }
[17:37:39.919]         }))
[17:37:39.919]     }, error = function(ex) {
[17:37:39.919]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:39.919]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:39.919]                 ...future.rng), started = ...future.startTime, 
[17:37:39.919]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:39.919]             version = "1.8"), class = "FutureResult")
[17:37:39.919]     }, finally = {
[17:37:39.919]         if (!identical(...future.workdir, getwd())) 
[17:37:39.919]             setwd(...future.workdir)
[17:37:39.919]         {
[17:37:39.919]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:39.919]                 ...future.oldOptions$nwarnings <- NULL
[17:37:39.919]             }
[17:37:39.919]             base::options(...future.oldOptions)
[17:37:39.919]             if (.Platform$OS.type == "windows") {
[17:37:39.919]                 old_names <- names(...future.oldEnvVars)
[17:37:39.919]                 envs <- base::Sys.getenv()
[17:37:39.919]                 names <- names(envs)
[17:37:39.919]                 common <- intersect(names, old_names)
[17:37:39.919]                 added <- setdiff(names, old_names)
[17:37:39.919]                 removed <- setdiff(old_names, names)
[17:37:39.919]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:39.919]                   envs[common]]
[17:37:39.919]                 NAMES <- toupper(changed)
[17:37:39.919]                 args <- list()
[17:37:39.919]                 for (kk in seq_along(NAMES)) {
[17:37:39.919]                   name <- changed[[kk]]
[17:37:39.919]                   NAME <- NAMES[[kk]]
[17:37:39.919]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.919]                     next
[17:37:39.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.919]                 }
[17:37:39.919]                 NAMES <- toupper(added)
[17:37:39.919]                 for (kk in seq_along(NAMES)) {
[17:37:39.919]                   name <- added[[kk]]
[17:37:39.919]                   NAME <- NAMES[[kk]]
[17:37:39.919]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.919]                     next
[17:37:39.919]                   args[[name]] <- ""
[17:37:39.919]                 }
[17:37:39.919]                 NAMES <- toupper(removed)
[17:37:39.919]                 for (kk in seq_along(NAMES)) {
[17:37:39.919]                   name <- removed[[kk]]
[17:37:39.919]                   NAME <- NAMES[[kk]]
[17:37:39.919]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:39.919]                     next
[17:37:39.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:39.919]                 }
[17:37:39.919]                 if (length(args) > 0) 
[17:37:39.919]                   base::do.call(base::Sys.setenv, args = args)
[17:37:39.919]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:39.919]             }
[17:37:39.919]             else {
[17:37:39.919]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:39.919]             }
[17:37:39.919]             {
[17:37:39.919]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:39.919]                   0L) {
[17:37:39.919]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:39.919]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:39.919]                   base::options(opts)
[17:37:39.919]                 }
[17:37:39.919]                 {
[17:37:39.919]                   {
[17:37:39.919]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:39.919]                     NULL
[17:37:39.919]                   }
[17:37:39.919]                   options(future.plan = NULL)
[17:37:39.919]                   if (is.na(NA_character_)) 
[17:37:39.919]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:39.919]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:39.919]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:39.919]                     .init = FALSE)
[17:37:39.919]                 }
[17:37:39.919]             }
[17:37:39.919]         }
[17:37:39.919]     })
[17:37:39.919]     if (TRUE) {
[17:37:39.919]         base::sink(type = "output", split = FALSE)
[17:37:39.919]         if (TRUE) {
[17:37:39.919]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:39.919]         }
[17:37:39.919]         else {
[17:37:39.919]             ...future.result["stdout"] <- base::list(NULL)
[17:37:39.919]         }
[17:37:39.919]         base::close(...future.stdout)
[17:37:39.919]         ...future.stdout <- NULL
[17:37:39.919]     }
[17:37:39.919]     ...future.result$conditions <- ...future.conditions
[17:37:39.919]     ...future.result$finished <- base::Sys.time()
[17:37:39.919]     ...future.result
[17:37:39.919] }
[17:37:39.922] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[17:37:39.922] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[17:37:39.922] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[17:37:39.922] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:37:39.923] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:37:39.923] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[17:37:39.923] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[17:37:39.923] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:37:39.924] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:37:39.924] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:37:39.924] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:37:39.924] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[17:37:39.925] MultisessionFuture started
[17:37:39.925] - Launch lazy future ... done
[17:37:39.925] run() for ‘MultisessionFuture’ ... done
[17:37:39.925] Created future:
[17:37:39.925] MultisessionFuture:
[17:37:39.925] Label: ‘future_.mapply-2’
[17:37:39.925] Expression:
[17:37:39.925] {
[17:37:39.925]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:39.925]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:39.925]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:39.925]         on.exit(options(oopts), add = TRUE)
[17:37:39.925]     }
[17:37:39.925]     {
[17:37:39.925]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:39.925]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:39.925]         do.call(mapply, args = args)
[17:37:39.925]     }
[17:37:39.925] }
[17:37:39.925] Lazy evaluation: FALSE
[17:37:39.925] Asynchronous evaluation: TRUE
[17:37:39.925] Local evaluation: TRUE
[17:37:39.925] Environment: R_GlobalEnv
[17:37:39.925] Capture standard output: TRUE
[17:37:39.925] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:39.925] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:39.925] Packages: <none>
[17:37:39.925] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:39.925] Resolved: FALSE
[17:37:39.925] Value: <not collected>
[17:37:39.925] Conditions captured: <none>
[17:37:39.925] Early signaling: FALSE
[17:37:39.925] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:39.925] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:39.939] Chunk #2 of 2 ... DONE
[17:37:39.939] Launching 2 futures (chunks) ... DONE
[17:37:39.939] Resolving 2 futures (chunks) ...
[17:37:39.939] resolve() on list ...
[17:37:39.939]  recursive: 0
[17:37:39.939]  length: 2
[17:37:39.940] 
[17:37:39.940] receiveMessageFromWorker() for ClusterFuture ...
[17:37:39.940] - Validating connection of MultisessionFuture
[17:37:39.940] - received message: FutureResult
[17:37:39.941] - Received FutureResult
[17:37:39.941] - Erased future from FutureRegistry
[17:37:39.941] result() for ClusterFuture ...
[17:37:39.941] - result already collected: FutureResult
[17:37:39.942] result() for ClusterFuture ... done
[17:37:39.942] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:39.942] Future #1
[17:37:39.942] result() for ClusterFuture ...
[17:37:39.942] - result already collected: FutureResult
[17:37:39.942] result() for ClusterFuture ... done
[17:37:39.942] result() for ClusterFuture ...
[17:37:39.942] - result already collected: FutureResult
[17:37:39.942] result() for ClusterFuture ... done
[17:37:39.943] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:37:39.943] - nx: 2
[17:37:39.943] - relay: TRUE
[17:37:39.943] - stdout: TRUE
[17:37:39.943] - signal: TRUE
[17:37:39.943] - resignal: FALSE
[17:37:39.943] - force: TRUE
[17:37:39.943] - relayed: [n=2] FALSE, FALSE
[17:37:39.943] - queued futures: [n=2] FALSE, FALSE
[17:37:39.943]  - until=1
[17:37:39.943]  - relaying element #1
[17:37:39.943] result() for ClusterFuture ...
[17:37:39.944] - result already collected: FutureResult
[17:37:39.944] result() for ClusterFuture ... done
[17:37:39.944] result() for ClusterFuture ...
[17:37:39.944] - result already collected: FutureResult
[17:37:39.944] result() for ClusterFuture ... done
[17:37:39.944] result() for ClusterFuture ...
[17:37:39.944] - result already collected: FutureResult
[17:37:39.944] result() for ClusterFuture ... done
[17:37:39.944] result() for ClusterFuture ...
[17:37:39.944] - result already collected: FutureResult
[17:37:39.945] result() for ClusterFuture ... done
[17:37:39.945] - relayed: [n=2] TRUE, FALSE
[17:37:39.945] - queued futures: [n=2] TRUE, FALSE
[17:37:39.945] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:37:39.945]  length: 1 (resolved future 1)
[17:37:39.970] receiveMessageFromWorker() for ClusterFuture ...
[17:37:39.970] - Validating connection of MultisessionFuture
[17:37:39.970] - received message: FutureResult
[17:37:39.970] - Received FutureResult
[17:37:39.970] - Erased future from FutureRegistry
[17:37:39.970] result() for ClusterFuture ...
[17:37:39.970] - result already collected: FutureResult
[17:37:39.971] result() for ClusterFuture ... done
[17:37:39.971] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:39.971] Future #2
[17:37:39.971] result() for ClusterFuture ...
[17:37:39.971] - result already collected: FutureResult
[17:37:39.971] result() for ClusterFuture ... done
[17:37:39.971] result() for ClusterFuture ...
[17:37:39.971] - result already collected: FutureResult
[17:37:39.971] result() for ClusterFuture ... done
[17:37:39.971] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:37:39.971] - nx: 2
[17:37:39.971] - relay: TRUE
[17:37:39.972] - stdout: TRUE
[17:37:39.972] - signal: TRUE
[17:37:39.972] - resignal: FALSE
[17:37:39.972] - force: TRUE
[17:37:39.972] - relayed: [n=2] TRUE, FALSE
[17:37:39.972] - queued futures: [n=2] TRUE, FALSE
[17:37:39.972]  - until=2
[17:37:39.972]  - relaying element #2
[17:37:39.972] result() for ClusterFuture ...
[17:37:39.972] - result already collected: FutureResult
[17:37:39.972] result() for ClusterFuture ... done
[17:37:39.973] result() for ClusterFuture ...
[17:37:39.973] - result already collected: FutureResult
[17:37:39.973] result() for ClusterFuture ... done
[17:37:39.973] result() for ClusterFuture ...
[17:37:39.973] - result already collected: FutureResult
[17:37:39.973] result() for ClusterFuture ... done
[17:37:39.973] result() for ClusterFuture ...
[17:37:39.973] - result already collected: FutureResult
[17:37:39.973] result() for ClusterFuture ... done
[17:37:39.973] - relayed: [n=2] TRUE, TRUE
[17:37:39.973] - queued futures: [n=2] TRUE, TRUE
[17:37:39.973] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:37:39.974]  length: 0 (resolved future 2)
[17:37:39.974] Relaying remaining futures
[17:37:39.974] signalConditionsASAP(NULL, pos=0) ...
[17:37:39.974] - nx: 2
[17:37:39.974] - relay: TRUE
[17:37:39.974] - stdout: TRUE
[17:37:39.974] - signal: TRUE
[17:37:39.974] - resignal: FALSE
[17:37:39.974] - force: TRUE
[17:37:39.974] - relayed: [n=2] TRUE, TRUE
[17:37:39.974] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:39.975] - relayed: [n=2] TRUE, TRUE
[17:37:39.975] - queued futures: [n=2] TRUE, TRUE
[17:37:39.975] signalConditionsASAP(NULL, pos=0) ... done
[17:37:39.975] resolve() on list ... DONE
[17:37:39.975] result() for ClusterFuture ...
[17:37:39.975] - result already collected: FutureResult
[17:37:39.975] result() for ClusterFuture ... done
[17:37:39.975] result() for ClusterFuture ...
[17:37:39.975] - result already collected: FutureResult
[17:37:39.975] result() for ClusterFuture ... done
[17:37:39.975] result() for ClusterFuture ...
[17:37:39.975] - result already collected: FutureResult
[17:37:39.976] result() for ClusterFuture ... done
[17:37:39.976] result() for ClusterFuture ...
[17:37:39.976] - result already collected: FutureResult
[17:37:39.976] result() for ClusterFuture ... done
[17:37:39.976]  - Number of value chunks collected: 2
[17:37:39.976] Resolving 2 futures (chunks) ... DONE
[17:37:39.976] Reducing values from 2 chunks ...
[17:37:39.976]  - Number of values collected after concatenation: 5
[17:37:39.976]  - Number of values expected: 5
[17:37:39.976] Reducing values from 2 chunks ... DONE
[17:37:39.976] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[17:37:39.977] future_mapply() ...
[17:37:39.980] Number of chunks: 1
[17:37:39.980] getGlobalsAndPackagesXApply() ...
[17:37:39.981]  - future.globals: TRUE
[17:37:39.981] getGlobalsAndPackages() ...
[17:37:39.981] Searching for globals...
[17:37:39.982] - globals found: [1] ‘FUN’
[17:37:39.982] Searching for globals ... DONE
[17:37:39.982] Resolving globals: FALSE
[17:37:39.982] The total size of the 1 globals is 848 bytes (848 bytes)
[17:37:39.983] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:37:39.983] - globals: [1] ‘FUN’
[17:37:39.983] 
[17:37:39.983] getGlobalsAndPackages() ... DONE
[17:37:39.983]  - globals found/used: [n=1] ‘FUN’
[17:37:39.983]  - needed namespaces: [n=0] 
[17:37:39.983] Finding globals ... DONE
[17:37:39.983] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:39.983] List of 2
[17:37:39.983]  $ ...future.FUN:function (x)  
[17:37:39.983]  $ MoreArgs     : NULL
[17:37:39.983]  - attr(*, "where")=List of 2
[17:37:39.983]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:39.983]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:39.983]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:39.983]  - attr(*, "resolved")= logi FALSE
[17:37:39.983]  - attr(*, "total_size")= num NA
[17:37:39.986] Packages to be attached in all futures: [n=0] 
[17:37:39.986] getGlobalsAndPackagesXApply() ... DONE
[17:37:39.986] Number of futures (= number of chunks): 1
[17:37:39.986] Launching 1 futures (chunks) ...
[17:37:39.986] Chunk #1 of 1 ...
[17:37:39.986]  - Finding globals in '...' for chunk #1 ...
[17:37:39.987] getGlobalsAndPackages() ...
[17:37:39.987] Searching for globals...
[17:37:39.987] 
[17:37:39.987] Searching for globals ... DONE
[17:37:39.987] - globals: [0] <none>
[17:37:39.987] getGlobalsAndPackages() ... DONE
[17:37:39.987]    + additional globals found: [n=0] 
[17:37:39.987]    + additional namespaces needed: [n=0] 
[17:37:39.987]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:39.988]  - seeds: <none>
[17:37:39.988]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.988] getGlobalsAndPackages() ...
[17:37:39.988] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.988] Resolving globals: FALSE
[17:37:39.989] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[17:37:39.989] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:39.989] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:39.989] 
[17:37:39.989] getGlobalsAndPackages() ... DONE
[17:37:39.990] run() for ‘Future’ ...
[17:37:39.990] - state: ‘created’
[17:37:39.990] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:40.003] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.004] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:40.004]   - Field: ‘node’
[17:37:40.004]   - Field: ‘label’
[17:37:40.004]   - Field: ‘local’
[17:37:40.004]   - Field: ‘owner’
[17:37:40.004]   - Field: ‘envir’
[17:37:40.004]   - Field: ‘workers’
[17:37:40.004]   - Field: ‘packages’
[17:37:40.004]   - Field: ‘gc’
[17:37:40.005]   - Field: ‘conditions’
[17:37:40.005]   - Field: ‘persistent’
[17:37:40.005]   - Field: ‘expr’
[17:37:40.005]   - Field: ‘uuid’
[17:37:40.005]   - Field: ‘seed’
[17:37:40.005]   - Field: ‘version’
[17:37:40.005]   - Field: ‘result’
[17:37:40.005]   - Field: ‘asynchronous’
[17:37:40.005]   - Field: ‘calls’
[17:37:40.005]   - Field: ‘globals’
[17:37:40.005]   - Field: ‘stdout’
[17:37:40.005]   - Field: ‘earlySignal’
[17:37:40.006]   - Field: ‘lazy’
[17:37:40.006]   - Field: ‘state’
[17:37:40.006] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:40.006] - Launch lazy future ...
[17:37:40.006] Packages needed by the future expression (n = 0): <none>
[17:37:40.006] Packages needed by future strategies (n = 0): <none>
[17:37:40.007] {
[17:37:40.007]     {
[17:37:40.007]         {
[17:37:40.007]             ...future.startTime <- base::Sys.time()
[17:37:40.007]             {
[17:37:40.007]                 {
[17:37:40.007]                   {
[17:37:40.007]                     {
[17:37:40.007]                       base::local({
[17:37:40.007]                         has_future <- base::requireNamespace("future", 
[17:37:40.007]                           quietly = TRUE)
[17:37:40.007]                         if (has_future) {
[17:37:40.007]                           ns <- base::getNamespace("future")
[17:37:40.007]                           version <- ns[[".package"]][["version"]]
[17:37:40.007]                           if (is.null(version)) 
[17:37:40.007]                             version <- utils::packageVersion("future")
[17:37:40.007]                         }
[17:37:40.007]                         else {
[17:37:40.007]                           version <- NULL
[17:37:40.007]                         }
[17:37:40.007]                         if (!has_future || version < "1.8.0") {
[17:37:40.007]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:40.007]                             "", base::R.version$version.string), 
[17:37:40.007]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:40.007]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:40.007]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:40.007]                               "release", "version")], collapse = " "), 
[17:37:40.007]                             hostname = base::Sys.info()[["nodename"]])
[17:37:40.007]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:40.007]                             info)
[17:37:40.007]                           info <- base::paste(info, collapse = "; ")
[17:37:40.007]                           if (!has_future) {
[17:37:40.007]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:40.007]                               info)
[17:37:40.007]                           }
[17:37:40.007]                           else {
[17:37:40.007]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:40.007]                               info, version)
[17:37:40.007]                           }
[17:37:40.007]                           base::stop(msg)
[17:37:40.007]                         }
[17:37:40.007]                       })
[17:37:40.007]                     }
[17:37:40.007]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:40.007]                     base::options(mc.cores = 1L)
[17:37:40.007]                   }
[17:37:40.007]                   ...future.strategy.old <- future::plan("list")
[17:37:40.007]                   options(future.plan = NULL)
[17:37:40.007]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.007]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:40.007]                 }
[17:37:40.007]                 ...future.workdir <- getwd()
[17:37:40.007]             }
[17:37:40.007]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:40.007]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:40.007]         }
[17:37:40.007]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:40.007]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:40.007]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:40.007]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:40.007]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:40.007]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:40.007]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:40.007]             base::names(...future.oldOptions))
[17:37:40.007]     }
[17:37:40.007]     if (FALSE) {
[17:37:40.007]     }
[17:37:40.007]     else {
[17:37:40.007]         if (TRUE) {
[17:37:40.007]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:40.007]                 open = "w")
[17:37:40.007]         }
[17:37:40.007]         else {
[17:37:40.007]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:40.007]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:40.007]         }
[17:37:40.007]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:40.007]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:40.007]             base::sink(type = "output", split = FALSE)
[17:37:40.007]             base::close(...future.stdout)
[17:37:40.007]         }, add = TRUE)
[17:37:40.007]     }
[17:37:40.007]     ...future.frame <- base::sys.nframe()
[17:37:40.007]     ...future.conditions <- base::list()
[17:37:40.007]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:40.007]     if (FALSE) {
[17:37:40.007]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:40.007]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:40.007]     }
[17:37:40.007]     ...future.result <- base::tryCatch({
[17:37:40.007]         base::withCallingHandlers({
[17:37:40.007]             ...future.value <- base::withVisible(base::local({
[17:37:40.007]                 ...future.makeSendCondition <- base::local({
[17:37:40.007]                   sendCondition <- NULL
[17:37:40.007]                   function(frame = 1L) {
[17:37:40.007]                     if (is.function(sendCondition)) 
[17:37:40.007]                       return(sendCondition)
[17:37:40.007]                     ns <- getNamespace("parallel")
[17:37:40.007]                     if (exists("sendData", mode = "function", 
[17:37:40.007]                       envir = ns)) {
[17:37:40.007]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:40.007]                         envir = ns)
[17:37:40.007]                       envir <- sys.frame(frame)
[17:37:40.007]                       master <- NULL
[17:37:40.007]                       while (!identical(envir, .GlobalEnv) && 
[17:37:40.007]                         !identical(envir, emptyenv())) {
[17:37:40.007]                         if (exists("master", mode = "list", envir = envir, 
[17:37:40.007]                           inherits = FALSE)) {
[17:37:40.007]                           master <- get("master", mode = "list", 
[17:37:40.007]                             envir = envir, inherits = FALSE)
[17:37:40.007]                           if (inherits(master, c("SOCKnode", 
[17:37:40.007]                             "SOCK0node"))) {
[17:37:40.007]                             sendCondition <<- function(cond) {
[17:37:40.007]                               data <- list(type = "VALUE", value = cond, 
[17:37:40.007]                                 success = TRUE)
[17:37:40.007]                               parallel_sendData(master, data)
[17:37:40.007]                             }
[17:37:40.007]                             return(sendCondition)
[17:37:40.007]                           }
[17:37:40.007]                         }
[17:37:40.007]                         frame <- frame + 1L
[17:37:40.007]                         envir <- sys.frame(frame)
[17:37:40.007]                       }
[17:37:40.007]                     }
[17:37:40.007]                     sendCondition <<- function(cond) NULL
[17:37:40.007]                   }
[17:37:40.007]                 })
[17:37:40.007]                 withCallingHandlers({
[17:37:40.007]                   {
[17:37:40.007]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.007]                     if (!identical(...future.globals.maxSize.org, 
[17:37:40.007]                       ...future.globals.maxSize)) {
[17:37:40.007]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.007]                       on.exit(options(oopts), add = TRUE)
[17:37:40.007]                     }
[17:37:40.007]                     {
[17:37:40.007]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.007]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:40.007]                         USE.NAMES = FALSE)
[17:37:40.007]                       do.call(mapply, args = args)
[17:37:40.007]                     }
[17:37:40.007]                   }
[17:37:40.007]                 }, immediateCondition = function(cond) {
[17:37:40.007]                   sendCondition <- ...future.makeSendCondition()
[17:37:40.007]                   sendCondition(cond)
[17:37:40.007]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.007]                   {
[17:37:40.007]                     inherits <- base::inherits
[17:37:40.007]                     invokeRestart <- base::invokeRestart
[17:37:40.007]                     is.null <- base::is.null
[17:37:40.007]                     muffled <- FALSE
[17:37:40.007]                     if (inherits(cond, "message")) {
[17:37:40.007]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:40.007]                       if (muffled) 
[17:37:40.007]                         invokeRestart("muffleMessage")
[17:37:40.007]                     }
[17:37:40.007]                     else if (inherits(cond, "warning")) {
[17:37:40.007]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:40.007]                       if (muffled) 
[17:37:40.007]                         invokeRestart("muffleWarning")
[17:37:40.007]                     }
[17:37:40.007]                     else if (inherits(cond, "condition")) {
[17:37:40.007]                       if (!is.null(pattern)) {
[17:37:40.007]                         computeRestarts <- base::computeRestarts
[17:37:40.007]                         grepl <- base::grepl
[17:37:40.007]                         restarts <- computeRestarts(cond)
[17:37:40.007]                         for (restart in restarts) {
[17:37:40.007]                           name <- restart$name
[17:37:40.007]                           if (is.null(name)) 
[17:37:40.007]                             next
[17:37:40.007]                           if (!grepl(pattern, name)) 
[17:37:40.007]                             next
[17:37:40.007]                           invokeRestart(restart)
[17:37:40.007]                           muffled <- TRUE
[17:37:40.007]                           break
[17:37:40.007]                         }
[17:37:40.007]                       }
[17:37:40.007]                     }
[17:37:40.007]                     invisible(muffled)
[17:37:40.007]                   }
[17:37:40.007]                   muffleCondition(cond)
[17:37:40.007]                 })
[17:37:40.007]             }))
[17:37:40.007]             future::FutureResult(value = ...future.value$value, 
[17:37:40.007]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.007]                   ...future.rng), globalenv = if (FALSE) 
[17:37:40.007]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:40.007]                     ...future.globalenv.names))
[17:37:40.007]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:40.007]         }, condition = base::local({
[17:37:40.007]             c <- base::c
[17:37:40.007]             inherits <- base::inherits
[17:37:40.007]             invokeRestart <- base::invokeRestart
[17:37:40.007]             length <- base::length
[17:37:40.007]             list <- base::list
[17:37:40.007]             seq.int <- base::seq.int
[17:37:40.007]             signalCondition <- base::signalCondition
[17:37:40.007]             sys.calls <- base::sys.calls
[17:37:40.007]             `[[` <- base::`[[`
[17:37:40.007]             `+` <- base::`+`
[17:37:40.007]             `<<-` <- base::`<<-`
[17:37:40.007]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:40.007]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:40.007]                   3L)]
[17:37:40.007]             }
[17:37:40.007]             function(cond) {
[17:37:40.007]                 is_error <- inherits(cond, "error")
[17:37:40.007]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:40.007]                   NULL)
[17:37:40.007]                 if (is_error) {
[17:37:40.007]                   sessionInformation <- function() {
[17:37:40.007]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:40.007]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:40.007]                       search = base::search(), system = base::Sys.info())
[17:37:40.007]                   }
[17:37:40.007]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.007]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:40.007]                     cond$call), session = sessionInformation(), 
[17:37:40.007]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:40.007]                   signalCondition(cond)
[17:37:40.007]                 }
[17:37:40.007]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:40.007]                 "immediateCondition"))) {
[17:37:40.007]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:40.007]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.007]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:40.007]                   if (TRUE && !signal) {
[17:37:40.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.007]                     {
[17:37:40.007]                       inherits <- base::inherits
[17:37:40.007]                       invokeRestart <- base::invokeRestart
[17:37:40.007]                       is.null <- base::is.null
[17:37:40.007]                       muffled <- FALSE
[17:37:40.007]                       if (inherits(cond, "message")) {
[17:37:40.007]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.007]                         if (muffled) 
[17:37:40.007]                           invokeRestart("muffleMessage")
[17:37:40.007]                       }
[17:37:40.007]                       else if (inherits(cond, "warning")) {
[17:37:40.007]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.007]                         if (muffled) 
[17:37:40.007]                           invokeRestart("muffleWarning")
[17:37:40.007]                       }
[17:37:40.007]                       else if (inherits(cond, "condition")) {
[17:37:40.007]                         if (!is.null(pattern)) {
[17:37:40.007]                           computeRestarts <- base::computeRestarts
[17:37:40.007]                           grepl <- base::grepl
[17:37:40.007]                           restarts <- computeRestarts(cond)
[17:37:40.007]                           for (restart in restarts) {
[17:37:40.007]                             name <- restart$name
[17:37:40.007]                             if (is.null(name)) 
[17:37:40.007]                               next
[17:37:40.007]                             if (!grepl(pattern, name)) 
[17:37:40.007]                               next
[17:37:40.007]                             invokeRestart(restart)
[17:37:40.007]                             muffled <- TRUE
[17:37:40.007]                             break
[17:37:40.007]                           }
[17:37:40.007]                         }
[17:37:40.007]                       }
[17:37:40.007]                       invisible(muffled)
[17:37:40.007]                     }
[17:37:40.007]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.007]                   }
[17:37:40.007]                 }
[17:37:40.007]                 else {
[17:37:40.007]                   if (TRUE) {
[17:37:40.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.007]                     {
[17:37:40.007]                       inherits <- base::inherits
[17:37:40.007]                       invokeRestart <- base::invokeRestart
[17:37:40.007]                       is.null <- base::is.null
[17:37:40.007]                       muffled <- FALSE
[17:37:40.007]                       if (inherits(cond, "message")) {
[17:37:40.007]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.007]                         if (muffled) 
[17:37:40.007]                           invokeRestart("muffleMessage")
[17:37:40.007]                       }
[17:37:40.007]                       else if (inherits(cond, "warning")) {
[17:37:40.007]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.007]                         if (muffled) 
[17:37:40.007]                           invokeRestart("muffleWarning")
[17:37:40.007]                       }
[17:37:40.007]                       else if (inherits(cond, "condition")) {
[17:37:40.007]                         if (!is.null(pattern)) {
[17:37:40.007]                           computeRestarts <- base::computeRestarts
[17:37:40.007]                           grepl <- base::grepl
[17:37:40.007]                           restarts <- computeRestarts(cond)
[17:37:40.007]                           for (restart in restarts) {
[17:37:40.007]                             name <- restart$name
[17:37:40.007]                             if (is.null(name)) 
[17:37:40.007]                               next
[17:37:40.007]                             if (!grepl(pattern, name)) 
[17:37:40.007]                               next
[17:37:40.007]                             invokeRestart(restart)
[17:37:40.007]                             muffled <- TRUE
[17:37:40.007]                             break
[17:37:40.007]                           }
[17:37:40.007]                         }
[17:37:40.007]                       }
[17:37:40.007]                       invisible(muffled)
[17:37:40.007]                     }
[17:37:40.007]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.007]                   }
[17:37:40.007]                 }
[17:37:40.007]             }
[17:37:40.007]         }))
[17:37:40.007]     }, error = function(ex) {
[17:37:40.007]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:40.007]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.007]                 ...future.rng), started = ...future.startTime, 
[17:37:40.007]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:40.007]             version = "1.8"), class = "FutureResult")
[17:37:40.007]     }, finally = {
[17:37:40.007]         if (!identical(...future.workdir, getwd())) 
[17:37:40.007]             setwd(...future.workdir)
[17:37:40.007]         {
[17:37:40.007]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:40.007]                 ...future.oldOptions$nwarnings <- NULL
[17:37:40.007]             }
[17:37:40.007]             base::options(...future.oldOptions)
[17:37:40.007]             if (.Platform$OS.type == "windows") {
[17:37:40.007]                 old_names <- names(...future.oldEnvVars)
[17:37:40.007]                 envs <- base::Sys.getenv()
[17:37:40.007]                 names <- names(envs)
[17:37:40.007]                 common <- intersect(names, old_names)
[17:37:40.007]                 added <- setdiff(names, old_names)
[17:37:40.007]                 removed <- setdiff(old_names, names)
[17:37:40.007]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:40.007]                   envs[common]]
[17:37:40.007]                 NAMES <- toupper(changed)
[17:37:40.007]                 args <- list()
[17:37:40.007]                 for (kk in seq_along(NAMES)) {
[17:37:40.007]                   name <- changed[[kk]]
[17:37:40.007]                   NAME <- NAMES[[kk]]
[17:37:40.007]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.007]                     next
[17:37:40.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.007]                 }
[17:37:40.007]                 NAMES <- toupper(added)
[17:37:40.007]                 for (kk in seq_along(NAMES)) {
[17:37:40.007]                   name <- added[[kk]]
[17:37:40.007]                   NAME <- NAMES[[kk]]
[17:37:40.007]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.007]                     next
[17:37:40.007]                   args[[name]] <- ""
[17:37:40.007]                 }
[17:37:40.007]                 NAMES <- toupper(removed)
[17:37:40.007]                 for (kk in seq_along(NAMES)) {
[17:37:40.007]                   name <- removed[[kk]]
[17:37:40.007]                   NAME <- NAMES[[kk]]
[17:37:40.007]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.007]                     next
[17:37:40.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.007]                 }
[17:37:40.007]                 if (length(args) > 0) 
[17:37:40.007]                   base::do.call(base::Sys.setenv, args = args)
[17:37:40.007]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:40.007]             }
[17:37:40.007]             else {
[17:37:40.007]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:40.007]             }
[17:37:40.007]             {
[17:37:40.007]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:40.007]                   0L) {
[17:37:40.007]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:40.007]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:40.007]                   base::options(opts)
[17:37:40.007]                 }
[17:37:40.007]                 {
[17:37:40.007]                   {
[17:37:40.007]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:40.007]                     NULL
[17:37:40.007]                   }
[17:37:40.007]                   options(future.plan = NULL)
[17:37:40.007]                   if (is.na(NA_character_)) 
[17:37:40.007]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.007]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:40.007]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:40.007]                     .init = FALSE)
[17:37:40.007]                 }
[17:37:40.007]             }
[17:37:40.007]         }
[17:37:40.007]     })
[17:37:40.007]     if (TRUE) {
[17:37:40.007]         base::sink(type = "output", split = FALSE)
[17:37:40.007]         if (TRUE) {
[17:37:40.007]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:40.007]         }
[17:37:40.007]         else {
[17:37:40.007]             ...future.result["stdout"] <- base::list(NULL)
[17:37:40.007]         }
[17:37:40.007]         base::close(...future.stdout)
[17:37:40.007]         ...future.stdout <- NULL
[17:37:40.007]     }
[17:37:40.007]     ...future.result$conditions <- ...future.conditions
[17:37:40.007]     ...future.result$finished <- base::Sys.time()
[17:37:40.007]     ...future.result
[17:37:40.007] }
[17:37:40.010] Exporting 5 global objects (1.10 KiB) to cluster node #1 ...
[17:37:40.010] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:37:40.010] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:37:40.010] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:37:40.011] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:37:40.011] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:37:40.011] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:37:40.012] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:40.012] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:40.012] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:40.012] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:40.013] Exporting 5 global objects (1.10 KiB) to cluster node #1 ... DONE
[17:37:40.013] MultisessionFuture started
[17:37:40.013] - Launch lazy future ... done
[17:37:40.013] run() for ‘MultisessionFuture’ ... done
[17:37:40.014] Created future:
[17:37:40.014] MultisessionFuture:
[17:37:40.014] Label: ‘future_mapply-1’
[17:37:40.014] Expression:
[17:37:40.014] {
[17:37:40.014]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.014]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:40.014]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.014]         on.exit(options(oopts), add = TRUE)
[17:37:40.014]     }
[17:37:40.014]     {
[17:37:40.014]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.014]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:40.014]         do.call(mapply, args = args)
[17:37:40.014]     }
[17:37:40.014] }
[17:37:40.014] Lazy evaluation: FALSE
[17:37:40.014] Asynchronous evaluation: TRUE
[17:37:40.014] Local evaluation: TRUE
[17:37:40.014] Environment: R_GlobalEnv
[17:37:40.014] Capture standard output: TRUE
[17:37:40.014] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:40.014] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:40.014] Packages: <none>
[17:37:40.014] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:40.014] Resolved: FALSE
[17:37:40.014] Value: <not collected>
[17:37:40.014] Conditions captured: <none>
[17:37:40.014] Early signaling: FALSE
[17:37:40.014] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:40.014] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.025] Chunk #1 of 1 ... DONE
[17:37:40.025] Launching 1 futures (chunks) ... DONE
[17:37:40.025] Resolving 1 futures (chunks) ...
[17:37:40.026] resolve() on list ...
[17:37:40.026]  recursive: 0
[17:37:40.026]  length: 1
[17:37:40.026] 
[17:37:40.067] receiveMessageFromWorker() for ClusterFuture ...
[17:37:40.068] - Validating connection of MultisessionFuture
[17:37:40.068] - received message: FutureResult
[17:37:40.068] - Received FutureResult
[17:37:40.068] - Erased future from FutureRegistry
[17:37:40.068] result() for ClusterFuture ...
[17:37:40.068] - result already collected: FutureResult
[17:37:40.068] result() for ClusterFuture ... done
[17:37:40.068] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:40.069] Future #1
[17:37:40.069] result() for ClusterFuture ...
[17:37:40.069] - result already collected: FutureResult
[17:37:40.069] result() for ClusterFuture ... done
[17:37:40.069] result() for ClusterFuture ...
[17:37:40.069] - result already collected: FutureResult
[17:37:40.069] result() for ClusterFuture ... done
[17:37:40.069] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:37:40.069] - nx: 1
[17:37:40.069] - relay: TRUE
[17:37:40.069] - stdout: TRUE
[17:37:40.070] - signal: TRUE
[17:37:40.070] - resignal: FALSE
[17:37:40.070] - force: TRUE
[17:37:40.070] - relayed: [n=1] FALSE
[17:37:40.070] - queued futures: [n=1] FALSE
[17:37:40.070]  - until=1
[17:37:40.070]  - relaying element #1
[17:37:40.070] result() for ClusterFuture ...
[17:37:40.070] - result already collected: FutureResult
[17:37:40.070] result() for ClusterFuture ... done
[17:37:40.070] result() for ClusterFuture ...
[17:37:40.070] - result already collected: FutureResult
[17:37:40.071] result() for ClusterFuture ... done
[17:37:40.071] result() for ClusterFuture ...
[17:37:40.071] - result already collected: FutureResult
[17:37:40.071] result() for ClusterFuture ... done
[17:37:40.071] result() for ClusterFuture ...
[17:37:40.071] - result already collected: FutureResult
[17:37:40.071] result() for ClusterFuture ... done
[17:37:40.071] - relayed: [n=1] TRUE
[17:37:40.071] - queued futures: [n=1] TRUE
[17:37:40.071] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:37:40.071]  length: 0 (resolved future 1)
[17:37:40.071] Relaying remaining futures
[17:37:40.072] signalConditionsASAP(NULL, pos=0) ...
[17:37:40.072] - nx: 1
[17:37:40.072] - relay: TRUE
[17:37:40.072] - stdout: TRUE
[17:37:40.072] - signal: TRUE
[17:37:40.072] - resignal: FALSE
[17:37:40.072] - force: TRUE
[17:37:40.072] - relayed: [n=1] TRUE
[17:37:40.072] - queued futures: [n=1] TRUE
 - flush all
[17:37:40.072] - relayed: [n=1] TRUE
[17:37:40.072] - queued futures: [n=1] TRUE
[17:37:40.073] signalConditionsASAP(NULL, pos=0) ... done
[17:37:40.073] resolve() on list ... DONE
[17:37:40.073] result() for ClusterFuture ...
[17:37:40.073] - result already collected: FutureResult
[17:37:40.073] result() for ClusterFuture ... done
[17:37:40.073] result() for ClusterFuture ...
[17:37:40.073] - result already collected: FutureResult
[17:37:40.073] result() for ClusterFuture ... done
[17:37:40.073]  - Number of value chunks collected: 1
[17:37:40.073] Resolving 1 futures (chunks) ... DONE
[17:37:40.073] Reducing values from 1 chunks ...
[17:37:40.074]  - Number of values collected after concatenation: 1
[17:37:40.074]  - Number of values expected: 1
[17:37:40.074] Reducing values from 1 chunks ... DONE
[17:37:40.074] future_mapply() ... DONE
[17:37:40.074] future_mapply() ...
[17:37:40.077] Number of chunks: 1
[17:37:40.078] getGlobalsAndPackagesXApply() ...
[17:37:40.078]  - future.globals: TRUE
[17:37:40.078] getGlobalsAndPackages() ...
[17:37:40.078] Searching for globals...
[17:37:40.079] - globals found: [1] ‘FUN’
[17:37:40.079] Searching for globals ... DONE
[17:37:40.079] Resolving globals: FALSE
[17:37:40.079] The total size of the 1 globals is 848 bytes (848 bytes)
[17:37:40.080] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:37:40.080] - globals: [1] ‘FUN’
[17:37:40.080] 
[17:37:40.080] getGlobalsAndPackages() ... DONE
[17:37:40.080]  - globals found/used: [n=1] ‘FUN’
[17:37:40.080]  - needed namespaces: [n=0] 
[17:37:40.080] Finding globals ... DONE
[17:37:40.081] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:40.081] List of 2
[17:37:40.081]  $ ...future.FUN:function (x)  
[17:37:40.081]  $ MoreArgs     : list()
[17:37:40.081]  - attr(*, "where")=List of 2
[17:37:40.081]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:40.081]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:40.081]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:40.081]  - attr(*, "resolved")= logi FALSE
[17:37:40.081]  - attr(*, "total_size")= num NA
[17:37:40.083] Packages to be attached in all futures: [n=0] 
[17:37:40.083] getGlobalsAndPackagesXApply() ... DONE
[17:37:40.083] Number of futures (= number of chunks): 1
[17:37:40.083] Launching 1 futures (chunks) ...
[17:37:40.083] Chunk #1 of 1 ...
[17:37:40.084]  - Finding globals in '...' for chunk #1 ...
[17:37:40.084] getGlobalsAndPackages() ...
[17:37:40.084] Searching for globals...
[17:37:40.084] 
[17:37:40.084] Searching for globals ... DONE
[17:37:40.084] - globals: [0] <none>
[17:37:40.084] getGlobalsAndPackages() ... DONE
[17:37:40.084]    + additional globals found: [n=0] 
[17:37:40.085]    + additional namespaces needed: [n=0] 
[17:37:40.085]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:40.085]  - seeds: <none>
[17:37:40.085]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.085] getGlobalsAndPackages() ...
[17:37:40.085] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.085] Resolving globals: FALSE
[17:37:40.086] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[17:37:40.086] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:37:40.086] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.086] 
[17:37:40.086] getGlobalsAndPackages() ... DONE
[17:37:40.087] run() for ‘Future’ ...
[17:37:40.087] - state: ‘created’
[17:37:40.087] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:40.100] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.101] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:40.101]   - Field: ‘node’
[17:37:40.101]   - Field: ‘label’
[17:37:40.101]   - Field: ‘local’
[17:37:40.101]   - Field: ‘owner’
[17:37:40.101]   - Field: ‘envir’
[17:37:40.101]   - Field: ‘workers’
[17:37:40.101]   - Field: ‘packages’
[17:37:40.101]   - Field: ‘gc’
[17:37:40.101]   - Field: ‘conditions’
[17:37:40.102]   - Field: ‘persistent’
[17:37:40.102]   - Field: ‘expr’
[17:37:40.102]   - Field: ‘uuid’
[17:37:40.102]   - Field: ‘seed’
[17:37:40.102]   - Field: ‘version’
[17:37:40.102]   - Field: ‘result’
[17:37:40.102]   - Field: ‘asynchronous’
[17:37:40.102]   - Field: ‘calls’
[17:37:40.102]   - Field: ‘globals’
[17:37:40.102]   - Field: ‘stdout’
[17:37:40.102]   - Field: ‘earlySignal’
[17:37:40.103]   - Field: ‘lazy’
[17:37:40.103]   - Field: ‘state’
[17:37:40.103] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:40.103] - Launch lazy future ...
[17:37:40.103] Packages needed by the future expression (n = 0): <none>
[17:37:40.103] Packages needed by future strategies (n = 0): <none>
[17:37:40.104] {
[17:37:40.104]     {
[17:37:40.104]         {
[17:37:40.104]             ...future.startTime <- base::Sys.time()
[17:37:40.104]             {
[17:37:40.104]                 {
[17:37:40.104]                   {
[17:37:40.104]                     {
[17:37:40.104]                       base::local({
[17:37:40.104]                         has_future <- base::requireNamespace("future", 
[17:37:40.104]                           quietly = TRUE)
[17:37:40.104]                         if (has_future) {
[17:37:40.104]                           ns <- base::getNamespace("future")
[17:37:40.104]                           version <- ns[[".package"]][["version"]]
[17:37:40.104]                           if (is.null(version)) 
[17:37:40.104]                             version <- utils::packageVersion("future")
[17:37:40.104]                         }
[17:37:40.104]                         else {
[17:37:40.104]                           version <- NULL
[17:37:40.104]                         }
[17:37:40.104]                         if (!has_future || version < "1.8.0") {
[17:37:40.104]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:40.104]                             "", base::R.version$version.string), 
[17:37:40.104]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:40.104]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:40.104]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:40.104]                               "release", "version")], collapse = " "), 
[17:37:40.104]                             hostname = base::Sys.info()[["nodename"]])
[17:37:40.104]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:40.104]                             info)
[17:37:40.104]                           info <- base::paste(info, collapse = "; ")
[17:37:40.104]                           if (!has_future) {
[17:37:40.104]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:40.104]                               info)
[17:37:40.104]                           }
[17:37:40.104]                           else {
[17:37:40.104]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:40.104]                               info, version)
[17:37:40.104]                           }
[17:37:40.104]                           base::stop(msg)
[17:37:40.104]                         }
[17:37:40.104]                       })
[17:37:40.104]                     }
[17:37:40.104]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:40.104]                     base::options(mc.cores = 1L)
[17:37:40.104]                   }
[17:37:40.104]                   ...future.strategy.old <- future::plan("list")
[17:37:40.104]                   options(future.plan = NULL)
[17:37:40.104]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.104]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:40.104]                 }
[17:37:40.104]                 ...future.workdir <- getwd()
[17:37:40.104]             }
[17:37:40.104]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:40.104]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:40.104]         }
[17:37:40.104]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:40.104]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:37:40.104]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:40.104]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:40.104]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:40.104]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:40.104]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:40.104]             base::names(...future.oldOptions))
[17:37:40.104]     }
[17:37:40.104]     if (FALSE) {
[17:37:40.104]     }
[17:37:40.104]     else {
[17:37:40.104]         if (TRUE) {
[17:37:40.104]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:40.104]                 open = "w")
[17:37:40.104]         }
[17:37:40.104]         else {
[17:37:40.104]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:40.104]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:40.104]         }
[17:37:40.104]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:40.104]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:40.104]             base::sink(type = "output", split = FALSE)
[17:37:40.104]             base::close(...future.stdout)
[17:37:40.104]         }, add = TRUE)
[17:37:40.104]     }
[17:37:40.104]     ...future.frame <- base::sys.nframe()
[17:37:40.104]     ...future.conditions <- base::list()
[17:37:40.104]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:40.104]     if (FALSE) {
[17:37:40.104]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:40.104]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:40.104]     }
[17:37:40.104]     ...future.result <- base::tryCatch({
[17:37:40.104]         base::withCallingHandlers({
[17:37:40.104]             ...future.value <- base::withVisible(base::local({
[17:37:40.104]                 ...future.makeSendCondition <- base::local({
[17:37:40.104]                   sendCondition <- NULL
[17:37:40.104]                   function(frame = 1L) {
[17:37:40.104]                     if (is.function(sendCondition)) 
[17:37:40.104]                       return(sendCondition)
[17:37:40.104]                     ns <- getNamespace("parallel")
[17:37:40.104]                     if (exists("sendData", mode = "function", 
[17:37:40.104]                       envir = ns)) {
[17:37:40.104]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:40.104]                         envir = ns)
[17:37:40.104]                       envir <- sys.frame(frame)
[17:37:40.104]                       master <- NULL
[17:37:40.104]                       while (!identical(envir, .GlobalEnv) && 
[17:37:40.104]                         !identical(envir, emptyenv())) {
[17:37:40.104]                         if (exists("master", mode = "list", envir = envir, 
[17:37:40.104]                           inherits = FALSE)) {
[17:37:40.104]                           master <- get("master", mode = "list", 
[17:37:40.104]                             envir = envir, inherits = FALSE)
[17:37:40.104]                           if (inherits(master, c("SOCKnode", 
[17:37:40.104]                             "SOCK0node"))) {
[17:37:40.104]                             sendCondition <<- function(cond) {
[17:37:40.104]                               data <- list(type = "VALUE", value = cond, 
[17:37:40.104]                                 success = TRUE)
[17:37:40.104]                               parallel_sendData(master, data)
[17:37:40.104]                             }
[17:37:40.104]                             return(sendCondition)
[17:37:40.104]                           }
[17:37:40.104]                         }
[17:37:40.104]                         frame <- frame + 1L
[17:37:40.104]                         envir <- sys.frame(frame)
[17:37:40.104]                       }
[17:37:40.104]                     }
[17:37:40.104]                     sendCondition <<- function(cond) NULL
[17:37:40.104]                   }
[17:37:40.104]                 })
[17:37:40.104]                 withCallingHandlers({
[17:37:40.104]                   {
[17:37:40.104]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.104]                     if (!identical(...future.globals.maxSize.org, 
[17:37:40.104]                       ...future.globals.maxSize)) {
[17:37:40.104]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.104]                       on.exit(options(oopts), add = TRUE)
[17:37:40.104]                     }
[17:37:40.104]                     {
[17:37:40.104]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.104]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:40.104]                         USE.NAMES = FALSE)
[17:37:40.104]                       do.call(mapply, args = args)
[17:37:40.104]                     }
[17:37:40.104]                   }
[17:37:40.104]                 }, immediateCondition = function(cond) {
[17:37:40.104]                   sendCondition <- ...future.makeSendCondition()
[17:37:40.104]                   sendCondition(cond)
[17:37:40.104]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.104]                   {
[17:37:40.104]                     inherits <- base::inherits
[17:37:40.104]                     invokeRestart <- base::invokeRestart
[17:37:40.104]                     is.null <- base::is.null
[17:37:40.104]                     muffled <- FALSE
[17:37:40.104]                     if (inherits(cond, "message")) {
[17:37:40.104]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:40.104]                       if (muffled) 
[17:37:40.104]                         invokeRestart("muffleMessage")
[17:37:40.104]                     }
[17:37:40.104]                     else if (inherits(cond, "warning")) {
[17:37:40.104]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:40.104]                       if (muffled) 
[17:37:40.104]                         invokeRestart("muffleWarning")
[17:37:40.104]                     }
[17:37:40.104]                     else if (inherits(cond, "condition")) {
[17:37:40.104]                       if (!is.null(pattern)) {
[17:37:40.104]                         computeRestarts <- base::computeRestarts
[17:37:40.104]                         grepl <- base::grepl
[17:37:40.104]                         restarts <- computeRestarts(cond)
[17:37:40.104]                         for (restart in restarts) {
[17:37:40.104]                           name <- restart$name
[17:37:40.104]                           if (is.null(name)) 
[17:37:40.104]                             next
[17:37:40.104]                           if (!grepl(pattern, name)) 
[17:37:40.104]                             next
[17:37:40.104]                           invokeRestart(restart)
[17:37:40.104]                           muffled <- TRUE
[17:37:40.104]                           break
[17:37:40.104]                         }
[17:37:40.104]                       }
[17:37:40.104]                     }
[17:37:40.104]                     invisible(muffled)
[17:37:40.104]                   }
[17:37:40.104]                   muffleCondition(cond)
[17:37:40.104]                 })
[17:37:40.104]             }))
[17:37:40.104]             future::FutureResult(value = ...future.value$value, 
[17:37:40.104]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.104]                   ...future.rng), globalenv = if (FALSE) 
[17:37:40.104]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:40.104]                     ...future.globalenv.names))
[17:37:40.104]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:40.104]         }, condition = base::local({
[17:37:40.104]             c <- base::c
[17:37:40.104]             inherits <- base::inherits
[17:37:40.104]             invokeRestart <- base::invokeRestart
[17:37:40.104]             length <- base::length
[17:37:40.104]             list <- base::list
[17:37:40.104]             seq.int <- base::seq.int
[17:37:40.104]             signalCondition <- base::signalCondition
[17:37:40.104]             sys.calls <- base::sys.calls
[17:37:40.104]             `[[` <- base::`[[`
[17:37:40.104]             `+` <- base::`+`
[17:37:40.104]             `<<-` <- base::`<<-`
[17:37:40.104]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:40.104]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:40.104]                   3L)]
[17:37:40.104]             }
[17:37:40.104]             function(cond) {
[17:37:40.104]                 is_error <- inherits(cond, "error")
[17:37:40.104]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:40.104]                   NULL)
[17:37:40.104]                 if (is_error) {
[17:37:40.104]                   sessionInformation <- function() {
[17:37:40.104]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:40.104]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:40.104]                       search = base::search(), system = base::Sys.info())
[17:37:40.104]                   }
[17:37:40.104]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.104]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:40.104]                     cond$call), session = sessionInformation(), 
[17:37:40.104]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:40.104]                   signalCondition(cond)
[17:37:40.104]                 }
[17:37:40.104]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:40.104]                 "immediateCondition"))) {
[17:37:40.104]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:40.104]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.104]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:40.104]                   if (TRUE && !signal) {
[17:37:40.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.104]                     {
[17:37:40.104]                       inherits <- base::inherits
[17:37:40.104]                       invokeRestart <- base::invokeRestart
[17:37:40.104]                       is.null <- base::is.null
[17:37:40.104]                       muffled <- FALSE
[17:37:40.104]                       if (inherits(cond, "message")) {
[17:37:40.104]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.104]                         if (muffled) 
[17:37:40.104]                           invokeRestart("muffleMessage")
[17:37:40.104]                       }
[17:37:40.104]                       else if (inherits(cond, "warning")) {
[17:37:40.104]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.104]                         if (muffled) 
[17:37:40.104]                           invokeRestart("muffleWarning")
[17:37:40.104]                       }
[17:37:40.104]                       else if (inherits(cond, "condition")) {
[17:37:40.104]                         if (!is.null(pattern)) {
[17:37:40.104]                           computeRestarts <- base::computeRestarts
[17:37:40.104]                           grepl <- base::grepl
[17:37:40.104]                           restarts <- computeRestarts(cond)
[17:37:40.104]                           for (restart in restarts) {
[17:37:40.104]                             name <- restart$name
[17:37:40.104]                             if (is.null(name)) 
[17:37:40.104]                               next
[17:37:40.104]                             if (!grepl(pattern, name)) 
[17:37:40.104]                               next
[17:37:40.104]                             invokeRestart(restart)
[17:37:40.104]                             muffled <- TRUE
[17:37:40.104]                             break
[17:37:40.104]                           }
[17:37:40.104]                         }
[17:37:40.104]                       }
[17:37:40.104]                       invisible(muffled)
[17:37:40.104]                     }
[17:37:40.104]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.104]                   }
[17:37:40.104]                 }
[17:37:40.104]                 else {
[17:37:40.104]                   if (TRUE) {
[17:37:40.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.104]                     {
[17:37:40.104]                       inherits <- base::inherits
[17:37:40.104]                       invokeRestart <- base::invokeRestart
[17:37:40.104]                       is.null <- base::is.null
[17:37:40.104]                       muffled <- FALSE
[17:37:40.104]                       if (inherits(cond, "message")) {
[17:37:40.104]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.104]                         if (muffled) 
[17:37:40.104]                           invokeRestart("muffleMessage")
[17:37:40.104]                       }
[17:37:40.104]                       else if (inherits(cond, "warning")) {
[17:37:40.104]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.104]                         if (muffled) 
[17:37:40.104]                           invokeRestart("muffleWarning")
[17:37:40.104]                       }
[17:37:40.104]                       else if (inherits(cond, "condition")) {
[17:37:40.104]                         if (!is.null(pattern)) {
[17:37:40.104]                           computeRestarts <- base::computeRestarts
[17:37:40.104]                           grepl <- base::grepl
[17:37:40.104]                           restarts <- computeRestarts(cond)
[17:37:40.104]                           for (restart in restarts) {
[17:37:40.104]                             name <- restart$name
[17:37:40.104]                             if (is.null(name)) 
[17:37:40.104]                               next
[17:37:40.104]                             if (!grepl(pattern, name)) 
[17:37:40.104]                               next
[17:37:40.104]                             invokeRestart(restart)
[17:37:40.104]                             muffled <- TRUE
[17:37:40.104]                             break
[17:37:40.104]                           }
[17:37:40.104]                         }
[17:37:40.104]                       }
[17:37:40.104]                       invisible(muffled)
[17:37:40.104]                     }
[17:37:40.104]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.104]                   }
[17:37:40.104]                 }
[17:37:40.104]             }
[17:37:40.104]         }))
[17:37:40.104]     }, error = function(ex) {
[17:37:40.104]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:40.104]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.104]                 ...future.rng), started = ...future.startTime, 
[17:37:40.104]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:40.104]             version = "1.8"), class = "FutureResult")
[17:37:40.104]     }, finally = {
[17:37:40.104]         if (!identical(...future.workdir, getwd())) 
[17:37:40.104]             setwd(...future.workdir)
[17:37:40.104]         {
[17:37:40.104]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:40.104]                 ...future.oldOptions$nwarnings <- NULL
[17:37:40.104]             }
[17:37:40.104]             base::options(...future.oldOptions)
[17:37:40.104]             if (.Platform$OS.type == "windows") {
[17:37:40.104]                 old_names <- names(...future.oldEnvVars)
[17:37:40.104]                 envs <- base::Sys.getenv()
[17:37:40.104]                 names <- names(envs)
[17:37:40.104]                 common <- intersect(names, old_names)
[17:37:40.104]                 added <- setdiff(names, old_names)
[17:37:40.104]                 removed <- setdiff(old_names, names)
[17:37:40.104]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:40.104]                   envs[common]]
[17:37:40.104]                 NAMES <- toupper(changed)
[17:37:40.104]                 args <- list()
[17:37:40.104]                 for (kk in seq_along(NAMES)) {
[17:37:40.104]                   name <- changed[[kk]]
[17:37:40.104]                   NAME <- NAMES[[kk]]
[17:37:40.104]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.104]                     next
[17:37:40.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.104]                 }
[17:37:40.104]                 NAMES <- toupper(added)
[17:37:40.104]                 for (kk in seq_along(NAMES)) {
[17:37:40.104]                   name <- added[[kk]]
[17:37:40.104]                   NAME <- NAMES[[kk]]
[17:37:40.104]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.104]                     next
[17:37:40.104]                   args[[name]] <- ""
[17:37:40.104]                 }
[17:37:40.104]                 NAMES <- toupper(removed)
[17:37:40.104]                 for (kk in seq_along(NAMES)) {
[17:37:40.104]                   name <- removed[[kk]]
[17:37:40.104]                   NAME <- NAMES[[kk]]
[17:37:40.104]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.104]                     next
[17:37:40.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.104]                 }
[17:37:40.104]                 if (length(args) > 0) 
[17:37:40.104]                   base::do.call(base::Sys.setenv, args = args)
[17:37:40.104]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:40.104]             }
[17:37:40.104]             else {
[17:37:40.104]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:40.104]             }
[17:37:40.104]             {
[17:37:40.104]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:40.104]                   0L) {
[17:37:40.104]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:40.104]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:40.104]                   base::options(opts)
[17:37:40.104]                 }
[17:37:40.104]                 {
[17:37:40.104]                   {
[17:37:40.104]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:40.104]                     NULL
[17:37:40.104]                   }
[17:37:40.104]                   options(future.plan = NULL)
[17:37:40.104]                   if (is.na(NA_character_)) 
[17:37:40.104]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.104]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:40.104]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:40.104]                     .init = FALSE)
[17:37:40.104]                 }
[17:37:40.104]             }
[17:37:40.104]         }
[17:37:40.104]     })
[17:37:40.104]     if (TRUE) {
[17:37:40.104]         base::sink(type = "output", split = FALSE)
[17:37:40.104]         if (TRUE) {
[17:37:40.104]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:40.104]         }
[17:37:40.104]         else {
[17:37:40.104]             ...future.result["stdout"] <- base::list(NULL)
[17:37:40.104]         }
[17:37:40.104]         base::close(...future.stdout)
[17:37:40.104]         ...future.stdout <- NULL
[17:37:40.104]     }
[17:37:40.104]     ...future.result$conditions <- ...future.conditions
[17:37:40.104]     ...future.result$finished <- base::Sys.time()
[17:37:40.104]     ...future.result
[17:37:40.104] }
[17:37:40.106] Exporting 5 global objects (1.10 KiB) to cluster node #1 ...
[17:37:40.107] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:37:40.107] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:37:40.107] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:37:40.107] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:37:40.108] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:37:40.108] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:37:40.108] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:40.109] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:40.109] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:40.109] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:40.109] Exporting 5 global objects (1.10 KiB) to cluster node #1 ... DONE
[17:37:40.110] MultisessionFuture started
[17:37:40.110] - Launch lazy future ... done
[17:37:40.110] run() for ‘MultisessionFuture’ ... done
[17:37:40.110] Created future:
[17:37:40.110] MultisessionFuture:
[17:37:40.110] Label: ‘future_.mapply-1’
[17:37:40.110] Expression:
[17:37:40.110] {
[17:37:40.110]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.110]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:40.110]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.110]         on.exit(options(oopts), add = TRUE)
[17:37:40.110]     }
[17:37:40.110]     {
[17:37:40.110]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.110]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:40.110]         do.call(mapply, args = args)
[17:37:40.110]     }
[17:37:40.110] }
[17:37:40.110] Lazy evaluation: FALSE
[17:37:40.110] Asynchronous evaluation: TRUE
[17:37:40.110] Local evaluation: TRUE
[17:37:40.110] Environment: R_GlobalEnv
[17:37:40.110] Capture standard output: TRUE
[17:37:40.110] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:40.110] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:40.110] Packages: <none>
[17:37:40.110] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:40.110] Resolved: FALSE
[17:37:40.110] Value: <not collected>
[17:37:40.110] Conditions captured: <none>
[17:37:40.110] Early signaling: FALSE
[17:37:40.110] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:40.110] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.122] Chunk #1 of 1 ... DONE
[17:37:40.122] Launching 1 futures (chunks) ... DONE
[17:37:40.122] Resolving 1 futures (chunks) ...
[17:37:40.122] resolve() on list ...
[17:37:40.122]  recursive: 0
[17:37:40.122]  length: 1
[17:37:40.122] 
[17:37:40.164] receiveMessageFromWorker() for ClusterFuture ...
[17:37:40.164] - Validating connection of MultisessionFuture
[17:37:40.164] - received message: FutureResult
[17:37:40.165] - Received FutureResult
[17:37:40.165] - Erased future from FutureRegistry
[17:37:40.165] result() for ClusterFuture ...
[17:37:40.165] - result already collected: FutureResult
[17:37:40.165] result() for ClusterFuture ... done
[17:37:40.165] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:40.165] Future #1
[17:37:40.165] result() for ClusterFuture ...
[17:37:40.165] - result already collected: FutureResult
[17:37:40.166] result() for ClusterFuture ... done
[17:37:40.166] result() for ClusterFuture ...
[17:37:40.166] - result already collected: FutureResult
[17:37:40.166] result() for ClusterFuture ... done
[17:37:40.166] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:37:40.166] - nx: 1
[17:37:40.166] - relay: TRUE
[17:37:40.166] - stdout: TRUE
[17:37:40.166] - signal: TRUE
[17:37:40.166] - resignal: FALSE
[17:37:40.166] - force: TRUE
[17:37:40.166] - relayed: [n=1] FALSE
[17:37:40.167] - queued futures: [n=1] FALSE
[17:37:40.167]  - until=1
[17:37:40.167]  - relaying element #1
[17:37:40.167] result() for ClusterFuture ...
[17:37:40.167] - result already collected: FutureResult
[17:37:40.167] result() for ClusterFuture ... done
[17:37:40.167] result() for ClusterFuture ...
[17:37:40.167] - result already collected: FutureResult
[17:37:40.167] result() for ClusterFuture ... done
[17:37:40.167] result() for ClusterFuture ...
[17:37:40.167] - result already collected: FutureResult
[17:37:40.168] result() for ClusterFuture ... done
[17:37:40.168] result() for ClusterFuture ...
[17:37:40.168] - result already collected: FutureResult
[17:37:40.168] result() for ClusterFuture ... done
[17:37:40.168] - relayed: [n=1] TRUE
[17:37:40.168] - queued futures: [n=1] TRUE
[17:37:40.168] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:37:40.168]  length: 0 (resolved future 1)
[17:37:40.168] Relaying remaining futures
[17:37:40.168] signalConditionsASAP(NULL, pos=0) ...
[17:37:40.168] - nx: 1
[17:37:40.169] - relay: TRUE
[17:37:40.169] - stdout: TRUE
[17:37:40.169] - signal: TRUE
[17:37:40.169] - resignal: FALSE
[17:37:40.169] - force: TRUE
[17:37:40.169] - relayed: [n=1] TRUE
[17:37:40.169] - queued futures: [n=1] TRUE
 - flush all
[17:37:40.169] - relayed: [n=1] TRUE
[17:37:40.169] - queued futures: [n=1] TRUE
[17:37:40.169] signalConditionsASAP(NULL, pos=0) ... done
[17:37:40.169] resolve() on list ... DONE
[17:37:40.169] result() for ClusterFuture ...
[17:37:40.170] - result already collected: FutureResult
[17:37:40.170] result() for ClusterFuture ... done
[17:37:40.170] result() for ClusterFuture ...
[17:37:40.170] - result already collected: FutureResult
[17:37:40.170] result() for ClusterFuture ... done
[17:37:40.170]  - Number of value chunks collected: 1
[17:37:40.170] Resolving 1 futures (chunks) ... DONE
[17:37:40.170] Reducing values from 1 chunks ...
[17:37:40.170]  - Number of values collected after concatenation: 1
[17:37:40.170]  - Number of values expected: 1
[17:37:40.170] Reducing values from 1 chunks ... DONE
[17:37:40.171] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[17:37:40.171] future_mapply() ...
[17:37:40.177] Number of chunks: 2
[17:37:40.177] getGlobalsAndPackagesXApply() ...
[17:37:40.177]  - future.globals: TRUE
[17:37:40.177] getGlobalsAndPackages() ...
[17:37:40.177] Searching for globals...
[17:37:40.178] - globals found: [1] ‘FUN’
[17:37:40.179] Searching for globals ... DONE
[17:37:40.179] Resolving globals: FALSE
[17:37:40.179] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:37:40.179] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:37:40.179] - globals: [1] ‘FUN’
[17:37:40.179] 
[17:37:40.180] getGlobalsAndPackages() ... DONE
[17:37:40.180]  - globals found/used: [n=1] ‘FUN’
[17:37:40.180]  - needed namespaces: [n=0] 
[17:37:40.180] Finding globals ... DONE
[17:37:40.180] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:40.180] List of 2
[17:37:40.180]  $ ...future.FUN:function (x, y)  
[17:37:40.180]  $ MoreArgs     :List of 1
[17:37:40.180]   ..$ y: int [1:2] 3 4
[17:37:40.180]  - attr(*, "where")=List of 2
[17:37:40.180]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:40.180]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:40.180]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:40.180]  - attr(*, "resolved")= logi FALSE
[17:37:40.180]  - attr(*, "total_size")= num NA
[17:37:40.183] Packages to be attached in all futures: [n=0] 
[17:37:40.183] getGlobalsAndPackagesXApply() ... DONE
[17:37:40.183] Number of futures (= number of chunks): 2
[17:37:40.183] Launching 2 futures (chunks) ...
[17:37:40.183] Chunk #1 of 2 ...
[17:37:40.183]  - Finding globals in '...' for chunk #1 ...
[17:37:40.184] getGlobalsAndPackages() ...
[17:37:40.184] Searching for globals...
[17:37:40.184] 
[17:37:40.184] Searching for globals ... DONE
[17:37:40.184] - globals: [0] <none>
[17:37:40.184] getGlobalsAndPackages() ... DONE
[17:37:40.184]    + additional globals found: [n=0] 
[17:37:40.184]    + additional namespaces needed: [n=0] 
[17:37:40.184]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:40.185]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:40.185]  - seeds: <none>
[17:37:40.185]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.185] getGlobalsAndPackages() ...
[17:37:40.185] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.185] Resolving globals: FALSE
[17:37:40.185] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:37:40.186] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:37:40.186] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.186] 
[17:37:40.186] getGlobalsAndPackages() ... DONE
[17:37:40.186] run() for ‘Future’ ...
[17:37:40.187] - state: ‘created’
[17:37:40.187] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:40.200] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.200] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:40.200]   - Field: ‘node’
[17:37:40.201]   - Field: ‘label’
[17:37:40.201]   - Field: ‘local’
[17:37:40.201]   - Field: ‘owner’
[17:37:40.201]   - Field: ‘envir’
[17:37:40.201]   - Field: ‘workers’
[17:37:40.201]   - Field: ‘packages’
[17:37:40.201]   - Field: ‘gc’
[17:37:40.201]   - Field: ‘conditions’
[17:37:40.201]   - Field: ‘persistent’
[17:37:40.201]   - Field: ‘expr’
[17:37:40.201]   - Field: ‘uuid’
[17:37:40.201]   - Field: ‘seed’
[17:37:40.202]   - Field: ‘version’
[17:37:40.202]   - Field: ‘result’
[17:37:40.202]   - Field: ‘asynchronous’
[17:37:40.202]   - Field: ‘calls’
[17:37:40.202]   - Field: ‘globals’
[17:37:40.202]   - Field: ‘stdout’
[17:37:40.202]   - Field: ‘earlySignal’
[17:37:40.202]   - Field: ‘lazy’
[17:37:40.202]   - Field: ‘state’
[17:37:40.202] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:40.202] - Launch lazy future ...
[17:37:40.203] Packages needed by the future expression (n = 0): <none>
[17:37:40.203] Packages needed by future strategies (n = 0): <none>
[17:37:40.203] {
[17:37:40.203]     {
[17:37:40.203]         {
[17:37:40.203]             ...future.startTime <- base::Sys.time()
[17:37:40.203]             {
[17:37:40.203]                 {
[17:37:40.203]                   {
[17:37:40.203]                     {
[17:37:40.203]                       base::local({
[17:37:40.203]                         has_future <- base::requireNamespace("future", 
[17:37:40.203]                           quietly = TRUE)
[17:37:40.203]                         if (has_future) {
[17:37:40.203]                           ns <- base::getNamespace("future")
[17:37:40.203]                           version <- ns[[".package"]][["version"]]
[17:37:40.203]                           if (is.null(version)) 
[17:37:40.203]                             version <- utils::packageVersion("future")
[17:37:40.203]                         }
[17:37:40.203]                         else {
[17:37:40.203]                           version <- NULL
[17:37:40.203]                         }
[17:37:40.203]                         if (!has_future || version < "1.8.0") {
[17:37:40.203]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:40.203]                             "", base::R.version$version.string), 
[17:37:40.203]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:40.203]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:40.203]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:40.203]                               "release", "version")], collapse = " "), 
[17:37:40.203]                             hostname = base::Sys.info()[["nodename"]])
[17:37:40.203]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:40.203]                             info)
[17:37:40.203]                           info <- base::paste(info, collapse = "; ")
[17:37:40.203]                           if (!has_future) {
[17:37:40.203]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:40.203]                               info)
[17:37:40.203]                           }
[17:37:40.203]                           else {
[17:37:40.203]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:40.203]                               info, version)
[17:37:40.203]                           }
[17:37:40.203]                           base::stop(msg)
[17:37:40.203]                         }
[17:37:40.203]                       })
[17:37:40.203]                     }
[17:37:40.203]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:40.203]                     base::options(mc.cores = 1L)
[17:37:40.203]                   }
[17:37:40.203]                   ...future.strategy.old <- future::plan("list")
[17:37:40.203]                   options(future.plan = NULL)
[17:37:40.203]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.203]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:40.203]                 }
[17:37:40.203]                 ...future.workdir <- getwd()
[17:37:40.203]             }
[17:37:40.203]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:40.203]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:40.203]         }
[17:37:40.203]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:40.203]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:40.203]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:40.203]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:40.203]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:40.203]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:40.203]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:40.203]             base::names(...future.oldOptions))
[17:37:40.203]     }
[17:37:40.203]     if (FALSE) {
[17:37:40.203]     }
[17:37:40.203]     else {
[17:37:40.203]         if (TRUE) {
[17:37:40.203]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:40.203]                 open = "w")
[17:37:40.203]         }
[17:37:40.203]         else {
[17:37:40.203]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:40.203]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:40.203]         }
[17:37:40.203]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:40.203]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:40.203]             base::sink(type = "output", split = FALSE)
[17:37:40.203]             base::close(...future.stdout)
[17:37:40.203]         }, add = TRUE)
[17:37:40.203]     }
[17:37:40.203]     ...future.frame <- base::sys.nframe()
[17:37:40.203]     ...future.conditions <- base::list()
[17:37:40.203]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:40.203]     if (FALSE) {
[17:37:40.203]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:40.203]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:40.203]     }
[17:37:40.203]     ...future.result <- base::tryCatch({
[17:37:40.203]         base::withCallingHandlers({
[17:37:40.203]             ...future.value <- base::withVisible(base::local({
[17:37:40.203]                 ...future.makeSendCondition <- base::local({
[17:37:40.203]                   sendCondition <- NULL
[17:37:40.203]                   function(frame = 1L) {
[17:37:40.203]                     if (is.function(sendCondition)) 
[17:37:40.203]                       return(sendCondition)
[17:37:40.203]                     ns <- getNamespace("parallel")
[17:37:40.203]                     if (exists("sendData", mode = "function", 
[17:37:40.203]                       envir = ns)) {
[17:37:40.203]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:40.203]                         envir = ns)
[17:37:40.203]                       envir <- sys.frame(frame)
[17:37:40.203]                       master <- NULL
[17:37:40.203]                       while (!identical(envir, .GlobalEnv) && 
[17:37:40.203]                         !identical(envir, emptyenv())) {
[17:37:40.203]                         if (exists("master", mode = "list", envir = envir, 
[17:37:40.203]                           inherits = FALSE)) {
[17:37:40.203]                           master <- get("master", mode = "list", 
[17:37:40.203]                             envir = envir, inherits = FALSE)
[17:37:40.203]                           if (inherits(master, c("SOCKnode", 
[17:37:40.203]                             "SOCK0node"))) {
[17:37:40.203]                             sendCondition <<- function(cond) {
[17:37:40.203]                               data <- list(type = "VALUE", value = cond, 
[17:37:40.203]                                 success = TRUE)
[17:37:40.203]                               parallel_sendData(master, data)
[17:37:40.203]                             }
[17:37:40.203]                             return(sendCondition)
[17:37:40.203]                           }
[17:37:40.203]                         }
[17:37:40.203]                         frame <- frame + 1L
[17:37:40.203]                         envir <- sys.frame(frame)
[17:37:40.203]                       }
[17:37:40.203]                     }
[17:37:40.203]                     sendCondition <<- function(cond) NULL
[17:37:40.203]                   }
[17:37:40.203]                 })
[17:37:40.203]                 withCallingHandlers({
[17:37:40.203]                   {
[17:37:40.203]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.203]                     if (!identical(...future.globals.maxSize.org, 
[17:37:40.203]                       ...future.globals.maxSize)) {
[17:37:40.203]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.203]                       on.exit(options(oopts), add = TRUE)
[17:37:40.203]                     }
[17:37:40.203]                     {
[17:37:40.203]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.203]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:40.203]                         USE.NAMES = FALSE)
[17:37:40.203]                       do.call(mapply, args = args)
[17:37:40.203]                     }
[17:37:40.203]                   }
[17:37:40.203]                 }, immediateCondition = function(cond) {
[17:37:40.203]                   sendCondition <- ...future.makeSendCondition()
[17:37:40.203]                   sendCondition(cond)
[17:37:40.203]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.203]                   {
[17:37:40.203]                     inherits <- base::inherits
[17:37:40.203]                     invokeRestart <- base::invokeRestart
[17:37:40.203]                     is.null <- base::is.null
[17:37:40.203]                     muffled <- FALSE
[17:37:40.203]                     if (inherits(cond, "message")) {
[17:37:40.203]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:40.203]                       if (muffled) 
[17:37:40.203]                         invokeRestart("muffleMessage")
[17:37:40.203]                     }
[17:37:40.203]                     else if (inherits(cond, "warning")) {
[17:37:40.203]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:40.203]                       if (muffled) 
[17:37:40.203]                         invokeRestart("muffleWarning")
[17:37:40.203]                     }
[17:37:40.203]                     else if (inherits(cond, "condition")) {
[17:37:40.203]                       if (!is.null(pattern)) {
[17:37:40.203]                         computeRestarts <- base::computeRestarts
[17:37:40.203]                         grepl <- base::grepl
[17:37:40.203]                         restarts <- computeRestarts(cond)
[17:37:40.203]                         for (restart in restarts) {
[17:37:40.203]                           name <- restart$name
[17:37:40.203]                           if (is.null(name)) 
[17:37:40.203]                             next
[17:37:40.203]                           if (!grepl(pattern, name)) 
[17:37:40.203]                             next
[17:37:40.203]                           invokeRestart(restart)
[17:37:40.203]                           muffled <- TRUE
[17:37:40.203]                           break
[17:37:40.203]                         }
[17:37:40.203]                       }
[17:37:40.203]                     }
[17:37:40.203]                     invisible(muffled)
[17:37:40.203]                   }
[17:37:40.203]                   muffleCondition(cond)
[17:37:40.203]                 })
[17:37:40.203]             }))
[17:37:40.203]             future::FutureResult(value = ...future.value$value, 
[17:37:40.203]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.203]                   ...future.rng), globalenv = if (FALSE) 
[17:37:40.203]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:40.203]                     ...future.globalenv.names))
[17:37:40.203]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:40.203]         }, condition = base::local({
[17:37:40.203]             c <- base::c
[17:37:40.203]             inherits <- base::inherits
[17:37:40.203]             invokeRestart <- base::invokeRestart
[17:37:40.203]             length <- base::length
[17:37:40.203]             list <- base::list
[17:37:40.203]             seq.int <- base::seq.int
[17:37:40.203]             signalCondition <- base::signalCondition
[17:37:40.203]             sys.calls <- base::sys.calls
[17:37:40.203]             `[[` <- base::`[[`
[17:37:40.203]             `+` <- base::`+`
[17:37:40.203]             `<<-` <- base::`<<-`
[17:37:40.203]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:40.203]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:40.203]                   3L)]
[17:37:40.203]             }
[17:37:40.203]             function(cond) {
[17:37:40.203]                 is_error <- inherits(cond, "error")
[17:37:40.203]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:40.203]                   NULL)
[17:37:40.203]                 if (is_error) {
[17:37:40.203]                   sessionInformation <- function() {
[17:37:40.203]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:40.203]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:40.203]                       search = base::search(), system = base::Sys.info())
[17:37:40.203]                   }
[17:37:40.203]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.203]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:40.203]                     cond$call), session = sessionInformation(), 
[17:37:40.203]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:40.203]                   signalCondition(cond)
[17:37:40.203]                 }
[17:37:40.203]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:40.203]                 "immediateCondition"))) {
[17:37:40.203]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:40.203]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.203]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:40.203]                   if (TRUE && !signal) {
[17:37:40.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.203]                     {
[17:37:40.203]                       inherits <- base::inherits
[17:37:40.203]                       invokeRestart <- base::invokeRestart
[17:37:40.203]                       is.null <- base::is.null
[17:37:40.203]                       muffled <- FALSE
[17:37:40.203]                       if (inherits(cond, "message")) {
[17:37:40.203]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.203]                         if (muffled) 
[17:37:40.203]                           invokeRestart("muffleMessage")
[17:37:40.203]                       }
[17:37:40.203]                       else if (inherits(cond, "warning")) {
[17:37:40.203]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.203]                         if (muffled) 
[17:37:40.203]                           invokeRestart("muffleWarning")
[17:37:40.203]                       }
[17:37:40.203]                       else if (inherits(cond, "condition")) {
[17:37:40.203]                         if (!is.null(pattern)) {
[17:37:40.203]                           computeRestarts <- base::computeRestarts
[17:37:40.203]                           grepl <- base::grepl
[17:37:40.203]                           restarts <- computeRestarts(cond)
[17:37:40.203]                           for (restart in restarts) {
[17:37:40.203]                             name <- restart$name
[17:37:40.203]                             if (is.null(name)) 
[17:37:40.203]                               next
[17:37:40.203]                             if (!grepl(pattern, name)) 
[17:37:40.203]                               next
[17:37:40.203]                             invokeRestart(restart)
[17:37:40.203]                             muffled <- TRUE
[17:37:40.203]                             break
[17:37:40.203]                           }
[17:37:40.203]                         }
[17:37:40.203]                       }
[17:37:40.203]                       invisible(muffled)
[17:37:40.203]                     }
[17:37:40.203]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.203]                   }
[17:37:40.203]                 }
[17:37:40.203]                 else {
[17:37:40.203]                   if (TRUE) {
[17:37:40.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.203]                     {
[17:37:40.203]                       inherits <- base::inherits
[17:37:40.203]                       invokeRestart <- base::invokeRestart
[17:37:40.203]                       is.null <- base::is.null
[17:37:40.203]                       muffled <- FALSE
[17:37:40.203]                       if (inherits(cond, "message")) {
[17:37:40.203]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.203]                         if (muffled) 
[17:37:40.203]                           invokeRestart("muffleMessage")
[17:37:40.203]                       }
[17:37:40.203]                       else if (inherits(cond, "warning")) {
[17:37:40.203]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.203]                         if (muffled) 
[17:37:40.203]                           invokeRestart("muffleWarning")
[17:37:40.203]                       }
[17:37:40.203]                       else if (inherits(cond, "condition")) {
[17:37:40.203]                         if (!is.null(pattern)) {
[17:37:40.203]                           computeRestarts <- base::computeRestarts
[17:37:40.203]                           grepl <- base::grepl
[17:37:40.203]                           restarts <- computeRestarts(cond)
[17:37:40.203]                           for (restart in restarts) {
[17:37:40.203]                             name <- restart$name
[17:37:40.203]                             if (is.null(name)) 
[17:37:40.203]                               next
[17:37:40.203]                             if (!grepl(pattern, name)) 
[17:37:40.203]                               next
[17:37:40.203]                             invokeRestart(restart)
[17:37:40.203]                             muffled <- TRUE
[17:37:40.203]                             break
[17:37:40.203]                           }
[17:37:40.203]                         }
[17:37:40.203]                       }
[17:37:40.203]                       invisible(muffled)
[17:37:40.203]                     }
[17:37:40.203]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.203]                   }
[17:37:40.203]                 }
[17:37:40.203]             }
[17:37:40.203]         }))
[17:37:40.203]     }, error = function(ex) {
[17:37:40.203]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:40.203]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.203]                 ...future.rng), started = ...future.startTime, 
[17:37:40.203]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:40.203]             version = "1.8"), class = "FutureResult")
[17:37:40.203]     }, finally = {
[17:37:40.203]         if (!identical(...future.workdir, getwd())) 
[17:37:40.203]             setwd(...future.workdir)
[17:37:40.203]         {
[17:37:40.203]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:40.203]                 ...future.oldOptions$nwarnings <- NULL
[17:37:40.203]             }
[17:37:40.203]             base::options(...future.oldOptions)
[17:37:40.203]             if (.Platform$OS.type == "windows") {
[17:37:40.203]                 old_names <- names(...future.oldEnvVars)
[17:37:40.203]                 envs <- base::Sys.getenv()
[17:37:40.203]                 names <- names(envs)
[17:37:40.203]                 common <- intersect(names, old_names)
[17:37:40.203]                 added <- setdiff(names, old_names)
[17:37:40.203]                 removed <- setdiff(old_names, names)
[17:37:40.203]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:40.203]                   envs[common]]
[17:37:40.203]                 NAMES <- toupper(changed)
[17:37:40.203]                 args <- list()
[17:37:40.203]                 for (kk in seq_along(NAMES)) {
[17:37:40.203]                   name <- changed[[kk]]
[17:37:40.203]                   NAME <- NAMES[[kk]]
[17:37:40.203]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.203]                     next
[17:37:40.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.203]                 }
[17:37:40.203]                 NAMES <- toupper(added)
[17:37:40.203]                 for (kk in seq_along(NAMES)) {
[17:37:40.203]                   name <- added[[kk]]
[17:37:40.203]                   NAME <- NAMES[[kk]]
[17:37:40.203]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.203]                     next
[17:37:40.203]                   args[[name]] <- ""
[17:37:40.203]                 }
[17:37:40.203]                 NAMES <- toupper(removed)
[17:37:40.203]                 for (kk in seq_along(NAMES)) {
[17:37:40.203]                   name <- removed[[kk]]
[17:37:40.203]                   NAME <- NAMES[[kk]]
[17:37:40.203]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.203]                     next
[17:37:40.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.203]                 }
[17:37:40.203]                 if (length(args) > 0) 
[17:37:40.203]                   base::do.call(base::Sys.setenv, args = args)
[17:37:40.203]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:40.203]             }
[17:37:40.203]             else {
[17:37:40.203]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:40.203]             }
[17:37:40.203]             {
[17:37:40.203]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:40.203]                   0L) {
[17:37:40.203]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:40.203]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:40.203]                   base::options(opts)
[17:37:40.203]                 }
[17:37:40.203]                 {
[17:37:40.203]                   {
[17:37:40.203]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:40.203]                     NULL
[17:37:40.203]                   }
[17:37:40.203]                   options(future.plan = NULL)
[17:37:40.203]                   if (is.na(NA_character_)) 
[17:37:40.203]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.203]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:40.203]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:40.203]                     .init = FALSE)
[17:37:40.203]                 }
[17:37:40.203]             }
[17:37:40.203]         }
[17:37:40.203]     })
[17:37:40.203]     if (TRUE) {
[17:37:40.203]         base::sink(type = "output", split = FALSE)
[17:37:40.203]         if (TRUE) {
[17:37:40.203]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:40.203]         }
[17:37:40.203]         else {
[17:37:40.203]             ...future.result["stdout"] <- base::list(NULL)
[17:37:40.203]         }
[17:37:40.203]         base::close(...future.stdout)
[17:37:40.203]         ...future.stdout <- NULL
[17:37:40.203]     }
[17:37:40.203]     ...future.result$conditions <- ...future.conditions
[17:37:40.203]     ...future.result$finished <- base::Sys.time()
[17:37:40.203]     ...future.result
[17:37:40.203] }
[17:37:40.206] Exporting 5 global objects (1.77 KiB) to cluster node #1 ...
[17:37:40.206] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[17:37:40.206] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[17:37:40.207] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[17:37:40.207] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[17:37:40.207] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:37:40.207] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:37:40.208] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:40.208] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:40.208] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:40.209] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:40.209] Exporting 5 global objects (1.77 KiB) to cluster node #1 ... DONE
[17:37:40.209] MultisessionFuture started
[17:37:40.209] - Launch lazy future ... done
[17:37:40.209] run() for ‘MultisessionFuture’ ... done
[17:37:40.210] Created future:
[17:37:40.210] MultisessionFuture:
[17:37:40.210] Label: ‘future_mapply-1’
[17:37:40.210] Expression:
[17:37:40.210] {
[17:37:40.210]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.210]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:40.210]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.210]         on.exit(options(oopts), add = TRUE)
[17:37:40.210]     }
[17:37:40.210]     {
[17:37:40.210]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.210]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:40.210]         do.call(mapply, args = args)
[17:37:40.210]     }
[17:37:40.210] }
[17:37:40.210] Lazy evaluation: FALSE
[17:37:40.210] Asynchronous evaluation: TRUE
[17:37:40.210] Local evaluation: TRUE
[17:37:40.210] Environment: R_GlobalEnv
[17:37:40.210] Capture standard output: TRUE
[17:37:40.210] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:40.210] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:40.210] Packages: <none>
[17:37:40.210] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:40.210] Resolved: FALSE
[17:37:40.210] Value: <not collected>
[17:37:40.210] Conditions captured: <none>
[17:37:40.210] Early signaling: FALSE
[17:37:40.210] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:40.210] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.221] Chunk #1 of 2 ... DONE
[17:37:40.221] Chunk #2 of 2 ...
[17:37:40.221]  - Finding globals in '...' for chunk #2 ...
[17:37:40.221] getGlobalsAndPackages() ...
[17:37:40.221] Searching for globals...
[17:37:40.222] 
[17:37:40.222] Searching for globals ... DONE
[17:37:40.222] - globals: [0] <none>
[17:37:40.222] getGlobalsAndPackages() ... DONE
[17:37:40.222]    + additional globals found: [n=0] 
[17:37:40.222]    + additional namespaces needed: [n=0] 
[17:37:40.222]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:40.222]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:40.222]  - seeds: <none>
[17:37:40.223]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.223] getGlobalsAndPackages() ...
[17:37:40.223] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.223] Resolving globals: FALSE
[17:37:40.223] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:37:40.224] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:37:40.224] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.224] 
[17:37:40.224] getGlobalsAndPackages() ... DONE
[17:37:40.224] run() for ‘Future’ ...
[17:37:40.224] - state: ‘created’
[17:37:40.225] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:40.238] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.238] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:40.238]   - Field: ‘node’
[17:37:40.238]   - Field: ‘label’
[17:37:40.238]   - Field: ‘local’
[17:37:40.238]   - Field: ‘owner’
[17:37:40.238]   - Field: ‘envir’
[17:37:40.238]   - Field: ‘workers’
[17:37:40.238]   - Field: ‘packages’
[17:37:40.239]   - Field: ‘gc’
[17:37:40.239]   - Field: ‘conditions’
[17:37:40.239]   - Field: ‘persistent’
[17:37:40.239]   - Field: ‘expr’
[17:37:40.239]   - Field: ‘uuid’
[17:37:40.239]   - Field: ‘seed’
[17:37:40.239]   - Field: ‘version’
[17:37:40.239]   - Field: ‘result’
[17:37:40.239]   - Field: ‘asynchronous’
[17:37:40.239]   - Field: ‘calls’
[17:37:40.239]   - Field: ‘globals’
[17:37:40.240]   - Field: ‘stdout’
[17:37:40.240]   - Field: ‘earlySignal’
[17:37:40.240]   - Field: ‘lazy’
[17:37:40.240]   - Field: ‘state’
[17:37:40.240] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:40.240] - Launch lazy future ...
[17:37:40.240] Packages needed by the future expression (n = 0): <none>
[17:37:40.240] Packages needed by future strategies (n = 0): <none>
[17:37:40.241] {
[17:37:40.241]     {
[17:37:40.241]         {
[17:37:40.241]             ...future.startTime <- base::Sys.time()
[17:37:40.241]             {
[17:37:40.241]                 {
[17:37:40.241]                   {
[17:37:40.241]                     {
[17:37:40.241]                       base::local({
[17:37:40.241]                         has_future <- base::requireNamespace("future", 
[17:37:40.241]                           quietly = TRUE)
[17:37:40.241]                         if (has_future) {
[17:37:40.241]                           ns <- base::getNamespace("future")
[17:37:40.241]                           version <- ns[[".package"]][["version"]]
[17:37:40.241]                           if (is.null(version)) 
[17:37:40.241]                             version <- utils::packageVersion("future")
[17:37:40.241]                         }
[17:37:40.241]                         else {
[17:37:40.241]                           version <- NULL
[17:37:40.241]                         }
[17:37:40.241]                         if (!has_future || version < "1.8.0") {
[17:37:40.241]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:40.241]                             "", base::R.version$version.string), 
[17:37:40.241]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:40.241]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:40.241]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:40.241]                               "release", "version")], collapse = " "), 
[17:37:40.241]                             hostname = base::Sys.info()[["nodename"]])
[17:37:40.241]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:40.241]                             info)
[17:37:40.241]                           info <- base::paste(info, collapse = "; ")
[17:37:40.241]                           if (!has_future) {
[17:37:40.241]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:40.241]                               info)
[17:37:40.241]                           }
[17:37:40.241]                           else {
[17:37:40.241]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:40.241]                               info, version)
[17:37:40.241]                           }
[17:37:40.241]                           base::stop(msg)
[17:37:40.241]                         }
[17:37:40.241]                       })
[17:37:40.241]                     }
[17:37:40.241]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:40.241]                     base::options(mc.cores = 1L)
[17:37:40.241]                   }
[17:37:40.241]                   ...future.strategy.old <- future::plan("list")
[17:37:40.241]                   options(future.plan = NULL)
[17:37:40.241]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.241]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:40.241]                 }
[17:37:40.241]                 ...future.workdir <- getwd()
[17:37:40.241]             }
[17:37:40.241]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:40.241]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:40.241]         }
[17:37:40.241]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:40.241]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:40.241]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:40.241]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:40.241]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:40.241]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:40.241]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:40.241]             base::names(...future.oldOptions))
[17:37:40.241]     }
[17:37:40.241]     if (FALSE) {
[17:37:40.241]     }
[17:37:40.241]     else {
[17:37:40.241]         if (TRUE) {
[17:37:40.241]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:40.241]                 open = "w")
[17:37:40.241]         }
[17:37:40.241]         else {
[17:37:40.241]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:40.241]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:40.241]         }
[17:37:40.241]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:40.241]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:40.241]             base::sink(type = "output", split = FALSE)
[17:37:40.241]             base::close(...future.stdout)
[17:37:40.241]         }, add = TRUE)
[17:37:40.241]     }
[17:37:40.241]     ...future.frame <- base::sys.nframe()
[17:37:40.241]     ...future.conditions <- base::list()
[17:37:40.241]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:40.241]     if (FALSE) {
[17:37:40.241]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:40.241]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:40.241]     }
[17:37:40.241]     ...future.result <- base::tryCatch({
[17:37:40.241]         base::withCallingHandlers({
[17:37:40.241]             ...future.value <- base::withVisible(base::local({
[17:37:40.241]                 ...future.makeSendCondition <- base::local({
[17:37:40.241]                   sendCondition <- NULL
[17:37:40.241]                   function(frame = 1L) {
[17:37:40.241]                     if (is.function(sendCondition)) 
[17:37:40.241]                       return(sendCondition)
[17:37:40.241]                     ns <- getNamespace("parallel")
[17:37:40.241]                     if (exists("sendData", mode = "function", 
[17:37:40.241]                       envir = ns)) {
[17:37:40.241]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:40.241]                         envir = ns)
[17:37:40.241]                       envir <- sys.frame(frame)
[17:37:40.241]                       master <- NULL
[17:37:40.241]                       while (!identical(envir, .GlobalEnv) && 
[17:37:40.241]                         !identical(envir, emptyenv())) {
[17:37:40.241]                         if (exists("master", mode = "list", envir = envir, 
[17:37:40.241]                           inherits = FALSE)) {
[17:37:40.241]                           master <- get("master", mode = "list", 
[17:37:40.241]                             envir = envir, inherits = FALSE)
[17:37:40.241]                           if (inherits(master, c("SOCKnode", 
[17:37:40.241]                             "SOCK0node"))) {
[17:37:40.241]                             sendCondition <<- function(cond) {
[17:37:40.241]                               data <- list(type = "VALUE", value = cond, 
[17:37:40.241]                                 success = TRUE)
[17:37:40.241]                               parallel_sendData(master, data)
[17:37:40.241]                             }
[17:37:40.241]                             return(sendCondition)
[17:37:40.241]                           }
[17:37:40.241]                         }
[17:37:40.241]                         frame <- frame + 1L
[17:37:40.241]                         envir <- sys.frame(frame)
[17:37:40.241]                       }
[17:37:40.241]                     }
[17:37:40.241]                     sendCondition <<- function(cond) NULL
[17:37:40.241]                   }
[17:37:40.241]                 })
[17:37:40.241]                 withCallingHandlers({
[17:37:40.241]                   {
[17:37:40.241]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.241]                     if (!identical(...future.globals.maxSize.org, 
[17:37:40.241]                       ...future.globals.maxSize)) {
[17:37:40.241]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.241]                       on.exit(options(oopts), add = TRUE)
[17:37:40.241]                     }
[17:37:40.241]                     {
[17:37:40.241]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.241]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:40.241]                         USE.NAMES = FALSE)
[17:37:40.241]                       do.call(mapply, args = args)
[17:37:40.241]                     }
[17:37:40.241]                   }
[17:37:40.241]                 }, immediateCondition = function(cond) {
[17:37:40.241]                   sendCondition <- ...future.makeSendCondition()
[17:37:40.241]                   sendCondition(cond)
[17:37:40.241]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.241]                   {
[17:37:40.241]                     inherits <- base::inherits
[17:37:40.241]                     invokeRestart <- base::invokeRestart
[17:37:40.241]                     is.null <- base::is.null
[17:37:40.241]                     muffled <- FALSE
[17:37:40.241]                     if (inherits(cond, "message")) {
[17:37:40.241]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:40.241]                       if (muffled) 
[17:37:40.241]                         invokeRestart("muffleMessage")
[17:37:40.241]                     }
[17:37:40.241]                     else if (inherits(cond, "warning")) {
[17:37:40.241]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:40.241]                       if (muffled) 
[17:37:40.241]                         invokeRestart("muffleWarning")
[17:37:40.241]                     }
[17:37:40.241]                     else if (inherits(cond, "condition")) {
[17:37:40.241]                       if (!is.null(pattern)) {
[17:37:40.241]                         computeRestarts <- base::computeRestarts
[17:37:40.241]                         grepl <- base::grepl
[17:37:40.241]                         restarts <- computeRestarts(cond)
[17:37:40.241]                         for (restart in restarts) {
[17:37:40.241]                           name <- restart$name
[17:37:40.241]                           if (is.null(name)) 
[17:37:40.241]                             next
[17:37:40.241]                           if (!grepl(pattern, name)) 
[17:37:40.241]                             next
[17:37:40.241]                           invokeRestart(restart)
[17:37:40.241]                           muffled <- TRUE
[17:37:40.241]                           break
[17:37:40.241]                         }
[17:37:40.241]                       }
[17:37:40.241]                     }
[17:37:40.241]                     invisible(muffled)
[17:37:40.241]                   }
[17:37:40.241]                   muffleCondition(cond)
[17:37:40.241]                 })
[17:37:40.241]             }))
[17:37:40.241]             future::FutureResult(value = ...future.value$value, 
[17:37:40.241]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.241]                   ...future.rng), globalenv = if (FALSE) 
[17:37:40.241]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:40.241]                     ...future.globalenv.names))
[17:37:40.241]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:40.241]         }, condition = base::local({
[17:37:40.241]             c <- base::c
[17:37:40.241]             inherits <- base::inherits
[17:37:40.241]             invokeRestart <- base::invokeRestart
[17:37:40.241]             length <- base::length
[17:37:40.241]             list <- base::list
[17:37:40.241]             seq.int <- base::seq.int
[17:37:40.241]             signalCondition <- base::signalCondition
[17:37:40.241]             sys.calls <- base::sys.calls
[17:37:40.241]             `[[` <- base::`[[`
[17:37:40.241]             `+` <- base::`+`
[17:37:40.241]             `<<-` <- base::`<<-`
[17:37:40.241]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:40.241]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:40.241]                   3L)]
[17:37:40.241]             }
[17:37:40.241]             function(cond) {
[17:37:40.241]                 is_error <- inherits(cond, "error")
[17:37:40.241]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:40.241]                   NULL)
[17:37:40.241]                 if (is_error) {
[17:37:40.241]                   sessionInformation <- function() {
[17:37:40.241]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:40.241]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:40.241]                       search = base::search(), system = base::Sys.info())
[17:37:40.241]                   }
[17:37:40.241]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.241]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:40.241]                     cond$call), session = sessionInformation(), 
[17:37:40.241]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:40.241]                   signalCondition(cond)
[17:37:40.241]                 }
[17:37:40.241]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:40.241]                 "immediateCondition"))) {
[17:37:40.241]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:40.241]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.241]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:40.241]                   if (TRUE && !signal) {
[17:37:40.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.241]                     {
[17:37:40.241]                       inherits <- base::inherits
[17:37:40.241]                       invokeRestart <- base::invokeRestart
[17:37:40.241]                       is.null <- base::is.null
[17:37:40.241]                       muffled <- FALSE
[17:37:40.241]                       if (inherits(cond, "message")) {
[17:37:40.241]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.241]                         if (muffled) 
[17:37:40.241]                           invokeRestart("muffleMessage")
[17:37:40.241]                       }
[17:37:40.241]                       else if (inherits(cond, "warning")) {
[17:37:40.241]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.241]                         if (muffled) 
[17:37:40.241]                           invokeRestart("muffleWarning")
[17:37:40.241]                       }
[17:37:40.241]                       else if (inherits(cond, "condition")) {
[17:37:40.241]                         if (!is.null(pattern)) {
[17:37:40.241]                           computeRestarts <- base::computeRestarts
[17:37:40.241]                           grepl <- base::grepl
[17:37:40.241]                           restarts <- computeRestarts(cond)
[17:37:40.241]                           for (restart in restarts) {
[17:37:40.241]                             name <- restart$name
[17:37:40.241]                             if (is.null(name)) 
[17:37:40.241]                               next
[17:37:40.241]                             if (!grepl(pattern, name)) 
[17:37:40.241]                               next
[17:37:40.241]                             invokeRestart(restart)
[17:37:40.241]                             muffled <- TRUE
[17:37:40.241]                             break
[17:37:40.241]                           }
[17:37:40.241]                         }
[17:37:40.241]                       }
[17:37:40.241]                       invisible(muffled)
[17:37:40.241]                     }
[17:37:40.241]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.241]                   }
[17:37:40.241]                 }
[17:37:40.241]                 else {
[17:37:40.241]                   if (TRUE) {
[17:37:40.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.241]                     {
[17:37:40.241]                       inherits <- base::inherits
[17:37:40.241]                       invokeRestart <- base::invokeRestart
[17:37:40.241]                       is.null <- base::is.null
[17:37:40.241]                       muffled <- FALSE
[17:37:40.241]                       if (inherits(cond, "message")) {
[17:37:40.241]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.241]                         if (muffled) 
[17:37:40.241]                           invokeRestart("muffleMessage")
[17:37:40.241]                       }
[17:37:40.241]                       else if (inherits(cond, "warning")) {
[17:37:40.241]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.241]                         if (muffled) 
[17:37:40.241]                           invokeRestart("muffleWarning")
[17:37:40.241]                       }
[17:37:40.241]                       else if (inherits(cond, "condition")) {
[17:37:40.241]                         if (!is.null(pattern)) {
[17:37:40.241]                           computeRestarts <- base::computeRestarts
[17:37:40.241]                           grepl <- base::grepl
[17:37:40.241]                           restarts <- computeRestarts(cond)
[17:37:40.241]                           for (restart in restarts) {
[17:37:40.241]                             name <- restart$name
[17:37:40.241]                             if (is.null(name)) 
[17:37:40.241]                               next
[17:37:40.241]                             if (!grepl(pattern, name)) 
[17:37:40.241]                               next
[17:37:40.241]                             invokeRestart(restart)
[17:37:40.241]                             muffled <- TRUE
[17:37:40.241]                             break
[17:37:40.241]                           }
[17:37:40.241]                         }
[17:37:40.241]                       }
[17:37:40.241]                       invisible(muffled)
[17:37:40.241]                     }
[17:37:40.241]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.241]                   }
[17:37:40.241]                 }
[17:37:40.241]             }
[17:37:40.241]         }))
[17:37:40.241]     }, error = function(ex) {
[17:37:40.241]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:40.241]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.241]                 ...future.rng), started = ...future.startTime, 
[17:37:40.241]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:40.241]             version = "1.8"), class = "FutureResult")
[17:37:40.241]     }, finally = {
[17:37:40.241]         if (!identical(...future.workdir, getwd())) 
[17:37:40.241]             setwd(...future.workdir)
[17:37:40.241]         {
[17:37:40.241]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:40.241]                 ...future.oldOptions$nwarnings <- NULL
[17:37:40.241]             }
[17:37:40.241]             base::options(...future.oldOptions)
[17:37:40.241]             if (.Platform$OS.type == "windows") {
[17:37:40.241]                 old_names <- names(...future.oldEnvVars)
[17:37:40.241]                 envs <- base::Sys.getenv()
[17:37:40.241]                 names <- names(envs)
[17:37:40.241]                 common <- intersect(names, old_names)
[17:37:40.241]                 added <- setdiff(names, old_names)
[17:37:40.241]                 removed <- setdiff(old_names, names)
[17:37:40.241]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:40.241]                   envs[common]]
[17:37:40.241]                 NAMES <- toupper(changed)
[17:37:40.241]                 args <- list()
[17:37:40.241]                 for (kk in seq_along(NAMES)) {
[17:37:40.241]                   name <- changed[[kk]]
[17:37:40.241]                   NAME <- NAMES[[kk]]
[17:37:40.241]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.241]                     next
[17:37:40.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.241]                 }
[17:37:40.241]                 NAMES <- toupper(added)
[17:37:40.241]                 for (kk in seq_along(NAMES)) {
[17:37:40.241]                   name <- added[[kk]]
[17:37:40.241]                   NAME <- NAMES[[kk]]
[17:37:40.241]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.241]                     next
[17:37:40.241]                   args[[name]] <- ""
[17:37:40.241]                 }
[17:37:40.241]                 NAMES <- toupper(removed)
[17:37:40.241]                 for (kk in seq_along(NAMES)) {
[17:37:40.241]                   name <- removed[[kk]]
[17:37:40.241]                   NAME <- NAMES[[kk]]
[17:37:40.241]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.241]                     next
[17:37:40.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.241]                 }
[17:37:40.241]                 if (length(args) > 0) 
[17:37:40.241]                   base::do.call(base::Sys.setenv, args = args)
[17:37:40.241]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:40.241]             }
[17:37:40.241]             else {
[17:37:40.241]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:40.241]             }
[17:37:40.241]             {
[17:37:40.241]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:40.241]                   0L) {
[17:37:40.241]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:40.241]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:40.241]                   base::options(opts)
[17:37:40.241]                 }
[17:37:40.241]                 {
[17:37:40.241]                   {
[17:37:40.241]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:40.241]                     NULL
[17:37:40.241]                   }
[17:37:40.241]                   options(future.plan = NULL)
[17:37:40.241]                   if (is.na(NA_character_)) 
[17:37:40.241]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.241]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:40.241]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:40.241]                     .init = FALSE)
[17:37:40.241]                 }
[17:37:40.241]             }
[17:37:40.241]         }
[17:37:40.241]     })
[17:37:40.241]     if (TRUE) {
[17:37:40.241]         base::sink(type = "output", split = FALSE)
[17:37:40.241]         if (TRUE) {
[17:37:40.241]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:40.241]         }
[17:37:40.241]         else {
[17:37:40.241]             ...future.result["stdout"] <- base::list(NULL)
[17:37:40.241]         }
[17:37:40.241]         base::close(...future.stdout)
[17:37:40.241]         ...future.stdout <- NULL
[17:37:40.241]     }
[17:37:40.241]     ...future.result$conditions <- ...future.conditions
[17:37:40.241]     ...future.result$finished <- base::Sys.time()
[17:37:40.241]     ...future.result
[17:37:40.241] }
[17:37:40.243] Exporting 5 global objects (1.77 KiB) to cluster node #2 ...
[17:37:40.244] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[17:37:40.244] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[17:37:40.244] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[17:37:40.244] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[17:37:40.245] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:37:40.245] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:37:40.245] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:37:40.245] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:37:40.245] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:37:40.246] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:37:40.246] Exporting 5 global objects (1.77 KiB) to cluster node #2 ... DONE
[17:37:40.246] MultisessionFuture started
[17:37:40.246] - Launch lazy future ... done
[17:37:40.246] run() for ‘MultisessionFuture’ ... done
[17:37:40.247] Created future:
[17:37:40.247] MultisessionFuture:
[17:37:40.247] Label: ‘future_mapply-2’
[17:37:40.247] Expression:
[17:37:40.247] {
[17:37:40.247]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.247]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:40.247]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.247]         on.exit(options(oopts), add = TRUE)
[17:37:40.247]     }
[17:37:40.247]     {
[17:37:40.247]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.247]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:40.247]         do.call(mapply, args = args)
[17:37:40.247]     }
[17:37:40.247] }
[17:37:40.247] Lazy evaluation: FALSE
[17:37:40.247] Asynchronous evaluation: TRUE
[17:37:40.247] Local evaluation: TRUE
[17:37:40.247] Environment: R_GlobalEnv
[17:37:40.247] Capture standard output: TRUE
[17:37:40.247] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:40.247] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:40.247] Packages: <none>
[17:37:40.247] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:40.247] Resolved: FALSE
[17:37:40.247] Value: <not collected>
[17:37:40.247] Conditions captured: <none>
[17:37:40.247] Early signaling: FALSE
[17:37:40.247] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:40.247] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.258] Chunk #2 of 2 ... DONE
[17:37:40.258] Launching 2 futures (chunks) ... DONE
[17:37:40.258] Resolving 2 futures (chunks) ...
[17:37:40.258] resolve() on list ...
[17:37:40.258]  recursive: 0
[17:37:40.259]  length: 2
[17:37:40.259] 
[17:37:40.259] receiveMessageFromWorker() for ClusterFuture ...
[17:37:40.259] - Validating connection of MultisessionFuture
[17:37:40.259] - received message: FutureResult
[17:37:40.260] - Received FutureResult
[17:37:40.260] - Erased future from FutureRegistry
[17:37:40.260] result() for ClusterFuture ...
[17:37:40.260] - result already collected: FutureResult
[17:37:40.260] result() for ClusterFuture ... done
[17:37:40.260] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:40.260] Future #1
[17:37:40.260] result() for ClusterFuture ...
[17:37:40.260] - result already collected: FutureResult
[17:37:40.260] result() for ClusterFuture ... done
[17:37:40.261] result() for ClusterFuture ...
[17:37:40.261] - result already collected: FutureResult
[17:37:40.261] result() for ClusterFuture ... done
[17:37:40.261] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:37:40.261] - nx: 2
[17:37:40.261] - relay: TRUE
[17:37:40.261] - stdout: TRUE
[17:37:40.261] - signal: TRUE
[17:37:40.261] - resignal: FALSE
[17:37:40.261] - force: TRUE
[17:37:40.261] - relayed: [n=2] FALSE, FALSE
[17:37:40.261] - queued futures: [n=2] FALSE, FALSE
[17:37:40.262]  - until=1
[17:37:40.262]  - relaying element #1
[17:37:40.262] result() for ClusterFuture ...
[17:37:40.262] - result already collected: FutureResult
[17:37:40.262] result() for ClusterFuture ... done
[17:37:40.262] result() for ClusterFuture ...
[17:37:40.262] - result already collected: FutureResult
[17:37:40.262] result() for ClusterFuture ... done
[17:37:40.262] result() for ClusterFuture ...
[17:37:40.262] - result already collected: FutureResult
[17:37:40.262] result() for ClusterFuture ... done
[17:37:40.262] result() for ClusterFuture ...
[17:37:40.263] - result already collected: FutureResult
[17:37:40.263] result() for ClusterFuture ... done
[17:37:40.263] - relayed: [n=2] TRUE, FALSE
[17:37:40.263] - queued futures: [n=2] TRUE, FALSE
[17:37:40.263] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:37:40.263]  length: 1 (resolved future 1)
[17:37:40.290] receiveMessageFromWorker() for ClusterFuture ...
[17:37:40.290] - Validating connection of MultisessionFuture
[17:37:40.290] - received message: FutureResult
[17:37:40.290] - Received FutureResult
[17:37:40.290] - Erased future from FutureRegistry
[17:37:40.290] result() for ClusterFuture ...
[17:37:40.291] - result already collected: FutureResult
[17:37:40.291] result() for ClusterFuture ... done
[17:37:40.291] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:40.291] Future #2
[17:37:40.291] result() for ClusterFuture ...
[17:37:40.291] - result already collected: FutureResult
[17:37:40.291] result() for ClusterFuture ... done
[17:37:40.291] result() for ClusterFuture ...
[17:37:40.291] - result already collected: FutureResult
[17:37:40.291] result() for ClusterFuture ... done
[17:37:40.292] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:37:40.292] - nx: 2
[17:37:40.292] - relay: TRUE
[17:37:40.292] - stdout: TRUE
[17:37:40.292] - signal: TRUE
[17:37:40.292] - resignal: FALSE
[17:37:40.292] - force: TRUE
[17:37:40.292] - relayed: [n=2] TRUE, FALSE
[17:37:40.292] - queued futures: [n=2] TRUE, FALSE
[17:37:40.292]  - until=2
[17:37:40.292]  - relaying element #2
[17:37:40.292] result() for ClusterFuture ...
[17:37:40.293] - result already collected: FutureResult
[17:37:40.293] result() for ClusterFuture ... done
[17:37:40.293] result() for ClusterFuture ...
[17:37:40.293] - result already collected: FutureResult
[17:37:40.293] result() for ClusterFuture ... done
[17:37:40.293] result() for ClusterFuture ...
[17:37:40.293] - result already collected: FutureResult
[17:37:40.293] result() for ClusterFuture ... done
[17:37:40.293] result() for ClusterFuture ...
[17:37:40.293] - result already collected: FutureResult
[17:37:40.293] result() for ClusterFuture ... done
[17:37:40.294] - relayed: [n=2] TRUE, TRUE
[17:37:40.294] - queued futures: [n=2] TRUE, TRUE
[17:37:40.294] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:37:40.294]  length: 0 (resolved future 2)
[17:37:40.294] Relaying remaining futures
[17:37:40.294] signalConditionsASAP(NULL, pos=0) ...
[17:37:40.294] - nx: 2
[17:37:40.294] - relay: TRUE
[17:37:40.294] - stdout: TRUE
[17:37:40.294] - signal: TRUE
[17:37:40.294] - resignal: FALSE
[17:37:40.294] - force: TRUE
[17:37:40.294] - relayed: [n=2] TRUE, TRUE
[17:37:40.295] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:40.295] - relayed: [n=2] TRUE, TRUE
[17:37:40.295] - queued futures: [n=2] TRUE, TRUE
[17:37:40.295] signalConditionsASAP(NULL, pos=0) ... done
[17:37:40.295] resolve() on list ... DONE
[17:37:40.295] result() for ClusterFuture ...
[17:37:40.295] - result already collected: FutureResult
[17:37:40.295] result() for ClusterFuture ... done
[17:37:40.295] result() for ClusterFuture ...
[17:37:40.295] - result already collected: FutureResult
[17:37:40.295] result() for ClusterFuture ... done
[17:37:40.296] result() for ClusterFuture ...
[17:37:40.296] - result already collected: FutureResult
[17:37:40.296] result() for ClusterFuture ... done
[17:37:40.296] result() for ClusterFuture ...
[17:37:40.296] - result already collected: FutureResult
[17:37:40.296] result() for ClusterFuture ... done
[17:37:40.296]  - Number of value chunks collected: 2
[17:37:40.296] Resolving 2 futures (chunks) ... DONE
[17:37:40.296] Reducing values from 2 chunks ...
[17:37:40.296]  - Number of values collected after concatenation: 2
[17:37:40.297]  - Number of values expected: 2
[17:37:40.297] Reducing values from 2 chunks ... DONE
[17:37:40.297] future_mapply() ... DONE
[17:37:40.297] future_mapply() ...
[17:37:40.297] Generating random seeds ...
[17:37:40.297] Generating random seed streams for 2 elements ...
[17:37:40.297] Generating random seed streams for 2 elements ... DONE
[17:37:40.298] Generating random seeds ... DONE
[17:37:40.298] Will set RNG state on exit: 10407, 183615021, -605875298, -1847219102, -1627949217, 862464991, 1510844200
[17:37:40.302] Number of chunks: 2
[17:37:40.302] getGlobalsAndPackagesXApply() ...
[17:37:40.302]  - future.globals: TRUE
[17:37:40.302] getGlobalsAndPackages() ...
[17:37:40.302] Searching for globals...
[17:37:40.304] - globals found: [1] ‘FUN’
[17:37:40.304] Searching for globals ... DONE
[17:37:40.304] Resolving globals: FALSE
[17:37:40.304] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:37:40.304] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:37:40.305] - globals: [1] ‘FUN’
[17:37:40.305] 
[17:37:40.305] getGlobalsAndPackages() ... DONE
[17:37:40.305]  - globals found/used: [n=1] ‘FUN’
[17:37:40.305]  - needed namespaces: [n=0] 
[17:37:40.305] Finding globals ... DONE
[17:37:40.305] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:40.305] List of 2
[17:37:40.305]  $ ...future.FUN:function (x, y)  
[17:37:40.305]  $ MoreArgs     :List of 1
[17:37:40.305]   ..$ y: int [1:2] 3 4
[17:37:40.305]  - attr(*, "where")=List of 2
[17:37:40.305]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:40.305]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:40.305]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:40.305]  - attr(*, "resolved")= logi FALSE
[17:37:40.305]  - attr(*, "total_size")= num NA
[17:37:40.308] Packages to be attached in all futures: [n=0] 
[17:37:40.308] getGlobalsAndPackagesXApply() ... DONE
[17:37:40.308] Number of futures (= number of chunks): 2
[17:37:40.308] Launching 2 futures (chunks) ...
[17:37:40.309] Chunk #1 of 2 ...
[17:37:40.309]  - Finding globals in '...' for chunk #1 ...
[17:37:40.309] getGlobalsAndPackages() ...
[17:37:40.309] Searching for globals...
[17:37:40.309] 
[17:37:40.309] Searching for globals ... DONE
[17:37:40.309] - globals: [0] <none>
[17:37:40.309] getGlobalsAndPackages() ... DONE
[17:37:40.309]    + additional globals found: [n=0] 
[17:37:40.310]    + additional namespaces needed: [n=0] 
[17:37:40.310]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:40.310]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:40.310]  - seeds: [1] <seeds>
[17:37:40.310]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.310] getGlobalsAndPackages() ...
[17:37:40.310] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.310] Resolving globals: FALSE
[17:37:40.311] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[17:37:40.311] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:37:40.311] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.311] 
[17:37:40.312] getGlobalsAndPackages() ... DONE
[17:37:40.312] run() for ‘Future’ ...
[17:37:40.312] - state: ‘created’
[17:37:40.312] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:40.326] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.326] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:40.326]   - Field: ‘node’
[17:37:40.327]   - Field: ‘label’
[17:37:40.327]   - Field: ‘local’
[17:37:40.327]   - Field: ‘owner’
[17:37:40.327]   - Field: ‘envir’
[17:37:40.327]   - Field: ‘workers’
[17:37:40.327]   - Field: ‘packages’
[17:37:40.327]   - Field: ‘gc’
[17:37:40.327]   - Field: ‘conditions’
[17:37:40.327]   - Field: ‘persistent’
[17:37:40.327]   - Field: ‘expr’
[17:37:40.327]   - Field: ‘uuid’
[17:37:40.328]   - Field: ‘seed’
[17:37:40.328]   - Field: ‘version’
[17:37:40.328]   - Field: ‘result’
[17:37:40.328]   - Field: ‘asynchronous’
[17:37:40.328]   - Field: ‘calls’
[17:37:40.328]   - Field: ‘globals’
[17:37:40.328]   - Field: ‘stdout’
[17:37:40.328]   - Field: ‘earlySignal’
[17:37:40.328]   - Field: ‘lazy’
[17:37:40.328]   - Field: ‘state’
[17:37:40.329] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:40.329] - Launch lazy future ...
[17:37:40.329] Packages needed by the future expression (n = 0): <none>
[17:37:40.329] Packages needed by future strategies (n = 0): <none>
[17:37:40.329] {
[17:37:40.329]     {
[17:37:40.329]         {
[17:37:40.329]             ...future.startTime <- base::Sys.time()
[17:37:40.329]             {
[17:37:40.329]                 {
[17:37:40.329]                   {
[17:37:40.329]                     {
[17:37:40.329]                       base::local({
[17:37:40.329]                         has_future <- base::requireNamespace("future", 
[17:37:40.329]                           quietly = TRUE)
[17:37:40.329]                         if (has_future) {
[17:37:40.329]                           ns <- base::getNamespace("future")
[17:37:40.329]                           version <- ns[[".package"]][["version"]]
[17:37:40.329]                           if (is.null(version)) 
[17:37:40.329]                             version <- utils::packageVersion("future")
[17:37:40.329]                         }
[17:37:40.329]                         else {
[17:37:40.329]                           version <- NULL
[17:37:40.329]                         }
[17:37:40.329]                         if (!has_future || version < "1.8.0") {
[17:37:40.329]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:40.329]                             "", base::R.version$version.string), 
[17:37:40.329]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:40.329]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:40.329]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:40.329]                               "release", "version")], collapse = " "), 
[17:37:40.329]                             hostname = base::Sys.info()[["nodename"]])
[17:37:40.329]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:40.329]                             info)
[17:37:40.329]                           info <- base::paste(info, collapse = "; ")
[17:37:40.329]                           if (!has_future) {
[17:37:40.329]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:40.329]                               info)
[17:37:40.329]                           }
[17:37:40.329]                           else {
[17:37:40.329]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:40.329]                               info, version)
[17:37:40.329]                           }
[17:37:40.329]                           base::stop(msg)
[17:37:40.329]                         }
[17:37:40.329]                       })
[17:37:40.329]                     }
[17:37:40.329]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:40.329]                     base::options(mc.cores = 1L)
[17:37:40.329]                   }
[17:37:40.329]                   ...future.strategy.old <- future::plan("list")
[17:37:40.329]                   options(future.plan = NULL)
[17:37:40.329]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.329]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:40.329]                 }
[17:37:40.329]                 ...future.workdir <- getwd()
[17:37:40.329]             }
[17:37:40.329]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:40.329]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:40.329]         }
[17:37:40.329]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:40.329]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:40.329]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:40.329]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:40.329]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:40.329]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:40.329]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:40.329]             base::names(...future.oldOptions))
[17:37:40.329]     }
[17:37:40.329]     if (FALSE) {
[17:37:40.329]     }
[17:37:40.329]     else {
[17:37:40.329]         if (TRUE) {
[17:37:40.329]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:40.329]                 open = "w")
[17:37:40.329]         }
[17:37:40.329]         else {
[17:37:40.329]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:40.329]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:40.329]         }
[17:37:40.329]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:40.329]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:40.329]             base::sink(type = "output", split = FALSE)
[17:37:40.329]             base::close(...future.stdout)
[17:37:40.329]         }, add = TRUE)
[17:37:40.329]     }
[17:37:40.329]     ...future.frame <- base::sys.nframe()
[17:37:40.329]     ...future.conditions <- base::list()
[17:37:40.329]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:40.329]     if (FALSE) {
[17:37:40.329]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:40.329]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:40.329]     }
[17:37:40.329]     ...future.result <- base::tryCatch({
[17:37:40.329]         base::withCallingHandlers({
[17:37:40.329]             ...future.value <- base::withVisible(base::local({
[17:37:40.329]                 ...future.makeSendCondition <- base::local({
[17:37:40.329]                   sendCondition <- NULL
[17:37:40.329]                   function(frame = 1L) {
[17:37:40.329]                     if (is.function(sendCondition)) 
[17:37:40.329]                       return(sendCondition)
[17:37:40.329]                     ns <- getNamespace("parallel")
[17:37:40.329]                     if (exists("sendData", mode = "function", 
[17:37:40.329]                       envir = ns)) {
[17:37:40.329]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:40.329]                         envir = ns)
[17:37:40.329]                       envir <- sys.frame(frame)
[17:37:40.329]                       master <- NULL
[17:37:40.329]                       while (!identical(envir, .GlobalEnv) && 
[17:37:40.329]                         !identical(envir, emptyenv())) {
[17:37:40.329]                         if (exists("master", mode = "list", envir = envir, 
[17:37:40.329]                           inherits = FALSE)) {
[17:37:40.329]                           master <- get("master", mode = "list", 
[17:37:40.329]                             envir = envir, inherits = FALSE)
[17:37:40.329]                           if (inherits(master, c("SOCKnode", 
[17:37:40.329]                             "SOCK0node"))) {
[17:37:40.329]                             sendCondition <<- function(cond) {
[17:37:40.329]                               data <- list(type = "VALUE", value = cond, 
[17:37:40.329]                                 success = TRUE)
[17:37:40.329]                               parallel_sendData(master, data)
[17:37:40.329]                             }
[17:37:40.329]                             return(sendCondition)
[17:37:40.329]                           }
[17:37:40.329]                         }
[17:37:40.329]                         frame <- frame + 1L
[17:37:40.329]                         envir <- sys.frame(frame)
[17:37:40.329]                       }
[17:37:40.329]                     }
[17:37:40.329]                     sendCondition <<- function(cond) NULL
[17:37:40.329]                   }
[17:37:40.329]                 })
[17:37:40.329]                 withCallingHandlers({
[17:37:40.329]                   {
[17:37:40.329]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.329]                     if (!identical(...future.globals.maxSize.org, 
[17:37:40.329]                       ...future.globals.maxSize)) {
[17:37:40.329]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.329]                       on.exit(options(oopts), add = TRUE)
[17:37:40.329]                     }
[17:37:40.329]                     {
[17:37:40.329]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:37:40.329]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:37:40.329]                           envir = globalenv(), inherits = FALSE)
[17:37:40.329]                         ...future.FUN(...)
[17:37:40.329]                       }
[17:37:40.329]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:37:40.329]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:37:40.329]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:40.329]                         USE.NAMES = FALSE)
[17:37:40.329]                       do.call(mapply, args = args)
[17:37:40.329]                     }
[17:37:40.329]                   }
[17:37:40.329]                 }, immediateCondition = function(cond) {
[17:37:40.329]                   sendCondition <- ...future.makeSendCondition()
[17:37:40.329]                   sendCondition(cond)
[17:37:40.329]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.329]                   {
[17:37:40.329]                     inherits <- base::inherits
[17:37:40.329]                     invokeRestart <- base::invokeRestart
[17:37:40.329]                     is.null <- base::is.null
[17:37:40.329]                     muffled <- FALSE
[17:37:40.329]                     if (inherits(cond, "message")) {
[17:37:40.329]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:40.329]                       if (muffled) 
[17:37:40.329]                         invokeRestart("muffleMessage")
[17:37:40.329]                     }
[17:37:40.329]                     else if (inherits(cond, "warning")) {
[17:37:40.329]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:40.329]                       if (muffled) 
[17:37:40.329]                         invokeRestart("muffleWarning")
[17:37:40.329]                     }
[17:37:40.329]                     else if (inherits(cond, "condition")) {
[17:37:40.329]                       if (!is.null(pattern)) {
[17:37:40.329]                         computeRestarts <- base::computeRestarts
[17:37:40.329]                         grepl <- base::grepl
[17:37:40.329]                         restarts <- computeRestarts(cond)
[17:37:40.329]                         for (restart in restarts) {
[17:37:40.329]                           name <- restart$name
[17:37:40.329]                           if (is.null(name)) 
[17:37:40.329]                             next
[17:37:40.329]                           if (!grepl(pattern, name)) 
[17:37:40.329]                             next
[17:37:40.329]                           invokeRestart(restart)
[17:37:40.329]                           muffled <- TRUE
[17:37:40.329]                           break
[17:37:40.329]                         }
[17:37:40.329]                       }
[17:37:40.329]                     }
[17:37:40.329]                     invisible(muffled)
[17:37:40.329]                   }
[17:37:40.329]                   muffleCondition(cond)
[17:37:40.329]                 })
[17:37:40.329]             }))
[17:37:40.329]             future::FutureResult(value = ...future.value$value, 
[17:37:40.329]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.329]                   ...future.rng), globalenv = if (FALSE) 
[17:37:40.329]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:40.329]                     ...future.globalenv.names))
[17:37:40.329]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:40.329]         }, condition = base::local({
[17:37:40.329]             c <- base::c
[17:37:40.329]             inherits <- base::inherits
[17:37:40.329]             invokeRestart <- base::invokeRestart
[17:37:40.329]             length <- base::length
[17:37:40.329]             list <- base::list
[17:37:40.329]             seq.int <- base::seq.int
[17:37:40.329]             signalCondition <- base::signalCondition
[17:37:40.329]             sys.calls <- base::sys.calls
[17:37:40.329]             `[[` <- base::`[[`
[17:37:40.329]             `+` <- base::`+`
[17:37:40.329]             `<<-` <- base::`<<-`
[17:37:40.329]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:40.329]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:40.329]                   3L)]
[17:37:40.329]             }
[17:37:40.329]             function(cond) {
[17:37:40.329]                 is_error <- inherits(cond, "error")
[17:37:40.329]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:40.329]                   NULL)
[17:37:40.329]                 if (is_error) {
[17:37:40.329]                   sessionInformation <- function() {
[17:37:40.329]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:40.329]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:40.329]                       search = base::search(), system = base::Sys.info())
[17:37:40.329]                   }
[17:37:40.329]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.329]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:40.329]                     cond$call), session = sessionInformation(), 
[17:37:40.329]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:40.329]                   signalCondition(cond)
[17:37:40.329]                 }
[17:37:40.329]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:40.329]                 "immediateCondition"))) {
[17:37:40.329]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:40.329]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.329]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:40.329]                   if (TRUE && !signal) {
[17:37:40.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.329]                     {
[17:37:40.329]                       inherits <- base::inherits
[17:37:40.329]                       invokeRestart <- base::invokeRestart
[17:37:40.329]                       is.null <- base::is.null
[17:37:40.329]                       muffled <- FALSE
[17:37:40.329]                       if (inherits(cond, "message")) {
[17:37:40.329]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.329]                         if (muffled) 
[17:37:40.329]                           invokeRestart("muffleMessage")
[17:37:40.329]                       }
[17:37:40.329]                       else if (inherits(cond, "warning")) {
[17:37:40.329]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.329]                         if (muffled) 
[17:37:40.329]                           invokeRestart("muffleWarning")
[17:37:40.329]                       }
[17:37:40.329]                       else if (inherits(cond, "condition")) {
[17:37:40.329]                         if (!is.null(pattern)) {
[17:37:40.329]                           computeRestarts <- base::computeRestarts
[17:37:40.329]                           grepl <- base::grepl
[17:37:40.329]                           restarts <- computeRestarts(cond)
[17:37:40.329]                           for (restart in restarts) {
[17:37:40.329]                             name <- restart$name
[17:37:40.329]                             if (is.null(name)) 
[17:37:40.329]                               next
[17:37:40.329]                             if (!grepl(pattern, name)) 
[17:37:40.329]                               next
[17:37:40.329]                             invokeRestart(restart)
[17:37:40.329]                             muffled <- TRUE
[17:37:40.329]                             break
[17:37:40.329]                           }
[17:37:40.329]                         }
[17:37:40.329]                       }
[17:37:40.329]                       invisible(muffled)
[17:37:40.329]                     }
[17:37:40.329]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.329]                   }
[17:37:40.329]                 }
[17:37:40.329]                 else {
[17:37:40.329]                   if (TRUE) {
[17:37:40.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.329]                     {
[17:37:40.329]                       inherits <- base::inherits
[17:37:40.329]                       invokeRestart <- base::invokeRestart
[17:37:40.329]                       is.null <- base::is.null
[17:37:40.329]                       muffled <- FALSE
[17:37:40.329]                       if (inherits(cond, "message")) {
[17:37:40.329]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.329]                         if (muffled) 
[17:37:40.329]                           invokeRestart("muffleMessage")
[17:37:40.329]                       }
[17:37:40.329]                       else if (inherits(cond, "warning")) {
[17:37:40.329]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.329]                         if (muffled) 
[17:37:40.329]                           invokeRestart("muffleWarning")
[17:37:40.329]                       }
[17:37:40.329]                       else if (inherits(cond, "condition")) {
[17:37:40.329]                         if (!is.null(pattern)) {
[17:37:40.329]                           computeRestarts <- base::computeRestarts
[17:37:40.329]                           grepl <- base::grepl
[17:37:40.329]                           restarts <- computeRestarts(cond)
[17:37:40.329]                           for (restart in restarts) {
[17:37:40.329]                             name <- restart$name
[17:37:40.329]                             if (is.null(name)) 
[17:37:40.329]                               next
[17:37:40.329]                             if (!grepl(pattern, name)) 
[17:37:40.329]                               next
[17:37:40.329]                             invokeRestart(restart)
[17:37:40.329]                             muffled <- TRUE
[17:37:40.329]                             break
[17:37:40.329]                           }
[17:37:40.329]                         }
[17:37:40.329]                       }
[17:37:40.329]                       invisible(muffled)
[17:37:40.329]                     }
[17:37:40.329]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.329]                   }
[17:37:40.329]                 }
[17:37:40.329]             }
[17:37:40.329]         }))
[17:37:40.329]     }, error = function(ex) {
[17:37:40.329]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:40.329]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.329]                 ...future.rng), started = ...future.startTime, 
[17:37:40.329]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:40.329]             version = "1.8"), class = "FutureResult")
[17:37:40.329]     }, finally = {
[17:37:40.329]         if (!identical(...future.workdir, getwd())) 
[17:37:40.329]             setwd(...future.workdir)
[17:37:40.329]         {
[17:37:40.329]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:40.329]                 ...future.oldOptions$nwarnings <- NULL
[17:37:40.329]             }
[17:37:40.329]             base::options(...future.oldOptions)
[17:37:40.329]             if (.Platform$OS.type == "windows") {
[17:37:40.329]                 old_names <- names(...future.oldEnvVars)
[17:37:40.329]                 envs <- base::Sys.getenv()
[17:37:40.329]                 names <- names(envs)
[17:37:40.329]                 common <- intersect(names, old_names)
[17:37:40.329]                 added <- setdiff(names, old_names)
[17:37:40.329]                 removed <- setdiff(old_names, names)
[17:37:40.329]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:40.329]                   envs[common]]
[17:37:40.329]                 NAMES <- toupper(changed)
[17:37:40.329]                 args <- list()
[17:37:40.329]                 for (kk in seq_along(NAMES)) {
[17:37:40.329]                   name <- changed[[kk]]
[17:37:40.329]                   NAME <- NAMES[[kk]]
[17:37:40.329]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.329]                     next
[17:37:40.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.329]                 }
[17:37:40.329]                 NAMES <- toupper(added)
[17:37:40.329]                 for (kk in seq_along(NAMES)) {
[17:37:40.329]                   name <- added[[kk]]
[17:37:40.329]                   NAME <- NAMES[[kk]]
[17:37:40.329]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.329]                     next
[17:37:40.329]                   args[[name]] <- ""
[17:37:40.329]                 }
[17:37:40.329]                 NAMES <- toupper(removed)
[17:37:40.329]                 for (kk in seq_along(NAMES)) {
[17:37:40.329]                   name <- removed[[kk]]
[17:37:40.329]                   NAME <- NAMES[[kk]]
[17:37:40.329]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.329]                     next
[17:37:40.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.329]                 }
[17:37:40.329]                 if (length(args) > 0) 
[17:37:40.329]                   base::do.call(base::Sys.setenv, args = args)
[17:37:40.329]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:40.329]             }
[17:37:40.329]             else {
[17:37:40.329]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:40.329]             }
[17:37:40.329]             {
[17:37:40.329]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:40.329]                   0L) {
[17:37:40.329]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:40.329]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:40.329]                   base::options(opts)
[17:37:40.329]                 }
[17:37:40.329]                 {
[17:37:40.329]                   {
[17:37:40.329]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:40.329]                     NULL
[17:37:40.329]                   }
[17:37:40.329]                   options(future.plan = NULL)
[17:37:40.329]                   if (is.na(NA_character_)) 
[17:37:40.329]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.329]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:40.329]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:40.329]                     .init = FALSE)
[17:37:40.329]                 }
[17:37:40.329]             }
[17:37:40.329]         }
[17:37:40.329]     })
[17:37:40.329]     if (TRUE) {
[17:37:40.329]         base::sink(type = "output", split = FALSE)
[17:37:40.329]         if (TRUE) {
[17:37:40.329]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:40.329]         }
[17:37:40.329]         else {
[17:37:40.329]             ...future.result["stdout"] <- base::list(NULL)
[17:37:40.329]         }
[17:37:40.329]         base::close(...future.stdout)
[17:37:40.329]         ...future.stdout <- NULL
[17:37:40.329]     }
[17:37:40.329]     ...future.result$conditions <- ...future.conditions
[17:37:40.329]     ...future.result$finished <- base::Sys.time()
[17:37:40.329]     ...future.result
[17:37:40.329] }
[17:37:40.332] Exporting 5 global objects (1.85 KiB) to cluster node #1 ...
[17:37:40.332] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[17:37:40.333] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[17:37:40.333] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[17:37:40.333] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[17:37:40.333] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:37:40.334] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:37:40.334] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[17:37:40.334] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[17:37:40.334] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:40.334] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:40.335] Exporting 5 global objects (1.85 KiB) to cluster node #1 ... DONE
[17:37:40.335] MultisessionFuture started
[17:37:40.335] - Launch lazy future ... done
[17:37:40.335] run() for ‘MultisessionFuture’ ... done
[17:37:40.335] Created future:
[17:37:40.335] MultisessionFuture:
[17:37:40.335] Label: ‘future_mapply-1’
[17:37:40.335] Expression:
[17:37:40.335] {
[17:37:40.335]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.335]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:40.335]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.335]         on.exit(options(oopts), add = TRUE)
[17:37:40.335]     }
[17:37:40.335]     {
[17:37:40.335]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:37:40.335]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:37:40.335]                 inherits = FALSE)
[17:37:40.335]             ...future.FUN(...)
[17:37:40.335]         }
[17:37:40.335]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:37:40.335]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:37:40.335]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:40.335]         do.call(mapply, args = args)
[17:37:40.335]     }
[17:37:40.335] }
[17:37:40.335] Lazy evaluation: FALSE
[17:37:40.335] Asynchronous evaluation: TRUE
[17:37:40.335] Local evaluation: TRUE
[17:37:40.335] Environment: R_GlobalEnv
[17:37:40.335] Capture standard output: TRUE
[17:37:40.335] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:40.335] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:40.335] Packages: <none>
[17:37:40.335] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:37:40.335] Resolved: FALSE
[17:37:40.335] Value: <not collected>
[17:37:40.335] Conditions captured: <none>
[17:37:40.335] Early signaling: FALSE
[17:37:40.335] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:40.335] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.347] Chunk #1 of 2 ... DONE
[17:37:40.347] Chunk #2 of 2 ...
[17:37:40.347]  - Finding globals in '...' for chunk #2 ...
[17:37:40.347] getGlobalsAndPackages() ...
[17:37:40.347] Searching for globals...
[17:37:40.348] 
[17:37:40.348] Searching for globals ... DONE
[17:37:40.348] - globals: [0] <none>
[17:37:40.348] getGlobalsAndPackages() ... DONE
[17:37:40.348]    + additional globals found: [n=0] 
[17:37:40.348]    + additional namespaces needed: [n=0] 
[17:37:40.348]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:40.348]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:40.348]  - seeds: [1] <seeds>
[17:37:40.349]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.349] getGlobalsAndPackages() ...
[17:37:40.349] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.349] Resolving globals: FALSE
[17:37:40.349] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[17:37:40.350] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:37:40.350] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.350] 
[17:37:40.350] getGlobalsAndPackages() ... DONE
[17:37:40.350] run() for ‘Future’ ...
[17:37:40.351] - state: ‘created’
[17:37:40.351] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:40.367] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.367] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:40.367]   - Field: ‘node’
[17:37:40.367]   - Field: ‘label’
[17:37:40.367]   - Field: ‘local’
[17:37:40.367]   - Field: ‘owner’
[17:37:40.367]   - Field: ‘envir’
[17:37:40.368]   - Field: ‘workers’
[17:37:40.368]   - Field: ‘packages’
[17:37:40.368]   - Field: ‘gc’
[17:37:40.368]   - Field: ‘conditions’
[17:37:40.368]   - Field: ‘persistent’
[17:37:40.368]   - Field: ‘expr’
[17:37:40.368]   - Field: ‘uuid’
[17:37:40.368]   - Field: ‘seed’
[17:37:40.368]   - Field: ‘version’
[17:37:40.368]   - Field: ‘result’
[17:37:40.368]   - Field: ‘asynchronous’
[17:37:40.369]   - Field: ‘calls’
[17:37:40.369]   - Field: ‘globals’
[17:37:40.369]   - Field: ‘stdout’
[17:37:40.369]   - Field: ‘earlySignal’
[17:37:40.369]   - Field: ‘lazy’
[17:37:40.369]   - Field: ‘state’
[17:37:40.369] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:40.369] - Launch lazy future ...
[17:37:40.369] Packages needed by the future expression (n = 0): <none>
[17:37:40.369] Packages needed by future strategies (n = 0): <none>
[17:37:40.370] {
[17:37:40.370]     {
[17:37:40.370]         {
[17:37:40.370]             ...future.startTime <- base::Sys.time()
[17:37:40.370]             {
[17:37:40.370]                 {
[17:37:40.370]                   {
[17:37:40.370]                     {
[17:37:40.370]                       base::local({
[17:37:40.370]                         has_future <- base::requireNamespace("future", 
[17:37:40.370]                           quietly = TRUE)
[17:37:40.370]                         if (has_future) {
[17:37:40.370]                           ns <- base::getNamespace("future")
[17:37:40.370]                           version <- ns[[".package"]][["version"]]
[17:37:40.370]                           if (is.null(version)) 
[17:37:40.370]                             version <- utils::packageVersion("future")
[17:37:40.370]                         }
[17:37:40.370]                         else {
[17:37:40.370]                           version <- NULL
[17:37:40.370]                         }
[17:37:40.370]                         if (!has_future || version < "1.8.0") {
[17:37:40.370]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:40.370]                             "", base::R.version$version.string), 
[17:37:40.370]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:40.370]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:40.370]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:40.370]                               "release", "version")], collapse = " "), 
[17:37:40.370]                             hostname = base::Sys.info()[["nodename"]])
[17:37:40.370]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:40.370]                             info)
[17:37:40.370]                           info <- base::paste(info, collapse = "; ")
[17:37:40.370]                           if (!has_future) {
[17:37:40.370]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:40.370]                               info)
[17:37:40.370]                           }
[17:37:40.370]                           else {
[17:37:40.370]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:40.370]                               info, version)
[17:37:40.370]                           }
[17:37:40.370]                           base::stop(msg)
[17:37:40.370]                         }
[17:37:40.370]                       })
[17:37:40.370]                     }
[17:37:40.370]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:40.370]                     base::options(mc.cores = 1L)
[17:37:40.370]                   }
[17:37:40.370]                   ...future.strategy.old <- future::plan("list")
[17:37:40.370]                   options(future.plan = NULL)
[17:37:40.370]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.370]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:40.370]                 }
[17:37:40.370]                 ...future.workdir <- getwd()
[17:37:40.370]             }
[17:37:40.370]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:40.370]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:40.370]         }
[17:37:40.370]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:40.370]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:40.370]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:40.370]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:40.370]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:40.370]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:40.370]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:40.370]             base::names(...future.oldOptions))
[17:37:40.370]     }
[17:37:40.370]     if (FALSE) {
[17:37:40.370]     }
[17:37:40.370]     else {
[17:37:40.370]         if (TRUE) {
[17:37:40.370]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:40.370]                 open = "w")
[17:37:40.370]         }
[17:37:40.370]         else {
[17:37:40.370]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:40.370]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:40.370]         }
[17:37:40.370]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:40.370]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:40.370]             base::sink(type = "output", split = FALSE)
[17:37:40.370]             base::close(...future.stdout)
[17:37:40.370]         }, add = TRUE)
[17:37:40.370]     }
[17:37:40.370]     ...future.frame <- base::sys.nframe()
[17:37:40.370]     ...future.conditions <- base::list()
[17:37:40.370]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:40.370]     if (FALSE) {
[17:37:40.370]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:40.370]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:40.370]     }
[17:37:40.370]     ...future.result <- base::tryCatch({
[17:37:40.370]         base::withCallingHandlers({
[17:37:40.370]             ...future.value <- base::withVisible(base::local({
[17:37:40.370]                 ...future.makeSendCondition <- base::local({
[17:37:40.370]                   sendCondition <- NULL
[17:37:40.370]                   function(frame = 1L) {
[17:37:40.370]                     if (is.function(sendCondition)) 
[17:37:40.370]                       return(sendCondition)
[17:37:40.370]                     ns <- getNamespace("parallel")
[17:37:40.370]                     if (exists("sendData", mode = "function", 
[17:37:40.370]                       envir = ns)) {
[17:37:40.370]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:40.370]                         envir = ns)
[17:37:40.370]                       envir <- sys.frame(frame)
[17:37:40.370]                       master <- NULL
[17:37:40.370]                       while (!identical(envir, .GlobalEnv) && 
[17:37:40.370]                         !identical(envir, emptyenv())) {
[17:37:40.370]                         if (exists("master", mode = "list", envir = envir, 
[17:37:40.370]                           inherits = FALSE)) {
[17:37:40.370]                           master <- get("master", mode = "list", 
[17:37:40.370]                             envir = envir, inherits = FALSE)
[17:37:40.370]                           if (inherits(master, c("SOCKnode", 
[17:37:40.370]                             "SOCK0node"))) {
[17:37:40.370]                             sendCondition <<- function(cond) {
[17:37:40.370]                               data <- list(type = "VALUE", value = cond, 
[17:37:40.370]                                 success = TRUE)
[17:37:40.370]                               parallel_sendData(master, data)
[17:37:40.370]                             }
[17:37:40.370]                             return(sendCondition)
[17:37:40.370]                           }
[17:37:40.370]                         }
[17:37:40.370]                         frame <- frame + 1L
[17:37:40.370]                         envir <- sys.frame(frame)
[17:37:40.370]                       }
[17:37:40.370]                     }
[17:37:40.370]                     sendCondition <<- function(cond) NULL
[17:37:40.370]                   }
[17:37:40.370]                 })
[17:37:40.370]                 withCallingHandlers({
[17:37:40.370]                   {
[17:37:40.370]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.370]                     if (!identical(...future.globals.maxSize.org, 
[17:37:40.370]                       ...future.globals.maxSize)) {
[17:37:40.370]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.370]                       on.exit(options(oopts), add = TRUE)
[17:37:40.370]                     }
[17:37:40.370]                     {
[17:37:40.370]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:37:40.370]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:37:40.370]                           envir = globalenv(), inherits = FALSE)
[17:37:40.370]                         ...future.FUN(...)
[17:37:40.370]                       }
[17:37:40.370]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:37:40.370]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:37:40.370]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:40.370]                         USE.NAMES = FALSE)
[17:37:40.370]                       do.call(mapply, args = args)
[17:37:40.370]                     }
[17:37:40.370]                   }
[17:37:40.370]                 }, immediateCondition = function(cond) {
[17:37:40.370]                   sendCondition <- ...future.makeSendCondition()
[17:37:40.370]                   sendCondition(cond)
[17:37:40.370]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.370]                   {
[17:37:40.370]                     inherits <- base::inherits
[17:37:40.370]                     invokeRestart <- base::invokeRestart
[17:37:40.370]                     is.null <- base::is.null
[17:37:40.370]                     muffled <- FALSE
[17:37:40.370]                     if (inherits(cond, "message")) {
[17:37:40.370]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:40.370]                       if (muffled) 
[17:37:40.370]                         invokeRestart("muffleMessage")
[17:37:40.370]                     }
[17:37:40.370]                     else if (inherits(cond, "warning")) {
[17:37:40.370]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:40.370]                       if (muffled) 
[17:37:40.370]                         invokeRestart("muffleWarning")
[17:37:40.370]                     }
[17:37:40.370]                     else if (inherits(cond, "condition")) {
[17:37:40.370]                       if (!is.null(pattern)) {
[17:37:40.370]                         computeRestarts <- base::computeRestarts
[17:37:40.370]                         grepl <- base::grepl
[17:37:40.370]                         restarts <- computeRestarts(cond)
[17:37:40.370]                         for (restart in restarts) {
[17:37:40.370]                           name <- restart$name
[17:37:40.370]                           if (is.null(name)) 
[17:37:40.370]                             next
[17:37:40.370]                           if (!grepl(pattern, name)) 
[17:37:40.370]                             next
[17:37:40.370]                           invokeRestart(restart)
[17:37:40.370]                           muffled <- TRUE
[17:37:40.370]                           break
[17:37:40.370]                         }
[17:37:40.370]                       }
[17:37:40.370]                     }
[17:37:40.370]                     invisible(muffled)
[17:37:40.370]                   }
[17:37:40.370]                   muffleCondition(cond)
[17:37:40.370]                 })
[17:37:40.370]             }))
[17:37:40.370]             future::FutureResult(value = ...future.value$value, 
[17:37:40.370]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.370]                   ...future.rng), globalenv = if (FALSE) 
[17:37:40.370]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:40.370]                     ...future.globalenv.names))
[17:37:40.370]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:40.370]         }, condition = base::local({
[17:37:40.370]             c <- base::c
[17:37:40.370]             inherits <- base::inherits
[17:37:40.370]             invokeRestart <- base::invokeRestart
[17:37:40.370]             length <- base::length
[17:37:40.370]             list <- base::list
[17:37:40.370]             seq.int <- base::seq.int
[17:37:40.370]             signalCondition <- base::signalCondition
[17:37:40.370]             sys.calls <- base::sys.calls
[17:37:40.370]             `[[` <- base::`[[`
[17:37:40.370]             `+` <- base::`+`
[17:37:40.370]             `<<-` <- base::`<<-`
[17:37:40.370]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:40.370]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:40.370]                   3L)]
[17:37:40.370]             }
[17:37:40.370]             function(cond) {
[17:37:40.370]                 is_error <- inherits(cond, "error")
[17:37:40.370]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:40.370]                   NULL)
[17:37:40.370]                 if (is_error) {
[17:37:40.370]                   sessionInformation <- function() {
[17:37:40.370]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:40.370]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:40.370]                       search = base::search(), system = base::Sys.info())
[17:37:40.370]                   }
[17:37:40.370]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.370]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:40.370]                     cond$call), session = sessionInformation(), 
[17:37:40.370]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:40.370]                   signalCondition(cond)
[17:37:40.370]                 }
[17:37:40.370]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:40.370]                 "immediateCondition"))) {
[17:37:40.370]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:40.370]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.370]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:40.370]                   if (TRUE && !signal) {
[17:37:40.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.370]                     {
[17:37:40.370]                       inherits <- base::inherits
[17:37:40.370]                       invokeRestart <- base::invokeRestart
[17:37:40.370]                       is.null <- base::is.null
[17:37:40.370]                       muffled <- FALSE
[17:37:40.370]                       if (inherits(cond, "message")) {
[17:37:40.370]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.370]                         if (muffled) 
[17:37:40.370]                           invokeRestart("muffleMessage")
[17:37:40.370]                       }
[17:37:40.370]                       else if (inherits(cond, "warning")) {
[17:37:40.370]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.370]                         if (muffled) 
[17:37:40.370]                           invokeRestart("muffleWarning")
[17:37:40.370]                       }
[17:37:40.370]                       else if (inherits(cond, "condition")) {
[17:37:40.370]                         if (!is.null(pattern)) {
[17:37:40.370]                           computeRestarts <- base::computeRestarts
[17:37:40.370]                           grepl <- base::grepl
[17:37:40.370]                           restarts <- computeRestarts(cond)
[17:37:40.370]                           for (restart in restarts) {
[17:37:40.370]                             name <- restart$name
[17:37:40.370]                             if (is.null(name)) 
[17:37:40.370]                               next
[17:37:40.370]                             if (!grepl(pattern, name)) 
[17:37:40.370]                               next
[17:37:40.370]                             invokeRestart(restart)
[17:37:40.370]                             muffled <- TRUE
[17:37:40.370]                             break
[17:37:40.370]                           }
[17:37:40.370]                         }
[17:37:40.370]                       }
[17:37:40.370]                       invisible(muffled)
[17:37:40.370]                     }
[17:37:40.370]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.370]                   }
[17:37:40.370]                 }
[17:37:40.370]                 else {
[17:37:40.370]                   if (TRUE) {
[17:37:40.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.370]                     {
[17:37:40.370]                       inherits <- base::inherits
[17:37:40.370]                       invokeRestart <- base::invokeRestart
[17:37:40.370]                       is.null <- base::is.null
[17:37:40.370]                       muffled <- FALSE
[17:37:40.370]                       if (inherits(cond, "message")) {
[17:37:40.370]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.370]                         if (muffled) 
[17:37:40.370]                           invokeRestart("muffleMessage")
[17:37:40.370]                       }
[17:37:40.370]                       else if (inherits(cond, "warning")) {
[17:37:40.370]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.370]                         if (muffled) 
[17:37:40.370]                           invokeRestart("muffleWarning")
[17:37:40.370]                       }
[17:37:40.370]                       else if (inherits(cond, "condition")) {
[17:37:40.370]                         if (!is.null(pattern)) {
[17:37:40.370]                           computeRestarts <- base::computeRestarts
[17:37:40.370]                           grepl <- base::grepl
[17:37:40.370]                           restarts <- computeRestarts(cond)
[17:37:40.370]                           for (restart in restarts) {
[17:37:40.370]                             name <- restart$name
[17:37:40.370]                             if (is.null(name)) 
[17:37:40.370]                               next
[17:37:40.370]                             if (!grepl(pattern, name)) 
[17:37:40.370]                               next
[17:37:40.370]                             invokeRestart(restart)
[17:37:40.370]                             muffled <- TRUE
[17:37:40.370]                             break
[17:37:40.370]                           }
[17:37:40.370]                         }
[17:37:40.370]                       }
[17:37:40.370]                       invisible(muffled)
[17:37:40.370]                     }
[17:37:40.370]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.370]                   }
[17:37:40.370]                 }
[17:37:40.370]             }
[17:37:40.370]         }))
[17:37:40.370]     }, error = function(ex) {
[17:37:40.370]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:40.370]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.370]                 ...future.rng), started = ...future.startTime, 
[17:37:40.370]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:40.370]             version = "1.8"), class = "FutureResult")
[17:37:40.370]     }, finally = {
[17:37:40.370]         if (!identical(...future.workdir, getwd())) 
[17:37:40.370]             setwd(...future.workdir)
[17:37:40.370]         {
[17:37:40.370]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:40.370]                 ...future.oldOptions$nwarnings <- NULL
[17:37:40.370]             }
[17:37:40.370]             base::options(...future.oldOptions)
[17:37:40.370]             if (.Platform$OS.type == "windows") {
[17:37:40.370]                 old_names <- names(...future.oldEnvVars)
[17:37:40.370]                 envs <- base::Sys.getenv()
[17:37:40.370]                 names <- names(envs)
[17:37:40.370]                 common <- intersect(names, old_names)
[17:37:40.370]                 added <- setdiff(names, old_names)
[17:37:40.370]                 removed <- setdiff(old_names, names)
[17:37:40.370]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:40.370]                   envs[common]]
[17:37:40.370]                 NAMES <- toupper(changed)
[17:37:40.370]                 args <- list()
[17:37:40.370]                 for (kk in seq_along(NAMES)) {
[17:37:40.370]                   name <- changed[[kk]]
[17:37:40.370]                   NAME <- NAMES[[kk]]
[17:37:40.370]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.370]                     next
[17:37:40.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.370]                 }
[17:37:40.370]                 NAMES <- toupper(added)
[17:37:40.370]                 for (kk in seq_along(NAMES)) {
[17:37:40.370]                   name <- added[[kk]]
[17:37:40.370]                   NAME <- NAMES[[kk]]
[17:37:40.370]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.370]                     next
[17:37:40.370]                   args[[name]] <- ""
[17:37:40.370]                 }
[17:37:40.370]                 NAMES <- toupper(removed)
[17:37:40.370]                 for (kk in seq_along(NAMES)) {
[17:37:40.370]                   name <- removed[[kk]]
[17:37:40.370]                   NAME <- NAMES[[kk]]
[17:37:40.370]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.370]                     next
[17:37:40.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.370]                 }
[17:37:40.370]                 if (length(args) > 0) 
[17:37:40.370]                   base::do.call(base::Sys.setenv, args = args)
[17:37:40.370]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:40.370]             }
[17:37:40.370]             else {
[17:37:40.370]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:40.370]             }
[17:37:40.370]             {
[17:37:40.370]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:40.370]                   0L) {
[17:37:40.370]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:40.370]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:40.370]                   base::options(opts)
[17:37:40.370]                 }
[17:37:40.370]                 {
[17:37:40.370]                   {
[17:37:40.370]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:40.370]                     NULL
[17:37:40.370]                   }
[17:37:40.370]                   options(future.plan = NULL)
[17:37:40.370]                   if (is.na(NA_character_)) 
[17:37:40.370]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.370]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:40.370]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:40.370]                     .init = FALSE)
[17:37:40.370]                 }
[17:37:40.370]             }
[17:37:40.370]         }
[17:37:40.370]     })
[17:37:40.370]     if (TRUE) {
[17:37:40.370]         base::sink(type = "output", split = FALSE)
[17:37:40.370]         if (TRUE) {
[17:37:40.370]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:40.370]         }
[17:37:40.370]         else {
[17:37:40.370]             ...future.result["stdout"] <- base::list(NULL)
[17:37:40.370]         }
[17:37:40.370]         base::close(...future.stdout)
[17:37:40.370]         ...future.stdout <- NULL
[17:37:40.370]     }
[17:37:40.370]     ...future.result$conditions <- ...future.conditions
[17:37:40.370]     ...future.result$finished <- base::Sys.time()
[17:37:40.370]     ...future.result
[17:37:40.370] }
[17:37:40.373] Exporting 5 global objects (1.85 KiB) to cluster node #2 ...
[17:37:40.373] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[17:37:40.373] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[17:37:40.373] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[17:37:40.374] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[17:37:40.374] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:37:40.374] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:37:40.374] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[17:37:40.375] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[17:37:40.375] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:37:40.375] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:37:40.375] Exporting 5 global objects (1.85 KiB) to cluster node #2 ... DONE
[17:37:40.376] MultisessionFuture started
[17:37:40.376] - Launch lazy future ... done
[17:37:40.376] run() for ‘MultisessionFuture’ ... done
[17:37:40.376] Created future:
[17:37:40.376] MultisessionFuture:
[17:37:40.376] Label: ‘future_mapply-2’
[17:37:40.376] Expression:
[17:37:40.376] {
[17:37:40.376]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.376]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:40.376]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.376]         on.exit(options(oopts), add = TRUE)
[17:37:40.376]     }
[17:37:40.376]     {
[17:37:40.376]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:37:40.376]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:37:40.376]                 inherits = FALSE)
[17:37:40.376]             ...future.FUN(...)
[17:37:40.376]         }
[17:37:40.376]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:37:40.376]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:37:40.376]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:40.376]         do.call(mapply, args = args)
[17:37:40.376]     }
[17:37:40.376] }
[17:37:40.376] Lazy evaluation: FALSE
[17:37:40.376] Asynchronous evaluation: TRUE
[17:37:40.376] Local evaluation: TRUE
[17:37:40.376] Environment: R_GlobalEnv
[17:37:40.376] Capture standard output: TRUE
[17:37:40.376] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:40.376] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:40.376] Packages: <none>
[17:37:40.376] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:37:40.376] Resolved: FALSE
[17:37:40.376] Value: <not collected>
[17:37:40.376] Conditions captured: <none>
[17:37:40.376] Early signaling: FALSE
[17:37:40.376] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:40.376] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.388] Chunk #2 of 2 ... DONE
[17:37:40.388] Launching 2 futures (chunks) ... DONE
[17:37:40.388] Resolving 2 futures (chunks) ...
[17:37:40.388] resolve() on list ...
[17:37:40.388]  recursive: 0
[17:37:40.388]  length: 2
[17:37:40.388] 
[17:37:40.389] receiveMessageFromWorker() for ClusterFuture ...
[17:37:40.389] - Validating connection of MultisessionFuture
[17:37:40.389] - received message: FutureResult
[17:37:40.389] - Received FutureResult
[17:37:40.389] - Erased future from FutureRegistry
[17:37:40.389] result() for ClusterFuture ...
[17:37:40.390] - result already collected: FutureResult
[17:37:40.390] result() for ClusterFuture ... done
[17:37:40.390] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:40.390] Future #1
[17:37:40.390] result() for ClusterFuture ...
[17:37:40.390] - result already collected: FutureResult
[17:37:40.390] result() for ClusterFuture ... done
[17:37:40.390] result() for ClusterFuture ...
[17:37:40.390] - result already collected: FutureResult
[17:37:40.390] result() for ClusterFuture ... done
[17:37:40.390] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:37:40.390] - nx: 2
[17:37:40.391] - relay: TRUE
[17:37:40.391] - stdout: TRUE
[17:37:40.391] - signal: TRUE
[17:37:40.391] - resignal: FALSE
[17:37:40.391] - force: TRUE
[17:37:40.391] - relayed: [n=2] FALSE, FALSE
[17:37:40.391] - queued futures: [n=2] FALSE, FALSE
[17:37:40.391]  - until=1
[17:37:40.391]  - relaying element #1
[17:37:40.391] result() for ClusterFuture ...
[17:37:40.391] - result already collected: FutureResult
[17:37:40.391] result() for ClusterFuture ... done
[17:37:40.392] result() for ClusterFuture ...
[17:37:40.392] - result already collected: FutureResult
[17:37:40.392] result() for ClusterFuture ... done
[17:37:40.392] result() for ClusterFuture ...
[17:37:40.392] - result already collected: FutureResult
[17:37:40.392] result() for ClusterFuture ... done
[17:37:40.392] result() for ClusterFuture ...
[17:37:40.392] - result already collected: FutureResult
[17:37:40.392] result() for ClusterFuture ... done
[17:37:40.392] - relayed: [n=2] TRUE, FALSE
[17:37:40.392] - queued futures: [n=2] TRUE, FALSE
[17:37:40.393] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:37:40.393]  length: 1 (resolved future 1)
[17:37:40.418] receiveMessageFromWorker() for ClusterFuture ...
[17:37:40.418] - Validating connection of MultisessionFuture
[17:37:40.418] - received message: FutureResult
[17:37:40.418] - Received FutureResult
[17:37:40.418] - Erased future from FutureRegistry
[17:37:40.419] result() for ClusterFuture ...
[17:37:40.419] - result already collected: FutureResult
[17:37:40.419] result() for ClusterFuture ... done
[17:37:40.419] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:40.419] Future #2
[17:37:40.419] result() for ClusterFuture ...
[17:37:40.419] - result already collected: FutureResult
[17:37:40.419] result() for ClusterFuture ... done
[17:37:40.419] result() for ClusterFuture ...
[17:37:40.419] - result already collected: FutureResult
[17:37:40.419] result() for ClusterFuture ... done
[17:37:40.419] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:37:40.420] - nx: 2
[17:37:40.420] - relay: TRUE
[17:37:40.420] - stdout: TRUE
[17:37:40.420] - signal: TRUE
[17:37:40.420] - resignal: FALSE
[17:37:40.420] - force: TRUE
[17:37:40.420] - relayed: [n=2] TRUE, FALSE
[17:37:40.420] - queued futures: [n=2] TRUE, FALSE
[17:37:40.420]  - until=2
[17:37:40.420]  - relaying element #2
[17:37:40.420] result() for ClusterFuture ...
[17:37:40.420] - result already collected: FutureResult
[17:37:40.421] result() for ClusterFuture ... done
[17:37:40.421] result() for ClusterFuture ...
[17:37:40.421] - result already collected: FutureResult
[17:37:40.421] result() for ClusterFuture ... done
[17:37:40.421] result() for ClusterFuture ...
[17:37:40.421] - result already collected: FutureResult
[17:37:40.421] result() for ClusterFuture ... done
[17:37:40.421] result() for ClusterFuture ...
[17:37:40.421] - result already collected: FutureResult
[17:37:40.421] result() for ClusterFuture ... done
[17:37:40.422] - relayed: [n=2] TRUE, TRUE
[17:37:40.422] - queued futures: [n=2] TRUE, TRUE
[17:37:40.422] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:37:40.422]  length: 0 (resolved future 2)
[17:37:40.422] Relaying remaining futures
[17:37:40.422] signalConditionsASAP(NULL, pos=0) ...
[17:37:40.422] - nx: 2
[17:37:40.422] - relay: TRUE
[17:37:40.422] - stdout: TRUE
[17:37:40.422] - signal: TRUE
[17:37:40.422] - resignal: FALSE
[17:37:40.422] - force: TRUE
[17:37:40.422] - relayed: [n=2] TRUE, TRUE
[17:37:40.423] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:40.423] - relayed: [n=2] TRUE, TRUE
[17:37:40.423] - queued futures: [n=2] TRUE, TRUE
[17:37:40.423] signalConditionsASAP(NULL, pos=0) ... done
[17:37:40.423] resolve() on list ... DONE
[17:37:40.423] result() for ClusterFuture ...
[17:37:40.423] - result already collected: FutureResult
[17:37:40.423] result() for ClusterFuture ... done
[17:37:40.423] result() for ClusterFuture ...
[17:37:40.423] - result already collected: FutureResult
[17:37:40.423] result() for ClusterFuture ... done
[17:37:40.424] result() for ClusterFuture ...
[17:37:40.424] - result already collected: FutureResult
[17:37:40.424] result() for ClusterFuture ... done
[17:37:40.424] result() for ClusterFuture ...
[17:37:40.424] - result already collected: FutureResult
[17:37:40.424] result() for ClusterFuture ... done
[17:37:40.424]  - Number of value chunks collected: 2
[17:37:40.424] Resolving 2 futures (chunks) ... DONE
[17:37:40.424] Reducing values from 2 chunks ...
[17:37:40.424]  - Number of values collected after concatenation: 2
[17:37:40.424]  - Number of values expected: 2
[17:37:40.425] Reducing values from 2 chunks ... DONE
[17:37:40.425] future_mapply() ... DONE
[17:37:40.425] future_mapply() ...
[17:37:40.428] Number of chunks: 2
[17:37:40.429] getGlobalsAndPackagesXApply() ...
[17:37:40.429]  - future.globals: TRUE
[17:37:40.429] getGlobalsAndPackages() ...
[17:37:40.429] Searching for globals...
[17:37:40.430] - globals found: [1] ‘FUN’
[17:37:40.430] Searching for globals ... DONE
[17:37:40.430] Resolving globals: FALSE
[17:37:40.430] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:37:40.431] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:37:40.431] - globals: [1] ‘FUN’
[17:37:40.431] 
[17:37:40.431] getGlobalsAndPackages() ... DONE
[17:37:40.431]  - globals found/used: [n=1] ‘FUN’
[17:37:40.431]  - needed namespaces: [n=0] 
[17:37:40.431] Finding globals ... DONE
[17:37:40.431] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:40.432] List of 2
[17:37:40.432]  $ ...future.FUN:function (x, y)  
[17:37:40.432]  $ MoreArgs     :List of 1
[17:37:40.432]   ..$ y: int [1:2] 3 4
[17:37:40.432]  - attr(*, "where")=List of 2
[17:37:40.432]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:40.432]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:40.432]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:40.432]  - attr(*, "resolved")= logi FALSE
[17:37:40.432]  - attr(*, "total_size")= num NA
[17:37:40.434] Packages to be attached in all futures: [n=0] 
[17:37:40.434] getGlobalsAndPackagesXApply() ... DONE
[17:37:40.435] Number of futures (= number of chunks): 2
[17:37:40.435] Launching 2 futures (chunks) ...
[17:37:40.435] Chunk #1 of 2 ...
[17:37:40.435]  - Finding globals in '...' for chunk #1 ...
[17:37:40.435] getGlobalsAndPackages() ...
[17:37:40.435] Searching for globals...
[17:37:40.435] 
[17:37:40.435] Searching for globals ... DONE
[17:37:40.436] - globals: [0] <none>
[17:37:40.436] getGlobalsAndPackages() ... DONE
[17:37:40.436]    + additional globals found: [n=0] 
[17:37:40.436]    + additional namespaces needed: [n=0] 
[17:37:40.436]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:40.436]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:40.436]  - seeds: <none>
[17:37:40.436]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.436] getGlobalsAndPackages() ...
[17:37:40.436] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.437] Resolving globals: FALSE
[17:37:40.437] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:37:40.437] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:37:40.438] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.438] 
[17:37:40.438] getGlobalsAndPackages() ... DONE
[17:37:40.438] run() for ‘Future’ ...
[17:37:40.438] - state: ‘created’
[17:37:40.438] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:40.452] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.452] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:40.452]   - Field: ‘node’
[17:37:40.452]   - Field: ‘label’
[17:37:40.452]   - Field: ‘local’
[17:37:40.452]   - Field: ‘owner’
[17:37:40.452]   - Field: ‘envir’
[17:37:40.452]   - Field: ‘workers’
[17:37:40.453]   - Field: ‘packages’
[17:37:40.453]   - Field: ‘gc’
[17:37:40.453]   - Field: ‘conditions’
[17:37:40.453]   - Field: ‘persistent’
[17:37:40.453]   - Field: ‘expr’
[17:37:40.453]   - Field: ‘uuid’
[17:37:40.453]   - Field: ‘seed’
[17:37:40.453]   - Field: ‘version’
[17:37:40.453]   - Field: ‘result’
[17:37:40.453]   - Field: ‘asynchronous’
[17:37:40.453]   - Field: ‘calls’
[17:37:40.454]   - Field: ‘globals’
[17:37:40.454]   - Field: ‘stdout’
[17:37:40.454]   - Field: ‘earlySignal’
[17:37:40.454]   - Field: ‘lazy’
[17:37:40.454]   - Field: ‘state’
[17:37:40.454] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:40.454] - Launch lazy future ...
[17:37:40.454] Packages needed by the future expression (n = 0): <none>
[17:37:40.454] Packages needed by future strategies (n = 0): <none>
[17:37:40.455] {
[17:37:40.455]     {
[17:37:40.455]         {
[17:37:40.455]             ...future.startTime <- base::Sys.time()
[17:37:40.455]             {
[17:37:40.455]                 {
[17:37:40.455]                   {
[17:37:40.455]                     {
[17:37:40.455]                       base::local({
[17:37:40.455]                         has_future <- base::requireNamespace("future", 
[17:37:40.455]                           quietly = TRUE)
[17:37:40.455]                         if (has_future) {
[17:37:40.455]                           ns <- base::getNamespace("future")
[17:37:40.455]                           version <- ns[[".package"]][["version"]]
[17:37:40.455]                           if (is.null(version)) 
[17:37:40.455]                             version <- utils::packageVersion("future")
[17:37:40.455]                         }
[17:37:40.455]                         else {
[17:37:40.455]                           version <- NULL
[17:37:40.455]                         }
[17:37:40.455]                         if (!has_future || version < "1.8.0") {
[17:37:40.455]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:40.455]                             "", base::R.version$version.string), 
[17:37:40.455]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:40.455]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:40.455]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:40.455]                               "release", "version")], collapse = " "), 
[17:37:40.455]                             hostname = base::Sys.info()[["nodename"]])
[17:37:40.455]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:40.455]                             info)
[17:37:40.455]                           info <- base::paste(info, collapse = "; ")
[17:37:40.455]                           if (!has_future) {
[17:37:40.455]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:40.455]                               info)
[17:37:40.455]                           }
[17:37:40.455]                           else {
[17:37:40.455]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:40.455]                               info, version)
[17:37:40.455]                           }
[17:37:40.455]                           base::stop(msg)
[17:37:40.455]                         }
[17:37:40.455]                       })
[17:37:40.455]                     }
[17:37:40.455]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:40.455]                     base::options(mc.cores = 1L)
[17:37:40.455]                   }
[17:37:40.455]                   ...future.strategy.old <- future::plan("list")
[17:37:40.455]                   options(future.plan = NULL)
[17:37:40.455]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.455]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:40.455]                 }
[17:37:40.455]                 ...future.workdir <- getwd()
[17:37:40.455]             }
[17:37:40.455]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:40.455]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:40.455]         }
[17:37:40.455]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:40.455]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:40.455]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:40.455]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:40.455]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:40.455]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:40.455]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:40.455]             base::names(...future.oldOptions))
[17:37:40.455]     }
[17:37:40.455]     if (FALSE) {
[17:37:40.455]     }
[17:37:40.455]     else {
[17:37:40.455]         if (TRUE) {
[17:37:40.455]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:40.455]                 open = "w")
[17:37:40.455]         }
[17:37:40.455]         else {
[17:37:40.455]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:40.455]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:40.455]         }
[17:37:40.455]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:40.455]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:40.455]             base::sink(type = "output", split = FALSE)
[17:37:40.455]             base::close(...future.stdout)
[17:37:40.455]         }, add = TRUE)
[17:37:40.455]     }
[17:37:40.455]     ...future.frame <- base::sys.nframe()
[17:37:40.455]     ...future.conditions <- base::list()
[17:37:40.455]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:40.455]     if (FALSE) {
[17:37:40.455]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:40.455]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:40.455]     }
[17:37:40.455]     ...future.result <- base::tryCatch({
[17:37:40.455]         base::withCallingHandlers({
[17:37:40.455]             ...future.value <- base::withVisible(base::local({
[17:37:40.455]                 ...future.makeSendCondition <- base::local({
[17:37:40.455]                   sendCondition <- NULL
[17:37:40.455]                   function(frame = 1L) {
[17:37:40.455]                     if (is.function(sendCondition)) 
[17:37:40.455]                       return(sendCondition)
[17:37:40.455]                     ns <- getNamespace("parallel")
[17:37:40.455]                     if (exists("sendData", mode = "function", 
[17:37:40.455]                       envir = ns)) {
[17:37:40.455]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:40.455]                         envir = ns)
[17:37:40.455]                       envir <- sys.frame(frame)
[17:37:40.455]                       master <- NULL
[17:37:40.455]                       while (!identical(envir, .GlobalEnv) && 
[17:37:40.455]                         !identical(envir, emptyenv())) {
[17:37:40.455]                         if (exists("master", mode = "list", envir = envir, 
[17:37:40.455]                           inherits = FALSE)) {
[17:37:40.455]                           master <- get("master", mode = "list", 
[17:37:40.455]                             envir = envir, inherits = FALSE)
[17:37:40.455]                           if (inherits(master, c("SOCKnode", 
[17:37:40.455]                             "SOCK0node"))) {
[17:37:40.455]                             sendCondition <<- function(cond) {
[17:37:40.455]                               data <- list(type = "VALUE", value = cond, 
[17:37:40.455]                                 success = TRUE)
[17:37:40.455]                               parallel_sendData(master, data)
[17:37:40.455]                             }
[17:37:40.455]                             return(sendCondition)
[17:37:40.455]                           }
[17:37:40.455]                         }
[17:37:40.455]                         frame <- frame + 1L
[17:37:40.455]                         envir <- sys.frame(frame)
[17:37:40.455]                       }
[17:37:40.455]                     }
[17:37:40.455]                     sendCondition <<- function(cond) NULL
[17:37:40.455]                   }
[17:37:40.455]                 })
[17:37:40.455]                 withCallingHandlers({
[17:37:40.455]                   {
[17:37:40.455]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.455]                     if (!identical(...future.globals.maxSize.org, 
[17:37:40.455]                       ...future.globals.maxSize)) {
[17:37:40.455]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.455]                       on.exit(options(oopts), add = TRUE)
[17:37:40.455]                     }
[17:37:40.455]                     {
[17:37:40.455]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.455]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:40.455]                         USE.NAMES = FALSE)
[17:37:40.455]                       do.call(mapply, args = args)
[17:37:40.455]                     }
[17:37:40.455]                   }
[17:37:40.455]                 }, immediateCondition = function(cond) {
[17:37:40.455]                   sendCondition <- ...future.makeSendCondition()
[17:37:40.455]                   sendCondition(cond)
[17:37:40.455]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.455]                   {
[17:37:40.455]                     inherits <- base::inherits
[17:37:40.455]                     invokeRestart <- base::invokeRestart
[17:37:40.455]                     is.null <- base::is.null
[17:37:40.455]                     muffled <- FALSE
[17:37:40.455]                     if (inherits(cond, "message")) {
[17:37:40.455]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:40.455]                       if (muffled) 
[17:37:40.455]                         invokeRestart("muffleMessage")
[17:37:40.455]                     }
[17:37:40.455]                     else if (inherits(cond, "warning")) {
[17:37:40.455]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:40.455]                       if (muffled) 
[17:37:40.455]                         invokeRestart("muffleWarning")
[17:37:40.455]                     }
[17:37:40.455]                     else if (inherits(cond, "condition")) {
[17:37:40.455]                       if (!is.null(pattern)) {
[17:37:40.455]                         computeRestarts <- base::computeRestarts
[17:37:40.455]                         grepl <- base::grepl
[17:37:40.455]                         restarts <- computeRestarts(cond)
[17:37:40.455]                         for (restart in restarts) {
[17:37:40.455]                           name <- restart$name
[17:37:40.455]                           if (is.null(name)) 
[17:37:40.455]                             next
[17:37:40.455]                           if (!grepl(pattern, name)) 
[17:37:40.455]                             next
[17:37:40.455]                           invokeRestart(restart)
[17:37:40.455]                           muffled <- TRUE
[17:37:40.455]                           break
[17:37:40.455]                         }
[17:37:40.455]                       }
[17:37:40.455]                     }
[17:37:40.455]                     invisible(muffled)
[17:37:40.455]                   }
[17:37:40.455]                   muffleCondition(cond)
[17:37:40.455]                 })
[17:37:40.455]             }))
[17:37:40.455]             future::FutureResult(value = ...future.value$value, 
[17:37:40.455]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.455]                   ...future.rng), globalenv = if (FALSE) 
[17:37:40.455]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:40.455]                     ...future.globalenv.names))
[17:37:40.455]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:40.455]         }, condition = base::local({
[17:37:40.455]             c <- base::c
[17:37:40.455]             inherits <- base::inherits
[17:37:40.455]             invokeRestart <- base::invokeRestart
[17:37:40.455]             length <- base::length
[17:37:40.455]             list <- base::list
[17:37:40.455]             seq.int <- base::seq.int
[17:37:40.455]             signalCondition <- base::signalCondition
[17:37:40.455]             sys.calls <- base::sys.calls
[17:37:40.455]             `[[` <- base::`[[`
[17:37:40.455]             `+` <- base::`+`
[17:37:40.455]             `<<-` <- base::`<<-`
[17:37:40.455]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:40.455]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:40.455]                   3L)]
[17:37:40.455]             }
[17:37:40.455]             function(cond) {
[17:37:40.455]                 is_error <- inherits(cond, "error")
[17:37:40.455]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:40.455]                   NULL)
[17:37:40.455]                 if (is_error) {
[17:37:40.455]                   sessionInformation <- function() {
[17:37:40.455]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:40.455]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:40.455]                       search = base::search(), system = base::Sys.info())
[17:37:40.455]                   }
[17:37:40.455]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.455]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:40.455]                     cond$call), session = sessionInformation(), 
[17:37:40.455]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:40.455]                   signalCondition(cond)
[17:37:40.455]                 }
[17:37:40.455]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:40.455]                 "immediateCondition"))) {
[17:37:40.455]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:40.455]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.455]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:40.455]                   if (TRUE && !signal) {
[17:37:40.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.455]                     {
[17:37:40.455]                       inherits <- base::inherits
[17:37:40.455]                       invokeRestart <- base::invokeRestart
[17:37:40.455]                       is.null <- base::is.null
[17:37:40.455]                       muffled <- FALSE
[17:37:40.455]                       if (inherits(cond, "message")) {
[17:37:40.455]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.455]                         if (muffled) 
[17:37:40.455]                           invokeRestart("muffleMessage")
[17:37:40.455]                       }
[17:37:40.455]                       else if (inherits(cond, "warning")) {
[17:37:40.455]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.455]                         if (muffled) 
[17:37:40.455]                           invokeRestart("muffleWarning")
[17:37:40.455]                       }
[17:37:40.455]                       else if (inherits(cond, "condition")) {
[17:37:40.455]                         if (!is.null(pattern)) {
[17:37:40.455]                           computeRestarts <- base::computeRestarts
[17:37:40.455]                           grepl <- base::grepl
[17:37:40.455]                           restarts <- computeRestarts(cond)
[17:37:40.455]                           for (restart in restarts) {
[17:37:40.455]                             name <- restart$name
[17:37:40.455]                             if (is.null(name)) 
[17:37:40.455]                               next
[17:37:40.455]                             if (!grepl(pattern, name)) 
[17:37:40.455]                               next
[17:37:40.455]                             invokeRestart(restart)
[17:37:40.455]                             muffled <- TRUE
[17:37:40.455]                             break
[17:37:40.455]                           }
[17:37:40.455]                         }
[17:37:40.455]                       }
[17:37:40.455]                       invisible(muffled)
[17:37:40.455]                     }
[17:37:40.455]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.455]                   }
[17:37:40.455]                 }
[17:37:40.455]                 else {
[17:37:40.455]                   if (TRUE) {
[17:37:40.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.455]                     {
[17:37:40.455]                       inherits <- base::inherits
[17:37:40.455]                       invokeRestart <- base::invokeRestart
[17:37:40.455]                       is.null <- base::is.null
[17:37:40.455]                       muffled <- FALSE
[17:37:40.455]                       if (inherits(cond, "message")) {
[17:37:40.455]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.455]                         if (muffled) 
[17:37:40.455]                           invokeRestart("muffleMessage")
[17:37:40.455]                       }
[17:37:40.455]                       else if (inherits(cond, "warning")) {
[17:37:40.455]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.455]                         if (muffled) 
[17:37:40.455]                           invokeRestart("muffleWarning")
[17:37:40.455]                       }
[17:37:40.455]                       else if (inherits(cond, "condition")) {
[17:37:40.455]                         if (!is.null(pattern)) {
[17:37:40.455]                           computeRestarts <- base::computeRestarts
[17:37:40.455]                           grepl <- base::grepl
[17:37:40.455]                           restarts <- computeRestarts(cond)
[17:37:40.455]                           for (restart in restarts) {
[17:37:40.455]                             name <- restart$name
[17:37:40.455]                             if (is.null(name)) 
[17:37:40.455]                               next
[17:37:40.455]                             if (!grepl(pattern, name)) 
[17:37:40.455]                               next
[17:37:40.455]                             invokeRestart(restart)
[17:37:40.455]                             muffled <- TRUE
[17:37:40.455]                             break
[17:37:40.455]                           }
[17:37:40.455]                         }
[17:37:40.455]                       }
[17:37:40.455]                       invisible(muffled)
[17:37:40.455]                     }
[17:37:40.455]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.455]                   }
[17:37:40.455]                 }
[17:37:40.455]             }
[17:37:40.455]         }))
[17:37:40.455]     }, error = function(ex) {
[17:37:40.455]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:40.455]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.455]                 ...future.rng), started = ...future.startTime, 
[17:37:40.455]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:40.455]             version = "1.8"), class = "FutureResult")
[17:37:40.455]     }, finally = {
[17:37:40.455]         if (!identical(...future.workdir, getwd())) 
[17:37:40.455]             setwd(...future.workdir)
[17:37:40.455]         {
[17:37:40.455]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:40.455]                 ...future.oldOptions$nwarnings <- NULL
[17:37:40.455]             }
[17:37:40.455]             base::options(...future.oldOptions)
[17:37:40.455]             if (.Platform$OS.type == "windows") {
[17:37:40.455]                 old_names <- names(...future.oldEnvVars)
[17:37:40.455]                 envs <- base::Sys.getenv()
[17:37:40.455]                 names <- names(envs)
[17:37:40.455]                 common <- intersect(names, old_names)
[17:37:40.455]                 added <- setdiff(names, old_names)
[17:37:40.455]                 removed <- setdiff(old_names, names)
[17:37:40.455]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:40.455]                   envs[common]]
[17:37:40.455]                 NAMES <- toupper(changed)
[17:37:40.455]                 args <- list()
[17:37:40.455]                 for (kk in seq_along(NAMES)) {
[17:37:40.455]                   name <- changed[[kk]]
[17:37:40.455]                   NAME <- NAMES[[kk]]
[17:37:40.455]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.455]                     next
[17:37:40.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.455]                 }
[17:37:40.455]                 NAMES <- toupper(added)
[17:37:40.455]                 for (kk in seq_along(NAMES)) {
[17:37:40.455]                   name <- added[[kk]]
[17:37:40.455]                   NAME <- NAMES[[kk]]
[17:37:40.455]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.455]                     next
[17:37:40.455]                   args[[name]] <- ""
[17:37:40.455]                 }
[17:37:40.455]                 NAMES <- toupper(removed)
[17:37:40.455]                 for (kk in seq_along(NAMES)) {
[17:37:40.455]                   name <- removed[[kk]]
[17:37:40.455]                   NAME <- NAMES[[kk]]
[17:37:40.455]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.455]                     next
[17:37:40.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.455]                 }
[17:37:40.455]                 if (length(args) > 0) 
[17:37:40.455]                   base::do.call(base::Sys.setenv, args = args)
[17:37:40.455]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:40.455]             }
[17:37:40.455]             else {
[17:37:40.455]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:40.455]             }
[17:37:40.455]             {
[17:37:40.455]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:40.455]                   0L) {
[17:37:40.455]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:40.455]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:40.455]                   base::options(opts)
[17:37:40.455]                 }
[17:37:40.455]                 {
[17:37:40.455]                   {
[17:37:40.455]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:40.455]                     NULL
[17:37:40.455]                   }
[17:37:40.455]                   options(future.plan = NULL)
[17:37:40.455]                   if (is.na(NA_character_)) 
[17:37:40.455]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.455]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:40.455]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:40.455]                     .init = FALSE)
[17:37:40.455]                 }
[17:37:40.455]             }
[17:37:40.455]         }
[17:37:40.455]     })
[17:37:40.455]     if (TRUE) {
[17:37:40.455]         base::sink(type = "output", split = FALSE)
[17:37:40.455]         if (TRUE) {
[17:37:40.455]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:40.455]         }
[17:37:40.455]         else {
[17:37:40.455]             ...future.result["stdout"] <- base::list(NULL)
[17:37:40.455]         }
[17:37:40.455]         base::close(...future.stdout)
[17:37:40.455]         ...future.stdout <- NULL
[17:37:40.455]     }
[17:37:40.455]     ...future.result$conditions <- ...future.conditions
[17:37:40.455]     ...future.result$finished <- base::Sys.time()
[17:37:40.455]     ...future.result
[17:37:40.455] }
[17:37:40.458] Exporting 5 global objects (1.77 KiB) to cluster node #1 ...
[17:37:40.458] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[17:37:40.458] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[17:37:40.458] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[17:37:40.459] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[17:37:40.459] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:37:40.459] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:37:40.459] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:40.459] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:40.460] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:40.460] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:40.460] Exporting 5 global objects (1.77 KiB) to cluster node #1 ... DONE
[17:37:40.460] MultisessionFuture started
[17:37:40.461] - Launch lazy future ... done
[17:37:40.461] run() for ‘MultisessionFuture’ ... done
[17:37:40.461] Created future:
[17:37:40.461] MultisessionFuture:
[17:37:40.461] Label: ‘future_.mapply-1’
[17:37:40.461] Expression:
[17:37:40.461] {
[17:37:40.461]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.461]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:40.461]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.461]         on.exit(options(oopts), add = TRUE)
[17:37:40.461]     }
[17:37:40.461]     {
[17:37:40.461]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.461]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:40.461]         do.call(mapply, args = args)
[17:37:40.461]     }
[17:37:40.461] }
[17:37:40.461] Lazy evaluation: FALSE
[17:37:40.461] Asynchronous evaluation: TRUE
[17:37:40.461] Local evaluation: TRUE
[17:37:40.461] Environment: R_GlobalEnv
[17:37:40.461] Capture standard output: TRUE
[17:37:40.461] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:40.461] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:40.461] Packages: <none>
[17:37:40.461] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:40.461] Resolved: FALSE
[17:37:40.461] Value: <not collected>
[17:37:40.461] Conditions captured: <none>
[17:37:40.461] Early signaling: FALSE
[17:37:40.461] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:40.461] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.472] Chunk #1 of 2 ... DONE
[17:37:40.472] Chunk #2 of 2 ...
[17:37:40.473]  - Finding globals in '...' for chunk #2 ...
[17:37:40.473] getGlobalsAndPackages() ...
[17:37:40.473] Searching for globals...
[17:37:40.473] 
[17:37:40.473] Searching for globals ... DONE
[17:37:40.473] - globals: [0] <none>
[17:37:40.474] getGlobalsAndPackages() ... DONE
[17:37:40.474]    + additional globals found: [n=0] 
[17:37:40.474]    + additional namespaces needed: [n=0] 
[17:37:40.474]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:40.474]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:40.474]  - seeds: <none>
[17:37:40.474]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.474] getGlobalsAndPackages() ...
[17:37:40.474] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.474] Resolving globals: FALSE
[17:37:40.475] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:37:40.475] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:37:40.475] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.475] 
[17:37:40.476] getGlobalsAndPackages() ... DONE
[17:37:40.476] run() for ‘Future’ ...
[17:37:40.476] - state: ‘created’
[17:37:40.476] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:40.490] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.490] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:40.490]   - Field: ‘node’
[17:37:40.490]   - Field: ‘label’
[17:37:40.490]   - Field: ‘local’
[17:37:40.490]   - Field: ‘owner’
[17:37:40.490]   - Field: ‘envir’
[17:37:40.490]   - Field: ‘workers’
[17:37:40.491]   - Field: ‘packages’
[17:37:40.491]   - Field: ‘gc’
[17:37:40.491]   - Field: ‘conditions’
[17:37:40.491]   - Field: ‘persistent’
[17:37:40.491]   - Field: ‘expr’
[17:37:40.491]   - Field: ‘uuid’
[17:37:40.491]   - Field: ‘seed’
[17:37:40.491]   - Field: ‘version’
[17:37:40.491]   - Field: ‘result’
[17:37:40.491]   - Field: ‘asynchronous’
[17:37:40.491]   - Field: ‘calls’
[17:37:40.492]   - Field: ‘globals’
[17:37:40.492]   - Field: ‘stdout’
[17:37:40.492]   - Field: ‘earlySignal’
[17:37:40.492]   - Field: ‘lazy’
[17:37:40.492]   - Field: ‘state’
[17:37:40.492] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:40.492] - Launch lazy future ...
[17:37:40.492] Packages needed by the future expression (n = 0): <none>
[17:37:40.493] Packages needed by future strategies (n = 0): <none>
[17:37:40.493] {
[17:37:40.493]     {
[17:37:40.493]         {
[17:37:40.493]             ...future.startTime <- base::Sys.time()
[17:37:40.493]             {
[17:37:40.493]                 {
[17:37:40.493]                   {
[17:37:40.493]                     {
[17:37:40.493]                       base::local({
[17:37:40.493]                         has_future <- base::requireNamespace("future", 
[17:37:40.493]                           quietly = TRUE)
[17:37:40.493]                         if (has_future) {
[17:37:40.493]                           ns <- base::getNamespace("future")
[17:37:40.493]                           version <- ns[[".package"]][["version"]]
[17:37:40.493]                           if (is.null(version)) 
[17:37:40.493]                             version <- utils::packageVersion("future")
[17:37:40.493]                         }
[17:37:40.493]                         else {
[17:37:40.493]                           version <- NULL
[17:37:40.493]                         }
[17:37:40.493]                         if (!has_future || version < "1.8.0") {
[17:37:40.493]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:40.493]                             "", base::R.version$version.string), 
[17:37:40.493]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:40.493]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:40.493]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:40.493]                               "release", "version")], collapse = " "), 
[17:37:40.493]                             hostname = base::Sys.info()[["nodename"]])
[17:37:40.493]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:40.493]                             info)
[17:37:40.493]                           info <- base::paste(info, collapse = "; ")
[17:37:40.493]                           if (!has_future) {
[17:37:40.493]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:40.493]                               info)
[17:37:40.493]                           }
[17:37:40.493]                           else {
[17:37:40.493]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:40.493]                               info, version)
[17:37:40.493]                           }
[17:37:40.493]                           base::stop(msg)
[17:37:40.493]                         }
[17:37:40.493]                       })
[17:37:40.493]                     }
[17:37:40.493]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:40.493]                     base::options(mc.cores = 1L)
[17:37:40.493]                   }
[17:37:40.493]                   ...future.strategy.old <- future::plan("list")
[17:37:40.493]                   options(future.plan = NULL)
[17:37:40.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:40.493]                 }
[17:37:40.493]                 ...future.workdir <- getwd()
[17:37:40.493]             }
[17:37:40.493]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:40.493]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:40.493]         }
[17:37:40.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:40.493]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:40.493]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:40.493]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:40.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:40.493]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:40.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:40.493]             base::names(...future.oldOptions))
[17:37:40.493]     }
[17:37:40.493]     if (FALSE) {
[17:37:40.493]     }
[17:37:40.493]     else {
[17:37:40.493]         if (TRUE) {
[17:37:40.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:40.493]                 open = "w")
[17:37:40.493]         }
[17:37:40.493]         else {
[17:37:40.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:40.493]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:40.493]         }
[17:37:40.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:40.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:40.493]             base::sink(type = "output", split = FALSE)
[17:37:40.493]             base::close(...future.stdout)
[17:37:40.493]         }, add = TRUE)
[17:37:40.493]     }
[17:37:40.493]     ...future.frame <- base::sys.nframe()
[17:37:40.493]     ...future.conditions <- base::list()
[17:37:40.493]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:40.493]     if (FALSE) {
[17:37:40.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:40.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:40.493]     }
[17:37:40.493]     ...future.result <- base::tryCatch({
[17:37:40.493]         base::withCallingHandlers({
[17:37:40.493]             ...future.value <- base::withVisible(base::local({
[17:37:40.493]                 ...future.makeSendCondition <- base::local({
[17:37:40.493]                   sendCondition <- NULL
[17:37:40.493]                   function(frame = 1L) {
[17:37:40.493]                     if (is.function(sendCondition)) 
[17:37:40.493]                       return(sendCondition)
[17:37:40.493]                     ns <- getNamespace("parallel")
[17:37:40.493]                     if (exists("sendData", mode = "function", 
[17:37:40.493]                       envir = ns)) {
[17:37:40.493]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:40.493]                         envir = ns)
[17:37:40.493]                       envir <- sys.frame(frame)
[17:37:40.493]                       master <- NULL
[17:37:40.493]                       while (!identical(envir, .GlobalEnv) && 
[17:37:40.493]                         !identical(envir, emptyenv())) {
[17:37:40.493]                         if (exists("master", mode = "list", envir = envir, 
[17:37:40.493]                           inherits = FALSE)) {
[17:37:40.493]                           master <- get("master", mode = "list", 
[17:37:40.493]                             envir = envir, inherits = FALSE)
[17:37:40.493]                           if (inherits(master, c("SOCKnode", 
[17:37:40.493]                             "SOCK0node"))) {
[17:37:40.493]                             sendCondition <<- function(cond) {
[17:37:40.493]                               data <- list(type = "VALUE", value = cond, 
[17:37:40.493]                                 success = TRUE)
[17:37:40.493]                               parallel_sendData(master, data)
[17:37:40.493]                             }
[17:37:40.493]                             return(sendCondition)
[17:37:40.493]                           }
[17:37:40.493]                         }
[17:37:40.493]                         frame <- frame + 1L
[17:37:40.493]                         envir <- sys.frame(frame)
[17:37:40.493]                       }
[17:37:40.493]                     }
[17:37:40.493]                     sendCondition <<- function(cond) NULL
[17:37:40.493]                   }
[17:37:40.493]                 })
[17:37:40.493]                 withCallingHandlers({
[17:37:40.493]                   {
[17:37:40.493]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.493]                     if (!identical(...future.globals.maxSize.org, 
[17:37:40.493]                       ...future.globals.maxSize)) {
[17:37:40.493]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.493]                       on.exit(options(oopts), add = TRUE)
[17:37:40.493]                     }
[17:37:40.493]                     {
[17:37:40.493]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.493]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:40.493]                         USE.NAMES = FALSE)
[17:37:40.493]                       do.call(mapply, args = args)
[17:37:40.493]                     }
[17:37:40.493]                   }
[17:37:40.493]                 }, immediateCondition = function(cond) {
[17:37:40.493]                   sendCondition <- ...future.makeSendCondition()
[17:37:40.493]                   sendCondition(cond)
[17:37:40.493]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.493]                   {
[17:37:40.493]                     inherits <- base::inherits
[17:37:40.493]                     invokeRestart <- base::invokeRestart
[17:37:40.493]                     is.null <- base::is.null
[17:37:40.493]                     muffled <- FALSE
[17:37:40.493]                     if (inherits(cond, "message")) {
[17:37:40.493]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:40.493]                       if (muffled) 
[17:37:40.493]                         invokeRestart("muffleMessage")
[17:37:40.493]                     }
[17:37:40.493]                     else if (inherits(cond, "warning")) {
[17:37:40.493]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:40.493]                       if (muffled) 
[17:37:40.493]                         invokeRestart("muffleWarning")
[17:37:40.493]                     }
[17:37:40.493]                     else if (inherits(cond, "condition")) {
[17:37:40.493]                       if (!is.null(pattern)) {
[17:37:40.493]                         computeRestarts <- base::computeRestarts
[17:37:40.493]                         grepl <- base::grepl
[17:37:40.493]                         restarts <- computeRestarts(cond)
[17:37:40.493]                         for (restart in restarts) {
[17:37:40.493]                           name <- restart$name
[17:37:40.493]                           if (is.null(name)) 
[17:37:40.493]                             next
[17:37:40.493]                           if (!grepl(pattern, name)) 
[17:37:40.493]                             next
[17:37:40.493]                           invokeRestart(restart)
[17:37:40.493]                           muffled <- TRUE
[17:37:40.493]                           break
[17:37:40.493]                         }
[17:37:40.493]                       }
[17:37:40.493]                     }
[17:37:40.493]                     invisible(muffled)
[17:37:40.493]                   }
[17:37:40.493]                   muffleCondition(cond)
[17:37:40.493]                 })
[17:37:40.493]             }))
[17:37:40.493]             future::FutureResult(value = ...future.value$value, 
[17:37:40.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.493]                   ...future.rng), globalenv = if (FALSE) 
[17:37:40.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:40.493]                     ...future.globalenv.names))
[17:37:40.493]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:40.493]         }, condition = base::local({
[17:37:40.493]             c <- base::c
[17:37:40.493]             inherits <- base::inherits
[17:37:40.493]             invokeRestart <- base::invokeRestart
[17:37:40.493]             length <- base::length
[17:37:40.493]             list <- base::list
[17:37:40.493]             seq.int <- base::seq.int
[17:37:40.493]             signalCondition <- base::signalCondition
[17:37:40.493]             sys.calls <- base::sys.calls
[17:37:40.493]             `[[` <- base::`[[`
[17:37:40.493]             `+` <- base::`+`
[17:37:40.493]             `<<-` <- base::`<<-`
[17:37:40.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:40.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:40.493]                   3L)]
[17:37:40.493]             }
[17:37:40.493]             function(cond) {
[17:37:40.493]                 is_error <- inherits(cond, "error")
[17:37:40.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:40.493]                   NULL)
[17:37:40.493]                 if (is_error) {
[17:37:40.493]                   sessionInformation <- function() {
[17:37:40.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:40.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:40.493]                       search = base::search(), system = base::Sys.info())
[17:37:40.493]                   }
[17:37:40.493]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:40.493]                     cond$call), session = sessionInformation(), 
[17:37:40.493]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:40.493]                   signalCondition(cond)
[17:37:40.493]                 }
[17:37:40.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:40.493]                 "immediateCondition"))) {
[17:37:40.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:40.493]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:40.493]                   if (TRUE && !signal) {
[17:37:40.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.493]                     {
[17:37:40.493]                       inherits <- base::inherits
[17:37:40.493]                       invokeRestart <- base::invokeRestart
[17:37:40.493]                       is.null <- base::is.null
[17:37:40.493]                       muffled <- FALSE
[17:37:40.493]                       if (inherits(cond, "message")) {
[17:37:40.493]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.493]                         if (muffled) 
[17:37:40.493]                           invokeRestart("muffleMessage")
[17:37:40.493]                       }
[17:37:40.493]                       else if (inherits(cond, "warning")) {
[17:37:40.493]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.493]                         if (muffled) 
[17:37:40.493]                           invokeRestart("muffleWarning")
[17:37:40.493]                       }
[17:37:40.493]                       else if (inherits(cond, "condition")) {
[17:37:40.493]                         if (!is.null(pattern)) {
[17:37:40.493]                           computeRestarts <- base::computeRestarts
[17:37:40.493]                           grepl <- base::grepl
[17:37:40.493]                           restarts <- computeRestarts(cond)
[17:37:40.493]                           for (restart in restarts) {
[17:37:40.493]                             name <- restart$name
[17:37:40.493]                             if (is.null(name)) 
[17:37:40.493]                               next
[17:37:40.493]                             if (!grepl(pattern, name)) 
[17:37:40.493]                               next
[17:37:40.493]                             invokeRestart(restart)
[17:37:40.493]                             muffled <- TRUE
[17:37:40.493]                             break
[17:37:40.493]                           }
[17:37:40.493]                         }
[17:37:40.493]                       }
[17:37:40.493]                       invisible(muffled)
[17:37:40.493]                     }
[17:37:40.493]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.493]                   }
[17:37:40.493]                 }
[17:37:40.493]                 else {
[17:37:40.493]                   if (TRUE) {
[17:37:40.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.493]                     {
[17:37:40.493]                       inherits <- base::inherits
[17:37:40.493]                       invokeRestart <- base::invokeRestart
[17:37:40.493]                       is.null <- base::is.null
[17:37:40.493]                       muffled <- FALSE
[17:37:40.493]                       if (inherits(cond, "message")) {
[17:37:40.493]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.493]                         if (muffled) 
[17:37:40.493]                           invokeRestart("muffleMessage")
[17:37:40.493]                       }
[17:37:40.493]                       else if (inherits(cond, "warning")) {
[17:37:40.493]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.493]                         if (muffled) 
[17:37:40.493]                           invokeRestart("muffleWarning")
[17:37:40.493]                       }
[17:37:40.493]                       else if (inherits(cond, "condition")) {
[17:37:40.493]                         if (!is.null(pattern)) {
[17:37:40.493]                           computeRestarts <- base::computeRestarts
[17:37:40.493]                           grepl <- base::grepl
[17:37:40.493]                           restarts <- computeRestarts(cond)
[17:37:40.493]                           for (restart in restarts) {
[17:37:40.493]                             name <- restart$name
[17:37:40.493]                             if (is.null(name)) 
[17:37:40.493]                               next
[17:37:40.493]                             if (!grepl(pattern, name)) 
[17:37:40.493]                               next
[17:37:40.493]                             invokeRestart(restart)
[17:37:40.493]                             muffled <- TRUE
[17:37:40.493]                             break
[17:37:40.493]                           }
[17:37:40.493]                         }
[17:37:40.493]                       }
[17:37:40.493]                       invisible(muffled)
[17:37:40.493]                     }
[17:37:40.493]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.493]                   }
[17:37:40.493]                 }
[17:37:40.493]             }
[17:37:40.493]         }))
[17:37:40.493]     }, error = function(ex) {
[17:37:40.493]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:40.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.493]                 ...future.rng), started = ...future.startTime, 
[17:37:40.493]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:40.493]             version = "1.8"), class = "FutureResult")
[17:37:40.493]     }, finally = {
[17:37:40.493]         if (!identical(...future.workdir, getwd())) 
[17:37:40.493]             setwd(...future.workdir)
[17:37:40.493]         {
[17:37:40.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:40.493]                 ...future.oldOptions$nwarnings <- NULL
[17:37:40.493]             }
[17:37:40.493]             base::options(...future.oldOptions)
[17:37:40.493]             if (.Platform$OS.type == "windows") {
[17:37:40.493]                 old_names <- names(...future.oldEnvVars)
[17:37:40.493]                 envs <- base::Sys.getenv()
[17:37:40.493]                 names <- names(envs)
[17:37:40.493]                 common <- intersect(names, old_names)
[17:37:40.493]                 added <- setdiff(names, old_names)
[17:37:40.493]                 removed <- setdiff(old_names, names)
[17:37:40.493]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:40.493]                   envs[common]]
[17:37:40.493]                 NAMES <- toupper(changed)
[17:37:40.493]                 args <- list()
[17:37:40.493]                 for (kk in seq_along(NAMES)) {
[17:37:40.493]                   name <- changed[[kk]]
[17:37:40.493]                   NAME <- NAMES[[kk]]
[17:37:40.493]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.493]                     next
[17:37:40.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.493]                 }
[17:37:40.493]                 NAMES <- toupper(added)
[17:37:40.493]                 for (kk in seq_along(NAMES)) {
[17:37:40.493]                   name <- added[[kk]]
[17:37:40.493]                   NAME <- NAMES[[kk]]
[17:37:40.493]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.493]                     next
[17:37:40.493]                   args[[name]] <- ""
[17:37:40.493]                 }
[17:37:40.493]                 NAMES <- toupper(removed)
[17:37:40.493]                 for (kk in seq_along(NAMES)) {
[17:37:40.493]                   name <- removed[[kk]]
[17:37:40.493]                   NAME <- NAMES[[kk]]
[17:37:40.493]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.493]                     next
[17:37:40.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.493]                 }
[17:37:40.493]                 if (length(args) > 0) 
[17:37:40.493]                   base::do.call(base::Sys.setenv, args = args)
[17:37:40.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:40.493]             }
[17:37:40.493]             else {
[17:37:40.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:40.493]             }
[17:37:40.493]             {
[17:37:40.493]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:40.493]                   0L) {
[17:37:40.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:40.493]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:40.493]                   base::options(opts)
[17:37:40.493]                 }
[17:37:40.493]                 {
[17:37:40.493]                   {
[17:37:40.493]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:40.493]                     NULL
[17:37:40.493]                   }
[17:37:40.493]                   options(future.plan = NULL)
[17:37:40.493]                   if (is.na(NA_character_)) 
[17:37:40.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:40.493]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:40.493]                     .init = FALSE)
[17:37:40.493]                 }
[17:37:40.493]             }
[17:37:40.493]         }
[17:37:40.493]     })
[17:37:40.493]     if (TRUE) {
[17:37:40.493]         base::sink(type = "output", split = FALSE)
[17:37:40.493]         if (TRUE) {
[17:37:40.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:40.493]         }
[17:37:40.493]         else {
[17:37:40.493]             ...future.result["stdout"] <- base::list(NULL)
[17:37:40.493]         }
[17:37:40.493]         base::close(...future.stdout)
[17:37:40.493]         ...future.stdout <- NULL
[17:37:40.493]     }
[17:37:40.493]     ...future.result$conditions <- ...future.conditions
[17:37:40.493]     ...future.result$finished <- base::Sys.time()
[17:37:40.493]     ...future.result
[17:37:40.493] }
[17:37:40.496] Exporting 5 global objects (1.77 KiB) to cluster node #2 ...
[17:37:40.496] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[17:37:40.496] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[17:37:40.496] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[17:37:40.497] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[17:37:40.497] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:37:40.497] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:37:40.497] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:37:40.498] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:37:40.498] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:37:40.498] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:37:40.498] Exporting 5 global objects (1.77 KiB) to cluster node #2 ... DONE
[17:37:40.499] MultisessionFuture started
[17:37:40.499] - Launch lazy future ... done
[17:37:40.499] run() for ‘MultisessionFuture’ ... done
[17:37:40.499] Created future:
[17:37:40.499] MultisessionFuture:
[17:37:40.499] Label: ‘future_.mapply-2’
[17:37:40.499] Expression:
[17:37:40.499] {
[17:37:40.499]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.499]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:40.499]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.499]         on.exit(options(oopts), add = TRUE)
[17:37:40.499]     }
[17:37:40.499]     {
[17:37:40.499]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.499]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:40.499]         do.call(mapply, args = args)
[17:37:40.499]     }
[17:37:40.499] }
[17:37:40.499] Lazy evaluation: FALSE
[17:37:40.499] Asynchronous evaluation: TRUE
[17:37:40.499] Local evaluation: TRUE
[17:37:40.499] Environment: R_GlobalEnv
[17:37:40.499] Capture standard output: TRUE
[17:37:40.499] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:40.499] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:40.499] Packages: <none>
[17:37:40.499] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:40.499] Resolved: FALSE
[17:37:40.499] Value: <not collected>
[17:37:40.499] Conditions captured: <none>
[17:37:40.499] Early signaling: FALSE
[17:37:40.499] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:40.499] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.510] Chunk #2 of 2 ... DONE
[17:37:40.510] Launching 2 futures (chunks) ... DONE
[17:37:40.511] Resolving 2 futures (chunks) ...
[17:37:40.511] resolve() on list ...
[17:37:40.511]  recursive: 0
[17:37:40.511]  length: 2
[17:37:40.511] 
[17:37:40.512] receiveMessageFromWorker() for ClusterFuture ...
[17:37:40.512] - Validating connection of MultisessionFuture
[17:37:40.512] - received message: FutureResult
[17:37:40.512] - Received FutureResult
[17:37:40.512] - Erased future from FutureRegistry
[17:37:40.512] result() for ClusterFuture ...
[17:37:40.512] - result already collected: FutureResult
[17:37:40.512] result() for ClusterFuture ... done
[17:37:40.513] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:40.513] Future #1
[17:37:40.513] result() for ClusterFuture ...
[17:37:40.513] - result already collected: FutureResult
[17:37:40.513] result() for ClusterFuture ... done
[17:37:40.513] result() for ClusterFuture ...
[17:37:40.513] - result already collected: FutureResult
[17:37:40.513] result() for ClusterFuture ... done
[17:37:40.513] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:37:40.513] - nx: 2
[17:37:40.513] - relay: TRUE
[17:37:40.514] - stdout: TRUE
[17:37:40.514] - signal: TRUE
[17:37:40.514] - resignal: FALSE
[17:37:40.514] - force: TRUE
[17:37:40.514] - relayed: [n=2] FALSE, FALSE
[17:37:40.514] - queued futures: [n=2] FALSE, FALSE
[17:37:40.514]  - until=1
[17:37:40.514]  - relaying element #1
[17:37:40.514] result() for ClusterFuture ...
[17:37:40.514] - result already collected: FutureResult
[17:37:40.514] result() for ClusterFuture ... done
[17:37:40.514] result() for ClusterFuture ...
[17:37:40.515] - result already collected: FutureResult
[17:37:40.515] result() for ClusterFuture ... done
[17:37:40.515] result() for ClusterFuture ...
[17:37:40.515] - result already collected: FutureResult
[17:37:40.515] result() for ClusterFuture ... done
[17:37:40.515] result() for ClusterFuture ...
[17:37:40.515] - result already collected: FutureResult
[17:37:40.515] result() for ClusterFuture ... done
[17:37:40.515] - relayed: [n=2] TRUE, FALSE
[17:37:40.515] - queued futures: [n=2] TRUE, FALSE
[17:37:40.515] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:37:40.516]  length: 1 (resolved future 1)
[17:37:40.542] receiveMessageFromWorker() for ClusterFuture ...
[17:37:40.542] - Validating connection of MultisessionFuture
[17:37:40.542] - received message: FutureResult
[17:37:40.542] - Received FutureResult
[17:37:40.542] - Erased future from FutureRegistry
[17:37:40.542] result() for ClusterFuture ...
[17:37:40.543] - result already collected: FutureResult
[17:37:40.543] result() for ClusterFuture ... done
[17:37:40.543] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:40.543] Future #2
[17:37:40.543] result() for ClusterFuture ...
[17:37:40.543] - result already collected: FutureResult
[17:37:40.543] result() for ClusterFuture ... done
[17:37:40.543] result() for ClusterFuture ...
[17:37:40.543] - result already collected: FutureResult
[17:37:40.543] result() for ClusterFuture ... done
[17:37:40.543] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:37:40.544] - nx: 2
[17:37:40.544] - relay: TRUE
[17:37:40.544] - stdout: TRUE
[17:37:40.544] - signal: TRUE
[17:37:40.544] - resignal: FALSE
[17:37:40.544] - force: TRUE
[17:37:40.544] - relayed: [n=2] TRUE, FALSE
[17:37:40.544] - queued futures: [n=2] TRUE, FALSE
[17:37:40.544]  - until=2
[17:37:40.544]  - relaying element #2
[17:37:40.544] result() for ClusterFuture ...
[17:37:40.545] - result already collected: FutureResult
[17:37:40.545] result() for ClusterFuture ... done
[17:37:40.545] result() for ClusterFuture ...
[17:37:40.545] - result already collected: FutureResult
[17:37:40.545] result() for ClusterFuture ... done
[17:37:40.545] result() for ClusterFuture ...
[17:37:40.545] - result already collected: FutureResult
[17:37:40.545] result() for ClusterFuture ... done
[17:37:40.545] result() for ClusterFuture ...
[17:37:40.545] - result already collected: FutureResult
[17:37:40.545] result() for ClusterFuture ... done
[17:37:40.546] - relayed: [n=2] TRUE, TRUE
[17:37:40.546] - queued futures: [n=2] TRUE, TRUE
[17:37:40.546] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:37:40.546]  length: 0 (resolved future 2)
[17:37:40.546] Relaying remaining futures
[17:37:40.546] signalConditionsASAP(NULL, pos=0) ...
[17:37:40.546] - nx: 2
[17:37:40.546] - relay: TRUE
[17:37:40.546] - stdout: TRUE
[17:37:40.546] - signal: TRUE
[17:37:40.546] - resignal: FALSE
[17:37:40.547] - force: TRUE
[17:37:40.547] - relayed: [n=2] TRUE, TRUE
[17:37:40.547] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:40.547] - relayed: [n=2] TRUE, TRUE
[17:37:40.547] - queued futures: [n=2] TRUE, TRUE
[17:37:40.547] signalConditionsASAP(NULL, pos=0) ... done
[17:37:40.547] resolve() on list ... DONE
[17:37:40.547] result() for ClusterFuture ...
[17:37:40.547] - result already collected: FutureResult
[17:37:40.547] result() for ClusterFuture ... done
[17:37:40.547] result() for ClusterFuture ...
[17:37:40.547] - result already collected: FutureResult
[17:37:40.548] result() for ClusterFuture ... done
[17:37:40.548] result() for ClusterFuture ...
[17:37:40.548] - result already collected: FutureResult
[17:37:40.548] result() for ClusterFuture ... done
[17:37:40.548] result() for ClusterFuture ...
[17:37:40.548] - result already collected: FutureResult
[17:37:40.548] result() for ClusterFuture ... done
[17:37:40.548]  - Number of value chunks collected: 2
[17:37:40.548] Resolving 2 futures (chunks) ... DONE
[17:37:40.548] Reducing values from 2 chunks ...
[17:37:40.549]  - Number of values collected after concatenation: 2
[17:37:40.549]  - Number of values expected: 2
[17:37:40.549] Reducing values from 2 chunks ... DONE
[17:37:40.549] future_mapply() ... DONE
- Recycle arguments to same length ...
[17:37:40.549] future_mapply() ...
[17:37:40.553] Number of chunks: 2
[17:37:40.553] getGlobalsAndPackagesXApply() ...
[17:37:40.553]  - future.globals: TRUE
[17:37:40.553] getGlobalsAndPackages() ...
[17:37:40.553] Searching for globals...
[17:37:40.556] - globals found: [1] ‘FUN’
[17:37:40.556] Searching for globals ... DONE
[17:37:40.556] Resolving globals: FALSE
[17:37:40.557] The total size of the 1 globals is 56 bytes (56 bytes)
[17:37:40.557] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:37:40.557] - globals: [1] ‘FUN’
[17:37:40.557] 
[17:37:40.557] getGlobalsAndPackages() ... DONE
[17:37:40.557]  - globals found/used: [n=1] ‘FUN’
[17:37:40.558]  - needed namespaces: [n=0] 
[17:37:40.558] Finding globals ... DONE
[17:37:40.558] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:40.558] List of 2
[17:37:40.558]  $ ...future.FUN:function (x, ...)  
[17:37:40.558]  $ MoreArgs     : NULL
[17:37:40.558]  - attr(*, "where")=List of 2
[17:37:40.558]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:40.558]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:40.558]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:40.558]  - attr(*, "resolved")= logi FALSE
[17:37:40.558]  - attr(*, "total_size")= num NA
[17:37:40.560] Packages to be attached in all futures: [n=0] 
[17:37:40.560] getGlobalsAndPackagesXApply() ... DONE
[17:37:40.561] Number of futures (= number of chunks): 2
[17:37:40.561] Launching 2 futures (chunks) ...
[17:37:40.561] Chunk #1 of 2 ...
[17:37:40.561]  - Finding globals in '...' for chunk #1 ...
[17:37:40.561] getGlobalsAndPackages() ...
[17:37:40.561] Searching for globals...
[17:37:40.561] 
[17:37:40.562] Searching for globals ... DONE
[17:37:40.562] - globals: [0] <none>
[17:37:40.562] getGlobalsAndPackages() ... DONE
[17:37:40.562]    + additional globals found: [n=0] 
[17:37:40.562]    + additional namespaces needed: [n=0] 
[17:37:40.562]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:40.562]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:40.562]  - seeds: <none>
[17:37:40.562]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.562] getGlobalsAndPackages() ...
[17:37:40.562] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.563] Resolving globals: FALSE
[17:37:40.563] The total size of the 5 globals is 280 bytes (280 bytes)
[17:37:40.563] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:40.563] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.564] 
[17:37:40.564] getGlobalsAndPackages() ... DONE
[17:37:40.564] run() for ‘Future’ ...
[17:37:40.564] - state: ‘created’
[17:37:40.564] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:40.578] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.578] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:40.578]   - Field: ‘node’
[17:37:40.578]   - Field: ‘label’
[17:37:40.578]   - Field: ‘local’
[17:37:40.578]   - Field: ‘owner’
[17:37:40.578]   - Field: ‘envir’
[17:37:40.578]   - Field: ‘workers’
[17:37:40.578]   - Field: ‘packages’
[17:37:40.579]   - Field: ‘gc’
[17:37:40.579]   - Field: ‘conditions’
[17:37:40.579]   - Field: ‘persistent’
[17:37:40.579]   - Field: ‘expr’
[17:37:40.579]   - Field: ‘uuid’
[17:37:40.579]   - Field: ‘seed’
[17:37:40.579]   - Field: ‘version’
[17:37:40.579]   - Field: ‘result’
[17:37:40.579]   - Field: ‘asynchronous’
[17:37:40.579]   - Field: ‘calls’
[17:37:40.579]   - Field: ‘globals’
[17:37:40.580]   - Field: ‘stdout’
[17:37:40.580]   - Field: ‘earlySignal’
[17:37:40.580]   - Field: ‘lazy’
[17:37:40.580]   - Field: ‘state’
[17:37:40.580] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:40.580] - Launch lazy future ...
[17:37:40.580] Packages needed by the future expression (n = 0): <none>
[17:37:40.580] Packages needed by future strategies (n = 0): <none>
[17:37:40.581] {
[17:37:40.581]     {
[17:37:40.581]         {
[17:37:40.581]             ...future.startTime <- base::Sys.time()
[17:37:40.581]             {
[17:37:40.581]                 {
[17:37:40.581]                   {
[17:37:40.581]                     {
[17:37:40.581]                       base::local({
[17:37:40.581]                         has_future <- base::requireNamespace("future", 
[17:37:40.581]                           quietly = TRUE)
[17:37:40.581]                         if (has_future) {
[17:37:40.581]                           ns <- base::getNamespace("future")
[17:37:40.581]                           version <- ns[[".package"]][["version"]]
[17:37:40.581]                           if (is.null(version)) 
[17:37:40.581]                             version <- utils::packageVersion("future")
[17:37:40.581]                         }
[17:37:40.581]                         else {
[17:37:40.581]                           version <- NULL
[17:37:40.581]                         }
[17:37:40.581]                         if (!has_future || version < "1.8.0") {
[17:37:40.581]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:40.581]                             "", base::R.version$version.string), 
[17:37:40.581]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:40.581]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:40.581]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:40.581]                               "release", "version")], collapse = " "), 
[17:37:40.581]                             hostname = base::Sys.info()[["nodename"]])
[17:37:40.581]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:40.581]                             info)
[17:37:40.581]                           info <- base::paste(info, collapse = "; ")
[17:37:40.581]                           if (!has_future) {
[17:37:40.581]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:40.581]                               info)
[17:37:40.581]                           }
[17:37:40.581]                           else {
[17:37:40.581]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:40.581]                               info, version)
[17:37:40.581]                           }
[17:37:40.581]                           base::stop(msg)
[17:37:40.581]                         }
[17:37:40.581]                       })
[17:37:40.581]                     }
[17:37:40.581]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:40.581]                     base::options(mc.cores = 1L)
[17:37:40.581]                   }
[17:37:40.581]                   ...future.strategy.old <- future::plan("list")
[17:37:40.581]                   options(future.plan = NULL)
[17:37:40.581]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.581]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:40.581]                 }
[17:37:40.581]                 ...future.workdir <- getwd()
[17:37:40.581]             }
[17:37:40.581]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:40.581]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:40.581]         }
[17:37:40.581]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:40.581]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:40.581]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:40.581]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:40.581]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:40.581]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:40.581]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:40.581]             base::names(...future.oldOptions))
[17:37:40.581]     }
[17:37:40.581]     if (FALSE) {
[17:37:40.581]     }
[17:37:40.581]     else {
[17:37:40.581]         if (TRUE) {
[17:37:40.581]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:40.581]                 open = "w")
[17:37:40.581]         }
[17:37:40.581]         else {
[17:37:40.581]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:40.581]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:40.581]         }
[17:37:40.581]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:40.581]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:40.581]             base::sink(type = "output", split = FALSE)
[17:37:40.581]             base::close(...future.stdout)
[17:37:40.581]         }, add = TRUE)
[17:37:40.581]     }
[17:37:40.581]     ...future.frame <- base::sys.nframe()
[17:37:40.581]     ...future.conditions <- base::list()
[17:37:40.581]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:40.581]     if (FALSE) {
[17:37:40.581]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:40.581]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:40.581]     }
[17:37:40.581]     ...future.result <- base::tryCatch({
[17:37:40.581]         base::withCallingHandlers({
[17:37:40.581]             ...future.value <- base::withVisible(base::local({
[17:37:40.581]                 ...future.makeSendCondition <- base::local({
[17:37:40.581]                   sendCondition <- NULL
[17:37:40.581]                   function(frame = 1L) {
[17:37:40.581]                     if (is.function(sendCondition)) 
[17:37:40.581]                       return(sendCondition)
[17:37:40.581]                     ns <- getNamespace("parallel")
[17:37:40.581]                     if (exists("sendData", mode = "function", 
[17:37:40.581]                       envir = ns)) {
[17:37:40.581]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:40.581]                         envir = ns)
[17:37:40.581]                       envir <- sys.frame(frame)
[17:37:40.581]                       master <- NULL
[17:37:40.581]                       while (!identical(envir, .GlobalEnv) && 
[17:37:40.581]                         !identical(envir, emptyenv())) {
[17:37:40.581]                         if (exists("master", mode = "list", envir = envir, 
[17:37:40.581]                           inherits = FALSE)) {
[17:37:40.581]                           master <- get("master", mode = "list", 
[17:37:40.581]                             envir = envir, inherits = FALSE)
[17:37:40.581]                           if (inherits(master, c("SOCKnode", 
[17:37:40.581]                             "SOCK0node"))) {
[17:37:40.581]                             sendCondition <<- function(cond) {
[17:37:40.581]                               data <- list(type = "VALUE", value = cond, 
[17:37:40.581]                                 success = TRUE)
[17:37:40.581]                               parallel_sendData(master, data)
[17:37:40.581]                             }
[17:37:40.581]                             return(sendCondition)
[17:37:40.581]                           }
[17:37:40.581]                         }
[17:37:40.581]                         frame <- frame + 1L
[17:37:40.581]                         envir <- sys.frame(frame)
[17:37:40.581]                       }
[17:37:40.581]                     }
[17:37:40.581]                     sendCondition <<- function(cond) NULL
[17:37:40.581]                   }
[17:37:40.581]                 })
[17:37:40.581]                 withCallingHandlers({
[17:37:40.581]                   {
[17:37:40.581]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.581]                     if (!identical(...future.globals.maxSize.org, 
[17:37:40.581]                       ...future.globals.maxSize)) {
[17:37:40.581]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.581]                       on.exit(options(oopts), add = TRUE)
[17:37:40.581]                     }
[17:37:40.581]                     {
[17:37:40.581]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.581]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:40.581]                         USE.NAMES = FALSE)
[17:37:40.581]                       do.call(mapply, args = args)
[17:37:40.581]                     }
[17:37:40.581]                   }
[17:37:40.581]                 }, immediateCondition = function(cond) {
[17:37:40.581]                   sendCondition <- ...future.makeSendCondition()
[17:37:40.581]                   sendCondition(cond)
[17:37:40.581]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.581]                   {
[17:37:40.581]                     inherits <- base::inherits
[17:37:40.581]                     invokeRestart <- base::invokeRestart
[17:37:40.581]                     is.null <- base::is.null
[17:37:40.581]                     muffled <- FALSE
[17:37:40.581]                     if (inherits(cond, "message")) {
[17:37:40.581]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:40.581]                       if (muffled) 
[17:37:40.581]                         invokeRestart("muffleMessage")
[17:37:40.581]                     }
[17:37:40.581]                     else if (inherits(cond, "warning")) {
[17:37:40.581]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:40.581]                       if (muffled) 
[17:37:40.581]                         invokeRestart("muffleWarning")
[17:37:40.581]                     }
[17:37:40.581]                     else if (inherits(cond, "condition")) {
[17:37:40.581]                       if (!is.null(pattern)) {
[17:37:40.581]                         computeRestarts <- base::computeRestarts
[17:37:40.581]                         grepl <- base::grepl
[17:37:40.581]                         restarts <- computeRestarts(cond)
[17:37:40.581]                         for (restart in restarts) {
[17:37:40.581]                           name <- restart$name
[17:37:40.581]                           if (is.null(name)) 
[17:37:40.581]                             next
[17:37:40.581]                           if (!grepl(pattern, name)) 
[17:37:40.581]                             next
[17:37:40.581]                           invokeRestart(restart)
[17:37:40.581]                           muffled <- TRUE
[17:37:40.581]                           break
[17:37:40.581]                         }
[17:37:40.581]                       }
[17:37:40.581]                     }
[17:37:40.581]                     invisible(muffled)
[17:37:40.581]                   }
[17:37:40.581]                   muffleCondition(cond)
[17:37:40.581]                 })
[17:37:40.581]             }))
[17:37:40.581]             future::FutureResult(value = ...future.value$value, 
[17:37:40.581]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.581]                   ...future.rng), globalenv = if (FALSE) 
[17:37:40.581]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:40.581]                     ...future.globalenv.names))
[17:37:40.581]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:40.581]         }, condition = base::local({
[17:37:40.581]             c <- base::c
[17:37:40.581]             inherits <- base::inherits
[17:37:40.581]             invokeRestart <- base::invokeRestart
[17:37:40.581]             length <- base::length
[17:37:40.581]             list <- base::list
[17:37:40.581]             seq.int <- base::seq.int
[17:37:40.581]             signalCondition <- base::signalCondition
[17:37:40.581]             sys.calls <- base::sys.calls
[17:37:40.581]             `[[` <- base::`[[`
[17:37:40.581]             `+` <- base::`+`
[17:37:40.581]             `<<-` <- base::`<<-`
[17:37:40.581]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:40.581]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:40.581]                   3L)]
[17:37:40.581]             }
[17:37:40.581]             function(cond) {
[17:37:40.581]                 is_error <- inherits(cond, "error")
[17:37:40.581]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:40.581]                   NULL)
[17:37:40.581]                 if (is_error) {
[17:37:40.581]                   sessionInformation <- function() {
[17:37:40.581]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:40.581]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:40.581]                       search = base::search(), system = base::Sys.info())
[17:37:40.581]                   }
[17:37:40.581]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.581]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:40.581]                     cond$call), session = sessionInformation(), 
[17:37:40.581]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:40.581]                   signalCondition(cond)
[17:37:40.581]                 }
[17:37:40.581]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:40.581]                 "immediateCondition"))) {
[17:37:40.581]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:40.581]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.581]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:40.581]                   if (TRUE && !signal) {
[17:37:40.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.581]                     {
[17:37:40.581]                       inherits <- base::inherits
[17:37:40.581]                       invokeRestart <- base::invokeRestart
[17:37:40.581]                       is.null <- base::is.null
[17:37:40.581]                       muffled <- FALSE
[17:37:40.581]                       if (inherits(cond, "message")) {
[17:37:40.581]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.581]                         if (muffled) 
[17:37:40.581]                           invokeRestart("muffleMessage")
[17:37:40.581]                       }
[17:37:40.581]                       else if (inherits(cond, "warning")) {
[17:37:40.581]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.581]                         if (muffled) 
[17:37:40.581]                           invokeRestart("muffleWarning")
[17:37:40.581]                       }
[17:37:40.581]                       else if (inherits(cond, "condition")) {
[17:37:40.581]                         if (!is.null(pattern)) {
[17:37:40.581]                           computeRestarts <- base::computeRestarts
[17:37:40.581]                           grepl <- base::grepl
[17:37:40.581]                           restarts <- computeRestarts(cond)
[17:37:40.581]                           for (restart in restarts) {
[17:37:40.581]                             name <- restart$name
[17:37:40.581]                             if (is.null(name)) 
[17:37:40.581]                               next
[17:37:40.581]                             if (!grepl(pattern, name)) 
[17:37:40.581]                               next
[17:37:40.581]                             invokeRestart(restart)
[17:37:40.581]                             muffled <- TRUE
[17:37:40.581]                             break
[17:37:40.581]                           }
[17:37:40.581]                         }
[17:37:40.581]                       }
[17:37:40.581]                       invisible(muffled)
[17:37:40.581]                     }
[17:37:40.581]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.581]                   }
[17:37:40.581]                 }
[17:37:40.581]                 else {
[17:37:40.581]                   if (TRUE) {
[17:37:40.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.581]                     {
[17:37:40.581]                       inherits <- base::inherits
[17:37:40.581]                       invokeRestart <- base::invokeRestart
[17:37:40.581]                       is.null <- base::is.null
[17:37:40.581]                       muffled <- FALSE
[17:37:40.581]                       if (inherits(cond, "message")) {
[17:37:40.581]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.581]                         if (muffled) 
[17:37:40.581]                           invokeRestart("muffleMessage")
[17:37:40.581]                       }
[17:37:40.581]                       else if (inherits(cond, "warning")) {
[17:37:40.581]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.581]                         if (muffled) 
[17:37:40.581]                           invokeRestart("muffleWarning")
[17:37:40.581]                       }
[17:37:40.581]                       else if (inherits(cond, "condition")) {
[17:37:40.581]                         if (!is.null(pattern)) {
[17:37:40.581]                           computeRestarts <- base::computeRestarts
[17:37:40.581]                           grepl <- base::grepl
[17:37:40.581]                           restarts <- computeRestarts(cond)
[17:37:40.581]                           for (restart in restarts) {
[17:37:40.581]                             name <- restart$name
[17:37:40.581]                             if (is.null(name)) 
[17:37:40.581]                               next
[17:37:40.581]                             if (!grepl(pattern, name)) 
[17:37:40.581]                               next
[17:37:40.581]                             invokeRestart(restart)
[17:37:40.581]                             muffled <- TRUE
[17:37:40.581]                             break
[17:37:40.581]                           }
[17:37:40.581]                         }
[17:37:40.581]                       }
[17:37:40.581]                       invisible(muffled)
[17:37:40.581]                     }
[17:37:40.581]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.581]                   }
[17:37:40.581]                 }
[17:37:40.581]             }
[17:37:40.581]         }))
[17:37:40.581]     }, error = function(ex) {
[17:37:40.581]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:40.581]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.581]                 ...future.rng), started = ...future.startTime, 
[17:37:40.581]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:40.581]             version = "1.8"), class = "FutureResult")
[17:37:40.581]     }, finally = {
[17:37:40.581]         if (!identical(...future.workdir, getwd())) 
[17:37:40.581]             setwd(...future.workdir)
[17:37:40.581]         {
[17:37:40.581]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:40.581]                 ...future.oldOptions$nwarnings <- NULL
[17:37:40.581]             }
[17:37:40.581]             base::options(...future.oldOptions)
[17:37:40.581]             if (.Platform$OS.type == "windows") {
[17:37:40.581]                 old_names <- names(...future.oldEnvVars)
[17:37:40.581]                 envs <- base::Sys.getenv()
[17:37:40.581]                 names <- names(envs)
[17:37:40.581]                 common <- intersect(names, old_names)
[17:37:40.581]                 added <- setdiff(names, old_names)
[17:37:40.581]                 removed <- setdiff(old_names, names)
[17:37:40.581]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:40.581]                   envs[common]]
[17:37:40.581]                 NAMES <- toupper(changed)
[17:37:40.581]                 args <- list()
[17:37:40.581]                 for (kk in seq_along(NAMES)) {
[17:37:40.581]                   name <- changed[[kk]]
[17:37:40.581]                   NAME <- NAMES[[kk]]
[17:37:40.581]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.581]                     next
[17:37:40.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.581]                 }
[17:37:40.581]                 NAMES <- toupper(added)
[17:37:40.581]                 for (kk in seq_along(NAMES)) {
[17:37:40.581]                   name <- added[[kk]]
[17:37:40.581]                   NAME <- NAMES[[kk]]
[17:37:40.581]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.581]                     next
[17:37:40.581]                   args[[name]] <- ""
[17:37:40.581]                 }
[17:37:40.581]                 NAMES <- toupper(removed)
[17:37:40.581]                 for (kk in seq_along(NAMES)) {
[17:37:40.581]                   name <- removed[[kk]]
[17:37:40.581]                   NAME <- NAMES[[kk]]
[17:37:40.581]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.581]                     next
[17:37:40.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.581]                 }
[17:37:40.581]                 if (length(args) > 0) 
[17:37:40.581]                   base::do.call(base::Sys.setenv, args = args)
[17:37:40.581]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:40.581]             }
[17:37:40.581]             else {
[17:37:40.581]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:40.581]             }
[17:37:40.581]             {
[17:37:40.581]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:40.581]                   0L) {
[17:37:40.581]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:40.581]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:40.581]                   base::options(opts)
[17:37:40.581]                 }
[17:37:40.581]                 {
[17:37:40.581]                   {
[17:37:40.581]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:40.581]                     NULL
[17:37:40.581]                   }
[17:37:40.581]                   options(future.plan = NULL)
[17:37:40.581]                   if (is.na(NA_character_)) 
[17:37:40.581]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.581]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:40.581]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:40.581]                     .init = FALSE)
[17:37:40.581]                 }
[17:37:40.581]             }
[17:37:40.581]         }
[17:37:40.581]     })
[17:37:40.581]     if (TRUE) {
[17:37:40.581]         base::sink(type = "output", split = FALSE)
[17:37:40.581]         if (TRUE) {
[17:37:40.581]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:40.581]         }
[17:37:40.581]         else {
[17:37:40.581]             ...future.result["stdout"] <- base::list(NULL)
[17:37:40.581]         }
[17:37:40.581]         base::close(...future.stdout)
[17:37:40.581]         ...future.stdout <- NULL
[17:37:40.581]     }
[17:37:40.581]     ...future.result$conditions <- ...future.conditions
[17:37:40.581]     ...future.result$finished <- base::Sys.time()
[17:37:40.581]     ...future.result
[17:37:40.581] }
[17:37:40.584] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[17:37:40.584] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[17:37:40.584] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[17:37:40.584] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:37:40.585] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:37:40.585] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[17:37:40.585] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[17:37:40.585] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:40.585] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:40.586] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:40.586] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:40.586] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[17:37:40.586] MultisessionFuture started
[17:37:40.587] - Launch lazy future ... done
[17:37:40.587] run() for ‘MultisessionFuture’ ... done
[17:37:40.587] Created future:
[17:37:40.587] MultisessionFuture:
[17:37:40.587] Label: ‘future_mapply-1’
[17:37:40.587] Expression:
[17:37:40.587] {
[17:37:40.587]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.587]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:40.587]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.587]         on.exit(options(oopts), add = TRUE)
[17:37:40.587]     }
[17:37:40.587]     {
[17:37:40.587]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.587]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:40.587]         do.call(mapply, args = args)
[17:37:40.587]     }
[17:37:40.587] }
[17:37:40.587] Lazy evaluation: FALSE
[17:37:40.587] Asynchronous evaluation: TRUE
[17:37:40.587] Local evaluation: TRUE
[17:37:40.587] Environment: R_GlobalEnv
[17:37:40.587] Capture standard output: TRUE
[17:37:40.587] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:40.587] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:40.587] Packages: <none>
[17:37:40.587] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:40.587] Resolved: FALSE
[17:37:40.587] Value: <not collected>
[17:37:40.587] Conditions captured: <none>
[17:37:40.587] Early signaling: FALSE
[17:37:40.587] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:40.587] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.598] Chunk #1 of 2 ... DONE
[17:37:40.598] Chunk #2 of 2 ...
[17:37:40.598]  - Finding globals in '...' for chunk #2 ...
[17:37:40.598] getGlobalsAndPackages() ...
[17:37:40.599] Searching for globals...
[17:37:40.599] 
[17:37:40.599] Searching for globals ... DONE
[17:37:40.599] - globals: [0] <none>
[17:37:40.599] getGlobalsAndPackages() ... DONE
[17:37:40.599]    + additional globals found: [n=0] 
[17:37:40.599]    + additional namespaces needed: [n=0] 
[17:37:40.599]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:40.600]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:40.600]  - seeds: <none>
[17:37:40.600]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.600] getGlobalsAndPackages() ...
[17:37:40.600] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.600] Resolving globals: FALSE
[17:37:40.601] The total size of the 5 globals is 280 bytes (280 bytes)
[17:37:40.601] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:40.601] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.601] 
[17:37:40.601] getGlobalsAndPackages() ... DONE
[17:37:40.602] run() for ‘Future’ ...
[17:37:40.602] - state: ‘created’
[17:37:40.602] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:40.615] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.615] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:40.615]   - Field: ‘node’
[17:37:40.615]   - Field: ‘label’
[17:37:40.616]   - Field: ‘local’
[17:37:40.616]   - Field: ‘owner’
[17:37:40.616]   - Field: ‘envir’
[17:37:40.616]   - Field: ‘workers’
[17:37:40.616]   - Field: ‘packages’
[17:37:40.616]   - Field: ‘gc’
[17:37:40.616]   - Field: ‘conditions’
[17:37:40.616]   - Field: ‘persistent’
[17:37:40.616]   - Field: ‘expr’
[17:37:40.616]   - Field: ‘uuid’
[17:37:40.616]   - Field: ‘seed’
[17:37:40.617]   - Field: ‘version’
[17:37:40.617]   - Field: ‘result’
[17:37:40.617]   - Field: ‘asynchronous’
[17:37:40.617]   - Field: ‘calls’
[17:37:40.617]   - Field: ‘globals’
[17:37:40.617]   - Field: ‘stdout’
[17:37:40.617]   - Field: ‘earlySignal’
[17:37:40.617]   - Field: ‘lazy’
[17:37:40.617]   - Field: ‘state’
[17:37:40.617] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:40.617] - Launch lazy future ...
[17:37:40.618] Packages needed by the future expression (n = 0): <none>
[17:37:40.618] Packages needed by future strategies (n = 0): <none>
[17:37:40.618] {
[17:37:40.618]     {
[17:37:40.618]         {
[17:37:40.618]             ...future.startTime <- base::Sys.time()
[17:37:40.618]             {
[17:37:40.618]                 {
[17:37:40.618]                   {
[17:37:40.618]                     {
[17:37:40.618]                       base::local({
[17:37:40.618]                         has_future <- base::requireNamespace("future", 
[17:37:40.618]                           quietly = TRUE)
[17:37:40.618]                         if (has_future) {
[17:37:40.618]                           ns <- base::getNamespace("future")
[17:37:40.618]                           version <- ns[[".package"]][["version"]]
[17:37:40.618]                           if (is.null(version)) 
[17:37:40.618]                             version <- utils::packageVersion("future")
[17:37:40.618]                         }
[17:37:40.618]                         else {
[17:37:40.618]                           version <- NULL
[17:37:40.618]                         }
[17:37:40.618]                         if (!has_future || version < "1.8.0") {
[17:37:40.618]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:40.618]                             "", base::R.version$version.string), 
[17:37:40.618]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:40.618]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:40.618]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:40.618]                               "release", "version")], collapse = " "), 
[17:37:40.618]                             hostname = base::Sys.info()[["nodename"]])
[17:37:40.618]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:40.618]                             info)
[17:37:40.618]                           info <- base::paste(info, collapse = "; ")
[17:37:40.618]                           if (!has_future) {
[17:37:40.618]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:40.618]                               info)
[17:37:40.618]                           }
[17:37:40.618]                           else {
[17:37:40.618]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:40.618]                               info, version)
[17:37:40.618]                           }
[17:37:40.618]                           base::stop(msg)
[17:37:40.618]                         }
[17:37:40.618]                       })
[17:37:40.618]                     }
[17:37:40.618]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:40.618]                     base::options(mc.cores = 1L)
[17:37:40.618]                   }
[17:37:40.618]                   ...future.strategy.old <- future::plan("list")
[17:37:40.618]                   options(future.plan = NULL)
[17:37:40.618]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.618]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:40.618]                 }
[17:37:40.618]                 ...future.workdir <- getwd()
[17:37:40.618]             }
[17:37:40.618]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:40.618]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:40.618]         }
[17:37:40.618]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:40.618]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:40.618]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:40.618]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:40.618]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:40.618]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:40.618]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:40.618]             base::names(...future.oldOptions))
[17:37:40.618]     }
[17:37:40.618]     if (FALSE) {
[17:37:40.618]     }
[17:37:40.618]     else {
[17:37:40.618]         if (TRUE) {
[17:37:40.618]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:40.618]                 open = "w")
[17:37:40.618]         }
[17:37:40.618]         else {
[17:37:40.618]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:40.618]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:40.618]         }
[17:37:40.618]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:40.618]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:40.618]             base::sink(type = "output", split = FALSE)
[17:37:40.618]             base::close(...future.stdout)
[17:37:40.618]         }, add = TRUE)
[17:37:40.618]     }
[17:37:40.618]     ...future.frame <- base::sys.nframe()
[17:37:40.618]     ...future.conditions <- base::list()
[17:37:40.618]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:40.618]     if (FALSE) {
[17:37:40.618]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:40.618]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:40.618]     }
[17:37:40.618]     ...future.result <- base::tryCatch({
[17:37:40.618]         base::withCallingHandlers({
[17:37:40.618]             ...future.value <- base::withVisible(base::local({
[17:37:40.618]                 ...future.makeSendCondition <- base::local({
[17:37:40.618]                   sendCondition <- NULL
[17:37:40.618]                   function(frame = 1L) {
[17:37:40.618]                     if (is.function(sendCondition)) 
[17:37:40.618]                       return(sendCondition)
[17:37:40.618]                     ns <- getNamespace("parallel")
[17:37:40.618]                     if (exists("sendData", mode = "function", 
[17:37:40.618]                       envir = ns)) {
[17:37:40.618]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:40.618]                         envir = ns)
[17:37:40.618]                       envir <- sys.frame(frame)
[17:37:40.618]                       master <- NULL
[17:37:40.618]                       while (!identical(envir, .GlobalEnv) && 
[17:37:40.618]                         !identical(envir, emptyenv())) {
[17:37:40.618]                         if (exists("master", mode = "list", envir = envir, 
[17:37:40.618]                           inherits = FALSE)) {
[17:37:40.618]                           master <- get("master", mode = "list", 
[17:37:40.618]                             envir = envir, inherits = FALSE)
[17:37:40.618]                           if (inherits(master, c("SOCKnode", 
[17:37:40.618]                             "SOCK0node"))) {
[17:37:40.618]                             sendCondition <<- function(cond) {
[17:37:40.618]                               data <- list(type = "VALUE", value = cond, 
[17:37:40.618]                                 success = TRUE)
[17:37:40.618]                               parallel_sendData(master, data)
[17:37:40.618]                             }
[17:37:40.618]                             return(sendCondition)
[17:37:40.618]                           }
[17:37:40.618]                         }
[17:37:40.618]                         frame <- frame + 1L
[17:37:40.618]                         envir <- sys.frame(frame)
[17:37:40.618]                       }
[17:37:40.618]                     }
[17:37:40.618]                     sendCondition <<- function(cond) NULL
[17:37:40.618]                   }
[17:37:40.618]                 })
[17:37:40.618]                 withCallingHandlers({
[17:37:40.618]                   {
[17:37:40.618]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.618]                     if (!identical(...future.globals.maxSize.org, 
[17:37:40.618]                       ...future.globals.maxSize)) {
[17:37:40.618]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.618]                       on.exit(options(oopts), add = TRUE)
[17:37:40.618]                     }
[17:37:40.618]                     {
[17:37:40.618]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.618]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:40.618]                         USE.NAMES = FALSE)
[17:37:40.618]                       do.call(mapply, args = args)
[17:37:40.618]                     }
[17:37:40.618]                   }
[17:37:40.618]                 }, immediateCondition = function(cond) {
[17:37:40.618]                   sendCondition <- ...future.makeSendCondition()
[17:37:40.618]                   sendCondition(cond)
[17:37:40.618]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.618]                   {
[17:37:40.618]                     inherits <- base::inherits
[17:37:40.618]                     invokeRestart <- base::invokeRestart
[17:37:40.618]                     is.null <- base::is.null
[17:37:40.618]                     muffled <- FALSE
[17:37:40.618]                     if (inherits(cond, "message")) {
[17:37:40.618]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:40.618]                       if (muffled) 
[17:37:40.618]                         invokeRestart("muffleMessage")
[17:37:40.618]                     }
[17:37:40.618]                     else if (inherits(cond, "warning")) {
[17:37:40.618]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:40.618]                       if (muffled) 
[17:37:40.618]                         invokeRestart("muffleWarning")
[17:37:40.618]                     }
[17:37:40.618]                     else if (inherits(cond, "condition")) {
[17:37:40.618]                       if (!is.null(pattern)) {
[17:37:40.618]                         computeRestarts <- base::computeRestarts
[17:37:40.618]                         grepl <- base::grepl
[17:37:40.618]                         restarts <- computeRestarts(cond)
[17:37:40.618]                         for (restart in restarts) {
[17:37:40.618]                           name <- restart$name
[17:37:40.618]                           if (is.null(name)) 
[17:37:40.618]                             next
[17:37:40.618]                           if (!grepl(pattern, name)) 
[17:37:40.618]                             next
[17:37:40.618]                           invokeRestart(restart)
[17:37:40.618]                           muffled <- TRUE
[17:37:40.618]                           break
[17:37:40.618]                         }
[17:37:40.618]                       }
[17:37:40.618]                     }
[17:37:40.618]                     invisible(muffled)
[17:37:40.618]                   }
[17:37:40.618]                   muffleCondition(cond)
[17:37:40.618]                 })
[17:37:40.618]             }))
[17:37:40.618]             future::FutureResult(value = ...future.value$value, 
[17:37:40.618]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.618]                   ...future.rng), globalenv = if (FALSE) 
[17:37:40.618]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:40.618]                     ...future.globalenv.names))
[17:37:40.618]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:40.618]         }, condition = base::local({
[17:37:40.618]             c <- base::c
[17:37:40.618]             inherits <- base::inherits
[17:37:40.618]             invokeRestart <- base::invokeRestart
[17:37:40.618]             length <- base::length
[17:37:40.618]             list <- base::list
[17:37:40.618]             seq.int <- base::seq.int
[17:37:40.618]             signalCondition <- base::signalCondition
[17:37:40.618]             sys.calls <- base::sys.calls
[17:37:40.618]             `[[` <- base::`[[`
[17:37:40.618]             `+` <- base::`+`
[17:37:40.618]             `<<-` <- base::`<<-`
[17:37:40.618]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:40.618]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:40.618]                   3L)]
[17:37:40.618]             }
[17:37:40.618]             function(cond) {
[17:37:40.618]                 is_error <- inherits(cond, "error")
[17:37:40.618]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:40.618]                   NULL)
[17:37:40.618]                 if (is_error) {
[17:37:40.618]                   sessionInformation <- function() {
[17:37:40.618]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:40.618]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:40.618]                       search = base::search(), system = base::Sys.info())
[17:37:40.618]                   }
[17:37:40.618]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.618]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:40.618]                     cond$call), session = sessionInformation(), 
[17:37:40.618]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:40.618]                   signalCondition(cond)
[17:37:40.618]                 }
[17:37:40.618]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:40.618]                 "immediateCondition"))) {
[17:37:40.618]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:40.618]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.618]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:40.618]                   if (TRUE && !signal) {
[17:37:40.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.618]                     {
[17:37:40.618]                       inherits <- base::inherits
[17:37:40.618]                       invokeRestart <- base::invokeRestart
[17:37:40.618]                       is.null <- base::is.null
[17:37:40.618]                       muffled <- FALSE
[17:37:40.618]                       if (inherits(cond, "message")) {
[17:37:40.618]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.618]                         if (muffled) 
[17:37:40.618]                           invokeRestart("muffleMessage")
[17:37:40.618]                       }
[17:37:40.618]                       else if (inherits(cond, "warning")) {
[17:37:40.618]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.618]                         if (muffled) 
[17:37:40.618]                           invokeRestart("muffleWarning")
[17:37:40.618]                       }
[17:37:40.618]                       else if (inherits(cond, "condition")) {
[17:37:40.618]                         if (!is.null(pattern)) {
[17:37:40.618]                           computeRestarts <- base::computeRestarts
[17:37:40.618]                           grepl <- base::grepl
[17:37:40.618]                           restarts <- computeRestarts(cond)
[17:37:40.618]                           for (restart in restarts) {
[17:37:40.618]                             name <- restart$name
[17:37:40.618]                             if (is.null(name)) 
[17:37:40.618]                               next
[17:37:40.618]                             if (!grepl(pattern, name)) 
[17:37:40.618]                               next
[17:37:40.618]                             invokeRestart(restart)
[17:37:40.618]                             muffled <- TRUE
[17:37:40.618]                             break
[17:37:40.618]                           }
[17:37:40.618]                         }
[17:37:40.618]                       }
[17:37:40.618]                       invisible(muffled)
[17:37:40.618]                     }
[17:37:40.618]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.618]                   }
[17:37:40.618]                 }
[17:37:40.618]                 else {
[17:37:40.618]                   if (TRUE) {
[17:37:40.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.618]                     {
[17:37:40.618]                       inherits <- base::inherits
[17:37:40.618]                       invokeRestart <- base::invokeRestart
[17:37:40.618]                       is.null <- base::is.null
[17:37:40.618]                       muffled <- FALSE
[17:37:40.618]                       if (inherits(cond, "message")) {
[17:37:40.618]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.618]                         if (muffled) 
[17:37:40.618]                           invokeRestart("muffleMessage")
[17:37:40.618]                       }
[17:37:40.618]                       else if (inherits(cond, "warning")) {
[17:37:40.618]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.618]                         if (muffled) 
[17:37:40.618]                           invokeRestart("muffleWarning")
[17:37:40.618]                       }
[17:37:40.618]                       else if (inherits(cond, "condition")) {
[17:37:40.618]                         if (!is.null(pattern)) {
[17:37:40.618]                           computeRestarts <- base::computeRestarts
[17:37:40.618]                           grepl <- base::grepl
[17:37:40.618]                           restarts <- computeRestarts(cond)
[17:37:40.618]                           for (restart in restarts) {
[17:37:40.618]                             name <- restart$name
[17:37:40.618]                             if (is.null(name)) 
[17:37:40.618]                               next
[17:37:40.618]                             if (!grepl(pattern, name)) 
[17:37:40.618]                               next
[17:37:40.618]                             invokeRestart(restart)
[17:37:40.618]                             muffled <- TRUE
[17:37:40.618]                             break
[17:37:40.618]                           }
[17:37:40.618]                         }
[17:37:40.618]                       }
[17:37:40.618]                       invisible(muffled)
[17:37:40.618]                     }
[17:37:40.618]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.618]                   }
[17:37:40.618]                 }
[17:37:40.618]             }
[17:37:40.618]         }))
[17:37:40.618]     }, error = function(ex) {
[17:37:40.618]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:40.618]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.618]                 ...future.rng), started = ...future.startTime, 
[17:37:40.618]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:40.618]             version = "1.8"), class = "FutureResult")
[17:37:40.618]     }, finally = {
[17:37:40.618]         if (!identical(...future.workdir, getwd())) 
[17:37:40.618]             setwd(...future.workdir)
[17:37:40.618]         {
[17:37:40.618]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:40.618]                 ...future.oldOptions$nwarnings <- NULL
[17:37:40.618]             }
[17:37:40.618]             base::options(...future.oldOptions)
[17:37:40.618]             if (.Platform$OS.type == "windows") {
[17:37:40.618]                 old_names <- names(...future.oldEnvVars)
[17:37:40.618]                 envs <- base::Sys.getenv()
[17:37:40.618]                 names <- names(envs)
[17:37:40.618]                 common <- intersect(names, old_names)
[17:37:40.618]                 added <- setdiff(names, old_names)
[17:37:40.618]                 removed <- setdiff(old_names, names)
[17:37:40.618]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:40.618]                   envs[common]]
[17:37:40.618]                 NAMES <- toupper(changed)
[17:37:40.618]                 args <- list()
[17:37:40.618]                 for (kk in seq_along(NAMES)) {
[17:37:40.618]                   name <- changed[[kk]]
[17:37:40.618]                   NAME <- NAMES[[kk]]
[17:37:40.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.618]                     next
[17:37:40.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.618]                 }
[17:37:40.618]                 NAMES <- toupper(added)
[17:37:40.618]                 for (kk in seq_along(NAMES)) {
[17:37:40.618]                   name <- added[[kk]]
[17:37:40.618]                   NAME <- NAMES[[kk]]
[17:37:40.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.618]                     next
[17:37:40.618]                   args[[name]] <- ""
[17:37:40.618]                 }
[17:37:40.618]                 NAMES <- toupper(removed)
[17:37:40.618]                 for (kk in seq_along(NAMES)) {
[17:37:40.618]                   name <- removed[[kk]]
[17:37:40.618]                   NAME <- NAMES[[kk]]
[17:37:40.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.618]                     next
[17:37:40.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.618]                 }
[17:37:40.618]                 if (length(args) > 0) 
[17:37:40.618]                   base::do.call(base::Sys.setenv, args = args)
[17:37:40.618]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:40.618]             }
[17:37:40.618]             else {
[17:37:40.618]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:40.618]             }
[17:37:40.618]             {
[17:37:40.618]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:40.618]                   0L) {
[17:37:40.618]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:40.618]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:40.618]                   base::options(opts)
[17:37:40.618]                 }
[17:37:40.618]                 {
[17:37:40.618]                   {
[17:37:40.618]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:40.618]                     NULL
[17:37:40.618]                   }
[17:37:40.618]                   options(future.plan = NULL)
[17:37:40.618]                   if (is.na(NA_character_)) 
[17:37:40.618]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.618]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:40.618]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:40.618]                     .init = FALSE)
[17:37:40.618]                 }
[17:37:40.618]             }
[17:37:40.618]         }
[17:37:40.618]     })
[17:37:40.618]     if (TRUE) {
[17:37:40.618]         base::sink(type = "output", split = FALSE)
[17:37:40.618]         if (TRUE) {
[17:37:40.618]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:40.618]         }
[17:37:40.618]         else {
[17:37:40.618]             ...future.result["stdout"] <- base::list(NULL)
[17:37:40.618]         }
[17:37:40.618]         base::close(...future.stdout)
[17:37:40.618]         ...future.stdout <- NULL
[17:37:40.618]     }
[17:37:40.618]     ...future.result$conditions <- ...future.conditions
[17:37:40.618]     ...future.result$finished <- base::Sys.time()
[17:37:40.618]     ...future.result
[17:37:40.618] }
[17:37:40.621] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[17:37:40.621] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[17:37:40.621] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[17:37:40.621] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:37:40.622] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:37:40.622] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:37:40.622] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:37:40.622] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:37:40.623] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:37:40.623] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:37:40.623] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:37:40.623] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[17:37:40.624] MultisessionFuture started
[17:37:40.624] - Launch lazy future ... done
[17:37:40.624] run() for ‘MultisessionFuture’ ... done
[17:37:40.624] Created future:
[17:37:40.624] MultisessionFuture:
[17:37:40.624] Label: ‘future_mapply-2’
[17:37:40.624] Expression:
[17:37:40.624] {
[17:37:40.624]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.624]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:40.624]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.624]         on.exit(options(oopts), add = TRUE)
[17:37:40.624]     }
[17:37:40.624]     {
[17:37:40.624]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.624]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:40.624]         do.call(mapply, args = args)
[17:37:40.624]     }
[17:37:40.624] }
[17:37:40.624] Lazy evaluation: FALSE
[17:37:40.624] Asynchronous evaluation: TRUE
[17:37:40.624] Local evaluation: TRUE
[17:37:40.624] Environment: R_GlobalEnv
[17:37:40.624] Capture standard output: TRUE
[17:37:40.624] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:40.624] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:40.624] Packages: <none>
[17:37:40.624] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:40.624] Resolved: FALSE
[17:37:40.624] Value: <not collected>
[17:37:40.624] Conditions captured: <none>
[17:37:40.624] Early signaling: FALSE
[17:37:40.624] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:40.624] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.635] Chunk #2 of 2 ... DONE
[17:37:40.636] Launching 2 futures (chunks) ... DONE
[17:37:40.636] Resolving 2 futures (chunks) ...
[17:37:40.636] resolve() on list ...
[17:37:40.636]  recursive: 0
[17:37:40.636]  length: 2
[17:37:40.636] 
[17:37:40.636] receiveMessageFromWorker() for ClusterFuture ...
[17:37:40.637] - Validating connection of MultisessionFuture
[17:37:40.637] - received message: FutureResult
[17:37:40.637] - Received FutureResult
[17:37:40.637] - Erased future from FutureRegistry
[17:37:40.637] result() for ClusterFuture ...
[17:37:40.637] - result already collected: FutureResult
[17:37:40.637] result() for ClusterFuture ... done
[17:37:40.637] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:40.637] Future #1
[17:37:40.638] result() for ClusterFuture ...
[17:37:40.638] - result already collected: FutureResult
[17:37:40.638] result() for ClusterFuture ... done
[17:37:40.638] result() for ClusterFuture ...
[17:37:40.638] - result already collected: FutureResult
[17:37:40.638] result() for ClusterFuture ... done
[17:37:40.638] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:37:40.638] - nx: 2
[17:37:40.638] - relay: TRUE
[17:37:40.638] - stdout: TRUE
[17:37:40.638] - signal: TRUE
[17:37:40.638] - resignal: FALSE
[17:37:40.639] - force: TRUE
[17:37:40.639] - relayed: [n=2] FALSE, FALSE
[17:37:40.639] - queued futures: [n=2] FALSE, FALSE
[17:37:40.639]  - until=1
[17:37:40.639]  - relaying element #1
[17:37:40.639] result() for ClusterFuture ...
[17:37:40.639] - result already collected: FutureResult
[17:37:40.639] result() for ClusterFuture ... done
[17:37:40.639] result() for ClusterFuture ...
[17:37:40.639] - result already collected: FutureResult
[17:37:40.639] result() for ClusterFuture ... done
[17:37:40.639] result() for ClusterFuture ...
[17:37:40.640] - result already collected: FutureResult
[17:37:40.640] result() for ClusterFuture ... done
[17:37:40.640] result() for ClusterFuture ...
[17:37:40.640] - result already collected: FutureResult
[17:37:40.640] result() for ClusterFuture ... done
[17:37:40.640] - relayed: [n=2] TRUE, FALSE
[17:37:40.640] - queued futures: [n=2] TRUE, FALSE
[17:37:40.640] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:37:40.640]  length: 1 (resolved future 1)
[17:37:40.666] receiveMessageFromWorker() for ClusterFuture ...
[17:37:40.666] - Validating connection of MultisessionFuture
[17:37:40.666] - received message: FutureResult
[17:37:40.666] - Received FutureResult
[17:37:40.666] - Erased future from FutureRegistry
[17:37:40.667] result() for ClusterFuture ...
[17:37:40.667] - result already collected: FutureResult
[17:37:40.667] result() for ClusterFuture ... done
[17:37:40.667] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:40.667] Future #2
[17:37:40.667] result() for ClusterFuture ...
[17:37:40.667] - result already collected: FutureResult
[17:37:40.667] result() for ClusterFuture ... done
[17:37:40.667] result() for ClusterFuture ...
[17:37:40.667] - result already collected: FutureResult
[17:37:40.667] result() for ClusterFuture ... done
[17:37:40.668] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:37:40.668] - nx: 2
[17:37:40.668] - relay: TRUE
[17:37:40.668] - stdout: TRUE
[17:37:40.668] - signal: TRUE
[17:37:40.668] - resignal: FALSE
[17:37:40.668] - force: TRUE
[17:37:40.668] - relayed: [n=2] TRUE, FALSE
[17:37:40.668] - queued futures: [n=2] TRUE, FALSE
[17:37:40.668]  - until=2
[17:37:40.668]  - relaying element #2
[17:37:40.668] result() for ClusterFuture ...
[17:37:40.669] - result already collected: FutureResult
[17:37:40.669] result() for ClusterFuture ... done
[17:37:40.669] result() for ClusterFuture ...
[17:37:40.669] - result already collected: FutureResult
[17:37:40.669] result() for ClusterFuture ... done
[17:37:40.669] result() for ClusterFuture ...
[17:37:40.669] - result already collected: FutureResult
[17:37:40.669] result() for ClusterFuture ... done
[17:37:40.669] result() for ClusterFuture ...
[17:37:40.669] - result already collected: FutureResult
[17:37:40.669] result() for ClusterFuture ... done
[17:37:40.670] - relayed: [n=2] TRUE, TRUE
[17:37:40.670] - queued futures: [n=2] TRUE, TRUE
[17:37:40.670] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:37:40.670]  length: 0 (resolved future 2)
[17:37:40.670] Relaying remaining futures
[17:37:40.670] signalConditionsASAP(NULL, pos=0) ...
[17:37:40.670] - nx: 2
[17:37:40.670] - relay: TRUE
[17:37:40.670] - stdout: TRUE
[17:37:40.670] - signal: TRUE
[17:37:40.670] - resignal: FALSE
[17:37:40.670] - force: TRUE
[17:37:40.670] - relayed: [n=2] TRUE, TRUE
[17:37:40.671] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:40.671] - relayed: [n=2] TRUE, TRUE
[17:37:40.671] - queued futures: [n=2] TRUE, TRUE
[17:37:40.671] signalConditionsASAP(NULL, pos=0) ... done
[17:37:40.671] resolve() on list ... DONE
[17:37:40.671] result() for ClusterFuture ...
[17:37:40.671] - result already collected: FutureResult
[17:37:40.671] result() for ClusterFuture ... done
[17:37:40.671] result() for ClusterFuture ...
[17:37:40.671] - result already collected: FutureResult
[17:37:40.671] result() for ClusterFuture ... done
[17:37:40.672] result() for ClusterFuture ...
[17:37:40.672] - result already collected: FutureResult
[17:37:40.672] result() for ClusterFuture ... done
[17:37:40.672] result() for ClusterFuture ...
[17:37:40.672] - result already collected: FutureResult
[17:37:40.672] result() for ClusterFuture ... done
[17:37:40.672]  - Number of value chunks collected: 2
[17:37:40.672] Resolving 2 futures (chunks) ... DONE
[17:37:40.672] Reducing values from 2 chunks ...
[17:37:40.672]  - Number of values collected after concatenation: 4
[17:37:40.672]  - Number of values expected: 4
[17:37:40.673] Reducing values from 2 chunks ... DONE
[17:37:40.673] future_mapply() ... DONE
- Parallel RNG ...
[17:37:40.673] future_mapply() ...
[17:37:40.673] Generating random seeds ...
[17:37:40.673] Generating random seed streams for 4 elements ...
[17:37:40.673] Generating random seed streams for 4 elements ... DONE
[17:37:40.673] Generating random seeds ... DONE
[17:37:40.673] Will set RNG state on exit: 10407, -1847219102, -1838603958, -788947431, 1510844200, 760488382, 141113700
[17:37:40.677] Number of chunks: 2
[17:37:40.677] getGlobalsAndPackagesXApply() ...
[17:37:40.677]  - future.globals: TRUE
[17:37:40.677] getGlobalsAndPackages() ...
[17:37:40.678] Searching for globals...
[17:37:40.679] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[17:37:40.679] Searching for globals ... DONE
[17:37:40.679] Resolving globals: FALSE
[17:37:40.679] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[17:37:40.680] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[17:37:40.680] - globals: [1] ‘FUN’
[17:37:40.680] - packages: [1] ‘stats’
[17:37:40.680] getGlobalsAndPackages() ... DONE
[17:37:40.680]  - globals found/used: [n=1] ‘FUN’
[17:37:40.680]  - needed namespaces: [n=1] ‘stats’
[17:37:40.680] Finding globals ... DONE
[17:37:40.681] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:40.681] List of 2
[17:37:40.681]  $ ...future.FUN:function (n, min = 0, max = 1)  
[17:37:40.681]  $ MoreArgs     :List of 1
[17:37:40.681]   ..$ min: num 1
[17:37:40.681]  - attr(*, "where")=List of 2
[17:37:40.681]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:40.681]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:40.681]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:40.681]  - attr(*, "resolved")= logi FALSE
[17:37:40.681]  - attr(*, "total_size")= num NA
[17:37:40.683] Packages to be attached in all futures: [n=1] ‘stats’
[17:37:40.684] getGlobalsAndPackagesXApply() ... DONE
[17:37:40.684] Number of futures (= number of chunks): 2
[17:37:40.684] Launching 2 futures (chunks) ...
[17:37:40.684] Chunk #1 of 2 ...
[17:37:40.684]  - Finding globals in '...' for chunk #1 ...
[17:37:40.684] getGlobalsAndPackages() ...
[17:37:40.684] Searching for globals...
[17:37:40.685] 
[17:37:40.685] Searching for globals ... DONE
[17:37:40.685] - globals: [0] <none>
[17:37:40.685] getGlobalsAndPackages() ... DONE
[17:37:40.685]    + additional globals found: [n=0] 
[17:37:40.685]    + additional namespaces needed: [n=0] 
[17:37:40.685]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:40.685]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:40.685]  - seeds: [2] <seeds>
[17:37:40.685]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.686] getGlobalsAndPackages() ...
[17:37:40.686] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.686] Resolving globals: FALSE
[17:37:40.686] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[17:37:40.687] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[17:37:40.687] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.687] - packages: [1] ‘stats’
[17:37:40.687] getGlobalsAndPackages() ... DONE
[17:37:40.687] run() for ‘Future’ ...
[17:37:40.687] - state: ‘created’
[17:37:40.688] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:40.701] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.701] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:40.701]   - Field: ‘node’
[17:37:40.701]   - Field: ‘label’
[17:37:40.701]   - Field: ‘local’
[17:37:40.702]   - Field: ‘owner’
[17:37:40.702]   - Field: ‘envir’
[17:37:40.702]   - Field: ‘workers’
[17:37:40.702]   - Field: ‘packages’
[17:37:40.702]   - Field: ‘gc’
[17:37:40.702]   - Field: ‘conditions’
[17:37:40.702]   - Field: ‘persistent’
[17:37:40.702]   - Field: ‘expr’
[17:37:40.702]   - Field: ‘uuid’
[17:37:40.702]   - Field: ‘seed’
[17:37:40.703]   - Field: ‘version’
[17:37:40.703]   - Field: ‘result’
[17:37:40.703]   - Field: ‘asynchronous’
[17:37:40.703]   - Field: ‘calls’
[17:37:40.703]   - Field: ‘globals’
[17:37:40.703]   - Field: ‘stdout’
[17:37:40.703]   - Field: ‘earlySignal’
[17:37:40.703]   - Field: ‘lazy’
[17:37:40.703]   - Field: ‘state’
[17:37:40.703] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:40.703] - Launch lazy future ...
[17:37:40.704] Packages needed by the future expression (n = 1): ‘stats’
[17:37:40.704] Packages needed by future strategies (n = 0): <none>
[17:37:40.704] {
[17:37:40.704]     {
[17:37:40.704]         {
[17:37:40.704]             ...future.startTime <- base::Sys.time()
[17:37:40.704]             {
[17:37:40.704]                 {
[17:37:40.704]                   {
[17:37:40.704]                     {
[17:37:40.704]                       {
[17:37:40.704]                         base::local({
[17:37:40.704]                           has_future <- base::requireNamespace("future", 
[17:37:40.704]                             quietly = TRUE)
[17:37:40.704]                           if (has_future) {
[17:37:40.704]                             ns <- base::getNamespace("future")
[17:37:40.704]                             version <- ns[[".package"]][["version"]]
[17:37:40.704]                             if (is.null(version)) 
[17:37:40.704]                               version <- utils::packageVersion("future")
[17:37:40.704]                           }
[17:37:40.704]                           else {
[17:37:40.704]                             version <- NULL
[17:37:40.704]                           }
[17:37:40.704]                           if (!has_future || version < "1.8.0") {
[17:37:40.704]                             info <- base::c(r_version = base::gsub("R version ", 
[17:37:40.704]                               "", base::R.version$version.string), 
[17:37:40.704]                               platform = base::sprintf("%s (%s-bit)", 
[17:37:40.704]                                 base::R.version$platform, 8 * 
[17:37:40.704]                                   base::.Machine$sizeof.pointer), 
[17:37:40.704]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:40.704]                                 "release", "version")], collapse = " "), 
[17:37:40.704]                               hostname = base::Sys.info()[["nodename"]])
[17:37:40.704]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:37:40.704]                               info)
[17:37:40.704]                             info <- base::paste(info, collapse = "; ")
[17:37:40.704]                             if (!has_future) {
[17:37:40.704]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:40.704]                                 info)
[17:37:40.704]                             }
[17:37:40.704]                             else {
[17:37:40.704]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:40.704]                                 info, version)
[17:37:40.704]                             }
[17:37:40.704]                             base::stop(msg)
[17:37:40.704]                           }
[17:37:40.704]                         })
[17:37:40.704]                       }
[17:37:40.704]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:40.704]                       base::options(mc.cores = 1L)
[17:37:40.704]                     }
[17:37:40.704]                     base::local({
[17:37:40.704]                       for (pkg in "stats") {
[17:37:40.704]                         base::loadNamespace(pkg)
[17:37:40.704]                         base::library(pkg, character.only = TRUE)
[17:37:40.704]                       }
[17:37:40.704]                     })
[17:37:40.704]                   }
[17:37:40.704]                   ...future.strategy.old <- future::plan("list")
[17:37:40.704]                   options(future.plan = NULL)
[17:37:40.704]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.704]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:40.704]                 }
[17:37:40.704]                 ...future.workdir <- getwd()
[17:37:40.704]             }
[17:37:40.704]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:40.704]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:40.704]         }
[17:37:40.704]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:40.704]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:40.704]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:40.704]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:40.704]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:40.704]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:40.704]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:40.704]             base::names(...future.oldOptions))
[17:37:40.704]     }
[17:37:40.704]     if (FALSE) {
[17:37:40.704]     }
[17:37:40.704]     else {
[17:37:40.704]         if (TRUE) {
[17:37:40.704]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:40.704]                 open = "w")
[17:37:40.704]         }
[17:37:40.704]         else {
[17:37:40.704]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:40.704]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:40.704]         }
[17:37:40.704]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:40.704]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:40.704]             base::sink(type = "output", split = FALSE)
[17:37:40.704]             base::close(...future.stdout)
[17:37:40.704]         }, add = TRUE)
[17:37:40.704]     }
[17:37:40.704]     ...future.frame <- base::sys.nframe()
[17:37:40.704]     ...future.conditions <- base::list()
[17:37:40.704]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:40.704]     if (FALSE) {
[17:37:40.704]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:40.704]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:40.704]     }
[17:37:40.704]     ...future.result <- base::tryCatch({
[17:37:40.704]         base::withCallingHandlers({
[17:37:40.704]             ...future.value <- base::withVisible(base::local({
[17:37:40.704]                 ...future.makeSendCondition <- base::local({
[17:37:40.704]                   sendCondition <- NULL
[17:37:40.704]                   function(frame = 1L) {
[17:37:40.704]                     if (is.function(sendCondition)) 
[17:37:40.704]                       return(sendCondition)
[17:37:40.704]                     ns <- getNamespace("parallel")
[17:37:40.704]                     if (exists("sendData", mode = "function", 
[17:37:40.704]                       envir = ns)) {
[17:37:40.704]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:40.704]                         envir = ns)
[17:37:40.704]                       envir <- sys.frame(frame)
[17:37:40.704]                       master <- NULL
[17:37:40.704]                       while (!identical(envir, .GlobalEnv) && 
[17:37:40.704]                         !identical(envir, emptyenv())) {
[17:37:40.704]                         if (exists("master", mode = "list", envir = envir, 
[17:37:40.704]                           inherits = FALSE)) {
[17:37:40.704]                           master <- get("master", mode = "list", 
[17:37:40.704]                             envir = envir, inherits = FALSE)
[17:37:40.704]                           if (inherits(master, c("SOCKnode", 
[17:37:40.704]                             "SOCK0node"))) {
[17:37:40.704]                             sendCondition <<- function(cond) {
[17:37:40.704]                               data <- list(type = "VALUE", value = cond, 
[17:37:40.704]                                 success = TRUE)
[17:37:40.704]                               parallel_sendData(master, data)
[17:37:40.704]                             }
[17:37:40.704]                             return(sendCondition)
[17:37:40.704]                           }
[17:37:40.704]                         }
[17:37:40.704]                         frame <- frame + 1L
[17:37:40.704]                         envir <- sys.frame(frame)
[17:37:40.704]                       }
[17:37:40.704]                     }
[17:37:40.704]                     sendCondition <<- function(cond) NULL
[17:37:40.704]                   }
[17:37:40.704]                 })
[17:37:40.704]                 withCallingHandlers({
[17:37:40.704]                   {
[17:37:40.704]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.704]                     if (!identical(...future.globals.maxSize.org, 
[17:37:40.704]                       ...future.globals.maxSize)) {
[17:37:40.704]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.704]                       on.exit(options(oopts), add = TRUE)
[17:37:40.704]                     }
[17:37:40.704]                     {
[17:37:40.704]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:37:40.704]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:37:40.704]                           envir = globalenv(), inherits = FALSE)
[17:37:40.704]                         ...future.FUN(...)
[17:37:40.704]                       }
[17:37:40.704]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:37:40.704]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:37:40.704]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:40.704]                         USE.NAMES = FALSE)
[17:37:40.704]                       do.call(mapply, args = args)
[17:37:40.704]                     }
[17:37:40.704]                   }
[17:37:40.704]                 }, immediateCondition = function(cond) {
[17:37:40.704]                   sendCondition <- ...future.makeSendCondition()
[17:37:40.704]                   sendCondition(cond)
[17:37:40.704]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.704]                   {
[17:37:40.704]                     inherits <- base::inherits
[17:37:40.704]                     invokeRestart <- base::invokeRestart
[17:37:40.704]                     is.null <- base::is.null
[17:37:40.704]                     muffled <- FALSE
[17:37:40.704]                     if (inherits(cond, "message")) {
[17:37:40.704]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:40.704]                       if (muffled) 
[17:37:40.704]                         invokeRestart("muffleMessage")
[17:37:40.704]                     }
[17:37:40.704]                     else if (inherits(cond, "warning")) {
[17:37:40.704]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:40.704]                       if (muffled) 
[17:37:40.704]                         invokeRestart("muffleWarning")
[17:37:40.704]                     }
[17:37:40.704]                     else if (inherits(cond, "condition")) {
[17:37:40.704]                       if (!is.null(pattern)) {
[17:37:40.704]                         computeRestarts <- base::computeRestarts
[17:37:40.704]                         grepl <- base::grepl
[17:37:40.704]                         restarts <- computeRestarts(cond)
[17:37:40.704]                         for (restart in restarts) {
[17:37:40.704]                           name <- restart$name
[17:37:40.704]                           if (is.null(name)) 
[17:37:40.704]                             next
[17:37:40.704]                           if (!grepl(pattern, name)) 
[17:37:40.704]                             next
[17:37:40.704]                           invokeRestart(restart)
[17:37:40.704]                           muffled <- TRUE
[17:37:40.704]                           break
[17:37:40.704]                         }
[17:37:40.704]                       }
[17:37:40.704]                     }
[17:37:40.704]                     invisible(muffled)
[17:37:40.704]                   }
[17:37:40.704]                   muffleCondition(cond)
[17:37:40.704]                 })
[17:37:40.704]             }))
[17:37:40.704]             future::FutureResult(value = ...future.value$value, 
[17:37:40.704]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.704]                   ...future.rng), globalenv = if (FALSE) 
[17:37:40.704]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:40.704]                     ...future.globalenv.names))
[17:37:40.704]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:40.704]         }, condition = base::local({
[17:37:40.704]             c <- base::c
[17:37:40.704]             inherits <- base::inherits
[17:37:40.704]             invokeRestart <- base::invokeRestart
[17:37:40.704]             length <- base::length
[17:37:40.704]             list <- base::list
[17:37:40.704]             seq.int <- base::seq.int
[17:37:40.704]             signalCondition <- base::signalCondition
[17:37:40.704]             sys.calls <- base::sys.calls
[17:37:40.704]             `[[` <- base::`[[`
[17:37:40.704]             `+` <- base::`+`
[17:37:40.704]             `<<-` <- base::`<<-`
[17:37:40.704]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:40.704]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:40.704]                   3L)]
[17:37:40.704]             }
[17:37:40.704]             function(cond) {
[17:37:40.704]                 is_error <- inherits(cond, "error")
[17:37:40.704]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:40.704]                   NULL)
[17:37:40.704]                 if (is_error) {
[17:37:40.704]                   sessionInformation <- function() {
[17:37:40.704]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:40.704]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:40.704]                       search = base::search(), system = base::Sys.info())
[17:37:40.704]                   }
[17:37:40.704]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.704]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:40.704]                     cond$call), session = sessionInformation(), 
[17:37:40.704]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:40.704]                   signalCondition(cond)
[17:37:40.704]                 }
[17:37:40.704]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:40.704]                 "immediateCondition"))) {
[17:37:40.704]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:40.704]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.704]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:40.704]                   if (TRUE && !signal) {
[17:37:40.704]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.704]                     {
[17:37:40.704]                       inherits <- base::inherits
[17:37:40.704]                       invokeRestart <- base::invokeRestart
[17:37:40.704]                       is.null <- base::is.null
[17:37:40.704]                       muffled <- FALSE
[17:37:40.704]                       if (inherits(cond, "message")) {
[17:37:40.704]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.704]                         if (muffled) 
[17:37:40.704]                           invokeRestart("muffleMessage")
[17:37:40.704]                       }
[17:37:40.704]                       else if (inherits(cond, "warning")) {
[17:37:40.704]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.704]                         if (muffled) 
[17:37:40.704]                           invokeRestart("muffleWarning")
[17:37:40.704]                       }
[17:37:40.704]                       else if (inherits(cond, "condition")) {
[17:37:40.704]                         if (!is.null(pattern)) {
[17:37:40.704]                           computeRestarts <- base::computeRestarts
[17:37:40.704]                           grepl <- base::grepl
[17:37:40.704]                           restarts <- computeRestarts(cond)
[17:37:40.704]                           for (restart in restarts) {
[17:37:40.704]                             name <- restart$name
[17:37:40.704]                             if (is.null(name)) 
[17:37:40.704]                               next
[17:37:40.704]                             if (!grepl(pattern, name)) 
[17:37:40.704]                               next
[17:37:40.704]                             invokeRestart(restart)
[17:37:40.704]                             muffled <- TRUE
[17:37:40.704]                             break
[17:37:40.704]                           }
[17:37:40.704]                         }
[17:37:40.704]                       }
[17:37:40.704]                       invisible(muffled)
[17:37:40.704]                     }
[17:37:40.704]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.704]                   }
[17:37:40.704]                 }
[17:37:40.704]                 else {
[17:37:40.704]                   if (TRUE) {
[17:37:40.704]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.704]                     {
[17:37:40.704]                       inherits <- base::inherits
[17:37:40.704]                       invokeRestart <- base::invokeRestart
[17:37:40.704]                       is.null <- base::is.null
[17:37:40.704]                       muffled <- FALSE
[17:37:40.704]                       if (inherits(cond, "message")) {
[17:37:40.704]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.704]                         if (muffled) 
[17:37:40.704]                           invokeRestart("muffleMessage")
[17:37:40.704]                       }
[17:37:40.704]                       else if (inherits(cond, "warning")) {
[17:37:40.704]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.704]                         if (muffled) 
[17:37:40.704]                           invokeRestart("muffleWarning")
[17:37:40.704]                       }
[17:37:40.704]                       else if (inherits(cond, "condition")) {
[17:37:40.704]                         if (!is.null(pattern)) {
[17:37:40.704]                           computeRestarts <- base::computeRestarts
[17:37:40.704]                           grepl <- base::grepl
[17:37:40.704]                           restarts <- computeRestarts(cond)
[17:37:40.704]                           for (restart in restarts) {
[17:37:40.704]                             name <- restart$name
[17:37:40.704]                             if (is.null(name)) 
[17:37:40.704]                               next
[17:37:40.704]                             if (!grepl(pattern, name)) 
[17:37:40.704]                               next
[17:37:40.704]                             invokeRestart(restart)
[17:37:40.704]                             muffled <- TRUE
[17:37:40.704]                             break
[17:37:40.704]                           }
[17:37:40.704]                         }
[17:37:40.704]                       }
[17:37:40.704]                       invisible(muffled)
[17:37:40.704]                     }
[17:37:40.704]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.704]                   }
[17:37:40.704]                 }
[17:37:40.704]             }
[17:37:40.704]         }))
[17:37:40.704]     }, error = function(ex) {
[17:37:40.704]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:40.704]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.704]                 ...future.rng), started = ...future.startTime, 
[17:37:40.704]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:40.704]             version = "1.8"), class = "FutureResult")
[17:37:40.704]     }, finally = {
[17:37:40.704]         if (!identical(...future.workdir, getwd())) 
[17:37:40.704]             setwd(...future.workdir)
[17:37:40.704]         {
[17:37:40.704]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:40.704]                 ...future.oldOptions$nwarnings <- NULL
[17:37:40.704]             }
[17:37:40.704]             base::options(...future.oldOptions)
[17:37:40.704]             if (.Platform$OS.type == "windows") {
[17:37:40.704]                 old_names <- names(...future.oldEnvVars)
[17:37:40.704]                 envs <- base::Sys.getenv()
[17:37:40.704]                 names <- names(envs)
[17:37:40.704]                 common <- intersect(names, old_names)
[17:37:40.704]                 added <- setdiff(names, old_names)
[17:37:40.704]                 removed <- setdiff(old_names, names)
[17:37:40.704]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:40.704]                   envs[common]]
[17:37:40.704]                 NAMES <- toupper(changed)
[17:37:40.704]                 args <- list()
[17:37:40.704]                 for (kk in seq_along(NAMES)) {
[17:37:40.704]                   name <- changed[[kk]]
[17:37:40.704]                   NAME <- NAMES[[kk]]
[17:37:40.704]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.704]                     next
[17:37:40.704]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.704]                 }
[17:37:40.704]                 NAMES <- toupper(added)
[17:37:40.704]                 for (kk in seq_along(NAMES)) {
[17:37:40.704]                   name <- added[[kk]]
[17:37:40.704]                   NAME <- NAMES[[kk]]
[17:37:40.704]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.704]                     next
[17:37:40.704]                   args[[name]] <- ""
[17:37:40.704]                 }
[17:37:40.704]                 NAMES <- toupper(removed)
[17:37:40.704]                 for (kk in seq_along(NAMES)) {
[17:37:40.704]                   name <- removed[[kk]]
[17:37:40.704]                   NAME <- NAMES[[kk]]
[17:37:40.704]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.704]                     next
[17:37:40.704]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.704]                 }
[17:37:40.704]                 if (length(args) > 0) 
[17:37:40.704]                   base::do.call(base::Sys.setenv, args = args)
[17:37:40.704]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:40.704]             }
[17:37:40.704]             else {
[17:37:40.704]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:40.704]             }
[17:37:40.704]             {
[17:37:40.704]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:40.704]                   0L) {
[17:37:40.704]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:40.704]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:40.704]                   base::options(opts)
[17:37:40.704]                 }
[17:37:40.704]                 {
[17:37:40.704]                   {
[17:37:40.704]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:40.704]                     NULL
[17:37:40.704]                   }
[17:37:40.704]                   options(future.plan = NULL)
[17:37:40.704]                   if (is.na(NA_character_)) 
[17:37:40.704]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.704]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:40.704]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:40.704]                     .init = FALSE)
[17:37:40.704]                 }
[17:37:40.704]             }
[17:37:40.704]         }
[17:37:40.704]     })
[17:37:40.704]     if (TRUE) {
[17:37:40.704]         base::sink(type = "output", split = FALSE)
[17:37:40.704]         if (TRUE) {
[17:37:40.704]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:40.704]         }
[17:37:40.704]         else {
[17:37:40.704]             ...future.result["stdout"] <- base::list(NULL)
[17:37:40.704]         }
[17:37:40.704]         base::close(...future.stdout)
[17:37:40.704]         ...future.stdout <- NULL
[17:37:40.704]     }
[17:37:40.704]     ...future.result$conditions <- ...future.conditions
[17:37:40.704]     ...future.result$finished <- base::Sys.time()
[17:37:40.704]     ...future.result
[17:37:40.704] }
[17:37:40.707] Exporting 5 global objects (2.47 KiB) to cluster node #1 ...
[17:37:40.707] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #1 ...
[17:37:40.708] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #1 ... DONE
[17:37:40.708] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[17:37:40.708] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[17:37:40.708] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[17:37:40.709] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[17:37:40.709] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #1 ...
[17:37:40.709] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #1 ... DONE
[17:37:40.709] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:40.710] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:40.710] Exporting 5 global objects (2.47 KiB) to cluster node #1 ... DONE
[17:37:40.710] MultisessionFuture started
[17:37:40.710] - Launch lazy future ... done
[17:37:40.710] run() for ‘MultisessionFuture’ ... done
[17:37:40.710] Created future:
[17:37:40.710] MultisessionFuture:
[17:37:40.710] Label: ‘future_mapply-1’
[17:37:40.710] Expression:
[17:37:40.710] {
[17:37:40.710]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.710]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:40.710]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.710]         on.exit(options(oopts), add = TRUE)
[17:37:40.710]     }
[17:37:40.710]     {
[17:37:40.710]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:37:40.710]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:37:40.710]                 inherits = FALSE)
[17:37:40.710]             ...future.FUN(...)
[17:37:40.710]         }
[17:37:40.710]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:37:40.710]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:37:40.710]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:40.710]         do.call(mapply, args = args)
[17:37:40.710]     }
[17:37:40.710] }
[17:37:40.710] Lazy evaluation: FALSE
[17:37:40.710] Asynchronous evaluation: TRUE
[17:37:40.710] Local evaluation: TRUE
[17:37:40.710] Environment: R_GlobalEnv
[17:37:40.710] Capture standard output: TRUE
[17:37:40.710] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:40.710] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:40.710] Packages: 1 packages (‘stats’)
[17:37:40.710] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:37:40.710] Resolved: FALSE
[17:37:40.710] Value: <not collected>
[17:37:40.710] Conditions captured: <none>
[17:37:40.710] Early signaling: FALSE
[17:37:40.710] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:40.710] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.722] Chunk #1 of 2 ... DONE
[17:37:40.722] Chunk #2 of 2 ...
[17:37:40.722]  - Finding globals in '...' for chunk #2 ...
[17:37:40.722] getGlobalsAndPackages() ...
[17:37:40.722] Searching for globals...
[17:37:40.723] 
[17:37:40.723] Searching for globals ... DONE
[17:37:40.723] - globals: [0] <none>
[17:37:40.723] getGlobalsAndPackages() ... DONE
[17:37:40.723]    + additional globals found: [n=0] 
[17:37:40.723]    + additional namespaces needed: [n=0] 
[17:37:40.723]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:40.723]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:40.723]  - seeds: [2] <seeds>
[17:37:40.724]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.724] getGlobalsAndPackages() ...
[17:37:40.724] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.724] Resolving globals: FALSE
[17:37:40.724] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[17:37:40.725] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[17:37:40.725] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.725] - packages: [1] ‘stats’
[17:37:40.725] getGlobalsAndPackages() ... DONE
[17:37:40.726] run() for ‘Future’ ...
[17:37:40.726] - state: ‘created’
[17:37:40.726] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:40.742] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.742] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:40.742]   - Field: ‘node’
[17:37:40.742]   - Field: ‘label’
[17:37:40.742]   - Field: ‘local’
[17:37:40.742]   - Field: ‘owner’
[17:37:40.742]   - Field: ‘envir’
[17:37:40.742]   - Field: ‘workers’
[17:37:40.742]   - Field: ‘packages’
[17:37:40.742]   - Field: ‘gc’
[17:37:40.743]   - Field: ‘conditions’
[17:37:40.743]   - Field: ‘persistent’
[17:37:40.743]   - Field: ‘expr’
[17:37:40.743]   - Field: ‘uuid’
[17:37:40.743]   - Field: ‘seed’
[17:37:40.743]   - Field: ‘version’
[17:37:40.743]   - Field: ‘result’
[17:37:40.743]   - Field: ‘asynchronous’
[17:37:40.743]   - Field: ‘calls’
[17:37:40.743]   - Field: ‘globals’
[17:37:40.743]   - Field: ‘stdout’
[17:37:40.744]   - Field: ‘earlySignal’
[17:37:40.744]   - Field: ‘lazy’
[17:37:40.744]   - Field: ‘state’
[17:37:40.744] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:40.744] - Launch lazy future ...
[17:37:40.744] Packages needed by the future expression (n = 1): ‘stats’
[17:37:40.744] Packages needed by future strategies (n = 0): <none>
[17:37:40.745] {
[17:37:40.745]     {
[17:37:40.745]         {
[17:37:40.745]             ...future.startTime <- base::Sys.time()
[17:37:40.745]             {
[17:37:40.745]                 {
[17:37:40.745]                   {
[17:37:40.745]                     {
[17:37:40.745]                       {
[17:37:40.745]                         base::local({
[17:37:40.745]                           has_future <- base::requireNamespace("future", 
[17:37:40.745]                             quietly = TRUE)
[17:37:40.745]                           if (has_future) {
[17:37:40.745]                             ns <- base::getNamespace("future")
[17:37:40.745]                             version <- ns[[".package"]][["version"]]
[17:37:40.745]                             if (is.null(version)) 
[17:37:40.745]                               version <- utils::packageVersion("future")
[17:37:40.745]                           }
[17:37:40.745]                           else {
[17:37:40.745]                             version <- NULL
[17:37:40.745]                           }
[17:37:40.745]                           if (!has_future || version < "1.8.0") {
[17:37:40.745]                             info <- base::c(r_version = base::gsub("R version ", 
[17:37:40.745]                               "", base::R.version$version.string), 
[17:37:40.745]                               platform = base::sprintf("%s (%s-bit)", 
[17:37:40.745]                                 base::R.version$platform, 8 * 
[17:37:40.745]                                   base::.Machine$sizeof.pointer), 
[17:37:40.745]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:40.745]                                 "release", "version")], collapse = " "), 
[17:37:40.745]                               hostname = base::Sys.info()[["nodename"]])
[17:37:40.745]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:37:40.745]                               info)
[17:37:40.745]                             info <- base::paste(info, collapse = "; ")
[17:37:40.745]                             if (!has_future) {
[17:37:40.745]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:40.745]                                 info)
[17:37:40.745]                             }
[17:37:40.745]                             else {
[17:37:40.745]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:40.745]                                 info, version)
[17:37:40.745]                             }
[17:37:40.745]                             base::stop(msg)
[17:37:40.745]                           }
[17:37:40.745]                         })
[17:37:40.745]                       }
[17:37:40.745]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:40.745]                       base::options(mc.cores = 1L)
[17:37:40.745]                     }
[17:37:40.745]                     base::local({
[17:37:40.745]                       for (pkg in "stats") {
[17:37:40.745]                         base::loadNamespace(pkg)
[17:37:40.745]                         base::library(pkg, character.only = TRUE)
[17:37:40.745]                       }
[17:37:40.745]                     })
[17:37:40.745]                   }
[17:37:40.745]                   ...future.strategy.old <- future::plan("list")
[17:37:40.745]                   options(future.plan = NULL)
[17:37:40.745]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.745]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:40.745]                 }
[17:37:40.745]                 ...future.workdir <- getwd()
[17:37:40.745]             }
[17:37:40.745]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:40.745]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:40.745]         }
[17:37:40.745]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:40.745]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:40.745]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:40.745]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:40.745]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:40.745]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:40.745]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:40.745]             base::names(...future.oldOptions))
[17:37:40.745]     }
[17:37:40.745]     if (FALSE) {
[17:37:40.745]     }
[17:37:40.745]     else {
[17:37:40.745]         if (TRUE) {
[17:37:40.745]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:40.745]                 open = "w")
[17:37:40.745]         }
[17:37:40.745]         else {
[17:37:40.745]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:40.745]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:40.745]         }
[17:37:40.745]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:40.745]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:40.745]             base::sink(type = "output", split = FALSE)
[17:37:40.745]             base::close(...future.stdout)
[17:37:40.745]         }, add = TRUE)
[17:37:40.745]     }
[17:37:40.745]     ...future.frame <- base::sys.nframe()
[17:37:40.745]     ...future.conditions <- base::list()
[17:37:40.745]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:40.745]     if (FALSE) {
[17:37:40.745]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:40.745]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:40.745]     }
[17:37:40.745]     ...future.result <- base::tryCatch({
[17:37:40.745]         base::withCallingHandlers({
[17:37:40.745]             ...future.value <- base::withVisible(base::local({
[17:37:40.745]                 ...future.makeSendCondition <- base::local({
[17:37:40.745]                   sendCondition <- NULL
[17:37:40.745]                   function(frame = 1L) {
[17:37:40.745]                     if (is.function(sendCondition)) 
[17:37:40.745]                       return(sendCondition)
[17:37:40.745]                     ns <- getNamespace("parallel")
[17:37:40.745]                     if (exists("sendData", mode = "function", 
[17:37:40.745]                       envir = ns)) {
[17:37:40.745]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:40.745]                         envir = ns)
[17:37:40.745]                       envir <- sys.frame(frame)
[17:37:40.745]                       master <- NULL
[17:37:40.745]                       while (!identical(envir, .GlobalEnv) && 
[17:37:40.745]                         !identical(envir, emptyenv())) {
[17:37:40.745]                         if (exists("master", mode = "list", envir = envir, 
[17:37:40.745]                           inherits = FALSE)) {
[17:37:40.745]                           master <- get("master", mode = "list", 
[17:37:40.745]                             envir = envir, inherits = FALSE)
[17:37:40.745]                           if (inherits(master, c("SOCKnode", 
[17:37:40.745]                             "SOCK0node"))) {
[17:37:40.745]                             sendCondition <<- function(cond) {
[17:37:40.745]                               data <- list(type = "VALUE", value = cond, 
[17:37:40.745]                                 success = TRUE)
[17:37:40.745]                               parallel_sendData(master, data)
[17:37:40.745]                             }
[17:37:40.745]                             return(sendCondition)
[17:37:40.745]                           }
[17:37:40.745]                         }
[17:37:40.745]                         frame <- frame + 1L
[17:37:40.745]                         envir <- sys.frame(frame)
[17:37:40.745]                       }
[17:37:40.745]                     }
[17:37:40.745]                     sendCondition <<- function(cond) NULL
[17:37:40.745]                   }
[17:37:40.745]                 })
[17:37:40.745]                 withCallingHandlers({
[17:37:40.745]                   {
[17:37:40.745]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.745]                     if (!identical(...future.globals.maxSize.org, 
[17:37:40.745]                       ...future.globals.maxSize)) {
[17:37:40.745]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.745]                       on.exit(options(oopts), add = TRUE)
[17:37:40.745]                     }
[17:37:40.745]                     {
[17:37:40.745]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:37:40.745]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:37:40.745]                           envir = globalenv(), inherits = FALSE)
[17:37:40.745]                         ...future.FUN(...)
[17:37:40.745]                       }
[17:37:40.745]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:37:40.745]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:37:40.745]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:40.745]                         USE.NAMES = FALSE)
[17:37:40.745]                       do.call(mapply, args = args)
[17:37:40.745]                     }
[17:37:40.745]                   }
[17:37:40.745]                 }, immediateCondition = function(cond) {
[17:37:40.745]                   sendCondition <- ...future.makeSendCondition()
[17:37:40.745]                   sendCondition(cond)
[17:37:40.745]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.745]                   {
[17:37:40.745]                     inherits <- base::inherits
[17:37:40.745]                     invokeRestart <- base::invokeRestart
[17:37:40.745]                     is.null <- base::is.null
[17:37:40.745]                     muffled <- FALSE
[17:37:40.745]                     if (inherits(cond, "message")) {
[17:37:40.745]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:40.745]                       if (muffled) 
[17:37:40.745]                         invokeRestart("muffleMessage")
[17:37:40.745]                     }
[17:37:40.745]                     else if (inherits(cond, "warning")) {
[17:37:40.745]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:40.745]                       if (muffled) 
[17:37:40.745]                         invokeRestart("muffleWarning")
[17:37:40.745]                     }
[17:37:40.745]                     else if (inherits(cond, "condition")) {
[17:37:40.745]                       if (!is.null(pattern)) {
[17:37:40.745]                         computeRestarts <- base::computeRestarts
[17:37:40.745]                         grepl <- base::grepl
[17:37:40.745]                         restarts <- computeRestarts(cond)
[17:37:40.745]                         for (restart in restarts) {
[17:37:40.745]                           name <- restart$name
[17:37:40.745]                           if (is.null(name)) 
[17:37:40.745]                             next
[17:37:40.745]                           if (!grepl(pattern, name)) 
[17:37:40.745]                             next
[17:37:40.745]                           invokeRestart(restart)
[17:37:40.745]                           muffled <- TRUE
[17:37:40.745]                           break
[17:37:40.745]                         }
[17:37:40.745]                       }
[17:37:40.745]                     }
[17:37:40.745]                     invisible(muffled)
[17:37:40.745]                   }
[17:37:40.745]                   muffleCondition(cond)
[17:37:40.745]                 })
[17:37:40.745]             }))
[17:37:40.745]             future::FutureResult(value = ...future.value$value, 
[17:37:40.745]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.745]                   ...future.rng), globalenv = if (FALSE) 
[17:37:40.745]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:40.745]                     ...future.globalenv.names))
[17:37:40.745]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:40.745]         }, condition = base::local({
[17:37:40.745]             c <- base::c
[17:37:40.745]             inherits <- base::inherits
[17:37:40.745]             invokeRestart <- base::invokeRestart
[17:37:40.745]             length <- base::length
[17:37:40.745]             list <- base::list
[17:37:40.745]             seq.int <- base::seq.int
[17:37:40.745]             signalCondition <- base::signalCondition
[17:37:40.745]             sys.calls <- base::sys.calls
[17:37:40.745]             `[[` <- base::`[[`
[17:37:40.745]             `+` <- base::`+`
[17:37:40.745]             `<<-` <- base::`<<-`
[17:37:40.745]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:40.745]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:40.745]                   3L)]
[17:37:40.745]             }
[17:37:40.745]             function(cond) {
[17:37:40.745]                 is_error <- inherits(cond, "error")
[17:37:40.745]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:40.745]                   NULL)
[17:37:40.745]                 if (is_error) {
[17:37:40.745]                   sessionInformation <- function() {
[17:37:40.745]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:40.745]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:40.745]                       search = base::search(), system = base::Sys.info())
[17:37:40.745]                   }
[17:37:40.745]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.745]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:40.745]                     cond$call), session = sessionInformation(), 
[17:37:40.745]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:40.745]                   signalCondition(cond)
[17:37:40.745]                 }
[17:37:40.745]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:40.745]                 "immediateCondition"))) {
[17:37:40.745]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:40.745]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.745]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:40.745]                   if (TRUE && !signal) {
[17:37:40.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.745]                     {
[17:37:40.745]                       inherits <- base::inherits
[17:37:40.745]                       invokeRestart <- base::invokeRestart
[17:37:40.745]                       is.null <- base::is.null
[17:37:40.745]                       muffled <- FALSE
[17:37:40.745]                       if (inherits(cond, "message")) {
[17:37:40.745]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.745]                         if (muffled) 
[17:37:40.745]                           invokeRestart("muffleMessage")
[17:37:40.745]                       }
[17:37:40.745]                       else if (inherits(cond, "warning")) {
[17:37:40.745]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.745]                         if (muffled) 
[17:37:40.745]                           invokeRestart("muffleWarning")
[17:37:40.745]                       }
[17:37:40.745]                       else if (inherits(cond, "condition")) {
[17:37:40.745]                         if (!is.null(pattern)) {
[17:37:40.745]                           computeRestarts <- base::computeRestarts
[17:37:40.745]                           grepl <- base::grepl
[17:37:40.745]                           restarts <- computeRestarts(cond)
[17:37:40.745]                           for (restart in restarts) {
[17:37:40.745]                             name <- restart$name
[17:37:40.745]                             if (is.null(name)) 
[17:37:40.745]                               next
[17:37:40.745]                             if (!grepl(pattern, name)) 
[17:37:40.745]                               next
[17:37:40.745]                             invokeRestart(restart)
[17:37:40.745]                             muffled <- TRUE
[17:37:40.745]                             break
[17:37:40.745]                           }
[17:37:40.745]                         }
[17:37:40.745]                       }
[17:37:40.745]                       invisible(muffled)
[17:37:40.745]                     }
[17:37:40.745]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.745]                   }
[17:37:40.745]                 }
[17:37:40.745]                 else {
[17:37:40.745]                   if (TRUE) {
[17:37:40.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.745]                     {
[17:37:40.745]                       inherits <- base::inherits
[17:37:40.745]                       invokeRestart <- base::invokeRestart
[17:37:40.745]                       is.null <- base::is.null
[17:37:40.745]                       muffled <- FALSE
[17:37:40.745]                       if (inherits(cond, "message")) {
[17:37:40.745]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.745]                         if (muffled) 
[17:37:40.745]                           invokeRestart("muffleMessage")
[17:37:40.745]                       }
[17:37:40.745]                       else if (inherits(cond, "warning")) {
[17:37:40.745]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.745]                         if (muffled) 
[17:37:40.745]                           invokeRestart("muffleWarning")
[17:37:40.745]                       }
[17:37:40.745]                       else if (inherits(cond, "condition")) {
[17:37:40.745]                         if (!is.null(pattern)) {
[17:37:40.745]                           computeRestarts <- base::computeRestarts
[17:37:40.745]                           grepl <- base::grepl
[17:37:40.745]                           restarts <- computeRestarts(cond)
[17:37:40.745]                           for (restart in restarts) {
[17:37:40.745]                             name <- restart$name
[17:37:40.745]                             if (is.null(name)) 
[17:37:40.745]                               next
[17:37:40.745]                             if (!grepl(pattern, name)) 
[17:37:40.745]                               next
[17:37:40.745]                             invokeRestart(restart)
[17:37:40.745]                             muffled <- TRUE
[17:37:40.745]                             break
[17:37:40.745]                           }
[17:37:40.745]                         }
[17:37:40.745]                       }
[17:37:40.745]                       invisible(muffled)
[17:37:40.745]                     }
[17:37:40.745]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.745]                   }
[17:37:40.745]                 }
[17:37:40.745]             }
[17:37:40.745]         }))
[17:37:40.745]     }, error = function(ex) {
[17:37:40.745]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:40.745]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.745]                 ...future.rng), started = ...future.startTime, 
[17:37:40.745]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:40.745]             version = "1.8"), class = "FutureResult")
[17:37:40.745]     }, finally = {
[17:37:40.745]         if (!identical(...future.workdir, getwd())) 
[17:37:40.745]             setwd(...future.workdir)
[17:37:40.745]         {
[17:37:40.745]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:40.745]                 ...future.oldOptions$nwarnings <- NULL
[17:37:40.745]             }
[17:37:40.745]             base::options(...future.oldOptions)
[17:37:40.745]             if (.Platform$OS.type == "windows") {
[17:37:40.745]                 old_names <- names(...future.oldEnvVars)
[17:37:40.745]                 envs <- base::Sys.getenv()
[17:37:40.745]                 names <- names(envs)
[17:37:40.745]                 common <- intersect(names, old_names)
[17:37:40.745]                 added <- setdiff(names, old_names)
[17:37:40.745]                 removed <- setdiff(old_names, names)
[17:37:40.745]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:40.745]                   envs[common]]
[17:37:40.745]                 NAMES <- toupper(changed)
[17:37:40.745]                 args <- list()
[17:37:40.745]                 for (kk in seq_along(NAMES)) {
[17:37:40.745]                   name <- changed[[kk]]
[17:37:40.745]                   NAME <- NAMES[[kk]]
[17:37:40.745]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.745]                     next
[17:37:40.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.745]                 }
[17:37:40.745]                 NAMES <- toupper(added)
[17:37:40.745]                 for (kk in seq_along(NAMES)) {
[17:37:40.745]                   name <- added[[kk]]
[17:37:40.745]                   NAME <- NAMES[[kk]]
[17:37:40.745]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.745]                     next
[17:37:40.745]                   args[[name]] <- ""
[17:37:40.745]                 }
[17:37:40.745]                 NAMES <- toupper(removed)
[17:37:40.745]                 for (kk in seq_along(NAMES)) {
[17:37:40.745]                   name <- removed[[kk]]
[17:37:40.745]                   NAME <- NAMES[[kk]]
[17:37:40.745]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.745]                     next
[17:37:40.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.745]                 }
[17:37:40.745]                 if (length(args) > 0) 
[17:37:40.745]                   base::do.call(base::Sys.setenv, args = args)
[17:37:40.745]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:40.745]             }
[17:37:40.745]             else {
[17:37:40.745]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:40.745]             }
[17:37:40.745]             {
[17:37:40.745]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:40.745]                   0L) {
[17:37:40.745]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:40.745]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:40.745]                   base::options(opts)
[17:37:40.745]                 }
[17:37:40.745]                 {
[17:37:40.745]                   {
[17:37:40.745]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:40.745]                     NULL
[17:37:40.745]                   }
[17:37:40.745]                   options(future.plan = NULL)
[17:37:40.745]                   if (is.na(NA_character_)) 
[17:37:40.745]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.745]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:40.745]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:40.745]                     .init = FALSE)
[17:37:40.745]                 }
[17:37:40.745]             }
[17:37:40.745]         }
[17:37:40.745]     })
[17:37:40.745]     if (TRUE) {
[17:37:40.745]         base::sink(type = "output", split = FALSE)
[17:37:40.745]         if (TRUE) {
[17:37:40.745]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:40.745]         }
[17:37:40.745]         else {
[17:37:40.745]             ...future.result["stdout"] <- base::list(NULL)
[17:37:40.745]         }
[17:37:40.745]         base::close(...future.stdout)
[17:37:40.745]         ...future.stdout <- NULL
[17:37:40.745]     }
[17:37:40.745]     ...future.result$conditions <- ...future.conditions
[17:37:40.745]     ...future.result$finished <- base::Sys.time()
[17:37:40.745]     ...future.result
[17:37:40.745] }
[17:37:40.747] Exporting 5 global objects (2.47 KiB) to cluster node #2 ...
[17:37:40.748] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #2 ...
[17:37:40.748] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #2 ... DONE
[17:37:40.748] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[17:37:40.748] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[17:37:40.749] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:37:40.749] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:37:40.749] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #2 ...
[17:37:40.749] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #2 ... DONE
[17:37:40.750] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:37:40.750] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:37:40.750] Exporting 5 global objects (2.47 KiB) to cluster node #2 ... DONE
[17:37:40.750] MultisessionFuture started
[17:37:40.751] - Launch lazy future ... done
[17:37:40.751] run() for ‘MultisessionFuture’ ... done
[17:37:40.751] Created future:
[17:37:40.751] MultisessionFuture:
[17:37:40.751] Label: ‘future_mapply-2’
[17:37:40.751] Expression:
[17:37:40.751] {
[17:37:40.751]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.751]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:40.751]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.751]         on.exit(options(oopts), add = TRUE)
[17:37:40.751]     }
[17:37:40.751]     {
[17:37:40.751]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:37:40.751]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:37:40.751]                 inherits = FALSE)
[17:37:40.751]             ...future.FUN(...)
[17:37:40.751]         }
[17:37:40.751]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:37:40.751]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:37:40.751]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:40.751]         do.call(mapply, args = args)
[17:37:40.751]     }
[17:37:40.751] }
[17:37:40.751] Lazy evaluation: FALSE
[17:37:40.751] Asynchronous evaluation: TRUE
[17:37:40.751] Local evaluation: TRUE
[17:37:40.751] Environment: R_GlobalEnv
[17:37:40.751] Capture standard output: TRUE
[17:37:40.751] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:40.751] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:40.751] Packages: 1 packages (‘stats’)
[17:37:40.751] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:37:40.751] Resolved: FALSE
[17:37:40.751] Value: <not collected>
[17:37:40.751] Conditions captured: <none>
[17:37:40.751] Early signaling: FALSE
[17:37:40.751] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:40.751] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.762] Chunk #2 of 2 ... DONE
[17:37:40.762] Launching 2 futures (chunks) ... DONE
[17:37:40.762] Resolving 2 futures (chunks) ...
[17:37:40.763] resolve() on list ...
[17:37:40.763]  recursive: 0
[17:37:40.763]  length: 2
[17:37:40.763] 
[17:37:40.763] receiveMessageFromWorker() for ClusterFuture ...
[17:37:40.763] - Validating connection of MultisessionFuture
[17:37:40.764] - received message: FutureResult
[17:37:40.764] - Received FutureResult
[17:37:40.764] - Erased future from FutureRegistry
[17:37:40.764] result() for ClusterFuture ...
[17:37:40.764] - result already collected: FutureResult
[17:37:40.764] result() for ClusterFuture ... done
[17:37:40.764] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:40.764] Future #1
[17:37:40.764] result() for ClusterFuture ...
[17:37:40.764] - result already collected: FutureResult
[17:37:40.765] result() for ClusterFuture ... done
[17:37:40.765] result() for ClusterFuture ...
[17:37:40.765] - result already collected: FutureResult
[17:37:40.765] result() for ClusterFuture ... done
[17:37:40.765] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:37:40.765] - nx: 2
[17:37:40.765] - relay: TRUE
[17:37:40.765] - stdout: TRUE
[17:37:40.765] - signal: TRUE
[17:37:40.765] - resignal: FALSE
[17:37:40.765] - force: TRUE
[17:37:40.765] - relayed: [n=2] FALSE, FALSE
[17:37:40.766] - queued futures: [n=2] FALSE, FALSE
[17:37:40.766]  - until=1
[17:37:40.766]  - relaying element #1
[17:37:40.766] result() for ClusterFuture ...
[17:37:40.766] - result already collected: FutureResult
[17:37:40.766] result() for ClusterFuture ... done
[17:37:40.766] result() for ClusterFuture ...
[17:37:40.766] - result already collected: FutureResult
[17:37:40.766] result() for ClusterFuture ... done
[17:37:40.766] result() for ClusterFuture ...
[17:37:40.766] - result already collected: FutureResult
[17:37:40.767] result() for ClusterFuture ... done
[17:37:40.767] result() for ClusterFuture ...
[17:37:40.767] - result already collected: FutureResult
[17:37:40.767] result() for ClusterFuture ... done
[17:37:40.767] - relayed: [n=2] TRUE, FALSE
[17:37:40.767] - queued futures: [n=2] TRUE, FALSE
[17:37:40.767] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:37:40.767]  length: 1 (resolved future 1)
[17:37:40.794] receiveMessageFromWorker() for ClusterFuture ...
[17:37:40.794] - Validating connection of MultisessionFuture
[17:37:40.794] - received message: FutureResult
[17:37:40.795] - Received FutureResult
[17:37:40.795] - Erased future from FutureRegistry
[17:37:40.795] result() for ClusterFuture ...
[17:37:40.795] - result already collected: FutureResult
[17:37:40.795] result() for ClusterFuture ... done
[17:37:40.795] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:40.795] Future #2
[17:37:40.795] result() for ClusterFuture ...
[17:37:40.795] - result already collected: FutureResult
[17:37:40.795] result() for ClusterFuture ... done
[17:37:40.795] result() for ClusterFuture ...
[17:37:40.796] - result already collected: FutureResult
[17:37:40.796] result() for ClusterFuture ... done
[17:37:40.796] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:37:40.796] - nx: 2
[17:37:40.796] - relay: TRUE
[17:37:40.796] - stdout: TRUE
[17:37:40.796] - signal: TRUE
[17:37:40.796] - resignal: FALSE
[17:37:40.796] - force: TRUE
[17:37:40.796] - relayed: [n=2] TRUE, FALSE
[17:37:40.796] - queued futures: [n=2] TRUE, FALSE
[17:37:40.797]  - until=2
[17:37:40.797]  - relaying element #2
[17:37:40.797] result() for ClusterFuture ...
[17:37:40.797] - result already collected: FutureResult
[17:37:40.797] result() for ClusterFuture ... done
[17:37:40.797] result() for ClusterFuture ...
[17:37:40.797] - result already collected: FutureResult
[17:37:40.797] result() for ClusterFuture ... done
[17:37:40.797] result() for ClusterFuture ...
[17:37:40.797] - result already collected: FutureResult
[17:37:40.797] result() for ClusterFuture ... done
[17:37:40.798] result() for ClusterFuture ...
[17:37:40.798] - result already collected: FutureResult
[17:37:40.798] result() for ClusterFuture ... done
[17:37:40.798] - relayed: [n=2] TRUE, TRUE
[17:37:40.798] - queued futures: [n=2] TRUE, TRUE
[17:37:40.798] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:37:40.798]  length: 0 (resolved future 2)
[17:37:40.798] Relaying remaining futures
[17:37:40.798] signalConditionsASAP(NULL, pos=0) ...
[17:37:40.798] - nx: 2
[17:37:40.798] - relay: TRUE
[17:37:40.798] - stdout: TRUE
[17:37:40.799] - signal: TRUE
[17:37:40.799] - resignal: FALSE
[17:37:40.799] - force: TRUE
[17:37:40.799] - relayed: [n=2] TRUE, TRUE
[17:37:40.799] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:40.799] - relayed: [n=2] TRUE, TRUE
[17:37:40.799] - queued futures: [n=2] TRUE, TRUE
[17:37:40.799] signalConditionsASAP(NULL, pos=0) ... done
[17:37:40.799] resolve() on list ... DONE
[17:37:40.799] result() for ClusterFuture ...
[17:37:40.799] - result already collected: FutureResult
[17:37:40.800] result() for ClusterFuture ... done
[17:37:40.800] result() for ClusterFuture ...
[17:37:40.800] - result already collected: FutureResult
[17:37:40.800] result() for ClusterFuture ... done
[17:37:40.800] result() for ClusterFuture ...
[17:37:40.800] - result already collected: FutureResult
[17:37:40.800] result() for ClusterFuture ... done
[17:37:40.800] result() for ClusterFuture ...
[17:37:40.800] - result already collected: FutureResult
[17:37:40.800] result() for ClusterFuture ... done
[17:37:40.800]  - Number of value chunks collected: 2
[17:37:40.801] Resolving 2 futures (chunks) ... DONE
[17:37:40.801] Reducing values from 2 chunks ...
[17:37:40.801]  - Number of values collected after concatenation: 4
[17:37:40.801]  - Number of values expected: 4
[17:37:40.801] Reducing values from 2 chunks ... DONE
[17:37:40.801] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[17:37:40.802] future_mapply() ...
[17:37:40.805] Number of chunks: 2
[17:37:40.805] getGlobalsAndPackagesXApply() ...
[17:37:40.805]  - future.globals: TRUE
[17:37:40.806] getGlobalsAndPackages() ...
[17:37:40.806] Searching for globals...
[17:37:40.807] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:37:40.807] Searching for globals ... DONE
[17:37:40.807] Resolving globals: FALSE
[17:37:40.807] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[17:37:40.808] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[17:37:40.808] - globals: [1] ‘FUN’
[17:37:40.808] - packages: [1] ‘stats’
[17:37:40.808] getGlobalsAndPackages() ... DONE
[17:37:40.808]  - globals found/used: [n=1] ‘FUN’
[17:37:40.808]  - needed namespaces: [n=1] ‘stats’
[17:37:40.808] Finding globals ... DONE
[17:37:40.809] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:40.809] List of 2
[17:37:40.809]  $ ...future.FUN:function (x, w, ...)  
[17:37:40.809]  $ MoreArgs     : NULL
[17:37:40.809]  - attr(*, "where")=List of 2
[17:37:40.809]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:40.809]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:40.809]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:40.809]  - attr(*, "resolved")= logi FALSE
[17:37:40.809]  - attr(*, "total_size")= num NA
[17:37:40.811] Packages to be attached in all futures: [n=1] ‘stats’
[17:37:40.811] getGlobalsAndPackagesXApply() ... DONE
[17:37:40.811] Number of futures (= number of chunks): 2
[17:37:40.811] Launching 2 futures (chunks) ...
[17:37:40.812] Chunk #1 of 2 ...
[17:37:40.812]  - Finding globals in '...' for chunk #1 ...
[17:37:40.812] getGlobalsAndPackages() ...
[17:37:40.812] Searching for globals...
[17:37:40.812] 
[17:37:40.812] Searching for globals ... DONE
[17:37:40.812] - globals: [0] <none>
[17:37:40.812] getGlobalsAndPackages() ... DONE
[17:37:40.813]    + additional globals found: [n=0] 
[17:37:40.813]    + additional namespaces needed: [n=0] 
[17:37:40.813]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:40.813]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:40.813]  - seeds: <none>
[17:37:40.813]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.813] getGlobalsAndPackages() ...
[17:37:40.813] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.813] Resolving globals: FALSE
[17:37:40.814] The total size of the 5 globals is 2.07 KiB (2120 bytes)
[17:37:40.814] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.07 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (704 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:40.814] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.814] - packages: [1] ‘stats’
[17:37:40.815] getGlobalsAndPackages() ... DONE
[17:37:40.815] run() for ‘Future’ ...
[17:37:40.815] - state: ‘created’
[17:37:40.815] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:40.828] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.828] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:40.829]   - Field: ‘node’
[17:37:40.829]   - Field: ‘label’
[17:37:40.829]   - Field: ‘local’
[17:37:40.829]   - Field: ‘owner’
[17:37:40.829]   - Field: ‘envir’
[17:37:40.829]   - Field: ‘workers’
[17:37:40.829]   - Field: ‘packages’
[17:37:40.829]   - Field: ‘gc’
[17:37:40.829]   - Field: ‘conditions’
[17:37:40.829]   - Field: ‘persistent’
[17:37:40.829]   - Field: ‘expr’
[17:37:40.830]   - Field: ‘uuid’
[17:37:40.830]   - Field: ‘seed’
[17:37:40.830]   - Field: ‘version’
[17:37:40.830]   - Field: ‘result’
[17:37:40.830]   - Field: ‘asynchronous’
[17:37:40.830]   - Field: ‘calls’
[17:37:40.830]   - Field: ‘globals’
[17:37:40.830]   - Field: ‘stdout’
[17:37:40.830]   - Field: ‘earlySignal’
[17:37:40.830]   - Field: ‘lazy’
[17:37:40.830]   - Field: ‘state’
[17:37:40.830] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:40.831] - Launch lazy future ...
[17:37:40.831] Packages needed by the future expression (n = 1): ‘stats’
[17:37:40.831] Packages needed by future strategies (n = 0): <none>
[17:37:40.831] {
[17:37:40.831]     {
[17:37:40.831]         {
[17:37:40.831]             ...future.startTime <- base::Sys.time()
[17:37:40.831]             {
[17:37:40.831]                 {
[17:37:40.831]                   {
[17:37:40.831]                     {
[17:37:40.831]                       {
[17:37:40.831]                         base::local({
[17:37:40.831]                           has_future <- base::requireNamespace("future", 
[17:37:40.831]                             quietly = TRUE)
[17:37:40.831]                           if (has_future) {
[17:37:40.831]                             ns <- base::getNamespace("future")
[17:37:40.831]                             version <- ns[[".package"]][["version"]]
[17:37:40.831]                             if (is.null(version)) 
[17:37:40.831]                               version <- utils::packageVersion("future")
[17:37:40.831]                           }
[17:37:40.831]                           else {
[17:37:40.831]                             version <- NULL
[17:37:40.831]                           }
[17:37:40.831]                           if (!has_future || version < "1.8.0") {
[17:37:40.831]                             info <- base::c(r_version = base::gsub("R version ", 
[17:37:40.831]                               "", base::R.version$version.string), 
[17:37:40.831]                               platform = base::sprintf("%s (%s-bit)", 
[17:37:40.831]                                 base::R.version$platform, 8 * 
[17:37:40.831]                                   base::.Machine$sizeof.pointer), 
[17:37:40.831]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:40.831]                                 "release", "version")], collapse = " "), 
[17:37:40.831]                               hostname = base::Sys.info()[["nodename"]])
[17:37:40.831]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:37:40.831]                               info)
[17:37:40.831]                             info <- base::paste(info, collapse = "; ")
[17:37:40.831]                             if (!has_future) {
[17:37:40.831]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:40.831]                                 info)
[17:37:40.831]                             }
[17:37:40.831]                             else {
[17:37:40.831]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:40.831]                                 info, version)
[17:37:40.831]                             }
[17:37:40.831]                             base::stop(msg)
[17:37:40.831]                           }
[17:37:40.831]                         })
[17:37:40.831]                       }
[17:37:40.831]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:40.831]                       base::options(mc.cores = 1L)
[17:37:40.831]                     }
[17:37:40.831]                     base::local({
[17:37:40.831]                       for (pkg in "stats") {
[17:37:40.831]                         base::loadNamespace(pkg)
[17:37:40.831]                         base::library(pkg, character.only = TRUE)
[17:37:40.831]                       }
[17:37:40.831]                     })
[17:37:40.831]                   }
[17:37:40.831]                   ...future.strategy.old <- future::plan("list")
[17:37:40.831]                   options(future.plan = NULL)
[17:37:40.831]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.831]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:40.831]                 }
[17:37:40.831]                 ...future.workdir <- getwd()
[17:37:40.831]             }
[17:37:40.831]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:40.831]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:40.831]         }
[17:37:40.831]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:40.831]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:40.831]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:40.831]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:40.831]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:40.831]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:40.831]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:40.831]             base::names(...future.oldOptions))
[17:37:40.831]     }
[17:37:40.831]     if (FALSE) {
[17:37:40.831]     }
[17:37:40.831]     else {
[17:37:40.831]         if (TRUE) {
[17:37:40.831]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:40.831]                 open = "w")
[17:37:40.831]         }
[17:37:40.831]         else {
[17:37:40.831]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:40.831]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:40.831]         }
[17:37:40.831]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:40.831]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:40.831]             base::sink(type = "output", split = FALSE)
[17:37:40.831]             base::close(...future.stdout)
[17:37:40.831]         }, add = TRUE)
[17:37:40.831]     }
[17:37:40.831]     ...future.frame <- base::sys.nframe()
[17:37:40.831]     ...future.conditions <- base::list()
[17:37:40.831]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:40.831]     if (FALSE) {
[17:37:40.831]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:40.831]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:40.831]     }
[17:37:40.831]     ...future.result <- base::tryCatch({
[17:37:40.831]         base::withCallingHandlers({
[17:37:40.831]             ...future.value <- base::withVisible(base::local({
[17:37:40.831]                 ...future.makeSendCondition <- base::local({
[17:37:40.831]                   sendCondition <- NULL
[17:37:40.831]                   function(frame = 1L) {
[17:37:40.831]                     if (is.function(sendCondition)) 
[17:37:40.831]                       return(sendCondition)
[17:37:40.831]                     ns <- getNamespace("parallel")
[17:37:40.831]                     if (exists("sendData", mode = "function", 
[17:37:40.831]                       envir = ns)) {
[17:37:40.831]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:40.831]                         envir = ns)
[17:37:40.831]                       envir <- sys.frame(frame)
[17:37:40.831]                       master <- NULL
[17:37:40.831]                       while (!identical(envir, .GlobalEnv) && 
[17:37:40.831]                         !identical(envir, emptyenv())) {
[17:37:40.831]                         if (exists("master", mode = "list", envir = envir, 
[17:37:40.831]                           inherits = FALSE)) {
[17:37:40.831]                           master <- get("master", mode = "list", 
[17:37:40.831]                             envir = envir, inherits = FALSE)
[17:37:40.831]                           if (inherits(master, c("SOCKnode", 
[17:37:40.831]                             "SOCK0node"))) {
[17:37:40.831]                             sendCondition <<- function(cond) {
[17:37:40.831]                               data <- list(type = "VALUE", value = cond, 
[17:37:40.831]                                 success = TRUE)
[17:37:40.831]                               parallel_sendData(master, data)
[17:37:40.831]                             }
[17:37:40.831]                             return(sendCondition)
[17:37:40.831]                           }
[17:37:40.831]                         }
[17:37:40.831]                         frame <- frame + 1L
[17:37:40.831]                         envir <- sys.frame(frame)
[17:37:40.831]                       }
[17:37:40.831]                     }
[17:37:40.831]                     sendCondition <<- function(cond) NULL
[17:37:40.831]                   }
[17:37:40.831]                 })
[17:37:40.831]                 withCallingHandlers({
[17:37:40.831]                   {
[17:37:40.831]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.831]                     if (!identical(...future.globals.maxSize.org, 
[17:37:40.831]                       ...future.globals.maxSize)) {
[17:37:40.831]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.831]                       on.exit(options(oopts), add = TRUE)
[17:37:40.831]                     }
[17:37:40.831]                     {
[17:37:40.831]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.831]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:40.831]                         USE.NAMES = FALSE)
[17:37:40.831]                       do.call(mapply, args = args)
[17:37:40.831]                     }
[17:37:40.831]                   }
[17:37:40.831]                 }, immediateCondition = function(cond) {
[17:37:40.831]                   sendCondition <- ...future.makeSendCondition()
[17:37:40.831]                   sendCondition(cond)
[17:37:40.831]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.831]                   {
[17:37:40.831]                     inherits <- base::inherits
[17:37:40.831]                     invokeRestart <- base::invokeRestart
[17:37:40.831]                     is.null <- base::is.null
[17:37:40.831]                     muffled <- FALSE
[17:37:40.831]                     if (inherits(cond, "message")) {
[17:37:40.831]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:40.831]                       if (muffled) 
[17:37:40.831]                         invokeRestart("muffleMessage")
[17:37:40.831]                     }
[17:37:40.831]                     else if (inherits(cond, "warning")) {
[17:37:40.831]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:40.831]                       if (muffled) 
[17:37:40.831]                         invokeRestart("muffleWarning")
[17:37:40.831]                     }
[17:37:40.831]                     else if (inherits(cond, "condition")) {
[17:37:40.831]                       if (!is.null(pattern)) {
[17:37:40.831]                         computeRestarts <- base::computeRestarts
[17:37:40.831]                         grepl <- base::grepl
[17:37:40.831]                         restarts <- computeRestarts(cond)
[17:37:40.831]                         for (restart in restarts) {
[17:37:40.831]                           name <- restart$name
[17:37:40.831]                           if (is.null(name)) 
[17:37:40.831]                             next
[17:37:40.831]                           if (!grepl(pattern, name)) 
[17:37:40.831]                             next
[17:37:40.831]                           invokeRestart(restart)
[17:37:40.831]                           muffled <- TRUE
[17:37:40.831]                           break
[17:37:40.831]                         }
[17:37:40.831]                       }
[17:37:40.831]                     }
[17:37:40.831]                     invisible(muffled)
[17:37:40.831]                   }
[17:37:40.831]                   muffleCondition(cond)
[17:37:40.831]                 })
[17:37:40.831]             }))
[17:37:40.831]             future::FutureResult(value = ...future.value$value, 
[17:37:40.831]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.831]                   ...future.rng), globalenv = if (FALSE) 
[17:37:40.831]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:40.831]                     ...future.globalenv.names))
[17:37:40.831]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:40.831]         }, condition = base::local({
[17:37:40.831]             c <- base::c
[17:37:40.831]             inherits <- base::inherits
[17:37:40.831]             invokeRestart <- base::invokeRestart
[17:37:40.831]             length <- base::length
[17:37:40.831]             list <- base::list
[17:37:40.831]             seq.int <- base::seq.int
[17:37:40.831]             signalCondition <- base::signalCondition
[17:37:40.831]             sys.calls <- base::sys.calls
[17:37:40.831]             `[[` <- base::`[[`
[17:37:40.831]             `+` <- base::`+`
[17:37:40.831]             `<<-` <- base::`<<-`
[17:37:40.831]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:40.831]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:40.831]                   3L)]
[17:37:40.831]             }
[17:37:40.831]             function(cond) {
[17:37:40.831]                 is_error <- inherits(cond, "error")
[17:37:40.831]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:40.831]                   NULL)
[17:37:40.831]                 if (is_error) {
[17:37:40.831]                   sessionInformation <- function() {
[17:37:40.831]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:40.831]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:40.831]                       search = base::search(), system = base::Sys.info())
[17:37:40.831]                   }
[17:37:40.831]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.831]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:40.831]                     cond$call), session = sessionInformation(), 
[17:37:40.831]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:40.831]                   signalCondition(cond)
[17:37:40.831]                 }
[17:37:40.831]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:40.831]                 "immediateCondition"))) {
[17:37:40.831]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:40.831]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.831]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:40.831]                   if (TRUE && !signal) {
[17:37:40.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.831]                     {
[17:37:40.831]                       inherits <- base::inherits
[17:37:40.831]                       invokeRestart <- base::invokeRestart
[17:37:40.831]                       is.null <- base::is.null
[17:37:40.831]                       muffled <- FALSE
[17:37:40.831]                       if (inherits(cond, "message")) {
[17:37:40.831]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.831]                         if (muffled) 
[17:37:40.831]                           invokeRestart("muffleMessage")
[17:37:40.831]                       }
[17:37:40.831]                       else if (inherits(cond, "warning")) {
[17:37:40.831]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.831]                         if (muffled) 
[17:37:40.831]                           invokeRestart("muffleWarning")
[17:37:40.831]                       }
[17:37:40.831]                       else if (inherits(cond, "condition")) {
[17:37:40.831]                         if (!is.null(pattern)) {
[17:37:40.831]                           computeRestarts <- base::computeRestarts
[17:37:40.831]                           grepl <- base::grepl
[17:37:40.831]                           restarts <- computeRestarts(cond)
[17:37:40.831]                           for (restart in restarts) {
[17:37:40.831]                             name <- restart$name
[17:37:40.831]                             if (is.null(name)) 
[17:37:40.831]                               next
[17:37:40.831]                             if (!grepl(pattern, name)) 
[17:37:40.831]                               next
[17:37:40.831]                             invokeRestart(restart)
[17:37:40.831]                             muffled <- TRUE
[17:37:40.831]                             break
[17:37:40.831]                           }
[17:37:40.831]                         }
[17:37:40.831]                       }
[17:37:40.831]                       invisible(muffled)
[17:37:40.831]                     }
[17:37:40.831]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.831]                   }
[17:37:40.831]                 }
[17:37:40.831]                 else {
[17:37:40.831]                   if (TRUE) {
[17:37:40.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.831]                     {
[17:37:40.831]                       inherits <- base::inherits
[17:37:40.831]                       invokeRestart <- base::invokeRestart
[17:37:40.831]                       is.null <- base::is.null
[17:37:40.831]                       muffled <- FALSE
[17:37:40.831]                       if (inherits(cond, "message")) {
[17:37:40.831]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.831]                         if (muffled) 
[17:37:40.831]                           invokeRestart("muffleMessage")
[17:37:40.831]                       }
[17:37:40.831]                       else if (inherits(cond, "warning")) {
[17:37:40.831]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.831]                         if (muffled) 
[17:37:40.831]                           invokeRestart("muffleWarning")
[17:37:40.831]                       }
[17:37:40.831]                       else if (inherits(cond, "condition")) {
[17:37:40.831]                         if (!is.null(pattern)) {
[17:37:40.831]                           computeRestarts <- base::computeRestarts
[17:37:40.831]                           grepl <- base::grepl
[17:37:40.831]                           restarts <- computeRestarts(cond)
[17:37:40.831]                           for (restart in restarts) {
[17:37:40.831]                             name <- restart$name
[17:37:40.831]                             if (is.null(name)) 
[17:37:40.831]                               next
[17:37:40.831]                             if (!grepl(pattern, name)) 
[17:37:40.831]                               next
[17:37:40.831]                             invokeRestart(restart)
[17:37:40.831]                             muffled <- TRUE
[17:37:40.831]                             break
[17:37:40.831]                           }
[17:37:40.831]                         }
[17:37:40.831]                       }
[17:37:40.831]                       invisible(muffled)
[17:37:40.831]                     }
[17:37:40.831]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.831]                   }
[17:37:40.831]                 }
[17:37:40.831]             }
[17:37:40.831]         }))
[17:37:40.831]     }, error = function(ex) {
[17:37:40.831]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:40.831]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.831]                 ...future.rng), started = ...future.startTime, 
[17:37:40.831]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:40.831]             version = "1.8"), class = "FutureResult")
[17:37:40.831]     }, finally = {
[17:37:40.831]         if (!identical(...future.workdir, getwd())) 
[17:37:40.831]             setwd(...future.workdir)
[17:37:40.831]         {
[17:37:40.831]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:40.831]                 ...future.oldOptions$nwarnings <- NULL
[17:37:40.831]             }
[17:37:40.831]             base::options(...future.oldOptions)
[17:37:40.831]             if (.Platform$OS.type == "windows") {
[17:37:40.831]                 old_names <- names(...future.oldEnvVars)
[17:37:40.831]                 envs <- base::Sys.getenv()
[17:37:40.831]                 names <- names(envs)
[17:37:40.831]                 common <- intersect(names, old_names)
[17:37:40.831]                 added <- setdiff(names, old_names)
[17:37:40.831]                 removed <- setdiff(old_names, names)
[17:37:40.831]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:40.831]                   envs[common]]
[17:37:40.831]                 NAMES <- toupper(changed)
[17:37:40.831]                 args <- list()
[17:37:40.831]                 for (kk in seq_along(NAMES)) {
[17:37:40.831]                   name <- changed[[kk]]
[17:37:40.831]                   NAME <- NAMES[[kk]]
[17:37:40.831]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.831]                     next
[17:37:40.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.831]                 }
[17:37:40.831]                 NAMES <- toupper(added)
[17:37:40.831]                 for (kk in seq_along(NAMES)) {
[17:37:40.831]                   name <- added[[kk]]
[17:37:40.831]                   NAME <- NAMES[[kk]]
[17:37:40.831]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.831]                     next
[17:37:40.831]                   args[[name]] <- ""
[17:37:40.831]                 }
[17:37:40.831]                 NAMES <- toupper(removed)
[17:37:40.831]                 for (kk in seq_along(NAMES)) {
[17:37:40.831]                   name <- removed[[kk]]
[17:37:40.831]                   NAME <- NAMES[[kk]]
[17:37:40.831]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.831]                     next
[17:37:40.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.831]                 }
[17:37:40.831]                 if (length(args) > 0) 
[17:37:40.831]                   base::do.call(base::Sys.setenv, args = args)
[17:37:40.831]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:40.831]             }
[17:37:40.831]             else {
[17:37:40.831]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:40.831]             }
[17:37:40.831]             {
[17:37:40.831]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:40.831]                   0L) {
[17:37:40.831]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:40.831]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:40.831]                   base::options(opts)
[17:37:40.831]                 }
[17:37:40.831]                 {
[17:37:40.831]                   {
[17:37:40.831]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:40.831]                     NULL
[17:37:40.831]                   }
[17:37:40.831]                   options(future.plan = NULL)
[17:37:40.831]                   if (is.na(NA_character_)) 
[17:37:40.831]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.831]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:40.831]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:40.831]                     .init = FALSE)
[17:37:40.831]                 }
[17:37:40.831]             }
[17:37:40.831]         }
[17:37:40.831]     })
[17:37:40.831]     if (TRUE) {
[17:37:40.831]         base::sink(type = "output", split = FALSE)
[17:37:40.831]         if (TRUE) {
[17:37:40.831]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:40.831]         }
[17:37:40.831]         else {
[17:37:40.831]             ...future.result["stdout"] <- base::list(NULL)
[17:37:40.831]         }
[17:37:40.831]         base::close(...future.stdout)
[17:37:40.831]         ...future.stdout <- NULL
[17:37:40.831]     }
[17:37:40.831]     ...future.result$conditions <- ...future.conditions
[17:37:40.831]     ...future.result$finished <- base::Sys.time()
[17:37:40.831]     ...future.result
[17:37:40.831] }
[17:37:40.834] Exporting 5 global objects (2.07 KiB) to cluster node #1 ...
[17:37:40.834] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #1 ...
[17:37:40.835] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #1 ... DONE
[17:37:40.835] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:37:40.835] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:37:40.835] Exporting ‘...future.elements_ii’ (704 bytes) to cluster node #1 ...
[17:37:40.836] Exporting ‘...future.elements_ii’ (704 bytes) to cluster node #1 ... DONE
[17:37:40.836] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:40.836] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:40.836] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:40.837] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:40.837] Exporting 5 global objects (2.07 KiB) to cluster node #1 ... DONE
[17:37:40.837] MultisessionFuture started
[17:37:40.837] - Launch lazy future ... done
[17:37:40.837] run() for ‘MultisessionFuture’ ... done
[17:37:40.837] Created future:
[17:37:40.838] MultisessionFuture:
[17:37:40.838] Label: ‘future_Map-1’
[17:37:40.838] Expression:
[17:37:40.838] {
[17:37:40.838]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.838]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:40.838]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.838]         on.exit(options(oopts), add = TRUE)
[17:37:40.838]     }
[17:37:40.838]     {
[17:37:40.838]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.838]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:40.838]         do.call(mapply, args = args)
[17:37:40.838]     }
[17:37:40.838] }
[17:37:40.838] Lazy evaluation: FALSE
[17:37:40.838] Asynchronous evaluation: TRUE
[17:37:40.838] Local evaluation: TRUE
[17:37:40.838] Environment: R_GlobalEnv
[17:37:40.838] Capture standard output: TRUE
[17:37:40.838] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:40.838] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 704 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:40.838] Packages: 1 packages (‘stats’)
[17:37:40.838] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:40.838] Resolved: FALSE
[17:37:40.838] Value: <not collected>
[17:37:40.838] Conditions captured: <none>
[17:37:40.838] Early signaling: FALSE
[17:37:40.838] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:40.838] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.849] Chunk #1 of 2 ... DONE
[17:37:40.849] Chunk #2 of 2 ...
[17:37:40.849]  - Finding globals in '...' for chunk #2 ...
[17:37:40.849] getGlobalsAndPackages() ...
[17:37:40.849] Searching for globals...
[17:37:40.850] 
[17:37:40.850] Searching for globals ... DONE
[17:37:40.850] - globals: [0] <none>
[17:37:40.850] getGlobalsAndPackages() ... DONE
[17:37:40.850]    + additional globals found: [n=0] 
[17:37:40.850]    + additional namespaces needed: [n=0] 
[17:37:40.850]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:40.850]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:40.850]  - seeds: <none>
[17:37:40.850]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.851] getGlobalsAndPackages() ...
[17:37:40.851] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.851] Resolving globals: FALSE
[17:37:40.851] The total size of the 5 globals is 2.41 KiB (2472 bytes)
[17:37:40.852] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.41 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (1.03 KiB of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:40.852] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.852] - packages: [1] ‘stats’
[17:37:40.852] getGlobalsAndPackages() ... DONE
[17:37:40.852] run() for ‘Future’ ...
[17:37:40.852] - state: ‘created’
[17:37:40.853] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:40.866] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.866] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:40.866]   - Field: ‘node’
[17:37:40.866]   - Field: ‘label’
[17:37:40.866]   - Field: ‘local’
[17:37:40.866]   - Field: ‘owner’
[17:37:40.866]   - Field: ‘envir’
[17:37:40.866]   - Field: ‘workers’
[17:37:40.866]   - Field: ‘packages’
[17:37:40.867]   - Field: ‘gc’
[17:37:40.867]   - Field: ‘conditions’
[17:37:40.867]   - Field: ‘persistent’
[17:37:40.867]   - Field: ‘expr’
[17:37:40.867]   - Field: ‘uuid’
[17:37:40.867]   - Field: ‘seed’
[17:37:40.867]   - Field: ‘version’
[17:37:40.867]   - Field: ‘result’
[17:37:40.867]   - Field: ‘asynchronous’
[17:37:40.867]   - Field: ‘calls’
[17:37:40.867]   - Field: ‘globals’
[17:37:40.867]   - Field: ‘stdout’
[17:37:40.868]   - Field: ‘earlySignal’
[17:37:40.868]   - Field: ‘lazy’
[17:37:40.868]   - Field: ‘state’
[17:37:40.868] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:40.868] - Launch lazy future ...
[17:37:40.868] Packages needed by the future expression (n = 1): ‘stats’
[17:37:40.868] Packages needed by future strategies (n = 0): <none>
[17:37:40.869] {
[17:37:40.869]     {
[17:37:40.869]         {
[17:37:40.869]             ...future.startTime <- base::Sys.time()
[17:37:40.869]             {
[17:37:40.869]                 {
[17:37:40.869]                   {
[17:37:40.869]                     {
[17:37:40.869]                       {
[17:37:40.869]                         base::local({
[17:37:40.869]                           has_future <- base::requireNamespace("future", 
[17:37:40.869]                             quietly = TRUE)
[17:37:40.869]                           if (has_future) {
[17:37:40.869]                             ns <- base::getNamespace("future")
[17:37:40.869]                             version <- ns[[".package"]][["version"]]
[17:37:40.869]                             if (is.null(version)) 
[17:37:40.869]                               version <- utils::packageVersion("future")
[17:37:40.869]                           }
[17:37:40.869]                           else {
[17:37:40.869]                             version <- NULL
[17:37:40.869]                           }
[17:37:40.869]                           if (!has_future || version < "1.8.0") {
[17:37:40.869]                             info <- base::c(r_version = base::gsub("R version ", 
[17:37:40.869]                               "", base::R.version$version.string), 
[17:37:40.869]                               platform = base::sprintf("%s (%s-bit)", 
[17:37:40.869]                                 base::R.version$platform, 8 * 
[17:37:40.869]                                   base::.Machine$sizeof.pointer), 
[17:37:40.869]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:40.869]                                 "release", "version")], collapse = " "), 
[17:37:40.869]                               hostname = base::Sys.info()[["nodename"]])
[17:37:40.869]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:37:40.869]                               info)
[17:37:40.869]                             info <- base::paste(info, collapse = "; ")
[17:37:40.869]                             if (!has_future) {
[17:37:40.869]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:40.869]                                 info)
[17:37:40.869]                             }
[17:37:40.869]                             else {
[17:37:40.869]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:40.869]                                 info, version)
[17:37:40.869]                             }
[17:37:40.869]                             base::stop(msg)
[17:37:40.869]                           }
[17:37:40.869]                         })
[17:37:40.869]                       }
[17:37:40.869]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:40.869]                       base::options(mc.cores = 1L)
[17:37:40.869]                     }
[17:37:40.869]                     base::local({
[17:37:40.869]                       for (pkg in "stats") {
[17:37:40.869]                         base::loadNamespace(pkg)
[17:37:40.869]                         base::library(pkg, character.only = TRUE)
[17:37:40.869]                       }
[17:37:40.869]                     })
[17:37:40.869]                   }
[17:37:40.869]                   ...future.strategy.old <- future::plan("list")
[17:37:40.869]                   options(future.plan = NULL)
[17:37:40.869]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.869]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:40.869]                 }
[17:37:40.869]                 ...future.workdir <- getwd()
[17:37:40.869]             }
[17:37:40.869]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:40.869]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:40.869]         }
[17:37:40.869]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:40.869]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:40.869]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:40.869]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:40.869]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:40.869]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:40.869]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:40.869]             base::names(...future.oldOptions))
[17:37:40.869]     }
[17:37:40.869]     if (FALSE) {
[17:37:40.869]     }
[17:37:40.869]     else {
[17:37:40.869]         if (TRUE) {
[17:37:40.869]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:40.869]                 open = "w")
[17:37:40.869]         }
[17:37:40.869]         else {
[17:37:40.869]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:40.869]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:40.869]         }
[17:37:40.869]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:40.869]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:40.869]             base::sink(type = "output", split = FALSE)
[17:37:40.869]             base::close(...future.stdout)
[17:37:40.869]         }, add = TRUE)
[17:37:40.869]     }
[17:37:40.869]     ...future.frame <- base::sys.nframe()
[17:37:40.869]     ...future.conditions <- base::list()
[17:37:40.869]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:40.869]     if (FALSE) {
[17:37:40.869]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:40.869]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:40.869]     }
[17:37:40.869]     ...future.result <- base::tryCatch({
[17:37:40.869]         base::withCallingHandlers({
[17:37:40.869]             ...future.value <- base::withVisible(base::local({
[17:37:40.869]                 ...future.makeSendCondition <- base::local({
[17:37:40.869]                   sendCondition <- NULL
[17:37:40.869]                   function(frame = 1L) {
[17:37:40.869]                     if (is.function(sendCondition)) 
[17:37:40.869]                       return(sendCondition)
[17:37:40.869]                     ns <- getNamespace("parallel")
[17:37:40.869]                     if (exists("sendData", mode = "function", 
[17:37:40.869]                       envir = ns)) {
[17:37:40.869]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:40.869]                         envir = ns)
[17:37:40.869]                       envir <- sys.frame(frame)
[17:37:40.869]                       master <- NULL
[17:37:40.869]                       while (!identical(envir, .GlobalEnv) && 
[17:37:40.869]                         !identical(envir, emptyenv())) {
[17:37:40.869]                         if (exists("master", mode = "list", envir = envir, 
[17:37:40.869]                           inherits = FALSE)) {
[17:37:40.869]                           master <- get("master", mode = "list", 
[17:37:40.869]                             envir = envir, inherits = FALSE)
[17:37:40.869]                           if (inherits(master, c("SOCKnode", 
[17:37:40.869]                             "SOCK0node"))) {
[17:37:40.869]                             sendCondition <<- function(cond) {
[17:37:40.869]                               data <- list(type = "VALUE", value = cond, 
[17:37:40.869]                                 success = TRUE)
[17:37:40.869]                               parallel_sendData(master, data)
[17:37:40.869]                             }
[17:37:40.869]                             return(sendCondition)
[17:37:40.869]                           }
[17:37:40.869]                         }
[17:37:40.869]                         frame <- frame + 1L
[17:37:40.869]                         envir <- sys.frame(frame)
[17:37:40.869]                       }
[17:37:40.869]                     }
[17:37:40.869]                     sendCondition <<- function(cond) NULL
[17:37:40.869]                   }
[17:37:40.869]                 })
[17:37:40.869]                 withCallingHandlers({
[17:37:40.869]                   {
[17:37:40.869]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.869]                     if (!identical(...future.globals.maxSize.org, 
[17:37:40.869]                       ...future.globals.maxSize)) {
[17:37:40.869]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.869]                       on.exit(options(oopts), add = TRUE)
[17:37:40.869]                     }
[17:37:40.869]                     {
[17:37:40.869]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.869]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:40.869]                         USE.NAMES = FALSE)
[17:37:40.869]                       do.call(mapply, args = args)
[17:37:40.869]                     }
[17:37:40.869]                   }
[17:37:40.869]                 }, immediateCondition = function(cond) {
[17:37:40.869]                   sendCondition <- ...future.makeSendCondition()
[17:37:40.869]                   sendCondition(cond)
[17:37:40.869]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.869]                   {
[17:37:40.869]                     inherits <- base::inherits
[17:37:40.869]                     invokeRestart <- base::invokeRestart
[17:37:40.869]                     is.null <- base::is.null
[17:37:40.869]                     muffled <- FALSE
[17:37:40.869]                     if (inherits(cond, "message")) {
[17:37:40.869]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:40.869]                       if (muffled) 
[17:37:40.869]                         invokeRestart("muffleMessage")
[17:37:40.869]                     }
[17:37:40.869]                     else if (inherits(cond, "warning")) {
[17:37:40.869]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:40.869]                       if (muffled) 
[17:37:40.869]                         invokeRestart("muffleWarning")
[17:37:40.869]                     }
[17:37:40.869]                     else if (inherits(cond, "condition")) {
[17:37:40.869]                       if (!is.null(pattern)) {
[17:37:40.869]                         computeRestarts <- base::computeRestarts
[17:37:40.869]                         grepl <- base::grepl
[17:37:40.869]                         restarts <- computeRestarts(cond)
[17:37:40.869]                         for (restart in restarts) {
[17:37:40.869]                           name <- restart$name
[17:37:40.869]                           if (is.null(name)) 
[17:37:40.869]                             next
[17:37:40.869]                           if (!grepl(pattern, name)) 
[17:37:40.869]                             next
[17:37:40.869]                           invokeRestart(restart)
[17:37:40.869]                           muffled <- TRUE
[17:37:40.869]                           break
[17:37:40.869]                         }
[17:37:40.869]                       }
[17:37:40.869]                     }
[17:37:40.869]                     invisible(muffled)
[17:37:40.869]                   }
[17:37:40.869]                   muffleCondition(cond)
[17:37:40.869]                 })
[17:37:40.869]             }))
[17:37:40.869]             future::FutureResult(value = ...future.value$value, 
[17:37:40.869]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.869]                   ...future.rng), globalenv = if (FALSE) 
[17:37:40.869]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:40.869]                     ...future.globalenv.names))
[17:37:40.869]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:40.869]         }, condition = base::local({
[17:37:40.869]             c <- base::c
[17:37:40.869]             inherits <- base::inherits
[17:37:40.869]             invokeRestart <- base::invokeRestart
[17:37:40.869]             length <- base::length
[17:37:40.869]             list <- base::list
[17:37:40.869]             seq.int <- base::seq.int
[17:37:40.869]             signalCondition <- base::signalCondition
[17:37:40.869]             sys.calls <- base::sys.calls
[17:37:40.869]             `[[` <- base::`[[`
[17:37:40.869]             `+` <- base::`+`
[17:37:40.869]             `<<-` <- base::`<<-`
[17:37:40.869]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:40.869]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:40.869]                   3L)]
[17:37:40.869]             }
[17:37:40.869]             function(cond) {
[17:37:40.869]                 is_error <- inherits(cond, "error")
[17:37:40.869]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:40.869]                   NULL)
[17:37:40.869]                 if (is_error) {
[17:37:40.869]                   sessionInformation <- function() {
[17:37:40.869]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:40.869]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:40.869]                       search = base::search(), system = base::Sys.info())
[17:37:40.869]                   }
[17:37:40.869]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.869]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:40.869]                     cond$call), session = sessionInformation(), 
[17:37:40.869]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:40.869]                   signalCondition(cond)
[17:37:40.869]                 }
[17:37:40.869]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:40.869]                 "immediateCondition"))) {
[17:37:40.869]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:40.869]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.869]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:40.869]                   if (TRUE && !signal) {
[17:37:40.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.869]                     {
[17:37:40.869]                       inherits <- base::inherits
[17:37:40.869]                       invokeRestart <- base::invokeRestart
[17:37:40.869]                       is.null <- base::is.null
[17:37:40.869]                       muffled <- FALSE
[17:37:40.869]                       if (inherits(cond, "message")) {
[17:37:40.869]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.869]                         if (muffled) 
[17:37:40.869]                           invokeRestart("muffleMessage")
[17:37:40.869]                       }
[17:37:40.869]                       else if (inherits(cond, "warning")) {
[17:37:40.869]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.869]                         if (muffled) 
[17:37:40.869]                           invokeRestart("muffleWarning")
[17:37:40.869]                       }
[17:37:40.869]                       else if (inherits(cond, "condition")) {
[17:37:40.869]                         if (!is.null(pattern)) {
[17:37:40.869]                           computeRestarts <- base::computeRestarts
[17:37:40.869]                           grepl <- base::grepl
[17:37:40.869]                           restarts <- computeRestarts(cond)
[17:37:40.869]                           for (restart in restarts) {
[17:37:40.869]                             name <- restart$name
[17:37:40.869]                             if (is.null(name)) 
[17:37:40.869]                               next
[17:37:40.869]                             if (!grepl(pattern, name)) 
[17:37:40.869]                               next
[17:37:40.869]                             invokeRestart(restart)
[17:37:40.869]                             muffled <- TRUE
[17:37:40.869]                             break
[17:37:40.869]                           }
[17:37:40.869]                         }
[17:37:40.869]                       }
[17:37:40.869]                       invisible(muffled)
[17:37:40.869]                     }
[17:37:40.869]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.869]                   }
[17:37:40.869]                 }
[17:37:40.869]                 else {
[17:37:40.869]                   if (TRUE) {
[17:37:40.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.869]                     {
[17:37:40.869]                       inherits <- base::inherits
[17:37:40.869]                       invokeRestart <- base::invokeRestart
[17:37:40.869]                       is.null <- base::is.null
[17:37:40.869]                       muffled <- FALSE
[17:37:40.869]                       if (inherits(cond, "message")) {
[17:37:40.869]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.869]                         if (muffled) 
[17:37:40.869]                           invokeRestart("muffleMessage")
[17:37:40.869]                       }
[17:37:40.869]                       else if (inherits(cond, "warning")) {
[17:37:40.869]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.869]                         if (muffled) 
[17:37:40.869]                           invokeRestart("muffleWarning")
[17:37:40.869]                       }
[17:37:40.869]                       else if (inherits(cond, "condition")) {
[17:37:40.869]                         if (!is.null(pattern)) {
[17:37:40.869]                           computeRestarts <- base::computeRestarts
[17:37:40.869]                           grepl <- base::grepl
[17:37:40.869]                           restarts <- computeRestarts(cond)
[17:37:40.869]                           for (restart in restarts) {
[17:37:40.869]                             name <- restart$name
[17:37:40.869]                             if (is.null(name)) 
[17:37:40.869]                               next
[17:37:40.869]                             if (!grepl(pattern, name)) 
[17:37:40.869]                               next
[17:37:40.869]                             invokeRestart(restart)
[17:37:40.869]                             muffled <- TRUE
[17:37:40.869]                             break
[17:37:40.869]                           }
[17:37:40.869]                         }
[17:37:40.869]                       }
[17:37:40.869]                       invisible(muffled)
[17:37:40.869]                     }
[17:37:40.869]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.869]                   }
[17:37:40.869]                 }
[17:37:40.869]             }
[17:37:40.869]         }))
[17:37:40.869]     }, error = function(ex) {
[17:37:40.869]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:40.869]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.869]                 ...future.rng), started = ...future.startTime, 
[17:37:40.869]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:40.869]             version = "1.8"), class = "FutureResult")
[17:37:40.869]     }, finally = {
[17:37:40.869]         if (!identical(...future.workdir, getwd())) 
[17:37:40.869]             setwd(...future.workdir)
[17:37:40.869]         {
[17:37:40.869]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:40.869]                 ...future.oldOptions$nwarnings <- NULL
[17:37:40.869]             }
[17:37:40.869]             base::options(...future.oldOptions)
[17:37:40.869]             if (.Platform$OS.type == "windows") {
[17:37:40.869]                 old_names <- names(...future.oldEnvVars)
[17:37:40.869]                 envs <- base::Sys.getenv()
[17:37:40.869]                 names <- names(envs)
[17:37:40.869]                 common <- intersect(names, old_names)
[17:37:40.869]                 added <- setdiff(names, old_names)
[17:37:40.869]                 removed <- setdiff(old_names, names)
[17:37:40.869]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:40.869]                   envs[common]]
[17:37:40.869]                 NAMES <- toupper(changed)
[17:37:40.869]                 args <- list()
[17:37:40.869]                 for (kk in seq_along(NAMES)) {
[17:37:40.869]                   name <- changed[[kk]]
[17:37:40.869]                   NAME <- NAMES[[kk]]
[17:37:40.869]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.869]                     next
[17:37:40.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.869]                 }
[17:37:40.869]                 NAMES <- toupper(added)
[17:37:40.869]                 for (kk in seq_along(NAMES)) {
[17:37:40.869]                   name <- added[[kk]]
[17:37:40.869]                   NAME <- NAMES[[kk]]
[17:37:40.869]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.869]                     next
[17:37:40.869]                   args[[name]] <- ""
[17:37:40.869]                 }
[17:37:40.869]                 NAMES <- toupper(removed)
[17:37:40.869]                 for (kk in seq_along(NAMES)) {
[17:37:40.869]                   name <- removed[[kk]]
[17:37:40.869]                   NAME <- NAMES[[kk]]
[17:37:40.869]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.869]                     next
[17:37:40.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.869]                 }
[17:37:40.869]                 if (length(args) > 0) 
[17:37:40.869]                   base::do.call(base::Sys.setenv, args = args)
[17:37:40.869]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:40.869]             }
[17:37:40.869]             else {
[17:37:40.869]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:40.869]             }
[17:37:40.869]             {
[17:37:40.869]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:40.869]                   0L) {
[17:37:40.869]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:40.869]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:40.869]                   base::options(opts)
[17:37:40.869]                 }
[17:37:40.869]                 {
[17:37:40.869]                   {
[17:37:40.869]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:40.869]                     NULL
[17:37:40.869]                   }
[17:37:40.869]                   options(future.plan = NULL)
[17:37:40.869]                   if (is.na(NA_character_)) 
[17:37:40.869]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.869]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:40.869]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:40.869]                     .init = FALSE)
[17:37:40.869]                 }
[17:37:40.869]             }
[17:37:40.869]         }
[17:37:40.869]     })
[17:37:40.869]     if (TRUE) {
[17:37:40.869]         base::sink(type = "output", split = FALSE)
[17:37:40.869]         if (TRUE) {
[17:37:40.869]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:40.869]         }
[17:37:40.869]         else {
[17:37:40.869]             ...future.result["stdout"] <- base::list(NULL)
[17:37:40.869]         }
[17:37:40.869]         base::close(...future.stdout)
[17:37:40.869]         ...future.stdout <- NULL
[17:37:40.869]     }
[17:37:40.869]     ...future.result$conditions <- ...future.conditions
[17:37:40.869]     ...future.result$finished <- base::Sys.time()
[17:37:40.869]     ...future.result
[17:37:40.869] }
[17:37:40.872] Exporting 5 global objects (2.41 KiB) to cluster node #2 ...
[17:37:40.872] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #2 ...
[17:37:40.872] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #2 ... DONE
[17:37:40.872] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:37:40.872] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:37:40.873] Exporting ‘...future.elements_ii’ (1.03 KiB) to cluster node #2 ...
[17:37:40.873] Exporting ‘...future.elements_ii’ (1.03 KiB) to cluster node #2 ... DONE
[17:37:40.873] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:37:40.873] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:37:40.873] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:37:40.874] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:37:40.874] Exporting 5 global objects (2.41 KiB) to cluster node #2 ... DONE
[17:37:40.874] MultisessionFuture started
[17:37:40.874] - Launch lazy future ... done
[17:37:40.875] run() for ‘MultisessionFuture’ ... done
[17:37:40.875] Created future:
[17:37:40.875] MultisessionFuture:
[17:37:40.875] Label: ‘future_Map-2’
[17:37:40.875] Expression:
[17:37:40.875] {
[17:37:40.875]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.875]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:40.875]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.875]         on.exit(options(oopts), add = TRUE)
[17:37:40.875]     }
[17:37:40.875]     {
[17:37:40.875]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.875]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:40.875]         do.call(mapply, args = args)
[17:37:40.875]     }
[17:37:40.875] }
[17:37:40.875] Lazy evaluation: FALSE
[17:37:40.875] Asynchronous evaluation: TRUE
[17:37:40.875] Local evaluation: TRUE
[17:37:40.875] Environment: R_GlobalEnv
[17:37:40.875] Capture standard output: TRUE
[17:37:40.875] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:40.875] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:40.875] Packages: 1 packages (‘stats’)
[17:37:40.875] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:40.875] Resolved: FALSE
[17:37:40.875] Value: <not collected>
[17:37:40.875] Conditions captured: <none>
[17:37:40.875] Early signaling: FALSE
[17:37:40.875] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:40.875] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.886] Chunk #2 of 2 ... DONE
[17:37:40.886] Launching 2 futures (chunks) ... DONE
[17:37:40.886] Resolving 2 futures (chunks) ...
[17:37:40.886] resolve() on list ...
[17:37:40.887]  recursive: 0
[17:37:40.887]  length: 2
[17:37:40.887] 
[17:37:40.887] receiveMessageFromWorker() for ClusterFuture ...
[17:37:40.887] - Validating connection of MultisessionFuture
[17:37:40.888] - received message: FutureResult
[17:37:40.888] - Received FutureResult
[17:37:40.888] - Erased future from FutureRegistry
[17:37:40.888] result() for ClusterFuture ...
[17:37:40.888] - result already collected: FutureResult
[17:37:40.888] result() for ClusterFuture ... done
[17:37:40.888] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:40.888] Future #1
[17:37:40.888] result() for ClusterFuture ...
[17:37:40.889] - result already collected: FutureResult
[17:37:40.889] result() for ClusterFuture ... done
[17:37:40.889] result() for ClusterFuture ...
[17:37:40.889] - result already collected: FutureResult
[17:37:40.889] result() for ClusterFuture ... done
[17:37:40.889] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:37:40.889] - nx: 2
[17:37:40.889] - relay: TRUE
[17:37:40.889] - stdout: TRUE
[17:37:40.889] - signal: TRUE
[17:37:40.889] - resignal: FALSE
[17:37:40.889] - force: TRUE
[17:37:40.890] - relayed: [n=2] FALSE, FALSE
[17:37:40.890] - queued futures: [n=2] FALSE, FALSE
[17:37:40.890]  - until=1
[17:37:40.890]  - relaying element #1
[17:37:40.890] result() for ClusterFuture ...
[17:37:40.890] - result already collected: FutureResult
[17:37:40.890] result() for ClusterFuture ... done
[17:37:40.890] result() for ClusterFuture ...
[17:37:40.890] - result already collected: FutureResult
[17:37:40.890] result() for ClusterFuture ... done
[17:37:40.890] result() for ClusterFuture ...
[17:37:40.891] - result already collected: FutureResult
[17:37:40.891] result() for ClusterFuture ... done
[17:37:40.891] result() for ClusterFuture ...
[17:37:40.891] - result already collected: FutureResult
[17:37:40.891] result() for ClusterFuture ... done
[17:37:40.891] - relayed: [n=2] TRUE, FALSE
[17:37:40.891] - queued futures: [n=2] TRUE, FALSE
[17:37:40.891] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:37:40.891]  length: 1 (resolved future 1)
[17:37:40.918] receiveMessageFromWorker() for ClusterFuture ...
[17:37:40.918] - Validating connection of MultisessionFuture
[17:37:40.918] - received message: FutureResult
[17:37:40.919] - Received FutureResult
[17:37:40.919] - Erased future from FutureRegistry
[17:37:40.919] result() for ClusterFuture ...
[17:37:40.919] - result already collected: FutureResult
[17:37:40.919] result() for ClusterFuture ... done
[17:37:40.919] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:40.919] Future #2
[17:37:40.919] result() for ClusterFuture ...
[17:37:40.919] - result already collected: FutureResult
[17:37:40.919] result() for ClusterFuture ... done
[17:37:40.920] result() for ClusterFuture ...
[17:37:40.920] - result already collected: FutureResult
[17:37:40.920] result() for ClusterFuture ... done
[17:37:40.920] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:37:40.920] - nx: 2
[17:37:40.920] - relay: TRUE
[17:37:40.920] - stdout: TRUE
[17:37:40.920] - signal: TRUE
[17:37:40.920] - resignal: FALSE
[17:37:40.920] - force: TRUE
[17:37:40.921] - relayed: [n=2] TRUE, FALSE
[17:37:40.921] - queued futures: [n=2] TRUE, FALSE
[17:37:40.921]  - until=2
[17:37:40.921]  - relaying element #2
[17:37:40.921] result() for ClusterFuture ...
[17:37:40.921] - result already collected: FutureResult
[17:37:40.921] result() for ClusterFuture ... done
[17:37:40.921] result() for ClusterFuture ...
[17:37:40.921] - result already collected: FutureResult
[17:37:40.921] result() for ClusterFuture ... done
[17:37:40.921] result() for ClusterFuture ...
[17:37:40.922] - result already collected: FutureResult
[17:37:40.922] result() for ClusterFuture ... done
[17:37:40.922] result() for ClusterFuture ...
[17:37:40.922] - result already collected: FutureResult
[17:37:40.922] result() for ClusterFuture ... done
[17:37:40.922] - relayed: [n=2] TRUE, TRUE
[17:37:40.922] - queued futures: [n=2] TRUE, TRUE
[17:37:40.922] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:37:40.922]  length: 0 (resolved future 2)
[17:37:40.922] Relaying remaining futures
[17:37:40.922] signalConditionsASAP(NULL, pos=0) ...
[17:37:40.922] - nx: 2
[17:37:40.923] - relay: TRUE
[17:37:40.923] - stdout: TRUE
[17:37:40.923] - signal: TRUE
[17:37:40.923] - resignal: FALSE
[17:37:40.923] - force: TRUE
[17:37:40.923] - relayed: [n=2] TRUE, TRUE
[17:37:40.923] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:40.923] - relayed: [n=2] TRUE, TRUE
[17:37:40.923] - queued futures: [n=2] TRUE, TRUE
[17:37:40.923] signalConditionsASAP(NULL, pos=0) ... done
[17:37:40.923] resolve() on list ... DONE
[17:37:40.924] result() for ClusterFuture ...
[17:37:40.924] - result already collected: FutureResult
[17:37:40.924] result() for ClusterFuture ... done
[17:37:40.924] result() for ClusterFuture ...
[17:37:40.924] - result already collected: FutureResult
[17:37:40.924] result() for ClusterFuture ... done
[17:37:40.924] result() for ClusterFuture ...
[17:37:40.924] - result already collected: FutureResult
[17:37:40.924] result() for ClusterFuture ... done
[17:37:40.924] result() for ClusterFuture ...
[17:37:40.924] - result already collected: FutureResult
[17:37:40.925] result() for ClusterFuture ... done
[17:37:40.925]  - Number of value chunks collected: 2
[17:37:40.925] Resolving 2 futures (chunks) ... DONE
[17:37:40.925] Reducing values from 2 chunks ...
[17:37:40.925]  - Number of values collected after concatenation: 5
[17:37:40.925]  - Number of values expected: 5
[17:37:40.925] Reducing values from 2 chunks ... DONE
[17:37:40.928] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[17:37:40.930] future_mapply() ...
[17:37:40.933] Number of chunks: 2
[17:37:40.933] getGlobalsAndPackagesXApply() ...
[17:37:40.933]  - future.globals: TRUE
[17:37:40.934] getGlobalsAndPackages() ...
[17:37:40.934] Searching for globals...
[17:37:40.934] - globals found: [1] ‘FUN’
[17:37:40.934] Searching for globals ... DONE
[17:37:40.934] Resolving globals: FALSE
[17:37:40.935] The total size of the 1 globals is 56 bytes (56 bytes)
[17:37:40.935] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:37:40.935] - globals: [1] ‘FUN’
[17:37:40.935] 
[17:37:40.935] getGlobalsAndPackages() ... DONE
[17:37:40.935]  - globals found/used: [n=1] ‘FUN’
[17:37:40.936]  - needed namespaces: [n=0] 
[17:37:40.936] Finding globals ... DONE
[17:37:40.936] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:40.936] List of 2
[17:37:40.936]  $ ...future.FUN:function (e1, e2)  
[17:37:40.936]  $ MoreArgs     : NULL
[17:37:40.936]  - attr(*, "where")=List of 2
[17:37:40.936]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:40.936]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:40.936]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:40.936]  - attr(*, "resolved")= logi FALSE
[17:37:40.936]  - attr(*, "total_size")= num NA
[17:37:40.938] Packages to be attached in all futures: [n=0] 
[17:37:40.938] getGlobalsAndPackagesXApply() ... DONE
[17:37:40.939] Number of futures (= number of chunks): 2
[17:37:40.939] Launching 2 futures (chunks) ...
[17:37:40.939] Chunk #1 of 2 ...
[17:37:40.939]  - Finding globals in '...' for chunk #1 ...
[17:37:40.939] getGlobalsAndPackages() ...
[17:37:40.939] Searching for globals...
[17:37:40.939] 
[17:37:40.940] Searching for globals ... DONE
[17:37:40.940] - globals: [0] <none>
[17:37:40.940] getGlobalsAndPackages() ... DONE
[17:37:40.940]    + additional globals found: [n=0] 
[17:37:40.940]    + additional namespaces needed: [n=0] 
[17:37:40.940]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:40.940]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:40.940]  - seeds: <none>
[17:37:40.940]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.940] getGlobalsAndPackages() ...
[17:37:40.940] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.941] Resolving globals: FALSE
[17:37:40.941] The total size of the 5 globals is 168 bytes (168 bytes)
[17:37:40.941] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 168 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:40.942] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.942] 
[17:37:40.942] getGlobalsAndPackages() ... DONE
[17:37:40.942] run() for ‘Future’ ...
[17:37:40.942] - state: ‘created’
[17:37:40.942] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:40.956] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.956] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:40.956]   - Field: ‘node’
[17:37:40.956]   - Field: ‘label’
[17:37:40.956]   - Field: ‘local’
[17:37:40.956]   - Field: ‘owner’
[17:37:40.956]   - Field: ‘envir’
[17:37:40.957]   - Field: ‘workers’
[17:37:40.957]   - Field: ‘packages’
[17:37:40.957]   - Field: ‘gc’
[17:37:40.957]   - Field: ‘conditions’
[17:37:40.957]   - Field: ‘persistent’
[17:37:40.957]   - Field: ‘expr’
[17:37:40.957]   - Field: ‘uuid’
[17:37:40.957]   - Field: ‘seed’
[17:37:40.957]   - Field: ‘version’
[17:37:40.957]   - Field: ‘result’
[17:37:40.957]   - Field: ‘asynchronous’
[17:37:40.958]   - Field: ‘calls’
[17:37:40.958]   - Field: ‘globals’
[17:37:40.958]   - Field: ‘stdout’
[17:37:40.958]   - Field: ‘earlySignal’
[17:37:40.958]   - Field: ‘lazy’
[17:37:40.958]   - Field: ‘state’
[17:37:40.958] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:40.958] - Launch lazy future ...
[17:37:40.958] Packages needed by the future expression (n = 0): <none>
[17:37:40.959] Packages needed by future strategies (n = 0): <none>
[17:37:40.959] {
[17:37:40.959]     {
[17:37:40.959]         {
[17:37:40.959]             ...future.startTime <- base::Sys.time()
[17:37:40.959]             {
[17:37:40.959]                 {
[17:37:40.959]                   {
[17:37:40.959]                     {
[17:37:40.959]                       base::local({
[17:37:40.959]                         has_future <- base::requireNamespace("future", 
[17:37:40.959]                           quietly = TRUE)
[17:37:40.959]                         if (has_future) {
[17:37:40.959]                           ns <- base::getNamespace("future")
[17:37:40.959]                           version <- ns[[".package"]][["version"]]
[17:37:40.959]                           if (is.null(version)) 
[17:37:40.959]                             version <- utils::packageVersion("future")
[17:37:40.959]                         }
[17:37:40.959]                         else {
[17:37:40.959]                           version <- NULL
[17:37:40.959]                         }
[17:37:40.959]                         if (!has_future || version < "1.8.0") {
[17:37:40.959]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:40.959]                             "", base::R.version$version.string), 
[17:37:40.959]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:40.959]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:40.959]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:40.959]                               "release", "version")], collapse = " "), 
[17:37:40.959]                             hostname = base::Sys.info()[["nodename"]])
[17:37:40.959]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:40.959]                             info)
[17:37:40.959]                           info <- base::paste(info, collapse = "; ")
[17:37:40.959]                           if (!has_future) {
[17:37:40.959]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:40.959]                               info)
[17:37:40.959]                           }
[17:37:40.959]                           else {
[17:37:40.959]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:40.959]                               info, version)
[17:37:40.959]                           }
[17:37:40.959]                           base::stop(msg)
[17:37:40.959]                         }
[17:37:40.959]                       })
[17:37:40.959]                     }
[17:37:40.959]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:40.959]                     base::options(mc.cores = 1L)
[17:37:40.959]                   }
[17:37:40.959]                   ...future.strategy.old <- future::plan("list")
[17:37:40.959]                   options(future.plan = NULL)
[17:37:40.959]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.959]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:40.959]                 }
[17:37:40.959]                 ...future.workdir <- getwd()
[17:37:40.959]             }
[17:37:40.959]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:40.959]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:40.959]         }
[17:37:40.959]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:40.959]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:40.959]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:40.959]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:40.959]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:40.959]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:40.959]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:40.959]             base::names(...future.oldOptions))
[17:37:40.959]     }
[17:37:40.959]     if (FALSE) {
[17:37:40.959]     }
[17:37:40.959]     else {
[17:37:40.959]         if (TRUE) {
[17:37:40.959]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:40.959]                 open = "w")
[17:37:40.959]         }
[17:37:40.959]         else {
[17:37:40.959]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:40.959]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:40.959]         }
[17:37:40.959]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:40.959]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:40.959]             base::sink(type = "output", split = FALSE)
[17:37:40.959]             base::close(...future.stdout)
[17:37:40.959]         }, add = TRUE)
[17:37:40.959]     }
[17:37:40.959]     ...future.frame <- base::sys.nframe()
[17:37:40.959]     ...future.conditions <- base::list()
[17:37:40.959]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:40.959]     if (FALSE) {
[17:37:40.959]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:40.959]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:40.959]     }
[17:37:40.959]     ...future.result <- base::tryCatch({
[17:37:40.959]         base::withCallingHandlers({
[17:37:40.959]             ...future.value <- base::withVisible(base::local({
[17:37:40.959]                 ...future.makeSendCondition <- base::local({
[17:37:40.959]                   sendCondition <- NULL
[17:37:40.959]                   function(frame = 1L) {
[17:37:40.959]                     if (is.function(sendCondition)) 
[17:37:40.959]                       return(sendCondition)
[17:37:40.959]                     ns <- getNamespace("parallel")
[17:37:40.959]                     if (exists("sendData", mode = "function", 
[17:37:40.959]                       envir = ns)) {
[17:37:40.959]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:40.959]                         envir = ns)
[17:37:40.959]                       envir <- sys.frame(frame)
[17:37:40.959]                       master <- NULL
[17:37:40.959]                       while (!identical(envir, .GlobalEnv) && 
[17:37:40.959]                         !identical(envir, emptyenv())) {
[17:37:40.959]                         if (exists("master", mode = "list", envir = envir, 
[17:37:40.959]                           inherits = FALSE)) {
[17:37:40.959]                           master <- get("master", mode = "list", 
[17:37:40.959]                             envir = envir, inherits = FALSE)
[17:37:40.959]                           if (inherits(master, c("SOCKnode", 
[17:37:40.959]                             "SOCK0node"))) {
[17:37:40.959]                             sendCondition <<- function(cond) {
[17:37:40.959]                               data <- list(type = "VALUE", value = cond, 
[17:37:40.959]                                 success = TRUE)
[17:37:40.959]                               parallel_sendData(master, data)
[17:37:40.959]                             }
[17:37:40.959]                             return(sendCondition)
[17:37:40.959]                           }
[17:37:40.959]                         }
[17:37:40.959]                         frame <- frame + 1L
[17:37:40.959]                         envir <- sys.frame(frame)
[17:37:40.959]                       }
[17:37:40.959]                     }
[17:37:40.959]                     sendCondition <<- function(cond) NULL
[17:37:40.959]                   }
[17:37:40.959]                 })
[17:37:40.959]                 withCallingHandlers({
[17:37:40.959]                   {
[17:37:40.959]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.959]                     if (!identical(...future.globals.maxSize.org, 
[17:37:40.959]                       ...future.globals.maxSize)) {
[17:37:40.959]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.959]                       on.exit(options(oopts), add = TRUE)
[17:37:40.959]                     }
[17:37:40.959]                     {
[17:37:40.959]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.959]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:40.959]                         USE.NAMES = FALSE)
[17:37:40.959]                       do.call(mapply, args = args)
[17:37:40.959]                     }
[17:37:40.959]                   }
[17:37:40.959]                 }, immediateCondition = function(cond) {
[17:37:40.959]                   sendCondition <- ...future.makeSendCondition()
[17:37:40.959]                   sendCondition(cond)
[17:37:40.959]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.959]                   {
[17:37:40.959]                     inherits <- base::inherits
[17:37:40.959]                     invokeRestart <- base::invokeRestart
[17:37:40.959]                     is.null <- base::is.null
[17:37:40.959]                     muffled <- FALSE
[17:37:40.959]                     if (inherits(cond, "message")) {
[17:37:40.959]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:40.959]                       if (muffled) 
[17:37:40.959]                         invokeRestart("muffleMessage")
[17:37:40.959]                     }
[17:37:40.959]                     else if (inherits(cond, "warning")) {
[17:37:40.959]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:40.959]                       if (muffled) 
[17:37:40.959]                         invokeRestart("muffleWarning")
[17:37:40.959]                     }
[17:37:40.959]                     else if (inherits(cond, "condition")) {
[17:37:40.959]                       if (!is.null(pattern)) {
[17:37:40.959]                         computeRestarts <- base::computeRestarts
[17:37:40.959]                         grepl <- base::grepl
[17:37:40.959]                         restarts <- computeRestarts(cond)
[17:37:40.959]                         for (restart in restarts) {
[17:37:40.959]                           name <- restart$name
[17:37:40.959]                           if (is.null(name)) 
[17:37:40.959]                             next
[17:37:40.959]                           if (!grepl(pattern, name)) 
[17:37:40.959]                             next
[17:37:40.959]                           invokeRestart(restart)
[17:37:40.959]                           muffled <- TRUE
[17:37:40.959]                           break
[17:37:40.959]                         }
[17:37:40.959]                       }
[17:37:40.959]                     }
[17:37:40.959]                     invisible(muffled)
[17:37:40.959]                   }
[17:37:40.959]                   muffleCondition(cond)
[17:37:40.959]                 })
[17:37:40.959]             }))
[17:37:40.959]             future::FutureResult(value = ...future.value$value, 
[17:37:40.959]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.959]                   ...future.rng), globalenv = if (FALSE) 
[17:37:40.959]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:40.959]                     ...future.globalenv.names))
[17:37:40.959]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:40.959]         }, condition = base::local({
[17:37:40.959]             c <- base::c
[17:37:40.959]             inherits <- base::inherits
[17:37:40.959]             invokeRestart <- base::invokeRestart
[17:37:40.959]             length <- base::length
[17:37:40.959]             list <- base::list
[17:37:40.959]             seq.int <- base::seq.int
[17:37:40.959]             signalCondition <- base::signalCondition
[17:37:40.959]             sys.calls <- base::sys.calls
[17:37:40.959]             `[[` <- base::`[[`
[17:37:40.959]             `+` <- base::`+`
[17:37:40.959]             `<<-` <- base::`<<-`
[17:37:40.959]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:40.959]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:40.959]                   3L)]
[17:37:40.959]             }
[17:37:40.959]             function(cond) {
[17:37:40.959]                 is_error <- inherits(cond, "error")
[17:37:40.959]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:40.959]                   NULL)
[17:37:40.959]                 if (is_error) {
[17:37:40.959]                   sessionInformation <- function() {
[17:37:40.959]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:40.959]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:40.959]                       search = base::search(), system = base::Sys.info())
[17:37:40.959]                   }
[17:37:40.959]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.959]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:40.959]                     cond$call), session = sessionInformation(), 
[17:37:40.959]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:40.959]                   signalCondition(cond)
[17:37:40.959]                 }
[17:37:40.959]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:40.959]                 "immediateCondition"))) {
[17:37:40.959]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:40.959]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.959]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:40.959]                   if (TRUE && !signal) {
[17:37:40.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.959]                     {
[17:37:40.959]                       inherits <- base::inherits
[17:37:40.959]                       invokeRestart <- base::invokeRestart
[17:37:40.959]                       is.null <- base::is.null
[17:37:40.959]                       muffled <- FALSE
[17:37:40.959]                       if (inherits(cond, "message")) {
[17:37:40.959]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.959]                         if (muffled) 
[17:37:40.959]                           invokeRestart("muffleMessage")
[17:37:40.959]                       }
[17:37:40.959]                       else if (inherits(cond, "warning")) {
[17:37:40.959]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.959]                         if (muffled) 
[17:37:40.959]                           invokeRestart("muffleWarning")
[17:37:40.959]                       }
[17:37:40.959]                       else if (inherits(cond, "condition")) {
[17:37:40.959]                         if (!is.null(pattern)) {
[17:37:40.959]                           computeRestarts <- base::computeRestarts
[17:37:40.959]                           grepl <- base::grepl
[17:37:40.959]                           restarts <- computeRestarts(cond)
[17:37:40.959]                           for (restart in restarts) {
[17:37:40.959]                             name <- restart$name
[17:37:40.959]                             if (is.null(name)) 
[17:37:40.959]                               next
[17:37:40.959]                             if (!grepl(pattern, name)) 
[17:37:40.959]                               next
[17:37:40.959]                             invokeRestart(restart)
[17:37:40.959]                             muffled <- TRUE
[17:37:40.959]                             break
[17:37:40.959]                           }
[17:37:40.959]                         }
[17:37:40.959]                       }
[17:37:40.959]                       invisible(muffled)
[17:37:40.959]                     }
[17:37:40.959]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.959]                   }
[17:37:40.959]                 }
[17:37:40.959]                 else {
[17:37:40.959]                   if (TRUE) {
[17:37:40.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.959]                     {
[17:37:40.959]                       inherits <- base::inherits
[17:37:40.959]                       invokeRestart <- base::invokeRestart
[17:37:40.959]                       is.null <- base::is.null
[17:37:40.959]                       muffled <- FALSE
[17:37:40.959]                       if (inherits(cond, "message")) {
[17:37:40.959]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.959]                         if (muffled) 
[17:37:40.959]                           invokeRestart("muffleMessage")
[17:37:40.959]                       }
[17:37:40.959]                       else if (inherits(cond, "warning")) {
[17:37:40.959]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.959]                         if (muffled) 
[17:37:40.959]                           invokeRestart("muffleWarning")
[17:37:40.959]                       }
[17:37:40.959]                       else if (inherits(cond, "condition")) {
[17:37:40.959]                         if (!is.null(pattern)) {
[17:37:40.959]                           computeRestarts <- base::computeRestarts
[17:37:40.959]                           grepl <- base::grepl
[17:37:40.959]                           restarts <- computeRestarts(cond)
[17:37:40.959]                           for (restart in restarts) {
[17:37:40.959]                             name <- restart$name
[17:37:40.959]                             if (is.null(name)) 
[17:37:40.959]                               next
[17:37:40.959]                             if (!grepl(pattern, name)) 
[17:37:40.959]                               next
[17:37:40.959]                             invokeRestart(restart)
[17:37:40.959]                             muffled <- TRUE
[17:37:40.959]                             break
[17:37:40.959]                           }
[17:37:40.959]                         }
[17:37:40.959]                       }
[17:37:40.959]                       invisible(muffled)
[17:37:40.959]                     }
[17:37:40.959]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.959]                   }
[17:37:40.959]                 }
[17:37:40.959]             }
[17:37:40.959]         }))
[17:37:40.959]     }, error = function(ex) {
[17:37:40.959]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:40.959]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.959]                 ...future.rng), started = ...future.startTime, 
[17:37:40.959]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:40.959]             version = "1.8"), class = "FutureResult")
[17:37:40.959]     }, finally = {
[17:37:40.959]         if (!identical(...future.workdir, getwd())) 
[17:37:40.959]             setwd(...future.workdir)
[17:37:40.959]         {
[17:37:40.959]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:40.959]                 ...future.oldOptions$nwarnings <- NULL
[17:37:40.959]             }
[17:37:40.959]             base::options(...future.oldOptions)
[17:37:40.959]             if (.Platform$OS.type == "windows") {
[17:37:40.959]                 old_names <- names(...future.oldEnvVars)
[17:37:40.959]                 envs <- base::Sys.getenv()
[17:37:40.959]                 names <- names(envs)
[17:37:40.959]                 common <- intersect(names, old_names)
[17:37:40.959]                 added <- setdiff(names, old_names)
[17:37:40.959]                 removed <- setdiff(old_names, names)
[17:37:40.959]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:40.959]                   envs[common]]
[17:37:40.959]                 NAMES <- toupper(changed)
[17:37:40.959]                 args <- list()
[17:37:40.959]                 for (kk in seq_along(NAMES)) {
[17:37:40.959]                   name <- changed[[kk]]
[17:37:40.959]                   NAME <- NAMES[[kk]]
[17:37:40.959]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.959]                     next
[17:37:40.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.959]                 }
[17:37:40.959]                 NAMES <- toupper(added)
[17:37:40.959]                 for (kk in seq_along(NAMES)) {
[17:37:40.959]                   name <- added[[kk]]
[17:37:40.959]                   NAME <- NAMES[[kk]]
[17:37:40.959]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.959]                     next
[17:37:40.959]                   args[[name]] <- ""
[17:37:40.959]                 }
[17:37:40.959]                 NAMES <- toupper(removed)
[17:37:40.959]                 for (kk in seq_along(NAMES)) {
[17:37:40.959]                   name <- removed[[kk]]
[17:37:40.959]                   NAME <- NAMES[[kk]]
[17:37:40.959]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.959]                     next
[17:37:40.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.959]                 }
[17:37:40.959]                 if (length(args) > 0) 
[17:37:40.959]                   base::do.call(base::Sys.setenv, args = args)
[17:37:40.959]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:40.959]             }
[17:37:40.959]             else {
[17:37:40.959]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:40.959]             }
[17:37:40.959]             {
[17:37:40.959]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:40.959]                   0L) {
[17:37:40.959]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:40.959]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:40.959]                   base::options(opts)
[17:37:40.959]                 }
[17:37:40.959]                 {
[17:37:40.959]                   {
[17:37:40.959]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:40.959]                     NULL
[17:37:40.959]                   }
[17:37:40.959]                   options(future.plan = NULL)
[17:37:40.959]                   if (is.na(NA_character_)) 
[17:37:40.959]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.959]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:40.959]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:40.959]                     .init = FALSE)
[17:37:40.959]                 }
[17:37:40.959]             }
[17:37:40.959]         }
[17:37:40.959]     })
[17:37:40.959]     if (TRUE) {
[17:37:40.959]         base::sink(type = "output", split = FALSE)
[17:37:40.959]         if (TRUE) {
[17:37:40.959]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:40.959]         }
[17:37:40.959]         else {
[17:37:40.959]             ...future.result["stdout"] <- base::list(NULL)
[17:37:40.959]         }
[17:37:40.959]         base::close(...future.stdout)
[17:37:40.959]         ...future.stdout <- NULL
[17:37:40.959]     }
[17:37:40.959]     ...future.result$conditions <- ...future.conditions
[17:37:40.959]     ...future.result$finished <- base::Sys.time()
[17:37:40.959]     ...future.result
[17:37:40.959] }
[17:37:40.962] Exporting 5 global objects (168 bytes) to cluster node #1 ...
[17:37:40.962] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[17:37:40.962] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[17:37:40.962] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:37:40.963] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:37:40.963] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:37:40.963] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:37:40.963] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:40.964] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:40.964] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:40.964] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:40.964] Exporting 5 global objects (168 bytes) to cluster node #1 ... DONE
[17:37:40.965] MultisessionFuture started
[17:37:40.965] - Launch lazy future ... done
[17:37:40.965] run() for ‘MultisessionFuture’ ... done
[17:37:40.965] Created future:
[17:37:40.965] MultisessionFuture:
[17:37:40.965] Label: ‘future_Map-1’
[17:37:40.965] Expression:
[17:37:40.965] {
[17:37:40.965]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.965]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:40.965]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.965]         on.exit(options(oopts), add = TRUE)
[17:37:40.965]     }
[17:37:40.965]     {
[17:37:40.965]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.965]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:40.965]         do.call(mapply, args = args)
[17:37:40.965]     }
[17:37:40.965] }
[17:37:40.965] Lazy evaluation: FALSE
[17:37:40.965] Asynchronous evaluation: TRUE
[17:37:40.965] Local evaluation: TRUE
[17:37:40.965] Environment: R_GlobalEnv
[17:37:40.965] Capture standard output: TRUE
[17:37:40.965] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:40.965] Globals: 5 objects totaling 168 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:40.965] Packages: <none>
[17:37:40.965] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:40.965] Resolved: FALSE
[17:37:40.965] Value: <not collected>
[17:37:40.965] Conditions captured: <none>
[17:37:40.965] Early signaling: FALSE
[17:37:40.965] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:40.965] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.976] Chunk #1 of 2 ... DONE
[17:37:40.976] Chunk #2 of 2 ...
[17:37:40.977]  - Finding globals in '...' for chunk #2 ...
[17:37:40.977] getGlobalsAndPackages() ...
[17:37:40.977] Searching for globals...
[17:37:40.977] 
[17:37:40.977] Searching for globals ... DONE
[17:37:40.977] - globals: [0] <none>
[17:37:40.978] getGlobalsAndPackages() ... DONE
[17:37:40.978]    + additional globals found: [n=0] 
[17:37:40.978]    + additional namespaces needed: [n=0] 
[17:37:40.978]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:40.978]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:40.978]  - seeds: <none>
[17:37:40.978]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.978] getGlobalsAndPackages() ...
[17:37:40.978] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.978] Resolving globals: FALSE
[17:37:40.979] The total size of the 5 globals is 280 bytes (280 bytes)
[17:37:40.979] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:40.979] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:40.980] 
[17:37:40.980] getGlobalsAndPackages() ... DONE
[17:37:40.980] run() for ‘Future’ ...
[17:37:40.980] - state: ‘created’
[17:37:40.980] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:40.993] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:40.994] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:40.994]   - Field: ‘node’
[17:37:40.994]   - Field: ‘label’
[17:37:40.994]   - Field: ‘local’
[17:37:40.994]   - Field: ‘owner’
[17:37:40.994]   - Field: ‘envir’
[17:37:40.994]   - Field: ‘workers’
[17:37:40.994]   - Field: ‘packages’
[17:37:40.994]   - Field: ‘gc’
[17:37:40.994]   - Field: ‘conditions’
[17:37:40.995]   - Field: ‘persistent’
[17:37:40.995]   - Field: ‘expr’
[17:37:40.995]   - Field: ‘uuid’
[17:37:40.995]   - Field: ‘seed’
[17:37:40.995]   - Field: ‘version’
[17:37:40.995]   - Field: ‘result’
[17:37:40.995]   - Field: ‘asynchronous’
[17:37:40.995]   - Field: ‘calls’
[17:37:40.995]   - Field: ‘globals’
[17:37:40.995]   - Field: ‘stdout’
[17:37:40.995]   - Field: ‘earlySignal’
[17:37:40.995]   - Field: ‘lazy’
[17:37:40.996]   - Field: ‘state’
[17:37:40.996] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:40.996] - Launch lazy future ...
[17:37:40.996] Packages needed by the future expression (n = 0): <none>
[17:37:40.996] Packages needed by future strategies (n = 0): <none>
[17:37:40.997] {
[17:37:40.997]     {
[17:37:40.997]         {
[17:37:40.997]             ...future.startTime <- base::Sys.time()
[17:37:40.997]             {
[17:37:40.997]                 {
[17:37:40.997]                   {
[17:37:40.997]                     {
[17:37:40.997]                       base::local({
[17:37:40.997]                         has_future <- base::requireNamespace("future", 
[17:37:40.997]                           quietly = TRUE)
[17:37:40.997]                         if (has_future) {
[17:37:40.997]                           ns <- base::getNamespace("future")
[17:37:40.997]                           version <- ns[[".package"]][["version"]]
[17:37:40.997]                           if (is.null(version)) 
[17:37:40.997]                             version <- utils::packageVersion("future")
[17:37:40.997]                         }
[17:37:40.997]                         else {
[17:37:40.997]                           version <- NULL
[17:37:40.997]                         }
[17:37:40.997]                         if (!has_future || version < "1.8.0") {
[17:37:40.997]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:40.997]                             "", base::R.version$version.string), 
[17:37:40.997]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:40.997]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:40.997]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:40.997]                               "release", "version")], collapse = " "), 
[17:37:40.997]                             hostname = base::Sys.info()[["nodename"]])
[17:37:40.997]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:40.997]                             info)
[17:37:40.997]                           info <- base::paste(info, collapse = "; ")
[17:37:40.997]                           if (!has_future) {
[17:37:40.997]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:40.997]                               info)
[17:37:40.997]                           }
[17:37:40.997]                           else {
[17:37:40.997]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:40.997]                               info, version)
[17:37:40.997]                           }
[17:37:40.997]                           base::stop(msg)
[17:37:40.997]                         }
[17:37:40.997]                       })
[17:37:40.997]                     }
[17:37:40.997]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:40.997]                     base::options(mc.cores = 1L)
[17:37:40.997]                   }
[17:37:40.997]                   ...future.strategy.old <- future::plan("list")
[17:37:40.997]                   options(future.plan = NULL)
[17:37:40.997]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.997]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:40.997]                 }
[17:37:40.997]                 ...future.workdir <- getwd()
[17:37:40.997]             }
[17:37:40.997]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:40.997]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:40.997]         }
[17:37:40.997]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:40.997]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:40.997]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:40.997]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:40.997]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:40.997]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:40.997]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:40.997]             base::names(...future.oldOptions))
[17:37:40.997]     }
[17:37:40.997]     if (FALSE) {
[17:37:40.997]     }
[17:37:40.997]     else {
[17:37:40.997]         if (TRUE) {
[17:37:40.997]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:40.997]                 open = "w")
[17:37:40.997]         }
[17:37:40.997]         else {
[17:37:40.997]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:40.997]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:40.997]         }
[17:37:40.997]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:40.997]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:40.997]             base::sink(type = "output", split = FALSE)
[17:37:40.997]             base::close(...future.stdout)
[17:37:40.997]         }, add = TRUE)
[17:37:40.997]     }
[17:37:40.997]     ...future.frame <- base::sys.nframe()
[17:37:40.997]     ...future.conditions <- base::list()
[17:37:40.997]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:40.997]     if (FALSE) {
[17:37:40.997]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:40.997]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:40.997]     }
[17:37:40.997]     ...future.result <- base::tryCatch({
[17:37:40.997]         base::withCallingHandlers({
[17:37:40.997]             ...future.value <- base::withVisible(base::local({
[17:37:40.997]                 ...future.makeSendCondition <- base::local({
[17:37:40.997]                   sendCondition <- NULL
[17:37:40.997]                   function(frame = 1L) {
[17:37:40.997]                     if (is.function(sendCondition)) 
[17:37:40.997]                       return(sendCondition)
[17:37:40.997]                     ns <- getNamespace("parallel")
[17:37:40.997]                     if (exists("sendData", mode = "function", 
[17:37:40.997]                       envir = ns)) {
[17:37:40.997]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:40.997]                         envir = ns)
[17:37:40.997]                       envir <- sys.frame(frame)
[17:37:40.997]                       master <- NULL
[17:37:40.997]                       while (!identical(envir, .GlobalEnv) && 
[17:37:40.997]                         !identical(envir, emptyenv())) {
[17:37:40.997]                         if (exists("master", mode = "list", envir = envir, 
[17:37:40.997]                           inherits = FALSE)) {
[17:37:40.997]                           master <- get("master", mode = "list", 
[17:37:40.997]                             envir = envir, inherits = FALSE)
[17:37:40.997]                           if (inherits(master, c("SOCKnode", 
[17:37:40.997]                             "SOCK0node"))) {
[17:37:40.997]                             sendCondition <<- function(cond) {
[17:37:40.997]                               data <- list(type = "VALUE", value = cond, 
[17:37:40.997]                                 success = TRUE)
[17:37:40.997]                               parallel_sendData(master, data)
[17:37:40.997]                             }
[17:37:40.997]                             return(sendCondition)
[17:37:40.997]                           }
[17:37:40.997]                         }
[17:37:40.997]                         frame <- frame + 1L
[17:37:40.997]                         envir <- sys.frame(frame)
[17:37:40.997]                       }
[17:37:40.997]                     }
[17:37:40.997]                     sendCondition <<- function(cond) NULL
[17:37:40.997]                   }
[17:37:40.997]                 })
[17:37:40.997]                 withCallingHandlers({
[17:37:40.997]                   {
[17:37:40.997]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:40.997]                     if (!identical(...future.globals.maxSize.org, 
[17:37:40.997]                       ...future.globals.maxSize)) {
[17:37:40.997]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:40.997]                       on.exit(options(oopts), add = TRUE)
[17:37:40.997]                     }
[17:37:40.997]                     {
[17:37:40.997]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:40.997]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:40.997]                         USE.NAMES = FALSE)
[17:37:40.997]                       do.call(mapply, args = args)
[17:37:40.997]                     }
[17:37:40.997]                   }
[17:37:40.997]                 }, immediateCondition = function(cond) {
[17:37:40.997]                   sendCondition <- ...future.makeSendCondition()
[17:37:40.997]                   sendCondition(cond)
[17:37:40.997]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.997]                   {
[17:37:40.997]                     inherits <- base::inherits
[17:37:40.997]                     invokeRestart <- base::invokeRestart
[17:37:40.997]                     is.null <- base::is.null
[17:37:40.997]                     muffled <- FALSE
[17:37:40.997]                     if (inherits(cond, "message")) {
[17:37:40.997]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:40.997]                       if (muffled) 
[17:37:40.997]                         invokeRestart("muffleMessage")
[17:37:40.997]                     }
[17:37:40.997]                     else if (inherits(cond, "warning")) {
[17:37:40.997]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:40.997]                       if (muffled) 
[17:37:40.997]                         invokeRestart("muffleWarning")
[17:37:40.997]                     }
[17:37:40.997]                     else if (inherits(cond, "condition")) {
[17:37:40.997]                       if (!is.null(pattern)) {
[17:37:40.997]                         computeRestarts <- base::computeRestarts
[17:37:40.997]                         grepl <- base::grepl
[17:37:40.997]                         restarts <- computeRestarts(cond)
[17:37:40.997]                         for (restart in restarts) {
[17:37:40.997]                           name <- restart$name
[17:37:40.997]                           if (is.null(name)) 
[17:37:40.997]                             next
[17:37:40.997]                           if (!grepl(pattern, name)) 
[17:37:40.997]                             next
[17:37:40.997]                           invokeRestart(restart)
[17:37:40.997]                           muffled <- TRUE
[17:37:40.997]                           break
[17:37:40.997]                         }
[17:37:40.997]                       }
[17:37:40.997]                     }
[17:37:40.997]                     invisible(muffled)
[17:37:40.997]                   }
[17:37:40.997]                   muffleCondition(cond)
[17:37:40.997]                 })
[17:37:40.997]             }))
[17:37:40.997]             future::FutureResult(value = ...future.value$value, 
[17:37:40.997]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.997]                   ...future.rng), globalenv = if (FALSE) 
[17:37:40.997]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:40.997]                     ...future.globalenv.names))
[17:37:40.997]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:40.997]         }, condition = base::local({
[17:37:40.997]             c <- base::c
[17:37:40.997]             inherits <- base::inherits
[17:37:40.997]             invokeRestart <- base::invokeRestart
[17:37:40.997]             length <- base::length
[17:37:40.997]             list <- base::list
[17:37:40.997]             seq.int <- base::seq.int
[17:37:40.997]             signalCondition <- base::signalCondition
[17:37:40.997]             sys.calls <- base::sys.calls
[17:37:40.997]             `[[` <- base::`[[`
[17:37:40.997]             `+` <- base::`+`
[17:37:40.997]             `<<-` <- base::`<<-`
[17:37:40.997]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:40.997]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:40.997]                   3L)]
[17:37:40.997]             }
[17:37:40.997]             function(cond) {
[17:37:40.997]                 is_error <- inherits(cond, "error")
[17:37:40.997]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:40.997]                   NULL)
[17:37:40.997]                 if (is_error) {
[17:37:40.997]                   sessionInformation <- function() {
[17:37:40.997]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:40.997]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:40.997]                       search = base::search(), system = base::Sys.info())
[17:37:40.997]                   }
[17:37:40.997]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.997]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:40.997]                     cond$call), session = sessionInformation(), 
[17:37:40.997]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:40.997]                   signalCondition(cond)
[17:37:40.997]                 }
[17:37:40.997]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:40.997]                 "immediateCondition"))) {
[17:37:40.997]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:40.997]                   ...future.conditions[[length(...future.conditions) + 
[17:37:40.997]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:40.997]                   if (TRUE && !signal) {
[17:37:40.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.997]                     {
[17:37:40.997]                       inherits <- base::inherits
[17:37:40.997]                       invokeRestart <- base::invokeRestart
[17:37:40.997]                       is.null <- base::is.null
[17:37:40.997]                       muffled <- FALSE
[17:37:40.997]                       if (inherits(cond, "message")) {
[17:37:40.997]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.997]                         if (muffled) 
[17:37:40.997]                           invokeRestart("muffleMessage")
[17:37:40.997]                       }
[17:37:40.997]                       else if (inherits(cond, "warning")) {
[17:37:40.997]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.997]                         if (muffled) 
[17:37:40.997]                           invokeRestart("muffleWarning")
[17:37:40.997]                       }
[17:37:40.997]                       else if (inherits(cond, "condition")) {
[17:37:40.997]                         if (!is.null(pattern)) {
[17:37:40.997]                           computeRestarts <- base::computeRestarts
[17:37:40.997]                           grepl <- base::grepl
[17:37:40.997]                           restarts <- computeRestarts(cond)
[17:37:40.997]                           for (restart in restarts) {
[17:37:40.997]                             name <- restart$name
[17:37:40.997]                             if (is.null(name)) 
[17:37:40.997]                               next
[17:37:40.997]                             if (!grepl(pattern, name)) 
[17:37:40.997]                               next
[17:37:40.997]                             invokeRestart(restart)
[17:37:40.997]                             muffled <- TRUE
[17:37:40.997]                             break
[17:37:40.997]                           }
[17:37:40.997]                         }
[17:37:40.997]                       }
[17:37:40.997]                       invisible(muffled)
[17:37:40.997]                     }
[17:37:40.997]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.997]                   }
[17:37:40.997]                 }
[17:37:40.997]                 else {
[17:37:40.997]                   if (TRUE) {
[17:37:40.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:40.997]                     {
[17:37:40.997]                       inherits <- base::inherits
[17:37:40.997]                       invokeRestart <- base::invokeRestart
[17:37:40.997]                       is.null <- base::is.null
[17:37:40.997]                       muffled <- FALSE
[17:37:40.997]                       if (inherits(cond, "message")) {
[17:37:40.997]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:40.997]                         if (muffled) 
[17:37:40.997]                           invokeRestart("muffleMessage")
[17:37:40.997]                       }
[17:37:40.997]                       else if (inherits(cond, "warning")) {
[17:37:40.997]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:40.997]                         if (muffled) 
[17:37:40.997]                           invokeRestart("muffleWarning")
[17:37:40.997]                       }
[17:37:40.997]                       else if (inherits(cond, "condition")) {
[17:37:40.997]                         if (!is.null(pattern)) {
[17:37:40.997]                           computeRestarts <- base::computeRestarts
[17:37:40.997]                           grepl <- base::grepl
[17:37:40.997]                           restarts <- computeRestarts(cond)
[17:37:40.997]                           for (restart in restarts) {
[17:37:40.997]                             name <- restart$name
[17:37:40.997]                             if (is.null(name)) 
[17:37:40.997]                               next
[17:37:40.997]                             if (!grepl(pattern, name)) 
[17:37:40.997]                               next
[17:37:40.997]                             invokeRestart(restart)
[17:37:40.997]                             muffled <- TRUE
[17:37:40.997]                             break
[17:37:40.997]                           }
[17:37:40.997]                         }
[17:37:40.997]                       }
[17:37:40.997]                       invisible(muffled)
[17:37:40.997]                     }
[17:37:40.997]                     muffleCondition(cond, pattern = "^muffle")
[17:37:40.997]                   }
[17:37:40.997]                 }
[17:37:40.997]             }
[17:37:40.997]         }))
[17:37:40.997]     }, error = function(ex) {
[17:37:40.997]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:40.997]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:40.997]                 ...future.rng), started = ...future.startTime, 
[17:37:40.997]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:40.997]             version = "1.8"), class = "FutureResult")
[17:37:40.997]     }, finally = {
[17:37:40.997]         if (!identical(...future.workdir, getwd())) 
[17:37:40.997]             setwd(...future.workdir)
[17:37:40.997]         {
[17:37:40.997]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:40.997]                 ...future.oldOptions$nwarnings <- NULL
[17:37:40.997]             }
[17:37:40.997]             base::options(...future.oldOptions)
[17:37:40.997]             if (.Platform$OS.type == "windows") {
[17:37:40.997]                 old_names <- names(...future.oldEnvVars)
[17:37:40.997]                 envs <- base::Sys.getenv()
[17:37:40.997]                 names <- names(envs)
[17:37:40.997]                 common <- intersect(names, old_names)
[17:37:40.997]                 added <- setdiff(names, old_names)
[17:37:40.997]                 removed <- setdiff(old_names, names)
[17:37:40.997]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:40.997]                   envs[common]]
[17:37:40.997]                 NAMES <- toupper(changed)
[17:37:40.997]                 args <- list()
[17:37:40.997]                 for (kk in seq_along(NAMES)) {
[17:37:40.997]                   name <- changed[[kk]]
[17:37:40.997]                   NAME <- NAMES[[kk]]
[17:37:40.997]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.997]                     next
[17:37:40.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.997]                 }
[17:37:40.997]                 NAMES <- toupper(added)
[17:37:40.997]                 for (kk in seq_along(NAMES)) {
[17:37:40.997]                   name <- added[[kk]]
[17:37:40.997]                   NAME <- NAMES[[kk]]
[17:37:40.997]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.997]                     next
[17:37:40.997]                   args[[name]] <- ""
[17:37:40.997]                 }
[17:37:40.997]                 NAMES <- toupper(removed)
[17:37:40.997]                 for (kk in seq_along(NAMES)) {
[17:37:40.997]                   name <- removed[[kk]]
[17:37:40.997]                   NAME <- NAMES[[kk]]
[17:37:40.997]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:40.997]                     next
[17:37:40.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:40.997]                 }
[17:37:40.997]                 if (length(args) > 0) 
[17:37:40.997]                   base::do.call(base::Sys.setenv, args = args)
[17:37:40.997]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:40.997]             }
[17:37:40.997]             else {
[17:37:40.997]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:40.997]             }
[17:37:40.997]             {
[17:37:40.997]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:40.997]                   0L) {
[17:37:40.997]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:40.997]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:40.997]                   base::options(opts)
[17:37:40.997]                 }
[17:37:40.997]                 {
[17:37:40.997]                   {
[17:37:40.997]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:40.997]                     NULL
[17:37:40.997]                   }
[17:37:40.997]                   options(future.plan = NULL)
[17:37:40.997]                   if (is.na(NA_character_)) 
[17:37:40.997]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:40.997]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:40.997]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:40.997]                     .init = FALSE)
[17:37:40.997]                 }
[17:37:40.997]             }
[17:37:40.997]         }
[17:37:40.997]     })
[17:37:40.997]     if (TRUE) {
[17:37:40.997]         base::sink(type = "output", split = FALSE)
[17:37:40.997]         if (TRUE) {
[17:37:40.997]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:40.997]         }
[17:37:40.997]         else {
[17:37:40.997]             ...future.result["stdout"] <- base::list(NULL)
[17:37:40.997]         }
[17:37:40.997]         base::close(...future.stdout)
[17:37:40.997]         ...future.stdout <- NULL
[17:37:40.997]     }
[17:37:40.997]     ...future.result$conditions <- ...future.conditions
[17:37:40.997]     ...future.result$finished <- base::Sys.time()
[17:37:40.997]     ...future.result
[17:37:40.997] }
[17:37:40.999] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[17:37:40.999] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[17:37:41.000] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[17:37:41.000] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:37:41.000] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:37:41.000] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:37:41.001] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:37:41.001] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:37:41.001] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:37:41.001] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:37:41.001] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:37:41.002] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[17:37:41.002] MultisessionFuture started
[17:37:41.002] - Launch lazy future ... done
[17:37:41.002] run() for ‘MultisessionFuture’ ... done
[17:37:41.002] Created future:
[17:37:41.002] MultisessionFuture:
[17:37:41.002] Label: ‘future_Map-2’
[17:37:41.002] Expression:
[17:37:41.002] {
[17:37:41.002]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:41.002]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:41.002]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:41.002]         on.exit(options(oopts), add = TRUE)
[17:37:41.002]     }
[17:37:41.002]     {
[17:37:41.002]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:41.002]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:41.002]         do.call(mapply, args = args)
[17:37:41.002]     }
[17:37:41.002] }
[17:37:41.002] Lazy evaluation: FALSE
[17:37:41.002] Asynchronous evaluation: TRUE
[17:37:41.002] Local evaluation: TRUE
[17:37:41.002] Environment: R_GlobalEnv
[17:37:41.002] Capture standard output: TRUE
[17:37:41.002] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:41.002] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:41.002] Packages: <none>
[17:37:41.002] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:41.002] Resolved: FALSE
[17:37:41.002] Value: <not collected>
[17:37:41.002] Conditions captured: <none>
[17:37:41.002] Early signaling: FALSE
[17:37:41.002] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:41.002] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:41.014] Chunk #2 of 2 ... DONE
[17:37:41.014] Launching 2 futures (chunks) ... DONE
[17:37:41.014] Resolving 2 futures (chunks) ...
[17:37:41.014] resolve() on list ...
[17:37:41.014]  recursive: 0
[17:37:41.014]  length: 2
[17:37:41.014] 
[17:37:41.015] receiveMessageFromWorker() for ClusterFuture ...
[17:37:41.015] - Validating connection of MultisessionFuture
[17:37:41.015] - received message: FutureResult
[17:37:41.015] - Received FutureResult
[17:37:41.015] - Erased future from FutureRegistry
[17:37:41.015] result() for ClusterFuture ...
[17:37:41.016] - result already collected: FutureResult
[17:37:41.016] result() for ClusterFuture ... done
[17:37:41.016] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:41.016] Future #1
[17:37:41.016] result() for ClusterFuture ...
[17:37:41.016] - result already collected: FutureResult
[17:37:41.016] result() for ClusterFuture ... done
[17:37:41.016] result() for ClusterFuture ...
[17:37:41.016] - result already collected: FutureResult
[17:37:41.016] result() for ClusterFuture ... done
[17:37:41.016] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:37:41.017] - nx: 2
[17:37:41.017] - relay: TRUE
[17:37:41.017] - stdout: TRUE
[17:37:41.017] - signal: TRUE
[17:37:41.017] - resignal: FALSE
[17:37:41.017] - force: TRUE
[17:37:41.017] - relayed: [n=2] FALSE, FALSE
[17:37:41.017] - queued futures: [n=2] FALSE, FALSE
[17:37:41.017]  - until=1
[17:37:41.017]  - relaying element #1
[17:37:41.017] result() for ClusterFuture ...
[17:37:41.017] - result already collected: FutureResult
[17:37:41.018] result() for ClusterFuture ... done
[17:37:41.018] result() for ClusterFuture ...
[17:37:41.018] - result already collected: FutureResult
[17:37:41.018] result() for ClusterFuture ... done
[17:37:41.018] result() for ClusterFuture ...
[17:37:41.018] - result already collected: FutureResult
[17:37:41.018] result() for ClusterFuture ... done
[17:37:41.018] result() for ClusterFuture ...
[17:37:41.018] - result already collected: FutureResult
[17:37:41.018] result() for ClusterFuture ... done
[17:37:41.018] - relayed: [n=2] TRUE, FALSE
[17:37:41.018] - queued futures: [n=2] TRUE, FALSE
[17:37:41.019] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:37:41.019]  length: 1 (resolved future 1)
[17:37:41.046] receiveMessageFromWorker() for ClusterFuture ...
[17:37:41.046] - Validating connection of MultisessionFuture
[17:37:41.046] - received message: FutureResult
[17:37:41.046] - Received FutureResult
[17:37:41.046] - Erased future from FutureRegistry
[17:37:41.047] result() for ClusterFuture ...
[17:37:41.047] - result already collected: FutureResult
[17:37:41.047] result() for ClusterFuture ... done
[17:37:41.047] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:41.047] Future #2
[17:37:41.047] result() for ClusterFuture ...
[17:37:41.047] - result already collected: FutureResult
[17:37:41.047] result() for ClusterFuture ... done
[17:37:41.047] result() for ClusterFuture ...
[17:37:41.047] - result already collected: FutureResult
[17:37:41.047] result() for ClusterFuture ... done
[17:37:41.048] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:37:41.048] - nx: 2
[17:37:41.048] - relay: TRUE
[17:37:41.048] - stdout: TRUE
[17:37:41.048] - signal: TRUE
[17:37:41.048] - resignal: FALSE
[17:37:41.048] - force: TRUE
[17:37:41.048] - relayed: [n=2] TRUE, FALSE
[17:37:41.048] - queued futures: [n=2] TRUE, FALSE
[17:37:41.048]  - until=2
[17:37:41.048]  - relaying element #2
[17:37:41.048] result() for ClusterFuture ...
[17:37:41.049] - result already collected: FutureResult
[17:37:41.049] result() for ClusterFuture ... done
[17:37:41.049] result() for ClusterFuture ...
[17:37:41.049] - result already collected: FutureResult
[17:37:41.049] result() for ClusterFuture ... done
[17:37:41.049] result() for ClusterFuture ...
[17:37:41.049] - result already collected: FutureResult
[17:37:41.049] result() for ClusterFuture ... done
[17:37:41.049] result() for ClusterFuture ...
[17:37:41.049] - result already collected: FutureResult
[17:37:41.049] result() for ClusterFuture ... done
[17:37:41.050] - relayed: [n=2] TRUE, TRUE
[17:37:41.050] - queued futures: [n=2] TRUE, TRUE
[17:37:41.050] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:37:41.050]  length: 0 (resolved future 2)
[17:37:41.050] Relaying remaining futures
[17:37:41.050] signalConditionsASAP(NULL, pos=0) ...
[17:37:41.050] - nx: 2
[17:37:41.050] - relay: TRUE
[17:37:41.050] - stdout: TRUE
[17:37:41.050] - signal: TRUE
[17:37:41.050] - resignal: FALSE
[17:37:41.050] - force: TRUE
[17:37:41.050] - relayed: [n=2] TRUE, TRUE
[17:37:41.051] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:41.051] - relayed: [n=2] TRUE, TRUE
[17:37:41.051] - queued futures: [n=2] TRUE, TRUE
[17:37:41.051] signalConditionsASAP(NULL, pos=0) ... done
[17:37:41.051] resolve() on list ... DONE
[17:37:41.051] result() for ClusterFuture ...
[17:37:41.051] - result already collected: FutureResult
[17:37:41.051] result() for ClusterFuture ... done
[17:37:41.051] result() for ClusterFuture ...
[17:37:41.051] - result already collected: FutureResult
[17:37:41.051] result() for ClusterFuture ... done
[17:37:41.052] result() for ClusterFuture ...
[17:37:41.052] - result already collected: FutureResult
[17:37:41.052] result() for ClusterFuture ... done
[17:37:41.052] result() for ClusterFuture ...
[17:37:41.052] - result already collected: FutureResult
[17:37:41.052] result() for ClusterFuture ... done
[17:37:41.052]  - Number of value chunks collected: 2
[17:37:41.052] Resolving 2 futures (chunks) ... DONE
[17:37:41.052] Reducing values from 2 chunks ...
[17:37:41.052]  - Number of values collected after concatenation: 3
[17:37:41.053]  - Number of values expected: 3
[17:37:41.053] Reducing values from 2 chunks ... DONE
[17:37:41.053] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[17:37:41.053] future_mapply() ...
[17:37:41.057] Number of chunks: 2
[17:37:41.057] getGlobalsAndPackagesXApply() ...
[17:37:41.057]  - future.globals: TRUE
[17:37:41.057] getGlobalsAndPackages() ...
[17:37:41.057] Searching for globals...
[17:37:41.058] - globals found: [1] ‘FUN’
[17:37:41.058] Searching for globals ... DONE
[17:37:41.058] Resolving globals: FALSE
[17:37:41.059] The total size of the 1 globals is 848 bytes (848 bytes)
[17:37:41.059] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:37:41.059] - globals: [1] ‘FUN’
[17:37:41.059] 
[17:37:41.059] getGlobalsAndPackages() ... DONE
[17:37:41.059]  - globals found/used: [n=1] ‘FUN’
[17:37:41.060]  - needed namespaces: [n=0] 
[17:37:41.060] Finding globals ... DONE
[17:37:41.060] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:37:41.060] List of 2
[17:37:41.060]  $ ...future.FUN:function (x)  
[17:37:41.060]  $ MoreArgs     : NULL
[17:37:41.060]  - attr(*, "where")=List of 2
[17:37:41.060]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:37:41.060]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:37:41.060]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:37:41.060]  - attr(*, "resolved")= logi FALSE
[17:37:41.060]  - attr(*, "total_size")= num NA
[17:37:41.062] Packages to be attached in all futures: [n=0] 
[17:37:41.063] getGlobalsAndPackagesXApply() ... DONE
[17:37:41.063] Number of futures (= number of chunks): 2
[17:37:41.063] Launching 2 futures (chunks) ...
[17:37:41.063] Chunk #1 of 2 ...
[17:37:41.063]  - Finding globals in '...' for chunk #1 ...
[17:37:41.063] getGlobalsAndPackages() ...
[17:37:41.063] Searching for globals...
[17:37:41.064] 
[17:37:41.064] Searching for globals ... DONE
[17:37:41.064] - globals: [0] <none>
[17:37:41.064] getGlobalsAndPackages() ... DONE
[17:37:41.064]    + additional globals found: [n=0] 
[17:37:41.064]    + additional namespaces needed: [n=0] 
[17:37:41.064]  - Finding globals in '...' for chunk #1 ... DONE
[17:37:41.064]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:41.064]  - seeds: <none>
[17:37:41.064]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:41.065] getGlobalsAndPackages() ...
[17:37:41.065] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:41.065] Resolving globals: FALSE
[17:37:41.065] The total size of the 5 globals is 904 bytes (904 bytes)
[17:37:41.066] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:41.066] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:41.066] 
[17:37:41.066] getGlobalsAndPackages() ... DONE
[17:37:41.066] run() for ‘Future’ ...
[17:37:41.066] - state: ‘created’
[17:37:41.066] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:41.080] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:41.081] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:41.081]   - Field: ‘node’
[17:37:41.081]   - Field: ‘label’
[17:37:41.081]   - Field: ‘local’
[17:37:41.081]   - Field: ‘owner’
[17:37:41.081]   - Field: ‘envir’
[17:37:41.081]   - Field: ‘workers’
[17:37:41.081]   - Field: ‘packages’
[17:37:41.081]   - Field: ‘gc’
[17:37:41.081]   - Field: ‘conditions’
[17:37:41.081]   - Field: ‘persistent’
[17:37:41.082]   - Field: ‘expr’
[17:37:41.082]   - Field: ‘uuid’
[17:37:41.082]   - Field: ‘seed’
[17:37:41.082]   - Field: ‘version’
[17:37:41.082]   - Field: ‘result’
[17:37:41.082]   - Field: ‘asynchronous’
[17:37:41.082]   - Field: ‘calls’
[17:37:41.082]   - Field: ‘globals’
[17:37:41.082]   - Field: ‘stdout’
[17:37:41.082]   - Field: ‘earlySignal’
[17:37:41.082]   - Field: ‘lazy’
[17:37:41.083]   - Field: ‘state’
[17:37:41.083] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:41.083] - Launch lazy future ...
[17:37:41.083] Packages needed by the future expression (n = 0): <none>
[17:37:41.083] Packages needed by future strategies (n = 0): <none>
[17:37:41.084] {
[17:37:41.084]     {
[17:37:41.084]         {
[17:37:41.084]             ...future.startTime <- base::Sys.time()
[17:37:41.084]             {
[17:37:41.084]                 {
[17:37:41.084]                   {
[17:37:41.084]                     {
[17:37:41.084]                       base::local({
[17:37:41.084]                         has_future <- base::requireNamespace("future", 
[17:37:41.084]                           quietly = TRUE)
[17:37:41.084]                         if (has_future) {
[17:37:41.084]                           ns <- base::getNamespace("future")
[17:37:41.084]                           version <- ns[[".package"]][["version"]]
[17:37:41.084]                           if (is.null(version)) 
[17:37:41.084]                             version <- utils::packageVersion("future")
[17:37:41.084]                         }
[17:37:41.084]                         else {
[17:37:41.084]                           version <- NULL
[17:37:41.084]                         }
[17:37:41.084]                         if (!has_future || version < "1.8.0") {
[17:37:41.084]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:41.084]                             "", base::R.version$version.string), 
[17:37:41.084]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:41.084]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:41.084]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:41.084]                               "release", "version")], collapse = " "), 
[17:37:41.084]                             hostname = base::Sys.info()[["nodename"]])
[17:37:41.084]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:41.084]                             info)
[17:37:41.084]                           info <- base::paste(info, collapse = "; ")
[17:37:41.084]                           if (!has_future) {
[17:37:41.084]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:41.084]                               info)
[17:37:41.084]                           }
[17:37:41.084]                           else {
[17:37:41.084]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:41.084]                               info, version)
[17:37:41.084]                           }
[17:37:41.084]                           base::stop(msg)
[17:37:41.084]                         }
[17:37:41.084]                       })
[17:37:41.084]                     }
[17:37:41.084]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:41.084]                     base::options(mc.cores = 1L)
[17:37:41.084]                   }
[17:37:41.084]                   ...future.strategy.old <- future::plan("list")
[17:37:41.084]                   options(future.plan = NULL)
[17:37:41.084]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:41.084]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:41.084]                 }
[17:37:41.084]                 ...future.workdir <- getwd()
[17:37:41.084]             }
[17:37:41.084]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:41.084]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:41.084]         }
[17:37:41.084]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:41.084]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:41.084]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:41.084]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:41.084]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:41.084]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:41.084]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:41.084]             base::names(...future.oldOptions))
[17:37:41.084]     }
[17:37:41.084]     if (FALSE) {
[17:37:41.084]     }
[17:37:41.084]     else {
[17:37:41.084]         if (TRUE) {
[17:37:41.084]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:41.084]                 open = "w")
[17:37:41.084]         }
[17:37:41.084]         else {
[17:37:41.084]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:41.084]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:41.084]         }
[17:37:41.084]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:41.084]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:41.084]             base::sink(type = "output", split = FALSE)
[17:37:41.084]             base::close(...future.stdout)
[17:37:41.084]         }, add = TRUE)
[17:37:41.084]     }
[17:37:41.084]     ...future.frame <- base::sys.nframe()
[17:37:41.084]     ...future.conditions <- base::list()
[17:37:41.084]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:41.084]     if (FALSE) {
[17:37:41.084]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:41.084]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:41.084]     }
[17:37:41.084]     ...future.result <- base::tryCatch({
[17:37:41.084]         base::withCallingHandlers({
[17:37:41.084]             ...future.value <- base::withVisible(base::local({
[17:37:41.084]                 ...future.makeSendCondition <- base::local({
[17:37:41.084]                   sendCondition <- NULL
[17:37:41.084]                   function(frame = 1L) {
[17:37:41.084]                     if (is.function(sendCondition)) 
[17:37:41.084]                       return(sendCondition)
[17:37:41.084]                     ns <- getNamespace("parallel")
[17:37:41.084]                     if (exists("sendData", mode = "function", 
[17:37:41.084]                       envir = ns)) {
[17:37:41.084]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:41.084]                         envir = ns)
[17:37:41.084]                       envir <- sys.frame(frame)
[17:37:41.084]                       master <- NULL
[17:37:41.084]                       while (!identical(envir, .GlobalEnv) && 
[17:37:41.084]                         !identical(envir, emptyenv())) {
[17:37:41.084]                         if (exists("master", mode = "list", envir = envir, 
[17:37:41.084]                           inherits = FALSE)) {
[17:37:41.084]                           master <- get("master", mode = "list", 
[17:37:41.084]                             envir = envir, inherits = FALSE)
[17:37:41.084]                           if (inherits(master, c("SOCKnode", 
[17:37:41.084]                             "SOCK0node"))) {
[17:37:41.084]                             sendCondition <<- function(cond) {
[17:37:41.084]                               data <- list(type = "VALUE", value = cond, 
[17:37:41.084]                                 success = TRUE)
[17:37:41.084]                               parallel_sendData(master, data)
[17:37:41.084]                             }
[17:37:41.084]                             return(sendCondition)
[17:37:41.084]                           }
[17:37:41.084]                         }
[17:37:41.084]                         frame <- frame + 1L
[17:37:41.084]                         envir <- sys.frame(frame)
[17:37:41.084]                       }
[17:37:41.084]                     }
[17:37:41.084]                     sendCondition <<- function(cond) NULL
[17:37:41.084]                   }
[17:37:41.084]                 })
[17:37:41.084]                 withCallingHandlers({
[17:37:41.084]                   {
[17:37:41.084]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:41.084]                     if (!identical(...future.globals.maxSize.org, 
[17:37:41.084]                       ...future.globals.maxSize)) {
[17:37:41.084]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:41.084]                       on.exit(options(oopts), add = TRUE)
[17:37:41.084]                     }
[17:37:41.084]                     {
[17:37:41.084]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:41.084]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:41.084]                         USE.NAMES = FALSE)
[17:37:41.084]                       do.call(mapply, args = args)
[17:37:41.084]                     }
[17:37:41.084]                   }
[17:37:41.084]                 }, immediateCondition = function(cond) {
[17:37:41.084]                   sendCondition <- ...future.makeSendCondition()
[17:37:41.084]                   sendCondition(cond)
[17:37:41.084]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:41.084]                   {
[17:37:41.084]                     inherits <- base::inherits
[17:37:41.084]                     invokeRestart <- base::invokeRestart
[17:37:41.084]                     is.null <- base::is.null
[17:37:41.084]                     muffled <- FALSE
[17:37:41.084]                     if (inherits(cond, "message")) {
[17:37:41.084]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:41.084]                       if (muffled) 
[17:37:41.084]                         invokeRestart("muffleMessage")
[17:37:41.084]                     }
[17:37:41.084]                     else if (inherits(cond, "warning")) {
[17:37:41.084]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:41.084]                       if (muffled) 
[17:37:41.084]                         invokeRestart("muffleWarning")
[17:37:41.084]                     }
[17:37:41.084]                     else if (inherits(cond, "condition")) {
[17:37:41.084]                       if (!is.null(pattern)) {
[17:37:41.084]                         computeRestarts <- base::computeRestarts
[17:37:41.084]                         grepl <- base::grepl
[17:37:41.084]                         restarts <- computeRestarts(cond)
[17:37:41.084]                         for (restart in restarts) {
[17:37:41.084]                           name <- restart$name
[17:37:41.084]                           if (is.null(name)) 
[17:37:41.084]                             next
[17:37:41.084]                           if (!grepl(pattern, name)) 
[17:37:41.084]                             next
[17:37:41.084]                           invokeRestart(restart)
[17:37:41.084]                           muffled <- TRUE
[17:37:41.084]                           break
[17:37:41.084]                         }
[17:37:41.084]                       }
[17:37:41.084]                     }
[17:37:41.084]                     invisible(muffled)
[17:37:41.084]                   }
[17:37:41.084]                   muffleCondition(cond)
[17:37:41.084]                 })
[17:37:41.084]             }))
[17:37:41.084]             future::FutureResult(value = ...future.value$value, 
[17:37:41.084]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:41.084]                   ...future.rng), globalenv = if (FALSE) 
[17:37:41.084]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:41.084]                     ...future.globalenv.names))
[17:37:41.084]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:41.084]         }, condition = base::local({
[17:37:41.084]             c <- base::c
[17:37:41.084]             inherits <- base::inherits
[17:37:41.084]             invokeRestart <- base::invokeRestart
[17:37:41.084]             length <- base::length
[17:37:41.084]             list <- base::list
[17:37:41.084]             seq.int <- base::seq.int
[17:37:41.084]             signalCondition <- base::signalCondition
[17:37:41.084]             sys.calls <- base::sys.calls
[17:37:41.084]             `[[` <- base::`[[`
[17:37:41.084]             `+` <- base::`+`
[17:37:41.084]             `<<-` <- base::`<<-`
[17:37:41.084]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:41.084]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:41.084]                   3L)]
[17:37:41.084]             }
[17:37:41.084]             function(cond) {
[17:37:41.084]                 is_error <- inherits(cond, "error")
[17:37:41.084]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:41.084]                   NULL)
[17:37:41.084]                 if (is_error) {
[17:37:41.084]                   sessionInformation <- function() {
[17:37:41.084]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:41.084]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:41.084]                       search = base::search(), system = base::Sys.info())
[17:37:41.084]                   }
[17:37:41.084]                   ...future.conditions[[length(...future.conditions) + 
[17:37:41.084]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:41.084]                     cond$call), session = sessionInformation(), 
[17:37:41.084]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:41.084]                   signalCondition(cond)
[17:37:41.084]                 }
[17:37:41.084]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:41.084]                 "immediateCondition"))) {
[17:37:41.084]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:41.084]                   ...future.conditions[[length(...future.conditions) + 
[17:37:41.084]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:41.084]                   if (TRUE && !signal) {
[17:37:41.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:41.084]                     {
[17:37:41.084]                       inherits <- base::inherits
[17:37:41.084]                       invokeRestart <- base::invokeRestart
[17:37:41.084]                       is.null <- base::is.null
[17:37:41.084]                       muffled <- FALSE
[17:37:41.084]                       if (inherits(cond, "message")) {
[17:37:41.084]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:41.084]                         if (muffled) 
[17:37:41.084]                           invokeRestart("muffleMessage")
[17:37:41.084]                       }
[17:37:41.084]                       else if (inherits(cond, "warning")) {
[17:37:41.084]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:41.084]                         if (muffled) 
[17:37:41.084]                           invokeRestart("muffleWarning")
[17:37:41.084]                       }
[17:37:41.084]                       else if (inherits(cond, "condition")) {
[17:37:41.084]                         if (!is.null(pattern)) {
[17:37:41.084]                           computeRestarts <- base::computeRestarts
[17:37:41.084]                           grepl <- base::grepl
[17:37:41.084]                           restarts <- computeRestarts(cond)
[17:37:41.084]                           for (restart in restarts) {
[17:37:41.084]                             name <- restart$name
[17:37:41.084]                             if (is.null(name)) 
[17:37:41.084]                               next
[17:37:41.084]                             if (!grepl(pattern, name)) 
[17:37:41.084]                               next
[17:37:41.084]                             invokeRestart(restart)
[17:37:41.084]                             muffled <- TRUE
[17:37:41.084]                             break
[17:37:41.084]                           }
[17:37:41.084]                         }
[17:37:41.084]                       }
[17:37:41.084]                       invisible(muffled)
[17:37:41.084]                     }
[17:37:41.084]                     muffleCondition(cond, pattern = "^muffle")
[17:37:41.084]                   }
[17:37:41.084]                 }
[17:37:41.084]                 else {
[17:37:41.084]                   if (TRUE) {
[17:37:41.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:41.084]                     {
[17:37:41.084]                       inherits <- base::inherits
[17:37:41.084]                       invokeRestart <- base::invokeRestart
[17:37:41.084]                       is.null <- base::is.null
[17:37:41.084]                       muffled <- FALSE
[17:37:41.084]                       if (inherits(cond, "message")) {
[17:37:41.084]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:41.084]                         if (muffled) 
[17:37:41.084]                           invokeRestart("muffleMessage")
[17:37:41.084]                       }
[17:37:41.084]                       else if (inherits(cond, "warning")) {
[17:37:41.084]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:41.084]                         if (muffled) 
[17:37:41.084]                           invokeRestart("muffleWarning")
[17:37:41.084]                       }
[17:37:41.084]                       else if (inherits(cond, "condition")) {
[17:37:41.084]                         if (!is.null(pattern)) {
[17:37:41.084]                           computeRestarts <- base::computeRestarts
[17:37:41.084]                           grepl <- base::grepl
[17:37:41.084]                           restarts <- computeRestarts(cond)
[17:37:41.084]                           for (restart in restarts) {
[17:37:41.084]                             name <- restart$name
[17:37:41.084]                             if (is.null(name)) 
[17:37:41.084]                               next
[17:37:41.084]                             if (!grepl(pattern, name)) 
[17:37:41.084]                               next
[17:37:41.084]                             invokeRestart(restart)
[17:37:41.084]                             muffled <- TRUE
[17:37:41.084]                             break
[17:37:41.084]                           }
[17:37:41.084]                         }
[17:37:41.084]                       }
[17:37:41.084]                       invisible(muffled)
[17:37:41.084]                     }
[17:37:41.084]                     muffleCondition(cond, pattern = "^muffle")
[17:37:41.084]                   }
[17:37:41.084]                 }
[17:37:41.084]             }
[17:37:41.084]         }))
[17:37:41.084]     }, error = function(ex) {
[17:37:41.084]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:41.084]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:41.084]                 ...future.rng), started = ...future.startTime, 
[17:37:41.084]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:41.084]             version = "1.8"), class = "FutureResult")
[17:37:41.084]     }, finally = {
[17:37:41.084]         if (!identical(...future.workdir, getwd())) 
[17:37:41.084]             setwd(...future.workdir)
[17:37:41.084]         {
[17:37:41.084]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:41.084]                 ...future.oldOptions$nwarnings <- NULL
[17:37:41.084]             }
[17:37:41.084]             base::options(...future.oldOptions)
[17:37:41.084]             if (.Platform$OS.type == "windows") {
[17:37:41.084]                 old_names <- names(...future.oldEnvVars)
[17:37:41.084]                 envs <- base::Sys.getenv()
[17:37:41.084]                 names <- names(envs)
[17:37:41.084]                 common <- intersect(names, old_names)
[17:37:41.084]                 added <- setdiff(names, old_names)
[17:37:41.084]                 removed <- setdiff(old_names, names)
[17:37:41.084]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:41.084]                   envs[common]]
[17:37:41.084]                 NAMES <- toupper(changed)
[17:37:41.084]                 args <- list()
[17:37:41.084]                 for (kk in seq_along(NAMES)) {
[17:37:41.084]                   name <- changed[[kk]]
[17:37:41.084]                   NAME <- NAMES[[kk]]
[17:37:41.084]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:41.084]                     next
[17:37:41.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:41.084]                 }
[17:37:41.084]                 NAMES <- toupper(added)
[17:37:41.084]                 for (kk in seq_along(NAMES)) {
[17:37:41.084]                   name <- added[[kk]]
[17:37:41.084]                   NAME <- NAMES[[kk]]
[17:37:41.084]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:41.084]                     next
[17:37:41.084]                   args[[name]] <- ""
[17:37:41.084]                 }
[17:37:41.084]                 NAMES <- toupper(removed)
[17:37:41.084]                 for (kk in seq_along(NAMES)) {
[17:37:41.084]                   name <- removed[[kk]]
[17:37:41.084]                   NAME <- NAMES[[kk]]
[17:37:41.084]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:41.084]                     next
[17:37:41.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:41.084]                 }
[17:37:41.084]                 if (length(args) > 0) 
[17:37:41.084]                   base::do.call(base::Sys.setenv, args = args)
[17:37:41.084]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:41.084]             }
[17:37:41.084]             else {
[17:37:41.084]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:41.084]             }
[17:37:41.084]             {
[17:37:41.084]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:41.084]                   0L) {
[17:37:41.084]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:41.084]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:41.084]                   base::options(opts)
[17:37:41.084]                 }
[17:37:41.084]                 {
[17:37:41.084]                   {
[17:37:41.084]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:41.084]                     NULL
[17:37:41.084]                   }
[17:37:41.084]                   options(future.plan = NULL)
[17:37:41.084]                   if (is.na(NA_character_)) 
[17:37:41.084]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:41.084]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:41.084]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:41.084]                     .init = FALSE)
[17:37:41.084]                 }
[17:37:41.084]             }
[17:37:41.084]         }
[17:37:41.084]     })
[17:37:41.084]     if (TRUE) {
[17:37:41.084]         base::sink(type = "output", split = FALSE)
[17:37:41.084]         if (TRUE) {
[17:37:41.084]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:41.084]         }
[17:37:41.084]         else {
[17:37:41.084]             ...future.result["stdout"] <- base::list(NULL)
[17:37:41.084]         }
[17:37:41.084]         base::close(...future.stdout)
[17:37:41.084]         ...future.stdout <- NULL
[17:37:41.084]     }
[17:37:41.084]     ...future.result$conditions <- ...future.conditions
[17:37:41.084]     ...future.result$finished <- base::Sys.time()
[17:37:41.084]     ...future.result
[17:37:41.084] }
[17:37:41.086] Exporting 5 global objects (904 bytes) to cluster node #1 ...
[17:37:41.087] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:37:41.087] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:37:41.087] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:37:41.087] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:37:41.087] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:37:41.088] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:37:41.088] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:37:41.088] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:37:41.088] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:37:41.089] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:37:41.089] Exporting 5 global objects (904 bytes) to cluster node #1 ... DONE
[17:37:41.089] MultisessionFuture started
[17:37:41.089] - Launch lazy future ... done
[17:37:41.089] run() for ‘MultisessionFuture’ ... done
[17:37:41.090] Created future:
[17:37:41.090] MultisessionFuture:
[17:37:41.090] Label: ‘future_mapply-1’
[17:37:41.090] Expression:
[17:37:41.090] {
[17:37:41.090]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:41.090]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:41.090]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:41.090]         on.exit(options(oopts), add = TRUE)
[17:37:41.090]     }
[17:37:41.090]     {
[17:37:41.090]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:41.090]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:41.090]         do.call(mapply, args = args)
[17:37:41.090]     }
[17:37:41.090] }
[17:37:41.090] Lazy evaluation: FALSE
[17:37:41.090] Asynchronous evaluation: TRUE
[17:37:41.090] Local evaluation: TRUE
[17:37:41.090] Environment: R_GlobalEnv
[17:37:41.090] Capture standard output: TRUE
[17:37:41.090] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:41.090] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:41.090] Packages: <none>
[17:37:41.090] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:41.090] Resolved: FALSE
[17:37:41.090] Value: <not collected>
[17:37:41.090] Conditions captured: <none>
[17:37:41.090] Early signaling: FALSE
[17:37:41.090] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:41.090] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:41.101] Chunk #1 of 2 ... DONE
[17:37:41.101] Chunk #2 of 2 ...
[17:37:41.101]  - Finding globals in '...' for chunk #2 ...
[17:37:41.101] getGlobalsAndPackages() ...
[17:37:41.102] Searching for globals...
[17:37:41.102] 
[17:37:41.102] Searching for globals ... DONE
[17:37:41.102] - globals: [0] <none>
[17:37:41.102] getGlobalsAndPackages() ... DONE
[17:37:41.102]    + additional globals found: [n=0] 
[17:37:41.102]    + additional namespaces needed: [n=0] 
[17:37:41.105]  - Finding globals in '...' for chunk #2 ... DONE
[17:37:41.105]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:37:41.105]  - seeds: <none>
[17:37:41.105]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:41.105] getGlobalsAndPackages() ...
[17:37:41.106] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:41.106] Resolving globals: FALSE
[17:37:41.106] The total size of the 5 globals is 904 bytes (904 bytes)
[17:37:41.107] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:37:41.107] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:37:41.107] 
[17:37:41.107] getGlobalsAndPackages() ... DONE
[17:37:41.107] run() for ‘Future’ ...
[17:37:41.107] - state: ‘created’
[17:37:41.107] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:37:41.121] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:41.121] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:37:41.121]   - Field: ‘node’
[17:37:41.121]   - Field: ‘label’
[17:37:41.121]   - Field: ‘local’
[17:37:41.122]   - Field: ‘owner’
[17:37:41.122]   - Field: ‘envir’
[17:37:41.122]   - Field: ‘workers’
[17:37:41.122]   - Field: ‘packages’
[17:37:41.122]   - Field: ‘gc’
[17:37:41.122]   - Field: ‘conditions’
[17:37:41.122]   - Field: ‘persistent’
[17:37:41.122]   - Field: ‘expr’
[17:37:41.122]   - Field: ‘uuid’
[17:37:41.122]   - Field: ‘seed’
[17:37:41.122]   - Field: ‘version’
[17:37:41.122]   - Field: ‘result’
[17:37:41.123]   - Field: ‘asynchronous’
[17:37:41.123]   - Field: ‘calls’
[17:37:41.123]   - Field: ‘globals’
[17:37:41.123]   - Field: ‘stdout’
[17:37:41.123]   - Field: ‘earlySignal’
[17:37:41.123]   - Field: ‘lazy’
[17:37:41.123]   - Field: ‘state’
[17:37:41.123] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:37:41.123] - Launch lazy future ...
[17:37:41.124] Packages needed by the future expression (n = 0): <none>
[17:37:41.124] Packages needed by future strategies (n = 0): <none>
[17:37:41.124] {
[17:37:41.124]     {
[17:37:41.124]         {
[17:37:41.124]             ...future.startTime <- base::Sys.time()
[17:37:41.124]             {
[17:37:41.124]                 {
[17:37:41.124]                   {
[17:37:41.124]                     {
[17:37:41.124]                       base::local({
[17:37:41.124]                         has_future <- base::requireNamespace("future", 
[17:37:41.124]                           quietly = TRUE)
[17:37:41.124]                         if (has_future) {
[17:37:41.124]                           ns <- base::getNamespace("future")
[17:37:41.124]                           version <- ns[[".package"]][["version"]]
[17:37:41.124]                           if (is.null(version)) 
[17:37:41.124]                             version <- utils::packageVersion("future")
[17:37:41.124]                         }
[17:37:41.124]                         else {
[17:37:41.124]                           version <- NULL
[17:37:41.124]                         }
[17:37:41.124]                         if (!has_future || version < "1.8.0") {
[17:37:41.124]                           info <- base::c(r_version = base::gsub("R version ", 
[17:37:41.124]                             "", base::R.version$version.string), 
[17:37:41.124]                             platform = base::sprintf("%s (%s-bit)", 
[17:37:41.124]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:37:41.124]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:37:41.124]                               "release", "version")], collapse = " "), 
[17:37:41.124]                             hostname = base::Sys.info()[["nodename"]])
[17:37:41.124]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:37:41.124]                             info)
[17:37:41.124]                           info <- base::paste(info, collapse = "; ")
[17:37:41.124]                           if (!has_future) {
[17:37:41.124]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:37:41.124]                               info)
[17:37:41.124]                           }
[17:37:41.124]                           else {
[17:37:41.124]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:37:41.124]                               info, version)
[17:37:41.124]                           }
[17:37:41.124]                           base::stop(msg)
[17:37:41.124]                         }
[17:37:41.124]                       })
[17:37:41.124]                     }
[17:37:41.124]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:37:41.124]                     base::options(mc.cores = 1L)
[17:37:41.124]                   }
[17:37:41.124]                   ...future.strategy.old <- future::plan("list")
[17:37:41.124]                   options(future.plan = NULL)
[17:37:41.124]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:37:41.124]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:37:41.124]                 }
[17:37:41.124]                 ...future.workdir <- getwd()
[17:37:41.124]             }
[17:37:41.124]             ...future.oldOptions <- base::as.list(base::.Options)
[17:37:41.124]             ...future.oldEnvVars <- base::Sys.getenv()
[17:37:41.124]         }
[17:37:41.124]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:37:41.124]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:37:41.124]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:37:41.124]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:37:41.124]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:37:41.124]             future.stdout.windows.reencode = NULL, width = 80L)
[17:37:41.124]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:37:41.124]             base::names(...future.oldOptions))
[17:37:41.124]     }
[17:37:41.124]     if (FALSE) {
[17:37:41.124]     }
[17:37:41.124]     else {
[17:37:41.124]         if (TRUE) {
[17:37:41.124]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:37:41.124]                 open = "w")
[17:37:41.124]         }
[17:37:41.124]         else {
[17:37:41.124]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:37:41.124]                 windows = "NUL", "/dev/null"), open = "w")
[17:37:41.124]         }
[17:37:41.124]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:37:41.124]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:37:41.124]             base::sink(type = "output", split = FALSE)
[17:37:41.124]             base::close(...future.stdout)
[17:37:41.124]         }, add = TRUE)
[17:37:41.124]     }
[17:37:41.124]     ...future.frame <- base::sys.nframe()
[17:37:41.124]     ...future.conditions <- base::list()
[17:37:41.124]     ...future.rng <- base::globalenv()$.Random.seed
[17:37:41.124]     if (FALSE) {
[17:37:41.124]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:37:41.124]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:37:41.124]     }
[17:37:41.124]     ...future.result <- base::tryCatch({
[17:37:41.124]         base::withCallingHandlers({
[17:37:41.124]             ...future.value <- base::withVisible(base::local({
[17:37:41.124]                 ...future.makeSendCondition <- base::local({
[17:37:41.124]                   sendCondition <- NULL
[17:37:41.124]                   function(frame = 1L) {
[17:37:41.124]                     if (is.function(sendCondition)) 
[17:37:41.124]                       return(sendCondition)
[17:37:41.124]                     ns <- getNamespace("parallel")
[17:37:41.124]                     if (exists("sendData", mode = "function", 
[17:37:41.124]                       envir = ns)) {
[17:37:41.124]                       parallel_sendData <- get("sendData", mode = "function", 
[17:37:41.124]                         envir = ns)
[17:37:41.124]                       envir <- sys.frame(frame)
[17:37:41.124]                       master <- NULL
[17:37:41.124]                       while (!identical(envir, .GlobalEnv) && 
[17:37:41.124]                         !identical(envir, emptyenv())) {
[17:37:41.124]                         if (exists("master", mode = "list", envir = envir, 
[17:37:41.124]                           inherits = FALSE)) {
[17:37:41.124]                           master <- get("master", mode = "list", 
[17:37:41.124]                             envir = envir, inherits = FALSE)
[17:37:41.124]                           if (inherits(master, c("SOCKnode", 
[17:37:41.124]                             "SOCK0node"))) {
[17:37:41.124]                             sendCondition <<- function(cond) {
[17:37:41.124]                               data <- list(type = "VALUE", value = cond, 
[17:37:41.124]                                 success = TRUE)
[17:37:41.124]                               parallel_sendData(master, data)
[17:37:41.124]                             }
[17:37:41.124]                             return(sendCondition)
[17:37:41.124]                           }
[17:37:41.124]                         }
[17:37:41.124]                         frame <- frame + 1L
[17:37:41.124]                         envir <- sys.frame(frame)
[17:37:41.124]                       }
[17:37:41.124]                     }
[17:37:41.124]                     sendCondition <<- function(cond) NULL
[17:37:41.124]                   }
[17:37:41.124]                 })
[17:37:41.124]                 withCallingHandlers({
[17:37:41.124]                   {
[17:37:41.124]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:41.124]                     if (!identical(...future.globals.maxSize.org, 
[17:37:41.124]                       ...future.globals.maxSize)) {
[17:37:41.124]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:41.124]                       on.exit(options(oopts), add = TRUE)
[17:37:41.124]                     }
[17:37:41.124]                     {
[17:37:41.124]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:41.124]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:37:41.124]                         USE.NAMES = FALSE)
[17:37:41.124]                       do.call(mapply, args = args)
[17:37:41.124]                     }
[17:37:41.124]                   }
[17:37:41.124]                 }, immediateCondition = function(cond) {
[17:37:41.124]                   sendCondition <- ...future.makeSendCondition()
[17:37:41.124]                   sendCondition(cond)
[17:37:41.124]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:41.124]                   {
[17:37:41.124]                     inherits <- base::inherits
[17:37:41.124]                     invokeRestart <- base::invokeRestart
[17:37:41.124]                     is.null <- base::is.null
[17:37:41.124]                     muffled <- FALSE
[17:37:41.124]                     if (inherits(cond, "message")) {
[17:37:41.124]                       muffled <- grepl(pattern, "muffleMessage")
[17:37:41.124]                       if (muffled) 
[17:37:41.124]                         invokeRestart("muffleMessage")
[17:37:41.124]                     }
[17:37:41.124]                     else if (inherits(cond, "warning")) {
[17:37:41.124]                       muffled <- grepl(pattern, "muffleWarning")
[17:37:41.124]                       if (muffled) 
[17:37:41.124]                         invokeRestart("muffleWarning")
[17:37:41.124]                     }
[17:37:41.124]                     else if (inherits(cond, "condition")) {
[17:37:41.124]                       if (!is.null(pattern)) {
[17:37:41.124]                         computeRestarts <- base::computeRestarts
[17:37:41.124]                         grepl <- base::grepl
[17:37:41.124]                         restarts <- computeRestarts(cond)
[17:37:41.124]                         for (restart in restarts) {
[17:37:41.124]                           name <- restart$name
[17:37:41.124]                           if (is.null(name)) 
[17:37:41.124]                             next
[17:37:41.124]                           if (!grepl(pattern, name)) 
[17:37:41.124]                             next
[17:37:41.124]                           invokeRestart(restart)
[17:37:41.124]                           muffled <- TRUE
[17:37:41.124]                           break
[17:37:41.124]                         }
[17:37:41.124]                       }
[17:37:41.124]                     }
[17:37:41.124]                     invisible(muffled)
[17:37:41.124]                   }
[17:37:41.124]                   muffleCondition(cond)
[17:37:41.124]                 })
[17:37:41.124]             }))
[17:37:41.124]             future::FutureResult(value = ...future.value$value, 
[17:37:41.124]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:41.124]                   ...future.rng), globalenv = if (FALSE) 
[17:37:41.124]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:37:41.124]                     ...future.globalenv.names))
[17:37:41.124]                 else NULL, started = ...future.startTime, version = "1.8")
[17:37:41.124]         }, condition = base::local({
[17:37:41.124]             c <- base::c
[17:37:41.124]             inherits <- base::inherits
[17:37:41.124]             invokeRestart <- base::invokeRestart
[17:37:41.124]             length <- base::length
[17:37:41.124]             list <- base::list
[17:37:41.124]             seq.int <- base::seq.int
[17:37:41.124]             signalCondition <- base::signalCondition
[17:37:41.124]             sys.calls <- base::sys.calls
[17:37:41.124]             `[[` <- base::`[[`
[17:37:41.124]             `+` <- base::`+`
[17:37:41.124]             `<<-` <- base::`<<-`
[17:37:41.124]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:37:41.124]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:37:41.124]                   3L)]
[17:37:41.124]             }
[17:37:41.124]             function(cond) {
[17:37:41.124]                 is_error <- inherits(cond, "error")
[17:37:41.124]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:37:41.124]                   NULL)
[17:37:41.124]                 if (is_error) {
[17:37:41.124]                   sessionInformation <- function() {
[17:37:41.124]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:37:41.124]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:37:41.124]                       search = base::search(), system = base::Sys.info())
[17:37:41.124]                   }
[17:37:41.124]                   ...future.conditions[[length(...future.conditions) + 
[17:37:41.124]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:37:41.124]                     cond$call), session = sessionInformation(), 
[17:37:41.124]                     timestamp = base::Sys.time(), signaled = 0L)
[17:37:41.124]                   signalCondition(cond)
[17:37:41.124]                 }
[17:37:41.124]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:37:41.124]                 "immediateCondition"))) {
[17:37:41.124]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:37:41.124]                   ...future.conditions[[length(...future.conditions) + 
[17:37:41.124]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:37:41.124]                   if (TRUE && !signal) {
[17:37:41.124]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:41.124]                     {
[17:37:41.124]                       inherits <- base::inherits
[17:37:41.124]                       invokeRestart <- base::invokeRestart
[17:37:41.124]                       is.null <- base::is.null
[17:37:41.124]                       muffled <- FALSE
[17:37:41.124]                       if (inherits(cond, "message")) {
[17:37:41.124]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:41.124]                         if (muffled) 
[17:37:41.124]                           invokeRestart("muffleMessage")
[17:37:41.124]                       }
[17:37:41.124]                       else if (inherits(cond, "warning")) {
[17:37:41.124]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:41.124]                         if (muffled) 
[17:37:41.124]                           invokeRestart("muffleWarning")
[17:37:41.124]                       }
[17:37:41.124]                       else if (inherits(cond, "condition")) {
[17:37:41.124]                         if (!is.null(pattern)) {
[17:37:41.124]                           computeRestarts <- base::computeRestarts
[17:37:41.124]                           grepl <- base::grepl
[17:37:41.124]                           restarts <- computeRestarts(cond)
[17:37:41.124]                           for (restart in restarts) {
[17:37:41.124]                             name <- restart$name
[17:37:41.124]                             if (is.null(name)) 
[17:37:41.124]                               next
[17:37:41.124]                             if (!grepl(pattern, name)) 
[17:37:41.124]                               next
[17:37:41.124]                             invokeRestart(restart)
[17:37:41.124]                             muffled <- TRUE
[17:37:41.124]                             break
[17:37:41.124]                           }
[17:37:41.124]                         }
[17:37:41.124]                       }
[17:37:41.124]                       invisible(muffled)
[17:37:41.124]                     }
[17:37:41.124]                     muffleCondition(cond, pattern = "^muffle")
[17:37:41.124]                   }
[17:37:41.124]                 }
[17:37:41.124]                 else {
[17:37:41.124]                   if (TRUE) {
[17:37:41.124]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:37:41.124]                     {
[17:37:41.124]                       inherits <- base::inherits
[17:37:41.124]                       invokeRestart <- base::invokeRestart
[17:37:41.124]                       is.null <- base::is.null
[17:37:41.124]                       muffled <- FALSE
[17:37:41.124]                       if (inherits(cond, "message")) {
[17:37:41.124]                         muffled <- grepl(pattern, "muffleMessage")
[17:37:41.124]                         if (muffled) 
[17:37:41.124]                           invokeRestart("muffleMessage")
[17:37:41.124]                       }
[17:37:41.124]                       else if (inherits(cond, "warning")) {
[17:37:41.124]                         muffled <- grepl(pattern, "muffleWarning")
[17:37:41.124]                         if (muffled) 
[17:37:41.124]                           invokeRestart("muffleWarning")
[17:37:41.124]                       }
[17:37:41.124]                       else if (inherits(cond, "condition")) {
[17:37:41.124]                         if (!is.null(pattern)) {
[17:37:41.124]                           computeRestarts <- base::computeRestarts
[17:37:41.124]                           grepl <- base::grepl
[17:37:41.124]                           restarts <- computeRestarts(cond)
[17:37:41.124]                           for (restart in restarts) {
[17:37:41.124]                             name <- restart$name
[17:37:41.124]                             if (is.null(name)) 
[17:37:41.124]                               next
[17:37:41.124]                             if (!grepl(pattern, name)) 
[17:37:41.124]                               next
[17:37:41.124]                             invokeRestart(restart)
[17:37:41.124]                             muffled <- TRUE
[17:37:41.124]                             break
[17:37:41.124]                           }
[17:37:41.124]                         }
[17:37:41.124]                       }
[17:37:41.124]                       invisible(muffled)
[17:37:41.124]                     }
[17:37:41.124]                     muffleCondition(cond, pattern = "^muffle")
[17:37:41.124]                   }
[17:37:41.124]                 }
[17:37:41.124]             }
[17:37:41.124]         }))
[17:37:41.124]     }, error = function(ex) {
[17:37:41.124]         base::structure(base::list(value = NULL, visible = NULL, 
[17:37:41.124]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:37:41.124]                 ...future.rng), started = ...future.startTime, 
[17:37:41.124]             finished = Sys.time(), session_uuid = NA_character_, 
[17:37:41.124]             version = "1.8"), class = "FutureResult")
[17:37:41.124]     }, finally = {
[17:37:41.124]         if (!identical(...future.workdir, getwd())) 
[17:37:41.124]             setwd(...future.workdir)
[17:37:41.124]         {
[17:37:41.124]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:37:41.124]                 ...future.oldOptions$nwarnings <- NULL
[17:37:41.124]             }
[17:37:41.124]             base::options(...future.oldOptions)
[17:37:41.124]             if (.Platform$OS.type == "windows") {
[17:37:41.124]                 old_names <- names(...future.oldEnvVars)
[17:37:41.124]                 envs <- base::Sys.getenv()
[17:37:41.124]                 names <- names(envs)
[17:37:41.124]                 common <- intersect(names, old_names)
[17:37:41.124]                 added <- setdiff(names, old_names)
[17:37:41.124]                 removed <- setdiff(old_names, names)
[17:37:41.124]                 changed <- common[...future.oldEnvVars[common] != 
[17:37:41.124]                   envs[common]]
[17:37:41.124]                 NAMES <- toupper(changed)
[17:37:41.124]                 args <- list()
[17:37:41.124]                 for (kk in seq_along(NAMES)) {
[17:37:41.124]                   name <- changed[[kk]]
[17:37:41.124]                   NAME <- NAMES[[kk]]
[17:37:41.124]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:41.124]                     next
[17:37:41.124]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:41.124]                 }
[17:37:41.124]                 NAMES <- toupper(added)
[17:37:41.124]                 for (kk in seq_along(NAMES)) {
[17:37:41.124]                   name <- added[[kk]]
[17:37:41.124]                   NAME <- NAMES[[kk]]
[17:37:41.124]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:41.124]                     next
[17:37:41.124]                   args[[name]] <- ""
[17:37:41.124]                 }
[17:37:41.124]                 NAMES <- toupper(removed)
[17:37:41.124]                 for (kk in seq_along(NAMES)) {
[17:37:41.124]                   name <- removed[[kk]]
[17:37:41.124]                   NAME <- NAMES[[kk]]
[17:37:41.124]                   if (name != NAME && is.element(NAME, old_names)) 
[17:37:41.124]                     next
[17:37:41.124]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:37:41.124]                 }
[17:37:41.124]                 if (length(args) > 0) 
[17:37:41.124]                   base::do.call(base::Sys.setenv, args = args)
[17:37:41.124]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:37:41.124]             }
[17:37:41.124]             else {
[17:37:41.124]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:37:41.124]             }
[17:37:41.124]             {
[17:37:41.124]                 if (base::length(...future.futureOptionsAdded) > 
[17:37:41.124]                   0L) {
[17:37:41.124]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:37:41.124]                   base::names(opts) <- ...future.futureOptionsAdded
[17:37:41.124]                   base::options(opts)
[17:37:41.124]                 }
[17:37:41.124]                 {
[17:37:41.124]                   {
[17:37:41.124]                     base::options(mc.cores = ...future.mc.cores.old)
[17:37:41.124]                     NULL
[17:37:41.124]                   }
[17:37:41.124]                   options(future.plan = NULL)
[17:37:41.124]                   if (is.na(NA_character_)) 
[17:37:41.124]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:37:41.124]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:37:41.124]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:37:41.124]                     .init = FALSE)
[17:37:41.124]                 }
[17:37:41.124]             }
[17:37:41.124]         }
[17:37:41.124]     })
[17:37:41.124]     if (TRUE) {
[17:37:41.124]         base::sink(type = "output", split = FALSE)
[17:37:41.124]         if (TRUE) {
[17:37:41.124]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:37:41.124]         }
[17:37:41.124]         else {
[17:37:41.124]             ...future.result["stdout"] <- base::list(NULL)
[17:37:41.124]         }
[17:37:41.124]         base::close(...future.stdout)
[17:37:41.124]         ...future.stdout <- NULL
[17:37:41.124]     }
[17:37:41.124]     ...future.result$conditions <- ...future.conditions
[17:37:41.124]     ...future.result$finished <- base::Sys.time()
[17:37:41.124]     ...future.result
[17:37:41.124] }
[17:37:41.127] Exporting 5 global objects (904 bytes) to cluster node #2 ...
[17:37:41.127] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[17:37:41.127] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[17:37:41.128] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:37:41.128] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:37:41.128] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:37:41.128] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:37:41.128] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:37:41.129] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:37:41.129] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:37:41.129] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:37:41.129] Exporting 5 global objects (904 bytes) to cluster node #2 ... DONE
[17:37:41.130] MultisessionFuture started
[17:37:41.130] - Launch lazy future ... done
[17:37:41.130] run() for ‘MultisessionFuture’ ... done
[17:37:41.130] Created future:
[17:37:41.130] MultisessionFuture:
[17:37:41.130] Label: ‘future_mapply-2’
[17:37:41.130] Expression:
[17:37:41.130] {
[17:37:41.130]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:37:41.130]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:37:41.130]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:37:41.130]         on.exit(options(oopts), add = TRUE)
[17:37:41.130]     }
[17:37:41.130]     {
[17:37:41.130]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:37:41.130]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:37:41.130]         do.call(mapply, args = args)
[17:37:41.130]     }
[17:37:41.130] }
[17:37:41.130] Lazy evaluation: FALSE
[17:37:41.130] Asynchronous evaluation: TRUE
[17:37:41.130] Local evaluation: TRUE
[17:37:41.130] Environment: R_GlobalEnv
[17:37:41.130] Capture standard output: TRUE
[17:37:41.130] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:37:41.130] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:37:41.130] Packages: <none>
[17:37:41.130] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:37:41.130] Resolved: FALSE
[17:37:41.130] Value: <not collected>
[17:37:41.130] Conditions captured: <none>
[17:37:41.130] Early signaling: FALSE
[17:37:41.130] Owner process: 82220eee-ca84-dca3-9164-42a927338a3a
[17:37:41.130] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:37:41.141] Chunk #2 of 2 ... DONE
[17:37:41.142] Launching 2 futures (chunks) ... DONE
[17:37:41.142] Resolving 2 futures (chunks) ...
[17:37:41.142] resolve() on list ...
[17:37:41.142]  recursive: 0
[17:37:41.142]  length: 2
[17:37:41.142] 
[17:37:41.142] receiveMessageFromWorker() for ClusterFuture ...
[17:37:41.143] - Validating connection of MultisessionFuture
[17:37:41.143] - received message: FutureResult
[17:37:41.143] - Received FutureResult
[17:37:41.143] - Erased future from FutureRegistry
[17:37:41.143] result() for ClusterFuture ...
[17:37:41.143] - result already collected: FutureResult
[17:37:41.143] result() for ClusterFuture ... done
[17:37:41.143] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:41.143] Future #1
[17:37:41.144] result() for ClusterFuture ...
[17:37:41.144] - result already collected: FutureResult
[17:37:41.144] result() for ClusterFuture ... done
[17:37:41.144] result() for ClusterFuture ...
[17:37:41.144] - result already collected: FutureResult
[17:37:41.144] result() for ClusterFuture ... done
[17:37:41.144] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:37:41.144] - nx: 2
[17:37:41.144] - relay: TRUE
[17:37:41.144] - stdout: TRUE
[17:37:41.144] - signal: TRUE
[17:37:41.145] - resignal: FALSE
[17:37:41.145] - force: TRUE
[17:37:41.145] - relayed: [n=2] FALSE, FALSE
[17:37:41.145] - queued futures: [n=2] FALSE, FALSE
[17:37:41.145]  - until=1
[17:37:41.145]  - relaying element #1
[17:37:41.145] result() for ClusterFuture ...
[17:37:41.145] - result already collected: FutureResult
[17:37:41.145] result() for ClusterFuture ... done
[17:37:41.145] result() for ClusterFuture ...
[17:37:41.145] - result already collected: FutureResult
[17:37:41.145] result() for ClusterFuture ... done
[17:37:41.146] result() for ClusterFuture ...
[17:37:41.146] - result already collected: FutureResult
[17:37:41.146] result() for ClusterFuture ... done
[17:37:41.146] result() for ClusterFuture ...
[17:37:41.146] - result already collected: FutureResult
[17:37:41.146] result() for ClusterFuture ... done
[17:37:41.146] - relayed: [n=2] TRUE, FALSE
[17:37:41.146] - queued futures: [n=2] TRUE, FALSE
[17:37:41.146] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:37:41.146]  length: 1 (resolved future 1)
[17:37:41.174] receiveMessageFromWorker() for ClusterFuture ...
[17:37:41.174] - Validating connection of MultisessionFuture
[17:37:41.174] - received message: FutureResult
[17:37:41.174] - Received FutureResult
[17:37:41.174] - Erased future from FutureRegistry
[17:37:41.175] result() for ClusterFuture ...
[17:37:41.175] - result already collected: FutureResult
[17:37:41.175] result() for ClusterFuture ... done
[17:37:41.175] receiveMessageFromWorker() for ClusterFuture ... done
[17:37:41.175] Future #2
[17:37:41.175] result() for ClusterFuture ...
[17:37:41.175] - result already collected: FutureResult
[17:37:41.175] result() for ClusterFuture ... done
[17:37:41.175] result() for ClusterFuture ...
[17:37:41.175] - result already collected: FutureResult
[17:37:41.175] result() for ClusterFuture ... done
[17:37:41.176] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:37:41.176] - nx: 2
[17:37:41.176] - relay: TRUE
[17:37:41.176] - stdout: TRUE
[17:37:41.176] - signal: TRUE
[17:37:41.176] - resignal: FALSE
[17:37:41.176] - force: TRUE
[17:37:41.176] - relayed: [n=2] TRUE, FALSE
[17:37:41.176] - queued futures: [n=2] TRUE, FALSE
[17:37:41.176]  - until=2
[17:37:41.176]  - relaying element #2
[17:37:41.176] result() for ClusterFuture ...
[17:37:41.177] - result already collected: FutureResult
[17:37:41.177] result() for ClusterFuture ... done
[17:37:41.177] result() for ClusterFuture ...
[17:37:41.177] - result already collected: FutureResult
[17:37:41.177] result() for ClusterFuture ... done
[17:37:41.177] result() for ClusterFuture ...
[17:37:41.177] - result already collected: FutureResult
[17:37:41.177] result() for ClusterFuture ... done
[17:37:41.177] result() for ClusterFuture ...
[17:37:41.177] - result already collected: FutureResult
[17:37:41.177] result() for ClusterFuture ... done
[17:37:41.178] - relayed: [n=2] TRUE, TRUE
[17:37:41.178] - queued futures: [n=2] TRUE, TRUE
[17:37:41.178] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:37:41.178]  length: 0 (resolved future 2)
[17:37:41.178] Relaying remaining futures
[17:37:41.178] signalConditionsASAP(NULL, pos=0) ...
[17:37:41.178] - nx: 2
[17:37:41.178] - relay: TRUE
[17:37:41.178] - stdout: TRUE
[17:37:41.178] - signal: TRUE
[17:37:41.178] - resignal: FALSE
[17:37:41.178] - force: TRUE
[17:37:41.179] - relayed: [n=2] TRUE, TRUE
[17:37:41.179] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:37:41.179] - relayed: [n=2] TRUE, TRUE
[17:37:41.179] - queued futures: [n=2] TRUE, TRUE
[17:37:41.179] signalConditionsASAP(NULL, pos=0) ... done
[17:37:41.179] resolve() on list ... DONE
[17:37:41.179] result() for ClusterFuture ...
[17:37:41.179] - result already collected: FutureResult
[17:37:41.179] result() for ClusterFuture ... done
[17:37:41.179] result() for ClusterFuture ...
[17:37:41.179] - result already collected: FutureResult
[17:37:41.179] result() for ClusterFuture ... done
[17:37:41.180] result() for ClusterFuture ...
[17:37:41.180] - result already collected: FutureResult
[17:37:41.180] result() for ClusterFuture ... done
[17:37:41.180] result() for ClusterFuture ...
[17:37:41.180] - result already collected: FutureResult
[17:37:41.180] result() for ClusterFuture ... done
[17:37:41.180]  - Number of value chunks collected: 2
[17:37:41.180] Resolving 2 futures (chunks) ... DONE
[17:37:41.180] Reducing values from 2 chunks ...
[17:37:41.180]  - Number of values collected after concatenation: 2
[17:37:41.180]  - Number of values expected: 2
[17:37:41.181] Reducing values from 2 chunks ... DONE
[17:37:41.181] future_mapply() ... DONE
[17:37:41.181] plan(): Setting new future strategy stack:
[17:37:41.181] List of future strategies:
[17:37:41.181] 1. sequential:
[17:37:41.181]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:41.181]    - tweaked: FALSE
[17:37:41.181]    - call: plan(sequential)
[17:37:41.182] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("- Empty input [non parallel] ...")
- Empty input [non parallel] ...
> y0 <- mapply(search)
> y1 <- future_mapply(search)
> stopifnot(identical(y1, y0))
> 
> y0 <- mapply(list, integer(0L))
> y1 <- future_mapply(list, integer(0L))
> stopifnot(identical(y1, y0))
> 
> message("*** future_mapply() - special cases ...")
*** future_mapply() - special cases ...
> 
> X <- list()
> names(X) <- character(0L)
> 
> y <- future_mapply(FUN = identity, X)
> stopifnot(length(y) == 0L, !is.null(names(y)), identical(y, X))
> 
> y <- future_mapply(FUN = identity, X, X)
> stopifnot(length(y) == 0L, !is.null(names(y)), identical(y, X))
> 
> message("*** future_mapply() - special cases ... DONE")
*** future_mapply() - special cases ... DONE
> 
> message("*** future_mapply() ... DONE")
*** future_mapply() ... DONE
> 
> source("incl/end.R")
[17:37:41.183] plan(): Setting new future strategy stack:
[17:37:41.184] List of future strategies:
[17:37:41.184] 1. FutureStrategy:
[17:37:41.184]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:37:41.184]    - tweaked: FALSE
[17:37:41.184]    - call: future::plan(oplan)
[17:37:41.184] plan(): nbrOfWorkers() = 1
> 
