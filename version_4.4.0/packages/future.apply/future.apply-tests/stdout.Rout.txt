
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[09:29:59.430] plan(): Setting new future strategy stack:
[09:29:59.430] List of future strategies:
[09:29:59.430] 1. sequential:
[09:29:59.430]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:59.430]    - tweaked: FALSE
[09:29:59.430]    - call: future::plan("sequential")
[09:29:59.443] plan(): nbrOfWorkers() = 1
> 
> message("*** future_*apply() and 'future.stdout' ...")
*** future_*apply() and 'future.stdout' ...
> 
> options(future.debug = TRUE)
> 
> truth <- list()
> 
> out <- utils::capture.output({
+   y <- lapply(1:0, FUN = function(x) {
+     print(x)
+   })
+ })
> truth[["lapply"]] <- list(value = y, stdout = out)
> 
> out <- utils::capture.output({
+   y <- mapply(1:0, 0:1, FUN = function(x, y) {
+     print(list(x = x, y = y))
+   })
+ })
> truth[["mapply"]] <- list(value = y, stdout = out)
> 
> for (cores in 1:availCores) {
+   message(sprintf("  - Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+   
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("* plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     for (fun in names(truth)) {
+       for (stdout in c(FALSE, TRUE, NA)) {
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ...", fun, stdout))
+   
+         out <- utils::capture.output({
+           if (fun == "lapply") {
+             y <- future_lapply(1:0, FUN = function(x) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+ 	      print(x)
+             }, future.stdout = stdout)
+ 	  } else if (fun == "mapply") {
+             y <- future_mapply(1:0, 0:1, FUN = function(x, y) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+               print(list(x = x, y = y))
+             }, future.stdout = stdout)
+ 	  }
+         })
+         stopifnot(identical(y, truth[[fun]]$value))
+   
+         if (isTRUE(stdout)) {
+           stopifnot(identical(out, truth[[fun]]$stdout))
+         } else if (is.na(stdout)) {
+         } else {
+           stopifnot(nchar(out) == 0)
+         }
+       
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ... DONE", fun, stdout))
+       } ## for (stdout ...)
+     } ## for (fun ...)
+     
+     message(sprintf("* plan('%s') ... DONE", strategy))
+   }
+   
+   message(sprintf("  - Testing with %d cores ... DONE", cores))
+ }
  - Testing with 1 cores ...
* plan('sequential') ...
[09:29:59.475] plan(): Setting new future strategy stack:
[09:29:59.475] List of future strategies:
[09:29:59.475] 1. sequential:
[09:29:59.475]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:59.475]    - tweaked: FALSE
[09:29:59.475]    - call: plan(strategy)
[09:29:59.486] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[09:29:59.486] future_lapply() ...
[09:29:59.490] Number of chunks: 1
[09:29:59.490] getGlobalsAndPackagesXApply() ...
[09:29:59.490]  - future.globals: TRUE
[09:29:59.491] getGlobalsAndPackages() ...
[09:29:59.491] Searching for globals...
[09:29:59.493] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[09:29:59.493] Searching for globals ... DONE
[09:29:59.493] Resolving globals: FALSE
[09:29:59.494] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[09:29:59.495] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[09:29:59.495] - globals: [1] ‘FUN’
[09:29:59.495] 
[09:29:59.495] getGlobalsAndPackages() ... DONE
[09:29:59.495]  - globals found/used: [n=1] ‘FUN’
[09:29:59.495]  - needed namespaces: [n=0] 
[09:29:59.495] Finding globals ... DONE
[09:29:59.495]  - use_args: TRUE
[09:29:59.496]  - Getting '...' globals ...
[09:29:59.496] resolve() on list ...
[09:29:59.496]  recursive: 0
[09:29:59.497]  length: 1
[09:29:59.497]  elements: ‘...’
[09:29:59.497]  length: 0 (resolved future 1)
[09:29:59.497] resolve() on list ... DONE
[09:29:59.497]    - '...' content: [n=0] 
[09:29:59.497] List of 1
[09:29:59.497]  $ ...: list()
[09:29:59.497]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:59.497]  - attr(*, "where")=List of 1
[09:29:59.497]   ..$ ...:<environment: 0x55c1038162d8> 
[09:29:59.497]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:59.497]  - attr(*, "resolved")= logi TRUE
[09:29:59.497]  - attr(*, "total_size")= num NA
[09:29:59.502]  - Getting '...' globals ... DONE
[09:29:59.502] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:29:59.502] List of 2
[09:29:59.502]  $ ...future.FUN:function (x)  
[09:29:59.502]  $ ...          : list()
[09:29:59.502]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:59.502]  - attr(*, "where")=List of 2
[09:29:59.502]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:59.502]   ..$ ...          :<environment: 0x55c1038162d8> 
[09:29:59.502]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:59.502]  - attr(*, "resolved")= logi FALSE
[09:29:59.502]  - attr(*, "total_size")= num 4720
[09:29:59.505] Packages to be attached in all futures: [n=0] 
[09:29:59.506] getGlobalsAndPackagesXApply() ... DONE
[09:29:59.506] Number of futures (= number of chunks): 1
[09:29:59.507] Launching 1 futures (chunks) ...
[09:29:59.507] Chunk #1 of 1 ...
[09:29:59.507]  - Finding globals in 'X' for chunk #1 ...
[09:29:59.507] getGlobalsAndPackages() ...
[09:29:59.507] Searching for globals...
[09:29:59.507] 
[09:29:59.507] Searching for globals ... DONE
[09:29:59.508] - globals: [0] <none>
[09:29:59.508] getGlobalsAndPackages() ... DONE
[09:29:59.508]    + additional globals found: [n=0] 
[09:29:59.508]    + additional namespaces needed: [n=0] 
[09:29:59.508]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:59.508]  - seeds: <none>
[09:29:59.508]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:59.508] getGlobalsAndPackages() ...
[09:29:59.508] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:59.509] Resolving globals: FALSE
[09:29:59.509] Tweak future expression to call with '...' arguments ...
[09:29:59.509] {
[09:29:59.509]     do.call(function(...) {
[09:29:59.509]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:59.509]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:59.509]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:59.509]             on.exit(options(oopts), add = TRUE)
[09:29:59.509]         }
[09:29:59.509]         {
[09:29:59.509]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:59.509]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:59.509]                 ...future.FUN(...future.X_jj, ...)
[09:29:59.509]             })
[09:29:59.509]         }
[09:29:59.509]     }, args = future.call.arguments)
[09:29:59.509] }
[09:29:59.509] Tweak future expression to call with '...' arguments ... DONE
[09:29:59.509] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:59.509] 
[09:29:59.510] getGlobalsAndPackages() ... DONE
[09:29:59.510] run() for ‘Future’ ...
[09:29:59.510] - state: ‘created’
[09:29:59.510] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:59.511] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:59.511] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:59.511]   - Field: ‘label’
[09:29:59.511]   - Field: ‘local’
[09:29:59.511]   - Field: ‘owner’
[09:29:59.511]   - Field: ‘envir’
[09:29:59.511]   - Field: ‘packages’
[09:29:59.511]   - Field: ‘gc’
[09:29:59.512]   - Field: ‘conditions’
[09:29:59.512]   - Field: ‘expr’
[09:29:59.512]   - Field: ‘uuid’
[09:29:59.512]   - Field: ‘seed’
[09:29:59.512]   - Field: ‘version’
[09:29:59.512]   - Field: ‘result’
[09:29:59.512]   - Field: ‘asynchronous’
[09:29:59.512]   - Field: ‘calls’
[09:29:59.512]   - Field: ‘globals’
[09:29:59.512]   - Field: ‘stdout’
[09:29:59.512]   - Field: ‘earlySignal’
[09:29:59.513]   - Field: ‘lazy’
[09:29:59.513]   - Field: ‘state’
[09:29:59.513] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:59.513] - Launch lazy future ...
[09:29:59.514] Packages needed by the future expression (n = 0): <none>
[09:29:59.514] Packages needed by future strategies (n = 0): <none>
[09:29:59.516] {
[09:29:59.516]     {
[09:29:59.516]         {
[09:29:59.516]             ...future.startTime <- base::Sys.time()
[09:29:59.516]             {
[09:29:59.516]                 {
[09:29:59.516]                   {
[09:29:59.516]                     base::local({
[09:29:59.516]                       has_future <- base::requireNamespace("future", 
[09:29:59.516]                         quietly = TRUE)
[09:29:59.516]                       if (has_future) {
[09:29:59.516]                         ns <- base::getNamespace("future")
[09:29:59.516]                         version <- ns[[".package"]][["version"]]
[09:29:59.516]                         if (is.null(version)) 
[09:29:59.516]                           version <- utils::packageVersion("future")
[09:29:59.516]                       }
[09:29:59.516]                       else {
[09:29:59.516]                         version <- NULL
[09:29:59.516]                       }
[09:29:59.516]                       if (!has_future || version < "1.8.0") {
[09:29:59.516]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:59.516]                           "", base::R.version$version.string), 
[09:29:59.516]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:59.516]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:59.516]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:59.516]                             "release", "version")], collapse = " "), 
[09:29:59.516]                           hostname = base::Sys.info()[["nodename"]])
[09:29:59.516]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:59.516]                           info)
[09:29:59.516]                         info <- base::paste(info, collapse = "; ")
[09:29:59.516]                         if (!has_future) {
[09:29:59.516]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:59.516]                             info)
[09:29:59.516]                         }
[09:29:59.516]                         else {
[09:29:59.516]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:59.516]                             info, version)
[09:29:59.516]                         }
[09:29:59.516]                         base::stop(msg)
[09:29:59.516]                       }
[09:29:59.516]                     })
[09:29:59.516]                   }
[09:29:59.516]                   ...future.strategy.old <- future::plan("list")
[09:29:59.516]                   options(future.plan = NULL)
[09:29:59.516]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:59.516]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:59.516]                 }
[09:29:59.516]                 ...future.workdir <- getwd()
[09:29:59.516]             }
[09:29:59.516]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:59.516]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:59.516]         }
[09:29:59.516]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:59.516]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:59.516]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:59.516]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:59.516]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:59.516]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:59.516]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:59.516]             base::names(...future.oldOptions))
[09:29:59.516]     }
[09:29:59.516]     if (FALSE) {
[09:29:59.516]     }
[09:29:59.516]     else {
[09:29:59.516]         if (FALSE) {
[09:29:59.516]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:59.516]                 open = "w")
[09:29:59.516]         }
[09:29:59.516]         else {
[09:29:59.516]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:59.516]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:59.516]         }
[09:29:59.516]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:59.516]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:59.516]             base::sink(type = "output", split = FALSE)
[09:29:59.516]             base::close(...future.stdout)
[09:29:59.516]         }, add = TRUE)
[09:29:59.516]     }
[09:29:59.516]     ...future.frame <- base::sys.nframe()
[09:29:59.516]     ...future.conditions <- base::list()
[09:29:59.516]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:59.516]     if (FALSE) {
[09:29:59.516]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:59.516]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:59.516]     }
[09:29:59.516]     ...future.result <- base::tryCatch({
[09:29:59.516]         base::withCallingHandlers({
[09:29:59.516]             ...future.value <- base::withVisible(base::local({
[09:29:59.516]                 do.call(function(...) {
[09:29:59.516]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:59.516]                   if (!identical(...future.globals.maxSize.org, 
[09:29:59.516]                     ...future.globals.maxSize)) {
[09:29:59.516]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:59.516]                     on.exit(options(oopts), add = TRUE)
[09:29:59.516]                   }
[09:29:59.516]                   {
[09:29:59.516]                     lapply(seq_along(...future.elements_ii), 
[09:29:59.516]                       FUN = function(jj) {
[09:29:59.516]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:59.516]                         ...future.FUN(...future.X_jj, ...)
[09:29:59.516]                       })
[09:29:59.516]                   }
[09:29:59.516]                 }, args = future.call.arguments)
[09:29:59.516]             }))
[09:29:59.516]             future::FutureResult(value = ...future.value$value, 
[09:29:59.516]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:59.516]                   ...future.rng), globalenv = if (FALSE) 
[09:29:59.516]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:59.516]                     ...future.globalenv.names))
[09:29:59.516]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:59.516]         }, condition = base::local({
[09:29:59.516]             c <- base::c
[09:29:59.516]             inherits <- base::inherits
[09:29:59.516]             invokeRestart <- base::invokeRestart
[09:29:59.516]             length <- base::length
[09:29:59.516]             list <- base::list
[09:29:59.516]             seq.int <- base::seq.int
[09:29:59.516]             signalCondition <- base::signalCondition
[09:29:59.516]             sys.calls <- base::sys.calls
[09:29:59.516]             `[[` <- base::`[[`
[09:29:59.516]             `+` <- base::`+`
[09:29:59.516]             `<<-` <- base::`<<-`
[09:29:59.516]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:59.516]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:59.516]                   3L)]
[09:29:59.516]             }
[09:29:59.516]             function(cond) {
[09:29:59.516]                 is_error <- inherits(cond, "error")
[09:29:59.516]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:59.516]                   NULL)
[09:29:59.516]                 if (is_error) {
[09:29:59.516]                   sessionInformation <- function() {
[09:29:59.516]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:59.516]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:59.516]                       search = base::search(), system = base::Sys.info())
[09:29:59.516]                   }
[09:29:59.516]                   ...future.conditions[[length(...future.conditions) + 
[09:29:59.516]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:59.516]                     cond$call), session = sessionInformation(), 
[09:29:59.516]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:59.516]                   signalCondition(cond)
[09:29:59.516]                 }
[09:29:59.516]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:59.516]                 "immediateCondition"))) {
[09:29:59.516]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:59.516]                   ...future.conditions[[length(...future.conditions) + 
[09:29:59.516]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:59.516]                   if (TRUE && !signal) {
[09:29:59.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:59.516]                     {
[09:29:59.516]                       inherits <- base::inherits
[09:29:59.516]                       invokeRestart <- base::invokeRestart
[09:29:59.516]                       is.null <- base::is.null
[09:29:59.516]                       muffled <- FALSE
[09:29:59.516]                       if (inherits(cond, "message")) {
[09:29:59.516]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:59.516]                         if (muffled) 
[09:29:59.516]                           invokeRestart("muffleMessage")
[09:29:59.516]                       }
[09:29:59.516]                       else if (inherits(cond, "warning")) {
[09:29:59.516]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:59.516]                         if (muffled) 
[09:29:59.516]                           invokeRestart("muffleWarning")
[09:29:59.516]                       }
[09:29:59.516]                       else if (inherits(cond, "condition")) {
[09:29:59.516]                         if (!is.null(pattern)) {
[09:29:59.516]                           computeRestarts <- base::computeRestarts
[09:29:59.516]                           grepl <- base::grepl
[09:29:59.516]                           restarts <- computeRestarts(cond)
[09:29:59.516]                           for (restart in restarts) {
[09:29:59.516]                             name <- restart$name
[09:29:59.516]                             if (is.null(name)) 
[09:29:59.516]                               next
[09:29:59.516]                             if (!grepl(pattern, name)) 
[09:29:59.516]                               next
[09:29:59.516]                             invokeRestart(restart)
[09:29:59.516]                             muffled <- TRUE
[09:29:59.516]                             break
[09:29:59.516]                           }
[09:29:59.516]                         }
[09:29:59.516]                       }
[09:29:59.516]                       invisible(muffled)
[09:29:59.516]                     }
[09:29:59.516]                     muffleCondition(cond, pattern = "^muffle")
[09:29:59.516]                   }
[09:29:59.516]                 }
[09:29:59.516]                 else {
[09:29:59.516]                   if (TRUE) {
[09:29:59.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:59.516]                     {
[09:29:59.516]                       inherits <- base::inherits
[09:29:59.516]                       invokeRestart <- base::invokeRestart
[09:29:59.516]                       is.null <- base::is.null
[09:29:59.516]                       muffled <- FALSE
[09:29:59.516]                       if (inherits(cond, "message")) {
[09:29:59.516]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:59.516]                         if (muffled) 
[09:29:59.516]                           invokeRestart("muffleMessage")
[09:29:59.516]                       }
[09:29:59.516]                       else if (inherits(cond, "warning")) {
[09:29:59.516]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:59.516]                         if (muffled) 
[09:29:59.516]                           invokeRestart("muffleWarning")
[09:29:59.516]                       }
[09:29:59.516]                       else if (inherits(cond, "condition")) {
[09:29:59.516]                         if (!is.null(pattern)) {
[09:29:59.516]                           computeRestarts <- base::computeRestarts
[09:29:59.516]                           grepl <- base::grepl
[09:29:59.516]                           restarts <- computeRestarts(cond)
[09:29:59.516]                           for (restart in restarts) {
[09:29:59.516]                             name <- restart$name
[09:29:59.516]                             if (is.null(name)) 
[09:29:59.516]                               next
[09:29:59.516]                             if (!grepl(pattern, name)) 
[09:29:59.516]                               next
[09:29:59.516]                             invokeRestart(restart)
[09:29:59.516]                             muffled <- TRUE
[09:29:59.516]                             break
[09:29:59.516]                           }
[09:29:59.516]                         }
[09:29:59.516]                       }
[09:29:59.516]                       invisible(muffled)
[09:29:59.516]                     }
[09:29:59.516]                     muffleCondition(cond, pattern = "^muffle")
[09:29:59.516]                   }
[09:29:59.516]                 }
[09:29:59.516]             }
[09:29:59.516]         }))
[09:29:59.516]     }, error = function(ex) {
[09:29:59.516]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:59.516]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:59.516]                 ...future.rng), started = ...future.startTime, 
[09:29:59.516]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:59.516]             version = "1.8"), class = "FutureResult")
[09:29:59.516]     }, finally = {
[09:29:59.516]         if (!identical(...future.workdir, getwd())) 
[09:29:59.516]             setwd(...future.workdir)
[09:29:59.516]         {
[09:29:59.516]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:59.516]                 ...future.oldOptions$nwarnings <- NULL
[09:29:59.516]             }
[09:29:59.516]             base::options(...future.oldOptions)
[09:29:59.516]             if (.Platform$OS.type == "windows") {
[09:29:59.516]                 old_names <- names(...future.oldEnvVars)
[09:29:59.516]                 envs <- base::Sys.getenv()
[09:29:59.516]                 names <- names(envs)
[09:29:59.516]                 common <- intersect(names, old_names)
[09:29:59.516]                 added <- setdiff(names, old_names)
[09:29:59.516]                 removed <- setdiff(old_names, names)
[09:29:59.516]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:59.516]                   envs[common]]
[09:29:59.516]                 NAMES <- toupper(changed)
[09:29:59.516]                 args <- list()
[09:29:59.516]                 for (kk in seq_along(NAMES)) {
[09:29:59.516]                   name <- changed[[kk]]
[09:29:59.516]                   NAME <- NAMES[[kk]]
[09:29:59.516]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:59.516]                     next
[09:29:59.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:59.516]                 }
[09:29:59.516]                 NAMES <- toupper(added)
[09:29:59.516]                 for (kk in seq_along(NAMES)) {
[09:29:59.516]                   name <- added[[kk]]
[09:29:59.516]                   NAME <- NAMES[[kk]]
[09:29:59.516]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:59.516]                     next
[09:29:59.516]                   args[[name]] <- ""
[09:29:59.516]                 }
[09:29:59.516]                 NAMES <- toupper(removed)
[09:29:59.516]                 for (kk in seq_along(NAMES)) {
[09:29:59.516]                   name <- removed[[kk]]
[09:29:59.516]                   NAME <- NAMES[[kk]]
[09:29:59.516]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:59.516]                     next
[09:29:59.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:59.516]                 }
[09:29:59.516]                 if (length(args) > 0) 
[09:29:59.516]                   base::do.call(base::Sys.setenv, args = args)
[09:29:59.516]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:59.516]             }
[09:29:59.516]             else {
[09:29:59.516]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:59.516]             }
[09:29:59.516]             {
[09:29:59.516]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:59.516]                   0L) {
[09:29:59.516]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:59.516]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:59.516]                   base::options(opts)
[09:29:59.516]                 }
[09:29:59.516]                 {
[09:29:59.516]                   {
[09:29:59.516]                     NULL
[09:29:59.516]                     RNGkind("Mersenne-Twister")
[09:29:59.516]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:29:59.516]                       inherits = FALSE)
[09:29:59.516]                   }
[09:29:59.516]                   options(future.plan = NULL)
[09:29:59.516]                   if (is.na(NA_character_)) 
[09:29:59.516]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:59.516]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:59.516]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:59.516]                     .init = FALSE)
[09:29:59.516]                 }
[09:29:59.516]             }
[09:29:59.516]         }
[09:29:59.516]     })
[09:29:59.516]     if (TRUE) {
[09:29:59.516]         base::sink(type = "output", split = FALSE)
[09:29:59.516]         if (FALSE) {
[09:29:59.516]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:59.516]         }
[09:29:59.516]         else {
[09:29:59.516]             ...future.result["stdout"] <- base::list(NULL)
[09:29:59.516]         }
[09:29:59.516]         base::close(...future.stdout)
[09:29:59.516]         ...future.stdout <- NULL
[09:29:59.516]     }
[09:29:59.516]     ...future.result$conditions <- ...future.conditions
[09:29:59.516]     ...future.result$finished <- base::Sys.time()
[09:29:59.516]     ...future.result
[09:29:59.516] }
[09:29:59.518] assign_globals() ...
[09:29:59.518] List of 5
[09:29:59.518]  $ ...future.FUN            :function (x)  
[09:29:59.518]  $ future.call.arguments    : list()
[09:29:59.518]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:59.518]  $ ...future.elements_ii    :List of 2
[09:29:59.518]   ..$ : int 1
[09:29:59.518]   ..$ : int 0
[09:29:59.518]  $ ...future.seeds_ii       : NULL
[09:29:59.518]  $ ...future.globals.maxSize: NULL
[09:29:59.518]  - attr(*, "where")=List of 5
[09:29:59.518]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:59.518]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:59.518]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:59.518]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:59.518]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:59.518]  - attr(*, "resolved")= logi FALSE
[09:29:59.518]  - attr(*, "total_size")= num 4720
[09:29:59.518]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:59.518]  - attr(*, "already-done")= logi TRUE
[09:29:59.522] - reassign environment for ‘...future.FUN’
[09:29:59.523] - copied ‘...future.FUN’ to environment
[09:29:59.523] - copied ‘future.call.arguments’ to environment
[09:29:59.523] - copied ‘...future.elements_ii’ to environment
[09:29:59.523] - copied ‘...future.seeds_ii’ to environment
[09:29:59.523] - copied ‘...future.globals.maxSize’ to environment
[09:29:59.523] assign_globals() ... done
[09:29:59.523] plan(): Setting new future strategy stack:
[09:29:59.523] List of future strategies:
[09:29:59.523] 1. sequential:
[09:29:59.523]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:59.523]    - tweaked: FALSE
[09:29:59.523]    - call: NULL
[09:29:59.524] plan(): nbrOfWorkers() = 1
[09:30:00.026] plan(): Setting new future strategy stack:
[09:30:00.026] List of future strategies:
[09:30:00.026] 1. sequential:
[09:30:00.026]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:00.026]    - tweaked: FALSE
[09:30:00.026]    - call: plan(strategy)
[09:30:00.027] plan(): nbrOfWorkers() = 1
[09:30:00.027] SequentialFuture started (and completed)
[09:30:00.027] - Launch lazy future ... done
[09:30:00.027] run() for ‘SequentialFuture’ ... done
[09:30:00.028] Created future:
[09:30:00.028] SequentialFuture:
[09:30:00.028] Label: ‘future_lapply-1’
[09:30:00.028] Expression:
[09:30:00.028] {
[09:30:00.028]     do.call(function(...) {
[09:30:00.028]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:00.028]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:00.028]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:00.028]             on.exit(options(oopts), add = TRUE)
[09:30:00.028]         }
[09:30:00.028]         {
[09:30:00.028]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:00.028]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:00.028]                 ...future.FUN(...future.X_jj, ...)
[09:30:00.028]             })
[09:30:00.028]         }
[09:30:00.028]     }, args = future.call.arguments)
[09:30:00.028] }
[09:30:00.028] Lazy evaluation: FALSE
[09:30:00.028] Asynchronous evaluation: FALSE
[09:30:00.028] Local evaluation: TRUE
[09:30:00.028] Environment: R_GlobalEnv
[09:30:00.028] Capture standard output: FALSE
[09:30:00.028] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:00.028] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:00.028] Packages: <none>
[09:30:00.028] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:00.028] Resolved: TRUE
[09:30:00.028] Value: 112 bytes of class ‘list’
[09:30:00.028] Early signaling: FALSE
[09:30:00.028] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:00.028] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:00.029] Chunk #1 of 1 ... DONE
[09:30:00.029] Launching 1 futures (chunks) ... DONE
[09:30:00.029] Resolving 1 futures (chunks) ...
[09:30:00.030] resolve() on list ...
[09:30:00.030]  recursive: 0
[09:30:00.030]  length: 1
[09:30:00.030] 
[09:30:00.030] resolved() for ‘SequentialFuture’ ...
[09:30:00.030] - state: ‘finished’
[09:30:00.030] - run: TRUE
[09:30:00.030] - result: ‘FutureResult’
[09:30:00.030] resolved() for ‘SequentialFuture’ ... done
[09:30:00.030] Future #1
[09:30:00.031] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:30:00.031] - nx: 1
[09:30:00.031] - relay: TRUE
[09:30:00.031] - stdout: TRUE
[09:30:00.031] - signal: TRUE
[09:30:00.031] - resignal: FALSE
[09:30:00.031] - force: TRUE
[09:30:00.031] - relayed: [n=1] FALSE
[09:30:00.032] - queued futures: [n=1] FALSE
[09:30:00.032]  - until=1
[09:30:00.032]  - relaying element #1
[09:30:00.032] - relayed: [n=1] TRUE
[09:30:00.032] - queued futures: [n=1] TRUE
[09:30:00.032] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:30:00.032]  length: 0 (resolved future 1)
[09:30:00.032] Relaying remaining futures
[09:30:00.032] signalConditionsASAP(NULL, pos=0) ...
[09:30:00.033] - nx: 1
[09:30:00.033] - relay: TRUE
[09:30:00.033] - stdout: TRUE
[09:30:00.033] - signal: TRUE
[09:30:00.033] - resignal: FALSE
[09:30:00.033] - force: TRUE
[09:30:00.033] - relayed: [n=1] TRUE
[09:30:00.033] - queued futures: [n=1] TRUE
 - flush all
[09:30:00.033] - relayed: [n=1] TRUE
[09:30:00.033] - queued futures: [n=1] TRUE
[09:30:00.033] signalConditionsASAP(NULL, pos=0) ... done
[09:30:00.034] resolve() on list ... DONE
[09:30:00.034]  - Number of value chunks collected: 1
[09:30:00.034] Resolving 1 futures (chunks) ... DONE
[09:30:00.034] Reducing values from 1 chunks ...
[09:30:00.034]  - Number of values collected after concatenation: 2
[09:30:00.034]  - Number of values expected: 2
[09:30:00.034] Reducing values from 1 chunks ... DONE
[09:30:00.034] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[09:30:00.035] future_lapply() ...
[09:30:00.035] Number of chunks: 1
[09:30:00.035] getGlobalsAndPackagesXApply() ...
[09:30:00.035]  - future.globals: TRUE
[09:30:00.036] getGlobalsAndPackages() ...
[09:30:00.036] Searching for globals...
[09:30:00.037] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[09:30:00.037] Searching for globals ... DONE
[09:30:00.037] Resolving globals: FALSE
[09:30:00.038] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[09:30:00.038] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[09:30:00.038] - globals: [1] ‘FUN’
[09:30:00.038] 
[09:30:00.038] getGlobalsAndPackages() ... DONE
[09:30:00.040]  - globals found/used: [n=1] ‘FUN’
[09:30:00.040]  - needed namespaces: [n=0] 
[09:30:00.040] Finding globals ... DONE
[09:30:00.041]  - use_args: TRUE
[09:30:00.041]  - Getting '...' globals ...
[09:30:00.041] resolve() on list ...
[09:30:00.041]  recursive: 0
[09:30:00.041]  length: 1
[09:30:00.041]  elements: ‘...’
[09:30:00.041]  length: 0 (resolved future 1)
[09:30:00.041] resolve() on list ... DONE
[09:30:00.042]    - '...' content: [n=0] 
[09:30:00.042] List of 1
[09:30:00.042]  $ ...: list()
[09:30:00.042]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:00.042]  - attr(*, "where")=List of 1
[09:30:00.042]   ..$ ...:<environment: 0x55c103edc250> 
[09:30:00.042]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:00.042]  - attr(*, "resolved")= logi TRUE
[09:30:00.042]  - attr(*, "total_size")= num NA
[09:30:00.044]  - Getting '...' globals ... DONE
[09:30:00.044] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:30:00.044] List of 2
[09:30:00.044]  $ ...future.FUN:function (x)  
[09:30:00.044]  $ ...          : list()
[09:30:00.044]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:00.044]  - attr(*, "where")=List of 2
[09:30:00.044]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:00.044]   ..$ ...          :<environment: 0x55c103edc250> 
[09:30:00.044]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:00.044]  - attr(*, "resolved")= logi FALSE
[09:30:00.044]  - attr(*, "total_size")= num 4720
[09:30:00.047] Packages to be attached in all futures: [n=0] 
[09:30:00.047] getGlobalsAndPackagesXApply() ... DONE
[09:30:00.047] Number of futures (= number of chunks): 1
[09:30:00.047] Launching 1 futures (chunks) ...
[09:30:00.047] Chunk #1 of 1 ...
[09:30:00.048]  - Finding globals in 'X' for chunk #1 ...
[09:30:00.048] getGlobalsAndPackages() ...
[09:30:00.048] Searching for globals...
[09:30:00.048] 
[09:30:00.048] Searching for globals ... DONE
[09:30:00.048] - globals: [0] <none>
[09:30:00.048] getGlobalsAndPackages() ... DONE
[09:30:00.048]    + additional globals found: [n=0] 
[09:30:00.048]    + additional namespaces needed: [n=0] 
[09:30:00.049]  - Finding globals in 'X' for chunk #1 ... DONE
[09:30:00.049]  - seeds: <none>
[09:30:00.049]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:00.049] getGlobalsAndPackages() ...
[09:30:00.049] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:00.049] Resolving globals: FALSE
[09:30:00.049] Tweak future expression to call with '...' arguments ...
[09:30:00.049] {
[09:30:00.049]     do.call(function(...) {
[09:30:00.049]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:00.049]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:00.049]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:00.049]             on.exit(options(oopts), add = TRUE)
[09:30:00.049]         }
[09:30:00.049]         {
[09:30:00.049]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:00.049]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:00.049]                 ...future.FUN(...future.X_jj, ...)
[09:30:00.049]             })
[09:30:00.049]         }
[09:30:00.049]     }, args = future.call.arguments)
[09:30:00.049] }
[09:30:00.049] Tweak future expression to call with '...' arguments ... DONE
[09:30:00.050] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:00.050] 
[09:30:00.050] getGlobalsAndPackages() ... DONE
[09:30:00.050] run() for ‘Future’ ...
[09:30:00.050] - state: ‘created’
[09:30:00.050] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:30:00.051] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:00.051] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:30:00.051]   - Field: ‘label’
[09:30:00.051]   - Field: ‘local’
[09:30:00.051]   - Field: ‘owner’
[09:30:00.051]   - Field: ‘envir’
[09:30:00.051]   - Field: ‘packages’
[09:30:00.051]   - Field: ‘gc’
[09:30:00.052]   - Field: ‘conditions’
[09:30:00.052]   - Field: ‘expr’
[09:30:00.052]   - Field: ‘uuid’
[09:30:00.052]   - Field: ‘seed’
[09:30:00.052]   - Field: ‘version’
[09:30:00.052]   - Field: ‘result’
[09:30:00.052]   - Field: ‘asynchronous’
[09:30:00.052]   - Field: ‘calls’
[09:30:00.052]   - Field: ‘globals’
[09:30:00.052]   - Field: ‘stdout’
[09:30:00.052]   - Field: ‘earlySignal’
[09:30:00.053]   - Field: ‘lazy’
[09:30:00.053]   - Field: ‘state’
[09:30:00.053] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:30:00.053] - Launch lazy future ...
[09:30:00.053] Packages needed by the future expression (n = 0): <none>
[09:30:00.053] Packages needed by future strategies (n = 0): <none>
[09:30:00.053] {
[09:30:00.053]     {
[09:30:00.053]         {
[09:30:00.053]             ...future.startTime <- base::Sys.time()
[09:30:00.053]             {
[09:30:00.053]                 {
[09:30:00.053]                   {
[09:30:00.053]                     base::local({
[09:30:00.053]                       has_future <- base::requireNamespace("future", 
[09:30:00.053]                         quietly = TRUE)
[09:30:00.053]                       if (has_future) {
[09:30:00.053]                         ns <- base::getNamespace("future")
[09:30:00.053]                         version <- ns[[".package"]][["version"]]
[09:30:00.053]                         if (is.null(version)) 
[09:30:00.053]                           version <- utils::packageVersion("future")
[09:30:00.053]                       }
[09:30:00.053]                       else {
[09:30:00.053]                         version <- NULL
[09:30:00.053]                       }
[09:30:00.053]                       if (!has_future || version < "1.8.0") {
[09:30:00.053]                         info <- base::c(r_version = base::gsub("R version ", 
[09:30:00.053]                           "", base::R.version$version.string), 
[09:30:00.053]                           platform = base::sprintf("%s (%s-bit)", 
[09:30:00.053]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:00.053]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:00.053]                             "release", "version")], collapse = " "), 
[09:30:00.053]                           hostname = base::Sys.info()[["nodename"]])
[09:30:00.053]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:30:00.053]                           info)
[09:30:00.053]                         info <- base::paste(info, collapse = "; ")
[09:30:00.053]                         if (!has_future) {
[09:30:00.053]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:00.053]                             info)
[09:30:00.053]                         }
[09:30:00.053]                         else {
[09:30:00.053]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:00.053]                             info, version)
[09:30:00.053]                         }
[09:30:00.053]                         base::stop(msg)
[09:30:00.053]                       }
[09:30:00.053]                     })
[09:30:00.053]                   }
[09:30:00.053]                   ...future.strategy.old <- future::plan("list")
[09:30:00.053]                   options(future.plan = NULL)
[09:30:00.053]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:00.053]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:00.053]                 }
[09:30:00.053]                 ...future.workdir <- getwd()
[09:30:00.053]             }
[09:30:00.053]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:00.053]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:00.053]         }
[09:30:00.053]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:00.053]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:30:00.053]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:00.053]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:00.053]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:00.053]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:00.053]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:00.053]             base::names(...future.oldOptions))
[09:30:00.053]     }
[09:30:00.053]     if (FALSE) {
[09:30:00.053]     }
[09:30:00.053]     else {
[09:30:00.053]         if (TRUE) {
[09:30:00.053]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:00.053]                 open = "w")
[09:30:00.053]         }
[09:30:00.053]         else {
[09:30:00.053]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:00.053]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:00.053]         }
[09:30:00.053]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:00.053]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:00.053]             base::sink(type = "output", split = FALSE)
[09:30:00.053]             base::close(...future.stdout)
[09:30:00.053]         }, add = TRUE)
[09:30:00.053]     }
[09:30:00.053]     ...future.frame <- base::sys.nframe()
[09:30:00.053]     ...future.conditions <- base::list()
[09:30:00.053]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:00.053]     if (FALSE) {
[09:30:00.053]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:00.053]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:00.053]     }
[09:30:00.053]     ...future.result <- base::tryCatch({
[09:30:00.053]         base::withCallingHandlers({
[09:30:00.053]             ...future.value <- base::withVisible(base::local({
[09:30:00.053]                 do.call(function(...) {
[09:30:00.053]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:00.053]                   if (!identical(...future.globals.maxSize.org, 
[09:30:00.053]                     ...future.globals.maxSize)) {
[09:30:00.053]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:00.053]                     on.exit(options(oopts), add = TRUE)
[09:30:00.053]                   }
[09:30:00.053]                   {
[09:30:00.053]                     lapply(seq_along(...future.elements_ii), 
[09:30:00.053]                       FUN = function(jj) {
[09:30:00.053]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:00.053]                         ...future.FUN(...future.X_jj, ...)
[09:30:00.053]                       })
[09:30:00.053]                   }
[09:30:00.053]                 }, args = future.call.arguments)
[09:30:00.053]             }))
[09:30:00.053]             future::FutureResult(value = ...future.value$value, 
[09:30:00.053]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:00.053]                   ...future.rng), globalenv = if (FALSE) 
[09:30:00.053]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:00.053]                     ...future.globalenv.names))
[09:30:00.053]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:00.053]         }, condition = base::local({
[09:30:00.053]             c <- base::c
[09:30:00.053]             inherits <- base::inherits
[09:30:00.053]             invokeRestart <- base::invokeRestart
[09:30:00.053]             length <- base::length
[09:30:00.053]             list <- base::list
[09:30:00.053]             seq.int <- base::seq.int
[09:30:00.053]             signalCondition <- base::signalCondition
[09:30:00.053]             sys.calls <- base::sys.calls
[09:30:00.053]             `[[` <- base::`[[`
[09:30:00.053]             `+` <- base::`+`
[09:30:00.053]             `<<-` <- base::`<<-`
[09:30:00.053]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:00.053]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:00.053]                   3L)]
[09:30:00.053]             }
[09:30:00.053]             function(cond) {
[09:30:00.053]                 is_error <- inherits(cond, "error")
[09:30:00.053]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:00.053]                   NULL)
[09:30:00.053]                 if (is_error) {
[09:30:00.053]                   sessionInformation <- function() {
[09:30:00.053]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:00.053]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:00.053]                       search = base::search(), system = base::Sys.info())
[09:30:00.053]                   }
[09:30:00.053]                   ...future.conditions[[length(...future.conditions) + 
[09:30:00.053]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:00.053]                     cond$call), session = sessionInformation(), 
[09:30:00.053]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:00.053]                   signalCondition(cond)
[09:30:00.053]                 }
[09:30:00.053]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:00.053]                 "immediateCondition"))) {
[09:30:00.053]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:00.053]                   ...future.conditions[[length(...future.conditions) + 
[09:30:00.053]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:00.053]                   if (TRUE && !signal) {
[09:30:00.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:00.053]                     {
[09:30:00.053]                       inherits <- base::inherits
[09:30:00.053]                       invokeRestart <- base::invokeRestart
[09:30:00.053]                       is.null <- base::is.null
[09:30:00.053]                       muffled <- FALSE
[09:30:00.053]                       if (inherits(cond, "message")) {
[09:30:00.053]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:00.053]                         if (muffled) 
[09:30:00.053]                           invokeRestart("muffleMessage")
[09:30:00.053]                       }
[09:30:00.053]                       else if (inherits(cond, "warning")) {
[09:30:00.053]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:00.053]                         if (muffled) 
[09:30:00.053]                           invokeRestart("muffleWarning")
[09:30:00.053]                       }
[09:30:00.053]                       else if (inherits(cond, "condition")) {
[09:30:00.053]                         if (!is.null(pattern)) {
[09:30:00.053]                           computeRestarts <- base::computeRestarts
[09:30:00.053]                           grepl <- base::grepl
[09:30:00.053]                           restarts <- computeRestarts(cond)
[09:30:00.053]                           for (restart in restarts) {
[09:30:00.053]                             name <- restart$name
[09:30:00.053]                             if (is.null(name)) 
[09:30:00.053]                               next
[09:30:00.053]                             if (!grepl(pattern, name)) 
[09:30:00.053]                               next
[09:30:00.053]                             invokeRestart(restart)
[09:30:00.053]                             muffled <- TRUE
[09:30:00.053]                             break
[09:30:00.053]                           }
[09:30:00.053]                         }
[09:30:00.053]                       }
[09:30:00.053]                       invisible(muffled)
[09:30:00.053]                     }
[09:30:00.053]                     muffleCondition(cond, pattern = "^muffle")
[09:30:00.053]                   }
[09:30:00.053]                 }
[09:30:00.053]                 else {
[09:30:00.053]                   if (TRUE) {
[09:30:00.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:00.053]                     {
[09:30:00.053]                       inherits <- base::inherits
[09:30:00.053]                       invokeRestart <- base::invokeRestart
[09:30:00.053]                       is.null <- base::is.null
[09:30:00.053]                       muffled <- FALSE
[09:30:00.053]                       if (inherits(cond, "message")) {
[09:30:00.053]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:00.053]                         if (muffled) 
[09:30:00.053]                           invokeRestart("muffleMessage")
[09:30:00.053]                       }
[09:30:00.053]                       else if (inherits(cond, "warning")) {
[09:30:00.053]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:00.053]                         if (muffled) 
[09:30:00.053]                           invokeRestart("muffleWarning")
[09:30:00.053]                       }
[09:30:00.053]                       else if (inherits(cond, "condition")) {
[09:30:00.053]                         if (!is.null(pattern)) {
[09:30:00.053]                           computeRestarts <- base::computeRestarts
[09:30:00.053]                           grepl <- base::grepl
[09:30:00.053]                           restarts <- computeRestarts(cond)
[09:30:00.053]                           for (restart in restarts) {
[09:30:00.053]                             name <- restart$name
[09:30:00.053]                             if (is.null(name)) 
[09:30:00.053]                               next
[09:30:00.053]                             if (!grepl(pattern, name)) 
[09:30:00.053]                               next
[09:30:00.053]                             invokeRestart(restart)
[09:30:00.053]                             muffled <- TRUE
[09:30:00.053]                             break
[09:30:00.053]                           }
[09:30:00.053]                         }
[09:30:00.053]                       }
[09:30:00.053]                       invisible(muffled)
[09:30:00.053]                     }
[09:30:00.053]                     muffleCondition(cond, pattern = "^muffle")
[09:30:00.053]                   }
[09:30:00.053]                 }
[09:30:00.053]             }
[09:30:00.053]         }))
[09:30:00.053]     }, error = function(ex) {
[09:30:00.053]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:00.053]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:00.053]                 ...future.rng), started = ...future.startTime, 
[09:30:00.053]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:00.053]             version = "1.8"), class = "FutureResult")
[09:30:00.053]     }, finally = {
[09:30:00.053]         if (!identical(...future.workdir, getwd())) 
[09:30:00.053]             setwd(...future.workdir)
[09:30:00.053]         {
[09:30:00.053]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:00.053]                 ...future.oldOptions$nwarnings <- NULL
[09:30:00.053]             }
[09:30:00.053]             base::options(...future.oldOptions)
[09:30:00.053]             if (.Platform$OS.type == "windows") {
[09:30:00.053]                 old_names <- names(...future.oldEnvVars)
[09:30:00.053]                 envs <- base::Sys.getenv()
[09:30:00.053]                 names <- names(envs)
[09:30:00.053]                 common <- intersect(names, old_names)
[09:30:00.053]                 added <- setdiff(names, old_names)
[09:30:00.053]                 removed <- setdiff(old_names, names)
[09:30:00.053]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:00.053]                   envs[common]]
[09:30:00.053]                 NAMES <- toupper(changed)
[09:30:00.053]                 args <- list()
[09:30:00.053]                 for (kk in seq_along(NAMES)) {
[09:30:00.053]                   name <- changed[[kk]]
[09:30:00.053]                   NAME <- NAMES[[kk]]
[09:30:00.053]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:00.053]                     next
[09:30:00.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:00.053]                 }
[09:30:00.053]                 NAMES <- toupper(added)
[09:30:00.053]                 for (kk in seq_along(NAMES)) {
[09:30:00.053]                   name <- added[[kk]]
[09:30:00.053]                   NAME <- NAMES[[kk]]
[09:30:00.053]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:00.053]                     next
[09:30:00.053]                   args[[name]] <- ""
[09:30:00.053]                 }
[09:30:00.053]                 NAMES <- toupper(removed)
[09:30:00.053]                 for (kk in seq_along(NAMES)) {
[09:30:00.053]                   name <- removed[[kk]]
[09:30:00.053]                   NAME <- NAMES[[kk]]
[09:30:00.053]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:00.053]                     next
[09:30:00.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:00.053]                 }
[09:30:00.053]                 if (length(args) > 0) 
[09:30:00.053]                   base::do.call(base::Sys.setenv, args = args)
[09:30:00.053]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:00.053]             }
[09:30:00.053]             else {
[09:30:00.053]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:00.053]             }
[09:30:00.053]             {
[09:30:00.053]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:00.053]                   0L) {
[09:30:00.053]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:00.053]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:00.053]                   base::options(opts)
[09:30:00.053]                 }
[09:30:00.053]                 {
[09:30:00.053]                   {
[09:30:00.053]                     NULL
[09:30:00.053]                     RNGkind("Mersenne-Twister")
[09:30:00.053]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:30:00.053]                       inherits = FALSE)
[09:30:00.053]                   }
[09:30:00.053]                   options(future.plan = NULL)
[09:30:00.053]                   if (is.na(NA_character_)) 
[09:30:00.053]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:00.053]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:00.053]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:00.053]                     .init = FALSE)
[09:30:00.053]                 }
[09:30:00.053]             }
[09:30:00.053]         }
[09:30:00.053]     })
[09:30:00.053]     if (TRUE) {
[09:30:00.053]         base::sink(type = "output", split = FALSE)
[09:30:00.053]         if (TRUE) {
[09:30:00.053]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:00.053]         }
[09:30:00.053]         else {
[09:30:00.053]             ...future.result["stdout"] <- base::list(NULL)
[09:30:00.053]         }
[09:30:00.053]         base::close(...future.stdout)
[09:30:00.053]         ...future.stdout <- NULL
[09:30:00.053]     }
[09:30:00.053]     ...future.result$conditions <- ...future.conditions
[09:30:00.053]     ...future.result$finished <- base::Sys.time()
[09:30:00.053]     ...future.result
[09:30:00.053] }
[09:30:00.055] assign_globals() ...
[09:30:00.055] List of 5
[09:30:00.055]  $ ...future.FUN            :function (x)  
[09:30:00.055]  $ future.call.arguments    : list()
[09:30:00.055]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:00.055]  $ ...future.elements_ii    :List of 2
[09:30:00.055]   ..$ : int 1
[09:30:00.055]   ..$ : int 0
[09:30:00.055]  $ ...future.seeds_ii       : NULL
[09:30:00.055]  $ ...future.globals.maxSize: NULL
[09:30:00.055]  - attr(*, "where")=List of 5
[09:30:00.055]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:00.055]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:30:00.055]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:00.055]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:00.055]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:00.055]  - attr(*, "resolved")= logi FALSE
[09:30:00.055]  - attr(*, "total_size")= num 4720
[09:30:00.055]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:00.055]  - attr(*, "already-done")= logi TRUE
[09:30:00.060] - reassign environment for ‘...future.FUN’
[09:30:00.060] - copied ‘...future.FUN’ to environment
[09:30:00.060] - copied ‘future.call.arguments’ to environment
[09:30:00.060] - copied ‘...future.elements_ii’ to environment
[09:30:00.060] - copied ‘...future.seeds_ii’ to environment
[09:30:00.060] - copied ‘...future.globals.maxSize’ to environment
[09:30:00.060] assign_globals() ... done
[09:30:00.060] plan(): Setting new future strategy stack:
[09:30:00.061] List of future strategies:
[09:30:00.061] 1. sequential:
[09:30:00.061]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:00.061]    - tweaked: FALSE
[09:30:00.061]    - call: NULL
[09:30:00.061] plan(): nbrOfWorkers() = 1
[09:30:00.563] plan(): Setting new future strategy stack:
[09:30:00.563] List of future strategies:
[09:30:00.563] 1. sequential:
[09:30:00.563]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:00.563]    - tweaked: FALSE
[09:30:00.563]    - call: plan(strategy)
[09:30:00.563] plan(): nbrOfWorkers() = 1
[09:30:00.564] SequentialFuture started (and completed)
[09:30:00.564] - Launch lazy future ... done
[09:30:00.564] run() for ‘SequentialFuture’ ... done
[09:30:00.564] Created future:
[09:30:00.564] SequentialFuture:
[09:30:00.564] Label: ‘future_lapply-1’
[09:30:00.564] Expression:
[09:30:00.564] {
[09:30:00.564]     do.call(function(...) {
[09:30:00.564]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:00.564]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:00.564]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:00.564]             on.exit(options(oopts), add = TRUE)
[09:30:00.564]         }
[09:30:00.564]         {
[09:30:00.564]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:00.564]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:00.564]                 ...future.FUN(...future.X_jj, ...)
[09:30:00.564]             })
[09:30:00.564]         }
[09:30:00.564]     }, args = future.call.arguments)
[09:30:00.564] }
[09:30:00.564] Lazy evaluation: FALSE
[09:30:00.564] Asynchronous evaluation: FALSE
[09:30:00.564] Local evaluation: TRUE
[09:30:00.564] Environment: R_GlobalEnv
[09:30:00.564] Capture standard output: TRUE
[09:30:00.564] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:00.564] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:00.564] Packages: <none>
[09:30:00.564] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:00.564] Resolved: TRUE
[09:30:00.564] Value: 112 bytes of class ‘list’
[09:30:00.564] Early signaling: FALSE
[09:30:00.564] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:00.564] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:00.565] Chunk #1 of 1 ... DONE
[09:30:00.565] Launching 1 futures (chunks) ... DONE
[09:30:00.565] Resolving 1 futures (chunks) ...
[09:30:00.566] resolve() on list ...
[09:30:00.566]  recursive: 0
[09:30:00.566]  length: 1
[09:30:00.566] 
[09:30:00.566] resolved() for ‘SequentialFuture’ ...
[09:30:00.566] - state: ‘finished’
[09:30:00.566] - run: TRUE
[09:30:00.566] - result: ‘FutureResult’
[09:30:00.566] resolved() for ‘SequentialFuture’ ... done
[09:30:00.566] Future #1
[09:30:00.567] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:30:00.567] - nx: 1
[09:30:00.567] - relay: TRUE
[09:30:00.567] - stdout: TRUE
[09:30:00.567] - signal: TRUE
[09:30:00.567] - resignal: FALSE
[09:30:00.569] - force: TRUE
[09:30:00.569] - relayed: [n=1] FALSE
[09:30:00.569] - queued futures: [n=1] FALSE
[09:30:00.569]  - until=1
[09:30:00.569]  - relaying element #1
[09:30:00.569] - relayed: [n=1] TRUE
[09:30:00.569] - queued futures: [n=1] TRUE
[09:30:00.570] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:30:00.570]  length: 0 (resolved future 1)
[09:30:00.570] Relaying remaining futures
[09:30:00.570] signalConditionsASAP(NULL, pos=0) ...
[09:30:00.570] - nx: 1
[09:30:00.570] - relay: TRUE
[09:30:00.570] - stdout: TRUE
[09:30:00.570] - signal: TRUE
[09:30:00.570] - resignal: FALSE
[09:30:00.570] - force: TRUE
[09:30:00.570] - relayed: [n=1] TRUE
[09:30:00.570] - queued futures: [n=1] TRUE
 - flush all
[09:30:00.571] - relayed: [n=1] TRUE
[09:30:00.571] - queued futures: [n=1] TRUE
[09:30:00.571] signalConditionsASAP(NULL, pos=0) ... done
[09:30:00.571] resolve() on list ... DONE
[09:30:00.571]  - Number of value chunks collected: 1
[09:30:00.571] Resolving 1 futures (chunks) ... DONE
[09:30:00.571] Reducing values from 1 chunks ...
[09:30:00.571]  - Number of values collected after concatenation: 2
[09:30:00.571]  - Number of values expected: 2
[09:30:00.571] Reducing values from 1 chunks ... DONE
[09:30:00.572] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[09:30:00.572] future_lapply() ...
[09:30:00.573] Number of chunks: 1
[09:30:00.573] getGlobalsAndPackagesXApply() ...
[09:30:00.573]  - future.globals: TRUE
[09:30:00.573] getGlobalsAndPackages() ...
[09:30:00.573] Searching for globals...
[09:30:00.574] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[09:30:00.574] Searching for globals ... DONE
[09:30:00.574] Resolving globals: FALSE
[09:30:00.575] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[09:30:00.575] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[09:30:00.575] - globals: [1] ‘FUN’
[09:30:00.575] 
[09:30:00.576] getGlobalsAndPackages() ... DONE
[09:30:00.576]  - globals found/used: [n=1] ‘FUN’
[09:30:00.576]  - needed namespaces: [n=0] 
[09:30:00.576] Finding globals ... DONE
[09:30:00.576]  - use_args: TRUE
[09:30:00.576]  - Getting '...' globals ...
[09:30:00.576] resolve() on list ...
[09:30:00.576]  recursive: 0
[09:30:00.576]  length: 1
[09:30:00.577]  elements: ‘...’
[09:30:00.577]  length: 0 (resolved future 1)
[09:30:00.577] resolve() on list ... DONE
[09:30:00.577]    - '...' content: [n=0] 
[09:30:00.577] List of 1
[09:30:00.577]  $ ...: list()
[09:30:00.577]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:00.577]  - attr(*, "where")=List of 1
[09:30:00.577]   ..$ ...:<environment: 0x55c102131378> 
[09:30:00.577]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:00.577]  - attr(*, "resolved")= logi TRUE
[09:30:00.577]  - attr(*, "total_size")= num NA
[09:30:00.579]  - Getting '...' globals ... DONE
[09:30:00.580] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:30:00.580] List of 2
[09:30:00.580]  $ ...future.FUN:function (x)  
[09:30:00.580]  $ ...          : list()
[09:30:00.580]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:00.580]  - attr(*, "where")=List of 2
[09:30:00.580]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:00.580]   ..$ ...          :<environment: 0x55c102131378> 
[09:30:00.580]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:00.580]  - attr(*, "resolved")= logi FALSE
[09:30:00.580]  - attr(*, "total_size")= num 4720
[09:30:00.582] Packages to be attached in all futures: [n=0] 
[09:30:00.582] getGlobalsAndPackagesXApply() ... DONE
[09:30:00.583] Number of futures (= number of chunks): 1
[09:30:00.583] Launching 1 futures (chunks) ...
[09:30:00.583] Chunk #1 of 1 ...
[09:30:00.583]  - Finding globals in 'X' for chunk #1 ...
[09:30:00.583] getGlobalsAndPackages() ...
[09:30:00.583] Searching for globals...
[09:30:00.583] 
[09:30:00.583] Searching for globals ... DONE
[09:30:00.584] - globals: [0] <none>
[09:30:00.584] getGlobalsAndPackages() ... DONE
[09:30:00.584]    + additional globals found: [n=0] 
[09:30:00.584]    + additional namespaces needed: [n=0] 
[09:30:00.584]  - Finding globals in 'X' for chunk #1 ... DONE
[09:30:00.584]  - seeds: <none>
[09:30:00.584]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:00.584] getGlobalsAndPackages() ...
[09:30:00.584] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:00.584] Resolving globals: FALSE
[09:30:00.584] Tweak future expression to call with '...' arguments ...
[09:30:00.585] {
[09:30:00.585]     do.call(function(...) {
[09:30:00.585]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:00.585]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:00.585]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:00.585]             on.exit(options(oopts), add = TRUE)
[09:30:00.585]         }
[09:30:00.585]         {
[09:30:00.585]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:00.585]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:00.585]                 ...future.FUN(...future.X_jj, ...)
[09:30:00.585]             })
[09:30:00.585]         }
[09:30:00.585]     }, args = future.call.arguments)
[09:30:00.585] }
[09:30:00.585] Tweak future expression to call with '...' arguments ... DONE
[09:30:00.585] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:00.585] 
[09:30:00.585] getGlobalsAndPackages() ... DONE
[09:30:00.586] run() for ‘Future’ ...
[09:30:00.586] - state: ‘created’
[09:30:00.586] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:30:00.586] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:00.586] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:30:00.586]   - Field: ‘label’
[09:30:00.586]   - Field: ‘local’
[09:30:00.586]   - Field: ‘owner’
[09:30:00.587]   - Field: ‘envir’
[09:30:00.587]   - Field: ‘packages’
[09:30:00.587]   - Field: ‘gc’
[09:30:00.587]   - Field: ‘conditions’
[09:30:00.587]   - Field: ‘expr’
[09:30:00.587]   - Field: ‘uuid’
[09:30:00.587]   - Field: ‘seed’
[09:30:00.587]   - Field: ‘version’
[09:30:00.587]   - Field: ‘result’
[09:30:00.587]   - Field: ‘asynchronous’
[09:30:00.587]   - Field: ‘calls’
[09:30:00.588]   - Field: ‘globals’
[09:30:00.588]   - Field: ‘stdout’
[09:30:00.588]   - Field: ‘earlySignal’
[09:30:00.588]   - Field: ‘lazy’
[09:30:00.588]   - Field: ‘state’
[09:30:00.588] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:30:00.588] - Launch lazy future ...
[09:30:00.588] Packages needed by the future expression (n = 0): <none>
[09:30:00.588] Packages needed by future strategies (n = 0): <none>
[09:30:00.589] {
[09:30:00.589]     {
[09:30:00.589]         {
[09:30:00.589]             ...future.startTime <- base::Sys.time()
[09:30:00.589]             {
[09:30:00.589]                 {
[09:30:00.589]                   {
[09:30:00.589]                     base::local({
[09:30:00.589]                       has_future <- base::requireNamespace("future", 
[09:30:00.589]                         quietly = TRUE)
[09:30:00.589]                       if (has_future) {
[09:30:00.589]                         ns <- base::getNamespace("future")
[09:30:00.589]                         version <- ns[[".package"]][["version"]]
[09:30:00.589]                         if (is.null(version)) 
[09:30:00.589]                           version <- utils::packageVersion("future")
[09:30:00.589]                       }
[09:30:00.589]                       else {
[09:30:00.589]                         version <- NULL
[09:30:00.589]                       }
[09:30:00.589]                       if (!has_future || version < "1.8.0") {
[09:30:00.589]                         info <- base::c(r_version = base::gsub("R version ", 
[09:30:00.589]                           "", base::R.version$version.string), 
[09:30:00.589]                           platform = base::sprintf("%s (%s-bit)", 
[09:30:00.589]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:00.589]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:00.589]                             "release", "version")], collapse = " "), 
[09:30:00.589]                           hostname = base::Sys.info()[["nodename"]])
[09:30:00.589]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:30:00.589]                           info)
[09:30:00.589]                         info <- base::paste(info, collapse = "; ")
[09:30:00.589]                         if (!has_future) {
[09:30:00.589]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:00.589]                             info)
[09:30:00.589]                         }
[09:30:00.589]                         else {
[09:30:00.589]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:00.589]                             info, version)
[09:30:00.589]                         }
[09:30:00.589]                         base::stop(msg)
[09:30:00.589]                       }
[09:30:00.589]                     })
[09:30:00.589]                   }
[09:30:00.589]                   ...future.strategy.old <- future::plan("list")
[09:30:00.589]                   options(future.plan = NULL)
[09:30:00.589]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:00.589]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:00.589]                 }
[09:30:00.589]                 ...future.workdir <- getwd()
[09:30:00.589]             }
[09:30:00.589]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:00.589]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:00.589]         }
[09:30:00.589]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:00.589]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:30:00.589]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:00.589]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:00.589]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:00.589]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:00.589]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:00.589]             base::names(...future.oldOptions))
[09:30:00.589]     }
[09:30:00.589]     if (TRUE) {
[09:30:00.589]     }
[09:30:00.589]     else {
[09:30:00.589]         if (NA) {
[09:30:00.589]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:00.589]                 open = "w")
[09:30:00.589]         }
[09:30:00.589]         else {
[09:30:00.589]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:00.589]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:00.589]         }
[09:30:00.589]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:00.589]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:00.589]             base::sink(type = "output", split = FALSE)
[09:30:00.589]             base::close(...future.stdout)
[09:30:00.589]         }, add = TRUE)
[09:30:00.589]     }
[09:30:00.589]     ...future.frame <- base::sys.nframe()
[09:30:00.589]     ...future.conditions <- base::list()
[09:30:00.589]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:00.589]     if (FALSE) {
[09:30:00.589]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:00.589]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:00.589]     }
[09:30:00.589]     ...future.result <- base::tryCatch({
[09:30:00.589]         base::withCallingHandlers({
[09:30:00.589]             ...future.value <- base::withVisible(base::local({
[09:30:00.589]                 do.call(function(...) {
[09:30:00.589]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:00.589]                   if (!identical(...future.globals.maxSize.org, 
[09:30:00.589]                     ...future.globals.maxSize)) {
[09:30:00.589]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:00.589]                     on.exit(options(oopts), add = TRUE)
[09:30:00.589]                   }
[09:30:00.589]                   {
[09:30:00.589]                     lapply(seq_along(...future.elements_ii), 
[09:30:00.589]                       FUN = function(jj) {
[09:30:00.589]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:00.589]                         ...future.FUN(...future.X_jj, ...)
[09:30:00.589]                       })
[09:30:00.589]                   }
[09:30:00.589]                 }, args = future.call.arguments)
[09:30:00.589]             }))
[09:30:00.589]             future::FutureResult(value = ...future.value$value, 
[09:30:00.589]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:00.589]                   ...future.rng), globalenv = if (FALSE) 
[09:30:00.589]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:00.589]                     ...future.globalenv.names))
[09:30:00.589]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:00.589]         }, condition = base::local({
[09:30:00.589]             c <- base::c
[09:30:00.589]             inherits <- base::inherits
[09:30:00.589]             invokeRestart <- base::invokeRestart
[09:30:00.589]             length <- base::length
[09:30:00.589]             list <- base::list
[09:30:00.589]             seq.int <- base::seq.int
[09:30:00.589]             signalCondition <- base::signalCondition
[09:30:00.589]             sys.calls <- base::sys.calls
[09:30:00.589]             `[[` <- base::`[[`
[09:30:00.589]             `+` <- base::`+`
[09:30:00.589]             `<<-` <- base::`<<-`
[09:30:00.589]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:00.589]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:00.589]                   3L)]
[09:30:00.589]             }
[09:30:00.589]             function(cond) {
[09:30:00.589]                 is_error <- inherits(cond, "error")
[09:30:00.589]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:00.589]                   NULL)
[09:30:00.589]                 if (is_error) {
[09:30:00.589]                   sessionInformation <- function() {
[09:30:00.589]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:00.589]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:00.589]                       search = base::search(), system = base::Sys.info())
[09:30:00.589]                   }
[09:30:00.589]                   ...future.conditions[[length(...future.conditions) + 
[09:30:00.589]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:00.589]                     cond$call), session = sessionInformation(), 
[09:30:00.589]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:00.589]                   signalCondition(cond)
[09:30:00.589]                 }
[09:30:00.589]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:00.589]                 "immediateCondition"))) {
[09:30:00.589]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:00.589]                   ...future.conditions[[length(...future.conditions) + 
[09:30:00.589]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:00.589]                   if (TRUE && !signal) {
[09:30:00.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:00.589]                     {
[09:30:00.589]                       inherits <- base::inherits
[09:30:00.589]                       invokeRestart <- base::invokeRestart
[09:30:00.589]                       is.null <- base::is.null
[09:30:00.589]                       muffled <- FALSE
[09:30:00.589]                       if (inherits(cond, "message")) {
[09:30:00.589]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:00.589]                         if (muffled) 
[09:30:00.589]                           invokeRestart("muffleMessage")
[09:30:00.589]                       }
[09:30:00.589]                       else if (inherits(cond, "warning")) {
[09:30:00.589]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:00.589]                         if (muffled) 
[09:30:00.589]                           invokeRestart("muffleWarning")
[09:30:00.589]                       }
[09:30:00.589]                       else if (inherits(cond, "condition")) {
[09:30:00.589]                         if (!is.null(pattern)) {
[09:30:00.589]                           computeRestarts <- base::computeRestarts
[09:30:00.589]                           grepl <- base::grepl
[09:30:00.589]                           restarts <- computeRestarts(cond)
[09:30:00.589]                           for (restart in restarts) {
[09:30:00.589]                             name <- restart$name
[09:30:00.589]                             if (is.null(name)) 
[09:30:00.589]                               next
[09:30:00.589]                             if (!grepl(pattern, name)) 
[09:30:00.589]                               next
[09:30:00.589]                             invokeRestart(restart)
[09:30:00.589]                             muffled <- TRUE
[09:30:00.589]                             break
[09:30:00.589]                           }
[09:30:00.589]                         }
[09:30:00.589]                       }
[09:30:00.589]                       invisible(muffled)
[09:30:00.589]                     }
[09:30:00.589]                     muffleCondition(cond, pattern = "^muffle")
[09:30:00.589]                   }
[09:30:00.589]                 }
[09:30:00.589]                 else {
[09:30:00.589]                   if (TRUE) {
[09:30:00.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:00.589]                     {
[09:30:00.589]                       inherits <- base::inherits
[09:30:00.589]                       invokeRestart <- base::invokeRestart
[09:30:00.589]                       is.null <- base::is.null
[09:30:00.589]                       muffled <- FALSE
[09:30:00.589]                       if (inherits(cond, "message")) {
[09:30:00.589]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:00.589]                         if (muffled) 
[09:30:00.589]                           invokeRestart("muffleMessage")
[09:30:00.589]                       }
[09:30:00.589]                       else if (inherits(cond, "warning")) {
[09:30:00.589]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:00.589]                         if (muffled) 
[09:30:00.589]                           invokeRestart("muffleWarning")
[09:30:00.589]                       }
[09:30:00.589]                       else if (inherits(cond, "condition")) {
[09:30:00.589]                         if (!is.null(pattern)) {
[09:30:00.589]                           computeRestarts <- base::computeRestarts
[09:30:00.589]                           grepl <- base::grepl
[09:30:00.589]                           restarts <- computeRestarts(cond)
[09:30:00.589]                           for (restart in restarts) {
[09:30:00.589]                             name <- restart$name
[09:30:00.589]                             if (is.null(name)) 
[09:30:00.589]                               next
[09:30:00.589]                             if (!grepl(pattern, name)) 
[09:30:00.589]                               next
[09:30:00.589]                             invokeRestart(restart)
[09:30:00.589]                             muffled <- TRUE
[09:30:00.589]                             break
[09:30:00.589]                           }
[09:30:00.589]                         }
[09:30:00.589]                       }
[09:30:00.589]                       invisible(muffled)
[09:30:00.589]                     }
[09:30:00.589]                     muffleCondition(cond, pattern = "^muffle")
[09:30:00.589]                   }
[09:30:00.589]                 }
[09:30:00.589]             }
[09:30:00.589]         }))
[09:30:00.589]     }, error = function(ex) {
[09:30:00.589]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:00.589]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:00.589]                 ...future.rng), started = ...future.startTime, 
[09:30:00.589]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:00.589]             version = "1.8"), class = "FutureResult")
[09:30:00.589]     }, finally = {
[09:30:00.589]         if (!identical(...future.workdir, getwd())) 
[09:30:00.589]             setwd(...future.workdir)
[09:30:00.589]         {
[09:30:00.589]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:00.589]                 ...future.oldOptions$nwarnings <- NULL
[09:30:00.589]             }
[09:30:00.589]             base::options(...future.oldOptions)
[09:30:00.589]             if (.Platform$OS.type == "windows") {
[09:30:00.589]                 old_names <- names(...future.oldEnvVars)
[09:30:00.589]                 envs <- base::Sys.getenv()
[09:30:00.589]                 names <- names(envs)
[09:30:00.589]                 common <- intersect(names, old_names)
[09:30:00.589]                 added <- setdiff(names, old_names)
[09:30:00.589]                 removed <- setdiff(old_names, names)
[09:30:00.589]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:00.589]                   envs[common]]
[09:30:00.589]                 NAMES <- toupper(changed)
[09:30:00.589]                 args <- list()
[09:30:00.589]                 for (kk in seq_along(NAMES)) {
[09:30:00.589]                   name <- changed[[kk]]
[09:30:00.589]                   NAME <- NAMES[[kk]]
[09:30:00.589]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:00.589]                     next
[09:30:00.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:00.589]                 }
[09:30:00.589]                 NAMES <- toupper(added)
[09:30:00.589]                 for (kk in seq_along(NAMES)) {
[09:30:00.589]                   name <- added[[kk]]
[09:30:00.589]                   NAME <- NAMES[[kk]]
[09:30:00.589]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:00.589]                     next
[09:30:00.589]                   args[[name]] <- ""
[09:30:00.589]                 }
[09:30:00.589]                 NAMES <- toupper(removed)
[09:30:00.589]                 for (kk in seq_along(NAMES)) {
[09:30:00.589]                   name <- removed[[kk]]
[09:30:00.589]                   NAME <- NAMES[[kk]]
[09:30:00.589]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:00.589]                     next
[09:30:00.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:00.589]                 }
[09:30:00.589]                 if (length(args) > 0) 
[09:30:00.589]                   base::do.call(base::Sys.setenv, args = args)
[09:30:00.589]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:00.589]             }
[09:30:00.589]             else {
[09:30:00.589]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:00.589]             }
[09:30:00.589]             {
[09:30:00.589]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:00.589]                   0L) {
[09:30:00.589]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:00.589]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:00.589]                   base::options(opts)
[09:30:00.589]                 }
[09:30:00.589]                 {
[09:30:00.589]                   {
[09:30:00.589]                     NULL
[09:30:00.589]                     RNGkind("Mersenne-Twister")
[09:30:00.589]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:30:00.589]                       inherits = FALSE)
[09:30:00.589]                   }
[09:30:00.589]                   options(future.plan = NULL)
[09:30:00.589]                   if (is.na(NA_character_)) 
[09:30:00.589]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:00.589]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:00.589]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:00.589]                     .init = FALSE)
[09:30:00.589]                 }
[09:30:00.589]             }
[09:30:00.589]         }
[09:30:00.589]     })
[09:30:00.589]     if (FALSE) {
[09:30:00.589]         base::sink(type = "output", split = FALSE)
[09:30:00.589]         if (NA) {
[09:30:00.589]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:00.589]         }
[09:30:00.589]         else {
[09:30:00.589]             ...future.result["stdout"] <- base::list(NULL)
[09:30:00.589]         }
[09:30:00.589]         base::close(...future.stdout)
[09:30:00.589]         ...future.stdout <- NULL
[09:30:00.589]     }
[09:30:00.589]     ...future.result$conditions <- ...future.conditions
[09:30:00.589]     ...future.result$finished <- base::Sys.time()
[09:30:00.589]     ...future.result
[09:30:00.589] }
[09:30:00.590] assign_globals() ...
[09:30:00.591] List of 5
[09:30:00.591]  $ ...future.FUN            :function (x)  
[09:30:00.591]  $ future.call.arguments    : list()
[09:30:00.591]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:00.591]  $ ...future.elements_ii    :List of 2
[09:30:00.591]   ..$ : int 1
[09:30:00.591]   ..$ : int 0
[09:30:00.591]  $ ...future.seeds_ii       : NULL
[09:30:00.591]  $ ...future.globals.maxSize: NULL
[09:30:00.591]  - attr(*, "where")=List of 5
[09:30:00.591]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:00.591]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:30:00.591]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:00.591]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:00.591]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:00.591]  - attr(*, "resolved")= logi FALSE
[09:30:00.591]  - attr(*, "total_size")= num 4720
[09:30:00.591]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:00.591]  - attr(*, "already-done")= logi TRUE
[09:30:00.596] - reassign environment for ‘...future.FUN’
[09:30:00.596] - copied ‘...future.FUN’ to environment
[09:30:00.597] - copied ‘future.call.arguments’ to environment
[09:30:00.597] - copied ‘...future.elements_ii’ to environment
[09:30:00.597] - copied ‘...future.seeds_ii’ to environment
[09:30:00.597] - copied ‘...future.globals.maxSize’ to environment
[09:30:00.597] assign_globals() ... done
[09:30:00.597] plan(): Setting new future strategy stack:
[09:30:00.597] List of future strategies:
[09:30:00.597] 1. sequential:
[09:30:00.597]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:00.597]    - tweaked: FALSE
[09:30:00.597]    - call: NULL
[09:30:00.598] plan(): nbrOfWorkers() = 1
[09:30:01.099] plan(): Setting new future strategy stack:
[09:30:01.099] List of future strategies:
[09:30:01.099] 1. sequential:
[09:30:01.099]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:01.099]    - tweaked: FALSE
[09:30:01.099]    - call: plan(strategy)
[09:30:01.100] plan(): nbrOfWorkers() = 1
[09:30:01.100] SequentialFuture started (and completed)
[09:30:01.100] - Launch lazy future ... done
[09:30:01.100] run() for ‘SequentialFuture’ ... done
[09:30:01.101] Created future:
[09:30:01.101] SequentialFuture:
[09:30:01.101] Label: ‘future_lapply-1’
[09:30:01.101] Expression:
[09:30:01.101] {
[09:30:01.101]     do.call(function(...) {
[09:30:01.101]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:01.101]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:01.101]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:01.101]             on.exit(options(oopts), add = TRUE)
[09:30:01.101]         }
[09:30:01.101]         {
[09:30:01.101]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:01.101]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:01.101]                 ...future.FUN(...future.X_jj, ...)
[09:30:01.101]             })
[09:30:01.101]         }
[09:30:01.101]     }, args = future.call.arguments)
[09:30:01.101] }
[09:30:01.101] Lazy evaluation: FALSE
[09:30:01.101] Asynchronous evaluation: FALSE
[09:30:01.101] Local evaluation: TRUE
[09:30:01.101] Environment: R_GlobalEnv
[09:30:01.101] Capture standard output: NA
[09:30:01.101] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:01.101] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:01.101] Packages: <none>
[09:30:01.101] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:01.101] Resolved: TRUE
[09:30:01.101] Value: 112 bytes of class ‘list’
[09:30:01.101] Early signaling: FALSE
[09:30:01.101] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:01.101] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:01.102] Chunk #1 of 1 ... DONE
[09:30:01.102] Launching 1 futures (chunks) ... DONE
[09:30:01.102] Resolving 1 futures (chunks) ...
[09:30:01.102] resolve() on list ...
[09:30:01.102]  recursive: 0
[09:30:01.102]  length: 1
[09:30:01.102] 
[09:30:01.102] resolved() for ‘SequentialFuture’ ...
[09:30:01.102] - state: ‘finished’
[09:30:01.103] - run: TRUE
[09:30:01.103] - result: ‘FutureResult’
[09:30:01.103] resolved() for ‘SequentialFuture’ ... done
[09:30:01.103] Future #1
[09:30:01.103] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:30:01.103] - nx: 1
[09:30:01.103] - relay: TRUE
[09:30:01.103] - stdout: TRUE
[09:30:01.103] - signal: TRUE
[09:30:01.103] - resignal: FALSE
[09:30:01.103] - force: TRUE
[09:30:01.104] - relayed: [n=1] FALSE
[09:30:01.104] - queued futures: [n=1] FALSE
[09:30:01.104]  - until=1
[09:30:01.104]  - relaying element #1
[09:30:01.104] - relayed: [n=1] TRUE
[09:30:01.104] - queued futures: [n=1] TRUE
[09:30:01.104] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:30:01.104]  length: 0 (resolved future 1)
[09:30:01.104] Relaying remaining futures
[09:30:01.105] signalConditionsASAP(NULL, pos=0) ...
[09:30:01.105] - nx: 1
[09:30:01.105] - relay: TRUE
[09:30:01.105] - stdout: TRUE
[09:30:01.105] - signal: TRUE
[09:30:01.105] - resignal: FALSE
[09:30:01.105] - force: TRUE
[09:30:01.105] - relayed: [n=1] TRUE
[09:30:01.105] - queued futures: [n=1] TRUE
 - flush all
[09:30:01.105] - relayed: [n=1] TRUE
[09:30:01.105] - queued futures: [n=1] TRUE
[09:30:01.105] signalConditionsASAP(NULL, pos=0) ... done
[09:30:01.106] resolve() on list ... DONE
[09:30:01.106]  - Number of value chunks collected: 1
[09:30:01.106] Resolving 1 futures (chunks) ... DONE
[09:30:01.106] Reducing values from 1 chunks ...
[09:30:01.106]  - Number of values collected after concatenation: 2
[09:30:01.106]  - Number of values expected: 2
[09:30:01.106] Reducing values from 1 chunks ... DONE
[09:30:01.106] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[09:30:01.107] future_mapply() ...
[09:30:01.107] Number of chunks: 1
[09:30:01.107] getGlobalsAndPackagesXApply() ...
[09:30:01.107]  - future.globals: TRUE
[09:30:01.107] getGlobalsAndPackages() ...
[09:30:01.107] Searching for globals...
[09:30:01.109] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[09:30:01.109] Searching for globals ... DONE
[09:30:01.109] Resolving globals: FALSE
[09:30:01.109] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[09:30:01.110] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[09:30:01.110] - globals: [1] ‘FUN’
[09:30:01.110] 
[09:30:01.110] getGlobalsAndPackages() ... DONE
[09:30:01.110]  - globals found/used: [n=1] ‘FUN’
[09:30:01.110]  - needed namespaces: [n=0] 
[09:30:01.110] Finding globals ... DONE
[09:30:01.111] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:30:01.111] List of 2
[09:30:01.111]  $ ...future.FUN:function (x, y)  
[09:30:01.111]  $ MoreArgs     : NULL
[09:30:01.111]  - attr(*, "where")=List of 2
[09:30:01.111]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:01.111]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:30:01.111]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:01.111]  - attr(*, "resolved")= logi FALSE
[09:30:01.111]  - attr(*, "total_size")= num NA
[09:30:01.113] Packages to be attached in all futures: [n=0] 
[09:30:01.113] getGlobalsAndPackagesXApply() ... DONE
[09:30:01.113] Number of futures (= number of chunks): 1
[09:30:01.114] Launching 1 futures (chunks) ...
[09:30:01.114] Chunk #1 of 1 ...
[09:30:01.114]  - Finding globals in '...' for chunk #1 ...
[09:30:01.114] getGlobalsAndPackages() ...
[09:30:01.114] Searching for globals...
[09:30:01.114] 
[09:30:01.114] Searching for globals ... DONE
[09:30:01.114] - globals: [0] <none>
[09:30:01.115] getGlobalsAndPackages() ... DONE
[09:30:01.115]    + additional globals found: [n=0] 
[09:30:01.115]    + additional namespaces needed: [n=0] 
[09:30:01.115]  - Finding globals in '...' for chunk #1 ... DONE
[09:30:01.115]  - seeds: <none>
[09:30:01.115]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:01.115] getGlobalsAndPackages() ...
[09:30:01.115] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:01.115] Resolving globals: FALSE
[09:30:01.116] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[09:30:01.116] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:30:01.116] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:01.116] 
[09:30:01.117] getGlobalsAndPackages() ... DONE
[09:30:01.117] run() for ‘Future’ ...
[09:30:01.117] - state: ‘created’
[09:30:01.117] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:30:01.117] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:01.117] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:30:01.118]   - Field: ‘label’
[09:30:01.118]   - Field: ‘local’
[09:30:01.118]   - Field: ‘owner’
[09:30:01.118]   - Field: ‘envir’
[09:30:01.118]   - Field: ‘packages’
[09:30:01.118]   - Field: ‘gc’
[09:30:01.118]   - Field: ‘conditions’
[09:30:01.118]   - Field: ‘expr’
[09:30:01.118]   - Field: ‘uuid’
[09:30:01.118]   - Field: ‘seed’
[09:30:01.119]   - Field: ‘version’
[09:30:01.119]   - Field: ‘result’
[09:30:01.119]   - Field: ‘asynchronous’
[09:30:01.119]   - Field: ‘calls’
[09:30:01.119]   - Field: ‘globals’
[09:30:01.119]   - Field: ‘stdout’
[09:30:01.119]   - Field: ‘earlySignal’
[09:30:01.119]   - Field: ‘lazy’
[09:30:01.119]   - Field: ‘state’
[09:30:01.119] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:30:01.119] - Launch lazy future ...
[09:30:01.120] Packages needed by the future expression (n = 0): <none>
[09:30:01.120] Packages needed by future strategies (n = 0): <none>
[09:30:01.120] {
[09:30:01.120]     {
[09:30:01.120]         {
[09:30:01.120]             ...future.startTime <- base::Sys.time()
[09:30:01.120]             {
[09:30:01.120]                 {
[09:30:01.120]                   {
[09:30:01.120]                     base::local({
[09:30:01.120]                       has_future <- base::requireNamespace("future", 
[09:30:01.120]                         quietly = TRUE)
[09:30:01.120]                       if (has_future) {
[09:30:01.120]                         ns <- base::getNamespace("future")
[09:30:01.120]                         version <- ns[[".package"]][["version"]]
[09:30:01.120]                         if (is.null(version)) 
[09:30:01.120]                           version <- utils::packageVersion("future")
[09:30:01.120]                       }
[09:30:01.120]                       else {
[09:30:01.120]                         version <- NULL
[09:30:01.120]                       }
[09:30:01.120]                       if (!has_future || version < "1.8.0") {
[09:30:01.120]                         info <- base::c(r_version = base::gsub("R version ", 
[09:30:01.120]                           "", base::R.version$version.string), 
[09:30:01.120]                           platform = base::sprintf("%s (%s-bit)", 
[09:30:01.120]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:01.120]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:01.120]                             "release", "version")], collapse = " "), 
[09:30:01.120]                           hostname = base::Sys.info()[["nodename"]])
[09:30:01.120]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:30:01.120]                           info)
[09:30:01.120]                         info <- base::paste(info, collapse = "; ")
[09:30:01.120]                         if (!has_future) {
[09:30:01.120]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:01.120]                             info)
[09:30:01.120]                         }
[09:30:01.120]                         else {
[09:30:01.120]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:01.120]                             info, version)
[09:30:01.120]                         }
[09:30:01.120]                         base::stop(msg)
[09:30:01.120]                       }
[09:30:01.120]                     })
[09:30:01.120]                   }
[09:30:01.120]                   ...future.strategy.old <- future::plan("list")
[09:30:01.120]                   options(future.plan = NULL)
[09:30:01.120]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:01.120]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:01.120]                 }
[09:30:01.120]                 ...future.workdir <- getwd()
[09:30:01.120]             }
[09:30:01.120]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:01.120]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:01.120]         }
[09:30:01.120]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:01.120]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:30:01.120]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:01.120]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:01.120]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:01.120]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:01.120]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:01.120]             base::names(...future.oldOptions))
[09:30:01.120]     }
[09:30:01.120]     if (FALSE) {
[09:30:01.120]     }
[09:30:01.120]     else {
[09:30:01.120]         if (FALSE) {
[09:30:01.120]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:01.120]                 open = "w")
[09:30:01.120]         }
[09:30:01.120]         else {
[09:30:01.120]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:01.120]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:01.120]         }
[09:30:01.120]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:01.120]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:01.120]             base::sink(type = "output", split = FALSE)
[09:30:01.120]             base::close(...future.stdout)
[09:30:01.120]         }, add = TRUE)
[09:30:01.120]     }
[09:30:01.120]     ...future.frame <- base::sys.nframe()
[09:30:01.120]     ...future.conditions <- base::list()
[09:30:01.120]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:01.120]     if (FALSE) {
[09:30:01.120]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:01.120]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:01.120]     }
[09:30:01.120]     ...future.result <- base::tryCatch({
[09:30:01.120]         base::withCallingHandlers({
[09:30:01.120]             ...future.value <- base::withVisible(base::local({
[09:30:01.120]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:01.120]                 if (!identical(...future.globals.maxSize.org, 
[09:30:01.120]                   ...future.globals.maxSize)) {
[09:30:01.120]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:01.120]                   on.exit(options(oopts), add = TRUE)
[09:30:01.120]                 }
[09:30:01.120]                 {
[09:30:01.120]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:01.120]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:30:01.120]                     USE.NAMES = FALSE)
[09:30:01.120]                   do.call(mapply, args = args)
[09:30:01.120]                 }
[09:30:01.120]             }))
[09:30:01.120]             future::FutureResult(value = ...future.value$value, 
[09:30:01.120]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:01.120]                   ...future.rng), globalenv = if (FALSE) 
[09:30:01.120]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:01.120]                     ...future.globalenv.names))
[09:30:01.120]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:01.120]         }, condition = base::local({
[09:30:01.120]             c <- base::c
[09:30:01.120]             inherits <- base::inherits
[09:30:01.120]             invokeRestart <- base::invokeRestart
[09:30:01.120]             length <- base::length
[09:30:01.120]             list <- base::list
[09:30:01.120]             seq.int <- base::seq.int
[09:30:01.120]             signalCondition <- base::signalCondition
[09:30:01.120]             sys.calls <- base::sys.calls
[09:30:01.120]             `[[` <- base::`[[`
[09:30:01.120]             `+` <- base::`+`
[09:30:01.120]             `<<-` <- base::`<<-`
[09:30:01.120]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:01.120]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:01.120]                   3L)]
[09:30:01.120]             }
[09:30:01.120]             function(cond) {
[09:30:01.120]                 is_error <- inherits(cond, "error")
[09:30:01.120]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:01.120]                   NULL)
[09:30:01.120]                 if (is_error) {
[09:30:01.120]                   sessionInformation <- function() {
[09:30:01.120]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:01.120]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:01.120]                       search = base::search(), system = base::Sys.info())
[09:30:01.120]                   }
[09:30:01.120]                   ...future.conditions[[length(...future.conditions) + 
[09:30:01.120]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:01.120]                     cond$call), session = sessionInformation(), 
[09:30:01.120]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:01.120]                   signalCondition(cond)
[09:30:01.120]                 }
[09:30:01.120]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:01.120]                 "immediateCondition"))) {
[09:30:01.120]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:01.120]                   ...future.conditions[[length(...future.conditions) + 
[09:30:01.120]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:01.120]                   if (TRUE && !signal) {
[09:30:01.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:01.120]                     {
[09:30:01.120]                       inherits <- base::inherits
[09:30:01.120]                       invokeRestart <- base::invokeRestart
[09:30:01.120]                       is.null <- base::is.null
[09:30:01.120]                       muffled <- FALSE
[09:30:01.120]                       if (inherits(cond, "message")) {
[09:30:01.120]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:01.120]                         if (muffled) 
[09:30:01.120]                           invokeRestart("muffleMessage")
[09:30:01.120]                       }
[09:30:01.120]                       else if (inherits(cond, "warning")) {
[09:30:01.120]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:01.120]                         if (muffled) 
[09:30:01.120]                           invokeRestart("muffleWarning")
[09:30:01.120]                       }
[09:30:01.120]                       else if (inherits(cond, "condition")) {
[09:30:01.120]                         if (!is.null(pattern)) {
[09:30:01.120]                           computeRestarts <- base::computeRestarts
[09:30:01.120]                           grepl <- base::grepl
[09:30:01.120]                           restarts <- computeRestarts(cond)
[09:30:01.120]                           for (restart in restarts) {
[09:30:01.120]                             name <- restart$name
[09:30:01.120]                             if (is.null(name)) 
[09:30:01.120]                               next
[09:30:01.120]                             if (!grepl(pattern, name)) 
[09:30:01.120]                               next
[09:30:01.120]                             invokeRestart(restart)
[09:30:01.120]                             muffled <- TRUE
[09:30:01.120]                             break
[09:30:01.120]                           }
[09:30:01.120]                         }
[09:30:01.120]                       }
[09:30:01.120]                       invisible(muffled)
[09:30:01.120]                     }
[09:30:01.120]                     muffleCondition(cond, pattern = "^muffle")
[09:30:01.120]                   }
[09:30:01.120]                 }
[09:30:01.120]                 else {
[09:30:01.120]                   if (TRUE) {
[09:30:01.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:01.120]                     {
[09:30:01.120]                       inherits <- base::inherits
[09:30:01.120]                       invokeRestart <- base::invokeRestart
[09:30:01.120]                       is.null <- base::is.null
[09:30:01.120]                       muffled <- FALSE
[09:30:01.120]                       if (inherits(cond, "message")) {
[09:30:01.120]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:01.120]                         if (muffled) 
[09:30:01.120]                           invokeRestart("muffleMessage")
[09:30:01.120]                       }
[09:30:01.120]                       else if (inherits(cond, "warning")) {
[09:30:01.120]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:01.120]                         if (muffled) 
[09:30:01.120]                           invokeRestart("muffleWarning")
[09:30:01.120]                       }
[09:30:01.120]                       else if (inherits(cond, "condition")) {
[09:30:01.120]                         if (!is.null(pattern)) {
[09:30:01.120]                           computeRestarts <- base::computeRestarts
[09:30:01.120]                           grepl <- base::grepl
[09:30:01.120]                           restarts <- computeRestarts(cond)
[09:30:01.120]                           for (restart in restarts) {
[09:30:01.120]                             name <- restart$name
[09:30:01.120]                             if (is.null(name)) 
[09:30:01.120]                               next
[09:30:01.120]                             if (!grepl(pattern, name)) 
[09:30:01.120]                               next
[09:30:01.120]                             invokeRestart(restart)
[09:30:01.120]                             muffled <- TRUE
[09:30:01.120]                             break
[09:30:01.120]                           }
[09:30:01.120]                         }
[09:30:01.120]                       }
[09:30:01.120]                       invisible(muffled)
[09:30:01.120]                     }
[09:30:01.120]                     muffleCondition(cond, pattern = "^muffle")
[09:30:01.120]                   }
[09:30:01.120]                 }
[09:30:01.120]             }
[09:30:01.120]         }))
[09:30:01.120]     }, error = function(ex) {
[09:30:01.120]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:01.120]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:01.120]                 ...future.rng), started = ...future.startTime, 
[09:30:01.120]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:01.120]             version = "1.8"), class = "FutureResult")
[09:30:01.120]     }, finally = {
[09:30:01.120]         if (!identical(...future.workdir, getwd())) 
[09:30:01.120]             setwd(...future.workdir)
[09:30:01.120]         {
[09:30:01.120]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:01.120]                 ...future.oldOptions$nwarnings <- NULL
[09:30:01.120]             }
[09:30:01.120]             base::options(...future.oldOptions)
[09:30:01.120]             if (.Platform$OS.type == "windows") {
[09:30:01.120]                 old_names <- names(...future.oldEnvVars)
[09:30:01.120]                 envs <- base::Sys.getenv()
[09:30:01.120]                 names <- names(envs)
[09:30:01.120]                 common <- intersect(names, old_names)
[09:30:01.120]                 added <- setdiff(names, old_names)
[09:30:01.120]                 removed <- setdiff(old_names, names)
[09:30:01.120]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:01.120]                   envs[common]]
[09:30:01.120]                 NAMES <- toupper(changed)
[09:30:01.120]                 args <- list()
[09:30:01.120]                 for (kk in seq_along(NAMES)) {
[09:30:01.120]                   name <- changed[[kk]]
[09:30:01.120]                   NAME <- NAMES[[kk]]
[09:30:01.120]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:01.120]                     next
[09:30:01.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:01.120]                 }
[09:30:01.120]                 NAMES <- toupper(added)
[09:30:01.120]                 for (kk in seq_along(NAMES)) {
[09:30:01.120]                   name <- added[[kk]]
[09:30:01.120]                   NAME <- NAMES[[kk]]
[09:30:01.120]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:01.120]                     next
[09:30:01.120]                   args[[name]] <- ""
[09:30:01.120]                 }
[09:30:01.120]                 NAMES <- toupper(removed)
[09:30:01.120]                 for (kk in seq_along(NAMES)) {
[09:30:01.120]                   name <- removed[[kk]]
[09:30:01.120]                   NAME <- NAMES[[kk]]
[09:30:01.120]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:01.120]                     next
[09:30:01.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:01.120]                 }
[09:30:01.120]                 if (length(args) > 0) 
[09:30:01.120]                   base::do.call(base::Sys.setenv, args = args)
[09:30:01.120]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:01.120]             }
[09:30:01.120]             else {
[09:30:01.120]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:01.120]             }
[09:30:01.120]             {
[09:30:01.120]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:01.120]                   0L) {
[09:30:01.120]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:01.120]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:01.120]                   base::options(opts)
[09:30:01.120]                 }
[09:30:01.120]                 {
[09:30:01.120]                   {
[09:30:01.120]                     NULL
[09:30:01.120]                     RNGkind("Mersenne-Twister")
[09:30:01.120]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:30:01.120]                       inherits = FALSE)
[09:30:01.120]                   }
[09:30:01.120]                   options(future.plan = NULL)
[09:30:01.120]                   if (is.na(NA_character_)) 
[09:30:01.120]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:01.120]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:01.120]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:01.120]                     .init = FALSE)
[09:30:01.120]                 }
[09:30:01.120]             }
[09:30:01.120]         }
[09:30:01.120]     })
[09:30:01.120]     if (TRUE) {
[09:30:01.120]         base::sink(type = "output", split = FALSE)
[09:30:01.120]         if (FALSE) {
[09:30:01.120]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:01.120]         }
[09:30:01.120]         else {
[09:30:01.120]             ...future.result["stdout"] <- base::list(NULL)
[09:30:01.120]         }
[09:30:01.120]         base::close(...future.stdout)
[09:30:01.120]         ...future.stdout <- NULL
[09:30:01.120]     }
[09:30:01.120]     ...future.result$conditions <- ...future.conditions
[09:30:01.120]     ...future.result$finished <- base::Sys.time()
[09:30:01.120]     ...future.result
[09:30:01.120] }
[09:30:01.122] assign_globals() ...
[09:30:01.122] List of 5
[09:30:01.122]  $ ...future.FUN            :function (x, y)  
[09:30:01.122]  $ MoreArgs                 : NULL
[09:30:01.122]  $ ...future.elements_ii    :List of 2
[09:30:01.122]   ..$ :List of 2
[09:30:01.122]   .. ..$ : int 1
[09:30:01.122]   .. ..$ : int 0
[09:30:01.122]   ..$ :List of 2
[09:30:01.122]   .. ..$ : int 0
[09:30:01.122]   .. ..$ : int 1
[09:30:01.122]  $ ...future.seeds_ii       : NULL
[09:30:01.122]  $ ...future.globals.maxSize: NULL
[09:30:01.122]  - attr(*, "where")=List of 5
[09:30:01.122]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:01.122]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:30:01.122]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:01.122]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:01.122]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:01.122]  - attr(*, "resolved")= logi FALSE
[09:30:01.122]  - attr(*, "total_size")= num 6480
[09:30:01.122]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:01.122]  - attr(*, "already-done")= logi TRUE
[09:30:01.129] - reassign environment for ‘...future.FUN’
[09:30:01.130] - copied ‘...future.FUN’ to environment
[09:30:01.130] - copied ‘MoreArgs’ to environment
[09:30:01.130] - copied ‘...future.elements_ii’ to environment
[09:30:01.130] - copied ‘...future.seeds_ii’ to environment
[09:30:01.130] - copied ‘...future.globals.maxSize’ to environment
[09:30:01.130] assign_globals() ... done
[09:30:01.130] plan(): Setting new future strategy stack:
[09:30:01.130] List of future strategies:
[09:30:01.130] 1. sequential:
[09:30:01.130]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:01.130]    - tweaked: FALSE
[09:30:01.130]    - call: NULL
[09:30:01.131] plan(): nbrOfWorkers() = 1
[09:30:01.633] plan(): Setting new future strategy stack:
[09:30:01.633] List of future strategies:
[09:30:01.633] 1. sequential:
[09:30:01.633]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:01.633]    - tweaked: FALSE
[09:30:01.633]    - call: plan(strategy)
[09:30:01.633] plan(): nbrOfWorkers() = 1
[09:30:01.634] SequentialFuture started (and completed)
[09:30:01.634] - Launch lazy future ... done
[09:30:01.634] run() for ‘SequentialFuture’ ... done
[09:30:01.634] Created future:
[09:30:01.634] SequentialFuture:
[09:30:01.634] Label: ‘future_mapply-1’
[09:30:01.634] Expression:
[09:30:01.634] {
[09:30:01.634]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:01.634]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:01.634]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:01.634]         on.exit(options(oopts), add = TRUE)
[09:30:01.634]     }
[09:30:01.634]     {
[09:30:01.634]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:01.634]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:30:01.634]         do.call(mapply, args = args)
[09:30:01.634]     }
[09:30:01.634] }
[09:30:01.634] Lazy evaluation: FALSE
[09:30:01.634] Asynchronous evaluation: FALSE
[09:30:01.634] Local evaluation: TRUE
[09:30:01.634] Environment: R_GlobalEnv
[09:30:01.634] Capture standard output: FALSE
[09:30:01.634] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:01.634] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:01.634] Packages: <none>
[09:30:01.634] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:01.634] Resolved: TRUE
[09:30:01.634] Value: 224 bytes of class ‘list’
[09:30:01.634] Early signaling: FALSE
[09:30:01.634] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:01.634] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:01.635] Chunk #1 of 1 ... DONE
[09:30:01.635] Launching 1 futures (chunks) ... DONE
[09:30:01.635] Resolving 1 futures (chunks) ...
[09:30:01.635] resolve() on list ...
[09:30:01.635]  recursive: 0
[09:30:01.636]  length: 1
[09:30:01.636] 
[09:30:01.636] resolved() for ‘SequentialFuture’ ...
[09:30:01.636] - state: ‘finished’
[09:30:01.636] - run: TRUE
[09:30:01.636] - result: ‘FutureResult’
[09:30:01.636] resolved() for ‘SequentialFuture’ ... done
[09:30:01.636] Future #1
[09:30:01.636] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:30:01.636] - nx: 1
[09:30:01.637] - relay: TRUE
[09:30:01.637] - stdout: TRUE
[09:30:01.637] - signal: TRUE
[09:30:01.637] - resignal: FALSE
[09:30:01.637] - force: TRUE
[09:30:01.637] - relayed: [n=1] FALSE
[09:30:01.637] - queued futures: [n=1] FALSE
[09:30:01.637]  - until=1
[09:30:01.637]  - relaying element #1
[09:30:01.637] - relayed: [n=1] TRUE
[09:30:01.637] - queued futures: [n=1] TRUE
[09:30:01.638] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:30:01.638]  length: 0 (resolved future 1)
[09:30:01.638] Relaying remaining futures
[09:30:01.638] signalConditionsASAP(NULL, pos=0) ...
[09:30:01.638] - nx: 1
[09:30:01.638] - relay: TRUE
[09:30:01.638] - stdout: TRUE
[09:30:01.638] - signal: TRUE
[09:30:01.638] - resignal: FALSE
[09:30:01.638] - force: TRUE
[09:30:01.638] - relayed: [n=1] TRUE
[09:30:01.638] - queued futures: [n=1] TRUE
 - flush all
[09:30:01.639] - relayed: [n=1] TRUE
[09:30:01.639] - queued futures: [n=1] TRUE
[09:30:01.639] signalConditionsASAP(NULL, pos=0) ... done
[09:30:01.639] resolve() on list ... DONE
[09:30:01.639]  - Number of value chunks collected: 1
[09:30:01.639] Resolving 1 futures (chunks) ... DONE
[09:30:01.639] Reducing values from 1 chunks ...
[09:30:01.639]  - Number of values collected after concatenation: 2
[09:30:01.639]  - Number of values expected: 2
[09:30:01.639] Reducing values from 1 chunks ... DONE
[09:30:01.640] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[09:30:01.640] future_mapply() ...
[09:30:01.640] Number of chunks: 1
[09:30:01.640] getGlobalsAndPackagesXApply() ...
[09:30:01.640]  - future.globals: TRUE
[09:30:01.640] getGlobalsAndPackages() ...
[09:30:01.641] Searching for globals...
[09:30:01.642] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[09:30:01.642] Searching for globals ... DONE
[09:30:01.642] Resolving globals: FALSE
[09:30:01.643] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[09:30:01.643] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[09:30:01.643] - globals: [1] ‘FUN’
[09:30:01.643] 
[09:30:01.643] getGlobalsAndPackages() ... DONE
[09:30:01.643]  - globals found/used: [n=1] ‘FUN’
[09:30:01.643]  - needed namespaces: [n=0] 
[09:30:01.644] Finding globals ... DONE
[09:30:01.644] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:30:01.644] List of 2
[09:30:01.644]  $ ...future.FUN:function (x, y)  
[09:30:01.644]  $ MoreArgs     : NULL
[09:30:01.644]  - attr(*, "where")=List of 2
[09:30:01.644]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:01.644]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:30:01.644]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:01.644]  - attr(*, "resolved")= logi FALSE
[09:30:01.644]  - attr(*, "total_size")= num NA
[09:30:01.646] Packages to be attached in all futures: [n=0] 
[09:30:01.646] getGlobalsAndPackagesXApply() ... DONE
[09:30:01.647] Number of futures (= number of chunks): 1
[09:30:01.647] Launching 1 futures (chunks) ...
[09:30:01.647] Chunk #1 of 1 ...
[09:30:01.647]  - Finding globals in '...' for chunk #1 ...
[09:30:01.647] getGlobalsAndPackages() ...
[09:30:01.647] Searching for globals...
[09:30:01.647] 
[09:30:01.647] Searching for globals ... DONE
[09:30:01.648] - globals: [0] <none>
[09:30:01.648] getGlobalsAndPackages() ... DONE
[09:30:01.648]    + additional globals found: [n=0] 
[09:30:01.648]    + additional namespaces needed: [n=0] 
[09:30:01.648]  - Finding globals in '...' for chunk #1 ... DONE
[09:30:01.648]  - seeds: <none>
[09:30:01.648]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:01.648] getGlobalsAndPackages() ...
[09:30:01.648] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:01.648] Resolving globals: FALSE
[09:30:01.649] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[09:30:01.649] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:30:01.649] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:01.649] 
[09:30:01.650] getGlobalsAndPackages() ... DONE
[09:30:01.652] run() for ‘Future’ ...
[09:30:01.652] - state: ‘created’
[09:30:01.652] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:30:01.652] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:01.653] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:30:01.653]   - Field: ‘label’
[09:30:01.653]   - Field: ‘local’
[09:30:01.653]   - Field: ‘owner’
[09:30:01.653]   - Field: ‘envir’
[09:30:01.653]   - Field: ‘packages’
[09:30:01.653]   - Field: ‘gc’
[09:30:01.653]   - Field: ‘conditions’
[09:30:01.653]   - Field: ‘expr’
[09:30:01.653]   - Field: ‘uuid’
[09:30:01.653]   - Field: ‘seed’
[09:30:01.654]   - Field: ‘version’
[09:30:01.654]   - Field: ‘result’
[09:30:01.654]   - Field: ‘asynchronous’
[09:30:01.654]   - Field: ‘calls’
[09:30:01.654]   - Field: ‘globals’
[09:30:01.654]   - Field: ‘stdout’
[09:30:01.654]   - Field: ‘earlySignal’
[09:30:01.654]   - Field: ‘lazy’
[09:30:01.654]   - Field: ‘state’
[09:30:01.654] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:30:01.654] - Launch lazy future ...
[09:30:01.655] Packages needed by the future expression (n = 0): <none>
[09:30:01.655] Packages needed by future strategies (n = 0): <none>
[09:30:01.655] {
[09:30:01.655]     {
[09:30:01.655]         {
[09:30:01.655]             ...future.startTime <- base::Sys.time()
[09:30:01.655]             {
[09:30:01.655]                 {
[09:30:01.655]                   {
[09:30:01.655]                     base::local({
[09:30:01.655]                       has_future <- base::requireNamespace("future", 
[09:30:01.655]                         quietly = TRUE)
[09:30:01.655]                       if (has_future) {
[09:30:01.655]                         ns <- base::getNamespace("future")
[09:30:01.655]                         version <- ns[[".package"]][["version"]]
[09:30:01.655]                         if (is.null(version)) 
[09:30:01.655]                           version <- utils::packageVersion("future")
[09:30:01.655]                       }
[09:30:01.655]                       else {
[09:30:01.655]                         version <- NULL
[09:30:01.655]                       }
[09:30:01.655]                       if (!has_future || version < "1.8.0") {
[09:30:01.655]                         info <- base::c(r_version = base::gsub("R version ", 
[09:30:01.655]                           "", base::R.version$version.string), 
[09:30:01.655]                           platform = base::sprintf("%s (%s-bit)", 
[09:30:01.655]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:01.655]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:01.655]                             "release", "version")], collapse = " "), 
[09:30:01.655]                           hostname = base::Sys.info()[["nodename"]])
[09:30:01.655]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:30:01.655]                           info)
[09:30:01.655]                         info <- base::paste(info, collapse = "; ")
[09:30:01.655]                         if (!has_future) {
[09:30:01.655]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:01.655]                             info)
[09:30:01.655]                         }
[09:30:01.655]                         else {
[09:30:01.655]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:01.655]                             info, version)
[09:30:01.655]                         }
[09:30:01.655]                         base::stop(msg)
[09:30:01.655]                       }
[09:30:01.655]                     })
[09:30:01.655]                   }
[09:30:01.655]                   ...future.strategy.old <- future::plan("list")
[09:30:01.655]                   options(future.plan = NULL)
[09:30:01.655]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:01.655]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:01.655]                 }
[09:30:01.655]                 ...future.workdir <- getwd()
[09:30:01.655]             }
[09:30:01.655]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:01.655]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:01.655]         }
[09:30:01.655]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:01.655]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:30:01.655]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:01.655]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:01.655]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:01.655]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:01.655]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:01.655]             base::names(...future.oldOptions))
[09:30:01.655]     }
[09:30:01.655]     if (FALSE) {
[09:30:01.655]     }
[09:30:01.655]     else {
[09:30:01.655]         if (TRUE) {
[09:30:01.655]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:01.655]                 open = "w")
[09:30:01.655]         }
[09:30:01.655]         else {
[09:30:01.655]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:01.655]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:01.655]         }
[09:30:01.655]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:01.655]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:01.655]             base::sink(type = "output", split = FALSE)
[09:30:01.655]             base::close(...future.stdout)
[09:30:01.655]         }, add = TRUE)
[09:30:01.655]     }
[09:30:01.655]     ...future.frame <- base::sys.nframe()
[09:30:01.655]     ...future.conditions <- base::list()
[09:30:01.655]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:01.655]     if (FALSE) {
[09:30:01.655]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:01.655]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:01.655]     }
[09:30:01.655]     ...future.result <- base::tryCatch({
[09:30:01.655]         base::withCallingHandlers({
[09:30:01.655]             ...future.value <- base::withVisible(base::local({
[09:30:01.655]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:01.655]                 if (!identical(...future.globals.maxSize.org, 
[09:30:01.655]                   ...future.globals.maxSize)) {
[09:30:01.655]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:01.655]                   on.exit(options(oopts), add = TRUE)
[09:30:01.655]                 }
[09:30:01.655]                 {
[09:30:01.655]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:01.655]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:30:01.655]                     USE.NAMES = FALSE)
[09:30:01.655]                   do.call(mapply, args = args)
[09:30:01.655]                 }
[09:30:01.655]             }))
[09:30:01.655]             future::FutureResult(value = ...future.value$value, 
[09:30:01.655]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:01.655]                   ...future.rng), globalenv = if (FALSE) 
[09:30:01.655]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:01.655]                     ...future.globalenv.names))
[09:30:01.655]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:01.655]         }, condition = base::local({
[09:30:01.655]             c <- base::c
[09:30:01.655]             inherits <- base::inherits
[09:30:01.655]             invokeRestart <- base::invokeRestart
[09:30:01.655]             length <- base::length
[09:30:01.655]             list <- base::list
[09:30:01.655]             seq.int <- base::seq.int
[09:30:01.655]             signalCondition <- base::signalCondition
[09:30:01.655]             sys.calls <- base::sys.calls
[09:30:01.655]             `[[` <- base::`[[`
[09:30:01.655]             `+` <- base::`+`
[09:30:01.655]             `<<-` <- base::`<<-`
[09:30:01.655]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:01.655]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:01.655]                   3L)]
[09:30:01.655]             }
[09:30:01.655]             function(cond) {
[09:30:01.655]                 is_error <- inherits(cond, "error")
[09:30:01.655]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:01.655]                   NULL)
[09:30:01.655]                 if (is_error) {
[09:30:01.655]                   sessionInformation <- function() {
[09:30:01.655]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:01.655]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:01.655]                       search = base::search(), system = base::Sys.info())
[09:30:01.655]                   }
[09:30:01.655]                   ...future.conditions[[length(...future.conditions) + 
[09:30:01.655]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:01.655]                     cond$call), session = sessionInformation(), 
[09:30:01.655]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:01.655]                   signalCondition(cond)
[09:30:01.655]                 }
[09:30:01.655]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:01.655]                 "immediateCondition"))) {
[09:30:01.655]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:01.655]                   ...future.conditions[[length(...future.conditions) + 
[09:30:01.655]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:01.655]                   if (TRUE && !signal) {
[09:30:01.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:01.655]                     {
[09:30:01.655]                       inherits <- base::inherits
[09:30:01.655]                       invokeRestart <- base::invokeRestart
[09:30:01.655]                       is.null <- base::is.null
[09:30:01.655]                       muffled <- FALSE
[09:30:01.655]                       if (inherits(cond, "message")) {
[09:30:01.655]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:01.655]                         if (muffled) 
[09:30:01.655]                           invokeRestart("muffleMessage")
[09:30:01.655]                       }
[09:30:01.655]                       else if (inherits(cond, "warning")) {
[09:30:01.655]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:01.655]                         if (muffled) 
[09:30:01.655]                           invokeRestart("muffleWarning")
[09:30:01.655]                       }
[09:30:01.655]                       else if (inherits(cond, "condition")) {
[09:30:01.655]                         if (!is.null(pattern)) {
[09:30:01.655]                           computeRestarts <- base::computeRestarts
[09:30:01.655]                           grepl <- base::grepl
[09:30:01.655]                           restarts <- computeRestarts(cond)
[09:30:01.655]                           for (restart in restarts) {
[09:30:01.655]                             name <- restart$name
[09:30:01.655]                             if (is.null(name)) 
[09:30:01.655]                               next
[09:30:01.655]                             if (!grepl(pattern, name)) 
[09:30:01.655]                               next
[09:30:01.655]                             invokeRestart(restart)
[09:30:01.655]                             muffled <- TRUE
[09:30:01.655]                             break
[09:30:01.655]                           }
[09:30:01.655]                         }
[09:30:01.655]                       }
[09:30:01.655]                       invisible(muffled)
[09:30:01.655]                     }
[09:30:01.655]                     muffleCondition(cond, pattern = "^muffle")
[09:30:01.655]                   }
[09:30:01.655]                 }
[09:30:01.655]                 else {
[09:30:01.655]                   if (TRUE) {
[09:30:01.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:01.655]                     {
[09:30:01.655]                       inherits <- base::inherits
[09:30:01.655]                       invokeRestart <- base::invokeRestart
[09:30:01.655]                       is.null <- base::is.null
[09:30:01.655]                       muffled <- FALSE
[09:30:01.655]                       if (inherits(cond, "message")) {
[09:30:01.655]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:01.655]                         if (muffled) 
[09:30:01.655]                           invokeRestart("muffleMessage")
[09:30:01.655]                       }
[09:30:01.655]                       else if (inherits(cond, "warning")) {
[09:30:01.655]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:01.655]                         if (muffled) 
[09:30:01.655]                           invokeRestart("muffleWarning")
[09:30:01.655]                       }
[09:30:01.655]                       else if (inherits(cond, "condition")) {
[09:30:01.655]                         if (!is.null(pattern)) {
[09:30:01.655]                           computeRestarts <- base::computeRestarts
[09:30:01.655]                           grepl <- base::grepl
[09:30:01.655]                           restarts <- computeRestarts(cond)
[09:30:01.655]                           for (restart in restarts) {
[09:30:01.655]                             name <- restart$name
[09:30:01.655]                             if (is.null(name)) 
[09:30:01.655]                               next
[09:30:01.655]                             if (!grepl(pattern, name)) 
[09:30:01.655]                               next
[09:30:01.655]                             invokeRestart(restart)
[09:30:01.655]                             muffled <- TRUE
[09:30:01.655]                             break
[09:30:01.655]                           }
[09:30:01.655]                         }
[09:30:01.655]                       }
[09:30:01.655]                       invisible(muffled)
[09:30:01.655]                     }
[09:30:01.655]                     muffleCondition(cond, pattern = "^muffle")
[09:30:01.655]                   }
[09:30:01.655]                 }
[09:30:01.655]             }
[09:30:01.655]         }))
[09:30:01.655]     }, error = function(ex) {
[09:30:01.655]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:01.655]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:01.655]                 ...future.rng), started = ...future.startTime, 
[09:30:01.655]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:01.655]             version = "1.8"), class = "FutureResult")
[09:30:01.655]     }, finally = {
[09:30:01.655]         if (!identical(...future.workdir, getwd())) 
[09:30:01.655]             setwd(...future.workdir)
[09:30:01.655]         {
[09:30:01.655]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:01.655]                 ...future.oldOptions$nwarnings <- NULL
[09:30:01.655]             }
[09:30:01.655]             base::options(...future.oldOptions)
[09:30:01.655]             if (.Platform$OS.type == "windows") {
[09:30:01.655]                 old_names <- names(...future.oldEnvVars)
[09:30:01.655]                 envs <- base::Sys.getenv()
[09:30:01.655]                 names <- names(envs)
[09:30:01.655]                 common <- intersect(names, old_names)
[09:30:01.655]                 added <- setdiff(names, old_names)
[09:30:01.655]                 removed <- setdiff(old_names, names)
[09:30:01.655]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:01.655]                   envs[common]]
[09:30:01.655]                 NAMES <- toupper(changed)
[09:30:01.655]                 args <- list()
[09:30:01.655]                 for (kk in seq_along(NAMES)) {
[09:30:01.655]                   name <- changed[[kk]]
[09:30:01.655]                   NAME <- NAMES[[kk]]
[09:30:01.655]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:01.655]                     next
[09:30:01.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:01.655]                 }
[09:30:01.655]                 NAMES <- toupper(added)
[09:30:01.655]                 for (kk in seq_along(NAMES)) {
[09:30:01.655]                   name <- added[[kk]]
[09:30:01.655]                   NAME <- NAMES[[kk]]
[09:30:01.655]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:01.655]                     next
[09:30:01.655]                   args[[name]] <- ""
[09:30:01.655]                 }
[09:30:01.655]                 NAMES <- toupper(removed)
[09:30:01.655]                 for (kk in seq_along(NAMES)) {
[09:30:01.655]                   name <- removed[[kk]]
[09:30:01.655]                   NAME <- NAMES[[kk]]
[09:30:01.655]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:01.655]                     next
[09:30:01.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:01.655]                 }
[09:30:01.655]                 if (length(args) > 0) 
[09:30:01.655]                   base::do.call(base::Sys.setenv, args = args)
[09:30:01.655]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:01.655]             }
[09:30:01.655]             else {
[09:30:01.655]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:01.655]             }
[09:30:01.655]             {
[09:30:01.655]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:01.655]                   0L) {
[09:30:01.655]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:01.655]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:01.655]                   base::options(opts)
[09:30:01.655]                 }
[09:30:01.655]                 {
[09:30:01.655]                   {
[09:30:01.655]                     NULL
[09:30:01.655]                     RNGkind("Mersenne-Twister")
[09:30:01.655]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:30:01.655]                       inherits = FALSE)
[09:30:01.655]                   }
[09:30:01.655]                   options(future.plan = NULL)
[09:30:01.655]                   if (is.na(NA_character_)) 
[09:30:01.655]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:01.655]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:01.655]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:01.655]                     .init = FALSE)
[09:30:01.655]                 }
[09:30:01.655]             }
[09:30:01.655]         }
[09:30:01.655]     })
[09:30:01.655]     if (TRUE) {
[09:30:01.655]         base::sink(type = "output", split = FALSE)
[09:30:01.655]         if (TRUE) {
[09:30:01.655]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:01.655]         }
[09:30:01.655]         else {
[09:30:01.655]             ...future.result["stdout"] <- base::list(NULL)
[09:30:01.655]         }
[09:30:01.655]         base::close(...future.stdout)
[09:30:01.655]         ...future.stdout <- NULL
[09:30:01.655]     }
[09:30:01.655]     ...future.result$conditions <- ...future.conditions
[09:30:01.655]     ...future.result$finished <- base::Sys.time()
[09:30:01.655]     ...future.result
[09:30:01.655] }
[09:30:01.657] assign_globals() ...
[09:30:01.657] List of 5
[09:30:01.657]  $ ...future.FUN            :function (x, y)  
[09:30:01.657]  $ MoreArgs                 : NULL
[09:30:01.657]  $ ...future.elements_ii    :List of 2
[09:30:01.657]   ..$ :List of 2
[09:30:01.657]   .. ..$ : int 1
[09:30:01.657]   .. ..$ : int 0
[09:30:01.657]   ..$ :List of 2
[09:30:01.657]   .. ..$ : int 0
[09:30:01.657]   .. ..$ : int 1
[09:30:01.657]  $ ...future.seeds_ii       : NULL
[09:30:01.657]  $ ...future.globals.maxSize: NULL
[09:30:01.657]  - attr(*, "where")=List of 5
[09:30:01.657]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:01.657]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:30:01.657]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:01.657]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:01.657]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:01.657]  - attr(*, "resolved")= logi FALSE
[09:30:01.657]  - attr(*, "total_size")= num 6480
[09:30:01.657]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:01.657]  - attr(*, "already-done")= logi TRUE
[09:30:01.662] - reassign environment for ‘...future.FUN’
[09:30:01.662] - copied ‘...future.FUN’ to environment
[09:30:01.662] - copied ‘MoreArgs’ to environment
[09:30:01.662] - copied ‘...future.elements_ii’ to environment
[09:30:01.663] - copied ‘...future.seeds_ii’ to environment
[09:30:01.663] - copied ‘...future.globals.maxSize’ to environment
[09:30:01.663] assign_globals() ... done
[09:30:01.663] plan(): Setting new future strategy stack:
[09:30:01.663] List of future strategies:
[09:30:01.663] 1. sequential:
[09:30:01.663]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:01.663]    - tweaked: FALSE
[09:30:01.663]    - call: NULL
[09:30:01.664] plan(): nbrOfWorkers() = 1
[09:30:02.165] plan(): Setting new future strategy stack:
[09:30:02.165] List of future strategies:
[09:30:02.165] 1. sequential:
[09:30:02.165]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:02.165]    - tweaked: FALSE
[09:30:02.165]    - call: plan(strategy)
[09:30:02.166] plan(): nbrOfWorkers() = 1
[09:30:02.166] SequentialFuture started (and completed)
[09:30:02.166] - Launch lazy future ... done
[09:30:02.166] run() for ‘SequentialFuture’ ... done
[09:30:02.166] Created future:
[09:30:02.166] SequentialFuture:
[09:30:02.166] Label: ‘future_mapply-1’
[09:30:02.166] Expression:
[09:30:02.166] {
[09:30:02.166]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:02.166]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:02.166]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:02.166]         on.exit(options(oopts), add = TRUE)
[09:30:02.166]     }
[09:30:02.166]     {
[09:30:02.166]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:02.166]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:30:02.166]         do.call(mapply, args = args)
[09:30:02.166]     }
[09:30:02.166] }
[09:30:02.166] Lazy evaluation: FALSE
[09:30:02.166] Asynchronous evaluation: FALSE
[09:30:02.166] Local evaluation: TRUE
[09:30:02.166] Environment: R_GlobalEnv
[09:30:02.166] Capture standard output: TRUE
[09:30:02.166] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:02.166] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:02.166] Packages: <none>
[09:30:02.166] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:02.166] Resolved: TRUE
[09:30:02.166] Value: 224 bytes of class ‘list’
[09:30:02.166] Early signaling: FALSE
[09:30:02.166] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:02.166] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:02.167] Chunk #1 of 1 ... DONE
[09:30:02.167] Launching 1 futures (chunks) ... DONE
[09:30:02.168] Resolving 1 futures (chunks) ...
[09:30:02.168] resolve() on list ...
[09:30:02.168]  recursive: 0
[09:30:02.168]  length: 1
[09:30:02.168] 
[09:30:02.168] resolved() for ‘SequentialFuture’ ...
[09:30:02.168] - state: ‘finished’
[09:30:02.168] - run: TRUE
[09:30:02.168] - result: ‘FutureResult’
[09:30:02.169] resolved() for ‘SequentialFuture’ ... done
[09:30:02.169] Future #1
[09:30:02.169] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:30:02.169] - nx: 1
[09:30:02.169] - relay: TRUE
[09:30:02.169] - stdout: TRUE
[09:30:02.169] - signal: TRUE
[09:30:02.169] - resignal: FALSE
[09:30:02.169] - force: TRUE
[09:30:02.169] - relayed: [n=1] FALSE
[09:30:02.169] - queued futures: [n=1] FALSE
[09:30:02.170]  - until=1
[09:30:02.170]  - relaying element #1
[09:30:02.170] - relayed: [n=1] TRUE
[09:30:02.170] - queued futures: [n=1] TRUE
[09:30:02.170] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:30:02.170]  length: 0 (resolved future 1)
[09:30:02.170] Relaying remaining futures
[09:30:02.170] signalConditionsASAP(NULL, pos=0) ...
[09:30:02.170] - nx: 1
[09:30:02.170] - relay: TRUE
[09:30:02.171] - stdout: TRUE
[09:30:02.171] - signal: TRUE
[09:30:02.171] - resignal: FALSE
[09:30:02.171] - force: TRUE
[09:30:02.171] - relayed: [n=1] TRUE
[09:30:02.171] - queued futures: [n=1] TRUE
 - flush all
[09:30:02.171] - relayed: [n=1] TRUE
[09:30:02.171] - queued futures: [n=1] TRUE
[09:30:02.171] signalConditionsASAP(NULL, pos=0) ... done
[09:30:02.171] resolve() on list ... DONE
[09:30:02.172]  - Number of value chunks collected: 1
[09:30:02.172] Resolving 1 futures (chunks) ... DONE
[09:30:02.172] Reducing values from 1 chunks ...
[09:30:02.172]  - Number of values collected after concatenation: 2
[09:30:02.172]  - Number of values expected: 2
[09:30:02.172] Reducing values from 1 chunks ... DONE
[09:30:02.172] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[09:30:02.172] future_mapply() ...
[09:30:02.173] Number of chunks: 1
[09:30:02.173] getGlobalsAndPackagesXApply() ...
[09:30:02.173]  - future.globals: TRUE
[09:30:02.173] getGlobalsAndPackages() ...
[09:30:02.173] Searching for globals...
[09:30:02.174] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[09:30:02.175] Searching for globals ... DONE
[09:30:02.175] Resolving globals: FALSE
[09:30:02.175] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[09:30:02.175] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[09:30:02.176] - globals: [1] ‘FUN’
[09:30:02.176] 
[09:30:02.176] getGlobalsAndPackages() ... DONE
[09:30:02.176]  - globals found/used: [n=1] ‘FUN’
[09:30:02.176]  - needed namespaces: [n=0] 
[09:30:02.176] Finding globals ... DONE
[09:30:02.176] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:30:02.176] List of 2
[09:30:02.176]  $ ...future.FUN:function (x, y)  
[09:30:02.176]  $ MoreArgs     : NULL
[09:30:02.176]  - attr(*, "where")=List of 2
[09:30:02.176]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:02.176]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:30:02.176]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:02.176]  - attr(*, "resolved")= logi FALSE
[09:30:02.176]  - attr(*, "total_size")= num NA
[09:30:02.180] Packages to be attached in all futures: [n=0] 
[09:30:02.181] getGlobalsAndPackagesXApply() ... DONE
[09:30:02.181] Number of futures (= number of chunks): 1
[09:30:02.181] Launching 1 futures (chunks) ...
[09:30:02.181] Chunk #1 of 1 ...
[09:30:02.181]  - Finding globals in '...' for chunk #1 ...
[09:30:02.181] getGlobalsAndPackages() ...
[09:30:02.181] Searching for globals...
[09:30:02.182] 
[09:30:02.182] Searching for globals ... DONE
[09:30:02.182] - globals: [0] <none>
[09:30:02.182] getGlobalsAndPackages() ... DONE
[09:30:02.182]    + additional globals found: [n=0] 
[09:30:02.182]    + additional namespaces needed: [n=0] 
[09:30:02.182]  - Finding globals in '...' for chunk #1 ... DONE
[09:30:02.182]  - seeds: <none>
[09:30:02.182]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:02.182] getGlobalsAndPackages() ...
[09:30:02.183] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:02.183] Resolving globals: FALSE
[09:30:02.183] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[09:30:02.183] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:30:02.184] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:02.184] 
[09:30:02.184] getGlobalsAndPackages() ... DONE
[09:30:02.184] run() for ‘Future’ ...
[09:30:02.184] - state: ‘created’
[09:30:02.184] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:30:02.185] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:02.185] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:30:02.185]   - Field: ‘label’
[09:30:02.185]   - Field: ‘local’
[09:30:02.185]   - Field: ‘owner’
[09:30:02.185]   - Field: ‘envir’
[09:30:02.185]   - Field: ‘packages’
[09:30:02.185]   - Field: ‘gc’
[09:30:02.185]   - Field: ‘conditions’
[09:30:02.185]   - Field: ‘expr’
[09:30:02.186]   - Field: ‘uuid’
[09:30:02.186]   - Field: ‘seed’
[09:30:02.186]   - Field: ‘version’
[09:30:02.186]   - Field: ‘result’
[09:30:02.186]   - Field: ‘asynchronous’
[09:30:02.186]   - Field: ‘calls’
[09:30:02.186]   - Field: ‘globals’
[09:30:02.186]   - Field: ‘stdout’
[09:30:02.186]   - Field: ‘earlySignal’
[09:30:02.186]   - Field: ‘lazy’
[09:30:02.186]   - Field: ‘state’
[09:30:02.187] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:30:02.187] - Launch lazy future ...
[09:30:02.187] Packages needed by the future expression (n = 0): <none>
[09:30:02.187] Packages needed by future strategies (n = 0): <none>
[09:30:02.187] {
[09:30:02.187]     {
[09:30:02.187]         {
[09:30:02.187]             ...future.startTime <- base::Sys.time()
[09:30:02.187]             {
[09:30:02.187]                 {
[09:30:02.187]                   {
[09:30:02.187]                     base::local({
[09:30:02.187]                       has_future <- base::requireNamespace("future", 
[09:30:02.187]                         quietly = TRUE)
[09:30:02.187]                       if (has_future) {
[09:30:02.187]                         ns <- base::getNamespace("future")
[09:30:02.187]                         version <- ns[[".package"]][["version"]]
[09:30:02.187]                         if (is.null(version)) 
[09:30:02.187]                           version <- utils::packageVersion("future")
[09:30:02.187]                       }
[09:30:02.187]                       else {
[09:30:02.187]                         version <- NULL
[09:30:02.187]                       }
[09:30:02.187]                       if (!has_future || version < "1.8.0") {
[09:30:02.187]                         info <- base::c(r_version = base::gsub("R version ", 
[09:30:02.187]                           "", base::R.version$version.string), 
[09:30:02.187]                           platform = base::sprintf("%s (%s-bit)", 
[09:30:02.187]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:02.187]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:02.187]                             "release", "version")], collapse = " "), 
[09:30:02.187]                           hostname = base::Sys.info()[["nodename"]])
[09:30:02.187]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:30:02.187]                           info)
[09:30:02.187]                         info <- base::paste(info, collapse = "; ")
[09:30:02.187]                         if (!has_future) {
[09:30:02.187]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:02.187]                             info)
[09:30:02.187]                         }
[09:30:02.187]                         else {
[09:30:02.187]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:02.187]                             info, version)
[09:30:02.187]                         }
[09:30:02.187]                         base::stop(msg)
[09:30:02.187]                       }
[09:30:02.187]                     })
[09:30:02.187]                   }
[09:30:02.187]                   ...future.strategy.old <- future::plan("list")
[09:30:02.187]                   options(future.plan = NULL)
[09:30:02.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:02.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:02.187]                 }
[09:30:02.187]                 ...future.workdir <- getwd()
[09:30:02.187]             }
[09:30:02.187]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:02.187]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:02.187]         }
[09:30:02.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:02.187]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:30:02.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:02.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:02.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:02.187]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:02.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:02.187]             base::names(...future.oldOptions))
[09:30:02.187]     }
[09:30:02.187]     if (TRUE) {
[09:30:02.187]     }
[09:30:02.187]     else {
[09:30:02.187]         if (NA) {
[09:30:02.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:02.187]                 open = "w")
[09:30:02.187]         }
[09:30:02.187]         else {
[09:30:02.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:02.187]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:02.187]         }
[09:30:02.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:02.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:02.187]             base::sink(type = "output", split = FALSE)
[09:30:02.187]             base::close(...future.stdout)
[09:30:02.187]         }, add = TRUE)
[09:30:02.187]     }
[09:30:02.187]     ...future.frame <- base::sys.nframe()
[09:30:02.187]     ...future.conditions <- base::list()
[09:30:02.187]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:02.187]     if (FALSE) {
[09:30:02.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:02.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:02.187]     }
[09:30:02.187]     ...future.result <- base::tryCatch({
[09:30:02.187]         base::withCallingHandlers({
[09:30:02.187]             ...future.value <- base::withVisible(base::local({
[09:30:02.187]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:02.187]                 if (!identical(...future.globals.maxSize.org, 
[09:30:02.187]                   ...future.globals.maxSize)) {
[09:30:02.187]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:02.187]                   on.exit(options(oopts), add = TRUE)
[09:30:02.187]                 }
[09:30:02.187]                 {
[09:30:02.187]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:02.187]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:30:02.187]                     USE.NAMES = FALSE)
[09:30:02.187]                   do.call(mapply, args = args)
[09:30:02.187]                 }
[09:30:02.187]             }))
[09:30:02.187]             future::FutureResult(value = ...future.value$value, 
[09:30:02.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:02.187]                   ...future.rng), globalenv = if (FALSE) 
[09:30:02.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:02.187]                     ...future.globalenv.names))
[09:30:02.187]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:02.187]         }, condition = base::local({
[09:30:02.187]             c <- base::c
[09:30:02.187]             inherits <- base::inherits
[09:30:02.187]             invokeRestart <- base::invokeRestart
[09:30:02.187]             length <- base::length
[09:30:02.187]             list <- base::list
[09:30:02.187]             seq.int <- base::seq.int
[09:30:02.187]             signalCondition <- base::signalCondition
[09:30:02.187]             sys.calls <- base::sys.calls
[09:30:02.187]             `[[` <- base::`[[`
[09:30:02.187]             `+` <- base::`+`
[09:30:02.187]             `<<-` <- base::`<<-`
[09:30:02.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:02.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:02.187]                   3L)]
[09:30:02.187]             }
[09:30:02.187]             function(cond) {
[09:30:02.187]                 is_error <- inherits(cond, "error")
[09:30:02.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:02.187]                   NULL)
[09:30:02.187]                 if (is_error) {
[09:30:02.187]                   sessionInformation <- function() {
[09:30:02.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:02.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:02.187]                       search = base::search(), system = base::Sys.info())
[09:30:02.187]                   }
[09:30:02.187]                   ...future.conditions[[length(...future.conditions) + 
[09:30:02.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:02.187]                     cond$call), session = sessionInformation(), 
[09:30:02.187]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:02.187]                   signalCondition(cond)
[09:30:02.187]                 }
[09:30:02.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:02.187]                 "immediateCondition"))) {
[09:30:02.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:02.187]                   ...future.conditions[[length(...future.conditions) + 
[09:30:02.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:02.187]                   if (TRUE && !signal) {
[09:30:02.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:02.187]                     {
[09:30:02.187]                       inherits <- base::inherits
[09:30:02.187]                       invokeRestart <- base::invokeRestart
[09:30:02.187]                       is.null <- base::is.null
[09:30:02.187]                       muffled <- FALSE
[09:30:02.187]                       if (inherits(cond, "message")) {
[09:30:02.187]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:02.187]                         if (muffled) 
[09:30:02.187]                           invokeRestart("muffleMessage")
[09:30:02.187]                       }
[09:30:02.187]                       else if (inherits(cond, "warning")) {
[09:30:02.187]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:02.187]                         if (muffled) 
[09:30:02.187]                           invokeRestart("muffleWarning")
[09:30:02.187]                       }
[09:30:02.187]                       else if (inherits(cond, "condition")) {
[09:30:02.187]                         if (!is.null(pattern)) {
[09:30:02.187]                           computeRestarts <- base::computeRestarts
[09:30:02.187]                           grepl <- base::grepl
[09:30:02.187]                           restarts <- computeRestarts(cond)
[09:30:02.187]                           for (restart in restarts) {
[09:30:02.187]                             name <- restart$name
[09:30:02.187]                             if (is.null(name)) 
[09:30:02.187]                               next
[09:30:02.187]                             if (!grepl(pattern, name)) 
[09:30:02.187]                               next
[09:30:02.187]                             invokeRestart(restart)
[09:30:02.187]                             muffled <- TRUE
[09:30:02.187]                             break
[09:30:02.187]                           }
[09:30:02.187]                         }
[09:30:02.187]                       }
[09:30:02.187]                       invisible(muffled)
[09:30:02.187]                     }
[09:30:02.187]                     muffleCondition(cond, pattern = "^muffle")
[09:30:02.187]                   }
[09:30:02.187]                 }
[09:30:02.187]                 else {
[09:30:02.187]                   if (TRUE) {
[09:30:02.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:02.187]                     {
[09:30:02.187]                       inherits <- base::inherits
[09:30:02.187]                       invokeRestart <- base::invokeRestart
[09:30:02.187]                       is.null <- base::is.null
[09:30:02.187]                       muffled <- FALSE
[09:30:02.187]                       if (inherits(cond, "message")) {
[09:30:02.187]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:02.187]                         if (muffled) 
[09:30:02.187]                           invokeRestart("muffleMessage")
[09:30:02.187]                       }
[09:30:02.187]                       else if (inherits(cond, "warning")) {
[09:30:02.187]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:02.187]                         if (muffled) 
[09:30:02.187]                           invokeRestart("muffleWarning")
[09:30:02.187]                       }
[09:30:02.187]                       else if (inherits(cond, "condition")) {
[09:30:02.187]                         if (!is.null(pattern)) {
[09:30:02.187]                           computeRestarts <- base::computeRestarts
[09:30:02.187]                           grepl <- base::grepl
[09:30:02.187]                           restarts <- computeRestarts(cond)
[09:30:02.187]                           for (restart in restarts) {
[09:30:02.187]                             name <- restart$name
[09:30:02.187]                             if (is.null(name)) 
[09:30:02.187]                               next
[09:30:02.187]                             if (!grepl(pattern, name)) 
[09:30:02.187]                               next
[09:30:02.187]                             invokeRestart(restart)
[09:30:02.187]                             muffled <- TRUE
[09:30:02.187]                             break
[09:30:02.187]                           }
[09:30:02.187]                         }
[09:30:02.187]                       }
[09:30:02.187]                       invisible(muffled)
[09:30:02.187]                     }
[09:30:02.187]                     muffleCondition(cond, pattern = "^muffle")
[09:30:02.187]                   }
[09:30:02.187]                 }
[09:30:02.187]             }
[09:30:02.187]         }))
[09:30:02.187]     }, error = function(ex) {
[09:30:02.187]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:02.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:02.187]                 ...future.rng), started = ...future.startTime, 
[09:30:02.187]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:02.187]             version = "1.8"), class = "FutureResult")
[09:30:02.187]     }, finally = {
[09:30:02.187]         if (!identical(...future.workdir, getwd())) 
[09:30:02.187]             setwd(...future.workdir)
[09:30:02.187]         {
[09:30:02.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:02.187]                 ...future.oldOptions$nwarnings <- NULL
[09:30:02.187]             }
[09:30:02.187]             base::options(...future.oldOptions)
[09:30:02.187]             if (.Platform$OS.type == "windows") {
[09:30:02.187]                 old_names <- names(...future.oldEnvVars)
[09:30:02.187]                 envs <- base::Sys.getenv()
[09:30:02.187]                 names <- names(envs)
[09:30:02.187]                 common <- intersect(names, old_names)
[09:30:02.187]                 added <- setdiff(names, old_names)
[09:30:02.187]                 removed <- setdiff(old_names, names)
[09:30:02.187]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:02.187]                   envs[common]]
[09:30:02.187]                 NAMES <- toupper(changed)
[09:30:02.187]                 args <- list()
[09:30:02.187]                 for (kk in seq_along(NAMES)) {
[09:30:02.187]                   name <- changed[[kk]]
[09:30:02.187]                   NAME <- NAMES[[kk]]
[09:30:02.187]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:02.187]                     next
[09:30:02.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:02.187]                 }
[09:30:02.187]                 NAMES <- toupper(added)
[09:30:02.187]                 for (kk in seq_along(NAMES)) {
[09:30:02.187]                   name <- added[[kk]]
[09:30:02.187]                   NAME <- NAMES[[kk]]
[09:30:02.187]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:02.187]                     next
[09:30:02.187]                   args[[name]] <- ""
[09:30:02.187]                 }
[09:30:02.187]                 NAMES <- toupper(removed)
[09:30:02.187]                 for (kk in seq_along(NAMES)) {
[09:30:02.187]                   name <- removed[[kk]]
[09:30:02.187]                   NAME <- NAMES[[kk]]
[09:30:02.187]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:02.187]                     next
[09:30:02.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:02.187]                 }
[09:30:02.187]                 if (length(args) > 0) 
[09:30:02.187]                   base::do.call(base::Sys.setenv, args = args)
[09:30:02.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:02.187]             }
[09:30:02.187]             else {
[09:30:02.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:02.187]             }
[09:30:02.187]             {
[09:30:02.187]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:02.187]                   0L) {
[09:30:02.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:02.187]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:02.187]                   base::options(opts)
[09:30:02.187]                 }
[09:30:02.187]                 {
[09:30:02.187]                   {
[09:30:02.187]                     NULL
[09:30:02.187]                     RNGkind("Mersenne-Twister")
[09:30:02.187]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:30:02.187]                       inherits = FALSE)
[09:30:02.187]                   }
[09:30:02.187]                   options(future.plan = NULL)
[09:30:02.187]                   if (is.na(NA_character_)) 
[09:30:02.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:02.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:02.187]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:02.187]                     .init = FALSE)
[09:30:02.187]                 }
[09:30:02.187]             }
[09:30:02.187]         }
[09:30:02.187]     })
[09:30:02.187]     if (FALSE) {
[09:30:02.187]         base::sink(type = "output", split = FALSE)
[09:30:02.187]         if (NA) {
[09:30:02.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:02.187]         }
[09:30:02.187]         else {
[09:30:02.187]             ...future.result["stdout"] <- base::list(NULL)
[09:30:02.187]         }
[09:30:02.187]         base::close(...future.stdout)
[09:30:02.187]         ...future.stdout <- NULL
[09:30:02.187]     }
[09:30:02.187]     ...future.result$conditions <- ...future.conditions
[09:30:02.187]     ...future.result$finished <- base::Sys.time()
[09:30:02.187]     ...future.result
[09:30:02.187] }
[09:30:02.189] assign_globals() ...
[09:30:02.189] List of 5
[09:30:02.189]  $ ...future.FUN            :function (x, y)  
[09:30:02.189]  $ MoreArgs                 : NULL
[09:30:02.189]  $ ...future.elements_ii    :List of 2
[09:30:02.189]   ..$ :List of 2
[09:30:02.189]   .. ..$ : int 1
[09:30:02.189]   .. ..$ : int 0
[09:30:02.189]   ..$ :List of 2
[09:30:02.189]   .. ..$ : int 0
[09:30:02.189]   .. ..$ : int 1
[09:30:02.189]  $ ...future.seeds_ii       : NULL
[09:30:02.189]  $ ...future.globals.maxSize: NULL
[09:30:02.189]  - attr(*, "where")=List of 5
[09:30:02.189]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:02.189]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:30:02.189]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:02.189]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:02.189]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:02.189]  - attr(*, "resolved")= logi FALSE
[09:30:02.189]  - attr(*, "total_size")= num 6480
[09:30:02.189]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:02.189]  - attr(*, "already-done")= logi TRUE
[09:30:02.194] - reassign environment for ‘...future.FUN’
[09:30:02.194] - copied ‘...future.FUN’ to environment
[09:30:02.194] - copied ‘MoreArgs’ to environment
[09:30:02.195] - copied ‘...future.elements_ii’ to environment
[09:30:02.195] - copied ‘...future.seeds_ii’ to environment
[09:30:02.195] - copied ‘...future.globals.maxSize’ to environment
[09:30:02.195] assign_globals() ... done
[09:30:02.195] plan(): Setting new future strategy stack:
[09:30:02.195] List of future strategies:
[09:30:02.195] 1. sequential:
[09:30:02.195]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:02.195]    - tweaked: FALSE
[09:30:02.195]    - call: NULL
[09:30:02.196] plan(): nbrOfWorkers() = 1
[09:30:02.697] plan(): Setting new future strategy stack:
[09:30:02.697] List of future strategies:
[09:30:02.697] 1. sequential:
[09:30:02.697]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:02.697]    - tweaked: FALSE
[09:30:02.697]    - call: plan(strategy)
[09:30:02.698] plan(): nbrOfWorkers() = 1
[09:30:02.698] SequentialFuture started (and completed)
[09:30:02.698] - Launch lazy future ... done
[09:30:02.698] run() for ‘SequentialFuture’ ... done
[09:30:02.698] Created future:
[09:30:02.698] SequentialFuture:
[09:30:02.698] Label: ‘future_mapply-1’
[09:30:02.698] Expression:
[09:30:02.698] {
[09:30:02.698]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:02.698]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:02.698]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:02.698]         on.exit(options(oopts), add = TRUE)
[09:30:02.698]     }
[09:30:02.698]     {
[09:30:02.698]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:02.698]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:30:02.698]         do.call(mapply, args = args)
[09:30:02.698]     }
[09:30:02.698] }
[09:30:02.698] Lazy evaluation: FALSE
[09:30:02.698] Asynchronous evaluation: FALSE
[09:30:02.698] Local evaluation: TRUE
[09:30:02.698] Environment: R_GlobalEnv
[09:30:02.698] Capture standard output: NA
[09:30:02.698] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:02.698] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:02.698] Packages: <none>
[09:30:02.698] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:02.698] Resolved: TRUE
[09:30:02.698] Value: 224 bytes of class ‘list’
[09:30:02.698] Early signaling: FALSE
[09:30:02.698] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:02.698] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:02.699] Chunk #1 of 1 ... DONE
[09:30:02.700] Launching 1 futures (chunks) ... DONE
[09:30:02.700] Resolving 1 futures (chunks) ...
[09:30:02.700] resolve() on list ...
[09:30:02.700]  recursive: 0
[09:30:02.700]  length: 1
[09:30:02.700] 
[09:30:02.700] resolved() for ‘SequentialFuture’ ...
[09:30:02.700] - state: ‘finished’
[09:30:02.700] - run: TRUE
[09:30:02.700] - result: ‘FutureResult’
[09:30:02.700] resolved() for ‘SequentialFuture’ ... done
[09:30:02.701] Future #1
[09:30:02.701] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:30:02.701] - nx: 1
[09:30:02.701] - relay: TRUE
[09:30:02.701] - stdout: TRUE
[09:30:02.701] - signal: TRUE
[09:30:02.701] - resignal: FALSE
[09:30:02.701] - force: TRUE
[09:30:02.701] - relayed: [n=1] FALSE
[09:30:02.701] - queued futures: [n=1] FALSE
[09:30:02.701]  - until=1
[09:30:02.702]  - relaying element #1
[09:30:02.702] - relayed: [n=1] TRUE
[09:30:02.702] - queued futures: [n=1] TRUE
[09:30:02.702] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:30:02.702]  length: 0 (resolved future 1)
[09:30:02.702] Relaying remaining futures
[09:30:02.702] signalConditionsASAP(NULL, pos=0) ...
[09:30:02.702] - nx: 1
[09:30:02.702] - relay: TRUE
[09:30:02.702] - stdout: TRUE
[09:30:02.703] - signal: TRUE
[09:30:02.703] - resignal: FALSE
[09:30:02.703] - force: TRUE
[09:30:02.703] - relayed: [n=1] TRUE
[09:30:02.703] - queued futures: [n=1] TRUE
 - flush all
[09:30:02.703] - relayed: [n=1] TRUE
[09:30:02.703] - queued futures: [n=1] TRUE
[09:30:02.703] signalConditionsASAP(NULL, pos=0) ... done
[09:30:02.703] resolve() on list ... DONE
[09:30:02.703]  - Number of value chunks collected: 1
[09:30:02.703] Resolving 1 futures (chunks) ... DONE
[09:30:02.704] Reducing values from 1 chunks ...
[09:30:02.704]  - Number of values collected after concatenation: 2
[09:30:02.704]  - Number of values expected: 2
[09:30:02.704] Reducing values from 1 chunks ... DONE
[09:30:02.704] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('sequential') ... DONE
* plan('multicore') ...
[09:30:02.704] plan(): Setting new future strategy stack:
[09:30:02.705] List of future strategies:
[09:30:02.705] 1. multicore:
[09:30:02.705]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:30:02.705]    - tweaked: FALSE
[09:30:02.705]    - call: plan(strategy)
[09:30:02.710] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[09:30:02.711] future_lapply() ...
[09:30:02.714] Number of chunks: 1
[09:30:02.715] getGlobalsAndPackagesXApply() ...
[09:30:02.715]  - future.globals: TRUE
[09:30:02.715] getGlobalsAndPackages() ...
[09:30:02.715] Searching for globals...
[09:30:02.716] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[09:30:02.716] Searching for globals ... DONE
[09:30:02.716] Resolving globals: FALSE
[09:30:02.717] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[09:30:02.717] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[09:30:02.717] - globals: [1] ‘FUN’
[09:30:02.717] 
[09:30:02.717] getGlobalsAndPackages() ... DONE
[09:30:02.718]  - globals found/used: [n=1] ‘FUN’
[09:30:02.718]  - needed namespaces: [n=0] 
[09:30:02.718] Finding globals ... DONE
[09:30:02.718]  - use_args: TRUE
[09:30:02.718]  - Getting '...' globals ...
[09:30:02.718] resolve() on list ...
[09:30:02.718]  recursive: 0
[09:30:02.718]  length: 1
[09:30:02.718]  elements: ‘...’
[09:30:02.719]  length: 0 (resolved future 1)
[09:30:02.719] resolve() on list ... DONE
[09:30:02.719]    - '...' content: [n=0] 
[09:30:02.719] List of 1
[09:30:02.719]  $ ...: list()
[09:30:02.719]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:02.719]  - attr(*, "where")=List of 1
[09:30:02.719]   ..$ ...:<environment: 0x55c102e8fb88> 
[09:30:02.719]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:02.719]  - attr(*, "resolved")= logi TRUE
[09:30:02.719]  - attr(*, "total_size")= num NA
[09:30:02.721]  - Getting '...' globals ... DONE
[09:30:02.722] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:30:02.722] List of 2
[09:30:02.722]  $ ...future.FUN:function (x)  
[09:30:02.722]  $ ...          : list()
[09:30:02.722]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:02.722]  - attr(*, "where")=List of 2
[09:30:02.722]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:02.722]   ..$ ...          :<environment: 0x55c102e8fb88> 
[09:30:02.722]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:02.722]  - attr(*, "resolved")= logi FALSE
[09:30:02.722]  - attr(*, "total_size")= num 4720
[09:30:02.724] Packages to be attached in all futures: [n=0] 
[09:30:02.724] getGlobalsAndPackagesXApply() ... DONE
[09:30:02.724] Number of futures (= number of chunks): 1
[09:30:02.725] Launching 1 futures (chunks) ...
[09:30:02.725] Chunk #1 of 1 ...
[09:30:02.725]  - Finding globals in 'X' for chunk #1 ...
[09:30:02.725] getGlobalsAndPackages() ...
[09:30:02.725] Searching for globals...
[09:30:02.725] 
[09:30:02.725] Searching for globals ... DONE
[09:30:02.725] - globals: [0] <none>
[09:30:02.726] getGlobalsAndPackages() ... DONE
[09:30:02.726]    + additional globals found: [n=0] 
[09:30:02.726]    + additional namespaces needed: [n=0] 
[09:30:02.726]  - Finding globals in 'X' for chunk #1 ... DONE
[09:30:02.726]  - seeds: <none>
[09:30:02.726]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:02.726] getGlobalsAndPackages() ...
[09:30:02.726] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:02.726] Resolving globals: FALSE
[09:30:02.726] Tweak future expression to call with '...' arguments ...
[09:30:02.727] {
[09:30:02.727]     do.call(function(...) {
[09:30:02.727]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:02.727]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:02.727]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:02.727]             on.exit(options(oopts), add = TRUE)
[09:30:02.727]         }
[09:30:02.727]         {
[09:30:02.727]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:02.727]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:02.727]                 ...future.FUN(...future.X_jj, ...)
[09:30:02.727]             })
[09:30:02.727]         }
[09:30:02.727]     }, args = future.call.arguments)
[09:30:02.727] }
[09:30:02.727] Tweak future expression to call with '...' arguments ... DONE
[09:30:02.727] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:02.727] 
[09:30:02.727] getGlobalsAndPackages() ... DONE
[09:30:02.728] run() for ‘Future’ ...
[09:30:02.728] - state: ‘created’
[09:30:02.728] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:30:02.731] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:02.731] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:30:02.731]   - Field: ‘label’
[09:30:02.732]   - Field: ‘local’
[09:30:02.732]   - Field: ‘owner’
[09:30:02.732]   - Field: ‘envir’
[09:30:02.732]   - Field: ‘packages’
[09:30:02.732]   - Field: ‘gc’
[09:30:02.732]   - Field: ‘conditions’
[09:30:02.732]   - Field: ‘expr’
[09:30:02.732]   - Field: ‘uuid’
[09:30:02.732]   - Field: ‘seed’
[09:30:02.732]   - Field: ‘version’
[09:30:02.732]   - Field: ‘result’
[09:30:02.733]   - Field: ‘asynchronous’
[09:30:02.733]   - Field: ‘calls’
[09:30:02.733]   - Field: ‘globals’
[09:30:02.733]   - Field: ‘stdout’
[09:30:02.733]   - Field: ‘earlySignal’
[09:30:02.733]   - Field: ‘lazy’
[09:30:02.733]   - Field: ‘state’
[09:30:02.733] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:30:02.733] - Launch lazy future ...
[09:30:02.733] Packages needed by the future expression (n = 0): <none>
[09:30:02.734] Packages needed by future strategies (n = 0): <none>
[09:30:02.734] {
[09:30:02.734]     {
[09:30:02.734]         {
[09:30:02.734]             ...future.startTime <- base::Sys.time()
[09:30:02.734]             {
[09:30:02.734]                 {
[09:30:02.734]                   {
[09:30:02.734]                     base::local({
[09:30:02.734]                       has_future <- base::requireNamespace("future", 
[09:30:02.734]                         quietly = TRUE)
[09:30:02.734]                       if (has_future) {
[09:30:02.734]                         ns <- base::getNamespace("future")
[09:30:02.734]                         version <- ns[[".package"]][["version"]]
[09:30:02.734]                         if (is.null(version)) 
[09:30:02.734]                           version <- utils::packageVersion("future")
[09:30:02.734]                       }
[09:30:02.734]                       else {
[09:30:02.734]                         version <- NULL
[09:30:02.734]                       }
[09:30:02.734]                       if (!has_future || version < "1.8.0") {
[09:30:02.734]                         info <- base::c(r_version = base::gsub("R version ", 
[09:30:02.734]                           "", base::R.version$version.string), 
[09:30:02.734]                           platform = base::sprintf("%s (%s-bit)", 
[09:30:02.734]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:02.734]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:02.734]                             "release", "version")], collapse = " "), 
[09:30:02.734]                           hostname = base::Sys.info()[["nodename"]])
[09:30:02.734]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:30:02.734]                           info)
[09:30:02.734]                         info <- base::paste(info, collapse = "; ")
[09:30:02.734]                         if (!has_future) {
[09:30:02.734]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:02.734]                             info)
[09:30:02.734]                         }
[09:30:02.734]                         else {
[09:30:02.734]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:02.734]                             info, version)
[09:30:02.734]                         }
[09:30:02.734]                         base::stop(msg)
[09:30:02.734]                       }
[09:30:02.734]                     })
[09:30:02.734]                   }
[09:30:02.734]                   ...future.strategy.old <- future::plan("list")
[09:30:02.734]                   options(future.plan = NULL)
[09:30:02.734]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:02.734]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:02.734]                 }
[09:30:02.734]                 ...future.workdir <- getwd()
[09:30:02.734]             }
[09:30:02.734]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:02.734]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:02.734]         }
[09:30:02.734]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:02.734]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:30:02.734]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:02.734]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:02.734]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:02.734]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:02.734]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:02.734]             base::names(...future.oldOptions))
[09:30:02.734]     }
[09:30:02.734]     if (FALSE) {
[09:30:02.734]     }
[09:30:02.734]     else {
[09:30:02.734]         if (FALSE) {
[09:30:02.734]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:02.734]                 open = "w")
[09:30:02.734]         }
[09:30:02.734]         else {
[09:30:02.734]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:02.734]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:02.734]         }
[09:30:02.734]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:02.734]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:02.734]             base::sink(type = "output", split = FALSE)
[09:30:02.734]             base::close(...future.stdout)
[09:30:02.734]         }, add = TRUE)
[09:30:02.734]     }
[09:30:02.734]     ...future.frame <- base::sys.nframe()
[09:30:02.734]     ...future.conditions <- base::list()
[09:30:02.734]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:02.734]     if (FALSE) {
[09:30:02.734]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:02.734]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:02.734]     }
[09:30:02.734]     ...future.result <- base::tryCatch({
[09:30:02.734]         base::withCallingHandlers({
[09:30:02.734]             ...future.value <- base::withVisible(base::local({
[09:30:02.734]                 do.call(function(...) {
[09:30:02.734]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:02.734]                   if (!identical(...future.globals.maxSize.org, 
[09:30:02.734]                     ...future.globals.maxSize)) {
[09:30:02.734]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:02.734]                     on.exit(options(oopts), add = TRUE)
[09:30:02.734]                   }
[09:30:02.734]                   {
[09:30:02.734]                     lapply(seq_along(...future.elements_ii), 
[09:30:02.734]                       FUN = function(jj) {
[09:30:02.734]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:02.734]                         ...future.FUN(...future.X_jj, ...)
[09:30:02.734]                       })
[09:30:02.734]                   }
[09:30:02.734]                 }, args = future.call.arguments)
[09:30:02.734]             }))
[09:30:02.734]             future::FutureResult(value = ...future.value$value, 
[09:30:02.734]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:02.734]                   ...future.rng), globalenv = if (FALSE) 
[09:30:02.734]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:02.734]                     ...future.globalenv.names))
[09:30:02.734]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:02.734]         }, condition = base::local({
[09:30:02.734]             c <- base::c
[09:30:02.734]             inherits <- base::inherits
[09:30:02.734]             invokeRestart <- base::invokeRestart
[09:30:02.734]             length <- base::length
[09:30:02.734]             list <- base::list
[09:30:02.734]             seq.int <- base::seq.int
[09:30:02.734]             signalCondition <- base::signalCondition
[09:30:02.734]             sys.calls <- base::sys.calls
[09:30:02.734]             `[[` <- base::`[[`
[09:30:02.734]             `+` <- base::`+`
[09:30:02.734]             `<<-` <- base::`<<-`
[09:30:02.734]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:02.734]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:02.734]                   3L)]
[09:30:02.734]             }
[09:30:02.734]             function(cond) {
[09:30:02.734]                 is_error <- inherits(cond, "error")
[09:30:02.734]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:02.734]                   NULL)
[09:30:02.734]                 if (is_error) {
[09:30:02.734]                   sessionInformation <- function() {
[09:30:02.734]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:02.734]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:02.734]                       search = base::search(), system = base::Sys.info())
[09:30:02.734]                   }
[09:30:02.734]                   ...future.conditions[[length(...future.conditions) + 
[09:30:02.734]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:02.734]                     cond$call), session = sessionInformation(), 
[09:30:02.734]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:02.734]                   signalCondition(cond)
[09:30:02.734]                 }
[09:30:02.734]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:02.734]                 "immediateCondition"))) {
[09:30:02.734]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:02.734]                   ...future.conditions[[length(...future.conditions) + 
[09:30:02.734]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:02.734]                   if (TRUE && !signal) {
[09:30:02.734]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:02.734]                     {
[09:30:02.734]                       inherits <- base::inherits
[09:30:02.734]                       invokeRestart <- base::invokeRestart
[09:30:02.734]                       is.null <- base::is.null
[09:30:02.734]                       muffled <- FALSE
[09:30:02.734]                       if (inherits(cond, "message")) {
[09:30:02.734]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:02.734]                         if (muffled) 
[09:30:02.734]                           invokeRestart("muffleMessage")
[09:30:02.734]                       }
[09:30:02.734]                       else if (inherits(cond, "warning")) {
[09:30:02.734]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:02.734]                         if (muffled) 
[09:30:02.734]                           invokeRestart("muffleWarning")
[09:30:02.734]                       }
[09:30:02.734]                       else if (inherits(cond, "condition")) {
[09:30:02.734]                         if (!is.null(pattern)) {
[09:30:02.734]                           computeRestarts <- base::computeRestarts
[09:30:02.734]                           grepl <- base::grepl
[09:30:02.734]                           restarts <- computeRestarts(cond)
[09:30:02.734]                           for (restart in restarts) {
[09:30:02.734]                             name <- restart$name
[09:30:02.734]                             if (is.null(name)) 
[09:30:02.734]                               next
[09:30:02.734]                             if (!grepl(pattern, name)) 
[09:30:02.734]                               next
[09:30:02.734]                             invokeRestart(restart)
[09:30:02.734]                             muffled <- TRUE
[09:30:02.734]                             break
[09:30:02.734]                           }
[09:30:02.734]                         }
[09:30:02.734]                       }
[09:30:02.734]                       invisible(muffled)
[09:30:02.734]                     }
[09:30:02.734]                     muffleCondition(cond, pattern = "^muffle")
[09:30:02.734]                   }
[09:30:02.734]                 }
[09:30:02.734]                 else {
[09:30:02.734]                   if (TRUE) {
[09:30:02.734]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:02.734]                     {
[09:30:02.734]                       inherits <- base::inherits
[09:30:02.734]                       invokeRestart <- base::invokeRestart
[09:30:02.734]                       is.null <- base::is.null
[09:30:02.734]                       muffled <- FALSE
[09:30:02.734]                       if (inherits(cond, "message")) {
[09:30:02.734]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:02.734]                         if (muffled) 
[09:30:02.734]                           invokeRestart("muffleMessage")
[09:30:02.734]                       }
[09:30:02.734]                       else if (inherits(cond, "warning")) {
[09:30:02.734]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:02.734]                         if (muffled) 
[09:30:02.734]                           invokeRestart("muffleWarning")
[09:30:02.734]                       }
[09:30:02.734]                       else if (inherits(cond, "condition")) {
[09:30:02.734]                         if (!is.null(pattern)) {
[09:30:02.734]                           computeRestarts <- base::computeRestarts
[09:30:02.734]                           grepl <- base::grepl
[09:30:02.734]                           restarts <- computeRestarts(cond)
[09:30:02.734]                           for (restart in restarts) {
[09:30:02.734]                             name <- restart$name
[09:30:02.734]                             if (is.null(name)) 
[09:30:02.734]                               next
[09:30:02.734]                             if (!grepl(pattern, name)) 
[09:30:02.734]                               next
[09:30:02.734]                             invokeRestart(restart)
[09:30:02.734]                             muffled <- TRUE
[09:30:02.734]                             break
[09:30:02.734]                           }
[09:30:02.734]                         }
[09:30:02.734]                       }
[09:30:02.734]                       invisible(muffled)
[09:30:02.734]                     }
[09:30:02.734]                     muffleCondition(cond, pattern = "^muffle")
[09:30:02.734]                   }
[09:30:02.734]                 }
[09:30:02.734]             }
[09:30:02.734]         }))
[09:30:02.734]     }, error = function(ex) {
[09:30:02.734]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:02.734]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:02.734]                 ...future.rng), started = ...future.startTime, 
[09:30:02.734]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:02.734]             version = "1.8"), class = "FutureResult")
[09:30:02.734]     }, finally = {
[09:30:02.734]         if (!identical(...future.workdir, getwd())) 
[09:30:02.734]             setwd(...future.workdir)
[09:30:02.734]         {
[09:30:02.734]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:02.734]                 ...future.oldOptions$nwarnings <- NULL
[09:30:02.734]             }
[09:30:02.734]             base::options(...future.oldOptions)
[09:30:02.734]             if (.Platform$OS.type == "windows") {
[09:30:02.734]                 old_names <- names(...future.oldEnvVars)
[09:30:02.734]                 envs <- base::Sys.getenv()
[09:30:02.734]                 names <- names(envs)
[09:30:02.734]                 common <- intersect(names, old_names)
[09:30:02.734]                 added <- setdiff(names, old_names)
[09:30:02.734]                 removed <- setdiff(old_names, names)
[09:30:02.734]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:02.734]                   envs[common]]
[09:30:02.734]                 NAMES <- toupper(changed)
[09:30:02.734]                 args <- list()
[09:30:02.734]                 for (kk in seq_along(NAMES)) {
[09:30:02.734]                   name <- changed[[kk]]
[09:30:02.734]                   NAME <- NAMES[[kk]]
[09:30:02.734]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:02.734]                     next
[09:30:02.734]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:02.734]                 }
[09:30:02.734]                 NAMES <- toupper(added)
[09:30:02.734]                 for (kk in seq_along(NAMES)) {
[09:30:02.734]                   name <- added[[kk]]
[09:30:02.734]                   NAME <- NAMES[[kk]]
[09:30:02.734]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:02.734]                     next
[09:30:02.734]                   args[[name]] <- ""
[09:30:02.734]                 }
[09:30:02.734]                 NAMES <- toupper(removed)
[09:30:02.734]                 for (kk in seq_along(NAMES)) {
[09:30:02.734]                   name <- removed[[kk]]
[09:30:02.734]                   NAME <- NAMES[[kk]]
[09:30:02.734]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:02.734]                     next
[09:30:02.734]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:02.734]                 }
[09:30:02.734]                 if (length(args) > 0) 
[09:30:02.734]                   base::do.call(base::Sys.setenv, args = args)
[09:30:02.734]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:02.734]             }
[09:30:02.734]             else {
[09:30:02.734]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:02.734]             }
[09:30:02.734]             {
[09:30:02.734]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:02.734]                   0L) {
[09:30:02.734]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:02.734]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:02.734]                   base::options(opts)
[09:30:02.734]                 }
[09:30:02.734]                 {
[09:30:02.734]                   {
[09:30:02.734]                     NULL
[09:30:02.734]                     RNGkind("Mersenne-Twister")
[09:30:02.734]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:30:02.734]                       inherits = FALSE)
[09:30:02.734]                   }
[09:30:02.734]                   options(future.plan = NULL)
[09:30:02.734]                   if (is.na(NA_character_)) 
[09:30:02.734]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:02.734]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:02.734]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:02.734]                     .init = FALSE)
[09:30:02.734]                 }
[09:30:02.734]             }
[09:30:02.734]         }
[09:30:02.734]     })
[09:30:02.734]     if (TRUE) {
[09:30:02.734]         base::sink(type = "output", split = FALSE)
[09:30:02.734]         if (FALSE) {
[09:30:02.734]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:02.734]         }
[09:30:02.734]         else {
[09:30:02.734]             ...future.result["stdout"] <- base::list(NULL)
[09:30:02.734]         }
[09:30:02.734]         base::close(...future.stdout)
[09:30:02.734]         ...future.stdout <- NULL
[09:30:02.734]     }
[09:30:02.734]     ...future.result$conditions <- ...future.conditions
[09:30:02.734]     ...future.result$finished <- base::Sys.time()
[09:30:02.734]     ...future.result
[09:30:02.734] }
[09:30:02.736] assign_globals() ...
[09:30:02.736] List of 5
[09:30:02.736]  $ ...future.FUN            :function (x)  
[09:30:02.736]  $ future.call.arguments    : list()
[09:30:02.736]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:02.736]  $ ...future.elements_ii    :List of 2
[09:30:02.736]   ..$ : int 1
[09:30:02.736]   ..$ : int 0
[09:30:02.736]  $ ...future.seeds_ii       : NULL
[09:30:02.736]  $ ...future.globals.maxSize: NULL
[09:30:02.736]  - attr(*, "where")=List of 5
[09:30:02.736]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:02.736]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:30:02.736]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:02.736]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:02.736]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:02.736]  - attr(*, "resolved")= logi FALSE
[09:30:02.736]  - attr(*, "total_size")= num 4720
[09:30:02.736]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:02.736]  - attr(*, "already-done")= logi TRUE
[09:30:02.742] - reassign environment for ‘...future.FUN’
[09:30:02.742] - copied ‘...future.FUN’ to environment
[09:30:02.742] - copied ‘future.call.arguments’ to environment
[09:30:02.742] - copied ‘...future.elements_ii’ to environment
[09:30:02.742] - copied ‘...future.seeds_ii’ to environment
[09:30:02.742] - copied ‘...future.globals.maxSize’ to environment
[09:30:02.742] assign_globals() ... done
[09:30:02.743] plan(): Setting new future strategy stack:
[09:30:02.743] List of future strategies:
[09:30:02.743] 1. sequential:
[09:30:02.743]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:02.743]    - tweaked: FALSE
[09:30:02.743]    - call: NULL
[09:30:02.743] plan(): nbrOfWorkers() = 1
[09:30:03.245] plan(): Setting new future strategy stack:
[09:30:03.245] List of future strategies:
[09:30:03.245] 1. multicore:
[09:30:03.245]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:30:03.245]    - tweaked: FALSE
[09:30:03.245]    - call: plan(strategy)
[09:30:03.249] plan(): nbrOfWorkers() = 1
[09:30:03.249] SequentialFuture started (and completed)
[09:30:03.249] - Launch lazy future ... done
[09:30:03.249] run() for ‘SequentialFuture’ ... done
[09:30:03.249] Created future:
[09:30:03.249] SequentialFuture:
[09:30:03.249] Label: ‘future_lapply-1’
[09:30:03.249] Expression:
[09:30:03.249] {
[09:30:03.249]     do.call(function(...) {
[09:30:03.249]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:03.249]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:03.249]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:03.249]             on.exit(options(oopts), add = TRUE)
[09:30:03.249]         }
[09:30:03.249]         {
[09:30:03.249]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:03.249]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:03.249]                 ...future.FUN(...future.X_jj, ...)
[09:30:03.249]             })
[09:30:03.249]         }
[09:30:03.249]     }, args = future.call.arguments)
[09:30:03.249] }
[09:30:03.249] Lazy evaluation: FALSE
[09:30:03.249] Asynchronous evaluation: FALSE
[09:30:03.249] Local evaluation: TRUE
[09:30:03.249] Environment: R_GlobalEnv
[09:30:03.249] Capture standard output: FALSE
[09:30:03.249] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:03.249] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:03.249] Packages: <none>
[09:30:03.249] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:03.249] Resolved: TRUE
[09:30:03.249] Value: 112 bytes of class ‘list’
[09:30:03.249] Early signaling: FALSE
[09:30:03.249] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:03.249] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:03.250] Chunk #1 of 1 ... DONE
[09:30:03.250] Launching 1 futures (chunks) ... DONE
[09:30:03.251] Resolving 1 futures (chunks) ...
[09:30:03.251] resolve() on list ...
[09:30:03.251]  recursive: 0
[09:30:03.251]  length: 1
[09:30:03.251] 
[09:30:03.251] resolved() for ‘SequentialFuture’ ...
[09:30:03.251] - state: ‘finished’
[09:30:03.251] - run: TRUE
[09:30:03.251] - result: ‘FutureResult’
[09:30:03.251] resolved() for ‘SequentialFuture’ ... done
[09:30:03.251] Future #1
[09:30:03.252] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:30:03.252] - nx: 1
[09:30:03.252] - relay: TRUE
[09:30:03.252] - stdout: TRUE
[09:30:03.252] - signal: TRUE
[09:30:03.252] - resignal: FALSE
[09:30:03.252] - force: TRUE
[09:30:03.252] - relayed: [n=1] FALSE
[09:30:03.252] - queued futures: [n=1] FALSE
[09:30:03.252]  - until=1
[09:30:03.253]  - relaying element #1
[09:30:03.253] - relayed: [n=1] TRUE
[09:30:03.253] - queued futures: [n=1] TRUE
[09:30:03.253] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:30:03.253]  length: 0 (resolved future 1)
[09:30:03.253] Relaying remaining futures
[09:30:03.253] signalConditionsASAP(NULL, pos=0) ...
[09:30:03.253] - nx: 1
[09:30:03.253] - relay: TRUE
[09:30:03.253] - stdout: TRUE
[09:30:03.253] - signal: TRUE
[09:30:03.254] - resignal: FALSE
[09:30:03.254] - force: TRUE
[09:30:03.254] - relayed: [n=1] TRUE
[09:30:03.254] - queued futures: [n=1] TRUE
 - flush all
[09:30:03.254] - relayed: [n=1] TRUE
[09:30:03.254] - queued futures: [n=1] TRUE
[09:30:03.254] signalConditionsASAP(NULL, pos=0) ... done
[09:30:03.254] resolve() on list ... DONE
[09:30:03.254]  - Number of value chunks collected: 1
[09:30:03.254] Resolving 1 futures (chunks) ... DONE
[09:30:03.254] Reducing values from 1 chunks ...
[09:30:03.255]  - Number of values collected after concatenation: 2
[09:30:03.255]  - Number of values expected: 2
[09:30:03.255] Reducing values from 1 chunks ... DONE
[09:30:03.255] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[09:30:03.255] future_lapply() ...
[09:30:03.259] Number of chunks: 1
[09:30:03.259] getGlobalsAndPackagesXApply() ...
[09:30:03.259]  - future.globals: TRUE
[09:30:03.259] getGlobalsAndPackages() ...
[09:30:03.259] Searching for globals...
[09:30:03.260] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[09:30:03.261] Searching for globals ... DONE
[09:30:03.261] Resolving globals: FALSE
[09:30:03.261] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[09:30:03.261] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[09:30:03.262] - globals: [1] ‘FUN’
[09:30:03.262] 
[09:30:03.262] getGlobalsAndPackages() ... DONE
[09:30:03.262]  - globals found/used: [n=1] ‘FUN’
[09:30:03.262]  - needed namespaces: [n=0] 
[09:30:03.262] Finding globals ... DONE
[09:30:03.262]  - use_args: TRUE
[09:30:03.262]  - Getting '...' globals ...
[09:30:03.262] resolve() on list ...
[09:30:03.263]  recursive: 0
[09:30:03.263]  length: 1
[09:30:03.263]  elements: ‘...’
[09:30:03.263]  length: 0 (resolved future 1)
[09:30:03.263] resolve() on list ... DONE
[09:30:03.263]    - '...' content: [n=0] 
[09:30:03.263] List of 1
[09:30:03.263]  $ ...: list()
[09:30:03.263]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:03.263]  - attr(*, "where")=List of 1
[09:30:03.263]   ..$ ...:<environment: 0x55c1032d0928> 
[09:30:03.263]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:03.263]  - attr(*, "resolved")= logi TRUE
[09:30:03.263]  - attr(*, "total_size")= num NA
[09:30:03.266]  - Getting '...' globals ... DONE
[09:30:03.266] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:30:03.266] List of 2
[09:30:03.266]  $ ...future.FUN:function (x)  
[09:30:03.266]  $ ...          : list()
[09:30:03.266]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:03.266]  - attr(*, "where")=List of 2
[09:30:03.266]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:03.266]   ..$ ...          :<environment: 0x55c1032d0928> 
[09:30:03.266]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:03.266]  - attr(*, "resolved")= logi FALSE
[09:30:03.266]  - attr(*, "total_size")= num 4720
[09:30:03.270] Packages to be attached in all futures: [n=0] 
[09:30:03.270] getGlobalsAndPackagesXApply() ... DONE
[09:30:03.271] Number of futures (= number of chunks): 1
[09:30:03.271] Launching 1 futures (chunks) ...
[09:30:03.271] Chunk #1 of 1 ...
[09:30:03.271]  - Finding globals in 'X' for chunk #1 ...
[09:30:03.271] getGlobalsAndPackages() ...
[09:30:03.271] Searching for globals...
[09:30:03.271] 
[09:30:03.271] Searching for globals ... DONE
[09:30:03.271] - globals: [0] <none>
[09:30:03.272] getGlobalsAndPackages() ... DONE
[09:30:03.272]    + additional globals found: [n=0] 
[09:30:03.272]    + additional namespaces needed: [n=0] 
[09:30:03.272]  - Finding globals in 'X' for chunk #1 ... DONE
[09:30:03.272]  - seeds: <none>
[09:30:03.272]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:03.272] getGlobalsAndPackages() ...
[09:30:03.272] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:03.272] Resolving globals: FALSE
[09:30:03.272] Tweak future expression to call with '...' arguments ...
[09:30:03.273] {
[09:30:03.273]     do.call(function(...) {
[09:30:03.273]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:03.273]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:03.273]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:03.273]             on.exit(options(oopts), add = TRUE)
[09:30:03.273]         }
[09:30:03.273]         {
[09:30:03.273]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:03.273]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:03.273]                 ...future.FUN(...future.X_jj, ...)
[09:30:03.273]             })
[09:30:03.273]         }
[09:30:03.273]     }, args = future.call.arguments)
[09:30:03.273] }
[09:30:03.273] Tweak future expression to call with '...' arguments ... DONE
[09:30:03.273] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:03.273] 
[09:30:03.273] getGlobalsAndPackages() ... DONE
[09:30:03.274] run() for ‘Future’ ...
[09:30:03.274] - state: ‘created’
[09:30:03.274] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:30:03.277] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:03.277] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:30:03.277]   - Field: ‘label’
[09:30:03.278]   - Field: ‘local’
[09:30:03.278]   - Field: ‘owner’
[09:30:03.278]   - Field: ‘envir’
[09:30:03.278]   - Field: ‘packages’
[09:30:03.278]   - Field: ‘gc’
[09:30:03.278]   - Field: ‘conditions’
[09:30:03.278]   - Field: ‘expr’
[09:30:03.278]   - Field: ‘uuid’
[09:30:03.278]   - Field: ‘seed’
[09:30:03.278]   - Field: ‘version’
[09:30:03.278]   - Field: ‘result’
[09:30:03.278]   - Field: ‘asynchronous’
[09:30:03.279]   - Field: ‘calls’
[09:30:03.279]   - Field: ‘globals’
[09:30:03.279]   - Field: ‘stdout’
[09:30:03.279]   - Field: ‘earlySignal’
[09:30:03.279]   - Field: ‘lazy’
[09:30:03.279]   - Field: ‘state’
[09:30:03.279] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:30:03.279] - Launch lazy future ...
[09:30:03.279] Packages needed by the future expression (n = 0): <none>
[09:30:03.279] Packages needed by future strategies (n = 0): <none>
[09:30:03.280] {
[09:30:03.280]     {
[09:30:03.280]         {
[09:30:03.280]             ...future.startTime <- base::Sys.time()
[09:30:03.280]             {
[09:30:03.280]                 {
[09:30:03.280]                   {
[09:30:03.280]                     base::local({
[09:30:03.280]                       has_future <- base::requireNamespace("future", 
[09:30:03.280]                         quietly = TRUE)
[09:30:03.280]                       if (has_future) {
[09:30:03.280]                         ns <- base::getNamespace("future")
[09:30:03.280]                         version <- ns[[".package"]][["version"]]
[09:30:03.280]                         if (is.null(version)) 
[09:30:03.280]                           version <- utils::packageVersion("future")
[09:30:03.280]                       }
[09:30:03.280]                       else {
[09:30:03.280]                         version <- NULL
[09:30:03.280]                       }
[09:30:03.280]                       if (!has_future || version < "1.8.0") {
[09:30:03.280]                         info <- base::c(r_version = base::gsub("R version ", 
[09:30:03.280]                           "", base::R.version$version.string), 
[09:30:03.280]                           platform = base::sprintf("%s (%s-bit)", 
[09:30:03.280]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:03.280]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:03.280]                             "release", "version")], collapse = " "), 
[09:30:03.280]                           hostname = base::Sys.info()[["nodename"]])
[09:30:03.280]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:30:03.280]                           info)
[09:30:03.280]                         info <- base::paste(info, collapse = "; ")
[09:30:03.280]                         if (!has_future) {
[09:30:03.280]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:03.280]                             info)
[09:30:03.280]                         }
[09:30:03.280]                         else {
[09:30:03.280]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:03.280]                             info, version)
[09:30:03.280]                         }
[09:30:03.280]                         base::stop(msg)
[09:30:03.280]                       }
[09:30:03.280]                     })
[09:30:03.280]                   }
[09:30:03.280]                   ...future.strategy.old <- future::plan("list")
[09:30:03.280]                   options(future.plan = NULL)
[09:30:03.280]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:03.280]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:03.280]                 }
[09:30:03.280]                 ...future.workdir <- getwd()
[09:30:03.280]             }
[09:30:03.280]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:03.280]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:03.280]         }
[09:30:03.280]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:03.280]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:30:03.280]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:03.280]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:03.280]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:03.280]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:03.280]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:03.280]             base::names(...future.oldOptions))
[09:30:03.280]     }
[09:30:03.280]     if (FALSE) {
[09:30:03.280]     }
[09:30:03.280]     else {
[09:30:03.280]         if (TRUE) {
[09:30:03.280]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:03.280]                 open = "w")
[09:30:03.280]         }
[09:30:03.280]         else {
[09:30:03.280]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:03.280]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:03.280]         }
[09:30:03.280]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:03.280]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:03.280]             base::sink(type = "output", split = FALSE)
[09:30:03.280]             base::close(...future.stdout)
[09:30:03.280]         }, add = TRUE)
[09:30:03.280]     }
[09:30:03.280]     ...future.frame <- base::sys.nframe()
[09:30:03.280]     ...future.conditions <- base::list()
[09:30:03.280]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:03.280]     if (FALSE) {
[09:30:03.280]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:03.280]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:03.280]     }
[09:30:03.280]     ...future.result <- base::tryCatch({
[09:30:03.280]         base::withCallingHandlers({
[09:30:03.280]             ...future.value <- base::withVisible(base::local({
[09:30:03.280]                 do.call(function(...) {
[09:30:03.280]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:03.280]                   if (!identical(...future.globals.maxSize.org, 
[09:30:03.280]                     ...future.globals.maxSize)) {
[09:30:03.280]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:03.280]                     on.exit(options(oopts), add = TRUE)
[09:30:03.280]                   }
[09:30:03.280]                   {
[09:30:03.280]                     lapply(seq_along(...future.elements_ii), 
[09:30:03.280]                       FUN = function(jj) {
[09:30:03.280]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:03.280]                         ...future.FUN(...future.X_jj, ...)
[09:30:03.280]                       })
[09:30:03.280]                   }
[09:30:03.280]                 }, args = future.call.arguments)
[09:30:03.280]             }))
[09:30:03.280]             future::FutureResult(value = ...future.value$value, 
[09:30:03.280]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:03.280]                   ...future.rng), globalenv = if (FALSE) 
[09:30:03.280]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:03.280]                     ...future.globalenv.names))
[09:30:03.280]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:03.280]         }, condition = base::local({
[09:30:03.280]             c <- base::c
[09:30:03.280]             inherits <- base::inherits
[09:30:03.280]             invokeRestart <- base::invokeRestart
[09:30:03.280]             length <- base::length
[09:30:03.280]             list <- base::list
[09:30:03.280]             seq.int <- base::seq.int
[09:30:03.280]             signalCondition <- base::signalCondition
[09:30:03.280]             sys.calls <- base::sys.calls
[09:30:03.280]             `[[` <- base::`[[`
[09:30:03.280]             `+` <- base::`+`
[09:30:03.280]             `<<-` <- base::`<<-`
[09:30:03.280]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:03.280]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:03.280]                   3L)]
[09:30:03.280]             }
[09:30:03.280]             function(cond) {
[09:30:03.280]                 is_error <- inherits(cond, "error")
[09:30:03.280]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:03.280]                   NULL)
[09:30:03.280]                 if (is_error) {
[09:30:03.280]                   sessionInformation <- function() {
[09:30:03.280]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:03.280]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:03.280]                       search = base::search(), system = base::Sys.info())
[09:30:03.280]                   }
[09:30:03.280]                   ...future.conditions[[length(...future.conditions) + 
[09:30:03.280]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:03.280]                     cond$call), session = sessionInformation(), 
[09:30:03.280]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:03.280]                   signalCondition(cond)
[09:30:03.280]                 }
[09:30:03.280]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:03.280]                 "immediateCondition"))) {
[09:30:03.280]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:03.280]                   ...future.conditions[[length(...future.conditions) + 
[09:30:03.280]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:03.280]                   if (TRUE && !signal) {
[09:30:03.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:03.280]                     {
[09:30:03.280]                       inherits <- base::inherits
[09:30:03.280]                       invokeRestart <- base::invokeRestart
[09:30:03.280]                       is.null <- base::is.null
[09:30:03.280]                       muffled <- FALSE
[09:30:03.280]                       if (inherits(cond, "message")) {
[09:30:03.280]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:03.280]                         if (muffled) 
[09:30:03.280]                           invokeRestart("muffleMessage")
[09:30:03.280]                       }
[09:30:03.280]                       else if (inherits(cond, "warning")) {
[09:30:03.280]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:03.280]                         if (muffled) 
[09:30:03.280]                           invokeRestart("muffleWarning")
[09:30:03.280]                       }
[09:30:03.280]                       else if (inherits(cond, "condition")) {
[09:30:03.280]                         if (!is.null(pattern)) {
[09:30:03.280]                           computeRestarts <- base::computeRestarts
[09:30:03.280]                           grepl <- base::grepl
[09:30:03.280]                           restarts <- computeRestarts(cond)
[09:30:03.280]                           for (restart in restarts) {
[09:30:03.280]                             name <- restart$name
[09:30:03.280]                             if (is.null(name)) 
[09:30:03.280]                               next
[09:30:03.280]                             if (!grepl(pattern, name)) 
[09:30:03.280]                               next
[09:30:03.280]                             invokeRestart(restart)
[09:30:03.280]                             muffled <- TRUE
[09:30:03.280]                             break
[09:30:03.280]                           }
[09:30:03.280]                         }
[09:30:03.280]                       }
[09:30:03.280]                       invisible(muffled)
[09:30:03.280]                     }
[09:30:03.280]                     muffleCondition(cond, pattern = "^muffle")
[09:30:03.280]                   }
[09:30:03.280]                 }
[09:30:03.280]                 else {
[09:30:03.280]                   if (TRUE) {
[09:30:03.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:03.280]                     {
[09:30:03.280]                       inherits <- base::inherits
[09:30:03.280]                       invokeRestart <- base::invokeRestart
[09:30:03.280]                       is.null <- base::is.null
[09:30:03.280]                       muffled <- FALSE
[09:30:03.280]                       if (inherits(cond, "message")) {
[09:30:03.280]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:03.280]                         if (muffled) 
[09:30:03.280]                           invokeRestart("muffleMessage")
[09:30:03.280]                       }
[09:30:03.280]                       else if (inherits(cond, "warning")) {
[09:30:03.280]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:03.280]                         if (muffled) 
[09:30:03.280]                           invokeRestart("muffleWarning")
[09:30:03.280]                       }
[09:30:03.280]                       else if (inherits(cond, "condition")) {
[09:30:03.280]                         if (!is.null(pattern)) {
[09:30:03.280]                           computeRestarts <- base::computeRestarts
[09:30:03.280]                           grepl <- base::grepl
[09:30:03.280]                           restarts <- computeRestarts(cond)
[09:30:03.280]                           for (restart in restarts) {
[09:30:03.280]                             name <- restart$name
[09:30:03.280]                             if (is.null(name)) 
[09:30:03.280]                               next
[09:30:03.280]                             if (!grepl(pattern, name)) 
[09:30:03.280]                               next
[09:30:03.280]                             invokeRestart(restart)
[09:30:03.280]                             muffled <- TRUE
[09:30:03.280]                             break
[09:30:03.280]                           }
[09:30:03.280]                         }
[09:30:03.280]                       }
[09:30:03.280]                       invisible(muffled)
[09:30:03.280]                     }
[09:30:03.280]                     muffleCondition(cond, pattern = "^muffle")
[09:30:03.280]                   }
[09:30:03.280]                 }
[09:30:03.280]             }
[09:30:03.280]         }))
[09:30:03.280]     }, error = function(ex) {
[09:30:03.280]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:03.280]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:03.280]                 ...future.rng), started = ...future.startTime, 
[09:30:03.280]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:03.280]             version = "1.8"), class = "FutureResult")
[09:30:03.280]     }, finally = {
[09:30:03.280]         if (!identical(...future.workdir, getwd())) 
[09:30:03.280]             setwd(...future.workdir)
[09:30:03.280]         {
[09:30:03.280]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:03.280]                 ...future.oldOptions$nwarnings <- NULL
[09:30:03.280]             }
[09:30:03.280]             base::options(...future.oldOptions)
[09:30:03.280]             if (.Platform$OS.type == "windows") {
[09:30:03.280]                 old_names <- names(...future.oldEnvVars)
[09:30:03.280]                 envs <- base::Sys.getenv()
[09:30:03.280]                 names <- names(envs)
[09:30:03.280]                 common <- intersect(names, old_names)
[09:30:03.280]                 added <- setdiff(names, old_names)
[09:30:03.280]                 removed <- setdiff(old_names, names)
[09:30:03.280]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:03.280]                   envs[common]]
[09:30:03.280]                 NAMES <- toupper(changed)
[09:30:03.280]                 args <- list()
[09:30:03.280]                 for (kk in seq_along(NAMES)) {
[09:30:03.280]                   name <- changed[[kk]]
[09:30:03.280]                   NAME <- NAMES[[kk]]
[09:30:03.280]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:03.280]                     next
[09:30:03.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:03.280]                 }
[09:30:03.280]                 NAMES <- toupper(added)
[09:30:03.280]                 for (kk in seq_along(NAMES)) {
[09:30:03.280]                   name <- added[[kk]]
[09:30:03.280]                   NAME <- NAMES[[kk]]
[09:30:03.280]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:03.280]                     next
[09:30:03.280]                   args[[name]] <- ""
[09:30:03.280]                 }
[09:30:03.280]                 NAMES <- toupper(removed)
[09:30:03.280]                 for (kk in seq_along(NAMES)) {
[09:30:03.280]                   name <- removed[[kk]]
[09:30:03.280]                   NAME <- NAMES[[kk]]
[09:30:03.280]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:03.280]                     next
[09:30:03.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:03.280]                 }
[09:30:03.280]                 if (length(args) > 0) 
[09:30:03.280]                   base::do.call(base::Sys.setenv, args = args)
[09:30:03.280]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:03.280]             }
[09:30:03.280]             else {
[09:30:03.280]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:03.280]             }
[09:30:03.280]             {
[09:30:03.280]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:03.280]                   0L) {
[09:30:03.280]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:03.280]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:03.280]                   base::options(opts)
[09:30:03.280]                 }
[09:30:03.280]                 {
[09:30:03.280]                   {
[09:30:03.280]                     NULL
[09:30:03.280]                     RNGkind("Mersenne-Twister")
[09:30:03.280]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:30:03.280]                       inherits = FALSE)
[09:30:03.280]                   }
[09:30:03.280]                   options(future.plan = NULL)
[09:30:03.280]                   if (is.na(NA_character_)) 
[09:30:03.280]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:03.280]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:03.280]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:03.280]                     .init = FALSE)
[09:30:03.280]                 }
[09:30:03.280]             }
[09:30:03.280]         }
[09:30:03.280]     })
[09:30:03.280]     if (TRUE) {
[09:30:03.280]         base::sink(type = "output", split = FALSE)
[09:30:03.280]         if (TRUE) {
[09:30:03.280]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:03.280]         }
[09:30:03.280]         else {
[09:30:03.280]             ...future.result["stdout"] <- base::list(NULL)
[09:30:03.280]         }
[09:30:03.280]         base::close(...future.stdout)
[09:30:03.280]         ...future.stdout <- NULL
[09:30:03.280]     }
[09:30:03.280]     ...future.result$conditions <- ...future.conditions
[09:30:03.280]     ...future.result$finished <- base::Sys.time()
[09:30:03.280]     ...future.result
[09:30:03.280] }
[09:30:03.282] assign_globals() ...
[09:30:03.282] List of 5
[09:30:03.282]  $ ...future.FUN            :function (x)  
[09:30:03.282]  $ future.call.arguments    : list()
[09:30:03.282]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:03.282]  $ ...future.elements_ii    :List of 2
[09:30:03.282]   ..$ : int 1
[09:30:03.282]   ..$ : int 0
[09:30:03.282]  $ ...future.seeds_ii       : NULL
[09:30:03.282]  $ ...future.globals.maxSize: NULL
[09:30:03.282]  - attr(*, "where")=List of 5
[09:30:03.282]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:03.282]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:30:03.282]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:03.282]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:03.282]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:03.282]  - attr(*, "resolved")= logi FALSE
[09:30:03.282]  - attr(*, "total_size")= num 4720
[09:30:03.282]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:03.282]  - attr(*, "already-done")= logi TRUE
[09:30:03.286] - reassign environment for ‘...future.FUN’
[09:30:03.286] - copied ‘...future.FUN’ to environment
[09:30:03.286] - copied ‘future.call.arguments’ to environment
[09:30:03.286] - copied ‘...future.elements_ii’ to environment
[09:30:03.287] - copied ‘...future.seeds_ii’ to environment
[09:30:03.287] - copied ‘...future.globals.maxSize’ to environment
[09:30:03.287] assign_globals() ... done
[09:30:03.287] plan(): Setting new future strategy stack:
[09:30:03.287] List of future strategies:
[09:30:03.287] 1. sequential:
[09:30:03.287]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:03.287]    - tweaked: FALSE
[09:30:03.287]    - call: NULL
[09:30:03.287] plan(): nbrOfWorkers() = 1
[09:30:03.789] plan(): Setting new future strategy stack:
[09:30:03.789] List of future strategies:
[09:30:03.789] 1. multicore:
[09:30:03.789]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:30:03.789]    - tweaked: FALSE
[09:30:03.789]    - call: plan(strategy)
[09:30:03.793] plan(): nbrOfWorkers() = 1
[09:30:03.793] SequentialFuture started (and completed)
[09:30:03.794] - Launch lazy future ... done
[09:30:03.794] run() for ‘SequentialFuture’ ... done
[09:30:03.794] Created future:
[09:30:03.794] SequentialFuture:
[09:30:03.794] Label: ‘future_lapply-1’
[09:30:03.794] Expression:
[09:30:03.794] {
[09:30:03.794]     do.call(function(...) {
[09:30:03.794]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:03.794]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:03.794]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:03.794]             on.exit(options(oopts), add = TRUE)
[09:30:03.794]         }
[09:30:03.794]         {
[09:30:03.794]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:03.794]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:03.794]                 ...future.FUN(...future.X_jj, ...)
[09:30:03.794]             })
[09:30:03.794]         }
[09:30:03.794]     }, args = future.call.arguments)
[09:30:03.794] }
[09:30:03.794] Lazy evaluation: FALSE
[09:30:03.794] Asynchronous evaluation: FALSE
[09:30:03.794] Local evaluation: TRUE
[09:30:03.794] Environment: R_GlobalEnv
[09:30:03.794] Capture standard output: TRUE
[09:30:03.794] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:03.794] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:03.794] Packages: <none>
[09:30:03.794] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:03.794] Resolved: TRUE
[09:30:03.794] Value: 112 bytes of class ‘list’
[09:30:03.794] Early signaling: FALSE
[09:30:03.794] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:03.794] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:03.795] Chunk #1 of 1 ... DONE
[09:30:03.795] Launching 1 futures (chunks) ... DONE
[09:30:03.795] Resolving 1 futures (chunks) ...
[09:30:03.795] resolve() on list ...
[09:30:03.795]  recursive: 0
[09:30:03.795]  length: 1
[09:30:03.796] 
[09:30:03.796] resolved() for ‘SequentialFuture’ ...
[09:30:03.796] - state: ‘finished’
[09:30:03.796] - run: TRUE
[09:30:03.796] - result: ‘FutureResult’
[09:30:03.796] resolved() for ‘SequentialFuture’ ... done
[09:30:03.796] Future #1
[09:30:03.796] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:30:03.796] - nx: 1
[09:30:03.797] - relay: TRUE
[09:30:03.797] - stdout: TRUE
[09:30:03.797] - signal: TRUE
[09:30:03.797] - resignal: FALSE
[09:30:03.797] - force: TRUE
[09:30:03.797] - relayed: [n=1] FALSE
[09:30:03.797] - queued futures: [n=1] FALSE
[09:30:03.797]  - until=1
[09:30:03.797]  - relaying element #1
[09:30:03.797] - relayed: [n=1] TRUE
[09:30:03.797] - queued futures: [n=1] TRUE
[09:30:03.798] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:30:03.798]  length: 0 (resolved future 1)
[09:30:03.798] Relaying remaining futures
[09:30:03.798] signalConditionsASAP(NULL, pos=0) ...
[09:30:03.798] - nx: 1
[09:30:03.798] - relay: TRUE
[09:30:03.798] - stdout: TRUE
[09:30:03.798] - signal: TRUE
[09:30:03.798] - resignal: FALSE
[09:30:03.798] - force: TRUE
[09:30:03.798] - relayed: [n=1] TRUE
[09:30:03.798] - queued futures: [n=1] TRUE
 - flush all
[09:30:03.799] - relayed: [n=1] TRUE
[09:30:03.799] - queued futures: [n=1] TRUE
[09:30:03.799] signalConditionsASAP(NULL, pos=0) ... done
[09:30:03.799] resolve() on list ... DONE
[09:30:03.799]  - Number of value chunks collected: 1
[09:30:03.799] Resolving 1 futures (chunks) ... DONE
[09:30:03.799] Reducing values from 1 chunks ...
[09:30:03.799]  - Number of values collected after concatenation: 2
[09:30:03.799]  - Number of values expected: 2
[09:30:03.799] Reducing values from 1 chunks ... DONE
[09:30:03.800] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[09:30:03.800] future_lapply() ...
[09:30:03.806] Number of chunks: 1
[09:30:03.806] getGlobalsAndPackagesXApply() ...
[09:30:03.806]  - future.globals: TRUE
[09:30:03.806] getGlobalsAndPackages() ...
[09:30:03.806] Searching for globals...
[09:30:03.807] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[09:30:03.808] Searching for globals ... DONE
[09:30:03.808] Resolving globals: FALSE
[09:30:03.808] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[09:30:03.809] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[09:30:03.809] - globals: [1] ‘FUN’
[09:30:03.809] 
[09:30:03.809] getGlobalsAndPackages() ... DONE
[09:30:03.809]  - globals found/used: [n=1] ‘FUN’
[09:30:03.809]  - needed namespaces: [n=0] 
[09:30:03.809] Finding globals ... DONE
[09:30:03.809]  - use_args: TRUE
[09:30:03.809]  - Getting '...' globals ...
[09:30:03.810] resolve() on list ...
[09:30:03.810]  recursive: 0
[09:30:03.810]  length: 1
[09:30:03.810]  elements: ‘...’
[09:30:03.810]  length: 0 (resolved future 1)
[09:30:03.810] resolve() on list ... DONE
[09:30:03.810]    - '...' content: [n=0] 
[09:30:03.810] List of 1
[09:30:03.810]  $ ...: list()
[09:30:03.810]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:03.810]  - attr(*, "where")=List of 1
[09:30:03.810]   ..$ ...:<environment: 0x55c1042ae500> 
[09:30:03.810]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:03.810]  - attr(*, "resolved")= logi TRUE
[09:30:03.810]  - attr(*, "total_size")= num NA
[09:30:03.813]  - Getting '...' globals ... DONE
[09:30:03.813] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:30:03.813] List of 2
[09:30:03.813]  $ ...future.FUN:function (x)  
[09:30:03.813]  $ ...          : list()
[09:30:03.813]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:03.813]  - attr(*, "where")=List of 2
[09:30:03.813]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:03.813]   ..$ ...          :<environment: 0x55c1042ae500> 
[09:30:03.813]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:03.813]  - attr(*, "resolved")= logi FALSE
[09:30:03.813]  - attr(*, "total_size")= num 4720
[09:30:03.816] Packages to be attached in all futures: [n=0] 
[09:30:03.816] getGlobalsAndPackagesXApply() ... DONE
[09:30:03.816] Number of futures (= number of chunks): 1
[09:30:03.816] Launching 1 futures (chunks) ...
[09:30:03.816] Chunk #1 of 1 ...
[09:30:03.816]  - Finding globals in 'X' for chunk #1 ...
[09:30:03.816] getGlobalsAndPackages() ...
[09:30:03.816] Searching for globals...
[09:30:03.817] 
[09:30:03.817] Searching for globals ... DONE
[09:30:03.817] - globals: [0] <none>
[09:30:03.817] getGlobalsAndPackages() ... DONE
[09:30:03.817]    + additional globals found: [n=0] 
[09:30:03.817]    + additional namespaces needed: [n=0] 
[09:30:03.818]  - Finding globals in 'X' for chunk #1 ... DONE
[09:30:03.818]  - seeds: <none>
[09:30:03.818]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:03.818] getGlobalsAndPackages() ...
[09:30:03.818] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:03.818] Resolving globals: FALSE
[09:30:03.818] Tweak future expression to call with '...' arguments ...
[09:30:03.818] {
[09:30:03.818]     do.call(function(...) {
[09:30:03.818]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:03.818]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:03.818]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:03.818]             on.exit(options(oopts), add = TRUE)
[09:30:03.818]         }
[09:30:03.818]         {
[09:30:03.818]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:03.818]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:03.818]                 ...future.FUN(...future.X_jj, ...)
[09:30:03.818]             })
[09:30:03.818]         }
[09:30:03.818]     }, args = future.call.arguments)
[09:30:03.818] }
[09:30:03.819] Tweak future expression to call with '...' arguments ... DONE
[09:30:03.819] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:03.819] 
[09:30:03.819] getGlobalsAndPackages() ... DONE
[09:30:03.820] run() for ‘Future’ ...
[09:30:03.820] - state: ‘created’
[09:30:03.820] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:30:03.824] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:03.824] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:30:03.824]   - Field: ‘label’
[09:30:03.825]   - Field: ‘local’
[09:30:03.825]   - Field: ‘owner’
[09:30:03.825]   - Field: ‘envir’
[09:30:03.825]   - Field: ‘packages’
[09:30:03.825]   - Field: ‘gc’
[09:30:03.825]   - Field: ‘conditions’
[09:30:03.825]   - Field: ‘expr’
[09:30:03.826]   - Field: ‘uuid’
[09:30:03.826]   - Field: ‘seed’
[09:30:03.826]   - Field: ‘version’
[09:30:03.826]   - Field: ‘result’
[09:30:03.826]   - Field: ‘asynchronous’
[09:30:03.826]   - Field: ‘calls’
[09:30:03.826]   - Field: ‘globals’
[09:30:03.826]   - Field: ‘stdout’
[09:30:03.827]   - Field: ‘earlySignal’
[09:30:03.827]   - Field: ‘lazy’
[09:30:03.827]   - Field: ‘state’
[09:30:03.827] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:30:03.827] - Launch lazy future ...
[09:30:03.827] Packages needed by the future expression (n = 0): <none>
[09:30:03.828] Packages needed by future strategies (n = 0): <none>
[09:30:03.828] {
[09:30:03.828]     {
[09:30:03.828]         {
[09:30:03.828]             ...future.startTime <- base::Sys.time()
[09:30:03.828]             {
[09:30:03.828]                 {
[09:30:03.828]                   {
[09:30:03.828]                     base::local({
[09:30:03.828]                       has_future <- base::requireNamespace("future", 
[09:30:03.828]                         quietly = TRUE)
[09:30:03.828]                       if (has_future) {
[09:30:03.828]                         ns <- base::getNamespace("future")
[09:30:03.828]                         version <- ns[[".package"]][["version"]]
[09:30:03.828]                         if (is.null(version)) 
[09:30:03.828]                           version <- utils::packageVersion("future")
[09:30:03.828]                       }
[09:30:03.828]                       else {
[09:30:03.828]                         version <- NULL
[09:30:03.828]                       }
[09:30:03.828]                       if (!has_future || version < "1.8.0") {
[09:30:03.828]                         info <- base::c(r_version = base::gsub("R version ", 
[09:30:03.828]                           "", base::R.version$version.string), 
[09:30:03.828]                           platform = base::sprintf("%s (%s-bit)", 
[09:30:03.828]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:03.828]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:03.828]                             "release", "version")], collapse = " "), 
[09:30:03.828]                           hostname = base::Sys.info()[["nodename"]])
[09:30:03.828]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:30:03.828]                           info)
[09:30:03.828]                         info <- base::paste(info, collapse = "; ")
[09:30:03.828]                         if (!has_future) {
[09:30:03.828]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:03.828]                             info)
[09:30:03.828]                         }
[09:30:03.828]                         else {
[09:30:03.828]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:03.828]                             info, version)
[09:30:03.828]                         }
[09:30:03.828]                         base::stop(msg)
[09:30:03.828]                       }
[09:30:03.828]                     })
[09:30:03.828]                   }
[09:30:03.828]                   ...future.strategy.old <- future::plan("list")
[09:30:03.828]                   options(future.plan = NULL)
[09:30:03.828]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:03.828]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:03.828]                 }
[09:30:03.828]                 ...future.workdir <- getwd()
[09:30:03.828]             }
[09:30:03.828]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:03.828]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:03.828]         }
[09:30:03.828]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:03.828]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:30:03.828]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:03.828]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:03.828]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:03.828]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:03.828]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:03.828]             base::names(...future.oldOptions))
[09:30:03.828]     }
[09:30:03.828]     if (TRUE) {
[09:30:03.828]     }
[09:30:03.828]     else {
[09:30:03.828]         if (NA) {
[09:30:03.828]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:03.828]                 open = "w")
[09:30:03.828]         }
[09:30:03.828]         else {
[09:30:03.828]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:03.828]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:03.828]         }
[09:30:03.828]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:03.828]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:03.828]             base::sink(type = "output", split = FALSE)
[09:30:03.828]             base::close(...future.stdout)
[09:30:03.828]         }, add = TRUE)
[09:30:03.828]     }
[09:30:03.828]     ...future.frame <- base::sys.nframe()
[09:30:03.828]     ...future.conditions <- base::list()
[09:30:03.828]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:03.828]     if (FALSE) {
[09:30:03.828]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:03.828]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:03.828]     }
[09:30:03.828]     ...future.result <- base::tryCatch({
[09:30:03.828]         base::withCallingHandlers({
[09:30:03.828]             ...future.value <- base::withVisible(base::local({
[09:30:03.828]                 do.call(function(...) {
[09:30:03.828]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:03.828]                   if (!identical(...future.globals.maxSize.org, 
[09:30:03.828]                     ...future.globals.maxSize)) {
[09:30:03.828]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:03.828]                     on.exit(options(oopts), add = TRUE)
[09:30:03.828]                   }
[09:30:03.828]                   {
[09:30:03.828]                     lapply(seq_along(...future.elements_ii), 
[09:30:03.828]                       FUN = function(jj) {
[09:30:03.828]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:03.828]                         ...future.FUN(...future.X_jj, ...)
[09:30:03.828]                       })
[09:30:03.828]                   }
[09:30:03.828]                 }, args = future.call.arguments)
[09:30:03.828]             }))
[09:30:03.828]             future::FutureResult(value = ...future.value$value, 
[09:30:03.828]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:03.828]                   ...future.rng), globalenv = if (FALSE) 
[09:30:03.828]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:03.828]                     ...future.globalenv.names))
[09:30:03.828]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:03.828]         }, condition = base::local({
[09:30:03.828]             c <- base::c
[09:30:03.828]             inherits <- base::inherits
[09:30:03.828]             invokeRestart <- base::invokeRestart
[09:30:03.828]             length <- base::length
[09:30:03.828]             list <- base::list
[09:30:03.828]             seq.int <- base::seq.int
[09:30:03.828]             signalCondition <- base::signalCondition
[09:30:03.828]             sys.calls <- base::sys.calls
[09:30:03.828]             `[[` <- base::`[[`
[09:30:03.828]             `+` <- base::`+`
[09:30:03.828]             `<<-` <- base::`<<-`
[09:30:03.828]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:03.828]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:03.828]                   3L)]
[09:30:03.828]             }
[09:30:03.828]             function(cond) {
[09:30:03.828]                 is_error <- inherits(cond, "error")
[09:30:03.828]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:03.828]                   NULL)
[09:30:03.828]                 if (is_error) {
[09:30:03.828]                   sessionInformation <- function() {
[09:30:03.828]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:03.828]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:03.828]                       search = base::search(), system = base::Sys.info())
[09:30:03.828]                   }
[09:30:03.828]                   ...future.conditions[[length(...future.conditions) + 
[09:30:03.828]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:03.828]                     cond$call), session = sessionInformation(), 
[09:30:03.828]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:03.828]                   signalCondition(cond)
[09:30:03.828]                 }
[09:30:03.828]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:03.828]                 "immediateCondition"))) {
[09:30:03.828]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:03.828]                   ...future.conditions[[length(...future.conditions) + 
[09:30:03.828]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:03.828]                   if (TRUE && !signal) {
[09:30:03.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:03.828]                     {
[09:30:03.828]                       inherits <- base::inherits
[09:30:03.828]                       invokeRestart <- base::invokeRestart
[09:30:03.828]                       is.null <- base::is.null
[09:30:03.828]                       muffled <- FALSE
[09:30:03.828]                       if (inherits(cond, "message")) {
[09:30:03.828]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:03.828]                         if (muffled) 
[09:30:03.828]                           invokeRestart("muffleMessage")
[09:30:03.828]                       }
[09:30:03.828]                       else if (inherits(cond, "warning")) {
[09:30:03.828]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:03.828]                         if (muffled) 
[09:30:03.828]                           invokeRestart("muffleWarning")
[09:30:03.828]                       }
[09:30:03.828]                       else if (inherits(cond, "condition")) {
[09:30:03.828]                         if (!is.null(pattern)) {
[09:30:03.828]                           computeRestarts <- base::computeRestarts
[09:30:03.828]                           grepl <- base::grepl
[09:30:03.828]                           restarts <- computeRestarts(cond)
[09:30:03.828]                           for (restart in restarts) {
[09:30:03.828]                             name <- restart$name
[09:30:03.828]                             if (is.null(name)) 
[09:30:03.828]                               next
[09:30:03.828]                             if (!grepl(pattern, name)) 
[09:30:03.828]                               next
[09:30:03.828]                             invokeRestart(restart)
[09:30:03.828]                             muffled <- TRUE
[09:30:03.828]                             break
[09:30:03.828]                           }
[09:30:03.828]                         }
[09:30:03.828]                       }
[09:30:03.828]                       invisible(muffled)
[09:30:03.828]                     }
[09:30:03.828]                     muffleCondition(cond, pattern = "^muffle")
[09:30:03.828]                   }
[09:30:03.828]                 }
[09:30:03.828]                 else {
[09:30:03.828]                   if (TRUE) {
[09:30:03.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:03.828]                     {
[09:30:03.828]                       inherits <- base::inherits
[09:30:03.828]                       invokeRestart <- base::invokeRestart
[09:30:03.828]                       is.null <- base::is.null
[09:30:03.828]                       muffled <- FALSE
[09:30:03.828]                       if (inherits(cond, "message")) {
[09:30:03.828]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:03.828]                         if (muffled) 
[09:30:03.828]                           invokeRestart("muffleMessage")
[09:30:03.828]                       }
[09:30:03.828]                       else if (inherits(cond, "warning")) {
[09:30:03.828]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:03.828]                         if (muffled) 
[09:30:03.828]                           invokeRestart("muffleWarning")
[09:30:03.828]                       }
[09:30:03.828]                       else if (inherits(cond, "condition")) {
[09:30:03.828]                         if (!is.null(pattern)) {
[09:30:03.828]                           computeRestarts <- base::computeRestarts
[09:30:03.828]                           grepl <- base::grepl
[09:30:03.828]                           restarts <- computeRestarts(cond)
[09:30:03.828]                           for (restart in restarts) {
[09:30:03.828]                             name <- restart$name
[09:30:03.828]                             if (is.null(name)) 
[09:30:03.828]                               next
[09:30:03.828]                             if (!grepl(pattern, name)) 
[09:30:03.828]                               next
[09:30:03.828]                             invokeRestart(restart)
[09:30:03.828]                             muffled <- TRUE
[09:30:03.828]                             break
[09:30:03.828]                           }
[09:30:03.828]                         }
[09:30:03.828]                       }
[09:30:03.828]                       invisible(muffled)
[09:30:03.828]                     }
[09:30:03.828]                     muffleCondition(cond, pattern = "^muffle")
[09:30:03.828]                   }
[09:30:03.828]                 }
[09:30:03.828]             }
[09:30:03.828]         }))
[09:30:03.828]     }, error = function(ex) {
[09:30:03.828]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:03.828]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:03.828]                 ...future.rng), started = ...future.startTime, 
[09:30:03.828]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:03.828]             version = "1.8"), class = "FutureResult")
[09:30:03.828]     }, finally = {
[09:30:03.828]         if (!identical(...future.workdir, getwd())) 
[09:30:03.828]             setwd(...future.workdir)
[09:30:03.828]         {
[09:30:03.828]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:03.828]                 ...future.oldOptions$nwarnings <- NULL
[09:30:03.828]             }
[09:30:03.828]             base::options(...future.oldOptions)
[09:30:03.828]             if (.Platform$OS.type == "windows") {
[09:30:03.828]                 old_names <- names(...future.oldEnvVars)
[09:30:03.828]                 envs <- base::Sys.getenv()
[09:30:03.828]                 names <- names(envs)
[09:30:03.828]                 common <- intersect(names, old_names)
[09:30:03.828]                 added <- setdiff(names, old_names)
[09:30:03.828]                 removed <- setdiff(old_names, names)
[09:30:03.828]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:03.828]                   envs[common]]
[09:30:03.828]                 NAMES <- toupper(changed)
[09:30:03.828]                 args <- list()
[09:30:03.828]                 for (kk in seq_along(NAMES)) {
[09:30:03.828]                   name <- changed[[kk]]
[09:30:03.828]                   NAME <- NAMES[[kk]]
[09:30:03.828]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:03.828]                     next
[09:30:03.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:03.828]                 }
[09:30:03.828]                 NAMES <- toupper(added)
[09:30:03.828]                 for (kk in seq_along(NAMES)) {
[09:30:03.828]                   name <- added[[kk]]
[09:30:03.828]                   NAME <- NAMES[[kk]]
[09:30:03.828]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:03.828]                     next
[09:30:03.828]                   args[[name]] <- ""
[09:30:03.828]                 }
[09:30:03.828]                 NAMES <- toupper(removed)
[09:30:03.828]                 for (kk in seq_along(NAMES)) {
[09:30:03.828]                   name <- removed[[kk]]
[09:30:03.828]                   NAME <- NAMES[[kk]]
[09:30:03.828]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:03.828]                     next
[09:30:03.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:03.828]                 }
[09:30:03.828]                 if (length(args) > 0) 
[09:30:03.828]                   base::do.call(base::Sys.setenv, args = args)
[09:30:03.828]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:03.828]             }
[09:30:03.828]             else {
[09:30:03.828]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:03.828]             }
[09:30:03.828]             {
[09:30:03.828]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:03.828]                   0L) {
[09:30:03.828]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:03.828]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:03.828]                   base::options(opts)
[09:30:03.828]                 }
[09:30:03.828]                 {
[09:30:03.828]                   {
[09:30:03.828]                     NULL
[09:30:03.828]                     RNGkind("Mersenne-Twister")
[09:30:03.828]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:30:03.828]                       inherits = FALSE)
[09:30:03.828]                   }
[09:30:03.828]                   options(future.plan = NULL)
[09:30:03.828]                   if (is.na(NA_character_)) 
[09:30:03.828]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:03.828]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:03.828]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:03.828]                     .init = FALSE)
[09:30:03.828]                 }
[09:30:03.828]             }
[09:30:03.828]         }
[09:30:03.828]     })
[09:30:03.828]     if (FALSE) {
[09:30:03.828]         base::sink(type = "output", split = FALSE)
[09:30:03.828]         if (NA) {
[09:30:03.828]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:03.828]         }
[09:30:03.828]         else {
[09:30:03.828]             ...future.result["stdout"] <- base::list(NULL)
[09:30:03.828]         }
[09:30:03.828]         base::close(...future.stdout)
[09:30:03.828]         ...future.stdout <- NULL
[09:30:03.828]     }
[09:30:03.828]     ...future.result$conditions <- ...future.conditions
[09:30:03.828]     ...future.result$finished <- base::Sys.time()
[09:30:03.828]     ...future.result
[09:30:03.828] }
[09:30:03.830] assign_globals() ...
[09:30:03.830] List of 5
[09:30:03.830]  $ ...future.FUN            :function (x)  
[09:30:03.830]  $ future.call.arguments    : list()
[09:30:03.830]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:03.830]  $ ...future.elements_ii    :List of 2
[09:30:03.830]   ..$ : int 1
[09:30:03.830]   ..$ : int 0
[09:30:03.830]  $ ...future.seeds_ii       : NULL
[09:30:03.830]  $ ...future.globals.maxSize: NULL
[09:30:03.830]  - attr(*, "where")=List of 5
[09:30:03.830]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:03.830]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:30:03.830]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:03.830]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:03.830]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:03.830]  - attr(*, "resolved")= logi FALSE
[09:30:03.830]  - attr(*, "total_size")= num 4720
[09:30:03.830]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:03.830]  - attr(*, "already-done")= logi TRUE
[09:30:03.839] - reassign environment for ‘...future.FUN’
[09:30:03.839] - copied ‘...future.FUN’ to environment
[09:30:03.839] - copied ‘future.call.arguments’ to environment
[09:30:03.839] - copied ‘...future.elements_ii’ to environment
[09:30:03.839] - copied ‘...future.seeds_ii’ to environment
[09:30:03.840] - copied ‘...future.globals.maxSize’ to environment
[09:30:03.840] assign_globals() ... done
[09:30:03.840] plan(): Setting new future strategy stack:
[09:30:03.840] List of future strategies:
[09:30:03.840] 1. sequential:
[09:30:03.840]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:03.840]    - tweaked: FALSE
[09:30:03.840]    - call: NULL
[09:30:03.841] plan(): nbrOfWorkers() = 1
[09:30:04.343] plan(): Setting new future strategy stack:
[09:30:04.343] List of future strategies:
[09:30:04.343] 1. multicore:
[09:30:04.343]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:30:04.343]    - tweaked: FALSE
[09:30:04.343]    - call: plan(strategy)
[09:30:04.347] plan(): nbrOfWorkers() = 1
[09:30:04.347] SequentialFuture started (and completed)
[09:30:04.348] - Launch lazy future ... done
[09:30:04.348] run() for ‘SequentialFuture’ ... done
[09:30:04.348] Created future:
[09:30:04.348] SequentialFuture:
[09:30:04.348] Label: ‘future_lapply-1’
[09:30:04.348] Expression:
[09:30:04.348] {
[09:30:04.348]     do.call(function(...) {
[09:30:04.348]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:04.348]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:04.348]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:04.348]             on.exit(options(oopts), add = TRUE)
[09:30:04.348]         }
[09:30:04.348]         {
[09:30:04.348]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:04.348]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:04.348]                 ...future.FUN(...future.X_jj, ...)
[09:30:04.348]             })
[09:30:04.348]         }
[09:30:04.348]     }, args = future.call.arguments)
[09:30:04.348] }
[09:30:04.348] Lazy evaluation: FALSE
[09:30:04.348] Asynchronous evaluation: FALSE
[09:30:04.348] Local evaluation: TRUE
[09:30:04.348] Environment: R_GlobalEnv
[09:30:04.348] Capture standard output: NA
[09:30:04.348] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:04.348] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:04.348] Packages: <none>
[09:30:04.348] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:04.348] Resolved: TRUE
[09:30:04.348] Value: 112 bytes of class ‘list’
[09:30:04.348] Early signaling: FALSE
[09:30:04.348] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:04.348] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:04.349] Chunk #1 of 1 ... DONE
[09:30:04.349] Launching 1 futures (chunks) ... DONE
[09:30:04.349] Resolving 1 futures (chunks) ...
[09:30:04.349] resolve() on list ...
[09:30:04.349]  recursive: 0
[09:30:04.349]  length: 1
[09:30:04.350] 
[09:30:04.350] resolved() for ‘SequentialFuture’ ...
[09:30:04.350] - state: ‘finished’
[09:30:04.350] - run: TRUE
[09:30:04.350] - result: ‘FutureResult’
[09:30:04.350] resolved() for ‘SequentialFuture’ ... done
[09:30:04.350] Future #1
[09:30:04.350] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:30:04.350] - nx: 1
[09:30:04.350] - relay: TRUE
[09:30:04.351] - stdout: TRUE
[09:30:04.351] - signal: TRUE
[09:30:04.351] - resignal: FALSE
[09:30:04.351] - force: TRUE
[09:30:04.351] - relayed: [n=1] FALSE
[09:30:04.351] - queued futures: [n=1] FALSE
[09:30:04.351]  - until=1
[09:30:04.351]  - relaying element #1
[09:30:04.351] - relayed: [n=1] TRUE
[09:30:04.351] - queued futures: [n=1] TRUE
[09:30:04.351] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:30:04.352]  length: 0 (resolved future 1)
[09:30:04.352] Relaying remaining futures
[09:30:04.352] signalConditionsASAP(NULL, pos=0) ...
[09:30:04.352] - nx: 1
[09:30:04.352] - relay: TRUE
[09:30:04.352] - stdout: TRUE
[09:30:04.352] - signal: TRUE
[09:30:04.352] - resignal: FALSE
[09:30:04.352] - force: TRUE
[09:30:04.352] - relayed: [n=1] TRUE
[09:30:04.352] - queued futures: [n=1] TRUE
 - flush all
[09:30:04.353] - relayed: [n=1] TRUE
[09:30:04.353] - queued futures: [n=1] TRUE
[09:30:04.353] signalConditionsASAP(NULL, pos=0) ... done
[09:30:04.353] resolve() on list ... DONE
[09:30:04.353]  - Number of value chunks collected: 1
[09:30:04.353] Resolving 1 futures (chunks) ... DONE
[09:30:04.353] Reducing values from 1 chunks ...
[09:30:04.353]  - Number of values collected after concatenation: 2
[09:30:04.353]  - Number of values expected: 2
[09:30:04.353] Reducing values from 1 chunks ... DONE
[09:30:04.354] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[09:30:04.354] future_mapply() ...
[09:30:04.357] Number of chunks: 1
[09:30:04.357] getGlobalsAndPackagesXApply() ...
[09:30:04.357]  - future.globals: TRUE
[09:30:04.357] getGlobalsAndPackages() ...
[09:30:04.358] Searching for globals...
[09:30:04.359] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[09:30:04.359] Searching for globals ... DONE
[09:30:04.359] Resolving globals: FALSE
[09:30:04.360] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[09:30:04.360] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[09:30:04.360] - globals: [1] ‘FUN’
[09:30:04.360] 
[09:30:04.360] getGlobalsAndPackages() ... DONE
[09:30:04.360]  - globals found/used: [n=1] ‘FUN’
[09:30:04.361]  - needed namespaces: [n=0] 
[09:30:04.361] Finding globals ... DONE
[09:30:04.361] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:30:04.361] List of 2
[09:30:04.361]  $ ...future.FUN:function (x, y)  
[09:30:04.361]  $ MoreArgs     : NULL
[09:30:04.361]  - attr(*, "where")=List of 2
[09:30:04.361]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:04.361]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:30:04.361]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:04.361]  - attr(*, "resolved")= logi FALSE
[09:30:04.361]  - attr(*, "total_size")= num NA
[09:30:04.363] Packages to be attached in all futures: [n=0] 
[09:30:04.363] getGlobalsAndPackagesXApply() ... DONE
[09:30:04.364] Number of futures (= number of chunks): 1
[09:30:04.364] Launching 1 futures (chunks) ...
[09:30:04.364] Chunk #1 of 1 ...
[09:30:04.364]  - Finding globals in '...' for chunk #1 ...
[09:30:04.364] getGlobalsAndPackages() ...
[09:30:04.364] Searching for globals...
[09:30:04.365] 
[09:30:04.365] Searching for globals ... DONE
[09:30:04.365] - globals: [0] <none>
[09:30:04.365] getGlobalsAndPackages() ... DONE
[09:30:04.365]    + additional globals found: [n=0] 
[09:30:04.365]    + additional namespaces needed: [n=0] 
[09:30:04.365]  - Finding globals in '...' for chunk #1 ... DONE
[09:30:04.365]  - seeds: <none>
[09:30:04.365]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:04.365] getGlobalsAndPackages() ...
[09:30:04.365] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:04.366] Resolving globals: FALSE
[09:30:04.366] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[09:30:04.366] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:30:04.366] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:04.367] 
[09:30:04.367] getGlobalsAndPackages() ... DONE
[09:30:04.367] run() for ‘Future’ ...
[09:30:04.367] - state: ‘created’
[09:30:04.367] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:30:04.372] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:04.373] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:30:04.373]   - Field: ‘label’
[09:30:04.373]   - Field: ‘local’
[09:30:04.373]   - Field: ‘owner’
[09:30:04.373]   - Field: ‘envir’
[09:30:04.373]   - Field: ‘packages’
[09:30:04.373]   - Field: ‘gc’
[09:30:04.373]   - Field: ‘conditions’
[09:30:04.373]   - Field: ‘expr’
[09:30:04.373]   - Field: ‘uuid’
[09:30:04.374]   - Field: ‘seed’
[09:30:04.374]   - Field: ‘version’
[09:30:04.374]   - Field: ‘result’
[09:30:04.374]   - Field: ‘asynchronous’
[09:30:04.374]   - Field: ‘calls’
[09:30:04.374]   - Field: ‘globals’
[09:30:04.374]   - Field: ‘stdout’
[09:30:04.374]   - Field: ‘earlySignal’
[09:30:04.374]   - Field: ‘lazy’
[09:30:04.374]   - Field: ‘state’
[09:30:04.374] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:30:04.375] - Launch lazy future ...
[09:30:04.375] Packages needed by the future expression (n = 0): <none>
[09:30:04.375] Packages needed by future strategies (n = 0): <none>
[09:30:04.375] {
[09:30:04.375]     {
[09:30:04.375]         {
[09:30:04.375]             ...future.startTime <- base::Sys.time()
[09:30:04.375]             {
[09:30:04.375]                 {
[09:30:04.375]                   {
[09:30:04.375]                     base::local({
[09:30:04.375]                       has_future <- base::requireNamespace("future", 
[09:30:04.375]                         quietly = TRUE)
[09:30:04.375]                       if (has_future) {
[09:30:04.375]                         ns <- base::getNamespace("future")
[09:30:04.375]                         version <- ns[[".package"]][["version"]]
[09:30:04.375]                         if (is.null(version)) 
[09:30:04.375]                           version <- utils::packageVersion("future")
[09:30:04.375]                       }
[09:30:04.375]                       else {
[09:30:04.375]                         version <- NULL
[09:30:04.375]                       }
[09:30:04.375]                       if (!has_future || version < "1.8.0") {
[09:30:04.375]                         info <- base::c(r_version = base::gsub("R version ", 
[09:30:04.375]                           "", base::R.version$version.string), 
[09:30:04.375]                           platform = base::sprintf("%s (%s-bit)", 
[09:30:04.375]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:04.375]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:04.375]                             "release", "version")], collapse = " "), 
[09:30:04.375]                           hostname = base::Sys.info()[["nodename"]])
[09:30:04.375]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:30:04.375]                           info)
[09:30:04.375]                         info <- base::paste(info, collapse = "; ")
[09:30:04.375]                         if (!has_future) {
[09:30:04.375]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:04.375]                             info)
[09:30:04.375]                         }
[09:30:04.375]                         else {
[09:30:04.375]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:04.375]                             info, version)
[09:30:04.375]                         }
[09:30:04.375]                         base::stop(msg)
[09:30:04.375]                       }
[09:30:04.375]                     })
[09:30:04.375]                   }
[09:30:04.375]                   ...future.strategy.old <- future::plan("list")
[09:30:04.375]                   options(future.plan = NULL)
[09:30:04.375]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:04.375]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:04.375]                 }
[09:30:04.375]                 ...future.workdir <- getwd()
[09:30:04.375]             }
[09:30:04.375]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:04.375]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:04.375]         }
[09:30:04.375]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:04.375]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:30:04.375]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:04.375]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:04.375]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:04.375]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:04.375]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:04.375]             base::names(...future.oldOptions))
[09:30:04.375]     }
[09:30:04.375]     if (FALSE) {
[09:30:04.375]     }
[09:30:04.375]     else {
[09:30:04.375]         if (FALSE) {
[09:30:04.375]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:04.375]                 open = "w")
[09:30:04.375]         }
[09:30:04.375]         else {
[09:30:04.375]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:04.375]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:04.375]         }
[09:30:04.375]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:04.375]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:04.375]             base::sink(type = "output", split = FALSE)
[09:30:04.375]             base::close(...future.stdout)
[09:30:04.375]         }, add = TRUE)
[09:30:04.375]     }
[09:30:04.375]     ...future.frame <- base::sys.nframe()
[09:30:04.375]     ...future.conditions <- base::list()
[09:30:04.375]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:04.375]     if (FALSE) {
[09:30:04.375]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:04.375]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:04.375]     }
[09:30:04.375]     ...future.result <- base::tryCatch({
[09:30:04.375]         base::withCallingHandlers({
[09:30:04.375]             ...future.value <- base::withVisible(base::local({
[09:30:04.375]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:04.375]                 if (!identical(...future.globals.maxSize.org, 
[09:30:04.375]                   ...future.globals.maxSize)) {
[09:30:04.375]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:04.375]                   on.exit(options(oopts), add = TRUE)
[09:30:04.375]                 }
[09:30:04.375]                 {
[09:30:04.375]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:04.375]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:30:04.375]                     USE.NAMES = FALSE)
[09:30:04.375]                   do.call(mapply, args = args)
[09:30:04.375]                 }
[09:30:04.375]             }))
[09:30:04.375]             future::FutureResult(value = ...future.value$value, 
[09:30:04.375]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:04.375]                   ...future.rng), globalenv = if (FALSE) 
[09:30:04.375]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:04.375]                     ...future.globalenv.names))
[09:30:04.375]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:04.375]         }, condition = base::local({
[09:30:04.375]             c <- base::c
[09:30:04.375]             inherits <- base::inherits
[09:30:04.375]             invokeRestart <- base::invokeRestart
[09:30:04.375]             length <- base::length
[09:30:04.375]             list <- base::list
[09:30:04.375]             seq.int <- base::seq.int
[09:30:04.375]             signalCondition <- base::signalCondition
[09:30:04.375]             sys.calls <- base::sys.calls
[09:30:04.375]             `[[` <- base::`[[`
[09:30:04.375]             `+` <- base::`+`
[09:30:04.375]             `<<-` <- base::`<<-`
[09:30:04.375]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:04.375]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:04.375]                   3L)]
[09:30:04.375]             }
[09:30:04.375]             function(cond) {
[09:30:04.375]                 is_error <- inherits(cond, "error")
[09:30:04.375]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:04.375]                   NULL)
[09:30:04.375]                 if (is_error) {
[09:30:04.375]                   sessionInformation <- function() {
[09:30:04.375]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:04.375]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:04.375]                       search = base::search(), system = base::Sys.info())
[09:30:04.375]                   }
[09:30:04.375]                   ...future.conditions[[length(...future.conditions) + 
[09:30:04.375]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:04.375]                     cond$call), session = sessionInformation(), 
[09:30:04.375]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:04.375]                   signalCondition(cond)
[09:30:04.375]                 }
[09:30:04.375]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:04.375]                 "immediateCondition"))) {
[09:30:04.375]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:04.375]                   ...future.conditions[[length(...future.conditions) + 
[09:30:04.375]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:04.375]                   if (TRUE && !signal) {
[09:30:04.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:04.375]                     {
[09:30:04.375]                       inherits <- base::inherits
[09:30:04.375]                       invokeRestart <- base::invokeRestart
[09:30:04.375]                       is.null <- base::is.null
[09:30:04.375]                       muffled <- FALSE
[09:30:04.375]                       if (inherits(cond, "message")) {
[09:30:04.375]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:04.375]                         if (muffled) 
[09:30:04.375]                           invokeRestart("muffleMessage")
[09:30:04.375]                       }
[09:30:04.375]                       else if (inherits(cond, "warning")) {
[09:30:04.375]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:04.375]                         if (muffled) 
[09:30:04.375]                           invokeRestart("muffleWarning")
[09:30:04.375]                       }
[09:30:04.375]                       else if (inherits(cond, "condition")) {
[09:30:04.375]                         if (!is.null(pattern)) {
[09:30:04.375]                           computeRestarts <- base::computeRestarts
[09:30:04.375]                           grepl <- base::grepl
[09:30:04.375]                           restarts <- computeRestarts(cond)
[09:30:04.375]                           for (restart in restarts) {
[09:30:04.375]                             name <- restart$name
[09:30:04.375]                             if (is.null(name)) 
[09:30:04.375]                               next
[09:30:04.375]                             if (!grepl(pattern, name)) 
[09:30:04.375]                               next
[09:30:04.375]                             invokeRestart(restart)
[09:30:04.375]                             muffled <- TRUE
[09:30:04.375]                             break
[09:30:04.375]                           }
[09:30:04.375]                         }
[09:30:04.375]                       }
[09:30:04.375]                       invisible(muffled)
[09:30:04.375]                     }
[09:30:04.375]                     muffleCondition(cond, pattern = "^muffle")
[09:30:04.375]                   }
[09:30:04.375]                 }
[09:30:04.375]                 else {
[09:30:04.375]                   if (TRUE) {
[09:30:04.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:04.375]                     {
[09:30:04.375]                       inherits <- base::inherits
[09:30:04.375]                       invokeRestart <- base::invokeRestart
[09:30:04.375]                       is.null <- base::is.null
[09:30:04.375]                       muffled <- FALSE
[09:30:04.375]                       if (inherits(cond, "message")) {
[09:30:04.375]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:04.375]                         if (muffled) 
[09:30:04.375]                           invokeRestart("muffleMessage")
[09:30:04.375]                       }
[09:30:04.375]                       else if (inherits(cond, "warning")) {
[09:30:04.375]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:04.375]                         if (muffled) 
[09:30:04.375]                           invokeRestart("muffleWarning")
[09:30:04.375]                       }
[09:30:04.375]                       else if (inherits(cond, "condition")) {
[09:30:04.375]                         if (!is.null(pattern)) {
[09:30:04.375]                           computeRestarts <- base::computeRestarts
[09:30:04.375]                           grepl <- base::grepl
[09:30:04.375]                           restarts <- computeRestarts(cond)
[09:30:04.375]                           for (restart in restarts) {
[09:30:04.375]                             name <- restart$name
[09:30:04.375]                             if (is.null(name)) 
[09:30:04.375]                               next
[09:30:04.375]                             if (!grepl(pattern, name)) 
[09:30:04.375]                               next
[09:30:04.375]                             invokeRestart(restart)
[09:30:04.375]                             muffled <- TRUE
[09:30:04.375]                             break
[09:30:04.375]                           }
[09:30:04.375]                         }
[09:30:04.375]                       }
[09:30:04.375]                       invisible(muffled)
[09:30:04.375]                     }
[09:30:04.375]                     muffleCondition(cond, pattern = "^muffle")
[09:30:04.375]                   }
[09:30:04.375]                 }
[09:30:04.375]             }
[09:30:04.375]         }))
[09:30:04.375]     }, error = function(ex) {
[09:30:04.375]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:04.375]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:04.375]                 ...future.rng), started = ...future.startTime, 
[09:30:04.375]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:04.375]             version = "1.8"), class = "FutureResult")
[09:30:04.375]     }, finally = {
[09:30:04.375]         if (!identical(...future.workdir, getwd())) 
[09:30:04.375]             setwd(...future.workdir)
[09:30:04.375]         {
[09:30:04.375]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:04.375]                 ...future.oldOptions$nwarnings <- NULL
[09:30:04.375]             }
[09:30:04.375]             base::options(...future.oldOptions)
[09:30:04.375]             if (.Platform$OS.type == "windows") {
[09:30:04.375]                 old_names <- names(...future.oldEnvVars)
[09:30:04.375]                 envs <- base::Sys.getenv()
[09:30:04.375]                 names <- names(envs)
[09:30:04.375]                 common <- intersect(names, old_names)
[09:30:04.375]                 added <- setdiff(names, old_names)
[09:30:04.375]                 removed <- setdiff(old_names, names)
[09:30:04.375]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:04.375]                   envs[common]]
[09:30:04.375]                 NAMES <- toupper(changed)
[09:30:04.375]                 args <- list()
[09:30:04.375]                 for (kk in seq_along(NAMES)) {
[09:30:04.375]                   name <- changed[[kk]]
[09:30:04.375]                   NAME <- NAMES[[kk]]
[09:30:04.375]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:04.375]                     next
[09:30:04.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:04.375]                 }
[09:30:04.375]                 NAMES <- toupper(added)
[09:30:04.375]                 for (kk in seq_along(NAMES)) {
[09:30:04.375]                   name <- added[[kk]]
[09:30:04.375]                   NAME <- NAMES[[kk]]
[09:30:04.375]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:04.375]                     next
[09:30:04.375]                   args[[name]] <- ""
[09:30:04.375]                 }
[09:30:04.375]                 NAMES <- toupper(removed)
[09:30:04.375]                 for (kk in seq_along(NAMES)) {
[09:30:04.375]                   name <- removed[[kk]]
[09:30:04.375]                   NAME <- NAMES[[kk]]
[09:30:04.375]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:04.375]                     next
[09:30:04.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:04.375]                 }
[09:30:04.375]                 if (length(args) > 0) 
[09:30:04.375]                   base::do.call(base::Sys.setenv, args = args)
[09:30:04.375]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:04.375]             }
[09:30:04.375]             else {
[09:30:04.375]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:04.375]             }
[09:30:04.375]             {
[09:30:04.375]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:04.375]                   0L) {
[09:30:04.375]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:04.375]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:04.375]                   base::options(opts)
[09:30:04.375]                 }
[09:30:04.375]                 {
[09:30:04.375]                   {
[09:30:04.375]                     NULL
[09:30:04.375]                     RNGkind("Mersenne-Twister")
[09:30:04.375]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:30:04.375]                       inherits = FALSE)
[09:30:04.375]                   }
[09:30:04.375]                   options(future.plan = NULL)
[09:30:04.375]                   if (is.na(NA_character_)) 
[09:30:04.375]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:04.375]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:04.375]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:04.375]                     .init = FALSE)
[09:30:04.375]                 }
[09:30:04.375]             }
[09:30:04.375]         }
[09:30:04.375]     })
[09:30:04.375]     if (TRUE) {
[09:30:04.375]         base::sink(type = "output", split = FALSE)
[09:30:04.375]         if (FALSE) {
[09:30:04.375]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:04.375]         }
[09:30:04.375]         else {
[09:30:04.375]             ...future.result["stdout"] <- base::list(NULL)
[09:30:04.375]         }
[09:30:04.375]         base::close(...future.stdout)
[09:30:04.375]         ...future.stdout <- NULL
[09:30:04.375]     }
[09:30:04.375]     ...future.result$conditions <- ...future.conditions
[09:30:04.375]     ...future.result$finished <- base::Sys.time()
[09:30:04.375]     ...future.result
[09:30:04.375] }
[09:30:04.377] assign_globals() ...
[09:30:04.377] List of 5
[09:30:04.377]  $ ...future.FUN            :function (x, y)  
[09:30:04.377]  $ MoreArgs                 : NULL
[09:30:04.377]  $ ...future.elements_ii    :List of 2
[09:30:04.377]   ..$ :List of 2
[09:30:04.377]   .. ..$ : int 1
[09:30:04.377]   .. ..$ : int 0
[09:30:04.377]   ..$ :List of 2
[09:30:04.377]   .. ..$ : int 0
[09:30:04.377]   .. ..$ : int 1
[09:30:04.377]  $ ...future.seeds_ii       : NULL
[09:30:04.377]  $ ...future.globals.maxSize: NULL
[09:30:04.377]  - attr(*, "where")=List of 5
[09:30:04.377]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:04.377]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:30:04.377]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:04.377]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:04.377]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:04.377]  - attr(*, "resolved")= logi FALSE
[09:30:04.377]  - attr(*, "total_size")= num 6480
[09:30:04.377]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:04.377]  - attr(*, "already-done")= logi TRUE
[09:30:04.382] - reassign environment for ‘...future.FUN’
[09:30:04.382] - copied ‘...future.FUN’ to environment
[09:30:04.383] - copied ‘MoreArgs’ to environment
[09:30:04.383] - copied ‘...future.elements_ii’ to environment
[09:30:04.383] - copied ‘...future.seeds_ii’ to environment
[09:30:04.383] - copied ‘...future.globals.maxSize’ to environment
[09:30:04.383] assign_globals() ... done
[09:30:04.383] plan(): Setting new future strategy stack:
[09:30:04.383] List of future strategies:
[09:30:04.383] 1. sequential:
[09:30:04.383]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:04.383]    - tweaked: FALSE
[09:30:04.383]    - call: NULL
[09:30:04.384] plan(): nbrOfWorkers() = 1
[09:30:04.885] plan(): Setting new future strategy stack:
[09:30:04.885] List of future strategies:
[09:30:04.885] 1. multicore:
[09:30:04.885]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:30:04.885]    - tweaked: FALSE
[09:30:04.885]    - call: plan(strategy)
[09:30:04.889] plan(): nbrOfWorkers() = 1
[09:30:04.889] SequentialFuture started (and completed)
[09:30:04.889] - Launch lazy future ... done
[09:30:04.890] run() for ‘SequentialFuture’ ... done
[09:30:04.890] Created future:
[09:30:04.890] SequentialFuture:
[09:30:04.890] Label: ‘future_mapply-1’
[09:30:04.890] Expression:
[09:30:04.890] {
[09:30:04.890]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:04.890]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:04.890]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:04.890]         on.exit(options(oopts), add = TRUE)
[09:30:04.890]     }
[09:30:04.890]     {
[09:30:04.890]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:04.890]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:30:04.890]         do.call(mapply, args = args)
[09:30:04.890]     }
[09:30:04.890] }
[09:30:04.890] Lazy evaluation: FALSE
[09:30:04.890] Asynchronous evaluation: FALSE
[09:30:04.890] Local evaluation: TRUE
[09:30:04.890] Environment: R_GlobalEnv
[09:30:04.890] Capture standard output: FALSE
[09:30:04.890] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:04.890] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:04.890] Packages: <none>
[09:30:04.890] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:04.890] Resolved: TRUE
[09:30:04.890] Value: 224 bytes of class ‘list’
[09:30:04.890] Early signaling: FALSE
[09:30:04.890] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:04.890] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:04.891] Chunk #1 of 1 ... DONE
[09:30:04.891] Launching 1 futures (chunks) ... DONE
[09:30:04.891] Resolving 1 futures (chunks) ...
[09:30:04.891] resolve() on list ...
[09:30:04.891]  recursive: 0
[09:30:04.891]  length: 1
[09:30:04.891] 
[09:30:04.891] resolved() for ‘SequentialFuture’ ...
[09:30:04.892] - state: ‘finished’
[09:30:04.892] - run: TRUE
[09:30:04.892] - result: ‘FutureResult’
[09:30:04.892] resolved() for ‘SequentialFuture’ ... done
[09:30:04.892] Future #1
[09:30:04.892] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:30:04.892] - nx: 1
[09:30:04.892] - relay: TRUE
[09:30:04.892] - stdout: TRUE
[09:30:04.892] - signal: TRUE
[09:30:04.893] - resignal: FALSE
[09:30:04.893] - force: TRUE
[09:30:04.893] - relayed: [n=1] FALSE
[09:30:04.893] - queued futures: [n=1] FALSE
[09:30:04.893]  - until=1
[09:30:04.893]  - relaying element #1
[09:30:04.893] - relayed: [n=1] TRUE
[09:30:04.893] - queued futures: [n=1] TRUE
[09:30:04.893] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:30:04.893]  length: 0 (resolved future 1)
[09:30:04.893] Relaying remaining futures
[09:30:04.894] signalConditionsASAP(NULL, pos=0) ...
[09:30:04.894] - nx: 1
[09:30:04.894] - relay: TRUE
[09:30:04.894] - stdout: TRUE
[09:30:04.894] - signal: TRUE
[09:30:04.894] - resignal: FALSE
[09:30:04.894] - force: TRUE
[09:30:04.894] - relayed: [n=1] TRUE
[09:30:04.894] - queued futures: [n=1] TRUE
 - flush all
[09:30:04.894] - relayed: [n=1] TRUE
[09:30:04.894] - queued futures: [n=1] TRUE
[09:30:04.895] signalConditionsASAP(NULL, pos=0) ... done
[09:30:04.895] resolve() on list ... DONE
[09:30:04.895]  - Number of value chunks collected: 1
[09:30:04.895] Resolving 1 futures (chunks) ... DONE
[09:30:04.895] Reducing values from 1 chunks ...
[09:30:04.895]  - Number of values collected after concatenation: 2
[09:30:04.895]  - Number of values expected: 2
[09:30:04.895] Reducing values from 1 chunks ... DONE
[09:30:04.895] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[09:30:04.896] future_mapply() ...
[09:30:04.899] Number of chunks: 1
[09:30:04.899] getGlobalsAndPackagesXApply() ...
[09:30:04.899]  - future.globals: TRUE
[09:30:04.899] getGlobalsAndPackages() ...
[09:30:04.899] Searching for globals...
[09:30:04.901] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[09:30:04.901] Searching for globals ... DONE
[09:30:04.901] Resolving globals: FALSE
[09:30:04.901] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[09:30:04.904] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[09:30:04.904] - globals: [1] ‘FUN’
[09:30:04.904] 
[09:30:04.904] getGlobalsAndPackages() ... DONE
[09:30:04.904]  - globals found/used: [n=1] ‘FUN’
[09:30:04.904]  - needed namespaces: [n=0] 
[09:30:04.904] Finding globals ... DONE
[09:30:04.905] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:30:04.905] List of 2
[09:30:04.905]  $ ...future.FUN:function (x, y)  
[09:30:04.905]  $ MoreArgs     : NULL
[09:30:04.905]  - attr(*, "where")=List of 2
[09:30:04.905]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:04.905]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:30:04.905]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:04.905]  - attr(*, "resolved")= logi FALSE
[09:30:04.905]  - attr(*, "total_size")= num NA
[09:30:04.907] Packages to be attached in all futures: [n=0] 
[09:30:04.907] getGlobalsAndPackagesXApply() ... DONE
[09:30:04.907] Number of futures (= number of chunks): 1
[09:30:04.908] Launching 1 futures (chunks) ...
[09:30:04.908] Chunk #1 of 1 ...
[09:30:04.908]  - Finding globals in '...' for chunk #1 ...
[09:30:04.908] getGlobalsAndPackages() ...
[09:30:04.908] Searching for globals...
[09:30:04.908] 
[09:30:04.908] Searching for globals ... DONE
[09:30:04.908] - globals: [0] <none>
[09:30:04.908] getGlobalsAndPackages() ... DONE
[09:30:04.909]    + additional globals found: [n=0] 
[09:30:04.909]    + additional namespaces needed: [n=0] 
[09:30:04.909]  - Finding globals in '...' for chunk #1 ... DONE
[09:30:04.909]  - seeds: <none>
[09:30:04.909]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:04.909] getGlobalsAndPackages() ...
[09:30:04.909] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:04.909] Resolving globals: FALSE
[09:30:04.910] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[09:30:04.910] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:30:04.910] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:04.910] 
[09:30:04.910] getGlobalsAndPackages() ... DONE
[09:30:04.911] run() for ‘Future’ ...
[09:30:04.911] - state: ‘created’
[09:30:04.911] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:30:04.914] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:04.914] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:30:04.915]   - Field: ‘label’
[09:30:04.915]   - Field: ‘local’
[09:30:04.915]   - Field: ‘owner’
[09:30:04.915]   - Field: ‘envir’
[09:30:04.915]   - Field: ‘packages’
[09:30:04.915]   - Field: ‘gc’
[09:30:04.915]   - Field: ‘conditions’
[09:30:04.915]   - Field: ‘expr’
[09:30:04.915]   - Field: ‘uuid’
[09:30:04.915]   - Field: ‘seed’
[09:30:04.915]   - Field: ‘version’
[09:30:04.916]   - Field: ‘result’
[09:30:04.916]   - Field: ‘asynchronous’
[09:30:04.916]   - Field: ‘calls’
[09:30:04.916]   - Field: ‘globals’
[09:30:04.916]   - Field: ‘stdout’
[09:30:04.916]   - Field: ‘earlySignal’
[09:30:04.916]   - Field: ‘lazy’
[09:30:04.916]   - Field: ‘state’
[09:30:04.916] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:30:04.916] - Launch lazy future ...
[09:30:04.917] Packages needed by the future expression (n = 0): <none>
[09:30:04.917] Packages needed by future strategies (n = 0): <none>
[09:30:04.917] {
[09:30:04.917]     {
[09:30:04.917]         {
[09:30:04.917]             ...future.startTime <- base::Sys.time()
[09:30:04.917]             {
[09:30:04.917]                 {
[09:30:04.917]                   {
[09:30:04.917]                     base::local({
[09:30:04.917]                       has_future <- base::requireNamespace("future", 
[09:30:04.917]                         quietly = TRUE)
[09:30:04.917]                       if (has_future) {
[09:30:04.917]                         ns <- base::getNamespace("future")
[09:30:04.917]                         version <- ns[[".package"]][["version"]]
[09:30:04.917]                         if (is.null(version)) 
[09:30:04.917]                           version <- utils::packageVersion("future")
[09:30:04.917]                       }
[09:30:04.917]                       else {
[09:30:04.917]                         version <- NULL
[09:30:04.917]                       }
[09:30:04.917]                       if (!has_future || version < "1.8.0") {
[09:30:04.917]                         info <- base::c(r_version = base::gsub("R version ", 
[09:30:04.917]                           "", base::R.version$version.string), 
[09:30:04.917]                           platform = base::sprintf("%s (%s-bit)", 
[09:30:04.917]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:04.917]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:04.917]                             "release", "version")], collapse = " "), 
[09:30:04.917]                           hostname = base::Sys.info()[["nodename"]])
[09:30:04.917]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:30:04.917]                           info)
[09:30:04.917]                         info <- base::paste(info, collapse = "; ")
[09:30:04.917]                         if (!has_future) {
[09:30:04.917]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:04.917]                             info)
[09:30:04.917]                         }
[09:30:04.917]                         else {
[09:30:04.917]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:04.917]                             info, version)
[09:30:04.917]                         }
[09:30:04.917]                         base::stop(msg)
[09:30:04.917]                       }
[09:30:04.917]                     })
[09:30:04.917]                   }
[09:30:04.917]                   ...future.strategy.old <- future::plan("list")
[09:30:04.917]                   options(future.plan = NULL)
[09:30:04.917]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:04.917]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:04.917]                 }
[09:30:04.917]                 ...future.workdir <- getwd()
[09:30:04.917]             }
[09:30:04.917]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:04.917]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:04.917]         }
[09:30:04.917]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:04.917]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:30:04.917]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:04.917]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:04.917]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:04.917]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:04.917]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:04.917]             base::names(...future.oldOptions))
[09:30:04.917]     }
[09:30:04.917]     if (FALSE) {
[09:30:04.917]     }
[09:30:04.917]     else {
[09:30:04.917]         if (TRUE) {
[09:30:04.917]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:04.917]                 open = "w")
[09:30:04.917]         }
[09:30:04.917]         else {
[09:30:04.917]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:04.917]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:04.917]         }
[09:30:04.917]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:04.917]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:04.917]             base::sink(type = "output", split = FALSE)
[09:30:04.917]             base::close(...future.stdout)
[09:30:04.917]         }, add = TRUE)
[09:30:04.917]     }
[09:30:04.917]     ...future.frame <- base::sys.nframe()
[09:30:04.917]     ...future.conditions <- base::list()
[09:30:04.917]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:04.917]     if (FALSE) {
[09:30:04.917]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:04.917]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:04.917]     }
[09:30:04.917]     ...future.result <- base::tryCatch({
[09:30:04.917]         base::withCallingHandlers({
[09:30:04.917]             ...future.value <- base::withVisible(base::local({
[09:30:04.917]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:04.917]                 if (!identical(...future.globals.maxSize.org, 
[09:30:04.917]                   ...future.globals.maxSize)) {
[09:30:04.917]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:04.917]                   on.exit(options(oopts), add = TRUE)
[09:30:04.917]                 }
[09:30:04.917]                 {
[09:30:04.917]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:04.917]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:30:04.917]                     USE.NAMES = FALSE)
[09:30:04.917]                   do.call(mapply, args = args)
[09:30:04.917]                 }
[09:30:04.917]             }))
[09:30:04.917]             future::FutureResult(value = ...future.value$value, 
[09:30:04.917]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:04.917]                   ...future.rng), globalenv = if (FALSE) 
[09:30:04.917]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:04.917]                     ...future.globalenv.names))
[09:30:04.917]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:04.917]         }, condition = base::local({
[09:30:04.917]             c <- base::c
[09:30:04.917]             inherits <- base::inherits
[09:30:04.917]             invokeRestart <- base::invokeRestart
[09:30:04.917]             length <- base::length
[09:30:04.917]             list <- base::list
[09:30:04.917]             seq.int <- base::seq.int
[09:30:04.917]             signalCondition <- base::signalCondition
[09:30:04.917]             sys.calls <- base::sys.calls
[09:30:04.917]             `[[` <- base::`[[`
[09:30:04.917]             `+` <- base::`+`
[09:30:04.917]             `<<-` <- base::`<<-`
[09:30:04.917]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:04.917]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:04.917]                   3L)]
[09:30:04.917]             }
[09:30:04.917]             function(cond) {
[09:30:04.917]                 is_error <- inherits(cond, "error")
[09:30:04.917]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:04.917]                   NULL)
[09:30:04.917]                 if (is_error) {
[09:30:04.917]                   sessionInformation <- function() {
[09:30:04.917]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:04.917]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:04.917]                       search = base::search(), system = base::Sys.info())
[09:30:04.917]                   }
[09:30:04.917]                   ...future.conditions[[length(...future.conditions) + 
[09:30:04.917]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:04.917]                     cond$call), session = sessionInformation(), 
[09:30:04.917]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:04.917]                   signalCondition(cond)
[09:30:04.917]                 }
[09:30:04.917]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:04.917]                 "immediateCondition"))) {
[09:30:04.917]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:04.917]                   ...future.conditions[[length(...future.conditions) + 
[09:30:04.917]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:04.917]                   if (TRUE && !signal) {
[09:30:04.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:04.917]                     {
[09:30:04.917]                       inherits <- base::inherits
[09:30:04.917]                       invokeRestart <- base::invokeRestart
[09:30:04.917]                       is.null <- base::is.null
[09:30:04.917]                       muffled <- FALSE
[09:30:04.917]                       if (inherits(cond, "message")) {
[09:30:04.917]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:04.917]                         if (muffled) 
[09:30:04.917]                           invokeRestart("muffleMessage")
[09:30:04.917]                       }
[09:30:04.917]                       else if (inherits(cond, "warning")) {
[09:30:04.917]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:04.917]                         if (muffled) 
[09:30:04.917]                           invokeRestart("muffleWarning")
[09:30:04.917]                       }
[09:30:04.917]                       else if (inherits(cond, "condition")) {
[09:30:04.917]                         if (!is.null(pattern)) {
[09:30:04.917]                           computeRestarts <- base::computeRestarts
[09:30:04.917]                           grepl <- base::grepl
[09:30:04.917]                           restarts <- computeRestarts(cond)
[09:30:04.917]                           for (restart in restarts) {
[09:30:04.917]                             name <- restart$name
[09:30:04.917]                             if (is.null(name)) 
[09:30:04.917]                               next
[09:30:04.917]                             if (!grepl(pattern, name)) 
[09:30:04.917]                               next
[09:30:04.917]                             invokeRestart(restart)
[09:30:04.917]                             muffled <- TRUE
[09:30:04.917]                             break
[09:30:04.917]                           }
[09:30:04.917]                         }
[09:30:04.917]                       }
[09:30:04.917]                       invisible(muffled)
[09:30:04.917]                     }
[09:30:04.917]                     muffleCondition(cond, pattern = "^muffle")
[09:30:04.917]                   }
[09:30:04.917]                 }
[09:30:04.917]                 else {
[09:30:04.917]                   if (TRUE) {
[09:30:04.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:04.917]                     {
[09:30:04.917]                       inherits <- base::inherits
[09:30:04.917]                       invokeRestart <- base::invokeRestart
[09:30:04.917]                       is.null <- base::is.null
[09:30:04.917]                       muffled <- FALSE
[09:30:04.917]                       if (inherits(cond, "message")) {
[09:30:04.917]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:04.917]                         if (muffled) 
[09:30:04.917]                           invokeRestart("muffleMessage")
[09:30:04.917]                       }
[09:30:04.917]                       else if (inherits(cond, "warning")) {
[09:30:04.917]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:04.917]                         if (muffled) 
[09:30:04.917]                           invokeRestart("muffleWarning")
[09:30:04.917]                       }
[09:30:04.917]                       else if (inherits(cond, "condition")) {
[09:30:04.917]                         if (!is.null(pattern)) {
[09:30:04.917]                           computeRestarts <- base::computeRestarts
[09:30:04.917]                           grepl <- base::grepl
[09:30:04.917]                           restarts <- computeRestarts(cond)
[09:30:04.917]                           for (restart in restarts) {
[09:30:04.917]                             name <- restart$name
[09:30:04.917]                             if (is.null(name)) 
[09:30:04.917]                               next
[09:30:04.917]                             if (!grepl(pattern, name)) 
[09:30:04.917]                               next
[09:30:04.917]                             invokeRestart(restart)
[09:30:04.917]                             muffled <- TRUE
[09:30:04.917]                             break
[09:30:04.917]                           }
[09:30:04.917]                         }
[09:30:04.917]                       }
[09:30:04.917]                       invisible(muffled)
[09:30:04.917]                     }
[09:30:04.917]                     muffleCondition(cond, pattern = "^muffle")
[09:30:04.917]                   }
[09:30:04.917]                 }
[09:30:04.917]             }
[09:30:04.917]         }))
[09:30:04.917]     }, error = function(ex) {
[09:30:04.917]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:04.917]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:04.917]                 ...future.rng), started = ...future.startTime, 
[09:30:04.917]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:04.917]             version = "1.8"), class = "FutureResult")
[09:30:04.917]     }, finally = {
[09:30:04.917]         if (!identical(...future.workdir, getwd())) 
[09:30:04.917]             setwd(...future.workdir)
[09:30:04.917]         {
[09:30:04.917]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:04.917]                 ...future.oldOptions$nwarnings <- NULL
[09:30:04.917]             }
[09:30:04.917]             base::options(...future.oldOptions)
[09:30:04.917]             if (.Platform$OS.type == "windows") {
[09:30:04.917]                 old_names <- names(...future.oldEnvVars)
[09:30:04.917]                 envs <- base::Sys.getenv()
[09:30:04.917]                 names <- names(envs)
[09:30:04.917]                 common <- intersect(names, old_names)
[09:30:04.917]                 added <- setdiff(names, old_names)
[09:30:04.917]                 removed <- setdiff(old_names, names)
[09:30:04.917]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:04.917]                   envs[common]]
[09:30:04.917]                 NAMES <- toupper(changed)
[09:30:04.917]                 args <- list()
[09:30:04.917]                 for (kk in seq_along(NAMES)) {
[09:30:04.917]                   name <- changed[[kk]]
[09:30:04.917]                   NAME <- NAMES[[kk]]
[09:30:04.917]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:04.917]                     next
[09:30:04.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:04.917]                 }
[09:30:04.917]                 NAMES <- toupper(added)
[09:30:04.917]                 for (kk in seq_along(NAMES)) {
[09:30:04.917]                   name <- added[[kk]]
[09:30:04.917]                   NAME <- NAMES[[kk]]
[09:30:04.917]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:04.917]                     next
[09:30:04.917]                   args[[name]] <- ""
[09:30:04.917]                 }
[09:30:04.917]                 NAMES <- toupper(removed)
[09:30:04.917]                 for (kk in seq_along(NAMES)) {
[09:30:04.917]                   name <- removed[[kk]]
[09:30:04.917]                   NAME <- NAMES[[kk]]
[09:30:04.917]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:04.917]                     next
[09:30:04.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:04.917]                 }
[09:30:04.917]                 if (length(args) > 0) 
[09:30:04.917]                   base::do.call(base::Sys.setenv, args = args)
[09:30:04.917]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:04.917]             }
[09:30:04.917]             else {
[09:30:04.917]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:04.917]             }
[09:30:04.917]             {
[09:30:04.917]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:04.917]                   0L) {
[09:30:04.917]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:04.917]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:04.917]                   base::options(opts)
[09:30:04.917]                 }
[09:30:04.917]                 {
[09:30:04.917]                   {
[09:30:04.917]                     NULL
[09:30:04.917]                     RNGkind("Mersenne-Twister")
[09:30:04.917]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:30:04.917]                       inherits = FALSE)
[09:30:04.917]                   }
[09:30:04.917]                   options(future.plan = NULL)
[09:30:04.917]                   if (is.na(NA_character_)) 
[09:30:04.917]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:04.917]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:04.917]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:04.917]                     .init = FALSE)
[09:30:04.917]                 }
[09:30:04.917]             }
[09:30:04.917]         }
[09:30:04.917]     })
[09:30:04.917]     if (TRUE) {
[09:30:04.917]         base::sink(type = "output", split = FALSE)
[09:30:04.917]         if (TRUE) {
[09:30:04.917]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:04.917]         }
[09:30:04.917]         else {
[09:30:04.917]             ...future.result["stdout"] <- base::list(NULL)
[09:30:04.917]         }
[09:30:04.917]         base::close(...future.stdout)
[09:30:04.917]         ...future.stdout <- NULL
[09:30:04.917]     }
[09:30:04.917]     ...future.result$conditions <- ...future.conditions
[09:30:04.917]     ...future.result$finished <- base::Sys.time()
[09:30:04.917]     ...future.result
[09:30:04.917] }
[09:30:04.919] assign_globals() ...
[09:30:04.919] List of 5
[09:30:04.919]  $ ...future.FUN            :function (x, y)  
[09:30:04.919]  $ MoreArgs                 : NULL
[09:30:04.919]  $ ...future.elements_ii    :List of 2
[09:30:04.919]   ..$ :List of 2
[09:30:04.919]   .. ..$ : int 1
[09:30:04.919]   .. ..$ : int 0
[09:30:04.919]   ..$ :List of 2
[09:30:04.919]   .. ..$ : int 0
[09:30:04.919]   .. ..$ : int 1
[09:30:04.919]  $ ...future.seeds_ii       : NULL
[09:30:04.919]  $ ...future.globals.maxSize: NULL
[09:30:04.919]  - attr(*, "where")=List of 5
[09:30:04.919]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:04.919]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:30:04.919]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:04.919]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:04.919]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:04.919]  - attr(*, "resolved")= logi FALSE
[09:30:04.919]  - attr(*, "total_size")= num 6480
[09:30:04.919]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:04.919]  - attr(*, "already-done")= logi TRUE
[09:30:04.924] - reassign environment for ‘...future.FUN’
[09:30:04.924] - copied ‘...future.FUN’ to environment
[09:30:04.924] - copied ‘MoreArgs’ to environment
[09:30:04.924] - copied ‘...future.elements_ii’ to environment
[09:30:04.924] - copied ‘...future.seeds_ii’ to environment
[09:30:04.924] - copied ‘...future.globals.maxSize’ to environment
[09:30:04.925] assign_globals() ... done
[09:30:04.925] plan(): Setting new future strategy stack:
[09:30:04.925] List of future strategies:
[09:30:04.925] 1. sequential:
[09:30:04.925]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:04.925]    - tweaked: FALSE
[09:30:04.925]    - call: NULL
[09:30:04.925] plan(): nbrOfWorkers() = 1
[09:30:05.427] plan(): Setting new future strategy stack:
[09:30:05.427] List of future strategies:
[09:30:05.427] 1. multicore:
[09:30:05.427]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:30:05.427]    - tweaked: FALSE
[09:30:05.427]    - call: plan(strategy)
[09:30:05.431] plan(): nbrOfWorkers() = 1
[09:30:05.431] SequentialFuture started (and completed)
[09:30:05.431] - Launch lazy future ... done
[09:30:05.431] run() for ‘SequentialFuture’ ... done
[09:30:05.432] Created future:
[09:30:05.432] SequentialFuture:
[09:30:05.432] Label: ‘future_mapply-1’
[09:30:05.432] Expression:
[09:30:05.432] {
[09:30:05.432]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:05.432]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:05.432]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:05.432]         on.exit(options(oopts), add = TRUE)
[09:30:05.432]     }
[09:30:05.432]     {
[09:30:05.432]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:05.432]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:30:05.432]         do.call(mapply, args = args)
[09:30:05.432]     }
[09:30:05.432] }
[09:30:05.432] Lazy evaluation: FALSE
[09:30:05.432] Asynchronous evaluation: FALSE
[09:30:05.432] Local evaluation: TRUE
[09:30:05.432] Environment: R_GlobalEnv
[09:30:05.432] Capture standard output: TRUE
[09:30:05.432] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:05.432] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:05.432] Packages: <none>
[09:30:05.432] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:05.432] Resolved: TRUE
[09:30:05.432] Value: 224 bytes of class ‘list’
[09:30:05.432] Early signaling: FALSE
[09:30:05.432] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:05.432] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:05.433] Chunk #1 of 1 ... DONE
[09:30:05.433] Launching 1 futures (chunks) ... DONE
[09:30:05.433] Resolving 1 futures (chunks) ...
[09:30:05.433] resolve() on list ...
[09:30:05.433]  recursive: 0
[09:30:05.433]  length: 1
[09:30:05.435] 
[09:30:05.435] resolved() for ‘SequentialFuture’ ...
[09:30:05.435] - state: ‘finished’
[09:30:05.435] - run: TRUE
[09:30:05.435] - result: ‘FutureResult’
[09:30:05.436] resolved() for ‘SequentialFuture’ ... done
[09:30:05.436] Future #1
[09:30:05.436] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:30:05.436] - nx: 1
[09:30:05.436] - relay: TRUE
[09:30:05.436] - stdout: TRUE
[09:30:05.436] - signal: TRUE
[09:30:05.436] - resignal: FALSE
[09:30:05.436] - force: TRUE
[09:30:05.436] - relayed: [n=1] FALSE
[09:30:05.436] - queued futures: [n=1] FALSE
[09:30:05.437]  - until=1
[09:30:05.437]  - relaying element #1
[09:30:05.437] - relayed: [n=1] TRUE
[09:30:05.437] - queued futures: [n=1] TRUE
[09:30:05.437] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:30:05.437]  length: 0 (resolved future 1)
[09:30:05.437] Relaying remaining futures
[09:30:05.437] signalConditionsASAP(NULL, pos=0) ...
[09:30:05.437] - nx: 1
[09:30:05.438] - relay: TRUE
[09:30:05.438] - stdout: TRUE
[09:30:05.438] - signal: TRUE
[09:30:05.438] - resignal: FALSE
[09:30:05.438] - force: TRUE
[09:30:05.438] - relayed: [n=1] TRUE
[09:30:05.438] - queued futures: [n=1] TRUE
 - flush all
[09:30:05.438] - relayed: [n=1] TRUE
[09:30:05.438] - queued futures: [n=1] TRUE
[09:30:05.438] signalConditionsASAP(NULL, pos=0) ... done
[09:30:05.438] resolve() on list ... DONE
[09:30:05.439]  - Number of value chunks collected: 1
[09:30:05.439] Resolving 1 futures (chunks) ... DONE
[09:30:05.439] Reducing values from 1 chunks ...
[09:30:05.439]  - Number of values collected after concatenation: 2
[09:30:05.439]  - Number of values expected: 2
[09:30:05.439] Reducing values from 1 chunks ... DONE
[09:30:05.439] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[09:30:05.439] future_mapply() ...
[09:30:05.443] Number of chunks: 1
[09:30:05.443] getGlobalsAndPackagesXApply() ...
[09:30:05.443]  - future.globals: TRUE
[09:30:05.443] getGlobalsAndPackages() ...
[09:30:05.443] Searching for globals...
[09:30:05.444] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[09:30:05.445] Searching for globals ... DONE
[09:30:05.445] Resolving globals: FALSE
[09:30:05.445] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[09:30:05.445] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[09:30:05.446] - globals: [1] ‘FUN’
[09:30:05.446] 
[09:30:05.446] getGlobalsAndPackages() ... DONE
[09:30:05.446]  - globals found/used: [n=1] ‘FUN’
[09:30:05.446]  - needed namespaces: [n=0] 
[09:30:05.446] Finding globals ... DONE
[09:30:05.446] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:30:05.446] List of 2
[09:30:05.446]  $ ...future.FUN:function (x, y)  
[09:30:05.446]  $ MoreArgs     : NULL
[09:30:05.446]  - attr(*, "where")=List of 2
[09:30:05.446]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:05.446]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:30:05.446]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:05.446]  - attr(*, "resolved")= logi FALSE
[09:30:05.446]  - attr(*, "total_size")= num NA
[09:30:05.449] Packages to be attached in all futures: [n=0] 
[09:30:05.449] getGlobalsAndPackagesXApply() ... DONE
[09:30:05.449] Number of futures (= number of chunks): 1
[09:30:05.449] Launching 1 futures (chunks) ...
[09:30:05.449] Chunk #1 of 1 ...
[09:30:05.449]  - Finding globals in '...' for chunk #1 ...
[09:30:05.449] getGlobalsAndPackages() ...
[09:30:05.450] Searching for globals...
[09:30:05.450] 
[09:30:05.450] Searching for globals ... DONE
[09:30:05.450] - globals: [0] <none>
[09:30:05.450] getGlobalsAndPackages() ... DONE
[09:30:05.450]    + additional globals found: [n=0] 
[09:30:05.450]    + additional namespaces needed: [n=0] 
[09:30:05.450]  - Finding globals in '...' for chunk #1 ... DONE
[09:30:05.450]  - seeds: <none>
[09:30:05.451]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:05.451] getGlobalsAndPackages() ...
[09:30:05.451] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:05.451] Resolving globals: FALSE
[09:30:05.451] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[09:30:05.452] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:30:05.452] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:05.452] 
[09:30:05.452] getGlobalsAndPackages() ... DONE
[09:30:05.452] run() for ‘Future’ ...
[09:30:05.452] - state: ‘created’
[09:30:05.453] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:30:05.456] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:05.456] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:30:05.456]   - Field: ‘label’
[09:30:05.456]   - Field: ‘local’
[09:30:05.456]   - Field: ‘owner’
[09:30:05.456]   - Field: ‘envir’
[09:30:05.457]   - Field: ‘packages’
[09:30:05.457]   - Field: ‘gc’
[09:30:05.457]   - Field: ‘conditions’
[09:30:05.457]   - Field: ‘expr’
[09:30:05.457]   - Field: ‘uuid’
[09:30:05.457]   - Field: ‘seed’
[09:30:05.457]   - Field: ‘version’
[09:30:05.457]   - Field: ‘result’
[09:30:05.457]   - Field: ‘asynchronous’
[09:30:05.457]   - Field: ‘calls’
[09:30:05.457]   - Field: ‘globals’
[09:30:05.458]   - Field: ‘stdout’
[09:30:05.458]   - Field: ‘earlySignal’
[09:30:05.458]   - Field: ‘lazy’
[09:30:05.458]   - Field: ‘state’
[09:30:05.458] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:30:05.458] - Launch lazy future ...
[09:30:05.458] Packages needed by the future expression (n = 0): <none>
[09:30:05.458] Packages needed by future strategies (n = 0): <none>
[09:30:05.459] {
[09:30:05.459]     {
[09:30:05.459]         {
[09:30:05.459]             ...future.startTime <- base::Sys.time()
[09:30:05.459]             {
[09:30:05.459]                 {
[09:30:05.459]                   {
[09:30:05.459]                     base::local({
[09:30:05.459]                       has_future <- base::requireNamespace("future", 
[09:30:05.459]                         quietly = TRUE)
[09:30:05.459]                       if (has_future) {
[09:30:05.459]                         ns <- base::getNamespace("future")
[09:30:05.459]                         version <- ns[[".package"]][["version"]]
[09:30:05.459]                         if (is.null(version)) 
[09:30:05.459]                           version <- utils::packageVersion("future")
[09:30:05.459]                       }
[09:30:05.459]                       else {
[09:30:05.459]                         version <- NULL
[09:30:05.459]                       }
[09:30:05.459]                       if (!has_future || version < "1.8.0") {
[09:30:05.459]                         info <- base::c(r_version = base::gsub("R version ", 
[09:30:05.459]                           "", base::R.version$version.string), 
[09:30:05.459]                           platform = base::sprintf("%s (%s-bit)", 
[09:30:05.459]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:05.459]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:05.459]                             "release", "version")], collapse = " "), 
[09:30:05.459]                           hostname = base::Sys.info()[["nodename"]])
[09:30:05.459]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:30:05.459]                           info)
[09:30:05.459]                         info <- base::paste(info, collapse = "; ")
[09:30:05.459]                         if (!has_future) {
[09:30:05.459]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:05.459]                             info)
[09:30:05.459]                         }
[09:30:05.459]                         else {
[09:30:05.459]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:05.459]                             info, version)
[09:30:05.459]                         }
[09:30:05.459]                         base::stop(msg)
[09:30:05.459]                       }
[09:30:05.459]                     })
[09:30:05.459]                   }
[09:30:05.459]                   ...future.strategy.old <- future::plan("list")
[09:30:05.459]                   options(future.plan = NULL)
[09:30:05.459]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:05.459]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:05.459]                 }
[09:30:05.459]                 ...future.workdir <- getwd()
[09:30:05.459]             }
[09:30:05.459]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:05.459]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:05.459]         }
[09:30:05.459]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:05.459]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:30:05.459]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:05.459]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:05.459]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:05.459]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:05.459]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:05.459]             base::names(...future.oldOptions))
[09:30:05.459]     }
[09:30:05.459]     if (TRUE) {
[09:30:05.459]     }
[09:30:05.459]     else {
[09:30:05.459]         if (NA) {
[09:30:05.459]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:05.459]                 open = "w")
[09:30:05.459]         }
[09:30:05.459]         else {
[09:30:05.459]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:05.459]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:05.459]         }
[09:30:05.459]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:05.459]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:05.459]             base::sink(type = "output", split = FALSE)
[09:30:05.459]             base::close(...future.stdout)
[09:30:05.459]         }, add = TRUE)
[09:30:05.459]     }
[09:30:05.459]     ...future.frame <- base::sys.nframe()
[09:30:05.459]     ...future.conditions <- base::list()
[09:30:05.459]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:05.459]     if (FALSE) {
[09:30:05.459]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:05.459]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:05.459]     }
[09:30:05.459]     ...future.result <- base::tryCatch({
[09:30:05.459]         base::withCallingHandlers({
[09:30:05.459]             ...future.value <- base::withVisible(base::local({
[09:30:05.459]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:05.459]                 if (!identical(...future.globals.maxSize.org, 
[09:30:05.459]                   ...future.globals.maxSize)) {
[09:30:05.459]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:05.459]                   on.exit(options(oopts), add = TRUE)
[09:30:05.459]                 }
[09:30:05.459]                 {
[09:30:05.459]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:05.459]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:30:05.459]                     USE.NAMES = FALSE)
[09:30:05.459]                   do.call(mapply, args = args)
[09:30:05.459]                 }
[09:30:05.459]             }))
[09:30:05.459]             future::FutureResult(value = ...future.value$value, 
[09:30:05.459]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:05.459]                   ...future.rng), globalenv = if (FALSE) 
[09:30:05.459]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:05.459]                     ...future.globalenv.names))
[09:30:05.459]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:05.459]         }, condition = base::local({
[09:30:05.459]             c <- base::c
[09:30:05.459]             inherits <- base::inherits
[09:30:05.459]             invokeRestart <- base::invokeRestart
[09:30:05.459]             length <- base::length
[09:30:05.459]             list <- base::list
[09:30:05.459]             seq.int <- base::seq.int
[09:30:05.459]             signalCondition <- base::signalCondition
[09:30:05.459]             sys.calls <- base::sys.calls
[09:30:05.459]             `[[` <- base::`[[`
[09:30:05.459]             `+` <- base::`+`
[09:30:05.459]             `<<-` <- base::`<<-`
[09:30:05.459]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:05.459]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:05.459]                   3L)]
[09:30:05.459]             }
[09:30:05.459]             function(cond) {
[09:30:05.459]                 is_error <- inherits(cond, "error")
[09:30:05.459]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:05.459]                   NULL)
[09:30:05.459]                 if (is_error) {
[09:30:05.459]                   sessionInformation <- function() {
[09:30:05.459]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:05.459]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:05.459]                       search = base::search(), system = base::Sys.info())
[09:30:05.459]                   }
[09:30:05.459]                   ...future.conditions[[length(...future.conditions) + 
[09:30:05.459]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:05.459]                     cond$call), session = sessionInformation(), 
[09:30:05.459]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:05.459]                   signalCondition(cond)
[09:30:05.459]                 }
[09:30:05.459]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:05.459]                 "immediateCondition"))) {
[09:30:05.459]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:05.459]                   ...future.conditions[[length(...future.conditions) + 
[09:30:05.459]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:05.459]                   if (TRUE && !signal) {
[09:30:05.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:05.459]                     {
[09:30:05.459]                       inherits <- base::inherits
[09:30:05.459]                       invokeRestart <- base::invokeRestart
[09:30:05.459]                       is.null <- base::is.null
[09:30:05.459]                       muffled <- FALSE
[09:30:05.459]                       if (inherits(cond, "message")) {
[09:30:05.459]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:05.459]                         if (muffled) 
[09:30:05.459]                           invokeRestart("muffleMessage")
[09:30:05.459]                       }
[09:30:05.459]                       else if (inherits(cond, "warning")) {
[09:30:05.459]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:05.459]                         if (muffled) 
[09:30:05.459]                           invokeRestart("muffleWarning")
[09:30:05.459]                       }
[09:30:05.459]                       else if (inherits(cond, "condition")) {
[09:30:05.459]                         if (!is.null(pattern)) {
[09:30:05.459]                           computeRestarts <- base::computeRestarts
[09:30:05.459]                           grepl <- base::grepl
[09:30:05.459]                           restarts <- computeRestarts(cond)
[09:30:05.459]                           for (restart in restarts) {
[09:30:05.459]                             name <- restart$name
[09:30:05.459]                             if (is.null(name)) 
[09:30:05.459]                               next
[09:30:05.459]                             if (!grepl(pattern, name)) 
[09:30:05.459]                               next
[09:30:05.459]                             invokeRestart(restart)
[09:30:05.459]                             muffled <- TRUE
[09:30:05.459]                             break
[09:30:05.459]                           }
[09:30:05.459]                         }
[09:30:05.459]                       }
[09:30:05.459]                       invisible(muffled)
[09:30:05.459]                     }
[09:30:05.459]                     muffleCondition(cond, pattern = "^muffle")
[09:30:05.459]                   }
[09:30:05.459]                 }
[09:30:05.459]                 else {
[09:30:05.459]                   if (TRUE) {
[09:30:05.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:05.459]                     {
[09:30:05.459]                       inherits <- base::inherits
[09:30:05.459]                       invokeRestart <- base::invokeRestart
[09:30:05.459]                       is.null <- base::is.null
[09:30:05.459]                       muffled <- FALSE
[09:30:05.459]                       if (inherits(cond, "message")) {
[09:30:05.459]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:05.459]                         if (muffled) 
[09:30:05.459]                           invokeRestart("muffleMessage")
[09:30:05.459]                       }
[09:30:05.459]                       else if (inherits(cond, "warning")) {
[09:30:05.459]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:05.459]                         if (muffled) 
[09:30:05.459]                           invokeRestart("muffleWarning")
[09:30:05.459]                       }
[09:30:05.459]                       else if (inherits(cond, "condition")) {
[09:30:05.459]                         if (!is.null(pattern)) {
[09:30:05.459]                           computeRestarts <- base::computeRestarts
[09:30:05.459]                           grepl <- base::grepl
[09:30:05.459]                           restarts <- computeRestarts(cond)
[09:30:05.459]                           for (restart in restarts) {
[09:30:05.459]                             name <- restart$name
[09:30:05.459]                             if (is.null(name)) 
[09:30:05.459]                               next
[09:30:05.459]                             if (!grepl(pattern, name)) 
[09:30:05.459]                               next
[09:30:05.459]                             invokeRestart(restart)
[09:30:05.459]                             muffled <- TRUE
[09:30:05.459]                             break
[09:30:05.459]                           }
[09:30:05.459]                         }
[09:30:05.459]                       }
[09:30:05.459]                       invisible(muffled)
[09:30:05.459]                     }
[09:30:05.459]                     muffleCondition(cond, pattern = "^muffle")
[09:30:05.459]                   }
[09:30:05.459]                 }
[09:30:05.459]             }
[09:30:05.459]         }))
[09:30:05.459]     }, error = function(ex) {
[09:30:05.459]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:05.459]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:05.459]                 ...future.rng), started = ...future.startTime, 
[09:30:05.459]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:05.459]             version = "1.8"), class = "FutureResult")
[09:30:05.459]     }, finally = {
[09:30:05.459]         if (!identical(...future.workdir, getwd())) 
[09:30:05.459]             setwd(...future.workdir)
[09:30:05.459]         {
[09:30:05.459]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:05.459]                 ...future.oldOptions$nwarnings <- NULL
[09:30:05.459]             }
[09:30:05.459]             base::options(...future.oldOptions)
[09:30:05.459]             if (.Platform$OS.type == "windows") {
[09:30:05.459]                 old_names <- names(...future.oldEnvVars)
[09:30:05.459]                 envs <- base::Sys.getenv()
[09:30:05.459]                 names <- names(envs)
[09:30:05.459]                 common <- intersect(names, old_names)
[09:30:05.459]                 added <- setdiff(names, old_names)
[09:30:05.459]                 removed <- setdiff(old_names, names)
[09:30:05.459]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:05.459]                   envs[common]]
[09:30:05.459]                 NAMES <- toupper(changed)
[09:30:05.459]                 args <- list()
[09:30:05.459]                 for (kk in seq_along(NAMES)) {
[09:30:05.459]                   name <- changed[[kk]]
[09:30:05.459]                   NAME <- NAMES[[kk]]
[09:30:05.459]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:05.459]                     next
[09:30:05.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:05.459]                 }
[09:30:05.459]                 NAMES <- toupper(added)
[09:30:05.459]                 for (kk in seq_along(NAMES)) {
[09:30:05.459]                   name <- added[[kk]]
[09:30:05.459]                   NAME <- NAMES[[kk]]
[09:30:05.459]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:05.459]                     next
[09:30:05.459]                   args[[name]] <- ""
[09:30:05.459]                 }
[09:30:05.459]                 NAMES <- toupper(removed)
[09:30:05.459]                 for (kk in seq_along(NAMES)) {
[09:30:05.459]                   name <- removed[[kk]]
[09:30:05.459]                   NAME <- NAMES[[kk]]
[09:30:05.459]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:05.459]                     next
[09:30:05.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:05.459]                 }
[09:30:05.459]                 if (length(args) > 0) 
[09:30:05.459]                   base::do.call(base::Sys.setenv, args = args)
[09:30:05.459]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:05.459]             }
[09:30:05.459]             else {
[09:30:05.459]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:05.459]             }
[09:30:05.459]             {
[09:30:05.459]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:05.459]                   0L) {
[09:30:05.459]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:05.459]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:05.459]                   base::options(opts)
[09:30:05.459]                 }
[09:30:05.459]                 {
[09:30:05.459]                   {
[09:30:05.459]                     NULL
[09:30:05.459]                     RNGkind("Mersenne-Twister")
[09:30:05.459]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:30:05.459]                       inherits = FALSE)
[09:30:05.459]                   }
[09:30:05.459]                   options(future.plan = NULL)
[09:30:05.459]                   if (is.na(NA_character_)) 
[09:30:05.459]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:05.459]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:05.459]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:05.459]                     .init = FALSE)
[09:30:05.459]                 }
[09:30:05.459]             }
[09:30:05.459]         }
[09:30:05.459]     })
[09:30:05.459]     if (FALSE) {
[09:30:05.459]         base::sink(type = "output", split = FALSE)
[09:30:05.459]         if (NA) {
[09:30:05.459]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:05.459]         }
[09:30:05.459]         else {
[09:30:05.459]             ...future.result["stdout"] <- base::list(NULL)
[09:30:05.459]         }
[09:30:05.459]         base::close(...future.stdout)
[09:30:05.459]         ...future.stdout <- NULL
[09:30:05.459]     }
[09:30:05.459]     ...future.result$conditions <- ...future.conditions
[09:30:05.459]     ...future.result$finished <- base::Sys.time()
[09:30:05.459]     ...future.result
[09:30:05.459] }
[09:30:05.460] assign_globals() ...
[09:30:05.460] List of 5
[09:30:05.460]  $ ...future.FUN            :function (x, y)  
[09:30:05.460]  $ MoreArgs                 : NULL
[09:30:05.460]  $ ...future.elements_ii    :List of 2
[09:30:05.460]   ..$ :List of 2
[09:30:05.460]   .. ..$ : int 1
[09:30:05.460]   .. ..$ : int 0
[09:30:05.460]   ..$ :List of 2
[09:30:05.460]   .. ..$ : int 0
[09:30:05.460]   .. ..$ : int 1
[09:30:05.460]  $ ...future.seeds_ii       : NULL
[09:30:05.460]  $ ...future.globals.maxSize: NULL
[09:30:05.460]  - attr(*, "where")=List of 5
[09:30:05.460]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:05.460]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:30:05.460]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:05.460]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:05.460]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:05.460]  - attr(*, "resolved")= logi FALSE
[09:30:05.460]  - attr(*, "total_size")= num 6480
[09:30:05.460]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:05.460]  - attr(*, "already-done")= logi TRUE
[09:30:05.467] - reassign environment for ‘...future.FUN’
[09:30:05.467] - copied ‘...future.FUN’ to environment
[09:30:05.467] - copied ‘MoreArgs’ to environment
[09:30:05.467] - copied ‘...future.elements_ii’ to environment
[09:30:05.467] - copied ‘...future.seeds_ii’ to environment
[09:30:05.467] - copied ‘...future.globals.maxSize’ to environment
[09:30:05.468] assign_globals() ... done
[09:30:05.468] plan(): Setting new future strategy stack:
[09:30:05.468] List of future strategies:
[09:30:05.468] 1. sequential:
[09:30:05.468]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:05.468]    - tweaked: FALSE
[09:30:05.468]    - call: NULL
[09:30:05.468] plan(): nbrOfWorkers() = 1
[09:30:05.970] plan(): Setting new future strategy stack:
[09:30:05.970] List of future strategies:
[09:30:05.970] 1. multicore:
[09:30:05.970]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:30:05.970]    - tweaked: FALSE
[09:30:05.970]    - call: plan(strategy)
[09:30:05.974] plan(): nbrOfWorkers() = 1
[09:30:05.974] SequentialFuture started (and completed)
[09:30:05.974] - Launch lazy future ... done
[09:30:05.974] run() for ‘SequentialFuture’ ... done
[09:30:05.975] Created future:
[09:30:05.975] SequentialFuture:
[09:30:05.975] Label: ‘future_mapply-1’
[09:30:05.975] Expression:
[09:30:05.975] {
[09:30:05.975]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:05.975]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:05.975]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:05.975]         on.exit(options(oopts), add = TRUE)
[09:30:05.975]     }
[09:30:05.975]     {
[09:30:05.975]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:05.975]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:30:05.975]         do.call(mapply, args = args)
[09:30:05.975]     }
[09:30:05.975] }
[09:30:05.975] Lazy evaluation: FALSE
[09:30:05.975] Asynchronous evaluation: FALSE
[09:30:05.975] Local evaluation: TRUE
[09:30:05.975] Environment: R_GlobalEnv
[09:30:05.975] Capture standard output: NA
[09:30:05.975] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:05.975] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:05.975] Packages: <none>
[09:30:05.975] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:05.975] Resolved: TRUE
[09:30:05.975] Value: 224 bytes of class ‘list’
[09:30:05.975] Early signaling: FALSE
[09:30:05.975] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:05.975] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:05.976] Chunk #1 of 1 ... DONE
[09:30:05.976] Launching 1 futures (chunks) ... DONE
[09:30:05.976] Resolving 1 futures (chunks) ...
[09:30:05.976] resolve() on list ...
[09:30:05.976]  recursive: 0
[09:30:05.976]  length: 1
[09:30:05.976] 
[09:30:05.976] resolved() for ‘SequentialFuture’ ...
[09:30:05.976] - state: ‘finished’
[09:30:05.977] - run: TRUE
[09:30:05.977] - result: ‘FutureResult’
[09:30:05.977] resolved() for ‘SequentialFuture’ ... done
[09:30:05.977] Future #1
[09:30:05.977] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:30:05.977] - nx: 1
[09:30:05.977] - relay: TRUE
[09:30:05.977] - stdout: TRUE
[09:30:05.977] - signal: TRUE
[09:30:05.977] - resignal: FALSE
[09:30:05.977] - force: TRUE
[09:30:05.978] - relayed: [n=1] FALSE
[09:30:05.978] - queued futures: [n=1] FALSE
[09:30:05.978]  - until=1
[09:30:05.978]  - relaying element #1
[09:30:05.978] - relayed: [n=1] TRUE
[09:30:05.978] - queued futures: [n=1] TRUE
[09:30:05.978] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:30:05.978]  length: 0 (resolved future 1)
[09:30:05.978] Relaying remaining futures
[09:30:05.978] signalConditionsASAP(NULL, pos=0) ...
[09:30:05.979] - nx: 1
[09:30:05.979] - relay: TRUE
[09:30:05.979] - stdout: TRUE
[09:30:05.979] - signal: TRUE
[09:30:05.979] - resignal: FALSE
[09:30:05.979] - force: TRUE
[09:30:05.979] - relayed: [n=1] TRUE
[09:30:05.979] - queued futures: [n=1] TRUE
 - flush all
[09:30:05.979] - relayed: [n=1] TRUE
[09:30:05.979] - queued futures: [n=1] TRUE
[09:30:05.979] signalConditionsASAP(NULL, pos=0) ... done
[09:30:05.979] resolve() on list ... DONE
[09:30:05.980]  - Number of value chunks collected: 1
[09:30:05.980] Resolving 1 futures (chunks) ... DONE
[09:30:05.980] Reducing values from 1 chunks ...
[09:30:05.980]  - Number of values collected after concatenation: 2
[09:30:05.980]  - Number of values expected: 2
[09:30:05.980] Reducing values from 1 chunks ... DONE
[09:30:05.980] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[09:30:05.981] plan(): Setting new future strategy stack:
[09:30:05.981] List of future strategies:
[09:30:05.981] 1. multisession:
[09:30:05.981]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:30:05.981]    - tweaked: FALSE
[09:30:05.981]    - call: plan(strategy)
[09:30:05.981] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[09:30:05.981] multisession:
[09:30:05.981] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:30:05.981] - tweaked: FALSE
[09:30:05.981] - call: plan(strategy)
[09:30:05.985] getGlobalsAndPackages() ...
[09:30:05.985] Not searching for globals
[09:30:05.985] - globals: [0] <none>
[09:30:05.985] getGlobalsAndPackages() ... DONE
[09:30:05.986] Packages needed by the future expression (n = 0): <none>
[09:30:05.986] Packages needed by future strategies (n = 0): <none>
[09:30:05.986] {
[09:30:05.986]     {
[09:30:05.986]         {
[09:30:05.986]             ...future.startTime <- base::Sys.time()
[09:30:05.986]             {
[09:30:05.986]                 {
[09:30:05.986]                   {
[09:30:05.986]                     base::local({
[09:30:05.986]                       has_future <- base::requireNamespace("future", 
[09:30:05.986]                         quietly = TRUE)
[09:30:05.986]                       if (has_future) {
[09:30:05.986]                         ns <- base::getNamespace("future")
[09:30:05.986]                         version <- ns[[".package"]][["version"]]
[09:30:05.986]                         if (is.null(version)) 
[09:30:05.986]                           version <- utils::packageVersion("future")
[09:30:05.986]                       }
[09:30:05.986]                       else {
[09:30:05.986]                         version <- NULL
[09:30:05.986]                       }
[09:30:05.986]                       if (!has_future || version < "1.8.0") {
[09:30:05.986]                         info <- base::c(r_version = base::gsub("R version ", 
[09:30:05.986]                           "", base::R.version$version.string), 
[09:30:05.986]                           platform = base::sprintf("%s (%s-bit)", 
[09:30:05.986]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:05.986]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:05.986]                             "release", "version")], collapse = " "), 
[09:30:05.986]                           hostname = base::Sys.info()[["nodename"]])
[09:30:05.986]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:30:05.986]                           info)
[09:30:05.986]                         info <- base::paste(info, collapse = "; ")
[09:30:05.986]                         if (!has_future) {
[09:30:05.986]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:05.986]                             info)
[09:30:05.986]                         }
[09:30:05.986]                         else {
[09:30:05.986]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:05.986]                             info, version)
[09:30:05.986]                         }
[09:30:05.986]                         base::stop(msg)
[09:30:05.986]                       }
[09:30:05.986]                     })
[09:30:05.986]                   }
[09:30:05.986]                   ...future.strategy.old <- future::plan("list")
[09:30:05.986]                   options(future.plan = NULL)
[09:30:05.986]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:05.986]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:05.986]                 }
[09:30:05.986]                 ...future.workdir <- getwd()
[09:30:05.986]             }
[09:30:05.986]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:05.986]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:05.986]         }
[09:30:05.986]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:05.986]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:30:05.986]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:05.986]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:05.986]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:05.986]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:05.986]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:05.986]             base::names(...future.oldOptions))
[09:30:05.986]     }
[09:30:05.986]     if (FALSE) {
[09:30:05.986]     }
[09:30:05.986]     else {
[09:30:05.986]         if (TRUE) {
[09:30:05.986]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:05.986]                 open = "w")
[09:30:05.986]         }
[09:30:05.986]         else {
[09:30:05.986]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:05.986]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:05.986]         }
[09:30:05.986]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:05.986]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:05.986]             base::sink(type = "output", split = FALSE)
[09:30:05.986]             base::close(...future.stdout)
[09:30:05.986]         }, add = TRUE)
[09:30:05.986]     }
[09:30:05.986]     ...future.frame <- base::sys.nframe()
[09:30:05.986]     ...future.conditions <- base::list()
[09:30:05.986]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:05.986]     if (FALSE) {
[09:30:05.986]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:05.986]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:05.986]     }
[09:30:05.986]     ...future.result <- base::tryCatch({
[09:30:05.986]         base::withCallingHandlers({
[09:30:05.986]             ...future.value <- base::withVisible(base::local(NA))
[09:30:05.986]             future::FutureResult(value = ...future.value$value, 
[09:30:05.986]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:05.986]                   ...future.rng), globalenv = if (FALSE) 
[09:30:05.986]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:05.986]                     ...future.globalenv.names))
[09:30:05.986]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:05.986]         }, condition = base::local({
[09:30:05.986]             c <- base::c
[09:30:05.986]             inherits <- base::inherits
[09:30:05.986]             invokeRestart <- base::invokeRestart
[09:30:05.986]             length <- base::length
[09:30:05.986]             list <- base::list
[09:30:05.986]             seq.int <- base::seq.int
[09:30:05.986]             signalCondition <- base::signalCondition
[09:30:05.986]             sys.calls <- base::sys.calls
[09:30:05.986]             `[[` <- base::`[[`
[09:30:05.986]             `+` <- base::`+`
[09:30:05.986]             `<<-` <- base::`<<-`
[09:30:05.986]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:05.986]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:05.986]                   3L)]
[09:30:05.986]             }
[09:30:05.986]             function(cond) {
[09:30:05.986]                 is_error <- inherits(cond, "error")
[09:30:05.986]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:05.986]                   NULL)
[09:30:05.986]                 if (is_error) {
[09:30:05.986]                   sessionInformation <- function() {
[09:30:05.986]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:05.986]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:05.986]                       search = base::search(), system = base::Sys.info())
[09:30:05.986]                   }
[09:30:05.986]                   ...future.conditions[[length(...future.conditions) + 
[09:30:05.986]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:05.986]                     cond$call), session = sessionInformation(), 
[09:30:05.986]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:05.986]                   signalCondition(cond)
[09:30:05.986]                 }
[09:30:05.986]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:05.986]                 "immediateCondition"))) {
[09:30:05.986]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:05.986]                   ...future.conditions[[length(...future.conditions) + 
[09:30:05.986]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:05.986]                   if (TRUE && !signal) {
[09:30:05.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:05.986]                     {
[09:30:05.986]                       inherits <- base::inherits
[09:30:05.986]                       invokeRestart <- base::invokeRestart
[09:30:05.986]                       is.null <- base::is.null
[09:30:05.986]                       muffled <- FALSE
[09:30:05.986]                       if (inherits(cond, "message")) {
[09:30:05.986]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:05.986]                         if (muffled) 
[09:30:05.986]                           invokeRestart("muffleMessage")
[09:30:05.986]                       }
[09:30:05.986]                       else if (inherits(cond, "warning")) {
[09:30:05.986]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:05.986]                         if (muffled) 
[09:30:05.986]                           invokeRestart("muffleWarning")
[09:30:05.986]                       }
[09:30:05.986]                       else if (inherits(cond, "condition")) {
[09:30:05.986]                         if (!is.null(pattern)) {
[09:30:05.986]                           computeRestarts <- base::computeRestarts
[09:30:05.986]                           grepl <- base::grepl
[09:30:05.986]                           restarts <- computeRestarts(cond)
[09:30:05.986]                           for (restart in restarts) {
[09:30:05.986]                             name <- restart$name
[09:30:05.986]                             if (is.null(name)) 
[09:30:05.986]                               next
[09:30:05.986]                             if (!grepl(pattern, name)) 
[09:30:05.986]                               next
[09:30:05.986]                             invokeRestart(restart)
[09:30:05.986]                             muffled <- TRUE
[09:30:05.986]                             break
[09:30:05.986]                           }
[09:30:05.986]                         }
[09:30:05.986]                       }
[09:30:05.986]                       invisible(muffled)
[09:30:05.986]                     }
[09:30:05.986]                     muffleCondition(cond, pattern = "^muffle")
[09:30:05.986]                   }
[09:30:05.986]                 }
[09:30:05.986]                 else {
[09:30:05.986]                   if (TRUE) {
[09:30:05.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:05.986]                     {
[09:30:05.986]                       inherits <- base::inherits
[09:30:05.986]                       invokeRestart <- base::invokeRestart
[09:30:05.986]                       is.null <- base::is.null
[09:30:05.986]                       muffled <- FALSE
[09:30:05.986]                       if (inherits(cond, "message")) {
[09:30:05.986]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:05.986]                         if (muffled) 
[09:30:05.986]                           invokeRestart("muffleMessage")
[09:30:05.986]                       }
[09:30:05.986]                       else if (inherits(cond, "warning")) {
[09:30:05.986]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:05.986]                         if (muffled) 
[09:30:05.986]                           invokeRestart("muffleWarning")
[09:30:05.986]                       }
[09:30:05.986]                       else if (inherits(cond, "condition")) {
[09:30:05.986]                         if (!is.null(pattern)) {
[09:30:05.986]                           computeRestarts <- base::computeRestarts
[09:30:05.986]                           grepl <- base::grepl
[09:30:05.986]                           restarts <- computeRestarts(cond)
[09:30:05.986]                           for (restart in restarts) {
[09:30:05.986]                             name <- restart$name
[09:30:05.986]                             if (is.null(name)) 
[09:30:05.986]                               next
[09:30:05.986]                             if (!grepl(pattern, name)) 
[09:30:05.986]                               next
[09:30:05.986]                             invokeRestart(restart)
[09:30:05.986]                             muffled <- TRUE
[09:30:05.986]                             break
[09:30:05.986]                           }
[09:30:05.986]                         }
[09:30:05.986]                       }
[09:30:05.986]                       invisible(muffled)
[09:30:05.986]                     }
[09:30:05.986]                     muffleCondition(cond, pattern = "^muffle")
[09:30:05.986]                   }
[09:30:05.986]                 }
[09:30:05.986]             }
[09:30:05.986]         }))
[09:30:05.986]     }, error = function(ex) {
[09:30:05.986]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:05.986]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:05.986]                 ...future.rng), started = ...future.startTime, 
[09:30:05.986]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:05.986]             version = "1.8"), class = "FutureResult")
[09:30:05.986]     }, finally = {
[09:30:05.986]         if (!identical(...future.workdir, getwd())) 
[09:30:05.986]             setwd(...future.workdir)
[09:30:05.986]         {
[09:30:05.986]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:05.986]                 ...future.oldOptions$nwarnings <- NULL
[09:30:05.986]             }
[09:30:05.986]             base::options(...future.oldOptions)
[09:30:05.986]             if (.Platform$OS.type == "windows") {
[09:30:05.986]                 old_names <- names(...future.oldEnvVars)
[09:30:05.986]                 envs <- base::Sys.getenv()
[09:30:05.986]                 names <- names(envs)
[09:30:05.986]                 common <- intersect(names, old_names)
[09:30:05.986]                 added <- setdiff(names, old_names)
[09:30:05.986]                 removed <- setdiff(old_names, names)
[09:30:05.986]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:05.986]                   envs[common]]
[09:30:05.986]                 NAMES <- toupper(changed)
[09:30:05.986]                 args <- list()
[09:30:05.986]                 for (kk in seq_along(NAMES)) {
[09:30:05.986]                   name <- changed[[kk]]
[09:30:05.986]                   NAME <- NAMES[[kk]]
[09:30:05.986]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:05.986]                     next
[09:30:05.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:05.986]                 }
[09:30:05.986]                 NAMES <- toupper(added)
[09:30:05.986]                 for (kk in seq_along(NAMES)) {
[09:30:05.986]                   name <- added[[kk]]
[09:30:05.986]                   NAME <- NAMES[[kk]]
[09:30:05.986]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:05.986]                     next
[09:30:05.986]                   args[[name]] <- ""
[09:30:05.986]                 }
[09:30:05.986]                 NAMES <- toupper(removed)
[09:30:05.986]                 for (kk in seq_along(NAMES)) {
[09:30:05.986]                   name <- removed[[kk]]
[09:30:05.986]                   NAME <- NAMES[[kk]]
[09:30:05.986]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:05.986]                     next
[09:30:05.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:05.986]                 }
[09:30:05.986]                 if (length(args) > 0) 
[09:30:05.986]                   base::do.call(base::Sys.setenv, args = args)
[09:30:05.986]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:05.986]             }
[09:30:05.986]             else {
[09:30:05.986]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:05.986]             }
[09:30:05.986]             {
[09:30:05.986]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:05.986]                   0L) {
[09:30:05.986]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:05.986]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:05.986]                   base::options(opts)
[09:30:05.986]                 }
[09:30:05.986]                 {
[09:30:05.986]                   {
[09:30:05.986]                     NULL
[09:30:05.986]                     RNGkind("Mersenne-Twister")
[09:30:05.986]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:30:05.986]                       inherits = FALSE)
[09:30:05.986]                   }
[09:30:05.986]                   options(future.plan = NULL)
[09:30:05.986]                   if (is.na(NA_character_)) 
[09:30:05.986]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:05.986]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:05.986]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:05.986]                     .init = FALSE)
[09:30:05.986]                 }
[09:30:05.986]             }
[09:30:05.986]         }
[09:30:05.986]     })
[09:30:05.986]     if (TRUE) {
[09:30:05.986]         base::sink(type = "output", split = FALSE)
[09:30:05.986]         if (TRUE) {
[09:30:05.986]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:05.986]         }
[09:30:05.986]         else {
[09:30:05.986]             ...future.result["stdout"] <- base::list(NULL)
[09:30:05.986]         }
[09:30:05.986]         base::close(...future.stdout)
[09:30:05.986]         ...future.stdout <- NULL
[09:30:05.986]     }
[09:30:05.986]     ...future.result$conditions <- ...future.conditions
[09:30:05.986]     ...future.result$finished <- base::Sys.time()
[09:30:05.986]     ...future.result
[09:30:05.986] }
[09:30:05.988] plan(): Setting new future strategy stack:
[09:30:05.988] List of future strategies:
[09:30:05.988] 1. sequential:
[09:30:05.988]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:05.988]    - tweaked: FALSE
[09:30:05.988]    - call: NULL
[09:30:05.988] plan(): nbrOfWorkers() = 1
[09:30:05.989] plan(): Setting new future strategy stack:
[09:30:05.989] List of future strategies:
[09:30:05.989] 1. multisession:
[09:30:05.989]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:30:05.989]    - tweaked: FALSE
[09:30:05.989]    - call: plan(strategy)
[09:30:05.992] plan(): nbrOfWorkers() = 1
[09:30:05.993] SequentialFuture started (and completed)
[09:30:05.993] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[09:30:05.996] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[09:30:05.996] future_lapply() ...
[09:30:06.000] Number of chunks: 1
[09:30:06.000] getGlobalsAndPackagesXApply() ...
[09:30:06.000]  - future.globals: TRUE
[09:30:06.000] getGlobalsAndPackages() ...
[09:30:06.000] Searching for globals...
[09:30:06.003] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[09:30:06.004] Searching for globals ... DONE
[09:30:06.004] Resolving globals: FALSE
[09:30:06.004] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[09:30:06.005] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[09:30:06.005] - globals: [1] ‘FUN’
[09:30:06.005] 
[09:30:06.005] getGlobalsAndPackages() ... DONE
[09:30:06.005]  - globals found/used: [n=1] ‘FUN’
[09:30:06.005]  - needed namespaces: [n=0] 
[09:30:06.005] Finding globals ... DONE
[09:30:06.005]  - use_args: TRUE
[09:30:06.005]  - Getting '...' globals ...
[09:30:06.006] resolve() on list ...
[09:30:06.006]  recursive: 0
[09:30:06.006]  length: 1
[09:30:06.006]  elements: ‘...’
[09:30:06.006]  length: 0 (resolved future 1)
[09:30:06.006] resolve() on list ... DONE
[09:30:06.006]    - '...' content: [n=0] 
[09:30:06.006] List of 1
[09:30:06.006]  $ ...: list()
[09:30:06.006]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:06.006]  - attr(*, "where")=List of 1
[09:30:06.006]   ..$ ...:<environment: 0x55c103e77eb0> 
[09:30:06.006]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:06.006]  - attr(*, "resolved")= logi TRUE
[09:30:06.006]  - attr(*, "total_size")= num NA
[09:30:06.009]  - Getting '...' globals ... DONE
[09:30:06.009] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:30:06.009] List of 2
[09:30:06.009]  $ ...future.FUN:function (x)  
[09:30:06.009]  $ ...          : list()
[09:30:06.009]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:06.009]  - attr(*, "where")=List of 2
[09:30:06.009]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:06.009]   ..$ ...          :<environment: 0x55c103e77eb0> 
[09:30:06.009]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:06.009]  - attr(*, "resolved")= logi FALSE
[09:30:06.009]  - attr(*, "total_size")= num 4720
[09:30:06.012] Packages to be attached in all futures: [n=0] 
[09:30:06.012] getGlobalsAndPackagesXApply() ... DONE
[09:30:06.012] Number of futures (= number of chunks): 1
[09:30:06.012] Launching 1 futures (chunks) ...
[09:30:06.012] Chunk #1 of 1 ...
[09:30:06.012]  - Finding globals in 'X' for chunk #1 ...
[09:30:06.012] getGlobalsAndPackages() ...
[09:30:06.012] Searching for globals...
[09:30:06.013] 
[09:30:06.013] Searching for globals ... DONE
[09:30:06.013] - globals: [0] <none>
[09:30:06.013] getGlobalsAndPackages() ... DONE
[09:30:06.013]    + additional globals found: [n=0] 
[09:30:06.013]    + additional namespaces needed: [n=0] 
[09:30:06.013]  - Finding globals in 'X' for chunk #1 ... DONE
[09:30:06.013]  - seeds: <none>
[09:30:06.013]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:06.013] getGlobalsAndPackages() ...
[09:30:06.014] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:06.014] Resolving globals: FALSE
[09:30:06.014] Tweak future expression to call with '...' arguments ...
[09:30:06.014] {
[09:30:06.014]     do.call(function(...) {
[09:30:06.014]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:06.014]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:06.014]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:06.014]             on.exit(options(oopts), add = TRUE)
[09:30:06.014]         }
[09:30:06.014]         {
[09:30:06.014]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:06.014]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:06.014]                 ...future.FUN(...future.X_jj, ...)
[09:30:06.014]             })
[09:30:06.014]         }
[09:30:06.014]     }, args = future.call.arguments)
[09:30:06.014] }
[09:30:06.014] Tweak future expression to call with '...' arguments ... DONE
[09:30:06.014] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:06.014] 
[09:30:06.015] getGlobalsAndPackages() ... DONE
[09:30:06.015] run() for ‘Future’ ...
[09:30:06.015] - state: ‘created’
[09:30:06.015] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:30:06.018] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:06.018] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:30:06.019]   - Field: ‘label’
[09:30:06.019]   - Field: ‘local’
[09:30:06.019]   - Field: ‘owner’
[09:30:06.019]   - Field: ‘envir’
[09:30:06.019]   - Field: ‘packages’
[09:30:06.019]   - Field: ‘gc’
[09:30:06.019]   - Field: ‘conditions’
[09:30:06.019]   - Field: ‘expr’
[09:30:06.019]   - Field: ‘uuid’
[09:30:06.019]   - Field: ‘seed’
[09:30:06.019]   - Field: ‘version’
[09:30:06.020]   - Field: ‘result’
[09:30:06.020]   - Field: ‘asynchronous’
[09:30:06.020]   - Field: ‘calls’
[09:30:06.020]   - Field: ‘globals’
[09:30:06.020]   - Field: ‘stdout’
[09:30:06.020]   - Field: ‘earlySignal’
[09:30:06.020]   - Field: ‘lazy’
[09:30:06.020]   - Field: ‘state’
[09:30:06.020] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:30:06.020] - Launch lazy future ...
[09:30:06.021] Packages needed by the future expression (n = 0): <none>
[09:30:06.021] Packages needed by future strategies (n = 0): <none>
[09:30:06.021] {
[09:30:06.021]     {
[09:30:06.021]         {
[09:30:06.021]             ...future.startTime <- base::Sys.time()
[09:30:06.021]             {
[09:30:06.021]                 {
[09:30:06.021]                   {
[09:30:06.021]                     base::local({
[09:30:06.021]                       has_future <- base::requireNamespace("future", 
[09:30:06.021]                         quietly = TRUE)
[09:30:06.021]                       if (has_future) {
[09:30:06.021]                         ns <- base::getNamespace("future")
[09:30:06.021]                         version <- ns[[".package"]][["version"]]
[09:30:06.021]                         if (is.null(version)) 
[09:30:06.021]                           version <- utils::packageVersion("future")
[09:30:06.021]                       }
[09:30:06.021]                       else {
[09:30:06.021]                         version <- NULL
[09:30:06.021]                       }
[09:30:06.021]                       if (!has_future || version < "1.8.0") {
[09:30:06.021]                         info <- base::c(r_version = base::gsub("R version ", 
[09:30:06.021]                           "", base::R.version$version.string), 
[09:30:06.021]                           platform = base::sprintf("%s (%s-bit)", 
[09:30:06.021]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:06.021]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:06.021]                             "release", "version")], collapse = " "), 
[09:30:06.021]                           hostname = base::Sys.info()[["nodename"]])
[09:30:06.021]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:30:06.021]                           info)
[09:30:06.021]                         info <- base::paste(info, collapse = "; ")
[09:30:06.021]                         if (!has_future) {
[09:30:06.021]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:06.021]                             info)
[09:30:06.021]                         }
[09:30:06.021]                         else {
[09:30:06.021]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:06.021]                             info, version)
[09:30:06.021]                         }
[09:30:06.021]                         base::stop(msg)
[09:30:06.021]                       }
[09:30:06.021]                     })
[09:30:06.021]                   }
[09:30:06.021]                   ...future.strategy.old <- future::plan("list")
[09:30:06.021]                   options(future.plan = NULL)
[09:30:06.021]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:06.021]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:06.021]                 }
[09:30:06.021]                 ...future.workdir <- getwd()
[09:30:06.021]             }
[09:30:06.021]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:06.021]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:06.021]         }
[09:30:06.021]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:06.021]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:30:06.021]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:06.021]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:06.021]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:06.021]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:06.021]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:06.021]             base::names(...future.oldOptions))
[09:30:06.021]     }
[09:30:06.021]     if (FALSE) {
[09:30:06.021]     }
[09:30:06.021]     else {
[09:30:06.021]         if (FALSE) {
[09:30:06.021]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:06.021]                 open = "w")
[09:30:06.021]         }
[09:30:06.021]         else {
[09:30:06.021]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:06.021]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:06.021]         }
[09:30:06.021]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:06.021]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:06.021]             base::sink(type = "output", split = FALSE)
[09:30:06.021]             base::close(...future.stdout)
[09:30:06.021]         }, add = TRUE)
[09:30:06.021]     }
[09:30:06.021]     ...future.frame <- base::sys.nframe()
[09:30:06.021]     ...future.conditions <- base::list()
[09:30:06.021]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:06.021]     if (FALSE) {
[09:30:06.021]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:06.021]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:06.021]     }
[09:30:06.021]     ...future.result <- base::tryCatch({
[09:30:06.021]         base::withCallingHandlers({
[09:30:06.021]             ...future.value <- base::withVisible(base::local({
[09:30:06.021]                 do.call(function(...) {
[09:30:06.021]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:06.021]                   if (!identical(...future.globals.maxSize.org, 
[09:30:06.021]                     ...future.globals.maxSize)) {
[09:30:06.021]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:06.021]                     on.exit(options(oopts), add = TRUE)
[09:30:06.021]                   }
[09:30:06.021]                   {
[09:30:06.021]                     lapply(seq_along(...future.elements_ii), 
[09:30:06.021]                       FUN = function(jj) {
[09:30:06.021]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:06.021]                         ...future.FUN(...future.X_jj, ...)
[09:30:06.021]                       })
[09:30:06.021]                   }
[09:30:06.021]                 }, args = future.call.arguments)
[09:30:06.021]             }))
[09:30:06.021]             future::FutureResult(value = ...future.value$value, 
[09:30:06.021]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:06.021]                   ...future.rng), globalenv = if (FALSE) 
[09:30:06.021]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:06.021]                     ...future.globalenv.names))
[09:30:06.021]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:06.021]         }, condition = base::local({
[09:30:06.021]             c <- base::c
[09:30:06.021]             inherits <- base::inherits
[09:30:06.021]             invokeRestart <- base::invokeRestart
[09:30:06.021]             length <- base::length
[09:30:06.021]             list <- base::list
[09:30:06.021]             seq.int <- base::seq.int
[09:30:06.021]             signalCondition <- base::signalCondition
[09:30:06.021]             sys.calls <- base::sys.calls
[09:30:06.021]             `[[` <- base::`[[`
[09:30:06.021]             `+` <- base::`+`
[09:30:06.021]             `<<-` <- base::`<<-`
[09:30:06.021]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:06.021]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:06.021]                   3L)]
[09:30:06.021]             }
[09:30:06.021]             function(cond) {
[09:30:06.021]                 is_error <- inherits(cond, "error")
[09:30:06.021]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:06.021]                   NULL)
[09:30:06.021]                 if (is_error) {
[09:30:06.021]                   sessionInformation <- function() {
[09:30:06.021]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:06.021]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:06.021]                       search = base::search(), system = base::Sys.info())
[09:30:06.021]                   }
[09:30:06.021]                   ...future.conditions[[length(...future.conditions) + 
[09:30:06.021]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:06.021]                     cond$call), session = sessionInformation(), 
[09:30:06.021]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:06.021]                   signalCondition(cond)
[09:30:06.021]                 }
[09:30:06.021]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:06.021]                 "immediateCondition"))) {
[09:30:06.021]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:06.021]                   ...future.conditions[[length(...future.conditions) + 
[09:30:06.021]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:06.021]                   if (TRUE && !signal) {
[09:30:06.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:06.021]                     {
[09:30:06.021]                       inherits <- base::inherits
[09:30:06.021]                       invokeRestart <- base::invokeRestart
[09:30:06.021]                       is.null <- base::is.null
[09:30:06.021]                       muffled <- FALSE
[09:30:06.021]                       if (inherits(cond, "message")) {
[09:30:06.021]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:06.021]                         if (muffled) 
[09:30:06.021]                           invokeRestart("muffleMessage")
[09:30:06.021]                       }
[09:30:06.021]                       else if (inherits(cond, "warning")) {
[09:30:06.021]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:06.021]                         if (muffled) 
[09:30:06.021]                           invokeRestart("muffleWarning")
[09:30:06.021]                       }
[09:30:06.021]                       else if (inherits(cond, "condition")) {
[09:30:06.021]                         if (!is.null(pattern)) {
[09:30:06.021]                           computeRestarts <- base::computeRestarts
[09:30:06.021]                           grepl <- base::grepl
[09:30:06.021]                           restarts <- computeRestarts(cond)
[09:30:06.021]                           for (restart in restarts) {
[09:30:06.021]                             name <- restart$name
[09:30:06.021]                             if (is.null(name)) 
[09:30:06.021]                               next
[09:30:06.021]                             if (!grepl(pattern, name)) 
[09:30:06.021]                               next
[09:30:06.021]                             invokeRestart(restart)
[09:30:06.021]                             muffled <- TRUE
[09:30:06.021]                             break
[09:30:06.021]                           }
[09:30:06.021]                         }
[09:30:06.021]                       }
[09:30:06.021]                       invisible(muffled)
[09:30:06.021]                     }
[09:30:06.021]                     muffleCondition(cond, pattern = "^muffle")
[09:30:06.021]                   }
[09:30:06.021]                 }
[09:30:06.021]                 else {
[09:30:06.021]                   if (TRUE) {
[09:30:06.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:06.021]                     {
[09:30:06.021]                       inherits <- base::inherits
[09:30:06.021]                       invokeRestart <- base::invokeRestart
[09:30:06.021]                       is.null <- base::is.null
[09:30:06.021]                       muffled <- FALSE
[09:30:06.021]                       if (inherits(cond, "message")) {
[09:30:06.021]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:06.021]                         if (muffled) 
[09:30:06.021]                           invokeRestart("muffleMessage")
[09:30:06.021]                       }
[09:30:06.021]                       else if (inherits(cond, "warning")) {
[09:30:06.021]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:06.021]                         if (muffled) 
[09:30:06.021]                           invokeRestart("muffleWarning")
[09:30:06.021]                       }
[09:30:06.021]                       else if (inherits(cond, "condition")) {
[09:30:06.021]                         if (!is.null(pattern)) {
[09:30:06.021]                           computeRestarts <- base::computeRestarts
[09:30:06.021]                           grepl <- base::grepl
[09:30:06.021]                           restarts <- computeRestarts(cond)
[09:30:06.021]                           for (restart in restarts) {
[09:30:06.021]                             name <- restart$name
[09:30:06.021]                             if (is.null(name)) 
[09:30:06.021]                               next
[09:30:06.021]                             if (!grepl(pattern, name)) 
[09:30:06.021]                               next
[09:30:06.021]                             invokeRestart(restart)
[09:30:06.021]                             muffled <- TRUE
[09:30:06.021]                             break
[09:30:06.021]                           }
[09:30:06.021]                         }
[09:30:06.021]                       }
[09:30:06.021]                       invisible(muffled)
[09:30:06.021]                     }
[09:30:06.021]                     muffleCondition(cond, pattern = "^muffle")
[09:30:06.021]                   }
[09:30:06.021]                 }
[09:30:06.021]             }
[09:30:06.021]         }))
[09:30:06.021]     }, error = function(ex) {
[09:30:06.021]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:06.021]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:06.021]                 ...future.rng), started = ...future.startTime, 
[09:30:06.021]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:06.021]             version = "1.8"), class = "FutureResult")
[09:30:06.021]     }, finally = {
[09:30:06.021]         if (!identical(...future.workdir, getwd())) 
[09:30:06.021]             setwd(...future.workdir)
[09:30:06.021]         {
[09:30:06.021]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:06.021]                 ...future.oldOptions$nwarnings <- NULL
[09:30:06.021]             }
[09:30:06.021]             base::options(...future.oldOptions)
[09:30:06.021]             if (.Platform$OS.type == "windows") {
[09:30:06.021]                 old_names <- names(...future.oldEnvVars)
[09:30:06.021]                 envs <- base::Sys.getenv()
[09:30:06.021]                 names <- names(envs)
[09:30:06.021]                 common <- intersect(names, old_names)
[09:30:06.021]                 added <- setdiff(names, old_names)
[09:30:06.021]                 removed <- setdiff(old_names, names)
[09:30:06.021]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:06.021]                   envs[common]]
[09:30:06.021]                 NAMES <- toupper(changed)
[09:30:06.021]                 args <- list()
[09:30:06.021]                 for (kk in seq_along(NAMES)) {
[09:30:06.021]                   name <- changed[[kk]]
[09:30:06.021]                   NAME <- NAMES[[kk]]
[09:30:06.021]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:06.021]                     next
[09:30:06.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:06.021]                 }
[09:30:06.021]                 NAMES <- toupper(added)
[09:30:06.021]                 for (kk in seq_along(NAMES)) {
[09:30:06.021]                   name <- added[[kk]]
[09:30:06.021]                   NAME <- NAMES[[kk]]
[09:30:06.021]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:06.021]                     next
[09:30:06.021]                   args[[name]] <- ""
[09:30:06.021]                 }
[09:30:06.021]                 NAMES <- toupper(removed)
[09:30:06.021]                 for (kk in seq_along(NAMES)) {
[09:30:06.021]                   name <- removed[[kk]]
[09:30:06.021]                   NAME <- NAMES[[kk]]
[09:30:06.021]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:06.021]                     next
[09:30:06.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:06.021]                 }
[09:30:06.021]                 if (length(args) > 0) 
[09:30:06.021]                   base::do.call(base::Sys.setenv, args = args)
[09:30:06.021]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:06.021]             }
[09:30:06.021]             else {
[09:30:06.021]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:06.021]             }
[09:30:06.021]             {
[09:30:06.021]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:06.021]                   0L) {
[09:30:06.021]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:06.021]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:06.021]                   base::options(opts)
[09:30:06.021]                 }
[09:30:06.021]                 {
[09:30:06.021]                   {
[09:30:06.021]                     NULL
[09:30:06.021]                     RNGkind("Mersenne-Twister")
[09:30:06.021]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:30:06.021]                       inherits = FALSE)
[09:30:06.021]                   }
[09:30:06.021]                   options(future.plan = NULL)
[09:30:06.021]                   if (is.na(NA_character_)) 
[09:30:06.021]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:06.021]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:06.021]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:06.021]                     .init = FALSE)
[09:30:06.021]                 }
[09:30:06.021]             }
[09:30:06.021]         }
[09:30:06.021]     })
[09:30:06.021]     if (TRUE) {
[09:30:06.021]         base::sink(type = "output", split = FALSE)
[09:30:06.021]         if (FALSE) {
[09:30:06.021]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:06.021]         }
[09:30:06.021]         else {
[09:30:06.021]             ...future.result["stdout"] <- base::list(NULL)
[09:30:06.021]         }
[09:30:06.021]         base::close(...future.stdout)
[09:30:06.021]         ...future.stdout <- NULL
[09:30:06.021]     }
[09:30:06.021]     ...future.result$conditions <- ...future.conditions
[09:30:06.021]     ...future.result$finished <- base::Sys.time()
[09:30:06.021]     ...future.result
[09:30:06.021] }
[09:30:06.023] assign_globals() ...
[09:30:06.023] List of 5
[09:30:06.023]  $ ...future.FUN            :function (x)  
[09:30:06.023]  $ future.call.arguments    : list()
[09:30:06.023]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:06.023]  $ ...future.elements_ii    :List of 2
[09:30:06.023]   ..$ : int 1
[09:30:06.023]   ..$ : int 0
[09:30:06.023]  $ ...future.seeds_ii       : NULL
[09:30:06.023]  $ ...future.globals.maxSize: NULL
[09:30:06.023]  - attr(*, "where")=List of 5
[09:30:06.023]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:06.023]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:30:06.023]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:06.023]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:06.023]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:06.023]  - attr(*, "resolved")= logi FALSE
[09:30:06.023]  - attr(*, "total_size")= num 4720
[09:30:06.023]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:06.023]  - attr(*, "already-done")= logi TRUE
[09:30:06.053] - reassign environment for ‘...future.FUN’
[09:30:06.053] - copied ‘...future.FUN’ to environment
[09:30:06.053] - copied ‘future.call.arguments’ to environment
[09:30:06.053] - copied ‘...future.elements_ii’ to environment
[09:30:06.053] - copied ‘...future.seeds_ii’ to environment
[09:30:06.053] - copied ‘...future.globals.maxSize’ to environment
[09:30:06.053] assign_globals() ... done
[09:30:06.054] plan(): Setting new future strategy stack:
[09:30:06.054] List of future strategies:
[09:30:06.054] 1. sequential:
[09:30:06.054]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:06.054]    - tweaked: FALSE
[09:30:06.054]    - call: NULL
[09:30:06.054] plan(): nbrOfWorkers() = 1
[09:30:06.556] plan(): Setting new future strategy stack:
[09:30:06.556] List of future strategies:
[09:30:06.556] 1. multisession:
[09:30:06.556]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:30:06.556]    - tweaked: FALSE
[09:30:06.556]    - call: plan(strategy)
[09:30:06.560] plan(): nbrOfWorkers() = 1
[09:30:06.560] SequentialFuture started (and completed)
[09:30:06.561] - Launch lazy future ... done
[09:30:06.561] run() for ‘SequentialFuture’ ... done
[09:30:06.561] Created future:
[09:30:06.561] SequentialFuture:
[09:30:06.561] Label: ‘future_lapply-1’
[09:30:06.561] Expression:
[09:30:06.561] {
[09:30:06.561]     do.call(function(...) {
[09:30:06.561]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:06.561]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:06.561]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:06.561]             on.exit(options(oopts), add = TRUE)
[09:30:06.561]         }
[09:30:06.561]         {
[09:30:06.561]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:06.561]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:06.561]                 ...future.FUN(...future.X_jj, ...)
[09:30:06.561]             })
[09:30:06.561]         }
[09:30:06.561]     }, args = future.call.arguments)
[09:30:06.561] }
[09:30:06.561] Lazy evaluation: FALSE
[09:30:06.561] Asynchronous evaluation: FALSE
[09:30:06.561] Local evaluation: TRUE
[09:30:06.561] Environment: R_GlobalEnv
[09:30:06.561] Capture standard output: FALSE
[09:30:06.561] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:06.561] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:06.561] Packages: <none>
[09:30:06.561] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:06.561] Resolved: TRUE
[09:30:06.561] Value: 112 bytes of class ‘list’
[09:30:06.561] Early signaling: FALSE
[09:30:06.561] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:06.561] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:06.562] Chunk #1 of 1 ... DONE
[09:30:06.562] Launching 1 futures (chunks) ... DONE
[09:30:06.562] Resolving 1 futures (chunks) ...
[09:30:06.562] resolve() on list ...
[09:30:06.562]  recursive: 0
[09:30:06.562]  length: 1
[09:30:06.563] 
[09:30:06.563] resolved() for ‘SequentialFuture’ ...
[09:30:06.563] - state: ‘finished’
[09:30:06.563] - run: TRUE
[09:30:06.563] - result: ‘FutureResult’
[09:30:06.563] resolved() for ‘SequentialFuture’ ... done
[09:30:06.563] Future #1
[09:30:06.563] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:30:06.563] - nx: 1
[09:30:06.563] - relay: TRUE
[09:30:06.564] - stdout: TRUE
[09:30:06.564] - signal: TRUE
[09:30:06.564] - resignal: FALSE
[09:30:06.564] - force: TRUE
[09:30:06.564] - relayed: [n=1] FALSE
[09:30:06.564] - queued futures: [n=1] FALSE
[09:30:06.564]  - until=1
[09:30:06.564]  - relaying element #1
[09:30:06.564] - relayed: [n=1] TRUE
[09:30:06.565] - queued futures: [n=1] TRUE
[09:30:06.565] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:30:06.565]  length: 0 (resolved future 1)
[09:30:06.565] Relaying remaining futures
[09:30:06.565] signalConditionsASAP(NULL, pos=0) ...
[09:30:06.565] - nx: 1
[09:30:06.565] - relay: TRUE
[09:30:06.565] - stdout: TRUE
[09:30:06.565] - signal: TRUE
[09:30:06.565] - resignal: FALSE
[09:30:06.565] - force: TRUE
[09:30:06.565] - relayed: [n=1] TRUE
[09:30:06.566] - queued futures: [n=1] TRUE
 - flush all
[09:30:06.566] - relayed: [n=1] TRUE
[09:30:06.566] - queued futures: [n=1] TRUE
[09:30:06.566] signalConditionsASAP(NULL, pos=0) ... done
[09:30:06.566] resolve() on list ... DONE
[09:30:06.566]  - Number of value chunks collected: 1
[09:30:06.566] Resolving 1 futures (chunks) ... DONE
[09:30:06.566] Reducing values from 1 chunks ...
[09:30:06.566]  - Number of values collected after concatenation: 2
[09:30:06.566]  - Number of values expected: 2
[09:30:06.567] Reducing values from 1 chunks ... DONE
[09:30:06.567] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[09:30:06.567] future_lapply() ...
[09:30:06.571] Number of chunks: 1
[09:30:06.571] getGlobalsAndPackagesXApply() ...
[09:30:06.571]  - future.globals: TRUE
[09:30:06.571] getGlobalsAndPackages() ...
[09:30:06.571] Searching for globals...
[09:30:06.573] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[09:30:06.573] Searching for globals ... DONE
[09:30:06.573] Resolving globals: FALSE
[09:30:06.573] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[09:30:06.574] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[09:30:06.574] - globals: [1] ‘FUN’
[09:30:06.574] 
[09:30:06.574] getGlobalsAndPackages() ... DONE
[09:30:06.574]  - globals found/used: [n=1] ‘FUN’
[09:30:06.574]  - needed namespaces: [n=0] 
[09:30:06.574] Finding globals ... DONE
[09:30:06.574]  - use_args: TRUE
[09:30:06.574]  - Getting '...' globals ...
[09:30:06.575] resolve() on list ...
[09:30:06.575]  recursive: 0
[09:30:06.575]  length: 1
[09:30:06.575]  elements: ‘...’
[09:30:06.575]  length: 0 (resolved future 1)
[09:30:06.575] resolve() on list ... DONE
[09:30:06.575]    - '...' content: [n=0] 
[09:30:06.575] List of 1
[09:30:06.575]  $ ...: list()
[09:30:06.575]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:06.575]  - attr(*, "where")=List of 1
[09:30:06.575]   ..$ ...:<environment: 0x55c1027378b0> 
[09:30:06.575]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:06.575]  - attr(*, "resolved")= logi TRUE
[09:30:06.575]  - attr(*, "total_size")= num NA
[09:30:06.578]  - Getting '...' globals ... DONE
[09:30:06.578] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:30:06.578] List of 2
[09:30:06.578]  $ ...future.FUN:function (x)  
[09:30:06.578]  $ ...          : list()
[09:30:06.578]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:06.578]  - attr(*, "where")=List of 2
[09:30:06.578]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:06.578]   ..$ ...          :<environment: 0x55c1027378b0> 
[09:30:06.578]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:06.578]  - attr(*, "resolved")= logi FALSE
[09:30:06.578]  - attr(*, "total_size")= num 4720
[09:30:06.581] Packages to be attached in all futures: [n=0] 
[09:30:06.581] getGlobalsAndPackagesXApply() ... DONE
[09:30:06.581] Number of futures (= number of chunks): 1
[09:30:06.581] Launching 1 futures (chunks) ...
[09:30:06.581] Chunk #1 of 1 ...
[09:30:06.582]  - Finding globals in 'X' for chunk #1 ...
[09:30:06.582] getGlobalsAndPackages() ...
[09:30:06.582] Searching for globals...
[09:30:06.582] 
[09:30:06.582] Searching for globals ... DONE
[09:30:06.582] - globals: [0] <none>
[09:30:06.582] getGlobalsAndPackages() ... DONE
[09:30:06.582]    + additional globals found: [n=0] 
[09:30:06.582]    + additional namespaces needed: [n=0] 
[09:30:06.582]  - Finding globals in 'X' for chunk #1 ... DONE
[09:30:06.583]  - seeds: <none>
[09:30:06.583]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:06.583] getGlobalsAndPackages() ...
[09:30:06.583] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:06.583] Resolving globals: FALSE
[09:30:06.583] Tweak future expression to call with '...' arguments ...
[09:30:06.583] {
[09:30:06.583]     do.call(function(...) {
[09:30:06.583]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:06.583]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:06.583]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:06.583]             on.exit(options(oopts), add = TRUE)
[09:30:06.583]         }
[09:30:06.583]         {
[09:30:06.583]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:06.583]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:06.583]                 ...future.FUN(...future.X_jj, ...)
[09:30:06.583]             })
[09:30:06.583]         }
[09:30:06.583]     }, args = future.call.arguments)
[09:30:06.583] }
[09:30:06.583] Tweak future expression to call with '...' arguments ... DONE
[09:30:06.584] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:06.584] 
[09:30:06.584] getGlobalsAndPackages() ... DONE
[09:30:06.584] run() for ‘Future’ ...
[09:30:06.584] - state: ‘created’
[09:30:06.585] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:30:06.589] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:06.590] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:30:06.590]   - Field: ‘label’
[09:30:06.590]   - Field: ‘local’
[09:30:06.590]   - Field: ‘owner’
[09:30:06.590]   - Field: ‘envir’
[09:30:06.590]   - Field: ‘packages’
[09:30:06.590]   - Field: ‘gc’
[09:30:06.590]   - Field: ‘conditions’
[09:30:06.590]   - Field: ‘expr’
[09:30:06.591]   - Field: ‘uuid’
[09:30:06.591]   - Field: ‘seed’
[09:30:06.591]   - Field: ‘version’
[09:30:06.591]   - Field: ‘result’
[09:30:06.591]   - Field: ‘asynchronous’
[09:30:06.591]   - Field: ‘calls’
[09:30:06.591]   - Field: ‘globals’
[09:30:06.591]   - Field: ‘stdout’
[09:30:06.591]   - Field: ‘earlySignal’
[09:30:06.591]   - Field: ‘lazy’
[09:30:06.591]   - Field: ‘state’
[09:30:06.591] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:30:06.592] - Launch lazy future ...
[09:30:06.592] Packages needed by the future expression (n = 0): <none>
[09:30:06.592] Packages needed by future strategies (n = 0): <none>
[09:30:06.592] {
[09:30:06.592]     {
[09:30:06.592]         {
[09:30:06.592]             ...future.startTime <- base::Sys.time()
[09:30:06.592]             {
[09:30:06.592]                 {
[09:30:06.592]                   {
[09:30:06.592]                     base::local({
[09:30:06.592]                       has_future <- base::requireNamespace("future", 
[09:30:06.592]                         quietly = TRUE)
[09:30:06.592]                       if (has_future) {
[09:30:06.592]                         ns <- base::getNamespace("future")
[09:30:06.592]                         version <- ns[[".package"]][["version"]]
[09:30:06.592]                         if (is.null(version)) 
[09:30:06.592]                           version <- utils::packageVersion("future")
[09:30:06.592]                       }
[09:30:06.592]                       else {
[09:30:06.592]                         version <- NULL
[09:30:06.592]                       }
[09:30:06.592]                       if (!has_future || version < "1.8.0") {
[09:30:06.592]                         info <- base::c(r_version = base::gsub("R version ", 
[09:30:06.592]                           "", base::R.version$version.string), 
[09:30:06.592]                           platform = base::sprintf("%s (%s-bit)", 
[09:30:06.592]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:06.592]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:06.592]                             "release", "version")], collapse = " "), 
[09:30:06.592]                           hostname = base::Sys.info()[["nodename"]])
[09:30:06.592]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:30:06.592]                           info)
[09:30:06.592]                         info <- base::paste(info, collapse = "; ")
[09:30:06.592]                         if (!has_future) {
[09:30:06.592]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:06.592]                             info)
[09:30:06.592]                         }
[09:30:06.592]                         else {
[09:30:06.592]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:06.592]                             info, version)
[09:30:06.592]                         }
[09:30:06.592]                         base::stop(msg)
[09:30:06.592]                       }
[09:30:06.592]                     })
[09:30:06.592]                   }
[09:30:06.592]                   ...future.strategy.old <- future::plan("list")
[09:30:06.592]                   options(future.plan = NULL)
[09:30:06.592]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:06.592]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:06.592]                 }
[09:30:06.592]                 ...future.workdir <- getwd()
[09:30:06.592]             }
[09:30:06.592]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:06.592]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:06.592]         }
[09:30:06.592]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:06.592]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:30:06.592]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:06.592]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:06.592]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:06.592]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:06.592]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:06.592]             base::names(...future.oldOptions))
[09:30:06.592]     }
[09:30:06.592]     if (FALSE) {
[09:30:06.592]     }
[09:30:06.592]     else {
[09:30:06.592]         if (TRUE) {
[09:30:06.592]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:06.592]                 open = "w")
[09:30:06.592]         }
[09:30:06.592]         else {
[09:30:06.592]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:06.592]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:06.592]         }
[09:30:06.592]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:06.592]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:06.592]             base::sink(type = "output", split = FALSE)
[09:30:06.592]             base::close(...future.stdout)
[09:30:06.592]         }, add = TRUE)
[09:30:06.592]     }
[09:30:06.592]     ...future.frame <- base::sys.nframe()
[09:30:06.592]     ...future.conditions <- base::list()
[09:30:06.592]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:06.592]     if (FALSE) {
[09:30:06.592]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:06.592]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:06.592]     }
[09:30:06.592]     ...future.result <- base::tryCatch({
[09:30:06.592]         base::withCallingHandlers({
[09:30:06.592]             ...future.value <- base::withVisible(base::local({
[09:30:06.592]                 do.call(function(...) {
[09:30:06.592]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:06.592]                   if (!identical(...future.globals.maxSize.org, 
[09:30:06.592]                     ...future.globals.maxSize)) {
[09:30:06.592]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:06.592]                     on.exit(options(oopts), add = TRUE)
[09:30:06.592]                   }
[09:30:06.592]                   {
[09:30:06.592]                     lapply(seq_along(...future.elements_ii), 
[09:30:06.592]                       FUN = function(jj) {
[09:30:06.592]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:06.592]                         ...future.FUN(...future.X_jj, ...)
[09:30:06.592]                       })
[09:30:06.592]                   }
[09:30:06.592]                 }, args = future.call.arguments)
[09:30:06.592]             }))
[09:30:06.592]             future::FutureResult(value = ...future.value$value, 
[09:30:06.592]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:06.592]                   ...future.rng), globalenv = if (FALSE) 
[09:30:06.592]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:06.592]                     ...future.globalenv.names))
[09:30:06.592]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:06.592]         }, condition = base::local({
[09:30:06.592]             c <- base::c
[09:30:06.592]             inherits <- base::inherits
[09:30:06.592]             invokeRestart <- base::invokeRestart
[09:30:06.592]             length <- base::length
[09:30:06.592]             list <- base::list
[09:30:06.592]             seq.int <- base::seq.int
[09:30:06.592]             signalCondition <- base::signalCondition
[09:30:06.592]             sys.calls <- base::sys.calls
[09:30:06.592]             `[[` <- base::`[[`
[09:30:06.592]             `+` <- base::`+`
[09:30:06.592]             `<<-` <- base::`<<-`
[09:30:06.592]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:06.592]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:06.592]                   3L)]
[09:30:06.592]             }
[09:30:06.592]             function(cond) {
[09:30:06.592]                 is_error <- inherits(cond, "error")
[09:30:06.592]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:06.592]                   NULL)
[09:30:06.592]                 if (is_error) {
[09:30:06.592]                   sessionInformation <- function() {
[09:30:06.592]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:06.592]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:06.592]                       search = base::search(), system = base::Sys.info())
[09:30:06.592]                   }
[09:30:06.592]                   ...future.conditions[[length(...future.conditions) + 
[09:30:06.592]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:06.592]                     cond$call), session = sessionInformation(), 
[09:30:06.592]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:06.592]                   signalCondition(cond)
[09:30:06.592]                 }
[09:30:06.592]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:06.592]                 "immediateCondition"))) {
[09:30:06.592]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:06.592]                   ...future.conditions[[length(...future.conditions) + 
[09:30:06.592]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:06.592]                   if (TRUE && !signal) {
[09:30:06.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:06.592]                     {
[09:30:06.592]                       inherits <- base::inherits
[09:30:06.592]                       invokeRestart <- base::invokeRestart
[09:30:06.592]                       is.null <- base::is.null
[09:30:06.592]                       muffled <- FALSE
[09:30:06.592]                       if (inherits(cond, "message")) {
[09:30:06.592]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:06.592]                         if (muffled) 
[09:30:06.592]                           invokeRestart("muffleMessage")
[09:30:06.592]                       }
[09:30:06.592]                       else if (inherits(cond, "warning")) {
[09:30:06.592]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:06.592]                         if (muffled) 
[09:30:06.592]                           invokeRestart("muffleWarning")
[09:30:06.592]                       }
[09:30:06.592]                       else if (inherits(cond, "condition")) {
[09:30:06.592]                         if (!is.null(pattern)) {
[09:30:06.592]                           computeRestarts <- base::computeRestarts
[09:30:06.592]                           grepl <- base::grepl
[09:30:06.592]                           restarts <- computeRestarts(cond)
[09:30:06.592]                           for (restart in restarts) {
[09:30:06.592]                             name <- restart$name
[09:30:06.592]                             if (is.null(name)) 
[09:30:06.592]                               next
[09:30:06.592]                             if (!grepl(pattern, name)) 
[09:30:06.592]                               next
[09:30:06.592]                             invokeRestart(restart)
[09:30:06.592]                             muffled <- TRUE
[09:30:06.592]                             break
[09:30:06.592]                           }
[09:30:06.592]                         }
[09:30:06.592]                       }
[09:30:06.592]                       invisible(muffled)
[09:30:06.592]                     }
[09:30:06.592]                     muffleCondition(cond, pattern = "^muffle")
[09:30:06.592]                   }
[09:30:06.592]                 }
[09:30:06.592]                 else {
[09:30:06.592]                   if (TRUE) {
[09:30:06.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:06.592]                     {
[09:30:06.592]                       inherits <- base::inherits
[09:30:06.592]                       invokeRestart <- base::invokeRestart
[09:30:06.592]                       is.null <- base::is.null
[09:30:06.592]                       muffled <- FALSE
[09:30:06.592]                       if (inherits(cond, "message")) {
[09:30:06.592]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:06.592]                         if (muffled) 
[09:30:06.592]                           invokeRestart("muffleMessage")
[09:30:06.592]                       }
[09:30:06.592]                       else if (inherits(cond, "warning")) {
[09:30:06.592]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:06.592]                         if (muffled) 
[09:30:06.592]                           invokeRestart("muffleWarning")
[09:30:06.592]                       }
[09:30:06.592]                       else if (inherits(cond, "condition")) {
[09:30:06.592]                         if (!is.null(pattern)) {
[09:30:06.592]                           computeRestarts <- base::computeRestarts
[09:30:06.592]                           grepl <- base::grepl
[09:30:06.592]                           restarts <- computeRestarts(cond)
[09:30:06.592]                           for (restart in restarts) {
[09:30:06.592]                             name <- restart$name
[09:30:06.592]                             if (is.null(name)) 
[09:30:06.592]                               next
[09:30:06.592]                             if (!grepl(pattern, name)) 
[09:30:06.592]                               next
[09:30:06.592]                             invokeRestart(restart)
[09:30:06.592]                             muffled <- TRUE
[09:30:06.592]                             break
[09:30:06.592]                           }
[09:30:06.592]                         }
[09:30:06.592]                       }
[09:30:06.592]                       invisible(muffled)
[09:30:06.592]                     }
[09:30:06.592]                     muffleCondition(cond, pattern = "^muffle")
[09:30:06.592]                   }
[09:30:06.592]                 }
[09:30:06.592]             }
[09:30:06.592]         }))
[09:30:06.592]     }, error = function(ex) {
[09:30:06.592]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:06.592]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:06.592]                 ...future.rng), started = ...future.startTime, 
[09:30:06.592]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:06.592]             version = "1.8"), class = "FutureResult")
[09:30:06.592]     }, finally = {
[09:30:06.592]         if (!identical(...future.workdir, getwd())) 
[09:30:06.592]             setwd(...future.workdir)
[09:30:06.592]         {
[09:30:06.592]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:06.592]                 ...future.oldOptions$nwarnings <- NULL
[09:30:06.592]             }
[09:30:06.592]             base::options(...future.oldOptions)
[09:30:06.592]             if (.Platform$OS.type == "windows") {
[09:30:06.592]                 old_names <- names(...future.oldEnvVars)
[09:30:06.592]                 envs <- base::Sys.getenv()
[09:30:06.592]                 names <- names(envs)
[09:30:06.592]                 common <- intersect(names, old_names)
[09:30:06.592]                 added <- setdiff(names, old_names)
[09:30:06.592]                 removed <- setdiff(old_names, names)
[09:30:06.592]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:06.592]                   envs[common]]
[09:30:06.592]                 NAMES <- toupper(changed)
[09:30:06.592]                 args <- list()
[09:30:06.592]                 for (kk in seq_along(NAMES)) {
[09:30:06.592]                   name <- changed[[kk]]
[09:30:06.592]                   NAME <- NAMES[[kk]]
[09:30:06.592]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:06.592]                     next
[09:30:06.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:06.592]                 }
[09:30:06.592]                 NAMES <- toupper(added)
[09:30:06.592]                 for (kk in seq_along(NAMES)) {
[09:30:06.592]                   name <- added[[kk]]
[09:30:06.592]                   NAME <- NAMES[[kk]]
[09:30:06.592]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:06.592]                     next
[09:30:06.592]                   args[[name]] <- ""
[09:30:06.592]                 }
[09:30:06.592]                 NAMES <- toupper(removed)
[09:30:06.592]                 for (kk in seq_along(NAMES)) {
[09:30:06.592]                   name <- removed[[kk]]
[09:30:06.592]                   NAME <- NAMES[[kk]]
[09:30:06.592]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:06.592]                     next
[09:30:06.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:06.592]                 }
[09:30:06.592]                 if (length(args) > 0) 
[09:30:06.592]                   base::do.call(base::Sys.setenv, args = args)
[09:30:06.592]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:06.592]             }
[09:30:06.592]             else {
[09:30:06.592]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:06.592]             }
[09:30:06.592]             {
[09:30:06.592]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:06.592]                   0L) {
[09:30:06.592]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:06.592]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:06.592]                   base::options(opts)
[09:30:06.592]                 }
[09:30:06.592]                 {
[09:30:06.592]                   {
[09:30:06.592]                     NULL
[09:30:06.592]                     RNGkind("Mersenne-Twister")
[09:30:06.592]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:30:06.592]                       inherits = FALSE)
[09:30:06.592]                   }
[09:30:06.592]                   options(future.plan = NULL)
[09:30:06.592]                   if (is.na(NA_character_)) 
[09:30:06.592]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:06.592]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:06.592]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:06.592]                     .init = FALSE)
[09:30:06.592]                 }
[09:30:06.592]             }
[09:30:06.592]         }
[09:30:06.592]     })
[09:30:06.592]     if (TRUE) {
[09:30:06.592]         base::sink(type = "output", split = FALSE)
[09:30:06.592]         if (TRUE) {
[09:30:06.592]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:06.592]         }
[09:30:06.592]         else {
[09:30:06.592]             ...future.result["stdout"] <- base::list(NULL)
[09:30:06.592]         }
[09:30:06.592]         base::close(...future.stdout)
[09:30:06.592]         ...future.stdout <- NULL
[09:30:06.592]     }
[09:30:06.592]     ...future.result$conditions <- ...future.conditions
[09:30:06.592]     ...future.result$finished <- base::Sys.time()
[09:30:06.592]     ...future.result
[09:30:06.592] }
[09:30:06.594] assign_globals() ...
[09:30:06.594] List of 5
[09:30:06.594]  $ ...future.FUN            :function (x)  
[09:30:06.594]  $ future.call.arguments    : list()
[09:30:06.594]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:06.594]  $ ...future.elements_ii    :List of 2
[09:30:06.594]   ..$ : int 1
[09:30:06.594]   ..$ : int 0
[09:30:06.594]  $ ...future.seeds_ii       : NULL
[09:30:06.594]  $ ...future.globals.maxSize: NULL
[09:30:06.594]  - attr(*, "where")=List of 5
[09:30:06.594]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:06.594]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:30:06.594]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:06.594]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:06.594]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:06.594]  - attr(*, "resolved")= logi FALSE
[09:30:06.594]  - attr(*, "total_size")= num 4720
[09:30:06.594]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:06.594]  - attr(*, "already-done")= logi TRUE
[09:30:06.599] - reassign environment for ‘...future.FUN’
[09:30:06.599] - copied ‘...future.FUN’ to environment
[09:30:06.599] - copied ‘future.call.arguments’ to environment
[09:30:06.599] - copied ‘...future.elements_ii’ to environment
[09:30:06.599] - copied ‘...future.seeds_ii’ to environment
[09:30:06.599] - copied ‘...future.globals.maxSize’ to environment
[09:30:06.599] assign_globals() ... done
[09:30:06.600] plan(): Setting new future strategy stack:
[09:30:06.600] List of future strategies:
[09:30:06.600] 1. sequential:
[09:30:06.600]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:06.600]    - tweaked: FALSE
[09:30:06.600]    - call: NULL
[09:30:06.600] plan(): nbrOfWorkers() = 1
[09:30:07.102] plan(): Setting new future strategy stack:
[09:30:07.102] List of future strategies:
[09:30:07.102] 1. multisession:
[09:30:07.102]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:30:07.102]    - tweaked: FALSE
[09:30:07.102]    - call: plan(strategy)
[09:30:07.106] plan(): nbrOfWorkers() = 1
[09:30:07.106] SequentialFuture started (and completed)
[09:30:07.106] - Launch lazy future ... done
[09:30:07.106] run() for ‘SequentialFuture’ ... done
[09:30:07.106] Created future:
[09:30:07.106] SequentialFuture:
[09:30:07.106] Label: ‘future_lapply-1’
[09:30:07.106] Expression:
[09:30:07.106] {
[09:30:07.106]     do.call(function(...) {
[09:30:07.106]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:07.106]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:07.106]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:07.106]             on.exit(options(oopts), add = TRUE)
[09:30:07.106]         }
[09:30:07.106]         {
[09:30:07.106]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:07.106]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:07.106]                 ...future.FUN(...future.X_jj, ...)
[09:30:07.106]             })
[09:30:07.106]         }
[09:30:07.106]     }, args = future.call.arguments)
[09:30:07.106] }
[09:30:07.106] Lazy evaluation: FALSE
[09:30:07.106] Asynchronous evaluation: FALSE
[09:30:07.106] Local evaluation: TRUE
[09:30:07.106] Environment: R_GlobalEnv
[09:30:07.106] Capture standard output: TRUE
[09:30:07.106] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:07.106] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:07.106] Packages: <none>
[09:30:07.106] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:07.106] Resolved: TRUE
[09:30:07.106] Value: 112 bytes of class ‘list’
[09:30:07.106] Early signaling: FALSE
[09:30:07.106] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:07.106] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:07.107] Chunk #1 of 1 ... DONE
[09:30:07.108] Launching 1 futures (chunks) ... DONE
[09:30:07.108] Resolving 1 futures (chunks) ...
[09:30:07.108] resolve() on list ...
[09:30:07.108]  recursive: 0
[09:30:07.108]  length: 1
[09:30:07.108] 
[09:30:07.108] resolved() for ‘SequentialFuture’ ...
[09:30:07.108] - state: ‘finished’
[09:30:07.108] - run: TRUE
[09:30:07.108] - result: ‘FutureResult’
[09:30:07.109] resolved() for ‘SequentialFuture’ ... done
[09:30:07.109] Future #1
[09:30:07.109] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:30:07.109] - nx: 1
[09:30:07.109] - relay: TRUE
[09:30:07.109] - stdout: TRUE
[09:30:07.109] - signal: TRUE
[09:30:07.109] - resignal: FALSE
[09:30:07.109] - force: TRUE
[09:30:07.109] - relayed: [n=1] FALSE
[09:30:07.109] - queued futures: [n=1] FALSE
[09:30:07.110]  - until=1
[09:30:07.110]  - relaying element #1
[09:30:07.110] - relayed: [n=1] TRUE
[09:30:07.110] - queued futures: [n=1] TRUE
[09:30:07.110] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:30:07.110]  length: 0 (resolved future 1)
[09:30:07.110] Relaying remaining futures
[09:30:07.110] signalConditionsASAP(NULL, pos=0) ...
[09:30:07.110] - nx: 1
[09:30:07.110] - relay: TRUE
[09:30:07.111] - stdout: TRUE
[09:30:07.111] - signal: TRUE
[09:30:07.111] - resignal: FALSE
[09:30:07.111] - force: TRUE
[09:30:07.111] - relayed: [n=1] TRUE
[09:30:07.111] - queued futures: [n=1] TRUE
 - flush all
[09:30:07.111] - relayed: [n=1] TRUE
[09:30:07.111] - queued futures: [n=1] TRUE
[09:30:07.111] signalConditionsASAP(NULL, pos=0) ... done
[09:30:07.111] resolve() on list ... DONE
[09:30:07.111]  - Number of value chunks collected: 1
[09:30:07.112] Resolving 1 futures (chunks) ... DONE
[09:30:07.112] Reducing values from 1 chunks ...
[09:30:07.112]  - Number of values collected after concatenation: 2
[09:30:07.112]  - Number of values expected: 2
[09:30:07.112] Reducing values from 1 chunks ... DONE
[09:30:07.112] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[09:30:07.112] future_lapply() ...
[09:30:07.116] Number of chunks: 1
[09:30:07.116] getGlobalsAndPackagesXApply() ...
[09:30:07.116]  - future.globals: TRUE
[09:30:07.116] getGlobalsAndPackages() ...
[09:30:07.116] Searching for globals...
[09:30:07.118] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[09:30:07.118] Searching for globals ... DONE
[09:30:07.118] Resolving globals: FALSE
[09:30:07.119] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[09:30:07.119] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[09:30:07.119] - globals: [1] ‘FUN’
[09:30:07.119] 
[09:30:07.119] getGlobalsAndPackages() ... DONE
[09:30:07.119]  - globals found/used: [n=1] ‘FUN’
[09:30:07.119]  - needed namespaces: [n=0] 
[09:30:07.119] Finding globals ... DONE
[09:30:07.120]  - use_args: TRUE
[09:30:07.120]  - Getting '...' globals ...
[09:30:07.120] resolve() on list ...
[09:30:07.120]  recursive: 0
[09:30:07.120]  length: 1
[09:30:07.120]  elements: ‘...’
[09:30:07.120]  length: 0 (resolved future 1)
[09:30:07.120] resolve() on list ... DONE
[09:30:07.122]    - '...' content: [n=0] 
[09:30:07.122] List of 1
[09:30:07.122]  $ ...: list()
[09:30:07.122]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:07.122]  - attr(*, "where")=List of 1
[09:30:07.122]   ..$ ...:<environment: 0x55c103c18ea8> 
[09:30:07.122]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:07.122]  - attr(*, "resolved")= logi TRUE
[09:30:07.122]  - attr(*, "total_size")= num NA
[09:30:07.125]  - Getting '...' globals ... DONE
[09:30:07.125] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:30:07.125] List of 2
[09:30:07.125]  $ ...future.FUN:function (x)  
[09:30:07.125]  $ ...          : list()
[09:30:07.125]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:07.125]  - attr(*, "where")=List of 2
[09:30:07.125]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:07.125]   ..$ ...          :<environment: 0x55c103c18ea8> 
[09:30:07.125]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:07.125]  - attr(*, "resolved")= logi FALSE
[09:30:07.125]  - attr(*, "total_size")= num 4720
[09:30:07.128] Packages to be attached in all futures: [n=0] 
[09:30:07.128] getGlobalsAndPackagesXApply() ... DONE
[09:30:07.128] Number of futures (= number of chunks): 1
[09:30:07.128] Launching 1 futures (chunks) ...
[09:30:07.128] Chunk #1 of 1 ...
[09:30:07.128]  - Finding globals in 'X' for chunk #1 ...
[09:30:07.128] getGlobalsAndPackages() ...
[09:30:07.128] Searching for globals...
[09:30:07.129] 
[09:30:07.129] Searching for globals ... DONE
[09:30:07.129] - globals: [0] <none>
[09:30:07.129] getGlobalsAndPackages() ... DONE
[09:30:07.129]    + additional globals found: [n=0] 
[09:30:07.129]    + additional namespaces needed: [n=0] 
[09:30:07.129]  - Finding globals in 'X' for chunk #1 ... DONE
[09:30:07.129]  - seeds: <none>
[09:30:07.129]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:07.130] getGlobalsAndPackages() ...
[09:30:07.130] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:07.130] Resolving globals: FALSE
[09:30:07.130] Tweak future expression to call with '...' arguments ...
[09:30:07.130] {
[09:30:07.130]     do.call(function(...) {
[09:30:07.130]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:07.130]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:07.130]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:07.130]             on.exit(options(oopts), add = TRUE)
[09:30:07.130]         }
[09:30:07.130]         {
[09:30:07.130]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:07.130]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:07.130]                 ...future.FUN(...future.X_jj, ...)
[09:30:07.130]             })
[09:30:07.130]         }
[09:30:07.130]     }, args = future.call.arguments)
[09:30:07.130] }
[09:30:07.130] Tweak future expression to call with '...' arguments ... DONE
[09:30:07.130] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:07.131] 
[09:30:07.131] getGlobalsAndPackages() ... DONE
[09:30:07.131] run() for ‘Future’ ...
[09:30:07.131] - state: ‘created’
[09:30:07.131] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:30:07.134] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:07.135] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:30:07.135]   - Field: ‘label’
[09:30:07.135]   - Field: ‘local’
[09:30:07.135]   - Field: ‘owner’
[09:30:07.135]   - Field: ‘envir’
[09:30:07.135]   - Field: ‘packages’
[09:30:07.135]   - Field: ‘gc’
[09:30:07.135]   - Field: ‘conditions’
[09:30:07.135]   - Field: ‘expr’
[09:30:07.135]   - Field: ‘uuid’
[09:30:07.135]   - Field: ‘seed’
[09:30:07.136]   - Field: ‘version’
[09:30:07.136]   - Field: ‘result’
[09:30:07.136]   - Field: ‘asynchronous’
[09:30:07.136]   - Field: ‘calls’
[09:30:07.136]   - Field: ‘globals’
[09:30:07.136]   - Field: ‘stdout’
[09:30:07.136]   - Field: ‘earlySignal’
[09:30:07.136]   - Field: ‘lazy’
[09:30:07.136]   - Field: ‘state’
[09:30:07.136] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:30:07.137] - Launch lazy future ...
[09:30:07.137] Packages needed by the future expression (n = 0): <none>
[09:30:07.137] Packages needed by future strategies (n = 0): <none>
[09:30:07.137] {
[09:30:07.137]     {
[09:30:07.137]         {
[09:30:07.137]             ...future.startTime <- base::Sys.time()
[09:30:07.137]             {
[09:30:07.137]                 {
[09:30:07.137]                   {
[09:30:07.137]                     base::local({
[09:30:07.137]                       has_future <- base::requireNamespace("future", 
[09:30:07.137]                         quietly = TRUE)
[09:30:07.137]                       if (has_future) {
[09:30:07.137]                         ns <- base::getNamespace("future")
[09:30:07.137]                         version <- ns[[".package"]][["version"]]
[09:30:07.137]                         if (is.null(version)) 
[09:30:07.137]                           version <- utils::packageVersion("future")
[09:30:07.137]                       }
[09:30:07.137]                       else {
[09:30:07.137]                         version <- NULL
[09:30:07.137]                       }
[09:30:07.137]                       if (!has_future || version < "1.8.0") {
[09:30:07.137]                         info <- base::c(r_version = base::gsub("R version ", 
[09:30:07.137]                           "", base::R.version$version.string), 
[09:30:07.137]                           platform = base::sprintf("%s (%s-bit)", 
[09:30:07.137]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:07.137]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:07.137]                             "release", "version")], collapse = " "), 
[09:30:07.137]                           hostname = base::Sys.info()[["nodename"]])
[09:30:07.137]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:30:07.137]                           info)
[09:30:07.137]                         info <- base::paste(info, collapse = "; ")
[09:30:07.137]                         if (!has_future) {
[09:30:07.137]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:07.137]                             info)
[09:30:07.137]                         }
[09:30:07.137]                         else {
[09:30:07.137]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:07.137]                             info, version)
[09:30:07.137]                         }
[09:30:07.137]                         base::stop(msg)
[09:30:07.137]                       }
[09:30:07.137]                     })
[09:30:07.137]                   }
[09:30:07.137]                   ...future.strategy.old <- future::plan("list")
[09:30:07.137]                   options(future.plan = NULL)
[09:30:07.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:07.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:07.137]                 }
[09:30:07.137]                 ...future.workdir <- getwd()
[09:30:07.137]             }
[09:30:07.137]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:07.137]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:07.137]         }
[09:30:07.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:07.137]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:30:07.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:07.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:07.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:07.137]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:07.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:07.137]             base::names(...future.oldOptions))
[09:30:07.137]     }
[09:30:07.137]     if (TRUE) {
[09:30:07.137]     }
[09:30:07.137]     else {
[09:30:07.137]         if (NA) {
[09:30:07.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:07.137]                 open = "w")
[09:30:07.137]         }
[09:30:07.137]         else {
[09:30:07.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:07.137]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:07.137]         }
[09:30:07.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:07.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:07.137]             base::sink(type = "output", split = FALSE)
[09:30:07.137]             base::close(...future.stdout)
[09:30:07.137]         }, add = TRUE)
[09:30:07.137]     }
[09:30:07.137]     ...future.frame <- base::sys.nframe()
[09:30:07.137]     ...future.conditions <- base::list()
[09:30:07.137]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:07.137]     if (FALSE) {
[09:30:07.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:07.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:07.137]     }
[09:30:07.137]     ...future.result <- base::tryCatch({
[09:30:07.137]         base::withCallingHandlers({
[09:30:07.137]             ...future.value <- base::withVisible(base::local({
[09:30:07.137]                 do.call(function(...) {
[09:30:07.137]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:07.137]                   if (!identical(...future.globals.maxSize.org, 
[09:30:07.137]                     ...future.globals.maxSize)) {
[09:30:07.137]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:07.137]                     on.exit(options(oopts), add = TRUE)
[09:30:07.137]                   }
[09:30:07.137]                   {
[09:30:07.137]                     lapply(seq_along(...future.elements_ii), 
[09:30:07.137]                       FUN = function(jj) {
[09:30:07.137]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:07.137]                         ...future.FUN(...future.X_jj, ...)
[09:30:07.137]                       })
[09:30:07.137]                   }
[09:30:07.137]                 }, args = future.call.arguments)
[09:30:07.137]             }))
[09:30:07.137]             future::FutureResult(value = ...future.value$value, 
[09:30:07.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:07.137]                   ...future.rng), globalenv = if (FALSE) 
[09:30:07.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:07.137]                     ...future.globalenv.names))
[09:30:07.137]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:07.137]         }, condition = base::local({
[09:30:07.137]             c <- base::c
[09:30:07.137]             inherits <- base::inherits
[09:30:07.137]             invokeRestart <- base::invokeRestart
[09:30:07.137]             length <- base::length
[09:30:07.137]             list <- base::list
[09:30:07.137]             seq.int <- base::seq.int
[09:30:07.137]             signalCondition <- base::signalCondition
[09:30:07.137]             sys.calls <- base::sys.calls
[09:30:07.137]             `[[` <- base::`[[`
[09:30:07.137]             `+` <- base::`+`
[09:30:07.137]             `<<-` <- base::`<<-`
[09:30:07.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:07.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:07.137]                   3L)]
[09:30:07.137]             }
[09:30:07.137]             function(cond) {
[09:30:07.137]                 is_error <- inherits(cond, "error")
[09:30:07.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:07.137]                   NULL)
[09:30:07.137]                 if (is_error) {
[09:30:07.137]                   sessionInformation <- function() {
[09:30:07.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:07.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:07.137]                       search = base::search(), system = base::Sys.info())
[09:30:07.137]                   }
[09:30:07.137]                   ...future.conditions[[length(...future.conditions) + 
[09:30:07.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:07.137]                     cond$call), session = sessionInformation(), 
[09:30:07.137]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:07.137]                   signalCondition(cond)
[09:30:07.137]                 }
[09:30:07.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:07.137]                 "immediateCondition"))) {
[09:30:07.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:07.137]                   ...future.conditions[[length(...future.conditions) + 
[09:30:07.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:07.137]                   if (TRUE && !signal) {
[09:30:07.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:07.137]                     {
[09:30:07.137]                       inherits <- base::inherits
[09:30:07.137]                       invokeRestart <- base::invokeRestart
[09:30:07.137]                       is.null <- base::is.null
[09:30:07.137]                       muffled <- FALSE
[09:30:07.137]                       if (inherits(cond, "message")) {
[09:30:07.137]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:07.137]                         if (muffled) 
[09:30:07.137]                           invokeRestart("muffleMessage")
[09:30:07.137]                       }
[09:30:07.137]                       else if (inherits(cond, "warning")) {
[09:30:07.137]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:07.137]                         if (muffled) 
[09:30:07.137]                           invokeRestart("muffleWarning")
[09:30:07.137]                       }
[09:30:07.137]                       else if (inherits(cond, "condition")) {
[09:30:07.137]                         if (!is.null(pattern)) {
[09:30:07.137]                           computeRestarts <- base::computeRestarts
[09:30:07.137]                           grepl <- base::grepl
[09:30:07.137]                           restarts <- computeRestarts(cond)
[09:30:07.137]                           for (restart in restarts) {
[09:30:07.137]                             name <- restart$name
[09:30:07.137]                             if (is.null(name)) 
[09:30:07.137]                               next
[09:30:07.137]                             if (!grepl(pattern, name)) 
[09:30:07.137]                               next
[09:30:07.137]                             invokeRestart(restart)
[09:30:07.137]                             muffled <- TRUE
[09:30:07.137]                             break
[09:30:07.137]                           }
[09:30:07.137]                         }
[09:30:07.137]                       }
[09:30:07.137]                       invisible(muffled)
[09:30:07.137]                     }
[09:30:07.137]                     muffleCondition(cond, pattern = "^muffle")
[09:30:07.137]                   }
[09:30:07.137]                 }
[09:30:07.137]                 else {
[09:30:07.137]                   if (TRUE) {
[09:30:07.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:07.137]                     {
[09:30:07.137]                       inherits <- base::inherits
[09:30:07.137]                       invokeRestart <- base::invokeRestart
[09:30:07.137]                       is.null <- base::is.null
[09:30:07.137]                       muffled <- FALSE
[09:30:07.137]                       if (inherits(cond, "message")) {
[09:30:07.137]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:07.137]                         if (muffled) 
[09:30:07.137]                           invokeRestart("muffleMessage")
[09:30:07.137]                       }
[09:30:07.137]                       else if (inherits(cond, "warning")) {
[09:30:07.137]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:07.137]                         if (muffled) 
[09:30:07.137]                           invokeRestart("muffleWarning")
[09:30:07.137]                       }
[09:30:07.137]                       else if (inherits(cond, "condition")) {
[09:30:07.137]                         if (!is.null(pattern)) {
[09:30:07.137]                           computeRestarts <- base::computeRestarts
[09:30:07.137]                           grepl <- base::grepl
[09:30:07.137]                           restarts <- computeRestarts(cond)
[09:30:07.137]                           for (restart in restarts) {
[09:30:07.137]                             name <- restart$name
[09:30:07.137]                             if (is.null(name)) 
[09:30:07.137]                               next
[09:30:07.137]                             if (!grepl(pattern, name)) 
[09:30:07.137]                               next
[09:30:07.137]                             invokeRestart(restart)
[09:30:07.137]                             muffled <- TRUE
[09:30:07.137]                             break
[09:30:07.137]                           }
[09:30:07.137]                         }
[09:30:07.137]                       }
[09:30:07.137]                       invisible(muffled)
[09:30:07.137]                     }
[09:30:07.137]                     muffleCondition(cond, pattern = "^muffle")
[09:30:07.137]                   }
[09:30:07.137]                 }
[09:30:07.137]             }
[09:30:07.137]         }))
[09:30:07.137]     }, error = function(ex) {
[09:30:07.137]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:07.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:07.137]                 ...future.rng), started = ...future.startTime, 
[09:30:07.137]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:07.137]             version = "1.8"), class = "FutureResult")
[09:30:07.137]     }, finally = {
[09:30:07.137]         if (!identical(...future.workdir, getwd())) 
[09:30:07.137]             setwd(...future.workdir)
[09:30:07.137]         {
[09:30:07.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:07.137]                 ...future.oldOptions$nwarnings <- NULL
[09:30:07.137]             }
[09:30:07.137]             base::options(...future.oldOptions)
[09:30:07.137]             if (.Platform$OS.type == "windows") {
[09:30:07.137]                 old_names <- names(...future.oldEnvVars)
[09:30:07.137]                 envs <- base::Sys.getenv()
[09:30:07.137]                 names <- names(envs)
[09:30:07.137]                 common <- intersect(names, old_names)
[09:30:07.137]                 added <- setdiff(names, old_names)
[09:30:07.137]                 removed <- setdiff(old_names, names)
[09:30:07.137]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:07.137]                   envs[common]]
[09:30:07.137]                 NAMES <- toupper(changed)
[09:30:07.137]                 args <- list()
[09:30:07.137]                 for (kk in seq_along(NAMES)) {
[09:30:07.137]                   name <- changed[[kk]]
[09:30:07.137]                   NAME <- NAMES[[kk]]
[09:30:07.137]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:07.137]                     next
[09:30:07.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:07.137]                 }
[09:30:07.137]                 NAMES <- toupper(added)
[09:30:07.137]                 for (kk in seq_along(NAMES)) {
[09:30:07.137]                   name <- added[[kk]]
[09:30:07.137]                   NAME <- NAMES[[kk]]
[09:30:07.137]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:07.137]                     next
[09:30:07.137]                   args[[name]] <- ""
[09:30:07.137]                 }
[09:30:07.137]                 NAMES <- toupper(removed)
[09:30:07.137]                 for (kk in seq_along(NAMES)) {
[09:30:07.137]                   name <- removed[[kk]]
[09:30:07.137]                   NAME <- NAMES[[kk]]
[09:30:07.137]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:07.137]                     next
[09:30:07.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:07.137]                 }
[09:30:07.137]                 if (length(args) > 0) 
[09:30:07.137]                   base::do.call(base::Sys.setenv, args = args)
[09:30:07.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:07.137]             }
[09:30:07.137]             else {
[09:30:07.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:07.137]             }
[09:30:07.137]             {
[09:30:07.137]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:07.137]                   0L) {
[09:30:07.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:07.137]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:07.137]                   base::options(opts)
[09:30:07.137]                 }
[09:30:07.137]                 {
[09:30:07.137]                   {
[09:30:07.137]                     NULL
[09:30:07.137]                     RNGkind("Mersenne-Twister")
[09:30:07.137]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:30:07.137]                       inherits = FALSE)
[09:30:07.137]                   }
[09:30:07.137]                   options(future.plan = NULL)
[09:30:07.137]                   if (is.na(NA_character_)) 
[09:30:07.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:07.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:07.137]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:07.137]                     .init = FALSE)
[09:30:07.137]                 }
[09:30:07.137]             }
[09:30:07.137]         }
[09:30:07.137]     })
[09:30:07.137]     if (FALSE) {
[09:30:07.137]         base::sink(type = "output", split = FALSE)
[09:30:07.137]         if (NA) {
[09:30:07.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:07.137]         }
[09:30:07.137]         else {
[09:30:07.137]             ...future.result["stdout"] <- base::list(NULL)
[09:30:07.137]         }
[09:30:07.137]         base::close(...future.stdout)
[09:30:07.137]         ...future.stdout <- NULL
[09:30:07.137]     }
[09:30:07.137]     ...future.result$conditions <- ...future.conditions
[09:30:07.137]     ...future.result$finished <- base::Sys.time()
[09:30:07.137]     ...future.result
[09:30:07.137] }
[09:30:07.139] assign_globals() ...
[09:30:07.139] List of 5
[09:30:07.139]  $ ...future.FUN            :function (x)  
[09:30:07.139]  $ future.call.arguments    : list()
[09:30:07.139]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:07.139]  $ ...future.elements_ii    :List of 2
[09:30:07.139]   ..$ : int 1
[09:30:07.139]   ..$ : int 0
[09:30:07.139]  $ ...future.seeds_ii       : NULL
[09:30:07.139]  $ ...future.globals.maxSize: NULL
[09:30:07.139]  - attr(*, "where")=List of 5
[09:30:07.139]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:07.139]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:30:07.139]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:07.139]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:07.139]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:07.139]  - attr(*, "resolved")= logi FALSE
[09:30:07.139]  - attr(*, "total_size")= num 4720
[09:30:07.139]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:07.139]  - attr(*, "already-done")= logi TRUE
[09:30:07.144] - reassign environment for ‘...future.FUN’
[09:30:07.144] - copied ‘...future.FUN’ to environment
[09:30:07.144] - copied ‘future.call.arguments’ to environment
[09:30:07.144] - copied ‘...future.elements_ii’ to environment
[09:30:07.144] - copied ‘...future.seeds_ii’ to environment
[09:30:07.144] - copied ‘...future.globals.maxSize’ to environment
[09:30:07.144] assign_globals() ... done
[09:30:07.144] plan(): Setting new future strategy stack:
[09:30:07.144] List of future strategies:
[09:30:07.144] 1. sequential:
[09:30:07.144]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:07.144]    - tweaked: FALSE
[09:30:07.144]    - call: NULL
[09:30:07.145] plan(): nbrOfWorkers() = 1
[09:30:07.646] plan(): Setting new future strategy stack:
[09:30:07.647] List of future strategies:
[09:30:07.647] 1. multisession:
[09:30:07.647]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:30:07.647]    - tweaked: FALSE
[09:30:07.647]    - call: plan(strategy)
[09:30:07.650] plan(): nbrOfWorkers() = 1
[09:30:07.650] SequentialFuture started (and completed)
[09:30:07.651] - Launch lazy future ... done
[09:30:07.651] run() for ‘SequentialFuture’ ... done
[09:30:07.651] Created future:
[09:30:07.651] SequentialFuture:
[09:30:07.651] Label: ‘future_lapply-1’
[09:30:07.651] Expression:
[09:30:07.651] {
[09:30:07.651]     do.call(function(...) {
[09:30:07.651]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:07.651]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:07.651]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:07.651]             on.exit(options(oopts), add = TRUE)
[09:30:07.651]         }
[09:30:07.651]         {
[09:30:07.651]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:07.651]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:07.651]                 ...future.FUN(...future.X_jj, ...)
[09:30:07.651]             })
[09:30:07.651]         }
[09:30:07.651]     }, args = future.call.arguments)
[09:30:07.651] }
[09:30:07.651] Lazy evaluation: FALSE
[09:30:07.651] Asynchronous evaluation: FALSE
[09:30:07.651] Local evaluation: TRUE
[09:30:07.651] Environment: R_GlobalEnv
[09:30:07.651] Capture standard output: NA
[09:30:07.651] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:07.651] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:07.651] Packages: <none>
[09:30:07.651] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:07.651] Resolved: TRUE
[09:30:07.651] Value: 112 bytes of class ‘list’
[09:30:07.651] Early signaling: FALSE
[09:30:07.651] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:07.651] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:07.652] Chunk #1 of 1 ... DONE
[09:30:07.652] Launching 1 futures (chunks) ... DONE
[09:30:07.652] Resolving 1 futures (chunks) ...
[09:30:07.652] resolve() on list ...
[09:30:07.652]  recursive: 0
[09:30:07.653]  length: 1
[09:30:07.653] 
[09:30:07.653] resolved() for ‘SequentialFuture’ ...
[09:30:07.653] - state: ‘finished’
[09:30:07.653] - run: TRUE
[09:30:07.653] - result: ‘FutureResult’
[09:30:07.653] resolved() for ‘SequentialFuture’ ... done
[09:30:07.653] Future #1
[09:30:07.653] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:30:07.653] - nx: 1
[09:30:07.654] - relay: TRUE
[09:30:07.654] - stdout: TRUE
[09:30:07.654] - signal: TRUE
[09:30:07.654] - resignal: FALSE
[09:30:07.655] - force: TRUE
[09:30:07.655] - relayed: [n=1] FALSE
[09:30:07.656] - queued futures: [n=1] FALSE
[09:30:07.656]  - until=1
[09:30:07.656]  - relaying element #1
[09:30:07.656] - relayed: [n=1] TRUE
[09:30:07.656] - queued futures: [n=1] TRUE
[09:30:07.656] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:30:07.656]  length: 0 (resolved future 1)
[09:30:07.656] Relaying remaining futures
[09:30:07.657] signalConditionsASAP(NULL, pos=0) ...
[09:30:07.657] - nx: 1
[09:30:07.657] - relay: TRUE
[09:30:07.657] - stdout: TRUE
[09:30:07.657] - signal: TRUE
[09:30:07.657] - resignal: FALSE
[09:30:07.657] - force: TRUE
[09:30:07.657] - relayed: [n=1] TRUE
[09:30:07.657] - queued futures: [n=1] TRUE
 - flush all
[09:30:07.658] - relayed: [n=1] TRUE
[09:30:07.658] - queued futures: [n=1] TRUE
[09:30:07.658] signalConditionsASAP(NULL, pos=0) ... done
[09:30:07.658] resolve() on list ... DONE
[09:30:07.658]  - Number of value chunks collected: 1
[09:30:07.658] Resolving 1 futures (chunks) ... DONE
[09:30:07.658] Reducing values from 1 chunks ...
[09:30:07.658]  - Number of values collected after concatenation: 2
[09:30:07.658]  - Number of values expected: 2
[09:30:07.658] Reducing values from 1 chunks ... DONE
[09:30:07.658] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[09:30:07.659] future_mapply() ...
[09:30:07.662] Number of chunks: 1
[09:30:07.662] getGlobalsAndPackagesXApply() ...
[09:30:07.662]  - future.globals: TRUE
[09:30:07.662] getGlobalsAndPackages() ...
[09:30:07.662] Searching for globals...
[09:30:07.664] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[09:30:07.664] Searching for globals ... DONE
[09:30:07.664] Resolving globals: FALSE
[09:30:07.665] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[09:30:07.665] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[09:30:07.665] - globals: [1] ‘FUN’
[09:30:07.665] 
[09:30:07.665] getGlobalsAndPackages() ... DONE
[09:30:07.665]  - globals found/used: [n=1] ‘FUN’
[09:30:07.665]  - needed namespaces: [n=0] 
[09:30:07.666] Finding globals ... DONE
[09:30:07.666] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:30:07.666] List of 2
[09:30:07.666]  $ ...future.FUN:function (x, y)  
[09:30:07.666]  $ MoreArgs     : NULL
[09:30:07.666]  - attr(*, "where")=List of 2
[09:30:07.666]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:07.666]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:30:07.666]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:07.666]  - attr(*, "resolved")= logi FALSE
[09:30:07.666]  - attr(*, "total_size")= num NA
[09:30:07.668] Packages to be attached in all futures: [n=0] 
[09:30:07.668] getGlobalsAndPackagesXApply() ... DONE
[09:30:07.669] Number of futures (= number of chunks): 1
[09:30:07.669] Launching 1 futures (chunks) ...
[09:30:07.669] Chunk #1 of 1 ...
[09:30:07.669]  - Finding globals in '...' for chunk #1 ...
[09:30:07.669] getGlobalsAndPackages() ...
[09:30:07.669] Searching for globals...
[09:30:07.669] 
[09:30:07.669] Searching for globals ... DONE
[09:30:07.670] - globals: [0] <none>
[09:30:07.670] getGlobalsAndPackages() ... DONE
[09:30:07.670]    + additional globals found: [n=0] 
[09:30:07.670]    + additional namespaces needed: [n=0] 
[09:30:07.670]  - Finding globals in '...' for chunk #1 ... DONE
[09:30:07.670]  - seeds: <none>
[09:30:07.670]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:07.670] getGlobalsAndPackages() ...
[09:30:07.670] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:07.670] Resolving globals: FALSE
[09:30:07.671] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[09:30:07.671] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:30:07.671] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:07.671] 
[09:30:07.672] getGlobalsAndPackages() ... DONE
[09:30:07.672] run() for ‘Future’ ...
[09:30:07.672] - state: ‘created’
[09:30:07.672] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:30:07.675] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:07.675] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:30:07.675]   - Field: ‘label’
[09:30:07.676]   - Field: ‘local’
[09:30:07.676]   - Field: ‘owner’
[09:30:07.676]   - Field: ‘envir’
[09:30:07.676]   - Field: ‘packages’
[09:30:07.676]   - Field: ‘gc’
[09:30:07.676]   - Field: ‘conditions’
[09:30:07.676]   - Field: ‘expr’
[09:30:07.676]   - Field: ‘uuid’
[09:30:07.676]   - Field: ‘seed’
[09:30:07.676]   - Field: ‘version’
[09:30:07.677]   - Field: ‘result’
[09:30:07.677]   - Field: ‘asynchronous’
[09:30:07.677]   - Field: ‘calls’
[09:30:07.677]   - Field: ‘globals’
[09:30:07.677]   - Field: ‘stdout’
[09:30:07.677]   - Field: ‘earlySignal’
[09:30:07.677]   - Field: ‘lazy’
[09:30:07.677]   - Field: ‘state’
[09:30:07.677] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:30:07.677] - Launch lazy future ...
[09:30:07.678] Packages needed by the future expression (n = 0): <none>
[09:30:07.678] Packages needed by future strategies (n = 0): <none>
[09:30:07.678] {
[09:30:07.678]     {
[09:30:07.678]         {
[09:30:07.678]             ...future.startTime <- base::Sys.time()
[09:30:07.678]             {
[09:30:07.678]                 {
[09:30:07.678]                   {
[09:30:07.678]                     base::local({
[09:30:07.678]                       has_future <- base::requireNamespace("future", 
[09:30:07.678]                         quietly = TRUE)
[09:30:07.678]                       if (has_future) {
[09:30:07.678]                         ns <- base::getNamespace("future")
[09:30:07.678]                         version <- ns[[".package"]][["version"]]
[09:30:07.678]                         if (is.null(version)) 
[09:30:07.678]                           version <- utils::packageVersion("future")
[09:30:07.678]                       }
[09:30:07.678]                       else {
[09:30:07.678]                         version <- NULL
[09:30:07.678]                       }
[09:30:07.678]                       if (!has_future || version < "1.8.0") {
[09:30:07.678]                         info <- base::c(r_version = base::gsub("R version ", 
[09:30:07.678]                           "", base::R.version$version.string), 
[09:30:07.678]                           platform = base::sprintf("%s (%s-bit)", 
[09:30:07.678]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:07.678]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:07.678]                             "release", "version")], collapse = " "), 
[09:30:07.678]                           hostname = base::Sys.info()[["nodename"]])
[09:30:07.678]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:30:07.678]                           info)
[09:30:07.678]                         info <- base::paste(info, collapse = "; ")
[09:30:07.678]                         if (!has_future) {
[09:30:07.678]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:07.678]                             info)
[09:30:07.678]                         }
[09:30:07.678]                         else {
[09:30:07.678]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:07.678]                             info, version)
[09:30:07.678]                         }
[09:30:07.678]                         base::stop(msg)
[09:30:07.678]                       }
[09:30:07.678]                     })
[09:30:07.678]                   }
[09:30:07.678]                   ...future.strategy.old <- future::plan("list")
[09:30:07.678]                   options(future.plan = NULL)
[09:30:07.678]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:07.678]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:07.678]                 }
[09:30:07.678]                 ...future.workdir <- getwd()
[09:30:07.678]             }
[09:30:07.678]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:07.678]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:07.678]         }
[09:30:07.678]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:07.678]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:30:07.678]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:07.678]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:07.678]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:07.678]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:07.678]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:07.678]             base::names(...future.oldOptions))
[09:30:07.678]     }
[09:30:07.678]     if (FALSE) {
[09:30:07.678]     }
[09:30:07.678]     else {
[09:30:07.678]         if (FALSE) {
[09:30:07.678]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:07.678]                 open = "w")
[09:30:07.678]         }
[09:30:07.678]         else {
[09:30:07.678]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:07.678]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:07.678]         }
[09:30:07.678]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:07.678]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:07.678]             base::sink(type = "output", split = FALSE)
[09:30:07.678]             base::close(...future.stdout)
[09:30:07.678]         }, add = TRUE)
[09:30:07.678]     }
[09:30:07.678]     ...future.frame <- base::sys.nframe()
[09:30:07.678]     ...future.conditions <- base::list()
[09:30:07.678]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:07.678]     if (FALSE) {
[09:30:07.678]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:07.678]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:07.678]     }
[09:30:07.678]     ...future.result <- base::tryCatch({
[09:30:07.678]         base::withCallingHandlers({
[09:30:07.678]             ...future.value <- base::withVisible(base::local({
[09:30:07.678]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:07.678]                 if (!identical(...future.globals.maxSize.org, 
[09:30:07.678]                   ...future.globals.maxSize)) {
[09:30:07.678]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:07.678]                   on.exit(options(oopts), add = TRUE)
[09:30:07.678]                 }
[09:30:07.678]                 {
[09:30:07.678]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:07.678]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:30:07.678]                     USE.NAMES = FALSE)
[09:30:07.678]                   do.call(mapply, args = args)
[09:30:07.678]                 }
[09:30:07.678]             }))
[09:30:07.678]             future::FutureResult(value = ...future.value$value, 
[09:30:07.678]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:07.678]                   ...future.rng), globalenv = if (FALSE) 
[09:30:07.678]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:07.678]                     ...future.globalenv.names))
[09:30:07.678]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:07.678]         }, condition = base::local({
[09:30:07.678]             c <- base::c
[09:30:07.678]             inherits <- base::inherits
[09:30:07.678]             invokeRestart <- base::invokeRestart
[09:30:07.678]             length <- base::length
[09:30:07.678]             list <- base::list
[09:30:07.678]             seq.int <- base::seq.int
[09:30:07.678]             signalCondition <- base::signalCondition
[09:30:07.678]             sys.calls <- base::sys.calls
[09:30:07.678]             `[[` <- base::`[[`
[09:30:07.678]             `+` <- base::`+`
[09:30:07.678]             `<<-` <- base::`<<-`
[09:30:07.678]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:07.678]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:07.678]                   3L)]
[09:30:07.678]             }
[09:30:07.678]             function(cond) {
[09:30:07.678]                 is_error <- inherits(cond, "error")
[09:30:07.678]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:07.678]                   NULL)
[09:30:07.678]                 if (is_error) {
[09:30:07.678]                   sessionInformation <- function() {
[09:30:07.678]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:07.678]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:07.678]                       search = base::search(), system = base::Sys.info())
[09:30:07.678]                   }
[09:30:07.678]                   ...future.conditions[[length(...future.conditions) + 
[09:30:07.678]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:07.678]                     cond$call), session = sessionInformation(), 
[09:30:07.678]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:07.678]                   signalCondition(cond)
[09:30:07.678]                 }
[09:30:07.678]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:07.678]                 "immediateCondition"))) {
[09:30:07.678]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:07.678]                   ...future.conditions[[length(...future.conditions) + 
[09:30:07.678]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:07.678]                   if (TRUE && !signal) {
[09:30:07.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:07.678]                     {
[09:30:07.678]                       inherits <- base::inherits
[09:30:07.678]                       invokeRestart <- base::invokeRestart
[09:30:07.678]                       is.null <- base::is.null
[09:30:07.678]                       muffled <- FALSE
[09:30:07.678]                       if (inherits(cond, "message")) {
[09:30:07.678]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:07.678]                         if (muffled) 
[09:30:07.678]                           invokeRestart("muffleMessage")
[09:30:07.678]                       }
[09:30:07.678]                       else if (inherits(cond, "warning")) {
[09:30:07.678]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:07.678]                         if (muffled) 
[09:30:07.678]                           invokeRestart("muffleWarning")
[09:30:07.678]                       }
[09:30:07.678]                       else if (inherits(cond, "condition")) {
[09:30:07.678]                         if (!is.null(pattern)) {
[09:30:07.678]                           computeRestarts <- base::computeRestarts
[09:30:07.678]                           grepl <- base::grepl
[09:30:07.678]                           restarts <- computeRestarts(cond)
[09:30:07.678]                           for (restart in restarts) {
[09:30:07.678]                             name <- restart$name
[09:30:07.678]                             if (is.null(name)) 
[09:30:07.678]                               next
[09:30:07.678]                             if (!grepl(pattern, name)) 
[09:30:07.678]                               next
[09:30:07.678]                             invokeRestart(restart)
[09:30:07.678]                             muffled <- TRUE
[09:30:07.678]                             break
[09:30:07.678]                           }
[09:30:07.678]                         }
[09:30:07.678]                       }
[09:30:07.678]                       invisible(muffled)
[09:30:07.678]                     }
[09:30:07.678]                     muffleCondition(cond, pattern = "^muffle")
[09:30:07.678]                   }
[09:30:07.678]                 }
[09:30:07.678]                 else {
[09:30:07.678]                   if (TRUE) {
[09:30:07.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:07.678]                     {
[09:30:07.678]                       inherits <- base::inherits
[09:30:07.678]                       invokeRestart <- base::invokeRestart
[09:30:07.678]                       is.null <- base::is.null
[09:30:07.678]                       muffled <- FALSE
[09:30:07.678]                       if (inherits(cond, "message")) {
[09:30:07.678]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:07.678]                         if (muffled) 
[09:30:07.678]                           invokeRestart("muffleMessage")
[09:30:07.678]                       }
[09:30:07.678]                       else if (inherits(cond, "warning")) {
[09:30:07.678]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:07.678]                         if (muffled) 
[09:30:07.678]                           invokeRestart("muffleWarning")
[09:30:07.678]                       }
[09:30:07.678]                       else if (inherits(cond, "condition")) {
[09:30:07.678]                         if (!is.null(pattern)) {
[09:30:07.678]                           computeRestarts <- base::computeRestarts
[09:30:07.678]                           grepl <- base::grepl
[09:30:07.678]                           restarts <- computeRestarts(cond)
[09:30:07.678]                           for (restart in restarts) {
[09:30:07.678]                             name <- restart$name
[09:30:07.678]                             if (is.null(name)) 
[09:30:07.678]                               next
[09:30:07.678]                             if (!grepl(pattern, name)) 
[09:30:07.678]                               next
[09:30:07.678]                             invokeRestart(restart)
[09:30:07.678]                             muffled <- TRUE
[09:30:07.678]                             break
[09:30:07.678]                           }
[09:30:07.678]                         }
[09:30:07.678]                       }
[09:30:07.678]                       invisible(muffled)
[09:30:07.678]                     }
[09:30:07.678]                     muffleCondition(cond, pattern = "^muffle")
[09:30:07.678]                   }
[09:30:07.678]                 }
[09:30:07.678]             }
[09:30:07.678]         }))
[09:30:07.678]     }, error = function(ex) {
[09:30:07.678]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:07.678]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:07.678]                 ...future.rng), started = ...future.startTime, 
[09:30:07.678]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:07.678]             version = "1.8"), class = "FutureResult")
[09:30:07.678]     }, finally = {
[09:30:07.678]         if (!identical(...future.workdir, getwd())) 
[09:30:07.678]             setwd(...future.workdir)
[09:30:07.678]         {
[09:30:07.678]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:07.678]                 ...future.oldOptions$nwarnings <- NULL
[09:30:07.678]             }
[09:30:07.678]             base::options(...future.oldOptions)
[09:30:07.678]             if (.Platform$OS.type == "windows") {
[09:30:07.678]                 old_names <- names(...future.oldEnvVars)
[09:30:07.678]                 envs <- base::Sys.getenv()
[09:30:07.678]                 names <- names(envs)
[09:30:07.678]                 common <- intersect(names, old_names)
[09:30:07.678]                 added <- setdiff(names, old_names)
[09:30:07.678]                 removed <- setdiff(old_names, names)
[09:30:07.678]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:07.678]                   envs[common]]
[09:30:07.678]                 NAMES <- toupper(changed)
[09:30:07.678]                 args <- list()
[09:30:07.678]                 for (kk in seq_along(NAMES)) {
[09:30:07.678]                   name <- changed[[kk]]
[09:30:07.678]                   NAME <- NAMES[[kk]]
[09:30:07.678]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:07.678]                     next
[09:30:07.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:07.678]                 }
[09:30:07.678]                 NAMES <- toupper(added)
[09:30:07.678]                 for (kk in seq_along(NAMES)) {
[09:30:07.678]                   name <- added[[kk]]
[09:30:07.678]                   NAME <- NAMES[[kk]]
[09:30:07.678]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:07.678]                     next
[09:30:07.678]                   args[[name]] <- ""
[09:30:07.678]                 }
[09:30:07.678]                 NAMES <- toupper(removed)
[09:30:07.678]                 for (kk in seq_along(NAMES)) {
[09:30:07.678]                   name <- removed[[kk]]
[09:30:07.678]                   NAME <- NAMES[[kk]]
[09:30:07.678]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:07.678]                     next
[09:30:07.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:07.678]                 }
[09:30:07.678]                 if (length(args) > 0) 
[09:30:07.678]                   base::do.call(base::Sys.setenv, args = args)
[09:30:07.678]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:07.678]             }
[09:30:07.678]             else {
[09:30:07.678]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:07.678]             }
[09:30:07.678]             {
[09:30:07.678]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:07.678]                   0L) {
[09:30:07.678]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:07.678]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:07.678]                   base::options(opts)
[09:30:07.678]                 }
[09:30:07.678]                 {
[09:30:07.678]                   {
[09:30:07.678]                     NULL
[09:30:07.678]                     RNGkind("Mersenne-Twister")
[09:30:07.678]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:30:07.678]                       inherits = FALSE)
[09:30:07.678]                   }
[09:30:07.678]                   options(future.plan = NULL)
[09:30:07.678]                   if (is.na(NA_character_)) 
[09:30:07.678]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:07.678]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:07.678]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:07.678]                     .init = FALSE)
[09:30:07.678]                 }
[09:30:07.678]             }
[09:30:07.678]         }
[09:30:07.678]     })
[09:30:07.678]     if (TRUE) {
[09:30:07.678]         base::sink(type = "output", split = FALSE)
[09:30:07.678]         if (FALSE) {
[09:30:07.678]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:07.678]         }
[09:30:07.678]         else {
[09:30:07.678]             ...future.result["stdout"] <- base::list(NULL)
[09:30:07.678]         }
[09:30:07.678]         base::close(...future.stdout)
[09:30:07.678]         ...future.stdout <- NULL
[09:30:07.678]     }
[09:30:07.678]     ...future.result$conditions <- ...future.conditions
[09:30:07.678]     ...future.result$finished <- base::Sys.time()
[09:30:07.678]     ...future.result
[09:30:07.678] }
[09:30:07.680] assign_globals() ...
[09:30:07.680] List of 5
[09:30:07.680]  $ ...future.FUN            :function (x, y)  
[09:30:07.680]  $ MoreArgs                 : NULL
[09:30:07.680]  $ ...future.elements_ii    :List of 2
[09:30:07.680]   ..$ :List of 2
[09:30:07.680]   .. ..$ : int 1
[09:30:07.680]   .. ..$ : int 0
[09:30:07.680]   ..$ :List of 2
[09:30:07.680]   .. ..$ : int 0
[09:30:07.680]   .. ..$ : int 1
[09:30:07.680]  $ ...future.seeds_ii       : NULL
[09:30:07.680]  $ ...future.globals.maxSize: NULL
[09:30:07.680]  - attr(*, "where")=List of 5
[09:30:07.680]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:07.680]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:30:07.680]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:07.680]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:07.680]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:07.680]  - attr(*, "resolved")= logi FALSE
[09:30:07.680]  - attr(*, "total_size")= num 6480
[09:30:07.680]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:07.680]  - attr(*, "already-done")= logi TRUE
[09:30:07.686] - reassign environment for ‘...future.FUN’
[09:30:07.686] - copied ‘...future.FUN’ to environment
[09:30:07.686] - copied ‘MoreArgs’ to environment
[09:30:07.686] - copied ‘...future.elements_ii’ to environment
[09:30:07.687] - copied ‘...future.seeds_ii’ to environment
[09:30:07.687] - copied ‘...future.globals.maxSize’ to environment
[09:30:07.687] assign_globals() ... done
[09:30:07.687] plan(): Setting new future strategy stack:
[09:30:07.687] List of future strategies:
[09:30:07.687] 1. sequential:
[09:30:07.687]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:07.687]    - tweaked: FALSE
[09:30:07.687]    - call: NULL
[09:30:07.688] plan(): nbrOfWorkers() = 1
[09:30:08.189] plan(): Setting new future strategy stack:
[09:30:08.189] List of future strategies:
[09:30:08.189] 1. multisession:
[09:30:08.189]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:30:08.189]    - tweaked: FALSE
[09:30:08.189]    - call: plan(strategy)
[09:30:08.193] plan(): nbrOfWorkers() = 1
[09:30:08.194] SequentialFuture started (and completed)
[09:30:08.194] - Launch lazy future ... done
[09:30:08.194] run() for ‘SequentialFuture’ ... done
[09:30:08.194] Created future:
[09:30:08.194] SequentialFuture:
[09:30:08.194] Label: ‘future_mapply-1’
[09:30:08.194] Expression:
[09:30:08.194] {
[09:30:08.194]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:08.194]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:08.194]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:08.194]         on.exit(options(oopts), add = TRUE)
[09:30:08.194]     }
[09:30:08.194]     {
[09:30:08.194]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:08.194]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:30:08.194]         do.call(mapply, args = args)
[09:30:08.194]     }
[09:30:08.194] }
[09:30:08.194] Lazy evaluation: FALSE
[09:30:08.194] Asynchronous evaluation: FALSE
[09:30:08.194] Local evaluation: TRUE
[09:30:08.194] Environment: R_GlobalEnv
[09:30:08.194] Capture standard output: FALSE
[09:30:08.194] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:08.194] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:08.194] Packages: <none>
[09:30:08.194] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:08.194] Resolved: TRUE
[09:30:08.194] Value: 224 bytes of class ‘list’
[09:30:08.194] Early signaling: FALSE
[09:30:08.194] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:08.194] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:08.195] Chunk #1 of 1 ... DONE
[09:30:08.195] Launching 1 futures (chunks) ... DONE
[09:30:08.195] Resolving 1 futures (chunks) ...
[09:30:08.195] resolve() on list ...
[09:30:08.195]  recursive: 0
[09:30:08.195]  length: 1
[09:30:08.196] 
[09:30:08.196] resolved() for ‘SequentialFuture’ ...
[09:30:08.196] - state: ‘finished’
[09:30:08.196] - run: TRUE
[09:30:08.196] - result: ‘FutureResult’
[09:30:08.196] resolved() for ‘SequentialFuture’ ... done
[09:30:08.196] Future #1
[09:30:08.196] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:30:08.196] - nx: 1
[09:30:08.197] - relay: TRUE
[09:30:08.197] - stdout: TRUE
[09:30:08.197] - signal: TRUE
[09:30:08.197] - resignal: FALSE
[09:30:08.197] - force: TRUE
[09:30:08.197] - relayed: [n=1] FALSE
[09:30:08.197] - queued futures: [n=1] FALSE
[09:30:08.197]  - until=1
[09:30:08.197]  - relaying element #1
[09:30:08.197] - relayed: [n=1] TRUE
[09:30:08.197] - queued futures: [n=1] TRUE
[09:30:08.198] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:30:08.198]  length: 0 (resolved future 1)
[09:30:08.198] Relaying remaining futures
[09:30:08.198] signalConditionsASAP(NULL, pos=0) ...
[09:30:08.198] - nx: 1
[09:30:08.198] - relay: TRUE
[09:30:08.198] - stdout: TRUE
[09:30:08.198] - signal: TRUE
[09:30:08.198] - resignal: FALSE
[09:30:08.198] - force: TRUE
[09:30:08.198] - relayed: [n=1] TRUE
[09:30:08.198] - queued futures: [n=1] TRUE
 - flush all
[09:30:08.199] - relayed: [n=1] TRUE
[09:30:08.199] - queued futures: [n=1] TRUE
[09:30:08.199] signalConditionsASAP(NULL, pos=0) ... done
[09:30:08.199] resolve() on list ... DONE
[09:30:08.199]  - Number of value chunks collected: 1
[09:30:08.199] Resolving 1 futures (chunks) ... DONE
[09:30:08.199] Reducing values from 1 chunks ...
[09:30:08.199]  - Number of values collected after concatenation: 2
[09:30:08.199]  - Number of values expected: 2
[09:30:08.199] Reducing values from 1 chunks ... DONE
[09:30:08.200] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[09:30:08.200] future_mapply() ...
[09:30:08.203] Number of chunks: 1
[09:30:08.203] getGlobalsAndPackagesXApply() ...
[09:30:08.203]  - future.globals: TRUE
[09:30:08.203] getGlobalsAndPackages() ...
[09:30:08.203] Searching for globals...
[09:30:08.205] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[09:30:08.205] Searching for globals ... DONE
[09:30:08.205] Resolving globals: FALSE
[09:30:08.206] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[09:30:08.206] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[09:30:08.206] - globals: [1] ‘FUN’
[09:30:08.206] 
[09:30:08.206] getGlobalsAndPackages() ... DONE
[09:30:08.206]  - globals found/used: [n=1] ‘FUN’
[09:30:08.207]  - needed namespaces: [n=0] 
[09:30:08.207] Finding globals ... DONE
[09:30:08.207] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:30:08.207] List of 2
[09:30:08.207]  $ ...future.FUN:function (x, y)  
[09:30:08.207]  $ MoreArgs     : NULL
[09:30:08.207]  - attr(*, "where")=List of 2
[09:30:08.207]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:08.207]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:30:08.207]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:08.207]  - attr(*, "resolved")= logi FALSE
[09:30:08.207]  - attr(*, "total_size")= num NA
[09:30:08.209] Packages to be attached in all futures: [n=0] 
[09:30:08.209] getGlobalsAndPackagesXApply() ... DONE
[09:30:08.210] Number of futures (= number of chunks): 1
[09:30:08.210] Launching 1 futures (chunks) ...
[09:30:08.210] Chunk #1 of 1 ...
[09:30:08.210]  - Finding globals in '...' for chunk #1 ...
[09:30:08.210] getGlobalsAndPackages() ...
[09:30:08.210] Searching for globals...
[09:30:08.210] 
[09:30:08.211] Searching for globals ... DONE
[09:30:08.211] - globals: [0] <none>
[09:30:08.211] getGlobalsAndPackages() ... DONE
[09:30:08.211]    + additional globals found: [n=0] 
[09:30:08.211]    + additional namespaces needed: [n=0] 
[09:30:08.211]  - Finding globals in '...' for chunk #1 ... DONE
[09:30:08.211]  - seeds: <none>
[09:30:08.211]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:08.211] getGlobalsAndPackages() ...
[09:30:08.211] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:08.212] Resolving globals: FALSE
[09:30:08.212] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[09:30:08.212] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:30:08.213] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:08.213] 
[09:30:08.213] getGlobalsAndPackages() ... DONE
[09:30:08.213] run() for ‘Future’ ...
[09:30:08.213] - state: ‘created’
[09:30:08.213] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:30:08.217] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:08.217] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:30:08.217]   - Field: ‘label’
[09:30:08.217]   - Field: ‘local’
[09:30:08.217]   - Field: ‘owner’
[09:30:08.217]   - Field: ‘envir’
[09:30:08.217]   - Field: ‘packages’
[09:30:08.217]   - Field: ‘gc’
[09:30:08.217]   - Field: ‘conditions’
[09:30:08.217]   - Field: ‘expr’
[09:30:08.218]   - Field: ‘uuid’
[09:30:08.218]   - Field: ‘seed’
[09:30:08.218]   - Field: ‘version’
[09:30:08.218]   - Field: ‘result’
[09:30:08.218]   - Field: ‘asynchronous’
[09:30:08.218]   - Field: ‘calls’
[09:30:08.218]   - Field: ‘globals’
[09:30:08.218]   - Field: ‘stdout’
[09:30:08.218]   - Field: ‘earlySignal’
[09:30:08.218]   - Field: ‘lazy’
[09:30:08.218]   - Field: ‘state’
[09:30:08.219] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:30:08.219] - Launch lazy future ...
[09:30:08.219] Packages needed by the future expression (n = 0): <none>
[09:30:08.219] Packages needed by future strategies (n = 0): <none>
[09:30:08.219] {
[09:30:08.219]     {
[09:30:08.219]         {
[09:30:08.219]             ...future.startTime <- base::Sys.time()
[09:30:08.219]             {
[09:30:08.219]                 {
[09:30:08.219]                   {
[09:30:08.219]                     base::local({
[09:30:08.219]                       has_future <- base::requireNamespace("future", 
[09:30:08.219]                         quietly = TRUE)
[09:30:08.219]                       if (has_future) {
[09:30:08.219]                         ns <- base::getNamespace("future")
[09:30:08.219]                         version <- ns[[".package"]][["version"]]
[09:30:08.219]                         if (is.null(version)) 
[09:30:08.219]                           version <- utils::packageVersion("future")
[09:30:08.219]                       }
[09:30:08.219]                       else {
[09:30:08.219]                         version <- NULL
[09:30:08.219]                       }
[09:30:08.219]                       if (!has_future || version < "1.8.0") {
[09:30:08.219]                         info <- base::c(r_version = base::gsub("R version ", 
[09:30:08.219]                           "", base::R.version$version.string), 
[09:30:08.219]                           platform = base::sprintf("%s (%s-bit)", 
[09:30:08.219]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:08.219]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:08.219]                             "release", "version")], collapse = " "), 
[09:30:08.219]                           hostname = base::Sys.info()[["nodename"]])
[09:30:08.219]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:30:08.219]                           info)
[09:30:08.219]                         info <- base::paste(info, collapse = "; ")
[09:30:08.219]                         if (!has_future) {
[09:30:08.219]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:08.219]                             info)
[09:30:08.219]                         }
[09:30:08.219]                         else {
[09:30:08.219]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:08.219]                             info, version)
[09:30:08.219]                         }
[09:30:08.219]                         base::stop(msg)
[09:30:08.219]                       }
[09:30:08.219]                     })
[09:30:08.219]                   }
[09:30:08.219]                   ...future.strategy.old <- future::plan("list")
[09:30:08.219]                   options(future.plan = NULL)
[09:30:08.219]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:08.219]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:08.219]                 }
[09:30:08.219]                 ...future.workdir <- getwd()
[09:30:08.219]             }
[09:30:08.219]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:08.219]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:08.219]         }
[09:30:08.219]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:08.219]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:30:08.219]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:08.219]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:08.219]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:08.219]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:08.219]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:08.219]             base::names(...future.oldOptions))
[09:30:08.219]     }
[09:30:08.219]     if (FALSE) {
[09:30:08.219]     }
[09:30:08.219]     else {
[09:30:08.219]         if (TRUE) {
[09:30:08.219]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:08.219]                 open = "w")
[09:30:08.219]         }
[09:30:08.219]         else {
[09:30:08.219]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:08.219]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:08.219]         }
[09:30:08.219]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:08.219]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:08.219]             base::sink(type = "output", split = FALSE)
[09:30:08.219]             base::close(...future.stdout)
[09:30:08.219]         }, add = TRUE)
[09:30:08.219]     }
[09:30:08.219]     ...future.frame <- base::sys.nframe()
[09:30:08.219]     ...future.conditions <- base::list()
[09:30:08.219]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:08.219]     if (FALSE) {
[09:30:08.219]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:08.219]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:08.219]     }
[09:30:08.219]     ...future.result <- base::tryCatch({
[09:30:08.219]         base::withCallingHandlers({
[09:30:08.219]             ...future.value <- base::withVisible(base::local({
[09:30:08.219]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:08.219]                 if (!identical(...future.globals.maxSize.org, 
[09:30:08.219]                   ...future.globals.maxSize)) {
[09:30:08.219]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:08.219]                   on.exit(options(oopts), add = TRUE)
[09:30:08.219]                 }
[09:30:08.219]                 {
[09:30:08.219]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:08.219]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:30:08.219]                     USE.NAMES = FALSE)
[09:30:08.219]                   do.call(mapply, args = args)
[09:30:08.219]                 }
[09:30:08.219]             }))
[09:30:08.219]             future::FutureResult(value = ...future.value$value, 
[09:30:08.219]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:08.219]                   ...future.rng), globalenv = if (FALSE) 
[09:30:08.219]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:08.219]                     ...future.globalenv.names))
[09:30:08.219]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:08.219]         }, condition = base::local({
[09:30:08.219]             c <- base::c
[09:30:08.219]             inherits <- base::inherits
[09:30:08.219]             invokeRestart <- base::invokeRestart
[09:30:08.219]             length <- base::length
[09:30:08.219]             list <- base::list
[09:30:08.219]             seq.int <- base::seq.int
[09:30:08.219]             signalCondition <- base::signalCondition
[09:30:08.219]             sys.calls <- base::sys.calls
[09:30:08.219]             `[[` <- base::`[[`
[09:30:08.219]             `+` <- base::`+`
[09:30:08.219]             `<<-` <- base::`<<-`
[09:30:08.219]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:08.219]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:08.219]                   3L)]
[09:30:08.219]             }
[09:30:08.219]             function(cond) {
[09:30:08.219]                 is_error <- inherits(cond, "error")
[09:30:08.219]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:08.219]                   NULL)
[09:30:08.219]                 if (is_error) {
[09:30:08.219]                   sessionInformation <- function() {
[09:30:08.219]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:08.219]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:08.219]                       search = base::search(), system = base::Sys.info())
[09:30:08.219]                   }
[09:30:08.219]                   ...future.conditions[[length(...future.conditions) + 
[09:30:08.219]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:08.219]                     cond$call), session = sessionInformation(), 
[09:30:08.219]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:08.219]                   signalCondition(cond)
[09:30:08.219]                 }
[09:30:08.219]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:08.219]                 "immediateCondition"))) {
[09:30:08.219]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:08.219]                   ...future.conditions[[length(...future.conditions) + 
[09:30:08.219]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:08.219]                   if (TRUE && !signal) {
[09:30:08.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:08.219]                     {
[09:30:08.219]                       inherits <- base::inherits
[09:30:08.219]                       invokeRestart <- base::invokeRestart
[09:30:08.219]                       is.null <- base::is.null
[09:30:08.219]                       muffled <- FALSE
[09:30:08.219]                       if (inherits(cond, "message")) {
[09:30:08.219]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:08.219]                         if (muffled) 
[09:30:08.219]                           invokeRestart("muffleMessage")
[09:30:08.219]                       }
[09:30:08.219]                       else if (inherits(cond, "warning")) {
[09:30:08.219]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:08.219]                         if (muffled) 
[09:30:08.219]                           invokeRestart("muffleWarning")
[09:30:08.219]                       }
[09:30:08.219]                       else if (inherits(cond, "condition")) {
[09:30:08.219]                         if (!is.null(pattern)) {
[09:30:08.219]                           computeRestarts <- base::computeRestarts
[09:30:08.219]                           grepl <- base::grepl
[09:30:08.219]                           restarts <- computeRestarts(cond)
[09:30:08.219]                           for (restart in restarts) {
[09:30:08.219]                             name <- restart$name
[09:30:08.219]                             if (is.null(name)) 
[09:30:08.219]                               next
[09:30:08.219]                             if (!grepl(pattern, name)) 
[09:30:08.219]                               next
[09:30:08.219]                             invokeRestart(restart)
[09:30:08.219]                             muffled <- TRUE
[09:30:08.219]                             break
[09:30:08.219]                           }
[09:30:08.219]                         }
[09:30:08.219]                       }
[09:30:08.219]                       invisible(muffled)
[09:30:08.219]                     }
[09:30:08.219]                     muffleCondition(cond, pattern = "^muffle")
[09:30:08.219]                   }
[09:30:08.219]                 }
[09:30:08.219]                 else {
[09:30:08.219]                   if (TRUE) {
[09:30:08.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:08.219]                     {
[09:30:08.219]                       inherits <- base::inherits
[09:30:08.219]                       invokeRestart <- base::invokeRestart
[09:30:08.219]                       is.null <- base::is.null
[09:30:08.219]                       muffled <- FALSE
[09:30:08.219]                       if (inherits(cond, "message")) {
[09:30:08.219]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:08.219]                         if (muffled) 
[09:30:08.219]                           invokeRestart("muffleMessage")
[09:30:08.219]                       }
[09:30:08.219]                       else if (inherits(cond, "warning")) {
[09:30:08.219]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:08.219]                         if (muffled) 
[09:30:08.219]                           invokeRestart("muffleWarning")
[09:30:08.219]                       }
[09:30:08.219]                       else if (inherits(cond, "condition")) {
[09:30:08.219]                         if (!is.null(pattern)) {
[09:30:08.219]                           computeRestarts <- base::computeRestarts
[09:30:08.219]                           grepl <- base::grepl
[09:30:08.219]                           restarts <- computeRestarts(cond)
[09:30:08.219]                           for (restart in restarts) {
[09:30:08.219]                             name <- restart$name
[09:30:08.219]                             if (is.null(name)) 
[09:30:08.219]                               next
[09:30:08.219]                             if (!grepl(pattern, name)) 
[09:30:08.219]                               next
[09:30:08.219]                             invokeRestart(restart)
[09:30:08.219]                             muffled <- TRUE
[09:30:08.219]                             break
[09:30:08.219]                           }
[09:30:08.219]                         }
[09:30:08.219]                       }
[09:30:08.219]                       invisible(muffled)
[09:30:08.219]                     }
[09:30:08.219]                     muffleCondition(cond, pattern = "^muffle")
[09:30:08.219]                   }
[09:30:08.219]                 }
[09:30:08.219]             }
[09:30:08.219]         }))
[09:30:08.219]     }, error = function(ex) {
[09:30:08.219]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:08.219]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:08.219]                 ...future.rng), started = ...future.startTime, 
[09:30:08.219]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:08.219]             version = "1.8"), class = "FutureResult")
[09:30:08.219]     }, finally = {
[09:30:08.219]         if (!identical(...future.workdir, getwd())) 
[09:30:08.219]             setwd(...future.workdir)
[09:30:08.219]         {
[09:30:08.219]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:08.219]                 ...future.oldOptions$nwarnings <- NULL
[09:30:08.219]             }
[09:30:08.219]             base::options(...future.oldOptions)
[09:30:08.219]             if (.Platform$OS.type == "windows") {
[09:30:08.219]                 old_names <- names(...future.oldEnvVars)
[09:30:08.219]                 envs <- base::Sys.getenv()
[09:30:08.219]                 names <- names(envs)
[09:30:08.219]                 common <- intersect(names, old_names)
[09:30:08.219]                 added <- setdiff(names, old_names)
[09:30:08.219]                 removed <- setdiff(old_names, names)
[09:30:08.219]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:08.219]                   envs[common]]
[09:30:08.219]                 NAMES <- toupper(changed)
[09:30:08.219]                 args <- list()
[09:30:08.219]                 for (kk in seq_along(NAMES)) {
[09:30:08.219]                   name <- changed[[kk]]
[09:30:08.219]                   NAME <- NAMES[[kk]]
[09:30:08.219]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:08.219]                     next
[09:30:08.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:08.219]                 }
[09:30:08.219]                 NAMES <- toupper(added)
[09:30:08.219]                 for (kk in seq_along(NAMES)) {
[09:30:08.219]                   name <- added[[kk]]
[09:30:08.219]                   NAME <- NAMES[[kk]]
[09:30:08.219]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:08.219]                     next
[09:30:08.219]                   args[[name]] <- ""
[09:30:08.219]                 }
[09:30:08.219]                 NAMES <- toupper(removed)
[09:30:08.219]                 for (kk in seq_along(NAMES)) {
[09:30:08.219]                   name <- removed[[kk]]
[09:30:08.219]                   NAME <- NAMES[[kk]]
[09:30:08.219]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:08.219]                     next
[09:30:08.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:08.219]                 }
[09:30:08.219]                 if (length(args) > 0) 
[09:30:08.219]                   base::do.call(base::Sys.setenv, args = args)
[09:30:08.219]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:08.219]             }
[09:30:08.219]             else {
[09:30:08.219]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:08.219]             }
[09:30:08.219]             {
[09:30:08.219]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:08.219]                   0L) {
[09:30:08.219]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:08.219]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:08.219]                   base::options(opts)
[09:30:08.219]                 }
[09:30:08.219]                 {
[09:30:08.219]                   {
[09:30:08.219]                     NULL
[09:30:08.219]                     RNGkind("Mersenne-Twister")
[09:30:08.219]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:30:08.219]                       inherits = FALSE)
[09:30:08.219]                   }
[09:30:08.219]                   options(future.plan = NULL)
[09:30:08.219]                   if (is.na(NA_character_)) 
[09:30:08.219]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:08.219]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:08.219]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:08.219]                     .init = FALSE)
[09:30:08.219]                 }
[09:30:08.219]             }
[09:30:08.219]         }
[09:30:08.219]     })
[09:30:08.219]     if (TRUE) {
[09:30:08.219]         base::sink(type = "output", split = FALSE)
[09:30:08.219]         if (TRUE) {
[09:30:08.219]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:08.219]         }
[09:30:08.219]         else {
[09:30:08.219]             ...future.result["stdout"] <- base::list(NULL)
[09:30:08.219]         }
[09:30:08.219]         base::close(...future.stdout)
[09:30:08.219]         ...future.stdout <- NULL
[09:30:08.219]     }
[09:30:08.219]     ...future.result$conditions <- ...future.conditions
[09:30:08.219]     ...future.result$finished <- base::Sys.time()
[09:30:08.219]     ...future.result
[09:30:08.219] }
[09:30:08.222] assign_globals() ...
[09:30:08.223] List of 5
[09:30:08.223]  $ ...future.FUN            :function (x, y)  
[09:30:08.223]  $ MoreArgs                 : NULL
[09:30:08.223]  $ ...future.elements_ii    :List of 2
[09:30:08.223]   ..$ :List of 2
[09:30:08.223]   .. ..$ : int 1
[09:30:08.223]   .. ..$ : int 0
[09:30:08.223]   ..$ :List of 2
[09:30:08.223]   .. ..$ : int 0
[09:30:08.223]   .. ..$ : int 1
[09:30:08.223]  $ ...future.seeds_ii       : NULL
[09:30:08.223]  $ ...future.globals.maxSize: NULL
[09:30:08.223]  - attr(*, "where")=List of 5
[09:30:08.223]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:08.223]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:30:08.223]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:08.223]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:08.223]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:08.223]  - attr(*, "resolved")= logi FALSE
[09:30:08.223]  - attr(*, "total_size")= num 6480
[09:30:08.223]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:08.223]  - attr(*, "already-done")= logi TRUE
[09:30:08.228] - reassign environment for ‘...future.FUN’
[09:30:08.228] - copied ‘...future.FUN’ to environment
[09:30:08.228] - copied ‘MoreArgs’ to environment
[09:30:08.229] - copied ‘...future.elements_ii’ to environment
[09:30:08.229] - copied ‘...future.seeds_ii’ to environment
[09:30:08.229] - copied ‘...future.globals.maxSize’ to environment
[09:30:08.229] assign_globals() ... done
[09:30:08.229] plan(): Setting new future strategy stack:
[09:30:08.229] List of future strategies:
[09:30:08.229] 1. sequential:
[09:30:08.229]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:08.229]    - tweaked: FALSE
[09:30:08.229]    - call: NULL
[09:30:08.230] plan(): nbrOfWorkers() = 1
[09:30:08.731] plan(): Setting new future strategy stack:
[09:30:08.731] List of future strategies:
[09:30:08.731] 1. multisession:
[09:30:08.731]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:30:08.731]    - tweaked: FALSE
[09:30:08.731]    - call: plan(strategy)
[09:30:08.735] plan(): nbrOfWorkers() = 1
[09:30:08.736] SequentialFuture started (and completed)
[09:30:08.736] - Launch lazy future ... done
[09:30:08.736] run() for ‘SequentialFuture’ ... done
[09:30:08.736] Created future:
[09:30:08.736] SequentialFuture:
[09:30:08.736] Label: ‘future_mapply-1’
[09:30:08.736] Expression:
[09:30:08.736] {
[09:30:08.736]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:08.736]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:08.736]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:08.736]         on.exit(options(oopts), add = TRUE)
[09:30:08.736]     }
[09:30:08.736]     {
[09:30:08.736]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:08.736]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:30:08.736]         do.call(mapply, args = args)
[09:30:08.736]     }
[09:30:08.736] }
[09:30:08.736] Lazy evaluation: FALSE
[09:30:08.736] Asynchronous evaluation: FALSE
[09:30:08.736] Local evaluation: TRUE
[09:30:08.736] Environment: R_GlobalEnv
[09:30:08.736] Capture standard output: TRUE
[09:30:08.736] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:08.736] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:08.736] Packages: <none>
[09:30:08.736] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:08.736] Resolved: TRUE
[09:30:08.736] Value: 224 bytes of class ‘list’
[09:30:08.736] Early signaling: FALSE
[09:30:08.736] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:08.736] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:08.737] Chunk #1 of 1 ... DONE
[09:30:08.737] Launching 1 futures (chunks) ... DONE
[09:30:08.737] Resolving 1 futures (chunks) ...
[09:30:08.737] resolve() on list ...
[09:30:08.737]  recursive: 0
[09:30:08.738]  length: 1
[09:30:08.738] 
[09:30:08.738] resolved() for ‘SequentialFuture’ ...
[09:30:08.738] - state: ‘finished’
[09:30:08.738] - run: TRUE
[09:30:08.738] - result: ‘FutureResult’
[09:30:08.738] resolved() for ‘SequentialFuture’ ... done
[09:30:08.738] Future #1
[09:30:08.738] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:30:08.738] - nx: 1
[09:30:08.739] - relay: TRUE
[09:30:08.739] - stdout: TRUE
[09:30:08.739] - signal: TRUE
[09:30:08.739] - resignal: FALSE
[09:30:08.739] - force: TRUE
[09:30:08.739] - relayed: [n=1] FALSE
[09:30:08.739] - queued futures: [n=1] FALSE
[09:30:08.739]  - until=1
[09:30:08.739]  - relaying element #1
[09:30:08.739] - relayed: [n=1] TRUE
[09:30:08.739] - queued futures: [n=1] TRUE
[09:30:08.740] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:30:08.740]  length: 0 (resolved future 1)
[09:30:08.740] Relaying remaining futures
[09:30:08.740] signalConditionsASAP(NULL, pos=0) ...
[09:30:08.740] - nx: 1
[09:30:08.740] - relay: TRUE
[09:30:08.740] - stdout: TRUE
[09:30:08.740] - signal: TRUE
[09:30:08.740] - resignal: FALSE
[09:30:08.740] - force: TRUE
[09:30:08.740] - relayed: [n=1] TRUE
[09:30:08.741] - queued futures: [n=1] TRUE
 - flush all
[09:30:08.741] - relayed: [n=1] TRUE
[09:30:08.741] - queued futures: [n=1] TRUE
[09:30:08.741] signalConditionsASAP(NULL, pos=0) ... done
[09:30:08.741] resolve() on list ... DONE
[09:30:08.741]  - Number of value chunks collected: 1
[09:30:08.741] Resolving 1 futures (chunks) ... DONE
[09:30:08.741] Reducing values from 1 chunks ...
[09:30:08.741]  - Number of values collected after concatenation: 2
[09:30:08.741]  - Number of values expected: 2
[09:30:08.742] Reducing values from 1 chunks ... DONE
[09:30:08.742] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[09:30:08.742] future_mapply() ...
[09:30:08.745] Number of chunks: 1
[09:30:08.745] getGlobalsAndPackagesXApply() ...
[09:30:08.745]  - future.globals: TRUE
[09:30:08.746] getGlobalsAndPackages() ...
[09:30:08.746] Searching for globals...
[09:30:08.747] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[09:30:08.747] Searching for globals ... DONE
[09:30:08.747] Resolving globals: FALSE
[09:30:08.748] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[09:30:08.748] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[09:30:08.748] - globals: [1] ‘FUN’
[09:30:08.748] 
[09:30:08.748] getGlobalsAndPackages() ... DONE
[09:30:08.749]  - globals found/used: [n=1] ‘FUN’
[09:30:08.749]  - needed namespaces: [n=0] 
[09:30:08.749] Finding globals ... DONE
[09:30:08.749] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:30:08.749] List of 2
[09:30:08.749]  $ ...future.FUN:function (x, y)  
[09:30:08.749]  $ MoreArgs     : NULL
[09:30:08.749]  - attr(*, "where")=List of 2
[09:30:08.749]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:08.749]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:30:08.749]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:08.749]  - attr(*, "resolved")= logi FALSE
[09:30:08.749]  - attr(*, "total_size")= num NA
[09:30:08.751] Packages to be attached in all futures: [n=0] 
[09:30:08.752] getGlobalsAndPackagesXApply() ... DONE
[09:30:08.752] Number of futures (= number of chunks): 1
[09:30:08.752] Launching 1 futures (chunks) ...
[09:30:08.752] Chunk #1 of 1 ...
[09:30:08.752]  - Finding globals in '...' for chunk #1 ...
[09:30:08.752] getGlobalsAndPackages() ...
[09:30:08.752] Searching for globals...
[09:30:08.753] 
[09:30:08.753] Searching for globals ... DONE
[09:30:08.754] - globals: [0] <none>
[09:30:08.754] getGlobalsAndPackages() ... DONE
[09:30:08.755]    + additional globals found: [n=0] 
[09:30:08.755]    + additional namespaces needed: [n=0] 
[09:30:08.755]  - Finding globals in '...' for chunk #1 ... DONE
[09:30:08.755]  - seeds: <none>
[09:30:08.755]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:08.755] getGlobalsAndPackages() ...
[09:30:08.755] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:08.755] Resolving globals: FALSE
[09:30:08.756] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[09:30:08.756] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:30:08.756] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:08.757] 
[09:30:08.757] getGlobalsAndPackages() ... DONE
[09:30:08.757] run() for ‘Future’ ...
[09:30:08.757] - state: ‘created’
[09:30:08.757] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:30:08.760] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:08.761] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:30:08.761]   - Field: ‘label’
[09:30:08.761]   - Field: ‘local’
[09:30:08.761]   - Field: ‘owner’
[09:30:08.761]   - Field: ‘envir’
[09:30:08.761]   - Field: ‘packages’
[09:30:08.761]   - Field: ‘gc’
[09:30:08.761]   - Field: ‘conditions’
[09:30:08.761]   - Field: ‘expr’
[09:30:08.761]   - Field: ‘uuid’
[09:30:08.762]   - Field: ‘seed’
[09:30:08.762]   - Field: ‘version’
[09:30:08.762]   - Field: ‘result’
[09:30:08.762]   - Field: ‘asynchronous’
[09:30:08.762]   - Field: ‘calls’
[09:30:08.762]   - Field: ‘globals’
[09:30:08.762]   - Field: ‘stdout’
[09:30:08.762]   - Field: ‘earlySignal’
[09:30:08.762]   - Field: ‘lazy’
[09:30:08.762]   - Field: ‘state’
[09:30:08.762] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:30:08.763] - Launch lazy future ...
[09:30:08.763] Packages needed by the future expression (n = 0): <none>
[09:30:08.763] Packages needed by future strategies (n = 0): <none>
[09:30:08.763] {
[09:30:08.763]     {
[09:30:08.763]         {
[09:30:08.763]             ...future.startTime <- base::Sys.time()
[09:30:08.763]             {
[09:30:08.763]                 {
[09:30:08.763]                   {
[09:30:08.763]                     base::local({
[09:30:08.763]                       has_future <- base::requireNamespace("future", 
[09:30:08.763]                         quietly = TRUE)
[09:30:08.763]                       if (has_future) {
[09:30:08.763]                         ns <- base::getNamespace("future")
[09:30:08.763]                         version <- ns[[".package"]][["version"]]
[09:30:08.763]                         if (is.null(version)) 
[09:30:08.763]                           version <- utils::packageVersion("future")
[09:30:08.763]                       }
[09:30:08.763]                       else {
[09:30:08.763]                         version <- NULL
[09:30:08.763]                       }
[09:30:08.763]                       if (!has_future || version < "1.8.0") {
[09:30:08.763]                         info <- base::c(r_version = base::gsub("R version ", 
[09:30:08.763]                           "", base::R.version$version.string), 
[09:30:08.763]                           platform = base::sprintf("%s (%s-bit)", 
[09:30:08.763]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:08.763]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:08.763]                             "release", "version")], collapse = " "), 
[09:30:08.763]                           hostname = base::Sys.info()[["nodename"]])
[09:30:08.763]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:30:08.763]                           info)
[09:30:08.763]                         info <- base::paste(info, collapse = "; ")
[09:30:08.763]                         if (!has_future) {
[09:30:08.763]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:08.763]                             info)
[09:30:08.763]                         }
[09:30:08.763]                         else {
[09:30:08.763]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:08.763]                             info, version)
[09:30:08.763]                         }
[09:30:08.763]                         base::stop(msg)
[09:30:08.763]                       }
[09:30:08.763]                     })
[09:30:08.763]                   }
[09:30:08.763]                   ...future.strategy.old <- future::plan("list")
[09:30:08.763]                   options(future.plan = NULL)
[09:30:08.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:08.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:08.763]                 }
[09:30:08.763]                 ...future.workdir <- getwd()
[09:30:08.763]             }
[09:30:08.763]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:08.763]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:08.763]         }
[09:30:08.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:08.763]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:30:08.763]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:08.763]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:08.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:08.763]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:08.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:08.763]             base::names(...future.oldOptions))
[09:30:08.763]     }
[09:30:08.763]     if (TRUE) {
[09:30:08.763]     }
[09:30:08.763]     else {
[09:30:08.763]         if (NA) {
[09:30:08.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:08.763]                 open = "w")
[09:30:08.763]         }
[09:30:08.763]         else {
[09:30:08.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:08.763]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:08.763]         }
[09:30:08.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:08.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:08.763]             base::sink(type = "output", split = FALSE)
[09:30:08.763]             base::close(...future.stdout)
[09:30:08.763]         }, add = TRUE)
[09:30:08.763]     }
[09:30:08.763]     ...future.frame <- base::sys.nframe()
[09:30:08.763]     ...future.conditions <- base::list()
[09:30:08.763]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:08.763]     if (FALSE) {
[09:30:08.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:08.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:08.763]     }
[09:30:08.763]     ...future.result <- base::tryCatch({
[09:30:08.763]         base::withCallingHandlers({
[09:30:08.763]             ...future.value <- base::withVisible(base::local({
[09:30:08.763]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:08.763]                 if (!identical(...future.globals.maxSize.org, 
[09:30:08.763]                   ...future.globals.maxSize)) {
[09:30:08.763]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:08.763]                   on.exit(options(oopts), add = TRUE)
[09:30:08.763]                 }
[09:30:08.763]                 {
[09:30:08.763]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:08.763]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:30:08.763]                     USE.NAMES = FALSE)
[09:30:08.763]                   do.call(mapply, args = args)
[09:30:08.763]                 }
[09:30:08.763]             }))
[09:30:08.763]             future::FutureResult(value = ...future.value$value, 
[09:30:08.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:08.763]                   ...future.rng), globalenv = if (FALSE) 
[09:30:08.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:08.763]                     ...future.globalenv.names))
[09:30:08.763]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:08.763]         }, condition = base::local({
[09:30:08.763]             c <- base::c
[09:30:08.763]             inherits <- base::inherits
[09:30:08.763]             invokeRestart <- base::invokeRestart
[09:30:08.763]             length <- base::length
[09:30:08.763]             list <- base::list
[09:30:08.763]             seq.int <- base::seq.int
[09:30:08.763]             signalCondition <- base::signalCondition
[09:30:08.763]             sys.calls <- base::sys.calls
[09:30:08.763]             `[[` <- base::`[[`
[09:30:08.763]             `+` <- base::`+`
[09:30:08.763]             `<<-` <- base::`<<-`
[09:30:08.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:08.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:08.763]                   3L)]
[09:30:08.763]             }
[09:30:08.763]             function(cond) {
[09:30:08.763]                 is_error <- inherits(cond, "error")
[09:30:08.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:08.763]                   NULL)
[09:30:08.763]                 if (is_error) {
[09:30:08.763]                   sessionInformation <- function() {
[09:30:08.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:08.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:08.763]                       search = base::search(), system = base::Sys.info())
[09:30:08.763]                   }
[09:30:08.763]                   ...future.conditions[[length(...future.conditions) + 
[09:30:08.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:08.763]                     cond$call), session = sessionInformation(), 
[09:30:08.763]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:08.763]                   signalCondition(cond)
[09:30:08.763]                 }
[09:30:08.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:08.763]                 "immediateCondition"))) {
[09:30:08.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:08.763]                   ...future.conditions[[length(...future.conditions) + 
[09:30:08.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:08.763]                   if (TRUE && !signal) {
[09:30:08.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:08.763]                     {
[09:30:08.763]                       inherits <- base::inherits
[09:30:08.763]                       invokeRestart <- base::invokeRestart
[09:30:08.763]                       is.null <- base::is.null
[09:30:08.763]                       muffled <- FALSE
[09:30:08.763]                       if (inherits(cond, "message")) {
[09:30:08.763]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:08.763]                         if (muffled) 
[09:30:08.763]                           invokeRestart("muffleMessage")
[09:30:08.763]                       }
[09:30:08.763]                       else if (inherits(cond, "warning")) {
[09:30:08.763]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:08.763]                         if (muffled) 
[09:30:08.763]                           invokeRestart("muffleWarning")
[09:30:08.763]                       }
[09:30:08.763]                       else if (inherits(cond, "condition")) {
[09:30:08.763]                         if (!is.null(pattern)) {
[09:30:08.763]                           computeRestarts <- base::computeRestarts
[09:30:08.763]                           grepl <- base::grepl
[09:30:08.763]                           restarts <- computeRestarts(cond)
[09:30:08.763]                           for (restart in restarts) {
[09:30:08.763]                             name <- restart$name
[09:30:08.763]                             if (is.null(name)) 
[09:30:08.763]                               next
[09:30:08.763]                             if (!grepl(pattern, name)) 
[09:30:08.763]                               next
[09:30:08.763]                             invokeRestart(restart)
[09:30:08.763]                             muffled <- TRUE
[09:30:08.763]                             break
[09:30:08.763]                           }
[09:30:08.763]                         }
[09:30:08.763]                       }
[09:30:08.763]                       invisible(muffled)
[09:30:08.763]                     }
[09:30:08.763]                     muffleCondition(cond, pattern = "^muffle")
[09:30:08.763]                   }
[09:30:08.763]                 }
[09:30:08.763]                 else {
[09:30:08.763]                   if (TRUE) {
[09:30:08.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:08.763]                     {
[09:30:08.763]                       inherits <- base::inherits
[09:30:08.763]                       invokeRestart <- base::invokeRestart
[09:30:08.763]                       is.null <- base::is.null
[09:30:08.763]                       muffled <- FALSE
[09:30:08.763]                       if (inherits(cond, "message")) {
[09:30:08.763]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:08.763]                         if (muffled) 
[09:30:08.763]                           invokeRestart("muffleMessage")
[09:30:08.763]                       }
[09:30:08.763]                       else if (inherits(cond, "warning")) {
[09:30:08.763]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:08.763]                         if (muffled) 
[09:30:08.763]                           invokeRestart("muffleWarning")
[09:30:08.763]                       }
[09:30:08.763]                       else if (inherits(cond, "condition")) {
[09:30:08.763]                         if (!is.null(pattern)) {
[09:30:08.763]                           computeRestarts <- base::computeRestarts
[09:30:08.763]                           grepl <- base::grepl
[09:30:08.763]                           restarts <- computeRestarts(cond)
[09:30:08.763]                           for (restart in restarts) {
[09:30:08.763]                             name <- restart$name
[09:30:08.763]                             if (is.null(name)) 
[09:30:08.763]                               next
[09:30:08.763]                             if (!grepl(pattern, name)) 
[09:30:08.763]                               next
[09:30:08.763]                             invokeRestart(restart)
[09:30:08.763]                             muffled <- TRUE
[09:30:08.763]                             break
[09:30:08.763]                           }
[09:30:08.763]                         }
[09:30:08.763]                       }
[09:30:08.763]                       invisible(muffled)
[09:30:08.763]                     }
[09:30:08.763]                     muffleCondition(cond, pattern = "^muffle")
[09:30:08.763]                   }
[09:30:08.763]                 }
[09:30:08.763]             }
[09:30:08.763]         }))
[09:30:08.763]     }, error = function(ex) {
[09:30:08.763]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:08.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:08.763]                 ...future.rng), started = ...future.startTime, 
[09:30:08.763]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:08.763]             version = "1.8"), class = "FutureResult")
[09:30:08.763]     }, finally = {
[09:30:08.763]         if (!identical(...future.workdir, getwd())) 
[09:30:08.763]             setwd(...future.workdir)
[09:30:08.763]         {
[09:30:08.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:08.763]                 ...future.oldOptions$nwarnings <- NULL
[09:30:08.763]             }
[09:30:08.763]             base::options(...future.oldOptions)
[09:30:08.763]             if (.Platform$OS.type == "windows") {
[09:30:08.763]                 old_names <- names(...future.oldEnvVars)
[09:30:08.763]                 envs <- base::Sys.getenv()
[09:30:08.763]                 names <- names(envs)
[09:30:08.763]                 common <- intersect(names, old_names)
[09:30:08.763]                 added <- setdiff(names, old_names)
[09:30:08.763]                 removed <- setdiff(old_names, names)
[09:30:08.763]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:08.763]                   envs[common]]
[09:30:08.763]                 NAMES <- toupper(changed)
[09:30:08.763]                 args <- list()
[09:30:08.763]                 for (kk in seq_along(NAMES)) {
[09:30:08.763]                   name <- changed[[kk]]
[09:30:08.763]                   NAME <- NAMES[[kk]]
[09:30:08.763]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:08.763]                     next
[09:30:08.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:08.763]                 }
[09:30:08.763]                 NAMES <- toupper(added)
[09:30:08.763]                 for (kk in seq_along(NAMES)) {
[09:30:08.763]                   name <- added[[kk]]
[09:30:08.763]                   NAME <- NAMES[[kk]]
[09:30:08.763]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:08.763]                     next
[09:30:08.763]                   args[[name]] <- ""
[09:30:08.763]                 }
[09:30:08.763]                 NAMES <- toupper(removed)
[09:30:08.763]                 for (kk in seq_along(NAMES)) {
[09:30:08.763]                   name <- removed[[kk]]
[09:30:08.763]                   NAME <- NAMES[[kk]]
[09:30:08.763]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:08.763]                     next
[09:30:08.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:08.763]                 }
[09:30:08.763]                 if (length(args) > 0) 
[09:30:08.763]                   base::do.call(base::Sys.setenv, args = args)
[09:30:08.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:08.763]             }
[09:30:08.763]             else {
[09:30:08.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:08.763]             }
[09:30:08.763]             {
[09:30:08.763]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:08.763]                   0L) {
[09:30:08.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:08.763]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:08.763]                   base::options(opts)
[09:30:08.763]                 }
[09:30:08.763]                 {
[09:30:08.763]                   {
[09:30:08.763]                     NULL
[09:30:08.763]                     RNGkind("Mersenne-Twister")
[09:30:08.763]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:30:08.763]                       inherits = FALSE)
[09:30:08.763]                   }
[09:30:08.763]                   options(future.plan = NULL)
[09:30:08.763]                   if (is.na(NA_character_)) 
[09:30:08.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:08.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:08.763]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:08.763]                     .init = FALSE)
[09:30:08.763]                 }
[09:30:08.763]             }
[09:30:08.763]         }
[09:30:08.763]     })
[09:30:08.763]     if (FALSE) {
[09:30:08.763]         base::sink(type = "output", split = FALSE)
[09:30:08.763]         if (NA) {
[09:30:08.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:08.763]         }
[09:30:08.763]         else {
[09:30:08.763]             ...future.result["stdout"] <- base::list(NULL)
[09:30:08.763]         }
[09:30:08.763]         base::close(...future.stdout)
[09:30:08.763]         ...future.stdout <- NULL
[09:30:08.763]     }
[09:30:08.763]     ...future.result$conditions <- ...future.conditions
[09:30:08.763]     ...future.result$finished <- base::Sys.time()
[09:30:08.763]     ...future.result
[09:30:08.763] }
[09:30:08.765] assign_globals() ...
[09:30:08.765] List of 5
[09:30:08.765]  $ ...future.FUN            :function (x, y)  
[09:30:08.765]  $ MoreArgs                 : NULL
[09:30:08.765]  $ ...future.elements_ii    :List of 2
[09:30:08.765]   ..$ :List of 2
[09:30:08.765]   .. ..$ : int 1
[09:30:08.765]   .. ..$ : int 0
[09:30:08.765]   ..$ :List of 2
[09:30:08.765]   .. ..$ : int 0
[09:30:08.765]   .. ..$ : int 1
[09:30:08.765]  $ ...future.seeds_ii       : NULL
[09:30:08.765]  $ ...future.globals.maxSize: NULL
[09:30:08.765]  - attr(*, "where")=List of 5
[09:30:08.765]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:08.765]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:30:08.765]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:08.765]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:08.765]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:08.765]  - attr(*, "resolved")= logi FALSE
[09:30:08.765]  - attr(*, "total_size")= num 6480
[09:30:08.765]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:08.765]  - attr(*, "already-done")= logi TRUE
[09:30:08.770] - reassign environment for ‘...future.FUN’
[09:30:08.770] - copied ‘...future.FUN’ to environment
[09:30:08.771] - copied ‘MoreArgs’ to environment
[09:30:08.771] - copied ‘...future.elements_ii’ to environment
[09:30:08.771] - copied ‘...future.seeds_ii’ to environment
[09:30:08.771] - copied ‘...future.globals.maxSize’ to environment
[09:30:08.771] assign_globals() ... done
[09:30:08.771] plan(): Setting new future strategy stack:
[09:30:08.771] List of future strategies:
[09:30:08.771] 1. sequential:
[09:30:08.771]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:08.771]    - tweaked: FALSE
[09:30:08.771]    - call: NULL
[09:30:08.772] plan(): nbrOfWorkers() = 1
[09:30:09.273] plan(): Setting new future strategy stack:
[09:30:09.273] List of future strategies:
[09:30:09.273] 1. multisession:
[09:30:09.273]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:30:09.273]    - tweaked: FALSE
[09:30:09.273]    - call: plan(strategy)
[09:30:09.277] plan(): nbrOfWorkers() = 1
[09:30:09.277] SequentialFuture started (and completed)
[09:30:09.278] - Launch lazy future ... done
[09:30:09.278] run() for ‘SequentialFuture’ ... done
[09:30:09.278] Created future:
[09:30:09.278] SequentialFuture:
[09:30:09.278] Label: ‘future_mapply-1’
[09:30:09.278] Expression:
[09:30:09.278] {
[09:30:09.278]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:09.278]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:09.278]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:09.278]         on.exit(options(oopts), add = TRUE)
[09:30:09.278]     }
[09:30:09.278]     {
[09:30:09.278]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:09.278]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:30:09.278]         do.call(mapply, args = args)
[09:30:09.278]     }
[09:30:09.278] }
[09:30:09.278] Lazy evaluation: FALSE
[09:30:09.278] Asynchronous evaluation: FALSE
[09:30:09.278] Local evaluation: TRUE
[09:30:09.278] Environment: R_GlobalEnv
[09:30:09.278] Capture standard output: NA
[09:30:09.278] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:09.278] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:09.278] Packages: <none>
[09:30:09.278] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:09.278] Resolved: TRUE
[09:30:09.278] Value: 224 bytes of class ‘list’
[09:30:09.278] Early signaling: FALSE
[09:30:09.278] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:09.278] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:30:09.279] Chunk #1 of 1 ... DONE
[09:30:09.279] Launching 1 futures (chunks) ... DONE
[09:30:09.279] Resolving 1 futures (chunks) ...
[09:30:09.279] resolve() on list ...
[09:30:09.279]  recursive: 0
[09:30:09.279]  length: 1
[09:30:09.279] 
[09:30:09.280] resolved() for ‘SequentialFuture’ ...
[09:30:09.280] - state: ‘finished’
[09:30:09.280] - run: TRUE
[09:30:09.280] - result: ‘FutureResult’
[09:30:09.280] resolved() for ‘SequentialFuture’ ... done
[09:30:09.280] Future #1
[09:30:09.280] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:30:09.280] - nx: 1
[09:30:09.280] - relay: TRUE
[09:30:09.280] - stdout: TRUE
[09:30:09.281] - signal: TRUE
[09:30:09.281] - resignal: FALSE
[09:30:09.281] - force: TRUE
[09:30:09.281] - relayed: [n=1] FALSE
[09:30:09.281] - queued futures: [n=1] FALSE
[09:30:09.281]  - until=1
[09:30:09.281]  - relaying element #1
[09:30:09.281] - relayed: [n=1] TRUE
[09:30:09.281] - queued futures: [n=1] TRUE
[09:30:09.281] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:30:09.282]  length: 0 (resolved future 1)
[09:30:09.282] Relaying remaining futures
[09:30:09.282] signalConditionsASAP(NULL, pos=0) ...
[09:30:09.282] - nx: 1
[09:30:09.282] - relay: TRUE
[09:30:09.282] - stdout: TRUE
[09:30:09.282] - signal: TRUE
[09:30:09.282] - resignal: FALSE
[09:30:09.282] - force: TRUE
[09:30:09.282] - relayed: [n=1] TRUE
[09:30:09.282] - queued futures: [n=1] TRUE
 - flush all
[09:30:09.282] - relayed: [n=1] TRUE
[09:30:09.283] - queued futures: [n=1] TRUE
[09:30:09.283] signalConditionsASAP(NULL, pos=0) ... done
[09:30:09.283] resolve() on list ... DONE
[09:30:09.283]  - Number of value chunks collected: 1
[09:30:09.283] Resolving 1 futures (chunks) ... DONE
[09:30:09.283] Reducing values from 1 chunks ...
[09:30:09.283]  - Number of values collected after concatenation: 2
[09:30:09.283]  - Number of values expected: 2
[09:30:09.283] Reducing values from 1 chunks ... DONE
[09:30:09.283] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 1 cores ... DONE
  - Testing with 2 cores ...
* plan('multicore') ...
[09:30:09.289] plan(): Setting new future strategy stack:
[09:30:09.289] List of future strategies:
[09:30:09.289] 1. multicore:
[09:30:09.289]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:30:09.289]    - tweaked: FALSE
[09:30:09.289]    - call: plan(strategy)
[09:30:09.292] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[09:30:09.293] future_lapply() ...
[09:30:09.298] Number of chunks: 2
[09:30:09.298] getGlobalsAndPackagesXApply() ...
[09:30:09.298]  - future.globals: TRUE
[09:30:09.298] getGlobalsAndPackages() ...
[09:30:09.298] Searching for globals...
[09:30:09.300] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[09:30:09.300] Searching for globals ... DONE
[09:30:09.300] Resolving globals: FALSE
[09:30:09.300] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[09:30:09.301] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[09:30:09.301] - globals: [1] ‘FUN’
[09:30:09.301] 
[09:30:09.301] getGlobalsAndPackages() ... DONE
[09:30:09.301]  - globals found/used: [n=1] ‘FUN’
[09:30:09.301]  - needed namespaces: [n=0] 
[09:30:09.301] Finding globals ... DONE
[09:30:09.301]  - use_args: TRUE
[09:30:09.301]  - Getting '...' globals ...
[09:30:09.302] resolve() on list ...
[09:30:09.302]  recursive: 0
[09:30:09.302]  length: 1
[09:30:09.302]  elements: ‘...’
[09:30:09.302]  length: 0 (resolved future 1)
[09:30:09.302] resolve() on list ... DONE
[09:30:09.302]    - '...' content: [n=0] 
[09:30:09.302] List of 1
[09:30:09.302]  $ ...: list()
[09:30:09.302]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:09.302]  - attr(*, "where")=List of 1
[09:30:09.302]   ..$ ...:<environment: 0x55c102734468> 
[09:30:09.302]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:09.302]  - attr(*, "resolved")= logi TRUE
[09:30:09.302]  - attr(*, "total_size")= num NA
[09:30:09.305]  - Getting '...' globals ... DONE
[09:30:09.305] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:30:09.305] List of 2
[09:30:09.305]  $ ...future.FUN:function (x)  
[09:30:09.305]  $ ...          : list()
[09:30:09.305]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:09.305]  - attr(*, "where")=List of 2
[09:30:09.305]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:09.305]   ..$ ...          :<environment: 0x55c102734468> 
[09:30:09.305]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:09.305]  - attr(*, "resolved")= logi FALSE
[09:30:09.305]  - attr(*, "total_size")= num 4720
[09:30:09.308] Packages to be attached in all futures: [n=0] 
[09:30:09.308] getGlobalsAndPackagesXApply() ... DONE
[09:30:09.308] Number of futures (= number of chunks): 2
[09:30:09.308] Launching 2 futures (chunks) ...
[09:30:09.308] Chunk #1 of 2 ...
[09:30:09.308]  - Finding globals in 'X' for chunk #1 ...
[09:30:09.308] getGlobalsAndPackages() ...
[09:30:09.309] Searching for globals...
[09:30:09.309] 
[09:30:09.309] Searching for globals ... DONE
[09:30:09.309] - globals: [0] <none>
[09:30:09.309] getGlobalsAndPackages() ... DONE
[09:30:09.309]    + additional globals found: [n=0] 
[09:30:09.309]    + additional namespaces needed: [n=0] 
[09:30:09.309]  - Finding globals in 'X' for chunk #1 ... DONE
[09:30:09.309]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:09.309]  - seeds: <none>
[09:30:09.310]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:09.310] getGlobalsAndPackages() ...
[09:30:09.310] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:09.310] Resolving globals: FALSE
[09:30:09.310] Tweak future expression to call with '...' arguments ...
[09:30:09.310] {
[09:30:09.310]     do.call(function(...) {
[09:30:09.310]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:09.310]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:09.310]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:09.310]             on.exit(options(oopts), add = TRUE)
[09:30:09.310]         }
[09:30:09.310]         {
[09:30:09.310]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:09.310]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:09.310]                 ...future.FUN(...future.X_jj, ...)
[09:30:09.310]             })
[09:30:09.310]         }
[09:30:09.310]     }, args = future.call.arguments)
[09:30:09.310] }
[09:30:09.310] Tweak future expression to call with '...' arguments ... DONE
[09:30:09.311] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:09.311] 
[09:30:09.311] getGlobalsAndPackages() ... DONE
[09:30:09.311] run() for ‘Future’ ...
[09:30:09.311] - state: ‘created’
[09:30:09.311] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:30:09.315] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:09.315] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:30:09.315]   - Field: ‘label’
[09:30:09.315]   - Field: ‘local’
[09:30:09.315]   - Field: ‘owner’
[09:30:09.315]   - Field: ‘envir’
[09:30:09.315]   - Field: ‘workers’
[09:30:09.315]   - Field: ‘packages’
[09:30:09.315]   - Field: ‘gc’
[09:30:09.316]   - Field: ‘job’
[09:30:09.316]   - Field: ‘conditions’
[09:30:09.316]   - Field: ‘expr’
[09:30:09.316]   - Field: ‘uuid’
[09:30:09.316]   - Field: ‘seed’
[09:30:09.316]   - Field: ‘version’
[09:30:09.316]   - Field: ‘result’
[09:30:09.316]   - Field: ‘asynchronous’
[09:30:09.316]   - Field: ‘calls’
[09:30:09.316]   - Field: ‘globals’
[09:30:09.316]   - Field: ‘stdout’
[09:30:09.317]   - Field: ‘earlySignal’
[09:30:09.317]   - Field: ‘lazy’
[09:30:09.317]   - Field: ‘state’
[09:30:09.317] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:30:09.317] - Launch lazy future ...
[09:30:09.318] Packages needed by the future expression (n = 0): <none>
[09:30:09.318] Packages needed by future strategies (n = 0): <none>
[09:30:09.320] {
[09:30:09.320]     {
[09:30:09.320]         {
[09:30:09.320]             ...future.startTime <- base::Sys.time()
[09:30:09.320]             {
[09:30:09.320]                 {
[09:30:09.320]                   {
[09:30:09.320]                     {
[09:30:09.320]                       base::local({
[09:30:09.320]                         has_future <- base::requireNamespace("future", 
[09:30:09.320]                           quietly = TRUE)
[09:30:09.320]                         if (has_future) {
[09:30:09.320]                           ns <- base::getNamespace("future")
[09:30:09.320]                           version <- ns[[".package"]][["version"]]
[09:30:09.320]                           if (is.null(version)) 
[09:30:09.320]                             version <- utils::packageVersion("future")
[09:30:09.320]                         }
[09:30:09.320]                         else {
[09:30:09.320]                           version <- NULL
[09:30:09.320]                         }
[09:30:09.320]                         if (!has_future || version < "1.8.0") {
[09:30:09.320]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:09.320]                             "", base::R.version$version.string), 
[09:30:09.320]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:09.320]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:09.320]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:09.320]                               "release", "version")], collapse = " "), 
[09:30:09.320]                             hostname = base::Sys.info()[["nodename"]])
[09:30:09.320]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:09.320]                             info)
[09:30:09.320]                           info <- base::paste(info, collapse = "; ")
[09:30:09.320]                           if (!has_future) {
[09:30:09.320]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:09.320]                               info)
[09:30:09.320]                           }
[09:30:09.320]                           else {
[09:30:09.320]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:09.320]                               info, version)
[09:30:09.320]                           }
[09:30:09.320]                           base::stop(msg)
[09:30:09.320]                         }
[09:30:09.320]                       })
[09:30:09.320]                     }
[09:30:09.320]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:09.320]                     base::options(mc.cores = 1L)
[09:30:09.320]                   }
[09:30:09.320]                   ...future.strategy.old <- future::plan("list")
[09:30:09.320]                   options(future.plan = NULL)
[09:30:09.320]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:09.320]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:09.320]                 }
[09:30:09.320]                 ...future.workdir <- getwd()
[09:30:09.320]             }
[09:30:09.320]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:09.320]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:09.320]         }
[09:30:09.320]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:09.320]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:09.320]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:09.320]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:09.320]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:09.320]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:09.320]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:09.320]             base::names(...future.oldOptions))
[09:30:09.320]     }
[09:30:09.320]     if (FALSE) {
[09:30:09.320]     }
[09:30:09.320]     else {
[09:30:09.320]         if (FALSE) {
[09:30:09.320]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:09.320]                 open = "w")
[09:30:09.320]         }
[09:30:09.320]         else {
[09:30:09.320]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:09.320]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:09.320]         }
[09:30:09.320]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:09.320]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:09.320]             base::sink(type = "output", split = FALSE)
[09:30:09.320]             base::close(...future.stdout)
[09:30:09.320]         }, add = TRUE)
[09:30:09.320]     }
[09:30:09.320]     ...future.frame <- base::sys.nframe()
[09:30:09.320]     ...future.conditions <- base::list()
[09:30:09.320]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:09.320]     if (FALSE) {
[09:30:09.320]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:09.320]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:09.320]     }
[09:30:09.320]     ...future.result <- base::tryCatch({
[09:30:09.320]         base::withCallingHandlers({
[09:30:09.320]             ...future.value <- base::withVisible(base::local({
[09:30:09.320]                 withCallingHandlers({
[09:30:09.320]                   {
[09:30:09.320]                     do.call(function(...) {
[09:30:09.320]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:09.320]                       if (!identical(...future.globals.maxSize.org, 
[09:30:09.320]                         ...future.globals.maxSize)) {
[09:30:09.320]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:09.320]                         on.exit(options(oopts), add = TRUE)
[09:30:09.320]                       }
[09:30:09.320]                       {
[09:30:09.320]                         lapply(seq_along(...future.elements_ii), 
[09:30:09.320]                           FUN = function(jj) {
[09:30:09.320]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:09.320]                             ...future.FUN(...future.X_jj, ...)
[09:30:09.320]                           })
[09:30:09.320]                       }
[09:30:09.320]                     }, args = future.call.arguments)
[09:30:09.320]                   }
[09:30:09.320]                 }, immediateCondition = function(cond) {
[09:30:09.320]                   save_rds <- function (object, pathname, ...) 
[09:30:09.320]                   {
[09:30:09.320]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:30:09.320]                     if (file_test("-f", pathname_tmp)) {
[09:30:09.320]                       fi_tmp <- file.info(pathname_tmp)
[09:30:09.320]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:30:09.320]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:09.320]                         fi_tmp[["mtime"]])
[09:30:09.320]                     }
[09:30:09.320]                     tryCatch({
[09:30:09.320]                       saveRDS(object, file = pathname_tmp, ...)
[09:30:09.320]                     }, error = function(ex) {
[09:30:09.320]                       msg <- conditionMessage(ex)
[09:30:09.320]                       fi_tmp <- file.info(pathname_tmp)
[09:30:09.320]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:30:09.320]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:09.320]                         fi_tmp[["mtime"]], msg)
[09:30:09.320]                       ex$message <- msg
[09:30:09.320]                       stop(ex)
[09:30:09.320]                     })
[09:30:09.320]                     stopifnot(file_test("-f", pathname_tmp))
[09:30:09.320]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:30:09.320]                     if (!res || file_test("-f", pathname_tmp)) {
[09:30:09.320]                       fi_tmp <- file.info(pathname_tmp)
[09:30:09.320]                       fi <- file.info(pathname)
[09:30:09.320]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:30:09.320]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:09.320]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:30:09.320]                         fi[["size"]], fi[["mtime"]])
[09:30:09.320]                       stop(msg)
[09:30:09.320]                     }
[09:30:09.320]                     invisible(pathname)
[09:30:09.320]                   }
[09:30:09.320]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:30:09.320]                     rootPath = tempdir()) 
[09:30:09.320]                   {
[09:30:09.320]                     obj <- list(time = Sys.time(), condition = cond)
[09:30:09.320]                     file <- tempfile(pattern = class(cond)[1], 
[09:30:09.320]                       tmpdir = path, fileext = ".rds")
[09:30:09.320]                     save_rds(obj, file)
[09:30:09.320]                   }
[09:30:09.320]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0coFNd/.future/immediateConditions")
[09:30:09.320]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:09.320]                   {
[09:30:09.320]                     inherits <- base::inherits
[09:30:09.320]                     invokeRestart <- base::invokeRestart
[09:30:09.320]                     is.null <- base::is.null
[09:30:09.320]                     muffled <- FALSE
[09:30:09.320]                     if (inherits(cond, "message")) {
[09:30:09.320]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:09.320]                       if (muffled) 
[09:30:09.320]                         invokeRestart("muffleMessage")
[09:30:09.320]                     }
[09:30:09.320]                     else if (inherits(cond, "warning")) {
[09:30:09.320]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:09.320]                       if (muffled) 
[09:30:09.320]                         invokeRestart("muffleWarning")
[09:30:09.320]                     }
[09:30:09.320]                     else if (inherits(cond, "condition")) {
[09:30:09.320]                       if (!is.null(pattern)) {
[09:30:09.320]                         computeRestarts <- base::computeRestarts
[09:30:09.320]                         grepl <- base::grepl
[09:30:09.320]                         restarts <- computeRestarts(cond)
[09:30:09.320]                         for (restart in restarts) {
[09:30:09.320]                           name <- restart$name
[09:30:09.320]                           if (is.null(name)) 
[09:30:09.320]                             next
[09:30:09.320]                           if (!grepl(pattern, name)) 
[09:30:09.320]                             next
[09:30:09.320]                           invokeRestart(restart)
[09:30:09.320]                           muffled <- TRUE
[09:30:09.320]                           break
[09:30:09.320]                         }
[09:30:09.320]                       }
[09:30:09.320]                     }
[09:30:09.320]                     invisible(muffled)
[09:30:09.320]                   }
[09:30:09.320]                   muffleCondition(cond)
[09:30:09.320]                 })
[09:30:09.320]             }))
[09:30:09.320]             future::FutureResult(value = ...future.value$value, 
[09:30:09.320]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:09.320]                   ...future.rng), globalenv = if (FALSE) 
[09:30:09.320]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:09.320]                     ...future.globalenv.names))
[09:30:09.320]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:09.320]         }, condition = base::local({
[09:30:09.320]             c <- base::c
[09:30:09.320]             inherits <- base::inherits
[09:30:09.320]             invokeRestart <- base::invokeRestart
[09:30:09.320]             length <- base::length
[09:30:09.320]             list <- base::list
[09:30:09.320]             seq.int <- base::seq.int
[09:30:09.320]             signalCondition <- base::signalCondition
[09:30:09.320]             sys.calls <- base::sys.calls
[09:30:09.320]             `[[` <- base::`[[`
[09:30:09.320]             `+` <- base::`+`
[09:30:09.320]             `<<-` <- base::`<<-`
[09:30:09.320]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:09.320]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:09.320]                   3L)]
[09:30:09.320]             }
[09:30:09.320]             function(cond) {
[09:30:09.320]                 is_error <- inherits(cond, "error")
[09:30:09.320]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:09.320]                   NULL)
[09:30:09.320]                 if (is_error) {
[09:30:09.320]                   sessionInformation <- function() {
[09:30:09.320]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:09.320]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:09.320]                       search = base::search(), system = base::Sys.info())
[09:30:09.320]                   }
[09:30:09.320]                   ...future.conditions[[length(...future.conditions) + 
[09:30:09.320]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:09.320]                     cond$call), session = sessionInformation(), 
[09:30:09.320]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:09.320]                   signalCondition(cond)
[09:30:09.320]                 }
[09:30:09.320]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:09.320]                 "immediateCondition"))) {
[09:30:09.320]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:09.320]                   ...future.conditions[[length(...future.conditions) + 
[09:30:09.320]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:09.320]                   if (TRUE && !signal) {
[09:30:09.320]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:09.320]                     {
[09:30:09.320]                       inherits <- base::inherits
[09:30:09.320]                       invokeRestart <- base::invokeRestart
[09:30:09.320]                       is.null <- base::is.null
[09:30:09.320]                       muffled <- FALSE
[09:30:09.320]                       if (inherits(cond, "message")) {
[09:30:09.320]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:09.320]                         if (muffled) 
[09:30:09.320]                           invokeRestart("muffleMessage")
[09:30:09.320]                       }
[09:30:09.320]                       else if (inherits(cond, "warning")) {
[09:30:09.320]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:09.320]                         if (muffled) 
[09:30:09.320]                           invokeRestart("muffleWarning")
[09:30:09.320]                       }
[09:30:09.320]                       else if (inherits(cond, "condition")) {
[09:30:09.320]                         if (!is.null(pattern)) {
[09:30:09.320]                           computeRestarts <- base::computeRestarts
[09:30:09.320]                           grepl <- base::grepl
[09:30:09.320]                           restarts <- computeRestarts(cond)
[09:30:09.320]                           for (restart in restarts) {
[09:30:09.320]                             name <- restart$name
[09:30:09.320]                             if (is.null(name)) 
[09:30:09.320]                               next
[09:30:09.320]                             if (!grepl(pattern, name)) 
[09:30:09.320]                               next
[09:30:09.320]                             invokeRestart(restart)
[09:30:09.320]                             muffled <- TRUE
[09:30:09.320]                             break
[09:30:09.320]                           }
[09:30:09.320]                         }
[09:30:09.320]                       }
[09:30:09.320]                       invisible(muffled)
[09:30:09.320]                     }
[09:30:09.320]                     muffleCondition(cond, pattern = "^muffle")
[09:30:09.320]                   }
[09:30:09.320]                 }
[09:30:09.320]                 else {
[09:30:09.320]                   if (TRUE) {
[09:30:09.320]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:09.320]                     {
[09:30:09.320]                       inherits <- base::inherits
[09:30:09.320]                       invokeRestart <- base::invokeRestart
[09:30:09.320]                       is.null <- base::is.null
[09:30:09.320]                       muffled <- FALSE
[09:30:09.320]                       if (inherits(cond, "message")) {
[09:30:09.320]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:09.320]                         if (muffled) 
[09:30:09.320]                           invokeRestart("muffleMessage")
[09:30:09.320]                       }
[09:30:09.320]                       else if (inherits(cond, "warning")) {
[09:30:09.320]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:09.320]                         if (muffled) 
[09:30:09.320]                           invokeRestart("muffleWarning")
[09:30:09.320]                       }
[09:30:09.320]                       else if (inherits(cond, "condition")) {
[09:30:09.320]                         if (!is.null(pattern)) {
[09:30:09.320]                           computeRestarts <- base::computeRestarts
[09:30:09.320]                           grepl <- base::grepl
[09:30:09.320]                           restarts <- computeRestarts(cond)
[09:30:09.320]                           for (restart in restarts) {
[09:30:09.320]                             name <- restart$name
[09:30:09.320]                             if (is.null(name)) 
[09:30:09.320]                               next
[09:30:09.320]                             if (!grepl(pattern, name)) 
[09:30:09.320]                               next
[09:30:09.320]                             invokeRestart(restart)
[09:30:09.320]                             muffled <- TRUE
[09:30:09.320]                             break
[09:30:09.320]                           }
[09:30:09.320]                         }
[09:30:09.320]                       }
[09:30:09.320]                       invisible(muffled)
[09:30:09.320]                     }
[09:30:09.320]                     muffleCondition(cond, pattern = "^muffle")
[09:30:09.320]                   }
[09:30:09.320]                 }
[09:30:09.320]             }
[09:30:09.320]         }))
[09:30:09.320]     }, error = function(ex) {
[09:30:09.320]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:09.320]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:09.320]                 ...future.rng), started = ...future.startTime, 
[09:30:09.320]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:09.320]             version = "1.8"), class = "FutureResult")
[09:30:09.320]     }, finally = {
[09:30:09.320]         if (!identical(...future.workdir, getwd())) 
[09:30:09.320]             setwd(...future.workdir)
[09:30:09.320]         {
[09:30:09.320]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:09.320]                 ...future.oldOptions$nwarnings <- NULL
[09:30:09.320]             }
[09:30:09.320]             base::options(...future.oldOptions)
[09:30:09.320]             if (.Platform$OS.type == "windows") {
[09:30:09.320]                 old_names <- names(...future.oldEnvVars)
[09:30:09.320]                 envs <- base::Sys.getenv()
[09:30:09.320]                 names <- names(envs)
[09:30:09.320]                 common <- intersect(names, old_names)
[09:30:09.320]                 added <- setdiff(names, old_names)
[09:30:09.320]                 removed <- setdiff(old_names, names)
[09:30:09.320]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:09.320]                   envs[common]]
[09:30:09.320]                 NAMES <- toupper(changed)
[09:30:09.320]                 args <- list()
[09:30:09.320]                 for (kk in seq_along(NAMES)) {
[09:30:09.320]                   name <- changed[[kk]]
[09:30:09.320]                   NAME <- NAMES[[kk]]
[09:30:09.320]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:09.320]                     next
[09:30:09.320]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:09.320]                 }
[09:30:09.320]                 NAMES <- toupper(added)
[09:30:09.320]                 for (kk in seq_along(NAMES)) {
[09:30:09.320]                   name <- added[[kk]]
[09:30:09.320]                   NAME <- NAMES[[kk]]
[09:30:09.320]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:09.320]                     next
[09:30:09.320]                   args[[name]] <- ""
[09:30:09.320]                 }
[09:30:09.320]                 NAMES <- toupper(removed)
[09:30:09.320]                 for (kk in seq_along(NAMES)) {
[09:30:09.320]                   name <- removed[[kk]]
[09:30:09.320]                   NAME <- NAMES[[kk]]
[09:30:09.320]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:09.320]                     next
[09:30:09.320]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:09.320]                 }
[09:30:09.320]                 if (length(args) > 0) 
[09:30:09.320]                   base::do.call(base::Sys.setenv, args = args)
[09:30:09.320]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:09.320]             }
[09:30:09.320]             else {
[09:30:09.320]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:09.320]             }
[09:30:09.320]             {
[09:30:09.320]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:09.320]                   0L) {
[09:30:09.320]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:09.320]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:09.320]                   base::options(opts)
[09:30:09.320]                 }
[09:30:09.320]                 {
[09:30:09.320]                   {
[09:30:09.320]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:09.320]                     NULL
[09:30:09.320]                   }
[09:30:09.320]                   options(future.plan = NULL)
[09:30:09.320]                   if (is.na(NA_character_)) 
[09:30:09.320]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:09.320]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:09.320]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:09.320]                     .init = FALSE)
[09:30:09.320]                 }
[09:30:09.320]             }
[09:30:09.320]         }
[09:30:09.320]     })
[09:30:09.320]     if (TRUE) {
[09:30:09.320]         base::sink(type = "output", split = FALSE)
[09:30:09.320]         if (FALSE) {
[09:30:09.320]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:09.320]         }
[09:30:09.320]         else {
[09:30:09.320]             ...future.result["stdout"] <- base::list(NULL)
[09:30:09.320]         }
[09:30:09.320]         base::close(...future.stdout)
[09:30:09.320]         ...future.stdout <- NULL
[09:30:09.320]     }
[09:30:09.320]     ...future.result$conditions <- ...future.conditions
[09:30:09.320]     ...future.result$finished <- base::Sys.time()
[09:30:09.320]     ...future.result
[09:30:09.320] }
[09:30:09.322] assign_globals() ...
[09:30:09.322] List of 5
[09:30:09.322]  $ ...future.FUN            :function (x)  
[09:30:09.322]  $ future.call.arguments    : list()
[09:30:09.322]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:09.322]  $ ...future.elements_ii    :List of 1
[09:30:09.322]   ..$ : int 1
[09:30:09.322]  $ ...future.seeds_ii       : NULL
[09:30:09.322]  $ ...future.globals.maxSize: NULL
[09:30:09.322]  - attr(*, "where")=List of 5
[09:30:09.322]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:09.322]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:30:09.322]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:09.322]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:09.322]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:09.322]  - attr(*, "resolved")= logi FALSE
[09:30:09.322]  - attr(*, "total_size")= num 4720
[09:30:09.322]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:09.322]  - attr(*, "already-done")= logi TRUE
[09:30:09.327] - reassign environment for ‘...future.FUN’
[09:30:09.327] - copied ‘...future.FUN’ to environment
[09:30:09.327] - copied ‘future.call.arguments’ to environment
[09:30:09.327] - copied ‘...future.elements_ii’ to environment
[09:30:09.327] - copied ‘...future.seeds_ii’ to environment
[09:30:09.327] - copied ‘...future.globals.maxSize’ to environment
[09:30:09.327] assign_globals() ... done
[09:30:09.327] requestCore(): workers = 2
[09:30:09.330] MulticoreFuture started
[09:30:09.331] - Launch lazy future ... done
[09:30:09.331] run() for ‘MulticoreFuture’ ... done
[09:30:09.331] Created future:
[09:30:09.331] plan(): Setting new future strategy stack:
[09:30:09.331] List of future strategies:
[09:30:09.331] 1. sequential:
[09:30:09.331]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:09.331]    - tweaked: FALSE
[09:30:09.331]    - call: NULL
[09:30:09.332] plan(): nbrOfWorkers() = 1
[09:30:09.331] MulticoreFuture:
[09:30:09.331] Label: ‘future_lapply-1’
[09:30:09.331] Expression:
[09:30:09.331] {
[09:30:09.331]     do.call(function(...) {
[09:30:09.331]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:09.331]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:09.331]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:09.331]             on.exit(options(oopts), add = TRUE)
[09:30:09.331]         }
[09:30:09.331]         {
[09:30:09.331]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:09.331]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:09.331]                 ...future.FUN(...future.X_jj, ...)
[09:30:09.331]             })
[09:30:09.331]         }
[09:30:09.331]     }, args = future.call.arguments)
[09:30:09.331] }
[09:30:09.331] Lazy evaluation: FALSE
[09:30:09.331] Asynchronous evaluation: TRUE
[09:30:09.331] Local evaluation: TRUE
[09:30:09.331] Environment: R_GlobalEnv
[09:30:09.331] Capture standard output: FALSE
[09:30:09.331] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:09.331] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:09.331] Packages: <none>
[09:30:09.331] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:09.331] Resolved: FALSE
[09:30:09.331] Value: <not collected>
[09:30:09.331] Conditions captured: <none>
[09:30:09.331] Early signaling: FALSE
[09:30:09.331] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:09.331] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:09.346] Chunk #1 of 2 ... DONE
[09:30:09.346] Chunk #2 of 2 ...
[09:30:09.346]  - Finding globals in 'X' for chunk #2 ...
[09:30:09.346] getGlobalsAndPackages() ...
[09:30:09.346] Searching for globals...
[09:30:09.347] 
[09:30:09.347] Searching for globals ... DONE
[09:30:09.347] - globals: [0] <none>
[09:30:09.347] getGlobalsAndPackages() ... DONE
[09:30:09.347]    + additional globals found: [n=0] 
[09:30:09.348]    + additional namespaces needed: [n=0] 
[09:30:09.348]  - Finding globals in 'X' for chunk #2 ... DONE
[09:30:09.348]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:09.348]  - seeds: <none>
[09:30:09.348]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:09.348] getGlobalsAndPackages() ...
[09:30:09.349] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:09.349] Resolving globals: FALSE
[09:30:09.349] Tweak future expression to call with '...' arguments ...
[09:30:09.349] {
[09:30:09.349]     do.call(function(...) {
[09:30:09.349]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:09.349]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:09.349]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:09.349]             on.exit(options(oopts), add = TRUE)
[09:30:09.349]         }
[09:30:09.349]         {
[09:30:09.349]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:09.349]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:09.349]                 ...future.FUN(...future.X_jj, ...)
[09:30:09.349]             })
[09:30:09.349]         }
[09:30:09.349]     }, args = future.call.arguments)
[09:30:09.349] }
[09:30:09.350] Tweak future expression to call with '...' arguments ... DONE
[09:30:09.350] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:09.350] 
[09:30:09.350] getGlobalsAndPackages() ... DONE
[09:30:09.351] run() for ‘Future’ ...
[09:30:09.351] - state: ‘created’
[09:30:09.351] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:30:09.356] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:09.357] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:30:09.357]   - Field: ‘label’
[09:30:09.357]   - Field: ‘local’
[09:30:09.357]   - Field: ‘owner’
[09:30:09.357]   - Field: ‘envir’
[09:30:09.357]   - Field: ‘workers’
[09:30:09.358]   - Field: ‘packages’
[09:30:09.358]   - Field: ‘gc’
[09:30:09.358]   - Field: ‘job’
[09:30:09.358]   - Field: ‘conditions’
[09:30:09.358]   - Field: ‘expr’
[09:30:09.358]   - Field: ‘uuid’
[09:30:09.359]   - Field: ‘seed’
[09:30:09.359]   - Field: ‘version’
[09:30:09.359]   - Field: ‘result’
[09:30:09.359]   - Field: ‘asynchronous’
[09:30:09.359]   - Field: ‘calls’
[09:30:09.359]   - Field: ‘globals’
[09:30:09.359]   - Field: ‘stdout’
[09:30:09.360]   - Field: ‘earlySignal’
[09:30:09.360]   - Field: ‘lazy’
[09:30:09.360]   - Field: ‘state’
[09:30:09.360] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:30:09.360] - Launch lazy future ...
[09:30:09.361] Packages needed by the future expression (n = 0): <none>
[09:30:09.361] Packages needed by future strategies (n = 0): <none>
[09:30:09.362] {
[09:30:09.362]     {
[09:30:09.362]         {
[09:30:09.362]             ...future.startTime <- base::Sys.time()
[09:30:09.362]             {
[09:30:09.362]                 {
[09:30:09.362]                   {
[09:30:09.362]                     {
[09:30:09.362]                       base::local({
[09:30:09.362]                         has_future <- base::requireNamespace("future", 
[09:30:09.362]                           quietly = TRUE)
[09:30:09.362]                         if (has_future) {
[09:30:09.362]                           ns <- base::getNamespace("future")
[09:30:09.362]                           version <- ns[[".package"]][["version"]]
[09:30:09.362]                           if (is.null(version)) 
[09:30:09.362]                             version <- utils::packageVersion("future")
[09:30:09.362]                         }
[09:30:09.362]                         else {
[09:30:09.362]                           version <- NULL
[09:30:09.362]                         }
[09:30:09.362]                         if (!has_future || version < "1.8.0") {
[09:30:09.362]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:09.362]                             "", base::R.version$version.string), 
[09:30:09.362]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:09.362]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:09.362]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:09.362]                               "release", "version")], collapse = " "), 
[09:30:09.362]                             hostname = base::Sys.info()[["nodename"]])
[09:30:09.362]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:09.362]                             info)
[09:30:09.362]                           info <- base::paste(info, collapse = "; ")
[09:30:09.362]                           if (!has_future) {
[09:30:09.362]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:09.362]                               info)
[09:30:09.362]                           }
[09:30:09.362]                           else {
[09:30:09.362]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:09.362]                               info, version)
[09:30:09.362]                           }
[09:30:09.362]                           base::stop(msg)
[09:30:09.362]                         }
[09:30:09.362]                       })
[09:30:09.362]                     }
[09:30:09.362]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:09.362]                     base::options(mc.cores = 1L)
[09:30:09.362]                   }
[09:30:09.362]                   ...future.strategy.old <- future::plan("list")
[09:30:09.362]                   options(future.plan = NULL)
[09:30:09.362]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:09.362]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:09.362]                 }
[09:30:09.362]                 ...future.workdir <- getwd()
[09:30:09.362]             }
[09:30:09.362]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:09.362]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:09.362]         }
[09:30:09.362]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:09.362]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:09.362]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:09.362]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:09.362]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:09.362]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:09.362]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:09.362]             base::names(...future.oldOptions))
[09:30:09.362]     }
[09:30:09.362]     if (FALSE) {
[09:30:09.362]     }
[09:30:09.362]     else {
[09:30:09.362]         if (FALSE) {
[09:30:09.362]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:09.362]                 open = "w")
[09:30:09.362]         }
[09:30:09.362]         else {
[09:30:09.362]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:09.362]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:09.362]         }
[09:30:09.362]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:09.362]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:09.362]             base::sink(type = "output", split = FALSE)
[09:30:09.362]             base::close(...future.stdout)
[09:30:09.362]         }, add = TRUE)
[09:30:09.362]     }
[09:30:09.362]     ...future.frame <- base::sys.nframe()
[09:30:09.362]     ...future.conditions <- base::list()
[09:30:09.362]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:09.362]     if (FALSE) {
[09:30:09.362]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:09.362]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:09.362]     }
[09:30:09.362]     ...future.result <- base::tryCatch({
[09:30:09.362]         base::withCallingHandlers({
[09:30:09.362]             ...future.value <- base::withVisible(base::local({
[09:30:09.362]                 withCallingHandlers({
[09:30:09.362]                   {
[09:30:09.362]                     do.call(function(...) {
[09:30:09.362]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:09.362]                       if (!identical(...future.globals.maxSize.org, 
[09:30:09.362]                         ...future.globals.maxSize)) {
[09:30:09.362]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:09.362]                         on.exit(options(oopts), add = TRUE)
[09:30:09.362]                       }
[09:30:09.362]                       {
[09:30:09.362]                         lapply(seq_along(...future.elements_ii), 
[09:30:09.362]                           FUN = function(jj) {
[09:30:09.362]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:09.362]                             ...future.FUN(...future.X_jj, ...)
[09:30:09.362]                           })
[09:30:09.362]                       }
[09:30:09.362]                     }, args = future.call.arguments)
[09:30:09.362]                   }
[09:30:09.362]                 }, immediateCondition = function(cond) {
[09:30:09.362]                   save_rds <- function (object, pathname, ...) 
[09:30:09.362]                   {
[09:30:09.362]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:30:09.362]                     if (file_test("-f", pathname_tmp)) {
[09:30:09.362]                       fi_tmp <- file.info(pathname_tmp)
[09:30:09.362]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:30:09.362]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:09.362]                         fi_tmp[["mtime"]])
[09:30:09.362]                     }
[09:30:09.362]                     tryCatch({
[09:30:09.362]                       saveRDS(object, file = pathname_tmp, ...)
[09:30:09.362]                     }, error = function(ex) {
[09:30:09.362]                       msg <- conditionMessage(ex)
[09:30:09.362]                       fi_tmp <- file.info(pathname_tmp)
[09:30:09.362]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:30:09.362]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:09.362]                         fi_tmp[["mtime"]], msg)
[09:30:09.362]                       ex$message <- msg
[09:30:09.362]                       stop(ex)
[09:30:09.362]                     })
[09:30:09.362]                     stopifnot(file_test("-f", pathname_tmp))
[09:30:09.362]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:30:09.362]                     if (!res || file_test("-f", pathname_tmp)) {
[09:30:09.362]                       fi_tmp <- file.info(pathname_tmp)
[09:30:09.362]                       fi <- file.info(pathname)
[09:30:09.362]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:30:09.362]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:09.362]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:30:09.362]                         fi[["size"]], fi[["mtime"]])
[09:30:09.362]                       stop(msg)
[09:30:09.362]                     }
[09:30:09.362]                     invisible(pathname)
[09:30:09.362]                   }
[09:30:09.362]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:30:09.362]                     rootPath = tempdir()) 
[09:30:09.362]                   {
[09:30:09.362]                     obj <- list(time = Sys.time(), condition = cond)
[09:30:09.362]                     file <- tempfile(pattern = class(cond)[1], 
[09:30:09.362]                       tmpdir = path, fileext = ".rds")
[09:30:09.362]                     save_rds(obj, file)
[09:30:09.362]                   }
[09:30:09.362]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0coFNd/.future/immediateConditions")
[09:30:09.362]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:09.362]                   {
[09:30:09.362]                     inherits <- base::inherits
[09:30:09.362]                     invokeRestart <- base::invokeRestart
[09:30:09.362]                     is.null <- base::is.null
[09:30:09.362]                     muffled <- FALSE
[09:30:09.362]                     if (inherits(cond, "message")) {
[09:30:09.362]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:09.362]                       if (muffled) 
[09:30:09.362]                         invokeRestart("muffleMessage")
[09:30:09.362]                     }
[09:30:09.362]                     else if (inherits(cond, "warning")) {
[09:30:09.362]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:09.362]                       if (muffled) 
[09:30:09.362]                         invokeRestart("muffleWarning")
[09:30:09.362]                     }
[09:30:09.362]                     else if (inherits(cond, "condition")) {
[09:30:09.362]                       if (!is.null(pattern)) {
[09:30:09.362]                         computeRestarts <- base::computeRestarts
[09:30:09.362]                         grepl <- base::grepl
[09:30:09.362]                         restarts <- computeRestarts(cond)
[09:30:09.362]                         for (restart in restarts) {
[09:30:09.362]                           name <- restart$name
[09:30:09.362]                           if (is.null(name)) 
[09:30:09.362]                             next
[09:30:09.362]                           if (!grepl(pattern, name)) 
[09:30:09.362]                             next
[09:30:09.362]                           invokeRestart(restart)
[09:30:09.362]                           muffled <- TRUE
[09:30:09.362]                           break
[09:30:09.362]                         }
[09:30:09.362]                       }
[09:30:09.362]                     }
[09:30:09.362]                     invisible(muffled)
[09:30:09.362]                   }
[09:30:09.362]                   muffleCondition(cond)
[09:30:09.362]                 })
[09:30:09.362]             }))
[09:30:09.362]             future::FutureResult(value = ...future.value$value, 
[09:30:09.362]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:09.362]                   ...future.rng), globalenv = if (FALSE) 
[09:30:09.362]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:09.362]                     ...future.globalenv.names))
[09:30:09.362]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:09.362]         }, condition = base::local({
[09:30:09.362]             c <- base::c
[09:30:09.362]             inherits <- base::inherits
[09:30:09.362]             invokeRestart <- base::invokeRestart
[09:30:09.362]             length <- base::length
[09:30:09.362]             list <- base::list
[09:30:09.362]             seq.int <- base::seq.int
[09:30:09.362]             signalCondition <- base::signalCondition
[09:30:09.362]             sys.calls <- base::sys.calls
[09:30:09.362]             `[[` <- base::`[[`
[09:30:09.362]             `+` <- base::`+`
[09:30:09.362]             `<<-` <- base::`<<-`
[09:30:09.362]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:09.362]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:09.362]                   3L)]
[09:30:09.362]             }
[09:30:09.362]             function(cond) {
[09:30:09.362]                 is_error <- inherits(cond, "error")
[09:30:09.362]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:09.362]                   NULL)
[09:30:09.362]                 if (is_error) {
[09:30:09.362]                   sessionInformation <- function() {
[09:30:09.362]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:09.362]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:09.362]                       search = base::search(), system = base::Sys.info())
[09:30:09.362]                   }
[09:30:09.362]                   ...future.conditions[[length(...future.conditions) + 
[09:30:09.362]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:09.362]                     cond$call), session = sessionInformation(), 
[09:30:09.362]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:09.362]                   signalCondition(cond)
[09:30:09.362]                 }
[09:30:09.362]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:09.362]                 "immediateCondition"))) {
[09:30:09.362]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:09.362]                   ...future.conditions[[length(...future.conditions) + 
[09:30:09.362]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:09.362]                   if (TRUE && !signal) {
[09:30:09.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:09.362]                     {
[09:30:09.362]                       inherits <- base::inherits
[09:30:09.362]                       invokeRestart <- base::invokeRestart
[09:30:09.362]                       is.null <- base::is.null
[09:30:09.362]                       muffled <- FALSE
[09:30:09.362]                       if (inherits(cond, "message")) {
[09:30:09.362]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:09.362]                         if (muffled) 
[09:30:09.362]                           invokeRestart("muffleMessage")
[09:30:09.362]                       }
[09:30:09.362]                       else if (inherits(cond, "warning")) {
[09:30:09.362]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:09.362]                         if (muffled) 
[09:30:09.362]                           invokeRestart("muffleWarning")
[09:30:09.362]                       }
[09:30:09.362]                       else if (inherits(cond, "condition")) {
[09:30:09.362]                         if (!is.null(pattern)) {
[09:30:09.362]                           computeRestarts <- base::computeRestarts
[09:30:09.362]                           grepl <- base::grepl
[09:30:09.362]                           restarts <- computeRestarts(cond)
[09:30:09.362]                           for (restart in restarts) {
[09:30:09.362]                             name <- restart$name
[09:30:09.362]                             if (is.null(name)) 
[09:30:09.362]                               next
[09:30:09.362]                             if (!grepl(pattern, name)) 
[09:30:09.362]                               next
[09:30:09.362]                             invokeRestart(restart)
[09:30:09.362]                             muffled <- TRUE
[09:30:09.362]                             break
[09:30:09.362]                           }
[09:30:09.362]                         }
[09:30:09.362]                       }
[09:30:09.362]                       invisible(muffled)
[09:30:09.362]                     }
[09:30:09.362]                     muffleCondition(cond, pattern = "^muffle")
[09:30:09.362]                   }
[09:30:09.362]                 }
[09:30:09.362]                 else {
[09:30:09.362]                   if (TRUE) {
[09:30:09.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:09.362]                     {
[09:30:09.362]                       inherits <- base::inherits
[09:30:09.362]                       invokeRestart <- base::invokeRestart
[09:30:09.362]                       is.null <- base::is.null
[09:30:09.362]                       muffled <- FALSE
[09:30:09.362]                       if (inherits(cond, "message")) {
[09:30:09.362]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:09.362]                         if (muffled) 
[09:30:09.362]                           invokeRestart("muffleMessage")
[09:30:09.362]                       }
[09:30:09.362]                       else if (inherits(cond, "warning")) {
[09:30:09.362]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:09.362]                         if (muffled) 
[09:30:09.362]                           invokeRestart("muffleWarning")
[09:30:09.362]                       }
[09:30:09.362]                       else if (inherits(cond, "condition")) {
[09:30:09.362]                         if (!is.null(pattern)) {
[09:30:09.362]                           computeRestarts <- base::computeRestarts
[09:30:09.362]                           grepl <- base::grepl
[09:30:09.362]                           restarts <- computeRestarts(cond)
[09:30:09.362]                           for (restart in restarts) {
[09:30:09.362]                             name <- restart$name
[09:30:09.362]                             if (is.null(name)) 
[09:30:09.362]                               next
[09:30:09.362]                             if (!grepl(pattern, name)) 
[09:30:09.362]                               next
[09:30:09.362]                             invokeRestart(restart)
[09:30:09.362]                             muffled <- TRUE
[09:30:09.362]                             break
[09:30:09.362]                           }
[09:30:09.362]                         }
[09:30:09.362]                       }
[09:30:09.362]                       invisible(muffled)
[09:30:09.362]                     }
[09:30:09.362]                     muffleCondition(cond, pattern = "^muffle")
[09:30:09.362]                   }
[09:30:09.362]                 }
[09:30:09.362]             }
[09:30:09.362]         }))
[09:30:09.362]     }, error = function(ex) {
[09:30:09.362]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:09.362]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:09.362]                 ...future.rng), started = ...future.startTime, 
[09:30:09.362]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:09.362]             version = "1.8"), class = "FutureResult")
[09:30:09.362]     }, finally = {
[09:30:09.362]         if (!identical(...future.workdir, getwd())) 
[09:30:09.362]             setwd(...future.workdir)
[09:30:09.362]         {
[09:30:09.362]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:09.362]                 ...future.oldOptions$nwarnings <- NULL
[09:30:09.362]             }
[09:30:09.362]             base::options(...future.oldOptions)
[09:30:09.362]             if (.Platform$OS.type == "windows") {
[09:30:09.362]                 old_names <- names(...future.oldEnvVars)
[09:30:09.362]                 envs <- base::Sys.getenv()
[09:30:09.362]                 names <- names(envs)
[09:30:09.362]                 common <- intersect(names, old_names)
[09:30:09.362]                 added <- setdiff(names, old_names)
[09:30:09.362]                 removed <- setdiff(old_names, names)
[09:30:09.362]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:09.362]                   envs[common]]
[09:30:09.362]                 NAMES <- toupper(changed)
[09:30:09.362]                 args <- list()
[09:30:09.362]                 for (kk in seq_along(NAMES)) {
[09:30:09.362]                   name <- changed[[kk]]
[09:30:09.362]                   NAME <- NAMES[[kk]]
[09:30:09.362]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:09.362]                     next
[09:30:09.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:09.362]                 }
[09:30:09.362]                 NAMES <- toupper(added)
[09:30:09.362]                 for (kk in seq_along(NAMES)) {
[09:30:09.362]                   name <- added[[kk]]
[09:30:09.362]                   NAME <- NAMES[[kk]]
[09:30:09.362]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:09.362]                     next
[09:30:09.362]                   args[[name]] <- ""
[09:30:09.362]                 }
[09:30:09.362]                 NAMES <- toupper(removed)
[09:30:09.362]                 for (kk in seq_along(NAMES)) {
[09:30:09.362]                   name <- removed[[kk]]
[09:30:09.362]                   NAME <- NAMES[[kk]]
[09:30:09.362]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:09.362]                     next
[09:30:09.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:09.362]                 }
[09:30:09.362]                 if (length(args) > 0) 
[09:30:09.362]                   base::do.call(base::Sys.setenv, args = args)
[09:30:09.362]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:09.362]             }
[09:30:09.362]             else {
[09:30:09.362]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:09.362]             }
[09:30:09.362]             {
[09:30:09.362]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:09.362]                   0L) {
[09:30:09.362]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:09.362]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:09.362]                   base::options(opts)
[09:30:09.362]                 }
[09:30:09.362]                 {
[09:30:09.362]                   {
[09:30:09.362]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:09.362]                     NULL
[09:30:09.362]                   }
[09:30:09.362]                   options(future.plan = NULL)
[09:30:09.362]                   if (is.na(NA_character_)) 
[09:30:09.362]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:09.362]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:09.362]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:09.362]                     .init = FALSE)
[09:30:09.362]                 }
[09:30:09.362]             }
[09:30:09.362]         }
[09:30:09.362]     })
[09:30:09.362]     if (TRUE) {
[09:30:09.362]         base::sink(type = "output", split = FALSE)
[09:30:09.362]         if (FALSE) {
[09:30:09.362]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:09.362]         }
[09:30:09.362]         else {
[09:30:09.362]             ...future.result["stdout"] <- base::list(NULL)
[09:30:09.362]         }
[09:30:09.362]         base::close(...future.stdout)
[09:30:09.362]         ...future.stdout <- NULL
[09:30:09.362]     }
[09:30:09.362]     ...future.result$conditions <- ...future.conditions
[09:30:09.362]     ...future.result$finished <- base::Sys.time()
[09:30:09.362]     ...future.result
[09:30:09.362] }
[09:30:09.365] assign_globals() ...
[09:30:09.365] List of 5
[09:30:09.365]  $ ...future.FUN            :function (x)  
[09:30:09.365]  $ future.call.arguments    : list()
[09:30:09.365]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:09.365]  $ ...future.elements_ii    :List of 1
[09:30:09.365]   ..$ : int 0
[09:30:09.365]  $ ...future.seeds_ii       : NULL
[09:30:09.365]  $ ...future.globals.maxSize: NULL
[09:30:09.365]  - attr(*, "where")=List of 5
[09:30:09.365]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:09.365]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:30:09.365]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:09.365]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:09.365]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:09.365]  - attr(*, "resolved")= logi FALSE
[09:30:09.365]  - attr(*, "total_size")= num 4720
[09:30:09.365]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:09.365]  - attr(*, "already-done")= logi TRUE
[09:30:09.372] - reassign environment for ‘...future.FUN’
[09:30:09.372] - copied ‘...future.FUN’ to environment
[09:30:09.372] - copied ‘future.call.arguments’ to environment
[09:30:09.372] - copied ‘...future.elements_ii’ to environment
[09:30:09.372] - copied ‘...future.seeds_ii’ to environment
[09:30:09.373] - copied ‘...future.globals.maxSize’ to environment
[09:30:09.373] assign_globals() ... done
[09:30:09.373] requestCore(): workers = 2
[09:30:09.382] MulticoreFuture started
[09:30:09.383] - Launch lazy future ... done
[09:30:09.384] plan(): Setting new future strategy stack:
[09:30:09.384] run() for ‘MulticoreFuture’ ... done
[09:30:09.384] Created future:
[09:30:09.384] List of future strategies:
[09:30:09.384] 1. sequential:
[09:30:09.384]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:09.384]    - tweaked: FALSE
[09:30:09.384]    - call: NULL
[09:30:09.385] plan(): nbrOfWorkers() = 1
[09:30:09.388] plan(): Setting new future strategy stack:
[09:30:09.388] List of future strategies:
[09:30:09.388] 1. multicore:
[09:30:09.388]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:30:09.388]    - tweaked: FALSE
[09:30:09.388]    - call: plan(strategy)
[09:30:09.393] plan(): nbrOfWorkers() = 2
[09:30:09.385] MulticoreFuture:
[09:30:09.385] Label: ‘future_lapply-2’
[09:30:09.385] Expression:
[09:30:09.385] {
[09:30:09.385]     do.call(function(...) {
[09:30:09.385]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:09.385]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:09.385]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:09.385]             on.exit(options(oopts), add = TRUE)
[09:30:09.385]         }
[09:30:09.385]         {
[09:30:09.385]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:09.385]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:09.385]                 ...future.FUN(...future.X_jj, ...)
[09:30:09.385]             })
[09:30:09.385]         }
[09:30:09.385]     }, args = future.call.arguments)
[09:30:09.385] }
[09:30:09.385] Lazy evaluation: FALSE
[09:30:09.385] Asynchronous evaluation: TRUE
[09:30:09.385] Local evaluation: TRUE
[09:30:09.385] Environment: R_GlobalEnv
[09:30:09.385] Capture standard output: FALSE
[09:30:09.385] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:09.385] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:09.385] Packages: <none>
[09:30:09.385] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:09.385] Resolved: TRUE
[09:30:09.385] Value: <not collected>
[09:30:09.385] Conditions captured: <none>
[09:30:09.385] Early signaling: FALSE
[09:30:09.385] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:09.385] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:09.394] Chunk #2 of 2 ... DONE
[09:30:09.395] Launching 2 futures (chunks) ... DONE
[09:30:09.395] Resolving 2 futures (chunks) ...
[09:30:09.395] resolve() on list ...
[09:30:09.395]  recursive: 0
[09:30:09.395]  length: 2
[09:30:09.396] 
[09:30:09.406] Future #2
[09:30:09.407] result() for MulticoreFuture ...
[09:30:09.409] result() for MulticoreFuture ...
[09:30:09.409] result() for MulticoreFuture ... done
[09:30:09.410] result() for MulticoreFuture ... done
[09:30:09.410] result() for MulticoreFuture ...
[09:30:09.410] result() for MulticoreFuture ... done
[09:30:09.410] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:30:09.410] - nx: 2
[09:30:09.410] - relay: TRUE
[09:30:09.411] - stdout: TRUE
[09:30:09.411] - signal: TRUE
[09:30:09.411] - resignal: FALSE
[09:30:09.411] - force: TRUE
[09:30:09.411] - relayed: [n=2] FALSE, FALSE
[09:30:09.411] - queued futures: [n=2] FALSE, FALSE
[09:30:09.411]  - until=1
[09:30:09.411]  - relaying element #1
[09:30:09.412] - relayed: [n=2] FALSE, FALSE
[09:30:09.412] - queued futures: [n=2] FALSE, TRUE
[09:30:09.412] signalConditionsASAP(NULL, pos=2) ... done
[09:30:09.412]  length: 1 (resolved future 2)
[09:30:09.835] plan(): Setting new future strategy stack:
[09:30:09.836] List of future strategies:
[09:30:09.836] 1. multicore:
[09:30:09.836]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:30:09.836]    - tweaked: FALSE
[09:30:09.836]    - call: plan(strategy)
[09:30:09.840] plan(): nbrOfWorkers() = 2
[09:30:09.841] Future #1
[09:30:09.841] result() for MulticoreFuture ...
[09:30:09.841] result() for MulticoreFuture ...
[09:30:09.842] result() for MulticoreFuture ... done
[09:30:09.842] result() for MulticoreFuture ... done
[09:30:09.842] result() for MulticoreFuture ...
[09:30:09.842] result() for MulticoreFuture ... done
[09:30:09.842] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:30:09.842] - nx: 2
[09:30:09.842] - relay: TRUE
[09:30:09.842] - stdout: TRUE
[09:30:09.842] - signal: TRUE
[09:30:09.843] - resignal: FALSE
[09:30:09.843] - force: TRUE
[09:30:09.843] - relayed: [n=2] FALSE, FALSE
[09:30:09.843] - queued futures: [n=2] FALSE, TRUE
[09:30:09.843]  - until=1
[09:30:09.843]  - relaying element #1
[09:30:09.843] result() for MulticoreFuture ...
[09:30:09.843] result() for MulticoreFuture ... done
[09:30:09.843] result() for MulticoreFuture ...
[09:30:09.843] result() for MulticoreFuture ... done
[09:30:09.844] result() for MulticoreFuture ...
[09:30:09.844] result() for MulticoreFuture ... done
[09:30:09.844] result() for MulticoreFuture ...
[09:30:09.844] result() for MulticoreFuture ... done
[09:30:09.844] - relayed: [n=2] TRUE, FALSE
[09:30:09.844] - queued futures: [n=2] TRUE, TRUE
[09:30:09.844] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:30:09.844]  length: 0 (resolved future 1)
[09:30:09.845] Relaying remaining futures
[09:30:09.845] signalConditionsASAP(NULL, pos=0) ...
[09:30:09.845] - nx: 2
[09:30:09.845] - relay: TRUE
[09:30:09.845] - stdout: TRUE
[09:30:09.845] - signal: TRUE
[09:30:09.845] - resignal: FALSE
[09:30:09.845] - force: TRUE
[09:30:09.845] - relayed: [n=2] TRUE, FALSE
[09:30:09.845] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:30:09.846]  - relaying element #2
[09:30:09.846] result() for MulticoreFuture ...
[09:30:09.846] result() for MulticoreFuture ... done
[09:30:09.846] result() for MulticoreFuture ...
[09:30:09.846] result() for MulticoreFuture ... done
[09:30:09.846] result() for MulticoreFuture ...
[09:30:09.846] result() for MulticoreFuture ... done
[09:30:09.846] result() for MulticoreFuture ...
[09:30:09.847] result() for MulticoreFuture ... done
[09:30:09.847] - relayed: [n=2] TRUE, TRUE
[09:30:09.847] - queued futures: [n=2] TRUE, TRUE
[09:30:09.847] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[09:30:09.847] resolve() on list ... DONE
[09:30:09.847] result() for MulticoreFuture ...
[09:30:09.847] result() for MulticoreFuture ... done
[09:30:09.847] result() for MulticoreFuture ...
[09:30:09.847] result() for MulticoreFuture ... done
[09:30:09.848] result() for MulticoreFuture ...
[09:30:09.848] result() for MulticoreFuture ... done
[09:30:09.848] result() for MulticoreFuture ...
[09:30:09.848] result() for MulticoreFuture ... done
[09:30:09.848]  - Number of value chunks collected: 2
[09:30:09.848] Resolving 2 futures (chunks) ... DONE
[09:30:09.848] Reducing values from 2 chunks ...
[09:30:09.848]  - Number of values collected after concatenation: 2
[09:30:09.848]  - Number of values expected: 2
[09:30:09.849] Reducing values from 2 chunks ... DONE
[09:30:09.849] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[09:30:09.849] future_lapply() ...
[09:30:09.854] Number of chunks: 2
[09:30:09.854] getGlobalsAndPackagesXApply() ...
[09:30:09.854]  - future.globals: TRUE
[09:30:09.854] getGlobalsAndPackages() ...
[09:30:09.855] Searching for globals...
[09:30:09.856] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[09:30:09.856] Searching for globals ... DONE
[09:30:09.856] Resolving globals: FALSE
[09:30:09.857] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[09:30:09.857] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[09:30:09.857] - globals: [1] ‘FUN’
[09:30:09.857] 
[09:30:09.858] getGlobalsAndPackages() ... DONE
[09:30:09.858]  - globals found/used: [n=1] ‘FUN’
[09:30:09.858]  - needed namespaces: [n=0] 
[09:30:09.858] Finding globals ... DONE
[09:30:09.858]  - use_args: TRUE
[09:30:09.858]  - Getting '...' globals ...
[09:30:09.858] resolve() on list ...
[09:30:09.859]  recursive: 0
[09:30:09.859]  length: 1
[09:30:09.859]  elements: ‘...’
[09:30:09.859]  length: 0 (resolved future 1)
[09:30:09.859] resolve() on list ... DONE
[09:30:09.859]    - '...' content: [n=0] 
[09:30:09.859] List of 1
[09:30:09.859]  $ ...: list()
[09:30:09.859]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:09.859]  - attr(*, "where")=List of 1
[09:30:09.859]   ..$ ...:<environment: 0x55c1038a76c8> 
[09:30:09.859]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:09.859]  - attr(*, "resolved")= logi TRUE
[09:30:09.859]  - attr(*, "total_size")= num NA
[09:30:09.864]  - Getting '...' globals ... DONE
[09:30:09.865] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:30:09.865] List of 2
[09:30:09.865]  $ ...future.FUN:function (x)  
[09:30:09.865]  $ ...          : list()
[09:30:09.865]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:09.865]  - attr(*, "where")=List of 2
[09:30:09.865]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:09.865]   ..$ ...          :<environment: 0x55c1038a76c8> 
[09:30:09.865]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:09.865]  - attr(*, "resolved")= logi FALSE
[09:30:09.865]  - attr(*, "total_size")= num 4720
[09:30:09.867] Packages to be attached in all futures: [n=0] 
[09:30:09.868] getGlobalsAndPackagesXApply() ... DONE
[09:30:09.868] Number of futures (= number of chunks): 2
[09:30:09.868] Launching 2 futures (chunks) ...
[09:30:09.868] Chunk #1 of 2 ...
[09:30:09.868]  - Finding globals in 'X' for chunk #1 ...
[09:30:09.868] getGlobalsAndPackages() ...
[09:30:09.868] Searching for globals...
[09:30:09.869] 
[09:30:09.869] Searching for globals ... DONE
[09:30:09.869] - globals: [0] <none>
[09:30:09.869] getGlobalsAndPackages() ... DONE
[09:30:09.869]    + additional globals found: [n=0] 
[09:30:09.869]    + additional namespaces needed: [n=0] 
[09:30:09.869]  - Finding globals in 'X' for chunk #1 ... DONE
[09:30:09.869]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:09.869]  - seeds: <none>
[09:30:09.869]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:09.869] getGlobalsAndPackages() ...
[09:30:09.870] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:09.870] Resolving globals: FALSE
[09:30:09.870] Tweak future expression to call with '...' arguments ...
[09:30:09.870] {
[09:30:09.870]     do.call(function(...) {
[09:30:09.870]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:09.870]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:09.870]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:09.870]             on.exit(options(oopts), add = TRUE)
[09:30:09.870]         }
[09:30:09.870]         {
[09:30:09.870]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:09.870]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:09.870]                 ...future.FUN(...future.X_jj, ...)
[09:30:09.870]             })
[09:30:09.870]         }
[09:30:09.870]     }, args = future.call.arguments)
[09:30:09.870] }
[09:30:09.870] Tweak future expression to call with '...' arguments ... DONE
[09:30:09.870] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:09.871] 
[09:30:09.871] getGlobalsAndPackages() ... DONE
[09:30:09.871] run() for ‘Future’ ...
[09:30:09.871] - state: ‘created’
[09:30:09.871] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:30:09.875] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:09.875] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:30:09.875]   - Field: ‘label’
[09:30:09.875]   - Field: ‘local’
[09:30:09.875]   - Field: ‘owner’
[09:30:09.875]   - Field: ‘envir’
[09:30:09.875]   - Field: ‘workers’
[09:30:09.875]   - Field: ‘packages’
[09:30:09.875]   - Field: ‘gc’
[09:30:09.876]   - Field: ‘job’
[09:30:09.876]   - Field: ‘conditions’
[09:30:09.876]   - Field: ‘expr’
[09:30:09.876]   - Field: ‘uuid’
[09:30:09.876]   - Field: ‘seed’
[09:30:09.876]   - Field: ‘version’
[09:30:09.876]   - Field: ‘result’
[09:30:09.876]   - Field: ‘asynchronous’
[09:30:09.876]   - Field: ‘calls’
[09:30:09.876]   - Field: ‘globals’
[09:30:09.877]   - Field: ‘stdout’
[09:30:09.877]   - Field: ‘earlySignal’
[09:30:09.877]   - Field: ‘lazy’
[09:30:09.877]   - Field: ‘state’
[09:30:09.877] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:30:09.877] - Launch lazy future ...
[09:30:09.877] Packages needed by the future expression (n = 0): <none>
[09:30:09.877] Packages needed by future strategies (n = 0): <none>
[09:30:09.878] {
[09:30:09.878]     {
[09:30:09.878]         {
[09:30:09.878]             ...future.startTime <- base::Sys.time()
[09:30:09.878]             {
[09:30:09.878]                 {
[09:30:09.878]                   {
[09:30:09.878]                     {
[09:30:09.878]                       base::local({
[09:30:09.878]                         has_future <- base::requireNamespace("future", 
[09:30:09.878]                           quietly = TRUE)
[09:30:09.878]                         if (has_future) {
[09:30:09.878]                           ns <- base::getNamespace("future")
[09:30:09.878]                           version <- ns[[".package"]][["version"]]
[09:30:09.878]                           if (is.null(version)) 
[09:30:09.878]                             version <- utils::packageVersion("future")
[09:30:09.878]                         }
[09:30:09.878]                         else {
[09:30:09.878]                           version <- NULL
[09:30:09.878]                         }
[09:30:09.878]                         if (!has_future || version < "1.8.0") {
[09:30:09.878]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:09.878]                             "", base::R.version$version.string), 
[09:30:09.878]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:09.878]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:09.878]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:09.878]                               "release", "version")], collapse = " "), 
[09:30:09.878]                             hostname = base::Sys.info()[["nodename"]])
[09:30:09.878]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:09.878]                             info)
[09:30:09.878]                           info <- base::paste(info, collapse = "; ")
[09:30:09.878]                           if (!has_future) {
[09:30:09.878]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:09.878]                               info)
[09:30:09.878]                           }
[09:30:09.878]                           else {
[09:30:09.878]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:09.878]                               info, version)
[09:30:09.878]                           }
[09:30:09.878]                           base::stop(msg)
[09:30:09.878]                         }
[09:30:09.878]                       })
[09:30:09.878]                     }
[09:30:09.878]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:09.878]                     base::options(mc.cores = 1L)
[09:30:09.878]                   }
[09:30:09.878]                   ...future.strategy.old <- future::plan("list")
[09:30:09.878]                   options(future.plan = NULL)
[09:30:09.878]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:09.878]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:09.878]                 }
[09:30:09.878]                 ...future.workdir <- getwd()
[09:30:09.878]             }
[09:30:09.878]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:09.878]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:09.878]         }
[09:30:09.878]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:09.878]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:09.878]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:09.878]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:09.878]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:09.878]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:09.878]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:09.878]             base::names(...future.oldOptions))
[09:30:09.878]     }
[09:30:09.878]     if (FALSE) {
[09:30:09.878]     }
[09:30:09.878]     else {
[09:30:09.878]         if (TRUE) {
[09:30:09.878]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:09.878]                 open = "w")
[09:30:09.878]         }
[09:30:09.878]         else {
[09:30:09.878]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:09.878]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:09.878]         }
[09:30:09.878]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:09.878]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:09.878]             base::sink(type = "output", split = FALSE)
[09:30:09.878]             base::close(...future.stdout)
[09:30:09.878]         }, add = TRUE)
[09:30:09.878]     }
[09:30:09.878]     ...future.frame <- base::sys.nframe()
[09:30:09.878]     ...future.conditions <- base::list()
[09:30:09.878]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:09.878]     if (FALSE) {
[09:30:09.878]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:09.878]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:09.878]     }
[09:30:09.878]     ...future.result <- base::tryCatch({
[09:30:09.878]         base::withCallingHandlers({
[09:30:09.878]             ...future.value <- base::withVisible(base::local({
[09:30:09.878]                 withCallingHandlers({
[09:30:09.878]                   {
[09:30:09.878]                     do.call(function(...) {
[09:30:09.878]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:09.878]                       if (!identical(...future.globals.maxSize.org, 
[09:30:09.878]                         ...future.globals.maxSize)) {
[09:30:09.878]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:09.878]                         on.exit(options(oopts), add = TRUE)
[09:30:09.878]                       }
[09:30:09.878]                       {
[09:30:09.878]                         lapply(seq_along(...future.elements_ii), 
[09:30:09.878]                           FUN = function(jj) {
[09:30:09.878]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:09.878]                             ...future.FUN(...future.X_jj, ...)
[09:30:09.878]                           })
[09:30:09.878]                       }
[09:30:09.878]                     }, args = future.call.arguments)
[09:30:09.878]                   }
[09:30:09.878]                 }, immediateCondition = function(cond) {
[09:30:09.878]                   save_rds <- function (object, pathname, ...) 
[09:30:09.878]                   {
[09:30:09.878]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:30:09.878]                     if (file_test("-f", pathname_tmp)) {
[09:30:09.878]                       fi_tmp <- file.info(pathname_tmp)
[09:30:09.878]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:30:09.878]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:09.878]                         fi_tmp[["mtime"]])
[09:30:09.878]                     }
[09:30:09.878]                     tryCatch({
[09:30:09.878]                       saveRDS(object, file = pathname_tmp, ...)
[09:30:09.878]                     }, error = function(ex) {
[09:30:09.878]                       msg <- conditionMessage(ex)
[09:30:09.878]                       fi_tmp <- file.info(pathname_tmp)
[09:30:09.878]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:30:09.878]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:09.878]                         fi_tmp[["mtime"]], msg)
[09:30:09.878]                       ex$message <- msg
[09:30:09.878]                       stop(ex)
[09:30:09.878]                     })
[09:30:09.878]                     stopifnot(file_test("-f", pathname_tmp))
[09:30:09.878]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:30:09.878]                     if (!res || file_test("-f", pathname_tmp)) {
[09:30:09.878]                       fi_tmp <- file.info(pathname_tmp)
[09:30:09.878]                       fi <- file.info(pathname)
[09:30:09.878]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:30:09.878]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:09.878]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:30:09.878]                         fi[["size"]], fi[["mtime"]])
[09:30:09.878]                       stop(msg)
[09:30:09.878]                     }
[09:30:09.878]                     invisible(pathname)
[09:30:09.878]                   }
[09:30:09.878]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:30:09.878]                     rootPath = tempdir()) 
[09:30:09.878]                   {
[09:30:09.878]                     obj <- list(time = Sys.time(), condition = cond)
[09:30:09.878]                     file <- tempfile(pattern = class(cond)[1], 
[09:30:09.878]                       tmpdir = path, fileext = ".rds")
[09:30:09.878]                     save_rds(obj, file)
[09:30:09.878]                   }
[09:30:09.878]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0coFNd/.future/immediateConditions")
[09:30:09.878]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:09.878]                   {
[09:30:09.878]                     inherits <- base::inherits
[09:30:09.878]                     invokeRestart <- base::invokeRestart
[09:30:09.878]                     is.null <- base::is.null
[09:30:09.878]                     muffled <- FALSE
[09:30:09.878]                     if (inherits(cond, "message")) {
[09:30:09.878]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:09.878]                       if (muffled) 
[09:30:09.878]                         invokeRestart("muffleMessage")
[09:30:09.878]                     }
[09:30:09.878]                     else if (inherits(cond, "warning")) {
[09:30:09.878]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:09.878]                       if (muffled) 
[09:30:09.878]                         invokeRestart("muffleWarning")
[09:30:09.878]                     }
[09:30:09.878]                     else if (inherits(cond, "condition")) {
[09:30:09.878]                       if (!is.null(pattern)) {
[09:30:09.878]                         computeRestarts <- base::computeRestarts
[09:30:09.878]                         grepl <- base::grepl
[09:30:09.878]                         restarts <- computeRestarts(cond)
[09:30:09.878]                         for (restart in restarts) {
[09:30:09.878]                           name <- restart$name
[09:30:09.878]                           if (is.null(name)) 
[09:30:09.878]                             next
[09:30:09.878]                           if (!grepl(pattern, name)) 
[09:30:09.878]                             next
[09:30:09.878]                           invokeRestart(restart)
[09:30:09.878]                           muffled <- TRUE
[09:30:09.878]                           break
[09:30:09.878]                         }
[09:30:09.878]                       }
[09:30:09.878]                     }
[09:30:09.878]                     invisible(muffled)
[09:30:09.878]                   }
[09:30:09.878]                   muffleCondition(cond)
[09:30:09.878]                 })
[09:30:09.878]             }))
[09:30:09.878]             future::FutureResult(value = ...future.value$value, 
[09:30:09.878]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:09.878]                   ...future.rng), globalenv = if (FALSE) 
[09:30:09.878]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:09.878]                     ...future.globalenv.names))
[09:30:09.878]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:09.878]         }, condition = base::local({
[09:30:09.878]             c <- base::c
[09:30:09.878]             inherits <- base::inherits
[09:30:09.878]             invokeRestart <- base::invokeRestart
[09:30:09.878]             length <- base::length
[09:30:09.878]             list <- base::list
[09:30:09.878]             seq.int <- base::seq.int
[09:30:09.878]             signalCondition <- base::signalCondition
[09:30:09.878]             sys.calls <- base::sys.calls
[09:30:09.878]             `[[` <- base::`[[`
[09:30:09.878]             `+` <- base::`+`
[09:30:09.878]             `<<-` <- base::`<<-`
[09:30:09.878]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:09.878]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:09.878]                   3L)]
[09:30:09.878]             }
[09:30:09.878]             function(cond) {
[09:30:09.878]                 is_error <- inherits(cond, "error")
[09:30:09.878]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:09.878]                   NULL)
[09:30:09.878]                 if (is_error) {
[09:30:09.878]                   sessionInformation <- function() {
[09:30:09.878]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:09.878]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:09.878]                       search = base::search(), system = base::Sys.info())
[09:30:09.878]                   }
[09:30:09.878]                   ...future.conditions[[length(...future.conditions) + 
[09:30:09.878]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:09.878]                     cond$call), session = sessionInformation(), 
[09:30:09.878]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:09.878]                   signalCondition(cond)
[09:30:09.878]                 }
[09:30:09.878]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:09.878]                 "immediateCondition"))) {
[09:30:09.878]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:09.878]                   ...future.conditions[[length(...future.conditions) + 
[09:30:09.878]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:09.878]                   if (TRUE && !signal) {
[09:30:09.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:09.878]                     {
[09:30:09.878]                       inherits <- base::inherits
[09:30:09.878]                       invokeRestart <- base::invokeRestart
[09:30:09.878]                       is.null <- base::is.null
[09:30:09.878]                       muffled <- FALSE
[09:30:09.878]                       if (inherits(cond, "message")) {
[09:30:09.878]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:09.878]                         if (muffled) 
[09:30:09.878]                           invokeRestart("muffleMessage")
[09:30:09.878]                       }
[09:30:09.878]                       else if (inherits(cond, "warning")) {
[09:30:09.878]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:09.878]                         if (muffled) 
[09:30:09.878]                           invokeRestart("muffleWarning")
[09:30:09.878]                       }
[09:30:09.878]                       else if (inherits(cond, "condition")) {
[09:30:09.878]                         if (!is.null(pattern)) {
[09:30:09.878]                           computeRestarts <- base::computeRestarts
[09:30:09.878]                           grepl <- base::grepl
[09:30:09.878]                           restarts <- computeRestarts(cond)
[09:30:09.878]                           for (restart in restarts) {
[09:30:09.878]                             name <- restart$name
[09:30:09.878]                             if (is.null(name)) 
[09:30:09.878]                               next
[09:30:09.878]                             if (!grepl(pattern, name)) 
[09:30:09.878]                               next
[09:30:09.878]                             invokeRestart(restart)
[09:30:09.878]                             muffled <- TRUE
[09:30:09.878]                             break
[09:30:09.878]                           }
[09:30:09.878]                         }
[09:30:09.878]                       }
[09:30:09.878]                       invisible(muffled)
[09:30:09.878]                     }
[09:30:09.878]                     muffleCondition(cond, pattern = "^muffle")
[09:30:09.878]                   }
[09:30:09.878]                 }
[09:30:09.878]                 else {
[09:30:09.878]                   if (TRUE) {
[09:30:09.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:09.878]                     {
[09:30:09.878]                       inherits <- base::inherits
[09:30:09.878]                       invokeRestart <- base::invokeRestart
[09:30:09.878]                       is.null <- base::is.null
[09:30:09.878]                       muffled <- FALSE
[09:30:09.878]                       if (inherits(cond, "message")) {
[09:30:09.878]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:09.878]                         if (muffled) 
[09:30:09.878]                           invokeRestart("muffleMessage")
[09:30:09.878]                       }
[09:30:09.878]                       else if (inherits(cond, "warning")) {
[09:30:09.878]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:09.878]                         if (muffled) 
[09:30:09.878]                           invokeRestart("muffleWarning")
[09:30:09.878]                       }
[09:30:09.878]                       else if (inherits(cond, "condition")) {
[09:30:09.878]                         if (!is.null(pattern)) {
[09:30:09.878]                           computeRestarts <- base::computeRestarts
[09:30:09.878]                           grepl <- base::grepl
[09:30:09.878]                           restarts <- computeRestarts(cond)
[09:30:09.878]                           for (restart in restarts) {
[09:30:09.878]                             name <- restart$name
[09:30:09.878]                             if (is.null(name)) 
[09:30:09.878]                               next
[09:30:09.878]                             if (!grepl(pattern, name)) 
[09:30:09.878]                               next
[09:30:09.878]                             invokeRestart(restart)
[09:30:09.878]                             muffled <- TRUE
[09:30:09.878]                             break
[09:30:09.878]                           }
[09:30:09.878]                         }
[09:30:09.878]                       }
[09:30:09.878]                       invisible(muffled)
[09:30:09.878]                     }
[09:30:09.878]                     muffleCondition(cond, pattern = "^muffle")
[09:30:09.878]                   }
[09:30:09.878]                 }
[09:30:09.878]             }
[09:30:09.878]         }))
[09:30:09.878]     }, error = function(ex) {
[09:30:09.878]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:09.878]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:09.878]                 ...future.rng), started = ...future.startTime, 
[09:30:09.878]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:09.878]             version = "1.8"), class = "FutureResult")
[09:30:09.878]     }, finally = {
[09:30:09.878]         if (!identical(...future.workdir, getwd())) 
[09:30:09.878]             setwd(...future.workdir)
[09:30:09.878]         {
[09:30:09.878]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:09.878]                 ...future.oldOptions$nwarnings <- NULL
[09:30:09.878]             }
[09:30:09.878]             base::options(...future.oldOptions)
[09:30:09.878]             if (.Platform$OS.type == "windows") {
[09:30:09.878]                 old_names <- names(...future.oldEnvVars)
[09:30:09.878]                 envs <- base::Sys.getenv()
[09:30:09.878]                 names <- names(envs)
[09:30:09.878]                 common <- intersect(names, old_names)
[09:30:09.878]                 added <- setdiff(names, old_names)
[09:30:09.878]                 removed <- setdiff(old_names, names)
[09:30:09.878]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:09.878]                   envs[common]]
[09:30:09.878]                 NAMES <- toupper(changed)
[09:30:09.878]                 args <- list()
[09:30:09.878]                 for (kk in seq_along(NAMES)) {
[09:30:09.878]                   name <- changed[[kk]]
[09:30:09.878]                   NAME <- NAMES[[kk]]
[09:30:09.878]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:09.878]                     next
[09:30:09.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:09.878]                 }
[09:30:09.878]                 NAMES <- toupper(added)
[09:30:09.878]                 for (kk in seq_along(NAMES)) {
[09:30:09.878]                   name <- added[[kk]]
[09:30:09.878]                   NAME <- NAMES[[kk]]
[09:30:09.878]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:09.878]                     next
[09:30:09.878]                   args[[name]] <- ""
[09:30:09.878]                 }
[09:30:09.878]                 NAMES <- toupper(removed)
[09:30:09.878]                 for (kk in seq_along(NAMES)) {
[09:30:09.878]                   name <- removed[[kk]]
[09:30:09.878]                   NAME <- NAMES[[kk]]
[09:30:09.878]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:09.878]                     next
[09:30:09.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:09.878]                 }
[09:30:09.878]                 if (length(args) > 0) 
[09:30:09.878]                   base::do.call(base::Sys.setenv, args = args)
[09:30:09.878]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:09.878]             }
[09:30:09.878]             else {
[09:30:09.878]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:09.878]             }
[09:30:09.878]             {
[09:30:09.878]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:09.878]                   0L) {
[09:30:09.878]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:09.878]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:09.878]                   base::options(opts)
[09:30:09.878]                 }
[09:30:09.878]                 {
[09:30:09.878]                   {
[09:30:09.878]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:09.878]                     NULL
[09:30:09.878]                   }
[09:30:09.878]                   options(future.plan = NULL)
[09:30:09.878]                   if (is.na(NA_character_)) 
[09:30:09.878]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:09.878]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:09.878]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:09.878]                     .init = FALSE)
[09:30:09.878]                 }
[09:30:09.878]             }
[09:30:09.878]         }
[09:30:09.878]     })
[09:30:09.878]     if (TRUE) {
[09:30:09.878]         base::sink(type = "output", split = FALSE)
[09:30:09.878]         if (TRUE) {
[09:30:09.878]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:09.878]         }
[09:30:09.878]         else {
[09:30:09.878]             ...future.result["stdout"] <- base::list(NULL)
[09:30:09.878]         }
[09:30:09.878]         base::close(...future.stdout)
[09:30:09.878]         ...future.stdout <- NULL
[09:30:09.878]     }
[09:30:09.878]     ...future.result$conditions <- ...future.conditions
[09:30:09.878]     ...future.result$finished <- base::Sys.time()
[09:30:09.878]     ...future.result
[09:30:09.878] }
[09:30:09.880] assign_globals() ...
[09:30:09.880] List of 5
[09:30:09.880]  $ ...future.FUN            :function (x)  
[09:30:09.880]  $ future.call.arguments    : list()
[09:30:09.880]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:09.880]  $ ...future.elements_ii    :List of 1
[09:30:09.880]   ..$ : int 1
[09:30:09.880]  $ ...future.seeds_ii       : NULL
[09:30:09.880]  $ ...future.globals.maxSize: NULL
[09:30:09.880]  - attr(*, "where")=List of 5
[09:30:09.880]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:09.880]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:30:09.880]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:09.880]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:09.880]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:09.880]  - attr(*, "resolved")= logi FALSE
[09:30:09.880]  - attr(*, "total_size")= num 4720
[09:30:09.880]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:09.880]  - attr(*, "already-done")= logi TRUE
[09:30:09.885] - reassign environment for ‘...future.FUN’
[09:30:09.885] - copied ‘...future.FUN’ to environment
[09:30:09.885] - copied ‘future.call.arguments’ to environment
[09:30:09.885] - copied ‘...future.elements_ii’ to environment
[09:30:09.885] - copied ‘...future.seeds_ii’ to environment
[09:30:09.885] - copied ‘...future.globals.maxSize’ to environment
[09:30:09.885] assign_globals() ... done
[09:30:09.885] requestCore(): workers = 2
[09:30:09.888] MulticoreFuture started
[09:30:09.888] - Launch lazy future ... done
[09:30:09.888] run() for ‘MulticoreFuture’ ... done
[09:30:09.888] Created future:
[09:30:09.889] plan(): Setting new future strategy stack:
[09:30:09.889] List of future strategies:
[09:30:09.889] 1. sequential:
[09:30:09.889]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:09.889]    - tweaked: FALSE
[09:30:09.889]    - call: NULL
[09:30:09.890] plan(): nbrOfWorkers() = 1
[09:30:09.889] MulticoreFuture:
[09:30:09.889] Label: ‘future_lapply-1’
[09:30:09.889] Expression:
[09:30:09.889] {
[09:30:09.889]     do.call(function(...) {
[09:30:09.889]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:09.889]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:09.889]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:09.889]             on.exit(options(oopts), add = TRUE)
[09:30:09.889]         }
[09:30:09.889]         {
[09:30:09.889]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:09.889]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:09.889]                 ...future.FUN(...future.X_jj, ...)
[09:30:09.889]             })
[09:30:09.889]         }
[09:30:09.889]     }, args = future.call.arguments)
[09:30:09.889] }
[09:30:09.889] Lazy evaluation: FALSE
[09:30:09.889] Asynchronous evaluation: TRUE
[09:30:09.889] Local evaluation: TRUE
[09:30:09.889] Environment: R_GlobalEnv
[09:30:09.889] Capture standard output: TRUE
[09:30:09.889] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:09.889] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:09.889] Packages: <none>
[09:30:09.889] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:09.889] Resolved: FALSE
[09:30:09.889] Value: <not collected>
[09:30:09.889] Conditions captured: <none>
[09:30:09.889] Early signaling: FALSE
[09:30:09.889] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:09.889] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:09.901] Chunk #1 of 2 ... DONE
[09:30:09.902] Chunk #2 of 2 ...
[09:30:09.902]  - Finding globals in 'X' for chunk #2 ...
[09:30:09.902] getGlobalsAndPackages() ...
[09:30:09.902] Searching for globals...
[09:30:09.903] 
[09:30:09.903] Searching for globals ... DONE
[09:30:09.903] - globals: [0] <none>
[09:30:09.903] getGlobalsAndPackages() ... DONE
[09:30:09.903]    + additional globals found: [n=0] 
[09:30:09.903]    + additional namespaces needed: [n=0] 
[09:30:09.903]  - Finding globals in 'X' for chunk #2 ... DONE
[09:30:09.904]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:09.904]  - seeds: <none>
[09:30:09.904]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:09.904] getGlobalsAndPackages() ...
[09:30:09.904] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:09.905] Resolving globals: FALSE
[09:30:09.905] Tweak future expression to call with '...' arguments ...
[09:30:09.905] {
[09:30:09.905]     do.call(function(...) {
[09:30:09.905]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:09.905]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:09.905]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:09.905]             on.exit(options(oopts), add = TRUE)
[09:30:09.905]         }
[09:30:09.905]         {
[09:30:09.905]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:09.905]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:09.905]                 ...future.FUN(...future.X_jj, ...)
[09:30:09.905]             })
[09:30:09.905]         }
[09:30:09.905]     }, args = future.call.arguments)
[09:30:09.905] }
[09:30:09.905] Tweak future expression to call with '...' arguments ... DONE
[09:30:09.910] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:09.910] 
[09:30:09.910] getGlobalsAndPackages() ... DONE
[09:30:09.911] run() for ‘Future’ ...
[09:30:09.912] - state: ‘created’
[09:30:09.912] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:30:09.918] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:09.919] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:30:09.919]   - Field: ‘label’
[09:30:09.919]   - Field: ‘local’
[09:30:09.919]   - Field: ‘owner’
[09:30:09.919]   - Field: ‘envir’
[09:30:09.919]   - Field: ‘workers’
[09:30:09.920]   - Field: ‘packages’
[09:30:09.920]   - Field: ‘gc’
[09:30:09.920]   - Field: ‘job’
[09:30:09.920]   - Field: ‘conditions’
[09:30:09.920]   - Field: ‘expr’
[09:30:09.920]   - Field: ‘uuid’
[09:30:09.920]   - Field: ‘seed’
[09:30:09.921]   - Field: ‘version’
[09:30:09.921]   - Field: ‘result’
[09:30:09.921]   - Field: ‘asynchronous’
[09:30:09.921]   - Field: ‘calls’
[09:30:09.921]   - Field: ‘globals’
[09:30:09.921]   - Field: ‘stdout’
[09:30:09.922]   - Field: ‘earlySignal’
[09:30:09.922]   - Field: ‘lazy’
[09:30:09.922]   - Field: ‘state’
[09:30:09.922] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:30:09.922] - Launch lazy future ...
[09:30:09.923] Packages needed by the future expression (n = 0): <none>
[09:30:09.923] Packages needed by future strategies (n = 0): <none>
[09:30:09.924] {
[09:30:09.924]     {
[09:30:09.924]         {
[09:30:09.924]             ...future.startTime <- base::Sys.time()
[09:30:09.924]             {
[09:30:09.924]                 {
[09:30:09.924]                   {
[09:30:09.924]                     {
[09:30:09.924]                       base::local({
[09:30:09.924]                         has_future <- base::requireNamespace("future", 
[09:30:09.924]                           quietly = TRUE)
[09:30:09.924]                         if (has_future) {
[09:30:09.924]                           ns <- base::getNamespace("future")
[09:30:09.924]                           version <- ns[[".package"]][["version"]]
[09:30:09.924]                           if (is.null(version)) 
[09:30:09.924]                             version <- utils::packageVersion("future")
[09:30:09.924]                         }
[09:30:09.924]                         else {
[09:30:09.924]                           version <- NULL
[09:30:09.924]                         }
[09:30:09.924]                         if (!has_future || version < "1.8.0") {
[09:30:09.924]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:09.924]                             "", base::R.version$version.string), 
[09:30:09.924]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:09.924]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:09.924]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:09.924]                               "release", "version")], collapse = " "), 
[09:30:09.924]                             hostname = base::Sys.info()[["nodename"]])
[09:30:09.924]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:09.924]                             info)
[09:30:09.924]                           info <- base::paste(info, collapse = "; ")
[09:30:09.924]                           if (!has_future) {
[09:30:09.924]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:09.924]                               info)
[09:30:09.924]                           }
[09:30:09.924]                           else {
[09:30:09.924]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:09.924]                               info, version)
[09:30:09.924]                           }
[09:30:09.924]                           base::stop(msg)
[09:30:09.924]                         }
[09:30:09.924]                       })
[09:30:09.924]                     }
[09:30:09.924]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:09.924]                     base::options(mc.cores = 1L)
[09:30:09.924]                   }
[09:30:09.924]                   ...future.strategy.old <- future::plan("list")
[09:30:09.924]                   options(future.plan = NULL)
[09:30:09.924]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:09.924]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:09.924]                 }
[09:30:09.924]                 ...future.workdir <- getwd()
[09:30:09.924]             }
[09:30:09.924]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:09.924]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:09.924]         }
[09:30:09.924]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:09.924]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:09.924]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:09.924]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:09.924]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:09.924]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:09.924]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:09.924]             base::names(...future.oldOptions))
[09:30:09.924]     }
[09:30:09.924]     if (FALSE) {
[09:30:09.924]     }
[09:30:09.924]     else {
[09:30:09.924]         if (TRUE) {
[09:30:09.924]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:09.924]                 open = "w")
[09:30:09.924]         }
[09:30:09.924]         else {
[09:30:09.924]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:09.924]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:09.924]         }
[09:30:09.924]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:09.924]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:09.924]             base::sink(type = "output", split = FALSE)
[09:30:09.924]             base::close(...future.stdout)
[09:30:09.924]         }, add = TRUE)
[09:30:09.924]     }
[09:30:09.924]     ...future.frame <- base::sys.nframe()
[09:30:09.924]     ...future.conditions <- base::list()
[09:30:09.924]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:09.924]     if (FALSE) {
[09:30:09.924]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:09.924]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:09.924]     }
[09:30:09.924]     ...future.result <- base::tryCatch({
[09:30:09.924]         base::withCallingHandlers({
[09:30:09.924]             ...future.value <- base::withVisible(base::local({
[09:30:09.924]                 withCallingHandlers({
[09:30:09.924]                   {
[09:30:09.924]                     do.call(function(...) {
[09:30:09.924]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:09.924]                       if (!identical(...future.globals.maxSize.org, 
[09:30:09.924]                         ...future.globals.maxSize)) {
[09:30:09.924]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:09.924]                         on.exit(options(oopts), add = TRUE)
[09:30:09.924]                       }
[09:30:09.924]                       {
[09:30:09.924]                         lapply(seq_along(...future.elements_ii), 
[09:30:09.924]                           FUN = function(jj) {
[09:30:09.924]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:09.924]                             ...future.FUN(...future.X_jj, ...)
[09:30:09.924]                           })
[09:30:09.924]                       }
[09:30:09.924]                     }, args = future.call.arguments)
[09:30:09.924]                   }
[09:30:09.924]                 }, immediateCondition = function(cond) {
[09:30:09.924]                   save_rds <- function (object, pathname, ...) 
[09:30:09.924]                   {
[09:30:09.924]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:30:09.924]                     if (file_test("-f", pathname_tmp)) {
[09:30:09.924]                       fi_tmp <- file.info(pathname_tmp)
[09:30:09.924]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:30:09.924]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:09.924]                         fi_tmp[["mtime"]])
[09:30:09.924]                     }
[09:30:09.924]                     tryCatch({
[09:30:09.924]                       saveRDS(object, file = pathname_tmp, ...)
[09:30:09.924]                     }, error = function(ex) {
[09:30:09.924]                       msg <- conditionMessage(ex)
[09:30:09.924]                       fi_tmp <- file.info(pathname_tmp)
[09:30:09.924]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:30:09.924]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:09.924]                         fi_tmp[["mtime"]], msg)
[09:30:09.924]                       ex$message <- msg
[09:30:09.924]                       stop(ex)
[09:30:09.924]                     })
[09:30:09.924]                     stopifnot(file_test("-f", pathname_tmp))
[09:30:09.924]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:30:09.924]                     if (!res || file_test("-f", pathname_tmp)) {
[09:30:09.924]                       fi_tmp <- file.info(pathname_tmp)
[09:30:09.924]                       fi <- file.info(pathname)
[09:30:09.924]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:30:09.924]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:09.924]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:30:09.924]                         fi[["size"]], fi[["mtime"]])
[09:30:09.924]                       stop(msg)
[09:30:09.924]                     }
[09:30:09.924]                     invisible(pathname)
[09:30:09.924]                   }
[09:30:09.924]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:30:09.924]                     rootPath = tempdir()) 
[09:30:09.924]                   {
[09:30:09.924]                     obj <- list(time = Sys.time(), condition = cond)
[09:30:09.924]                     file <- tempfile(pattern = class(cond)[1], 
[09:30:09.924]                       tmpdir = path, fileext = ".rds")
[09:30:09.924]                     save_rds(obj, file)
[09:30:09.924]                   }
[09:30:09.924]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0coFNd/.future/immediateConditions")
[09:30:09.924]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:09.924]                   {
[09:30:09.924]                     inherits <- base::inherits
[09:30:09.924]                     invokeRestart <- base::invokeRestart
[09:30:09.924]                     is.null <- base::is.null
[09:30:09.924]                     muffled <- FALSE
[09:30:09.924]                     if (inherits(cond, "message")) {
[09:30:09.924]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:09.924]                       if (muffled) 
[09:30:09.924]                         invokeRestart("muffleMessage")
[09:30:09.924]                     }
[09:30:09.924]                     else if (inherits(cond, "warning")) {
[09:30:09.924]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:09.924]                       if (muffled) 
[09:30:09.924]                         invokeRestart("muffleWarning")
[09:30:09.924]                     }
[09:30:09.924]                     else if (inherits(cond, "condition")) {
[09:30:09.924]                       if (!is.null(pattern)) {
[09:30:09.924]                         computeRestarts <- base::computeRestarts
[09:30:09.924]                         grepl <- base::grepl
[09:30:09.924]                         restarts <- computeRestarts(cond)
[09:30:09.924]                         for (restart in restarts) {
[09:30:09.924]                           name <- restart$name
[09:30:09.924]                           if (is.null(name)) 
[09:30:09.924]                             next
[09:30:09.924]                           if (!grepl(pattern, name)) 
[09:30:09.924]                             next
[09:30:09.924]                           invokeRestart(restart)
[09:30:09.924]                           muffled <- TRUE
[09:30:09.924]                           break
[09:30:09.924]                         }
[09:30:09.924]                       }
[09:30:09.924]                     }
[09:30:09.924]                     invisible(muffled)
[09:30:09.924]                   }
[09:30:09.924]                   muffleCondition(cond)
[09:30:09.924]                 })
[09:30:09.924]             }))
[09:30:09.924]             future::FutureResult(value = ...future.value$value, 
[09:30:09.924]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:09.924]                   ...future.rng), globalenv = if (FALSE) 
[09:30:09.924]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:09.924]                     ...future.globalenv.names))
[09:30:09.924]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:09.924]         }, condition = base::local({
[09:30:09.924]             c <- base::c
[09:30:09.924]             inherits <- base::inherits
[09:30:09.924]             invokeRestart <- base::invokeRestart
[09:30:09.924]             length <- base::length
[09:30:09.924]             list <- base::list
[09:30:09.924]             seq.int <- base::seq.int
[09:30:09.924]             signalCondition <- base::signalCondition
[09:30:09.924]             sys.calls <- base::sys.calls
[09:30:09.924]             `[[` <- base::`[[`
[09:30:09.924]             `+` <- base::`+`
[09:30:09.924]             `<<-` <- base::`<<-`
[09:30:09.924]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:09.924]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:09.924]                   3L)]
[09:30:09.924]             }
[09:30:09.924]             function(cond) {
[09:30:09.924]                 is_error <- inherits(cond, "error")
[09:30:09.924]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:09.924]                   NULL)
[09:30:09.924]                 if (is_error) {
[09:30:09.924]                   sessionInformation <- function() {
[09:30:09.924]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:09.924]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:09.924]                       search = base::search(), system = base::Sys.info())
[09:30:09.924]                   }
[09:30:09.924]                   ...future.conditions[[length(...future.conditions) + 
[09:30:09.924]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:09.924]                     cond$call), session = sessionInformation(), 
[09:30:09.924]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:09.924]                   signalCondition(cond)
[09:30:09.924]                 }
[09:30:09.924]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:09.924]                 "immediateCondition"))) {
[09:30:09.924]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:09.924]                   ...future.conditions[[length(...future.conditions) + 
[09:30:09.924]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:09.924]                   if (TRUE && !signal) {
[09:30:09.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:09.924]                     {
[09:30:09.924]                       inherits <- base::inherits
[09:30:09.924]                       invokeRestart <- base::invokeRestart
[09:30:09.924]                       is.null <- base::is.null
[09:30:09.924]                       muffled <- FALSE
[09:30:09.924]                       if (inherits(cond, "message")) {
[09:30:09.924]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:09.924]                         if (muffled) 
[09:30:09.924]                           invokeRestart("muffleMessage")
[09:30:09.924]                       }
[09:30:09.924]                       else if (inherits(cond, "warning")) {
[09:30:09.924]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:09.924]                         if (muffled) 
[09:30:09.924]                           invokeRestart("muffleWarning")
[09:30:09.924]                       }
[09:30:09.924]                       else if (inherits(cond, "condition")) {
[09:30:09.924]                         if (!is.null(pattern)) {
[09:30:09.924]                           computeRestarts <- base::computeRestarts
[09:30:09.924]                           grepl <- base::grepl
[09:30:09.924]                           restarts <- computeRestarts(cond)
[09:30:09.924]                           for (restart in restarts) {
[09:30:09.924]                             name <- restart$name
[09:30:09.924]                             if (is.null(name)) 
[09:30:09.924]                               next
[09:30:09.924]                             if (!grepl(pattern, name)) 
[09:30:09.924]                               next
[09:30:09.924]                             invokeRestart(restart)
[09:30:09.924]                             muffled <- TRUE
[09:30:09.924]                             break
[09:30:09.924]                           }
[09:30:09.924]                         }
[09:30:09.924]                       }
[09:30:09.924]                       invisible(muffled)
[09:30:09.924]                     }
[09:30:09.924]                     muffleCondition(cond, pattern = "^muffle")
[09:30:09.924]                   }
[09:30:09.924]                 }
[09:30:09.924]                 else {
[09:30:09.924]                   if (TRUE) {
[09:30:09.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:09.924]                     {
[09:30:09.924]                       inherits <- base::inherits
[09:30:09.924]                       invokeRestart <- base::invokeRestart
[09:30:09.924]                       is.null <- base::is.null
[09:30:09.924]                       muffled <- FALSE
[09:30:09.924]                       if (inherits(cond, "message")) {
[09:30:09.924]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:09.924]                         if (muffled) 
[09:30:09.924]                           invokeRestart("muffleMessage")
[09:30:09.924]                       }
[09:30:09.924]                       else if (inherits(cond, "warning")) {
[09:30:09.924]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:09.924]                         if (muffled) 
[09:30:09.924]                           invokeRestart("muffleWarning")
[09:30:09.924]                       }
[09:30:09.924]                       else if (inherits(cond, "condition")) {
[09:30:09.924]                         if (!is.null(pattern)) {
[09:30:09.924]                           computeRestarts <- base::computeRestarts
[09:30:09.924]                           grepl <- base::grepl
[09:30:09.924]                           restarts <- computeRestarts(cond)
[09:30:09.924]                           for (restart in restarts) {
[09:30:09.924]                             name <- restart$name
[09:30:09.924]                             if (is.null(name)) 
[09:30:09.924]                               next
[09:30:09.924]                             if (!grepl(pattern, name)) 
[09:30:09.924]                               next
[09:30:09.924]                             invokeRestart(restart)
[09:30:09.924]                             muffled <- TRUE
[09:30:09.924]                             break
[09:30:09.924]                           }
[09:30:09.924]                         }
[09:30:09.924]                       }
[09:30:09.924]                       invisible(muffled)
[09:30:09.924]                     }
[09:30:09.924]                     muffleCondition(cond, pattern = "^muffle")
[09:30:09.924]                   }
[09:30:09.924]                 }
[09:30:09.924]             }
[09:30:09.924]         }))
[09:30:09.924]     }, error = function(ex) {
[09:30:09.924]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:09.924]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:09.924]                 ...future.rng), started = ...future.startTime, 
[09:30:09.924]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:09.924]             version = "1.8"), class = "FutureResult")
[09:30:09.924]     }, finally = {
[09:30:09.924]         if (!identical(...future.workdir, getwd())) 
[09:30:09.924]             setwd(...future.workdir)
[09:30:09.924]         {
[09:30:09.924]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:09.924]                 ...future.oldOptions$nwarnings <- NULL
[09:30:09.924]             }
[09:30:09.924]             base::options(...future.oldOptions)
[09:30:09.924]             if (.Platform$OS.type == "windows") {
[09:30:09.924]                 old_names <- names(...future.oldEnvVars)
[09:30:09.924]                 envs <- base::Sys.getenv()
[09:30:09.924]                 names <- names(envs)
[09:30:09.924]                 common <- intersect(names, old_names)
[09:30:09.924]                 added <- setdiff(names, old_names)
[09:30:09.924]                 removed <- setdiff(old_names, names)
[09:30:09.924]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:09.924]                   envs[common]]
[09:30:09.924]                 NAMES <- toupper(changed)
[09:30:09.924]                 args <- list()
[09:30:09.924]                 for (kk in seq_along(NAMES)) {
[09:30:09.924]                   name <- changed[[kk]]
[09:30:09.924]                   NAME <- NAMES[[kk]]
[09:30:09.924]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:09.924]                     next
[09:30:09.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:09.924]                 }
[09:30:09.924]                 NAMES <- toupper(added)
[09:30:09.924]                 for (kk in seq_along(NAMES)) {
[09:30:09.924]                   name <- added[[kk]]
[09:30:09.924]                   NAME <- NAMES[[kk]]
[09:30:09.924]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:09.924]                     next
[09:30:09.924]                   args[[name]] <- ""
[09:30:09.924]                 }
[09:30:09.924]                 NAMES <- toupper(removed)
[09:30:09.924]                 for (kk in seq_along(NAMES)) {
[09:30:09.924]                   name <- removed[[kk]]
[09:30:09.924]                   NAME <- NAMES[[kk]]
[09:30:09.924]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:09.924]                     next
[09:30:09.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:09.924]                 }
[09:30:09.924]                 if (length(args) > 0) 
[09:30:09.924]                   base::do.call(base::Sys.setenv, args = args)
[09:30:09.924]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:09.924]             }
[09:30:09.924]             else {
[09:30:09.924]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:09.924]             }
[09:30:09.924]             {
[09:30:09.924]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:09.924]                   0L) {
[09:30:09.924]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:09.924]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:09.924]                   base::options(opts)
[09:30:09.924]                 }
[09:30:09.924]                 {
[09:30:09.924]                   {
[09:30:09.924]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:09.924]                     NULL
[09:30:09.924]                   }
[09:30:09.924]                   options(future.plan = NULL)
[09:30:09.924]                   if (is.na(NA_character_)) 
[09:30:09.924]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:09.924]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:09.924]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:09.924]                     .init = FALSE)
[09:30:09.924]                 }
[09:30:09.924]             }
[09:30:09.924]         }
[09:30:09.924]     })
[09:30:09.924]     if (TRUE) {
[09:30:09.924]         base::sink(type = "output", split = FALSE)
[09:30:09.924]         if (TRUE) {
[09:30:09.924]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:09.924]         }
[09:30:09.924]         else {
[09:30:09.924]             ...future.result["stdout"] <- base::list(NULL)
[09:30:09.924]         }
[09:30:09.924]         base::close(...future.stdout)
[09:30:09.924]         ...future.stdout <- NULL
[09:30:09.924]     }
[09:30:09.924]     ...future.result$conditions <- ...future.conditions
[09:30:09.924]     ...future.result$finished <- base::Sys.time()
[09:30:09.924]     ...future.result
[09:30:09.924] }
[09:30:09.926] assign_globals() ...
[09:30:09.926] List of 5
[09:30:09.926]  $ ...future.FUN            :function (x)  
[09:30:09.926]  $ future.call.arguments    : list()
[09:30:09.926]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:09.926]  $ ...future.elements_ii    :List of 1
[09:30:09.926]   ..$ : int 0
[09:30:09.926]  $ ...future.seeds_ii       : NULL
[09:30:09.926]  $ ...future.globals.maxSize: NULL
[09:30:09.926]  - attr(*, "where")=List of 5
[09:30:09.926]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:09.926]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:30:09.926]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:09.926]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:09.926]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:09.926]  - attr(*, "resolved")= logi FALSE
[09:30:09.926]  - attr(*, "total_size")= num 4720
[09:30:09.926]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:09.926]  - attr(*, "already-done")= logi TRUE
[09:30:09.933] - reassign environment for ‘...future.FUN’
[09:30:09.933] - copied ‘...future.FUN’ to environment
[09:30:09.933] - copied ‘future.call.arguments’ to environment
[09:30:09.933] - copied ‘...future.elements_ii’ to environment
[09:30:09.933] - copied ‘...future.seeds_ii’ to environment
[09:30:09.933] - copied ‘...future.globals.maxSize’ to environment
[09:30:09.933] assign_globals() ... done
[09:30:09.934] requestCore(): workers = 2
[09:30:09.936] MulticoreFuture started
[09:30:09.936] - Launch lazy future ... done
[09:30:09.936] run() for ‘MulticoreFuture’ ... done
[09:30:09.937] Created future:
[09:30:09.937] plan(): Setting new future strategy stack:
[09:30:09.937] List of future strategies:
[09:30:09.937] 1. sequential:
[09:30:09.937]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:09.937]    - tweaked: FALSE
[09:30:09.937]    - call: NULL
[09:30:09.938] plan(): nbrOfWorkers() = 1
[09:30:09.940] plan(): Setting new future strategy stack:
[09:30:09.941] List of future strategies:
[09:30:09.941] 1. multicore:
[09:30:09.941]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:30:09.941]    - tweaked: FALSE
[09:30:09.941]    - call: plan(strategy)
[09:30:09.946] plan(): nbrOfWorkers() = 2
[09:30:09.937] MulticoreFuture:
[09:30:09.937] Label: ‘future_lapply-2’
[09:30:09.937] Expression:
[09:30:09.937] {
[09:30:09.937]     do.call(function(...) {
[09:30:09.937]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:09.937]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:09.937]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:09.937]             on.exit(options(oopts), add = TRUE)
[09:30:09.937]         }
[09:30:09.937]         {
[09:30:09.937]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:09.937]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:09.937]                 ...future.FUN(...future.X_jj, ...)
[09:30:09.937]             })
[09:30:09.937]         }
[09:30:09.937]     }, args = future.call.arguments)
[09:30:09.937] }
[09:30:09.937] Lazy evaluation: FALSE
[09:30:09.937] Asynchronous evaluation: TRUE
[09:30:09.937] Local evaluation: TRUE
[09:30:09.937] Environment: R_GlobalEnv
[09:30:09.937] Capture standard output: TRUE
[09:30:09.937] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:09.937] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:09.937] Packages: <none>
[09:30:09.937] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:09.937] Resolved: TRUE
[09:30:09.937] Value: <not collected>
[09:30:09.937] Conditions captured: <none>
[09:30:09.937] Early signaling: FALSE
[09:30:09.937] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:09.937] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:09.947] Chunk #2 of 2 ... DONE
[09:30:09.947] Launching 2 futures (chunks) ... DONE
[09:30:09.947] Resolving 2 futures (chunks) ...
[09:30:09.947] resolve() on list ...
[09:30:09.947]  recursive: 0
[09:30:09.947]  length: 2
[09:30:09.948] 
[09:30:09.958] Future #2
[09:30:09.959] result() for MulticoreFuture ...
[09:30:09.959] result() for MulticoreFuture ...
[09:30:09.960] result() for MulticoreFuture ... done
[09:30:09.960] result() for MulticoreFuture ... done
[09:30:09.960] result() for MulticoreFuture ...
[09:30:09.960] result() for MulticoreFuture ... done
[09:30:09.960] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:30:09.960] - nx: 2
[09:30:09.961] - relay: TRUE
[09:30:09.961] - stdout: TRUE
[09:30:09.961] - signal: TRUE
[09:30:09.961] - resignal: FALSE
[09:30:09.961] - force: TRUE
[09:30:09.961] - relayed: [n=2] FALSE, FALSE
[09:30:09.961] - queued futures: [n=2] FALSE, FALSE
[09:30:09.962]  - until=1
[09:30:09.962]  - relaying element #1
[09:30:09.962] - relayed: [n=2] FALSE, FALSE
[09:30:09.962] - queued futures: [n=2] FALSE, TRUE
[09:30:09.962] signalConditionsASAP(NULL, pos=2) ... done
[09:30:09.962]  length: 1 (resolved future 2)
[09:30:10.392] plan(): Setting new future strategy stack:
[09:30:10.393] List of future strategies:
[09:30:10.393] 1. multicore:
[09:30:10.393]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:30:10.393]    - tweaked: FALSE
[09:30:10.393]    - call: plan(strategy)
[09:30:10.397] plan(): nbrOfWorkers() = 2
[09:30:10.401] Future #1
[09:30:10.401] result() for MulticoreFuture ...
[09:30:10.402] result() for MulticoreFuture ...
[09:30:10.402] result() for MulticoreFuture ... done
[09:30:10.402] result() for MulticoreFuture ... done
[09:30:10.402] result() for MulticoreFuture ...
[09:30:10.402] result() for MulticoreFuture ... done
[09:30:10.402] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:30:10.403] - nx: 2
[09:30:10.403] - relay: TRUE
[09:30:10.403] - stdout: TRUE
[09:30:10.403] - signal: TRUE
[09:30:10.403] - resignal: FALSE
[09:30:10.403] - force: TRUE
[09:30:10.403] - relayed: [n=2] FALSE, FALSE
[09:30:10.403] - queued futures: [n=2] FALSE, TRUE
[09:30:10.403]  - until=1
[09:30:10.404]  - relaying element #1
[09:30:10.404] result() for MulticoreFuture ...
[09:30:10.404] result() for MulticoreFuture ... done
[09:30:10.404] result() for MulticoreFuture ...
[09:30:10.404] result() for MulticoreFuture ... done
[09:30:10.404] result() for MulticoreFuture ...
[09:30:10.404] result() for MulticoreFuture ... done
[09:30:10.404] result() for MulticoreFuture ...
[09:30:10.404] result() for MulticoreFuture ... done
[09:30:10.405] - relayed: [n=2] TRUE, FALSE
[09:30:10.405] - queued futures: [n=2] TRUE, TRUE
[09:30:10.405] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:30:10.405]  length: 0 (resolved future 1)
[09:30:10.405] Relaying remaining futures
[09:30:10.405] signalConditionsASAP(NULL, pos=0) ...
[09:30:10.405] - nx: 2
[09:30:10.405] - relay: TRUE
[09:30:10.405] - stdout: TRUE
[09:30:10.406] - signal: TRUE
[09:30:10.406] - resignal: FALSE
[09:30:10.406] - force: TRUE
[09:30:10.406] - relayed: [n=2] TRUE, FALSE
[09:30:10.406] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:30:10.406]  - relaying element #2
[09:30:10.406] result() for MulticoreFuture ...
[09:30:10.406] result() for MulticoreFuture ... done
[09:30:10.407] result() for MulticoreFuture ...
[09:30:10.407] result() for MulticoreFuture ... done
[09:30:10.409] result() for MulticoreFuture ...
[09:30:10.409] result() for MulticoreFuture ... done
[09:30:10.410] result() for MulticoreFuture ...
[09:30:10.410] result() for MulticoreFuture ... done
[09:30:10.410] - relayed: [n=2] TRUE, TRUE
[09:30:10.410] - queued futures: [n=2] TRUE, TRUE
[09:30:10.410] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[09:30:10.410] resolve() on list ... DONE
[09:30:10.411] result() for MulticoreFuture ...
[09:30:10.411] result() for MulticoreFuture ... done
[09:30:10.411] result() for MulticoreFuture ...
[09:30:10.411] result() for MulticoreFuture ... done
[09:30:10.411] result() for MulticoreFuture ...
[09:30:10.411] result() for MulticoreFuture ... done
[09:30:10.411] result() for MulticoreFuture ...
[09:30:10.412] result() for MulticoreFuture ... done
[09:30:10.412]  - Number of value chunks collected: 2
[09:30:10.412] Resolving 2 futures (chunks) ... DONE
[09:30:10.412] Reducing values from 2 chunks ...
[09:30:10.412]  - Number of values collected after concatenation: 2
[09:30:10.412]  - Number of values expected: 2
[09:30:10.412] Reducing values from 2 chunks ... DONE
[09:30:10.413] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[09:30:10.413] future_lapply() ...
[09:30:10.418] Number of chunks: 2
[09:30:10.418] getGlobalsAndPackagesXApply() ...
[09:30:10.418]  - future.globals: TRUE
[09:30:10.418] getGlobalsAndPackages() ...
[09:30:10.418] Searching for globals...
[09:30:10.420] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[09:30:10.420] Searching for globals ... DONE
[09:30:10.420] Resolving globals: FALSE
[09:30:10.421] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[09:30:10.421] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[09:30:10.421] - globals: [1] ‘FUN’
[09:30:10.421] 
[09:30:10.422] getGlobalsAndPackages() ... DONE
[09:30:10.422]  - globals found/used: [n=1] ‘FUN’
[09:30:10.422]  - needed namespaces: [n=0] 
[09:30:10.422] Finding globals ... DONE
[09:30:10.422]  - use_args: TRUE
[09:30:10.422]  - Getting '...' globals ...
[09:30:10.422] resolve() on list ...
[09:30:10.423]  recursive: 0
[09:30:10.423]  length: 1
[09:30:10.423]  elements: ‘...’
[09:30:10.423]  length: 0 (resolved future 1)
[09:30:10.423] resolve() on list ... DONE
[09:30:10.423]    - '...' content: [n=0] 
[09:30:10.423] List of 1
[09:30:10.423]  $ ...: list()
[09:30:10.423]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:10.423]  - attr(*, "where")=List of 1
[09:30:10.423]   ..$ ...:<environment: 0x55c102eeec88> 
[09:30:10.423]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:10.423]  - attr(*, "resolved")= logi TRUE
[09:30:10.423]  - attr(*, "total_size")= num NA
[09:30:10.426]  - Getting '...' globals ... DONE
[09:30:10.426] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:30:10.426] List of 2
[09:30:10.426]  $ ...future.FUN:function (x)  
[09:30:10.426]  $ ...          : list()
[09:30:10.426]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:10.426]  - attr(*, "where")=List of 2
[09:30:10.426]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:10.426]   ..$ ...          :<environment: 0x55c102eeec88> 
[09:30:10.426]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:10.426]  - attr(*, "resolved")= logi FALSE
[09:30:10.426]  - attr(*, "total_size")= num 4720
[09:30:10.429] Packages to be attached in all futures: [n=0] 
[09:30:10.429] getGlobalsAndPackagesXApply() ... DONE
[09:30:10.429] Number of futures (= number of chunks): 2
[09:30:10.429] Launching 2 futures (chunks) ...
[09:30:10.430] Chunk #1 of 2 ...
[09:30:10.430]  - Finding globals in 'X' for chunk #1 ...
[09:30:10.430] getGlobalsAndPackages() ...
[09:30:10.430] Searching for globals...
[09:30:10.430] 
[09:30:10.430] Searching for globals ... DONE
[09:30:10.430] - globals: [0] <none>
[09:30:10.430] getGlobalsAndPackages() ... DONE
[09:30:10.430]    + additional globals found: [n=0] 
[09:30:10.431]    + additional namespaces needed: [n=0] 
[09:30:10.431]  - Finding globals in 'X' for chunk #1 ... DONE
[09:30:10.431]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:10.431]  - seeds: <none>
[09:30:10.431]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:10.431] getGlobalsAndPackages() ...
[09:30:10.431] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:10.431] Resolving globals: FALSE
[09:30:10.431] Tweak future expression to call with '...' arguments ...
[09:30:10.431] {
[09:30:10.431]     do.call(function(...) {
[09:30:10.431]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:10.431]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:10.431]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:10.431]             on.exit(options(oopts), add = TRUE)
[09:30:10.431]         }
[09:30:10.431]         {
[09:30:10.431]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:10.431]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:10.431]                 ...future.FUN(...future.X_jj, ...)
[09:30:10.431]             })
[09:30:10.431]         }
[09:30:10.431]     }, args = future.call.arguments)
[09:30:10.431] }
[09:30:10.432] Tweak future expression to call with '...' arguments ... DONE
[09:30:10.432] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:10.432] 
[09:30:10.432] getGlobalsAndPackages() ... DONE
[09:30:10.433] run() for ‘Future’ ...
[09:30:10.433] - state: ‘created’
[09:30:10.433] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:30:10.436] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:10.436] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:30:10.437]   - Field: ‘label’
[09:30:10.437]   - Field: ‘local’
[09:30:10.437]   - Field: ‘owner’
[09:30:10.437]   - Field: ‘envir’
[09:30:10.437]   - Field: ‘workers’
[09:30:10.437]   - Field: ‘packages’
[09:30:10.437]   - Field: ‘gc’
[09:30:10.437]   - Field: ‘job’
[09:30:10.437]   - Field: ‘conditions’
[09:30:10.437]   - Field: ‘expr’
[09:30:10.437]   - Field: ‘uuid’
[09:30:10.438]   - Field: ‘seed’
[09:30:10.438]   - Field: ‘version’
[09:30:10.438]   - Field: ‘result’
[09:30:10.438]   - Field: ‘asynchronous’
[09:30:10.438]   - Field: ‘calls’
[09:30:10.438]   - Field: ‘globals’
[09:30:10.438]   - Field: ‘stdout’
[09:30:10.438]   - Field: ‘earlySignal’
[09:30:10.438]   - Field: ‘lazy’
[09:30:10.438]   - Field: ‘state’
[09:30:10.438] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:30:10.439] - Launch lazy future ...
[09:30:10.440] Packages needed by the future expression (n = 0): <none>
[09:30:10.440] Packages needed by future strategies (n = 0): <none>
[09:30:10.441] {
[09:30:10.441]     {
[09:30:10.441]         {
[09:30:10.441]             ...future.startTime <- base::Sys.time()
[09:30:10.441]             {
[09:30:10.441]                 {
[09:30:10.441]                   {
[09:30:10.441]                     {
[09:30:10.441]                       base::local({
[09:30:10.441]                         has_future <- base::requireNamespace("future", 
[09:30:10.441]                           quietly = TRUE)
[09:30:10.441]                         if (has_future) {
[09:30:10.441]                           ns <- base::getNamespace("future")
[09:30:10.441]                           version <- ns[[".package"]][["version"]]
[09:30:10.441]                           if (is.null(version)) 
[09:30:10.441]                             version <- utils::packageVersion("future")
[09:30:10.441]                         }
[09:30:10.441]                         else {
[09:30:10.441]                           version <- NULL
[09:30:10.441]                         }
[09:30:10.441]                         if (!has_future || version < "1.8.0") {
[09:30:10.441]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:10.441]                             "", base::R.version$version.string), 
[09:30:10.441]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:10.441]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:10.441]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:10.441]                               "release", "version")], collapse = " "), 
[09:30:10.441]                             hostname = base::Sys.info()[["nodename"]])
[09:30:10.441]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:10.441]                             info)
[09:30:10.441]                           info <- base::paste(info, collapse = "; ")
[09:30:10.441]                           if (!has_future) {
[09:30:10.441]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:10.441]                               info)
[09:30:10.441]                           }
[09:30:10.441]                           else {
[09:30:10.441]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:10.441]                               info, version)
[09:30:10.441]                           }
[09:30:10.441]                           base::stop(msg)
[09:30:10.441]                         }
[09:30:10.441]                       })
[09:30:10.441]                     }
[09:30:10.441]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:10.441]                     base::options(mc.cores = 1L)
[09:30:10.441]                   }
[09:30:10.441]                   ...future.strategy.old <- future::plan("list")
[09:30:10.441]                   options(future.plan = NULL)
[09:30:10.441]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:10.441]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:10.441]                 }
[09:30:10.441]                 ...future.workdir <- getwd()
[09:30:10.441]             }
[09:30:10.441]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:10.441]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:10.441]         }
[09:30:10.441]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:10.441]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:10.441]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:10.441]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:10.441]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:10.441]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:10.441]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:10.441]             base::names(...future.oldOptions))
[09:30:10.441]     }
[09:30:10.441]     if (TRUE) {
[09:30:10.441]     }
[09:30:10.441]     else {
[09:30:10.441]         if (NA) {
[09:30:10.441]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:10.441]                 open = "w")
[09:30:10.441]         }
[09:30:10.441]         else {
[09:30:10.441]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:10.441]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:10.441]         }
[09:30:10.441]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:10.441]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:10.441]             base::sink(type = "output", split = FALSE)
[09:30:10.441]             base::close(...future.stdout)
[09:30:10.441]         }, add = TRUE)
[09:30:10.441]     }
[09:30:10.441]     ...future.frame <- base::sys.nframe()
[09:30:10.441]     ...future.conditions <- base::list()
[09:30:10.441]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:10.441]     if (FALSE) {
[09:30:10.441]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:10.441]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:10.441]     }
[09:30:10.441]     ...future.result <- base::tryCatch({
[09:30:10.441]         base::withCallingHandlers({
[09:30:10.441]             ...future.value <- base::withVisible(base::local({
[09:30:10.441]                 withCallingHandlers({
[09:30:10.441]                   {
[09:30:10.441]                     do.call(function(...) {
[09:30:10.441]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:10.441]                       if (!identical(...future.globals.maxSize.org, 
[09:30:10.441]                         ...future.globals.maxSize)) {
[09:30:10.441]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:10.441]                         on.exit(options(oopts), add = TRUE)
[09:30:10.441]                       }
[09:30:10.441]                       {
[09:30:10.441]                         lapply(seq_along(...future.elements_ii), 
[09:30:10.441]                           FUN = function(jj) {
[09:30:10.441]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:10.441]                             ...future.FUN(...future.X_jj, ...)
[09:30:10.441]                           })
[09:30:10.441]                       }
[09:30:10.441]                     }, args = future.call.arguments)
[09:30:10.441]                   }
[09:30:10.441]                 }, immediateCondition = function(cond) {
[09:30:10.441]                   save_rds <- function (object, pathname, ...) 
[09:30:10.441]                   {
[09:30:10.441]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:30:10.441]                     if (file_test("-f", pathname_tmp)) {
[09:30:10.441]                       fi_tmp <- file.info(pathname_tmp)
[09:30:10.441]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:30:10.441]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:10.441]                         fi_tmp[["mtime"]])
[09:30:10.441]                     }
[09:30:10.441]                     tryCatch({
[09:30:10.441]                       saveRDS(object, file = pathname_tmp, ...)
[09:30:10.441]                     }, error = function(ex) {
[09:30:10.441]                       msg <- conditionMessage(ex)
[09:30:10.441]                       fi_tmp <- file.info(pathname_tmp)
[09:30:10.441]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:30:10.441]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:10.441]                         fi_tmp[["mtime"]], msg)
[09:30:10.441]                       ex$message <- msg
[09:30:10.441]                       stop(ex)
[09:30:10.441]                     })
[09:30:10.441]                     stopifnot(file_test("-f", pathname_tmp))
[09:30:10.441]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:30:10.441]                     if (!res || file_test("-f", pathname_tmp)) {
[09:30:10.441]                       fi_tmp <- file.info(pathname_tmp)
[09:30:10.441]                       fi <- file.info(pathname)
[09:30:10.441]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:30:10.441]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:10.441]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:30:10.441]                         fi[["size"]], fi[["mtime"]])
[09:30:10.441]                       stop(msg)
[09:30:10.441]                     }
[09:30:10.441]                     invisible(pathname)
[09:30:10.441]                   }
[09:30:10.441]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:30:10.441]                     rootPath = tempdir()) 
[09:30:10.441]                   {
[09:30:10.441]                     obj <- list(time = Sys.time(), condition = cond)
[09:30:10.441]                     file <- tempfile(pattern = class(cond)[1], 
[09:30:10.441]                       tmpdir = path, fileext = ".rds")
[09:30:10.441]                     save_rds(obj, file)
[09:30:10.441]                   }
[09:30:10.441]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0coFNd/.future/immediateConditions")
[09:30:10.441]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:10.441]                   {
[09:30:10.441]                     inherits <- base::inherits
[09:30:10.441]                     invokeRestart <- base::invokeRestart
[09:30:10.441]                     is.null <- base::is.null
[09:30:10.441]                     muffled <- FALSE
[09:30:10.441]                     if (inherits(cond, "message")) {
[09:30:10.441]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:10.441]                       if (muffled) 
[09:30:10.441]                         invokeRestart("muffleMessage")
[09:30:10.441]                     }
[09:30:10.441]                     else if (inherits(cond, "warning")) {
[09:30:10.441]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:10.441]                       if (muffled) 
[09:30:10.441]                         invokeRestart("muffleWarning")
[09:30:10.441]                     }
[09:30:10.441]                     else if (inherits(cond, "condition")) {
[09:30:10.441]                       if (!is.null(pattern)) {
[09:30:10.441]                         computeRestarts <- base::computeRestarts
[09:30:10.441]                         grepl <- base::grepl
[09:30:10.441]                         restarts <- computeRestarts(cond)
[09:30:10.441]                         for (restart in restarts) {
[09:30:10.441]                           name <- restart$name
[09:30:10.441]                           if (is.null(name)) 
[09:30:10.441]                             next
[09:30:10.441]                           if (!grepl(pattern, name)) 
[09:30:10.441]                             next
[09:30:10.441]                           invokeRestart(restart)
[09:30:10.441]                           muffled <- TRUE
[09:30:10.441]                           break
[09:30:10.441]                         }
[09:30:10.441]                       }
[09:30:10.441]                     }
[09:30:10.441]                     invisible(muffled)
[09:30:10.441]                   }
[09:30:10.441]                   muffleCondition(cond)
[09:30:10.441]                 })
[09:30:10.441]             }))
[09:30:10.441]             future::FutureResult(value = ...future.value$value, 
[09:30:10.441]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:10.441]                   ...future.rng), globalenv = if (FALSE) 
[09:30:10.441]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:10.441]                     ...future.globalenv.names))
[09:30:10.441]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:10.441]         }, condition = base::local({
[09:30:10.441]             c <- base::c
[09:30:10.441]             inherits <- base::inherits
[09:30:10.441]             invokeRestart <- base::invokeRestart
[09:30:10.441]             length <- base::length
[09:30:10.441]             list <- base::list
[09:30:10.441]             seq.int <- base::seq.int
[09:30:10.441]             signalCondition <- base::signalCondition
[09:30:10.441]             sys.calls <- base::sys.calls
[09:30:10.441]             `[[` <- base::`[[`
[09:30:10.441]             `+` <- base::`+`
[09:30:10.441]             `<<-` <- base::`<<-`
[09:30:10.441]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:10.441]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:10.441]                   3L)]
[09:30:10.441]             }
[09:30:10.441]             function(cond) {
[09:30:10.441]                 is_error <- inherits(cond, "error")
[09:30:10.441]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:10.441]                   NULL)
[09:30:10.441]                 if (is_error) {
[09:30:10.441]                   sessionInformation <- function() {
[09:30:10.441]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:10.441]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:10.441]                       search = base::search(), system = base::Sys.info())
[09:30:10.441]                   }
[09:30:10.441]                   ...future.conditions[[length(...future.conditions) + 
[09:30:10.441]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:10.441]                     cond$call), session = sessionInformation(), 
[09:30:10.441]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:10.441]                   signalCondition(cond)
[09:30:10.441]                 }
[09:30:10.441]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:10.441]                 "immediateCondition"))) {
[09:30:10.441]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:10.441]                   ...future.conditions[[length(...future.conditions) + 
[09:30:10.441]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:10.441]                   if (TRUE && !signal) {
[09:30:10.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:10.441]                     {
[09:30:10.441]                       inherits <- base::inherits
[09:30:10.441]                       invokeRestart <- base::invokeRestart
[09:30:10.441]                       is.null <- base::is.null
[09:30:10.441]                       muffled <- FALSE
[09:30:10.441]                       if (inherits(cond, "message")) {
[09:30:10.441]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:10.441]                         if (muffled) 
[09:30:10.441]                           invokeRestart("muffleMessage")
[09:30:10.441]                       }
[09:30:10.441]                       else if (inherits(cond, "warning")) {
[09:30:10.441]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:10.441]                         if (muffled) 
[09:30:10.441]                           invokeRestart("muffleWarning")
[09:30:10.441]                       }
[09:30:10.441]                       else if (inherits(cond, "condition")) {
[09:30:10.441]                         if (!is.null(pattern)) {
[09:30:10.441]                           computeRestarts <- base::computeRestarts
[09:30:10.441]                           grepl <- base::grepl
[09:30:10.441]                           restarts <- computeRestarts(cond)
[09:30:10.441]                           for (restart in restarts) {
[09:30:10.441]                             name <- restart$name
[09:30:10.441]                             if (is.null(name)) 
[09:30:10.441]                               next
[09:30:10.441]                             if (!grepl(pattern, name)) 
[09:30:10.441]                               next
[09:30:10.441]                             invokeRestart(restart)
[09:30:10.441]                             muffled <- TRUE
[09:30:10.441]                             break
[09:30:10.441]                           }
[09:30:10.441]                         }
[09:30:10.441]                       }
[09:30:10.441]                       invisible(muffled)
[09:30:10.441]                     }
[09:30:10.441]                     muffleCondition(cond, pattern = "^muffle")
[09:30:10.441]                   }
[09:30:10.441]                 }
[09:30:10.441]                 else {
[09:30:10.441]                   if (TRUE) {
[09:30:10.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:10.441]                     {
[09:30:10.441]                       inherits <- base::inherits
[09:30:10.441]                       invokeRestart <- base::invokeRestart
[09:30:10.441]                       is.null <- base::is.null
[09:30:10.441]                       muffled <- FALSE
[09:30:10.441]                       if (inherits(cond, "message")) {
[09:30:10.441]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:10.441]                         if (muffled) 
[09:30:10.441]                           invokeRestart("muffleMessage")
[09:30:10.441]                       }
[09:30:10.441]                       else if (inherits(cond, "warning")) {
[09:30:10.441]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:10.441]                         if (muffled) 
[09:30:10.441]                           invokeRestart("muffleWarning")
[09:30:10.441]                       }
[09:30:10.441]                       else if (inherits(cond, "condition")) {
[09:30:10.441]                         if (!is.null(pattern)) {
[09:30:10.441]                           computeRestarts <- base::computeRestarts
[09:30:10.441]                           grepl <- base::grepl
[09:30:10.441]                           restarts <- computeRestarts(cond)
[09:30:10.441]                           for (restart in restarts) {
[09:30:10.441]                             name <- restart$name
[09:30:10.441]                             if (is.null(name)) 
[09:30:10.441]                               next
[09:30:10.441]                             if (!grepl(pattern, name)) 
[09:30:10.441]                               next
[09:30:10.441]                             invokeRestart(restart)
[09:30:10.441]                             muffled <- TRUE
[09:30:10.441]                             break
[09:30:10.441]                           }
[09:30:10.441]                         }
[09:30:10.441]                       }
[09:30:10.441]                       invisible(muffled)
[09:30:10.441]                     }
[09:30:10.441]                     muffleCondition(cond, pattern = "^muffle")
[09:30:10.441]                   }
[09:30:10.441]                 }
[09:30:10.441]             }
[09:30:10.441]         }))
[09:30:10.441]     }, error = function(ex) {
[09:30:10.441]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:10.441]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:10.441]                 ...future.rng), started = ...future.startTime, 
[09:30:10.441]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:10.441]             version = "1.8"), class = "FutureResult")
[09:30:10.441]     }, finally = {
[09:30:10.441]         if (!identical(...future.workdir, getwd())) 
[09:30:10.441]             setwd(...future.workdir)
[09:30:10.441]         {
[09:30:10.441]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:10.441]                 ...future.oldOptions$nwarnings <- NULL
[09:30:10.441]             }
[09:30:10.441]             base::options(...future.oldOptions)
[09:30:10.441]             if (.Platform$OS.type == "windows") {
[09:30:10.441]                 old_names <- names(...future.oldEnvVars)
[09:30:10.441]                 envs <- base::Sys.getenv()
[09:30:10.441]                 names <- names(envs)
[09:30:10.441]                 common <- intersect(names, old_names)
[09:30:10.441]                 added <- setdiff(names, old_names)
[09:30:10.441]                 removed <- setdiff(old_names, names)
[09:30:10.441]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:10.441]                   envs[common]]
[09:30:10.441]                 NAMES <- toupper(changed)
[09:30:10.441]                 args <- list()
[09:30:10.441]                 for (kk in seq_along(NAMES)) {
[09:30:10.441]                   name <- changed[[kk]]
[09:30:10.441]                   NAME <- NAMES[[kk]]
[09:30:10.441]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:10.441]                     next
[09:30:10.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:10.441]                 }
[09:30:10.441]                 NAMES <- toupper(added)
[09:30:10.441]                 for (kk in seq_along(NAMES)) {
[09:30:10.441]                   name <- added[[kk]]
[09:30:10.441]                   NAME <- NAMES[[kk]]
[09:30:10.441]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:10.441]                     next
[09:30:10.441]                   args[[name]] <- ""
[09:30:10.441]                 }
[09:30:10.441]                 NAMES <- toupper(removed)
[09:30:10.441]                 for (kk in seq_along(NAMES)) {
[09:30:10.441]                   name <- removed[[kk]]
[09:30:10.441]                   NAME <- NAMES[[kk]]
[09:30:10.441]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:10.441]                     next
[09:30:10.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:10.441]                 }
[09:30:10.441]                 if (length(args) > 0) 
[09:30:10.441]                   base::do.call(base::Sys.setenv, args = args)
[09:30:10.441]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:10.441]             }
[09:30:10.441]             else {
[09:30:10.441]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:10.441]             }
[09:30:10.441]             {
[09:30:10.441]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:10.441]                   0L) {
[09:30:10.441]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:10.441]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:10.441]                   base::options(opts)
[09:30:10.441]                 }
[09:30:10.441]                 {
[09:30:10.441]                   {
[09:30:10.441]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:10.441]                     NULL
[09:30:10.441]                   }
[09:30:10.441]                   options(future.plan = NULL)
[09:30:10.441]                   if (is.na(NA_character_)) 
[09:30:10.441]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:10.441]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:10.441]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:10.441]                     .init = FALSE)
[09:30:10.441]                 }
[09:30:10.441]             }
[09:30:10.441]         }
[09:30:10.441]     })
[09:30:10.441]     if (FALSE) {
[09:30:10.441]         base::sink(type = "output", split = FALSE)
[09:30:10.441]         if (NA) {
[09:30:10.441]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:10.441]         }
[09:30:10.441]         else {
[09:30:10.441]             ...future.result["stdout"] <- base::list(NULL)
[09:30:10.441]         }
[09:30:10.441]         base::close(...future.stdout)
[09:30:10.441]         ...future.stdout <- NULL
[09:30:10.441]     }
[09:30:10.441]     ...future.result$conditions <- ...future.conditions
[09:30:10.441]     ...future.result$finished <- base::Sys.time()
[09:30:10.441]     ...future.result
[09:30:10.441] }
[09:30:10.443] assign_globals() ...
[09:30:10.443] List of 5
[09:30:10.443]  $ ...future.FUN            :function (x)  
[09:30:10.443]  $ future.call.arguments    : list()
[09:30:10.443]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:10.443]  $ ...future.elements_ii    :List of 1
[09:30:10.443]   ..$ : int 1
[09:30:10.443]  $ ...future.seeds_ii       : NULL
[09:30:10.443]  $ ...future.globals.maxSize: NULL
[09:30:10.443]  - attr(*, "where")=List of 5
[09:30:10.443]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:10.443]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:30:10.443]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:10.443]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:10.443]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:10.443]  - attr(*, "resolved")= logi FALSE
[09:30:10.443]  - attr(*, "total_size")= num 4720
[09:30:10.443]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:10.443]  - attr(*, "already-done")= logi TRUE
[09:30:10.447] - reassign environment for ‘...future.FUN’
[09:30:10.448] - copied ‘...future.FUN’ to environment
[09:30:10.448] - copied ‘future.call.arguments’ to environment
[09:30:10.448] - copied ‘...future.elements_ii’ to environment
[09:30:10.448] - copied ‘...future.seeds_ii’ to environment
[09:30:10.448] - copied ‘...future.globals.maxSize’ to environment
[09:30:10.448] assign_globals() ... done
[09:30:10.448] requestCore(): workers = 2
[09:30:10.450] MulticoreFuture started
[09:30:10.450] - Launch lazy future ... done
[09:30:10.451] run() for ‘MulticoreFuture’ ... done
[09:30:10.451] Created future:
[09:30:10.451] plan(): Setting new future strategy stack:
[09:30:10.451] List of future strategies:
[09:30:10.451] 1. sequential:
[09:30:10.451]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:10.451]    - tweaked: FALSE
[09:30:10.451]    - call: NULL
[09:30:10.452] plan(): nbrOfWorkers() = 1
[09:30:10.451] MulticoreFuture:
[09:30:10.451] Label: ‘future_lapply-1’
[09:30:10.451] Expression:
[09:30:10.451] {
[09:30:10.451]     do.call(function(...) {
[09:30:10.451]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:10.451]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:10.451]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:10.451]             on.exit(options(oopts), add = TRUE)
[09:30:10.451]         }
[09:30:10.451]         {
[09:30:10.451]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:10.451]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:10.451]                 ...future.FUN(...future.X_jj, ...)
[09:30:10.451]             })
[09:30:10.451]         }
[09:30:10.451]     }, args = future.call.arguments)
[09:30:10.451] }
[09:30:10.451] Lazy evaluation: FALSE
[09:30:10.451] Asynchronous evaluation: TRUE
[09:30:10.451] Local evaluation: TRUE
[09:30:10.451] Environment: R_GlobalEnv
[09:30:10.451] Capture standard output: NA
[09:30:10.451] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:10.451] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:10.451] Packages: <none>
[09:30:10.451] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:10.451] Resolved: FALSE
[09:30:10.451] Value: <not collected>
[09:30:10.451] Conditions captured: <none>
[09:30:10.451] Early signaling: FALSE
[09:30:10.451] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:10.451] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:10.464] Chunk #1 of 2 ... DONE
[09:30:10.464] Chunk #2 of 2 ...
[09:30:10.465]  - Finding globals in 'X' for chunk #2 ...
[09:30:10.465] getGlobalsAndPackages() ...
[09:30:10.465] Searching for globals...
[09:30:10.466] 
[09:30:10.466] Searching for globals ... DONE
[09:30:10.466] - globals: [0] <none>
[09:30:10.466] getGlobalsAndPackages() ... DONE
[09:30:10.466]    + additional globals found: [n=0] 
[09:30:10.466]    + additional namespaces needed: [n=0] 
[09:30:10.467]  - Finding globals in 'X' for chunk #2 ... DONE
[09:30:10.467]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:10.467]  - seeds: <none>
[09:30:10.467]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:10.467] getGlobalsAndPackages() ...
[09:30:10.467] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:10.467] Resolving globals: FALSE
[09:30:10.468] Tweak future expression to call with '...' arguments ...
[09:30:10.468] {
[09:30:10.468]     do.call(function(...) {
[09:30:10.468]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:10.468]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:10.468]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:10.468]             on.exit(options(oopts), add = TRUE)
[09:30:10.468]         }
[09:30:10.468]         {
[09:30:10.468]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:10.468]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:10.468]                 ...future.FUN(...future.X_jj, ...)
[09:30:10.468]             })
[09:30:10.468]         }
[09:30:10.468]     }, args = future.call.arguments)
[09:30:10.468] }
[09:30:10.468] Tweak future expression to call with '...' arguments ... DONE
[09:30:10.469] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:10.469] 
[09:30:10.469] getGlobalsAndPackages() ... DONE
[09:30:10.470] run() for ‘Future’ ...
[09:30:10.470] - state: ‘created’
[09:30:10.470] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:30:10.475] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:10.475] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:30:10.476]   - Field: ‘label’
[09:30:10.476]   - Field: ‘local’
[09:30:10.476]   - Field: ‘owner’
[09:30:10.476]   - Field: ‘envir’
[09:30:10.476]   - Field: ‘workers’
[09:30:10.476]   - Field: ‘packages’
[09:30:10.476]   - Field: ‘gc’
[09:30:10.477]   - Field: ‘job’
[09:30:10.477]   - Field: ‘conditions’
[09:30:10.477]   - Field: ‘expr’
[09:30:10.477]   - Field: ‘uuid’
[09:30:10.477]   - Field: ‘seed’
[09:30:10.477]   - Field: ‘version’
[09:30:10.478]   - Field: ‘result’
[09:30:10.478]   - Field: ‘asynchronous’
[09:30:10.478]   - Field: ‘calls’
[09:30:10.478]   - Field: ‘globals’
[09:30:10.478]   - Field: ‘stdout’
[09:30:10.478]   - Field: ‘earlySignal’
[09:30:10.478]   - Field: ‘lazy’
[09:30:10.479]   - Field: ‘state’
[09:30:10.479] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:30:10.479] - Launch lazy future ...
[09:30:10.479] Packages needed by the future expression (n = 0): <none>
[09:30:10.480] Packages needed by future strategies (n = 0): <none>
[09:30:10.480] {
[09:30:10.480]     {
[09:30:10.480]         {
[09:30:10.480]             ...future.startTime <- base::Sys.time()
[09:30:10.480]             {
[09:30:10.480]                 {
[09:30:10.480]                   {
[09:30:10.480]                     {
[09:30:10.480]                       base::local({
[09:30:10.480]                         has_future <- base::requireNamespace("future", 
[09:30:10.480]                           quietly = TRUE)
[09:30:10.480]                         if (has_future) {
[09:30:10.480]                           ns <- base::getNamespace("future")
[09:30:10.480]                           version <- ns[[".package"]][["version"]]
[09:30:10.480]                           if (is.null(version)) 
[09:30:10.480]                             version <- utils::packageVersion("future")
[09:30:10.480]                         }
[09:30:10.480]                         else {
[09:30:10.480]                           version <- NULL
[09:30:10.480]                         }
[09:30:10.480]                         if (!has_future || version < "1.8.0") {
[09:30:10.480]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:10.480]                             "", base::R.version$version.string), 
[09:30:10.480]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:10.480]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:10.480]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:10.480]                               "release", "version")], collapse = " "), 
[09:30:10.480]                             hostname = base::Sys.info()[["nodename"]])
[09:30:10.480]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:10.480]                             info)
[09:30:10.480]                           info <- base::paste(info, collapse = "; ")
[09:30:10.480]                           if (!has_future) {
[09:30:10.480]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:10.480]                               info)
[09:30:10.480]                           }
[09:30:10.480]                           else {
[09:30:10.480]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:10.480]                               info, version)
[09:30:10.480]                           }
[09:30:10.480]                           base::stop(msg)
[09:30:10.480]                         }
[09:30:10.480]                       })
[09:30:10.480]                     }
[09:30:10.480]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:10.480]                     base::options(mc.cores = 1L)
[09:30:10.480]                   }
[09:30:10.480]                   ...future.strategy.old <- future::plan("list")
[09:30:10.480]                   options(future.plan = NULL)
[09:30:10.480]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:10.480]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:10.480]                 }
[09:30:10.480]                 ...future.workdir <- getwd()
[09:30:10.480]             }
[09:30:10.480]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:10.480]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:10.480]         }
[09:30:10.480]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:10.480]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:10.480]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:10.480]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:10.480]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:10.480]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:10.480]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:10.480]             base::names(...future.oldOptions))
[09:30:10.480]     }
[09:30:10.480]     if (TRUE) {
[09:30:10.480]     }
[09:30:10.480]     else {
[09:30:10.480]         if (NA) {
[09:30:10.480]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:10.480]                 open = "w")
[09:30:10.480]         }
[09:30:10.480]         else {
[09:30:10.480]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:10.480]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:10.480]         }
[09:30:10.480]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:10.480]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:10.480]             base::sink(type = "output", split = FALSE)
[09:30:10.480]             base::close(...future.stdout)
[09:30:10.480]         }, add = TRUE)
[09:30:10.480]     }
[09:30:10.480]     ...future.frame <- base::sys.nframe()
[09:30:10.480]     ...future.conditions <- base::list()
[09:30:10.480]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:10.480]     if (FALSE) {
[09:30:10.480]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:10.480]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:10.480]     }
[09:30:10.480]     ...future.result <- base::tryCatch({
[09:30:10.480]         base::withCallingHandlers({
[09:30:10.480]             ...future.value <- base::withVisible(base::local({
[09:30:10.480]                 withCallingHandlers({
[09:30:10.480]                   {
[09:30:10.480]                     do.call(function(...) {
[09:30:10.480]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:10.480]                       if (!identical(...future.globals.maxSize.org, 
[09:30:10.480]                         ...future.globals.maxSize)) {
[09:30:10.480]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:10.480]                         on.exit(options(oopts), add = TRUE)
[09:30:10.480]                       }
[09:30:10.480]                       {
[09:30:10.480]                         lapply(seq_along(...future.elements_ii), 
[09:30:10.480]                           FUN = function(jj) {
[09:30:10.480]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:10.480]                             ...future.FUN(...future.X_jj, ...)
[09:30:10.480]                           })
[09:30:10.480]                       }
[09:30:10.480]                     }, args = future.call.arguments)
[09:30:10.480]                   }
[09:30:10.480]                 }, immediateCondition = function(cond) {
[09:30:10.480]                   save_rds <- function (object, pathname, ...) 
[09:30:10.480]                   {
[09:30:10.480]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:30:10.480]                     if (file_test("-f", pathname_tmp)) {
[09:30:10.480]                       fi_tmp <- file.info(pathname_tmp)
[09:30:10.480]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:30:10.480]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:10.480]                         fi_tmp[["mtime"]])
[09:30:10.480]                     }
[09:30:10.480]                     tryCatch({
[09:30:10.480]                       saveRDS(object, file = pathname_tmp, ...)
[09:30:10.480]                     }, error = function(ex) {
[09:30:10.480]                       msg <- conditionMessage(ex)
[09:30:10.480]                       fi_tmp <- file.info(pathname_tmp)
[09:30:10.480]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:30:10.480]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:10.480]                         fi_tmp[["mtime"]], msg)
[09:30:10.480]                       ex$message <- msg
[09:30:10.480]                       stop(ex)
[09:30:10.480]                     })
[09:30:10.480]                     stopifnot(file_test("-f", pathname_tmp))
[09:30:10.480]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:30:10.480]                     if (!res || file_test("-f", pathname_tmp)) {
[09:30:10.480]                       fi_tmp <- file.info(pathname_tmp)
[09:30:10.480]                       fi <- file.info(pathname)
[09:30:10.480]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:30:10.480]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:10.480]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:30:10.480]                         fi[["size"]], fi[["mtime"]])
[09:30:10.480]                       stop(msg)
[09:30:10.480]                     }
[09:30:10.480]                     invisible(pathname)
[09:30:10.480]                   }
[09:30:10.480]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:30:10.480]                     rootPath = tempdir()) 
[09:30:10.480]                   {
[09:30:10.480]                     obj <- list(time = Sys.time(), condition = cond)
[09:30:10.480]                     file <- tempfile(pattern = class(cond)[1], 
[09:30:10.480]                       tmpdir = path, fileext = ".rds")
[09:30:10.480]                     save_rds(obj, file)
[09:30:10.480]                   }
[09:30:10.480]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0coFNd/.future/immediateConditions")
[09:30:10.480]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:10.480]                   {
[09:30:10.480]                     inherits <- base::inherits
[09:30:10.480]                     invokeRestart <- base::invokeRestart
[09:30:10.480]                     is.null <- base::is.null
[09:30:10.480]                     muffled <- FALSE
[09:30:10.480]                     if (inherits(cond, "message")) {
[09:30:10.480]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:10.480]                       if (muffled) 
[09:30:10.480]                         invokeRestart("muffleMessage")
[09:30:10.480]                     }
[09:30:10.480]                     else if (inherits(cond, "warning")) {
[09:30:10.480]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:10.480]                       if (muffled) 
[09:30:10.480]                         invokeRestart("muffleWarning")
[09:30:10.480]                     }
[09:30:10.480]                     else if (inherits(cond, "condition")) {
[09:30:10.480]                       if (!is.null(pattern)) {
[09:30:10.480]                         computeRestarts <- base::computeRestarts
[09:30:10.480]                         grepl <- base::grepl
[09:30:10.480]                         restarts <- computeRestarts(cond)
[09:30:10.480]                         for (restart in restarts) {
[09:30:10.480]                           name <- restart$name
[09:30:10.480]                           if (is.null(name)) 
[09:30:10.480]                             next
[09:30:10.480]                           if (!grepl(pattern, name)) 
[09:30:10.480]                             next
[09:30:10.480]                           invokeRestart(restart)
[09:30:10.480]                           muffled <- TRUE
[09:30:10.480]                           break
[09:30:10.480]                         }
[09:30:10.480]                       }
[09:30:10.480]                     }
[09:30:10.480]                     invisible(muffled)
[09:30:10.480]                   }
[09:30:10.480]                   muffleCondition(cond)
[09:30:10.480]                 })
[09:30:10.480]             }))
[09:30:10.480]             future::FutureResult(value = ...future.value$value, 
[09:30:10.480]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:10.480]                   ...future.rng), globalenv = if (FALSE) 
[09:30:10.480]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:10.480]                     ...future.globalenv.names))
[09:30:10.480]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:10.480]         }, condition = base::local({
[09:30:10.480]             c <- base::c
[09:30:10.480]             inherits <- base::inherits
[09:30:10.480]             invokeRestart <- base::invokeRestart
[09:30:10.480]             length <- base::length
[09:30:10.480]             list <- base::list
[09:30:10.480]             seq.int <- base::seq.int
[09:30:10.480]             signalCondition <- base::signalCondition
[09:30:10.480]             sys.calls <- base::sys.calls
[09:30:10.480]             `[[` <- base::`[[`
[09:30:10.480]             `+` <- base::`+`
[09:30:10.480]             `<<-` <- base::`<<-`
[09:30:10.480]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:10.480]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:10.480]                   3L)]
[09:30:10.480]             }
[09:30:10.480]             function(cond) {
[09:30:10.480]                 is_error <- inherits(cond, "error")
[09:30:10.480]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:10.480]                   NULL)
[09:30:10.480]                 if (is_error) {
[09:30:10.480]                   sessionInformation <- function() {
[09:30:10.480]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:10.480]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:10.480]                       search = base::search(), system = base::Sys.info())
[09:30:10.480]                   }
[09:30:10.480]                   ...future.conditions[[length(...future.conditions) + 
[09:30:10.480]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:10.480]                     cond$call), session = sessionInformation(), 
[09:30:10.480]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:10.480]                   signalCondition(cond)
[09:30:10.480]                 }
[09:30:10.480]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:10.480]                 "immediateCondition"))) {
[09:30:10.480]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:10.480]                   ...future.conditions[[length(...future.conditions) + 
[09:30:10.480]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:10.480]                   if (TRUE && !signal) {
[09:30:10.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:10.480]                     {
[09:30:10.480]                       inherits <- base::inherits
[09:30:10.480]                       invokeRestart <- base::invokeRestart
[09:30:10.480]                       is.null <- base::is.null
[09:30:10.480]                       muffled <- FALSE
[09:30:10.480]                       if (inherits(cond, "message")) {
[09:30:10.480]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:10.480]                         if (muffled) 
[09:30:10.480]                           invokeRestart("muffleMessage")
[09:30:10.480]                       }
[09:30:10.480]                       else if (inherits(cond, "warning")) {
[09:30:10.480]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:10.480]                         if (muffled) 
[09:30:10.480]                           invokeRestart("muffleWarning")
[09:30:10.480]                       }
[09:30:10.480]                       else if (inherits(cond, "condition")) {
[09:30:10.480]                         if (!is.null(pattern)) {
[09:30:10.480]                           computeRestarts <- base::computeRestarts
[09:30:10.480]                           grepl <- base::grepl
[09:30:10.480]                           restarts <- computeRestarts(cond)
[09:30:10.480]                           for (restart in restarts) {
[09:30:10.480]                             name <- restart$name
[09:30:10.480]                             if (is.null(name)) 
[09:30:10.480]                               next
[09:30:10.480]                             if (!grepl(pattern, name)) 
[09:30:10.480]                               next
[09:30:10.480]                             invokeRestart(restart)
[09:30:10.480]                             muffled <- TRUE
[09:30:10.480]                             break
[09:30:10.480]                           }
[09:30:10.480]                         }
[09:30:10.480]                       }
[09:30:10.480]                       invisible(muffled)
[09:30:10.480]                     }
[09:30:10.480]                     muffleCondition(cond, pattern = "^muffle")
[09:30:10.480]                   }
[09:30:10.480]                 }
[09:30:10.480]                 else {
[09:30:10.480]                   if (TRUE) {
[09:30:10.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:10.480]                     {
[09:30:10.480]                       inherits <- base::inherits
[09:30:10.480]                       invokeRestart <- base::invokeRestart
[09:30:10.480]                       is.null <- base::is.null
[09:30:10.480]                       muffled <- FALSE
[09:30:10.480]                       if (inherits(cond, "message")) {
[09:30:10.480]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:10.480]                         if (muffled) 
[09:30:10.480]                           invokeRestart("muffleMessage")
[09:30:10.480]                       }
[09:30:10.480]                       else if (inherits(cond, "warning")) {
[09:30:10.480]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:10.480]                         if (muffled) 
[09:30:10.480]                           invokeRestart("muffleWarning")
[09:30:10.480]                       }
[09:30:10.480]                       else if (inherits(cond, "condition")) {
[09:30:10.480]                         if (!is.null(pattern)) {
[09:30:10.480]                           computeRestarts <- base::computeRestarts
[09:30:10.480]                           grepl <- base::grepl
[09:30:10.480]                           restarts <- computeRestarts(cond)
[09:30:10.480]                           for (restart in restarts) {
[09:30:10.480]                             name <- restart$name
[09:30:10.480]                             if (is.null(name)) 
[09:30:10.480]                               next
[09:30:10.480]                             if (!grepl(pattern, name)) 
[09:30:10.480]                               next
[09:30:10.480]                             invokeRestart(restart)
[09:30:10.480]                             muffled <- TRUE
[09:30:10.480]                             break
[09:30:10.480]                           }
[09:30:10.480]                         }
[09:30:10.480]                       }
[09:30:10.480]                       invisible(muffled)
[09:30:10.480]                     }
[09:30:10.480]                     muffleCondition(cond, pattern = "^muffle")
[09:30:10.480]                   }
[09:30:10.480]                 }
[09:30:10.480]             }
[09:30:10.480]         }))
[09:30:10.480]     }, error = function(ex) {
[09:30:10.480]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:10.480]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:10.480]                 ...future.rng), started = ...future.startTime, 
[09:30:10.480]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:10.480]             version = "1.8"), class = "FutureResult")
[09:30:10.480]     }, finally = {
[09:30:10.480]         if (!identical(...future.workdir, getwd())) 
[09:30:10.480]             setwd(...future.workdir)
[09:30:10.480]         {
[09:30:10.480]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:10.480]                 ...future.oldOptions$nwarnings <- NULL
[09:30:10.480]             }
[09:30:10.480]             base::options(...future.oldOptions)
[09:30:10.480]             if (.Platform$OS.type == "windows") {
[09:30:10.480]                 old_names <- names(...future.oldEnvVars)
[09:30:10.480]                 envs <- base::Sys.getenv()
[09:30:10.480]                 names <- names(envs)
[09:30:10.480]                 common <- intersect(names, old_names)
[09:30:10.480]                 added <- setdiff(names, old_names)
[09:30:10.480]                 removed <- setdiff(old_names, names)
[09:30:10.480]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:10.480]                   envs[common]]
[09:30:10.480]                 NAMES <- toupper(changed)
[09:30:10.480]                 args <- list()
[09:30:10.480]                 for (kk in seq_along(NAMES)) {
[09:30:10.480]                   name <- changed[[kk]]
[09:30:10.480]                   NAME <- NAMES[[kk]]
[09:30:10.480]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:10.480]                     next
[09:30:10.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:10.480]                 }
[09:30:10.480]                 NAMES <- toupper(added)
[09:30:10.480]                 for (kk in seq_along(NAMES)) {
[09:30:10.480]                   name <- added[[kk]]
[09:30:10.480]                   NAME <- NAMES[[kk]]
[09:30:10.480]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:10.480]                     next
[09:30:10.480]                   args[[name]] <- ""
[09:30:10.480]                 }
[09:30:10.480]                 NAMES <- toupper(removed)
[09:30:10.480]                 for (kk in seq_along(NAMES)) {
[09:30:10.480]                   name <- removed[[kk]]
[09:30:10.480]                   NAME <- NAMES[[kk]]
[09:30:10.480]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:10.480]                     next
[09:30:10.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:10.480]                 }
[09:30:10.480]                 if (length(args) > 0) 
[09:30:10.480]                   base::do.call(base::Sys.setenv, args = args)
[09:30:10.480]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:10.480]             }
[09:30:10.480]             else {
[09:30:10.480]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:10.480]             }
[09:30:10.480]             {
[09:30:10.480]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:10.480]                   0L) {
[09:30:10.480]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:10.480]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:10.480]                   base::options(opts)
[09:30:10.480]                 }
[09:30:10.480]                 {
[09:30:10.480]                   {
[09:30:10.480]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:10.480]                     NULL
[09:30:10.480]                   }
[09:30:10.480]                   options(future.plan = NULL)
[09:30:10.480]                   if (is.na(NA_character_)) 
[09:30:10.480]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:10.480]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:10.480]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:10.480]                     .init = FALSE)
[09:30:10.480]                 }
[09:30:10.480]             }
[09:30:10.480]         }
[09:30:10.480]     })
[09:30:10.480]     if (FALSE) {
[09:30:10.480]         base::sink(type = "output", split = FALSE)
[09:30:10.480]         if (NA) {
[09:30:10.480]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:10.480]         }
[09:30:10.480]         else {
[09:30:10.480]             ...future.result["stdout"] <- base::list(NULL)
[09:30:10.480]         }
[09:30:10.480]         base::close(...future.stdout)
[09:30:10.480]         ...future.stdout <- NULL
[09:30:10.480]     }
[09:30:10.480]     ...future.result$conditions <- ...future.conditions
[09:30:10.480]     ...future.result$finished <- base::Sys.time()
[09:30:10.480]     ...future.result
[09:30:10.480] }
[09:30:10.484] assign_globals() ...
[09:30:10.484] List of 5
[09:30:10.484]  $ ...future.FUN            :function (x)  
[09:30:10.484]  $ future.call.arguments    : list()
[09:30:10.484]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:10.484]  $ ...future.elements_ii    :List of 1
[09:30:10.484]   ..$ : int 0
[09:30:10.484]  $ ...future.seeds_ii       : NULL
[09:30:10.484]  $ ...future.globals.maxSize: NULL
[09:30:10.484]  - attr(*, "where")=List of 5
[09:30:10.484]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:10.484]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:30:10.484]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:10.484]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:10.484]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:10.484]  - attr(*, "resolved")= logi FALSE
[09:30:10.484]  - attr(*, "total_size")= num 4720
[09:30:10.484]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:10.484]  - attr(*, "already-done")= logi TRUE
[09:30:10.491] - reassign environment for ‘...future.FUN’
[09:30:10.491] - copied ‘...future.FUN’ to environment
[09:30:10.491] - copied ‘future.call.arguments’ to environment
[09:30:10.491] - copied ‘...future.elements_ii’ to environment
[09:30:10.491] - copied ‘...future.seeds_ii’ to environment
[09:30:10.491] - copied ‘...future.globals.maxSize’ to environment
[09:30:10.491] assign_globals() ... done
[09:30:10.492] requestCore(): workers = 2
[09:30:10.497] MulticoreFuture started
[09:30:10.497] - Launch lazy future ... done
[09:30:10.498] plan(): Setting new future strategy stack:
[09:30:10.498] run() for ‘MulticoreFuture’ ... done
[09:30:10.499] Created future:
[09:30:10.498] List of future strategies:
[09:30:10.498] 1. sequential:
[09:30:10.498]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:10.498]    - tweaked: FALSE
[09:30:10.498]    - call: NULL
[09:30:10.500] plan(): nbrOfWorkers() = 1
[09:30:10.503] plan(): Setting new future strategy stack:
[09:30:10.503] List of future strategies:
[09:30:10.503] 1. multicore:
[09:30:10.503]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:30:10.503]    - tweaked: FALSE
[09:30:10.503]    - call: plan(strategy)
[09:30:10.509] plan(): nbrOfWorkers() = 2
[09:30:10.499] MulticoreFuture:
[09:30:10.499] Label: ‘future_lapply-2’
[09:30:10.499] Expression:
[09:30:10.499] {
[09:30:10.499]     do.call(function(...) {
[09:30:10.499]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:10.499]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:10.499]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:10.499]             on.exit(options(oopts), add = TRUE)
[09:30:10.499]         }
[09:30:10.499]         {
[09:30:10.499]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:10.499]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:10.499]                 ...future.FUN(...future.X_jj, ...)
[09:30:10.499]             })
[09:30:10.499]         }
[09:30:10.499]     }, args = future.call.arguments)
[09:30:10.499] }
[09:30:10.499] Lazy evaluation: FALSE
[09:30:10.499] Asynchronous evaluation: TRUE
[09:30:10.499] Local evaluation: TRUE
[09:30:10.499] Environment: R_GlobalEnv
[09:30:10.499] Capture standard output: NA
[09:30:10.499] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:10.499] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:10.499] Packages: <none>
[09:30:10.499] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:10.499] Resolved: TRUE
[09:30:10.499] Value: <not collected>
[09:30:10.499] Conditions captured: <none>
[09:30:10.499] Early signaling: FALSE
[09:30:10.499] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:10.499] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:10.511] Chunk #2 of 2 ... DONE
[09:30:10.511] Launching 2 futures (chunks) ... DONE
[09:30:10.511] Resolving 2 futures (chunks) ...
[09:30:10.511] resolve() on list ...
[09:30:10.511]  recursive: 0
[09:30:10.512]  length: 2
[09:30:10.512] 
[09:30:10.523] Future #2
[09:30:10.523] result() for MulticoreFuture ...
[09:30:10.524] result() for MulticoreFuture ...
[09:30:10.524] result() for MulticoreFuture ... done
[09:30:10.524] result() for MulticoreFuture ... done
[09:30:10.525] result() for MulticoreFuture ...
[09:30:10.525] result() for MulticoreFuture ... done
[09:30:10.525] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:30:10.525] - nx: 2
[09:30:10.525] - relay: TRUE
[09:30:10.525] - stdout: TRUE
[09:30:10.526] - signal: TRUE
[09:30:10.526] - resignal: FALSE
[09:30:10.526] - force: TRUE
[09:30:10.526] - relayed: [n=2] FALSE, FALSE
[09:30:10.526] - queued futures: [n=2] FALSE, FALSE
[09:30:10.526]  - until=1
[09:30:10.527]  - relaying element #1
[09:30:10.527] - relayed: [n=2] FALSE, FALSE
[09:30:10.527] - queued futures: [n=2] FALSE, TRUE
[09:30:10.527] signalConditionsASAP(NULL, pos=2) ... done
[09:30:10.527]  length: 1 (resolved future 2)
[09:30:10.955] plan(): Setting new future strategy stack:
[09:30:10.955] List of future strategies:
[09:30:10.955] 1. multicore:
[09:30:10.955]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:30:10.955]    - tweaked: FALSE
[09:30:10.955]    - call: plan(strategy)
[09:30:10.959] plan(): nbrOfWorkers() = 2
[09:30:10.966] Future #1
[09:30:10.966] result() for MulticoreFuture ...
[09:30:10.967] result() for MulticoreFuture ...
[09:30:10.967] result() for MulticoreFuture ... done
[09:30:10.967] result() for MulticoreFuture ... done
[09:30:10.967] result() for MulticoreFuture ...
[09:30:10.967] result() for MulticoreFuture ... done
[09:30:10.968] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:30:10.968] - nx: 2
[09:30:10.968] - relay: TRUE
[09:30:10.968] - stdout: TRUE
[09:30:10.968] - signal: TRUE
[09:30:10.968] - resignal: FALSE
[09:30:10.969] - force: TRUE
[09:30:10.969] - relayed: [n=2] FALSE, FALSE
[09:30:10.969] - queued futures: [n=2] FALSE, TRUE
[09:30:10.969]  - until=1
[09:30:10.969]  - relaying element #1
[09:30:10.969] result() for MulticoreFuture ...
[09:30:10.969] result() for MulticoreFuture ... done
[09:30:10.970] result() for MulticoreFuture ...
[09:30:10.970] result() for MulticoreFuture ... done
[09:30:10.970] result() for MulticoreFuture ...
[09:30:10.970] result() for MulticoreFuture ... done
[09:30:10.970] result() for MulticoreFuture ...
[09:30:10.970] result() for MulticoreFuture ... done
[09:30:10.971] - relayed: [n=2] TRUE, FALSE
[09:30:10.971] - queued futures: [n=2] TRUE, TRUE
[09:30:10.971] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:30:10.971]  length: 0 (resolved future 1)
[09:30:10.971] Relaying remaining futures
[09:30:10.971] signalConditionsASAP(NULL, pos=0) ...
[09:30:10.971] - nx: 2
[09:30:10.971] - relay: TRUE
[09:30:10.972] - stdout: TRUE
[09:30:10.972] - signal: TRUE
[09:30:10.972] - resignal: FALSE
[09:30:10.972] - force: TRUE
[09:30:10.972] - relayed: [n=2] TRUE, FALSE
[09:30:10.972] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:30:10.972]  - relaying element #2
[09:30:10.972] result() for MulticoreFuture ...
[09:30:10.972] result() for MulticoreFuture ... done
[09:30:10.973] result() for MulticoreFuture ...
[09:30:10.973] result() for MulticoreFuture ... done
[09:30:10.973] result() for MulticoreFuture ...
[09:30:10.973] result() for MulticoreFuture ... done
[09:30:10.973] result() for MulticoreFuture ...
[09:30:10.973] result() for MulticoreFuture ... done
[09:30:10.973] - relayed: [n=2] TRUE, TRUE
[09:30:10.973] - queued futures: [n=2] TRUE, TRUE
[09:30:10.973] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[09:30:10.974] resolve() on list ... DONE
[09:30:10.974] result() for MulticoreFuture ...
[09:30:10.974] result() for MulticoreFuture ... done
[09:30:10.974] result() for MulticoreFuture ...
[09:30:10.974] result() for MulticoreFuture ... done
[09:30:10.974] result() for MulticoreFuture ...
[09:30:10.974] result() for MulticoreFuture ... done
[09:30:10.974] result() for MulticoreFuture ...
[09:30:10.974] result() for MulticoreFuture ... done
[09:30:10.975]  - Number of value chunks collected: 2
[09:30:10.975] Resolving 2 futures (chunks) ... DONE
[09:30:10.975] Reducing values from 2 chunks ...
[09:30:10.975]  - Number of values collected after concatenation: 2
[09:30:10.975]  - Number of values expected: 2
[09:30:10.975] Reducing values from 2 chunks ... DONE
[09:30:10.975] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[09:30:10.976] future_mapply() ...
[09:30:10.980] Number of chunks: 2
[09:30:10.980] getGlobalsAndPackagesXApply() ...
[09:30:10.980]  - future.globals: TRUE
[09:30:10.980] getGlobalsAndPackages() ...
[09:30:10.980] Searching for globals...
[09:30:10.982] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[09:30:10.982] Searching for globals ... DONE
[09:30:10.982] Resolving globals: FALSE
[09:30:10.983] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[09:30:10.983] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[09:30:10.983] - globals: [1] ‘FUN’
[09:30:10.983] 
[09:30:10.984] getGlobalsAndPackages() ... DONE
[09:30:10.984]  - globals found/used: [n=1] ‘FUN’
[09:30:10.984]  - needed namespaces: [n=0] 
[09:30:10.984] Finding globals ... DONE
[09:30:10.984] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:30:10.984] List of 2
[09:30:10.984]  $ ...future.FUN:function (x, y)  
[09:30:10.984]  $ MoreArgs     : NULL
[09:30:10.984]  - attr(*, "where")=List of 2
[09:30:10.984]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:10.984]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:30:10.984]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:10.984]  - attr(*, "resolved")= logi FALSE
[09:30:10.984]  - attr(*, "total_size")= num NA
[09:30:10.987] Packages to be attached in all futures: [n=0] 
[09:30:10.987] getGlobalsAndPackagesXApply() ... DONE
[09:30:10.987] Number of futures (= number of chunks): 2
[09:30:10.987] Launching 2 futures (chunks) ...
[09:30:10.988] Chunk #1 of 2 ...
[09:30:10.988]  - Finding globals in '...' for chunk #1 ...
[09:30:10.988] getGlobalsAndPackages() ...
[09:30:10.988] Searching for globals...
[09:30:10.990] 
[09:30:10.990] Searching for globals ... DONE
[09:30:10.990] - globals: [0] <none>
[09:30:10.991] getGlobalsAndPackages() ... DONE
[09:30:10.991]    + additional globals found: [n=0] 
[09:30:10.991]    + additional namespaces needed: [n=0] 
[09:30:10.991]  - Finding globals in '...' for chunk #1 ... DONE
[09:30:10.991]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:10.991]  - seeds: <none>
[09:30:10.991]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:10.991] getGlobalsAndPackages() ...
[09:30:10.992] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:10.992] Resolving globals: FALSE
[09:30:10.992] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[09:30:10.993] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:30:10.993] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:10.993] 
[09:30:10.993] getGlobalsAndPackages() ... DONE
[09:30:10.993] run() for ‘Future’ ...
[09:30:10.994] - state: ‘created’
[09:30:10.994] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:30:10.997] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:10.997] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:30:10.997]   - Field: ‘label’
[09:30:10.998]   - Field: ‘local’
[09:30:10.998]   - Field: ‘owner’
[09:30:10.998]   - Field: ‘envir’
[09:30:10.998]   - Field: ‘workers’
[09:30:10.998]   - Field: ‘packages’
[09:30:10.998]   - Field: ‘gc’
[09:30:10.998]   - Field: ‘job’
[09:30:10.998]   - Field: ‘conditions’
[09:30:10.998]   - Field: ‘expr’
[09:30:10.998]   - Field: ‘uuid’
[09:30:10.998]   - Field: ‘seed’
[09:30:10.999]   - Field: ‘version’
[09:30:10.999]   - Field: ‘result’
[09:30:10.999]   - Field: ‘asynchronous’
[09:30:10.999]   - Field: ‘calls’
[09:30:10.999]   - Field: ‘globals’
[09:30:10.999]   - Field: ‘stdout’
[09:30:10.999]   - Field: ‘earlySignal’
[09:30:10.999]   - Field: ‘lazy’
[09:30:10.999]   - Field: ‘state’
[09:30:10.999] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:30:10.999] - Launch lazy future ...
[09:30:11.000] Packages needed by the future expression (n = 0): <none>
[09:30:11.000] Packages needed by future strategies (n = 0): <none>
[09:30:11.000] {
[09:30:11.000]     {
[09:30:11.000]         {
[09:30:11.000]             ...future.startTime <- base::Sys.time()
[09:30:11.000]             {
[09:30:11.000]                 {
[09:30:11.000]                   {
[09:30:11.000]                     {
[09:30:11.000]                       base::local({
[09:30:11.000]                         has_future <- base::requireNamespace("future", 
[09:30:11.000]                           quietly = TRUE)
[09:30:11.000]                         if (has_future) {
[09:30:11.000]                           ns <- base::getNamespace("future")
[09:30:11.000]                           version <- ns[[".package"]][["version"]]
[09:30:11.000]                           if (is.null(version)) 
[09:30:11.000]                             version <- utils::packageVersion("future")
[09:30:11.000]                         }
[09:30:11.000]                         else {
[09:30:11.000]                           version <- NULL
[09:30:11.000]                         }
[09:30:11.000]                         if (!has_future || version < "1.8.0") {
[09:30:11.000]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:11.000]                             "", base::R.version$version.string), 
[09:30:11.000]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:11.000]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:11.000]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:11.000]                               "release", "version")], collapse = " "), 
[09:30:11.000]                             hostname = base::Sys.info()[["nodename"]])
[09:30:11.000]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:11.000]                             info)
[09:30:11.000]                           info <- base::paste(info, collapse = "; ")
[09:30:11.000]                           if (!has_future) {
[09:30:11.000]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:11.000]                               info)
[09:30:11.000]                           }
[09:30:11.000]                           else {
[09:30:11.000]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:11.000]                               info, version)
[09:30:11.000]                           }
[09:30:11.000]                           base::stop(msg)
[09:30:11.000]                         }
[09:30:11.000]                       })
[09:30:11.000]                     }
[09:30:11.000]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:11.000]                     base::options(mc.cores = 1L)
[09:30:11.000]                   }
[09:30:11.000]                   ...future.strategy.old <- future::plan("list")
[09:30:11.000]                   options(future.plan = NULL)
[09:30:11.000]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:11.000]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:11.000]                 }
[09:30:11.000]                 ...future.workdir <- getwd()
[09:30:11.000]             }
[09:30:11.000]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:11.000]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:11.000]         }
[09:30:11.000]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:11.000]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:11.000]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:11.000]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:11.000]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:11.000]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:11.000]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:11.000]             base::names(...future.oldOptions))
[09:30:11.000]     }
[09:30:11.000]     if (FALSE) {
[09:30:11.000]     }
[09:30:11.000]     else {
[09:30:11.000]         if (FALSE) {
[09:30:11.000]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:11.000]                 open = "w")
[09:30:11.000]         }
[09:30:11.000]         else {
[09:30:11.000]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:11.000]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:11.000]         }
[09:30:11.000]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:11.000]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:11.000]             base::sink(type = "output", split = FALSE)
[09:30:11.000]             base::close(...future.stdout)
[09:30:11.000]         }, add = TRUE)
[09:30:11.000]     }
[09:30:11.000]     ...future.frame <- base::sys.nframe()
[09:30:11.000]     ...future.conditions <- base::list()
[09:30:11.000]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:11.000]     if (FALSE) {
[09:30:11.000]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:11.000]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:11.000]     }
[09:30:11.000]     ...future.result <- base::tryCatch({
[09:30:11.000]         base::withCallingHandlers({
[09:30:11.000]             ...future.value <- base::withVisible(base::local({
[09:30:11.000]                 withCallingHandlers({
[09:30:11.000]                   {
[09:30:11.000]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:11.000]                     if (!identical(...future.globals.maxSize.org, 
[09:30:11.000]                       ...future.globals.maxSize)) {
[09:30:11.000]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:11.000]                       on.exit(options(oopts), add = TRUE)
[09:30:11.000]                     }
[09:30:11.000]                     {
[09:30:11.000]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:11.000]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:30:11.000]                         USE.NAMES = FALSE)
[09:30:11.000]                       do.call(mapply, args = args)
[09:30:11.000]                     }
[09:30:11.000]                   }
[09:30:11.000]                 }, immediateCondition = function(cond) {
[09:30:11.000]                   save_rds <- function (object, pathname, ...) 
[09:30:11.000]                   {
[09:30:11.000]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:30:11.000]                     if (file_test("-f", pathname_tmp)) {
[09:30:11.000]                       fi_tmp <- file.info(pathname_tmp)
[09:30:11.000]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:30:11.000]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:11.000]                         fi_tmp[["mtime"]])
[09:30:11.000]                     }
[09:30:11.000]                     tryCatch({
[09:30:11.000]                       saveRDS(object, file = pathname_tmp, ...)
[09:30:11.000]                     }, error = function(ex) {
[09:30:11.000]                       msg <- conditionMessage(ex)
[09:30:11.000]                       fi_tmp <- file.info(pathname_tmp)
[09:30:11.000]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:30:11.000]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:11.000]                         fi_tmp[["mtime"]], msg)
[09:30:11.000]                       ex$message <- msg
[09:30:11.000]                       stop(ex)
[09:30:11.000]                     })
[09:30:11.000]                     stopifnot(file_test("-f", pathname_tmp))
[09:30:11.000]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:30:11.000]                     if (!res || file_test("-f", pathname_tmp)) {
[09:30:11.000]                       fi_tmp <- file.info(pathname_tmp)
[09:30:11.000]                       fi <- file.info(pathname)
[09:30:11.000]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:30:11.000]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:11.000]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:30:11.000]                         fi[["size"]], fi[["mtime"]])
[09:30:11.000]                       stop(msg)
[09:30:11.000]                     }
[09:30:11.000]                     invisible(pathname)
[09:30:11.000]                   }
[09:30:11.000]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:30:11.000]                     rootPath = tempdir()) 
[09:30:11.000]                   {
[09:30:11.000]                     obj <- list(time = Sys.time(), condition = cond)
[09:30:11.000]                     file <- tempfile(pattern = class(cond)[1], 
[09:30:11.000]                       tmpdir = path, fileext = ".rds")
[09:30:11.000]                     save_rds(obj, file)
[09:30:11.000]                   }
[09:30:11.000]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0coFNd/.future/immediateConditions")
[09:30:11.000]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:11.000]                   {
[09:30:11.000]                     inherits <- base::inherits
[09:30:11.000]                     invokeRestart <- base::invokeRestart
[09:30:11.000]                     is.null <- base::is.null
[09:30:11.000]                     muffled <- FALSE
[09:30:11.000]                     if (inherits(cond, "message")) {
[09:30:11.000]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:11.000]                       if (muffled) 
[09:30:11.000]                         invokeRestart("muffleMessage")
[09:30:11.000]                     }
[09:30:11.000]                     else if (inherits(cond, "warning")) {
[09:30:11.000]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:11.000]                       if (muffled) 
[09:30:11.000]                         invokeRestart("muffleWarning")
[09:30:11.000]                     }
[09:30:11.000]                     else if (inherits(cond, "condition")) {
[09:30:11.000]                       if (!is.null(pattern)) {
[09:30:11.000]                         computeRestarts <- base::computeRestarts
[09:30:11.000]                         grepl <- base::grepl
[09:30:11.000]                         restarts <- computeRestarts(cond)
[09:30:11.000]                         for (restart in restarts) {
[09:30:11.000]                           name <- restart$name
[09:30:11.000]                           if (is.null(name)) 
[09:30:11.000]                             next
[09:30:11.000]                           if (!grepl(pattern, name)) 
[09:30:11.000]                             next
[09:30:11.000]                           invokeRestart(restart)
[09:30:11.000]                           muffled <- TRUE
[09:30:11.000]                           break
[09:30:11.000]                         }
[09:30:11.000]                       }
[09:30:11.000]                     }
[09:30:11.000]                     invisible(muffled)
[09:30:11.000]                   }
[09:30:11.000]                   muffleCondition(cond)
[09:30:11.000]                 })
[09:30:11.000]             }))
[09:30:11.000]             future::FutureResult(value = ...future.value$value, 
[09:30:11.000]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:11.000]                   ...future.rng), globalenv = if (FALSE) 
[09:30:11.000]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:11.000]                     ...future.globalenv.names))
[09:30:11.000]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:11.000]         }, condition = base::local({
[09:30:11.000]             c <- base::c
[09:30:11.000]             inherits <- base::inherits
[09:30:11.000]             invokeRestart <- base::invokeRestart
[09:30:11.000]             length <- base::length
[09:30:11.000]             list <- base::list
[09:30:11.000]             seq.int <- base::seq.int
[09:30:11.000]             signalCondition <- base::signalCondition
[09:30:11.000]             sys.calls <- base::sys.calls
[09:30:11.000]             `[[` <- base::`[[`
[09:30:11.000]             `+` <- base::`+`
[09:30:11.000]             `<<-` <- base::`<<-`
[09:30:11.000]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:11.000]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:11.000]                   3L)]
[09:30:11.000]             }
[09:30:11.000]             function(cond) {
[09:30:11.000]                 is_error <- inherits(cond, "error")
[09:30:11.000]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:11.000]                   NULL)
[09:30:11.000]                 if (is_error) {
[09:30:11.000]                   sessionInformation <- function() {
[09:30:11.000]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:11.000]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:11.000]                       search = base::search(), system = base::Sys.info())
[09:30:11.000]                   }
[09:30:11.000]                   ...future.conditions[[length(...future.conditions) + 
[09:30:11.000]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:11.000]                     cond$call), session = sessionInformation(), 
[09:30:11.000]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:11.000]                   signalCondition(cond)
[09:30:11.000]                 }
[09:30:11.000]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:11.000]                 "immediateCondition"))) {
[09:30:11.000]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:11.000]                   ...future.conditions[[length(...future.conditions) + 
[09:30:11.000]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:11.000]                   if (TRUE && !signal) {
[09:30:11.000]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:11.000]                     {
[09:30:11.000]                       inherits <- base::inherits
[09:30:11.000]                       invokeRestart <- base::invokeRestart
[09:30:11.000]                       is.null <- base::is.null
[09:30:11.000]                       muffled <- FALSE
[09:30:11.000]                       if (inherits(cond, "message")) {
[09:30:11.000]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:11.000]                         if (muffled) 
[09:30:11.000]                           invokeRestart("muffleMessage")
[09:30:11.000]                       }
[09:30:11.000]                       else if (inherits(cond, "warning")) {
[09:30:11.000]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:11.000]                         if (muffled) 
[09:30:11.000]                           invokeRestart("muffleWarning")
[09:30:11.000]                       }
[09:30:11.000]                       else if (inherits(cond, "condition")) {
[09:30:11.000]                         if (!is.null(pattern)) {
[09:30:11.000]                           computeRestarts <- base::computeRestarts
[09:30:11.000]                           grepl <- base::grepl
[09:30:11.000]                           restarts <- computeRestarts(cond)
[09:30:11.000]                           for (restart in restarts) {
[09:30:11.000]                             name <- restart$name
[09:30:11.000]                             if (is.null(name)) 
[09:30:11.000]                               next
[09:30:11.000]                             if (!grepl(pattern, name)) 
[09:30:11.000]                               next
[09:30:11.000]                             invokeRestart(restart)
[09:30:11.000]                             muffled <- TRUE
[09:30:11.000]                             break
[09:30:11.000]                           }
[09:30:11.000]                         }
[09:30:11.000]                       }
[09:30:11.000]                       invisible(muffled)
[09:30:11.000]                     }
[09:30:11.000]                     muffleCondition(cond, pattern = "^muffle")
[09:30:11.000]                   }
[09:30:11.000]                 }
[09:30:11.000]                 else {
[09:30:11.000]                   if (TRUE) {
[09:30:11.000]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:11.000]                     {
[09:30:11.000]                       inherits <- base::inherits
[09:30:11.000]                       invokeRestart <- base::invokeRestart
[09:30:11.000]                       is.null <- base::is.null
[09:30:11.000]                       muffled <- FALSE
[09:30:11.000]                       if (inherits(cond, "message")) {
[09:30:11.000]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:11.000]                         if (muffled) 
[09:30:11.000]                           invokeRestart("muffleMessage")
[09:30:11.000]                       }
[09:30:11.000]                       else if (inherits(cond, "warning")) {
[09:30:11.000]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:11.000]                         if (muffled) 
[09:30:11.000]                           invokeRestart("muffleWarning")
[09:30:11.000]                       }
[09:30:11.000]                       else if (inherits(cond, "condition")) {
[09:30:11.000]                         if (!is.null(pattern)) {
[09:30:11.000]                           computeRestarts <- base::computeRestarts
[09:30:11.000]                           grepl <- base::grepl
[09:30:11.000]                           restarts <- computeRestarts(cond)
[09:30:11.000]                           for (restart in restarts) {
[09:30:11.000]                             name <- restart$name
[09:30:11.000]                             if (is.null(name)) 
[09:30:11.000]                               next
[09:30:11.000]                             if (!grepl(pattern, name)) 
[09:30:11.000]                               next
[09:30:11.000]                             invokeRestart(restart)
[09:30:11.000]                             muffled <- TRUE
[09:30:11.000]                             break
[09:30:11.000]                           }
[09:30:11.000]                         }
[09:30:11.000]                       }
[09:30:11.000]                       invisible(muffled)
[09:30:11.000]                     }
[09:30:11.000]                     muffleCondition(cond, pattern = "^muffle")
[09:30:11.000]                   }
[09:30:11.000]                 }
[09:30:11.000]             }
[09:30:11.000]         }))
[09:30:11.000]     }, error = function(ex) {
[09:30:11.000]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:11.000]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:11.000]                 ...future.rng), started = ...future.startTime, 
[09:30:11.000]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:11.000]             version = "1.8"), class = "FutureResult")
[09:30:11.000]     }, finally = {
[09:30:11.000]         if (!identical(...future.workdir, getwd())) 
[09:30:11.000]             setwd(...future.workdir)
[09:30:11.000]         {
[09:30:11.000]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:11.000]                 ...future.oldOptions$nwarnings <- NULL
[09:30:11.000]             }
[09:30:11.000]             base::options(...future.oldOptions)
[09:30:11.000]             if (.Platform$OS.type == "windows") {
[09:30:11.000]                 old_names <- names(...future.oldEnvVars)
[09:30:11.000]                 envs <- base::Sys.getenv()
[09:30:11.000]                 names <- names(envs)
[09:30:11.000]                 common <- intersect(names, old_names)
[09:30:11.000]                 added <- setdiff(names, old_names)
[09:30:11.000]                 removed <- setdiff(old_names, names)
[09:30:11.000]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:11.000]                   envs[common]]
[09:30:11.000]                 NAMES <- toupper(changed)
[09:30:11.000]                 args <- list()
[09:30:11.000]                 for (kk in seq_along(NAMES)) {
[09:30:11.000]                   name <- changed[[kk]]
[09:30:11.000]                   NAME <- NAMES[[kk]]
[09:30:11.000]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:11.000]                     next
[09:30:11.000]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:11.000]                 }
[09:30:11.000]                 NAMES <- toupper(added)
[09:30:11.000]                 for (kk in seq_along(NAMES)) {
[09:30:11.000]                   name <- added[[kk]]
[09:30:11.000]                   NAME <- NAMES[[kk]]
[09:30:11.000]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:11.000]                     next
[09:30:11.000]                   args[[name]] <- ""
[09:30:11.000]                 }
[09:30:11.000]                 NAMES <- toupper(removed)
[09:30:11.000]                 for (kk in seq_along(NAMES)) {
[09:30:11.000]                   name <- removed[[kk]]
[09:30:11.000]                   NAME <- NAMES[[kk]]
[09:30:11.000]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:11.000]                     next
[09:30:11.000]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:11.000]                 }
[09:30:11.000]                 if (length(args) > 0) 
[09:30:11.000]                   base::do.call(base::Sys.setenv, args = args)
[09:30:11.000]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:11.000]             }
[09:30:11.000]             else {
[09:30:11.000]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:11.000]             }
[09:30:11.000]             {
[09:30:11.000]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:11.000]                   0L) {
[09:30:11.000]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:11.000]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:11.000]                   base::options(opts)
[09:30:11.000]                 }
[09:30:11.000]                 {
[09:30:11.000]                   {
[09:30:11.000]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:11.000]                     NULL
[09:30:11.000]                   }
[09:30:11.000]                   options(future.plan = NULL)
[09:30:11.000]                   if (is.na(NA_character_)) 
[09:30:11.000]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:11.000]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:11.000]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:11.000]                     .init = FALSE)
[09:30:11.000]                 }
[09:30:11.000]             }
[09:30:11.000]         }
[09:30:11.000]     })
[09:30:11.000]     if (TRUE) {
[09:30:11.000]         base::sink(type = "output", split = FALSE)
[09:30:11.000]         if (FALSE) {
[09:30:11.000]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:11.000]         }
[09:30:11.000]         else {
[09:30:11.000]             ...future.result["stdout"] <- base::list(NULL)
[09:30:11.000]         }
[09:30:11.000]         base::close(...future.stdout)
[09:30:11.000]         ...future.stdout <- NULL
[09:30:11.000]     }
[09:30:11.000]     ...future.result$conditions <- ...future.conditions
[09:30:11.000]     ...future.result$finished <- base::Sys.time()
[09:30:11.000]     ...future.result
[09:30:11.000] }
[09:30:11.003] assign_globals() ...
[09:30:11.003] List of 5
[09:30:11.003]  $ ...future.FUN            :function (x, y)  
[09:30:11.003]  $ MoreArgs                 : NULL
[09:30:11.003]  $ ...future.elements_ii    :List of 2
[09:30:11.003]   ..$ :List of 1
[09:30:11.003]   .. ..$ : int 1
[09:30:11.003]   ..$ :List of 1
[09:30:11.003]   .. ..$ : int 0
[09:30:11.003]  $ ...future.seeds_ii       : NULL
[09:30:11.003]  $ ...future.globals.maxSize: NULL
[09:30:11.003]  - attr(*, "where")=List of 5
[09:30:11.003]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:11.003]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:30:11.003]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:11.003]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:11.003]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:11.003]  - attr(*, "resolved")= logi FALSE
[09:30:11.003]  - attr(*, "total_size")= num 6368
[09:30:11.003]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:11.003]  - attr(*, "already-done")= logi TRUE
[09:30:11.008] - reassign environment for ‘...future.FUN’
[09:30:11.008] - copied ‘...future.FUN’ to environment
[09:30:11.008] - copied ‘MoreArgs’ to environment
[09:30:11.008] - copied ‘...future.elements_ii’ to environment
[09:30:11.008] - copied ‘...future.seeds_ii’ to environment
[09:30:11.008] - copied ‘...future.globals.maxSize’ to environment
[09:30:11.008] assign_globals() ... done
[09:30:11.008] requestCore(): workers = 2
[09:30:11.010] MulticoreFuture started
[09:30:11.011] - Launch lazy future ... done
[09:30:11.011] run() for ‘MulticoreFuture’ ... done
[09:30:11.011] Created future:
[09:30:11.011] plan(): Setting new future strategy stack:
[09:30:11.012] List of future strategies:
[09:30:11.012] 1. sequential:
[09:30:11.012]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:11.012]    - tweaked: FALSE
[09:30:11.012]    - call: NULL
[09:30:11.013] plan(): nbrOfWorkers() = 1
[09:30:11.011] MulticoreFuture:
[09:30:11.011] Label: ‘future_mapply-1’
[09:30:11.011] Expression:
[09:30:11.011] {
[09:30:11.011]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:11.011]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:11.011]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:11.011]         on.exit(options(oopts), add = TRUE)
[09:30:11.011]     }
[09:30:11.011]     {
[09:30:11.011]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:11.011]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:30:11.011]         do.call(mapply, args = args)
[09:30:11.011]     }
[09:30:11.011] }
[09:30:11.011] Lazy evaluation: FALSE
[09:30:11.011] Asynchronous evaluation: TRUE
[09:30:11.011] Local evaluation: TRUE
[09:30:11.011] Environment: R_GlobalEnv
[09:30:11.011] Capture standard output: FALSE
[09:30:11.011] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:11.011] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:11.011] Packages: <none>
[09:30:11.011] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:11.011] Resolved: FALSE
[09:30:11.011] Value: <not collected>
[09:30:11.011] Conditions captured: <none>
[09:30:11.011] Early signaling: FALSE
[09:30:11.011] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:11.011] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:11.024] Chunk #1 of 2 ... DONE
[09:30:11.024] Chunk #2 of 2 ...
[09:30:11.025]  - Finding globals in '...' for chunk #2 ...
[09:30:11.025] getGlobalsAndPackages() ...
[09:30:11.025] Searching for globals...
[09:30:11.026] 
[09:30:11.026] Searching for globals ... DONE
[09:30:11.026] - globals: [0] <none>
[09:30:11.026] getGlobalsAndPackages() ... DONE
[09:30:11.026]    + additional globals found: [n=0] 
[09:30:11.026]    + additional namespaces needed: [n=0] 
[09:30:11.027]  - Finding globals in '...' for chunk #2 ... DONE
[09:30:11.027]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:11.027]  - seeds: <none>
[09:30:11.027]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:11.027] getGlobalsAndPackages() ...
[09:30:11.027] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:11.027] Resolving globals: FALSE
[09:30:11.028] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[09:30:11.029] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:30:11.029] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:11.030] 
[09:30:11.030] getGlobalsAndPackages() ... DONE
[09:30:11.030] run() for ‘Future’ ...
[09:30:11.030] - state: ‘created’
[09:30:11.031] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:30:11.036] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:11.036] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:30:11.036]   - Field: ‘label’
[09:30:11.036]   - Field: ‘local’
[09:30:11.036]   - Field: ‘owner’
[09:30:11.036]   - Field: ‘envir’
[09:30:11.037]   - Field: ‘workers’
[09:30:11.037]   - Field: ‘packages’
[09:30:11.037]   - Field: ‘gc’
[09:30:11.037]   - Field: ‘job’
[09:30:11.037]   - Field: ‘conditions’
[09:30:11.037]   - Field: ‘expr’
[09:30:11.037]   - Field: ‘uuid’
[09:30:11.038]   - Field: ‘seed’
[09:30:11.038]   - Field: ‘version’
[09:30:11.038]   - Field: ‘result’
[09:30:11.038]   - Field: ‘asynchronous’
[09:30:11.041]   - Field: ‘calls’
[09:30:11.042]   - Field: ‘globals’
[09:30:11.042]   - Field: ‘stdout’
[09:30:11.042]   - Field: ‘earlySignal’
[09:30:11.043]   - Field: ‘lazy’
[09:30:11.043]   - Field: ‘state’
[09:30:11.043] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:30:11.044] - Launch lazy future ...
[09:30:11.044] Packages needed by the future expression (n = 0): <none>
[09:30:11.044] Packages needed by future strategies (n = 0): <none>
[09:30:11.046] {
[09:30:11.046]     {
[09:30:11.046]         {
[09:30:11.046]             ...future.startTime <- base::Sys.time()
[09:30:11.046]             {
[09:30:11.046]                 {
[09:30:11.046]                   {
[09:30:11.046]                     {
[09:30:11.046]                       base::local({
[09:30:11.046]                         has_future <- base::requireNamespace("future", 
[09:30:11.046]                           quietly = TRUE)
[09:30:11.046]                         if (has_future) {
[09:30:11.046]                           ns <- base::getNamespace("future")
[09:30:11.046]                           version <- ns[[".package"]][["version"]]
[09:30:11.046]                           if (is.null(version)) 
[09:30:11.046]                             version <- utils::packageVersion("future")
[09:30:11.046]                         }
[09:30:11.046]                         else {
[09:30:11.046]                           version <- NULL
[09:30:11.046]                         }
[09:30:11.046]                         if (!has_future || version < "1.8.0") {
[09:30:11.046]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:11.046]                             "", base::R.version$version.string), 
[09:30:11.046]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:11.046]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:11.046]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:11.046]                               "release", "version")], collapse = " "), 
[09:30:11.046]                             hostname = base::Sys.info()[["nodename"]])
[09:30:11.046]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:11.046]                             info)
[09:30:11.046]                           info <- base::paste(info, collapse = "; ")
[09:30:11.046]                           if (!has_future) {
[09:30:11.046]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:11.046]                               info)
[09:30:11.046]                           }
[09:30:11.046]                           else {
[09:30:11.046]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:11.046]                               info, version)
[09:30:11.046]                           }
[09:30:11.046]                           base::stop(msg)
[09:30:11.046]                         }
[09:30:11.046]                       })
[09:30:11.046]                     }
[09:30:11.046]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:11.046]                     base::options(mc.cores = 1L)
[09:30:11.046]                   }
[09:30:11.046]                   ...future.strategy.old <- future::plan("list")
[09:30:11.046]                   options(future.plan = NULL)
[09:30:11.046]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:11.046]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:11.046]                 }
[09:30:11.046]                 ...future.workdir <- getwd()
[09:30:11.046]             }
[09:30:11.046]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:11.046]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:11.046]         }
[09:30:11.046]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:11.046]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:11.046]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:11.046]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:11.046]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:11.046]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:11.046]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:11.046]             base::names(...future.oldOptions))
[09:30:11.046]     }
[09:30:11.046]     if (FALSE) {
[09:30:11.046]     }
[09:30:11.046]     else {
[09:30:11.046]         if (FALSE) {
[09:30:11.046]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:11.046]                 open = "w")
[09:30:11.046]         }
[09:30:11.046]         else {
[09:30:11.046]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:11.046]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:11.046]         }
[09:30:11.046]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:11.046]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:11.046]             base::sink(type = "output", split = FALSE)
[09:30:11.046]             base::close(...future.stdout)
[09:30:11.046]         }, add = TRUE)
[09:30:11.046]     }
[09:30:11.046]     ...future.frame <- base::sys.nframe()
[09:30:11.046]     ...future.conditions <- base::list()
[09:30:11.046]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:11.046]     if (FALSE) {
[09:30:11.046]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:11.046]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:11.046]     }
[09:30:11.046]     ...future.result <- base::tryCatch({
[09:30:11.046]         base::withCallingHandlers({
[09:30:11.046]             ...future.value <- base::withVisible(base::local({
[09:30:11.046]                 withCallingHandlers({
[09:30:11.046]                   {
[09:30:11.046]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:11.046]                     if (!identical(...future.globals.maxSize.org, 
[09:30:11.046]                       ...future.globals.maxSize)) {
[09:30:11.046]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:11.046]                       on.exit(options(oopts), add = TRUE)
[09:30:11.046]                     }
[09:30:11.046]                     {
[09:30:11.046]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:11.046]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:30:11.046]                         USE.NAMES = FALSE)
[09:30:11.046]                       do.call(mapply, args = args)
[09:30:11.046]                     }
[09:30:11.046]                   }
[09:30:11.046]                 }, immediateCondition = function(cond) {
[09:30:11.046]                   save_rds <- function (object, pathname, ...) 
[09:30:11.046]                   {
[09:30:11.046]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:30:11.046]                     if (file_test("-f", pathname_tmp)) {
[09:30:11.046]                       fi_tmp <- file.info(pathname_tmp)
[09:30:11.046]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:30:11.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:11.046]                         fi_tmp[["mtime"]])
[09:30:11.046]                     }
[09:30:11.046]                     tryCatch({
[09:30:11.046]                       saveRDS(object, file = pathname_tmp, ...)
[09:30:11.046]                     }, error = function(ex) {
[09:30:11.046]                       msg <- conditionMessage(ex)
[09:30:11.046]                       fi_tmp <- file.info(pathname_tmp)
[09:30:11.046]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:30:11.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:11.046]                         fi_tmp[["mtime"]], msg)
[09:30:11.046]                       ex$message <- msg
[09:30:11.046]                       stop(ex)
[09:30:11.046]                     })
[09:30:11.046]                     stopifnot(file_test("-f", pathname_tmp))
[09:30:11.046]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:30:11.046]                     if (!res || file_test("-f", pathname_tmp)) {
[09:30:11.046]                       fi_tmp <- file.info(pathname_tmp)
[09:30:11.046]                       fi <- file.info(pathname)
[09:30:11.046]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:30:11.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:11.046]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:30:11.046]                         fi[["size"]], fi[["mtime"]])
[09:30:11.046]                       stop(msg)
[09:30:11.046]                     }
[09:30:11.046]                     invisible(pathname)
[09:30:11.046]                   }
[09:30:11.046]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:30:11.046]                     rootPath = tempdir()) 
[09:30:11.046]                   {
[09:30:11.046]                     obj <- list(time = Sys.time(), condition = cond)
[09:30:11.046]                     file <- tempfile(pattern = class(cond)[1], 
[09:30:11.046]                       tmpdir = path, fileext = ".rds")
[09:30:11.046]                     save_rds(obj, file)
[09:30:11.046]                   }
[09:30:11.046]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0coFNd/.future/immediateConditions")
[09:30:11.046]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:11.046]                   {
[09:30:11.046]                     inherits <- base::inherits
[09:30:11.046]                     invokeRestart <- base::invokeRestart
[09:30:11.046]                     is.null <- base::is.null
[09:30:11.046]                     muffled <- FALSE
[09:30:11.046]                     if (inherits(cond, "message")) {
[09:30:11.046]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:11.046]                       if (muffled) 
[09:30:11.046]                         invokeRestart("muffleMessage")
[09:30:11.046]                     }
[09:30:11.046]                     else if (inherits(cond, "warning")) {
[09:30:11.046]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:11.046]                       if (muffled) 
[09:30:11.046]                         invokeRestart("muffleWarning")
[09:30:11.046]                     }
[09:30:11.046]                     else if (inherits(cond, "condition")) {
[09:30:11.046]                       if (!is.null(pattern)) {
[09:30:11.046]                         computeRestarts <- base::computeRestarts
[09:30:11.046]                         grepl <- base::grepl
[09:30:11.046]                         restarts <- computeRestarts(cond)
[09:30:11.046]                         for (restart in restarts) {
[09:30:11.046]                           name <- restart$name
[09:30:11.046]                           if (is.null(name)) 
[09:30:11.046]                             next
[09:30:11.046]                           if (!grepl(pattern, name)) 
[09:30:11.046]                             next
[09:30:11.046]                           invokeRestart(restart)
[09:30:11.046]                           muffled <- TRUE
[09:30:11.046]                           break
[09:30:11.046]                         }
[09:30:11.046]                       }
[09:30:11.046]                     }
[09:30:11.046]                     invisible(muffled)
[09:30:11.046]                   }
[09:30:11.046]                   muffleCondition(cond)
[09:30:11.046]                 })
[09:30:11.046]             }))
[09:30:11.046]             future::FutureResult(value = ...future.value$value, 
[09:30:11.046]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:11.046]                   ...future.rng), globalenv = if (FALSE) 
[09:30:11.046]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:11.046]                     ...future.globalenv.names))
[09:30:11.046]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:11.046]         }, condition = base::local({
[09:30:11.046]             c <- base::c
[09:30:11.046]             inherits <- base::inherits
[09:30:11.046]             invokeRestart <- base::invokeRestart
[09:30:11.046]             length <- base::length
[09:30:11.046]             list <- base::list
[09:30:11.046]             seq.int <- base::seq.int
[09:30:11.046]             signalCondition <- base::signalCondition
[09:30:11.046]             sys.calls <- base::sys.calls
[09:30:11.046]             `[[` <- base::`[[`
[09:30:11.046]             `+` <- base::`+`
[09:30:11.046]             `<<-` <- base::`<<-`
[09:30:11.046]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:11.046]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:11.046]                   3L)]
[09:30:11.046]             }
[09:30:11.046]             function(cond) {
[09:30:11.046]                 is_error <- inherits(cond, "error")
[09:30:11.046]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:11.046]                   NULL)
[09:30:11.046]                 if (is_error) {
[09:30:11.046]                   sessionInformation <- function() {
[09:30:11.046]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:11.046]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:11.046]                       search = base::search(), system = base::Sys.info())
[09:30:11.046]                   }
[09:30:11.046]                   ...future.conditions[[length(...future.conditions) + 
[09:30:11.046]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:11.046]                     cond$call), session = sessionInformation(), 
[09:30:11.046]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:11.046]                   signalCondition(cond)
[09:30:11.046]                 }
[09:30:11.046]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:11.046]                 "immediateCondition"))) {
[09:30:11.046]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:11.046]                   ...future.conditions[[length(...future.conditions) + 
[09:30:11.046]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:11.046]                   if (TRUE && !signal) {
[09:30:11.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:11.046]                     {
[09:30:11.046]                       inherits <- base::inherits
[09:30:11.046]                       invokeRestart <- base::invokeRestart
[09:30:11.046]                       is.null <- base::is.null
[09:30:11.046]                       muffled <- FALSE
[09:30:11.046]                       if (inherits(cond, "message")) {
[09:30:11.046]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:11.046]                         if (muffled) 
[09:30:11.046]                           invokeRestart("muffleMessage")
[09:30:11.046]                       }
[09:30:11.046]                       else if (inherits(cond, "warning")) {
[09:30:11.046]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:11.046]                         if (muffled) 
[09:30:11.046]                           invokeRestart("muffleWarning")
[09:30:11.046]                       }
[09:30:11.046]                       else if (inherits(cond, "condition")) {
[09:30:11.046]                         if (!is.null(pattern)) {
[09:30:11.046]                           computeRestarts <- base::computeRestarts
[09:30:11.046]                           grepl <- base::grepl
[09:30:11.046]                           restarts <- computeRestarts(cond)
[09:30:11.046]                           for (restart in restarts) {
[09:30:11.046]                             name <- restart$name
[09:30:11.046]                             if (is.null(name)) 
[09:30:11.046]                               next
[09:30:11.046]                             if (!grepl(pattern, name)) 
[09:30:11.046]                               next
[09:30:11.046]                             invokeRestart(restart)
[09:30:11.046]                             muffled <- TRUE
[09:30:11.046]                             break
[09:30:11.046]                           }
[09:30:11.046]                         }
[09:30:11.046]                       }
[09:30:11.046]                       invisible(muffled)
[09:30:11.046]                     }
[09:30:11.046]                     muffleCondition(cond, pattern = "^muffle")
[09:30:11.046]                   }
[09:30:11.046]                 }
[09:30:11.046]                 else {
[09:30:11.046]                   if (TRUE) {
[09:30:11.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:11.046]                     {
[09:30:11.046]                       inherits <- base::inherits
[09:30:11.046]                       invokeRestart <- base::invokeRestart
[09:30:11.046]                       is.null <- base::is.null
[09:30:11.046]                       muffled <- FALSE
[09:30:11.046]                       if (inherits(cond, "message")) {
[09:30:11.046]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:11.046]                         if (muffled) 
[09:30:11.046]                           invokeRestart("muffleMessage")
[09:30:11.046]                       }
[09:30:11.046]                       else if (inherits(cond, "warning")) {
[09:30:11.046]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:11.046]                         if (muffled) 
[09:30:11.046]                           invokeRestart("muffleWarning")
[09:30:11.046]                       }
[09:30:11.046]                       else if (inherits(cond, "condition")) {
[09:30:11.046]                         if (!is.null(pattern)) {
[09:30:11.046]                           computeRestarts <- base::computeRestarts
[09:30:11.046]                           grepl <- base::grepl
[09:30:11.046]                           restarts <- computeRestarts(cond)
[09:30:11.046]                           for (restart in restarts) {
[09:30:11.046]                             name <- restart$name
[09:30:11.046]                             if (is.null(name)) 
[09:30:11.046]                               next
[09:30:11.046]                             if (!grepl(pattern, name)) 
[09:30:11.046]                               next
[09:30:11.046]                             invokeRestart(restart)
[09:30:11.046]                             muffled <- TRUE
[09:30:11.046]                             break
[09:30:11.046]                           }
[09:30:11.046]                         }
[09:30:11.046]                       }
[09:30:11.046]                       invisible(muffled)
[09:30:11.046]                     }
[09:30:11.046]                     muffleCondition(cond, pattern = "^muffle")
[09:30:11.046]                   }
[09:30:11.046]                 }
[09:30:11.046]             }
[09:30:11.046]         }))
[09:30:11.046]     }, error = function(ex) {
[09:30:11.046]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:11.046]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:11.046]                 ...future.rng), started = ...future.startTime, 
[09:30:11.046]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:11.046]             version = "1.8"), class = "FutureResult")
[09:30:11.046]     }, finally = {
[09:30:11.046]         if (!identical(...future.workdir, getwd())) 
[09:30:11.046]             setwd(...future.workdir)
[09:30:11.046]         {
[09:30:11.046]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:11.046]                 ...future.oldOptions$nwarnings <- NULL
[09:30:11.046]             }
[09:30:11.046]             base::options(...future.oldOptions)
[09:30:11.046]             if (.Platform$OS.type == "windows") {
[09:30:11.046]                 old_names <- names(...future.oldEnvVars)
[09:30:11.046]                 envs <- base::Sys.getenv()
[09:30:11.046]                 names <- names(envs)
[09:30:11.046]                 common <- intersect(names, old_names)
[09:30:11.046]                 added <- setdiff(names, old_names)
[09:30:11.046]                 removed <- setdiff(old_names, names)
[09:30:11.046]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:11.046]                   envs[common]]
[09:30:11.046]                 NAMES <- toupper(changed)
[09:30:11.046]                 args <- list()
[09:30:11.046]                 for (kk in seq_along(NAMES)) {
[09:30:11.046]                   name <- changed[[kk]]
[09:30:11.046]                   NAME <- NAMES[[kk]]
[09:30:11.046]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:11.046]                     next
[09:30:11.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:11.046]                 }
[09:30:11.046]                 NAMES <- toupper(added)
[09:30:11.046]                 for (kk in seq_along(NAMES)) {
[09:30:11.046]                   name <- added[[kk]]
[09:30:11.046]                   NAME <- NAMES[[kk]]
[09:30:11.046]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:11.046]                     next
[09:30:11.046]                   args[[name]] <- ""
[09:30:11.046]                 }
[09:30:11.046]                 NAMES <- toupper(removed)
[09:30:11.046]                 for (kk in seq_along(NAMES)) {
[09:30:11.046]                   name <- removed[[kk]]
[09:30:11.046]                   NAME <- NAMES[[kk]]
[09:30:11.046]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:11.046]                     next
[09:30:11.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:11.046]                 }
[09:30:11.046]                 if (length(args) > 0) 
[09:30:11.046]                   base::do.call(base::Sys.setenv, args = args)
[09:30:11.046]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:11.046]             }
[09:30:11.046]             else {
[09:30:11.046]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:11.046]             }
[09:30:11.046]             {
[09:30:11.046]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:11.046]                   0L) {
[09:30:11.046]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:11.046]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:11.046]                   base::options(opts)
[09:30:11.046]                 }
[09:30:11.046]                 {
[09:30:11.046]                   {
[09:30:11.046]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:11.046]                     NULL
[09:30:11.046]                   }
[09:30:11.046]                   options(future.plan = NULL)
[09:30:11.046]                   if (is.na(NA_character_)) 
[09:30:11.046]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:11.046]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:11.046]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:11.046]                     .init = FALSE)
[09:30:11.046]                 }
[09:30:11.046]             }
[09:30:11.046]         }
[09:30:11.046]     })
[09:30:11.046]     if (TRUE) {
[09:30:11.046]         base::sink(type = "output", split = FALSE)
[09:30:11.046]         if (FALSE) {
[09:30:11.046]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:11.046]         }
[09:30:11.046]         else {
[09:30:11.046]             ...future.result["stdout"] <- base::list(NULL)
[09:30:11.046]         }
[09:30:11.046]         base::close(...future.stdout)
[09:30:11.046]         ...future.stdout <- NULL
[09:30:11.046]     }
[09:30:11.046]     ...future.result$conditions <- ...future.conditions
[09:30:11.046]     ...future.result$finished <- base::Sys.time()
[09:30:11.046]     ...future.result
[09:30:11.046] }
[09:30:11.048] assign_globals() ...
[09:30:11.049] List of 5
[09:30:11.049]  $ ...future.FUN            :function (x, y)  
[09:30:11.049]  $ MoreArgs                 : NULL
[09:30:11.049]  $ ...future.elements_ii    :List of 2
[09:30:11.049]   ..$ :List of 1
[09:30:11.049]   .. ..$ : int 0
[09:30:11.049]   ..$ :List of 1
[09:30:11.049]   .. ..$ : int 1
[09:30:11.049]  $ ...future.seeds_ii       : NULL
[09:30:11.049]  $ ...future.globals.maxSize: NULL
[09:30:11.049]  - attr(*, "where")=List of 5
[09:30:11.049]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:11.049]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:30:11.049]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:11.049]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:11.049]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:11.049]  - attr(*, "resolved")= logi FALSE
[09:30:11.049]  - attr(*, "total_size")= num 6368
[09:30:11.049]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:11.049]  - attr(*, "already-done")= logi TRUE
[09:30:11.056] - reassign environment for ‘...future.FUN’
[09:30:11.057] - copied ‘...future.FUN’ to environment
[09:30:11.057] - copied ‘MoreArgs’ to environment
[09:30:11.057] - copied ‘...future.elements_ii’ to environment
[09:30:11.057] - copied ‘...future.seeds_ii’ to environment
[09:30:11.057] - copied ‘...future.globals.maxSize’ to environment
[09:30:11.057] assign_globals() ... done
[09:30:11.057] requestCore(): workers = 2
[09:30:11.059] MulticoreFuture started
[09:30:11.060] - Launch lazy future ... done
[09:30:11.060] run() for ‘MulticoreFuture’ ... done
[09:30:11.060] Created future:
[09:30:11.061] plan(): Setting new future strategy stack:
[09:30:11.061] List of future strategies:
[09:30:11.061] 1. sequential:
[09:30:11.061]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:11.061]    - tweaked: FALSE
[09:30:11.061]    - call: NULL
[09:30:11.062] plan(): nbrOfWorkers() = 1
[09:30:11.064] plan(): Setting new future strategy stack:
[09:30:11.064] List of future strategies:
[09:30:11.064] 1. multicore:
[09:30:11.064]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:30:11.064]    - tweaked: FALSE
[09:30:11.064]    - call: plan(strategy)
[09:30:11.069] plan(): nbrOfWorkers() = 2
[09:30:11.060] MulticoreFuture:
[09:30:11.060] Label: ‘future_mapply-2’
[09:30:11.060] Expression:
[09:30:11.060] {
[09:30:11.060]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:11.060]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:11.060]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:11.060]         on.exit(options(oopts), add = TRUE)
[09:30:11.060]     }
[09:30:11.060]     {
[09:30:11.060]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:11.060]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:30:11.060]         do.call(mapply, args = args)
[09:30:11.060]     }
[09:30:11.060] }
[09:30:11.060] Lazy evaluation: FALSE
[09:30:11.060] Asynchronous evaluation: TRUE
[09:30:11.060] Local evaluation: TRUE
[09:30:11.060] Environment: R_GlobalEnv
[09:30:11.060] Capture standard output: FALSE
[09:30:11.060] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:11.060] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:11.060] Packages: <none>
[09:30:11.060] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:11.060] Resolved: TRUE
[09:30:11.060] Value: <not collected>
[09:30:11.060] Conditions captured: <none>
[09:30:11.060] Early signaling: FALSE
[09:30:11.060] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:11.060] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:11.071] Chunk #2 of 2 ... DONE
[09:30:11.071] Launching 2 futures (chunks) ... DONE
[09:30:11.071] Resolving 2 futures (chunks) ...
[09:30:11.071] resolve() on list ...
[09:30:11.071]  recursive: 0
[09:30:11.071]  length: 2
[09:30:11.072] 
[09:30:11.082] Future #2
[09:30:11.082] result() for MulticoreFuture ...
[09:30:11.083] result() for MulticoreFuture ...
[09:30:11.084] result() for MulticoreFuture ... done
[09:30:11.084] result() for MulticoreFuture ... done
[09:30:11.084] result() for MulticoreFuture ...
[09:30:11.084] result() for MulticoreFuture ... done
[09:30:11.084] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:30:11.084] - nx: 2
[09:30:11.084] - relay: TRUE
[09:30:11.085] - stdout: TRUE
[09:30:11.085] - signal: TRUE
[09:30:11.085] - resignal: FALSE
[09:30:11.085] - force: TRUE
[09:30:11.085] - relayed: [n=2] FALSE, FALSE
[09:30:11.085] - queued futures: [n=2] FALSE, FALSE
[09:30:11.085]  - until=1
[09:30:11.085]  - relaying element #1
[09:30:11.086] - relayed: [n=2] FALSE, FALSE
[09:30:11.086] - queued futures: [n=2] FALSE, TRUE
[09:30:11.086] signalConditionsASAP(NULL, pos=2) ... done
[09:30:11.086]  length: 1 (resolved future 2)
[09:30:11.515] plan(): Setting new future strategy stack:
[09:30:11.516] List of future strategies:
[09:30:11.516] 1. multicore:
[09:30:11.516]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:30:11.516]    - tweaked: FALSE
[09:30:11.516]    - call: plan(strategy)
[09:30:11.520] plan(): nbrOfWorkers() = 2
[09:30:11.524] Future #1
[09:30:11.525] result() for MulticoreFuture ...
[09:30:11.525] result() for MulticoreFuture ...
[09:30:11.525] result() for MulticoreFuture ... done
[09:30:11.526] result() for MulticoreFuture ... done
[09:30:11.526] result() for MulticoreFuture ...
[09:30:11.526] result() for MulticoreFuture ... done
[09:30:11.526] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:30:11.526] - nx: 2
[09:30:11.526] - relay: TRUE
[09:30:11.526] - stdout: TRUE
[09:30:11.526] - signal: TRUE
[09:30:11.527] - resignal: FALSE
[09:30:11.527] - force: TRUE
[09:30:11.527] - relayed: [n=2] FALSE, FALSE
[09:30:11.527] - queued futures: [n=2] FALSE, TRUE
[09:30:11.527]  - until=1
[09:30:11.527]  - relaying element #1
[09:30:11.527] result() for MulticoreFuture ...
[09:30:11.527] result() for MulticoreFuture ... done
[09:30:11.527] result() for MulticoreFuture ...
[09:30:11.528] result() for MulticoreFuture ... done
[09:30:11.528] result() for MulticoreFuture ...
[09:30:11.528] result() for MulticoreFuture ... done
[09:30:11.528] result() for MulticoreFuture ...
[09:30:11.528] result() for MulticoreFuture ... done
[09:30:11.528] - relayed: [n=2] TRUE, FALSE
[09:30:11.528] - queued futures: [n=2] TRUE, TRUE
[09:30:11.528] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:30:11.529]  length: 0 (resolved future 1)
[09:30:11.529] Relaying remaining futures
[09:30:11.529] signalConditionsASAP(NULL, pos=0) ...
[09:30:11.529] - nx: 2
[09:30:11.529] - relay: TRUE
[09:30:11.529] - stdout: TRUE
[09:30:11.529] - signal: TRUE
[09:30:11.529] - resignal: FALSE
[09:30:11.529] - force: TRUE
[09:30:11.529] - relayed: [n=2] TRUE, FALSE
[09:30:11.530] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:30:11.530]  - relaying element #2
[09:30:11.530] result() for MulticoreFuture ...
[09:30:11.530] result() for MulticoreFuture ... done
[09:30:11.530] result() for MulticoreFuture ...
[09:30:11.530] result() for MulticoreFuture ... done
[09:30:11.530] result() for MulticoreFuture ...
[09:30:11.530] result() for MulticoreFuture ... done
[09:30:11.531] result() for MulticoreFuture ...
[09:30:11.531] result() for MulticoreFuture ... done
[09:30:11.531] - relayed: [n=2] TRUE, TRUE
[09:30:11.531] - queued futures: [n=2] TRUE, TRUE
[09:30:11.531] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[09:30:11.531] resolve() on list ... DONE
[09:30:11.531] result() for MulticoreFuture ...
[09:30:11.531] result() for MulticoreFuture ... done
[09:30:11.531] result() for MulticoreFuture ...
[09:30:11.532] result() for MulticoreFuture ... done
[09:30:11.532] result() for MulticoreFuture ...
[09:30:11.532] result() for MulticoreFuture ... done
[09:30:11.532] result() for MulticoreFuture ...
[09:30:11.532] result() for MulticoreFuture ... done
[09:30:11.532]  - Number of value chunks collected: 2
[09:30:11.532] Resolving 2 futures (chunks) ... DONE
[09:30:11.532] Reducing values from 2 chunks ...
[09:30:11.533]  - Number of values collected after concatenation: 2
[09:30:11.533]  - Number of values expected: 2
[09:30:11.533] Reducing values from 2 chunks ... DONE
[09:30:11.533] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[09:30:11.533] future_mapply() ...
[09:30:11.540] Number of chunks: 2
[09:30:11.540] getGlobalsAndPackagesXApply() ...
[09:30:11.541]  - future.globals: TRUE
[09:30:11.541] getGlobalsAndPackages() ...
[09:30:11.541] Searching for globals...
[09:30:11.543] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[09:30:11.543] Searching for globals ... DONE
[09:30:11.543] Resolving globals: FALSE
[09:30:11.543] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[09:30:11.544] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[09:30:11.544] - globals: [1] ‘FUN’
[09:30:11.544] 
[09:30:11.544] getGlobalsAndPackages() ... DONE
[09:30:11.544]  - globals found/used: [n=1] ‘FUN’
[09:30:11.545]  - needed namespaces: [n=0] 
[09:30:11.545] Finding globals ... DONE
[09:30:11.545] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:30:11.545] List of 2
[09:30:11.545]  $ ...future.FUN:function (x, y)  
[09:30:11.545]  $ MoreArgs     : NULL
[09:30:11.545]  - attr(*, "where")=List of 2
[09:30:11.545]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:11.545]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:30:11.545]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:11.545]  - attr(*, "resolved")= logi FALSE
[09:30:11.545]  - attr(*, "total_size")= num NA
[09:30:11.548] Packages to be attached in all futures: [n=0] 
[09:30:11.548] getGlobalsAndPackagesXApply() ... DONE
[09:30:11.548] Number of futures (= number of chunks): 2
[09:30:11.548] Launching 2 futures (chunks) ...
[09:30:11.549] Chunk #1 of 2 ...
[09:30:11.549]  - Finding globals in '...' for chunk #1 ...
[09:30:11.549] getGlobalsAndPackages() ...
[09:30:11.549] Searching for globals...
[09:30:11.549] 
[09:30:11.549] Searching for globals ... DONE
[09:30:11.549] - globals: [0] <none>
[09:30:11.550] getGlobalsAndPackages() ... DONE
[09:30:11.550]    + additional globals found: [n=0] 
[09:30:11.550]    + additional namespaces needed: [n=0] 
[09:30:11.550]  - Finding globals in '...' for chunk #1 ... DONE
[09:30:11.550]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:11.550]  - seeds: <none>
[09:30:11.550]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:11.550] getGlobalsAndPackages() ...
[09:30:11.550] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:11.550] Resolving globals: FALSE
[09:30:11.551] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[09:30:11.551] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:30:11.551] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:11.551] 
[09:30:11.552] getGlobalsAndPackages() ... DONE
[09:30:11.552] run() for ‘Future’ ...
[09:30:11.552] - state: ‘created’
[09:30:11.552] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:30:11.555] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:11.556] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:30:11.556]   - Field: ‘label’
[09:30:11.556]   - Field: ‘local’
[09:30:11.556]   - Field: ‘owner’
[09:30:11.556]   - Field: ‘envir’
[09:30:11.556]   - Field: ‘workers’
[09:30:11.556]   - Field: ‘packages’
[09:30:11.556]   - Field: ‘gc’
[09:30:11.556]   - Field: ‘job’
[09:30:11.557]   - Field: ‘conditions’
[09:30:11.557]   - Field: ‘expr’
[09:30:11.557]   - Field: ‘uuid’
[09:30:11.557]   - Field: ‘seed’
[09:30:11.557]   - Field: ‘version’
[09:30:11.557]   - Field: ‘result’
[09:30:11.557]   - Field: ‘asynchronous’
[09:30:11.557]   - Field: ‘calls’
[09:30:11.557]   - Field: ‘globals’
[09:30:11.557]   - Field: ‘stdout’
[09:30:11.557]   - Field: ‘earlySignal’
[09:30:11.558]   - Field: ‘lazy’
[09:30:11.558]   - Field: ‘state’
[09:30:11.558] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:30:11.558] - Launch lazy future ...
[09:30:11.558] Packages needed by the future expression (n = 0): <none>
[09:30:11.558] Packages needed by future strategies (n = 0): <none>
[09:30:11.559] {
[09:30:11.559]     {
[09:30:11.559]         {
[09:30:11.559]             ...future.startTime <- base::Sys.time()
[09:30:11.559]             {
[09:30:11.559]                 {
[09:30:11.559]                   {
[09:30:11.559]                     {
[09:30:11.559]                       base::local({
[09:30:11.559]                         has_future <- base::requireNamespace("future", 
[09:30:11.559]                           quietly = TRUE)
[09:30:11.559]                         if (has_future) {
[09:30:11.559]                           ns <- base::getNamespace("future")
[09:30:11.559]                           version <- ns[[".package"]][["version"]]
[09:30:11.559]                           if (is.null(version)) 
[09:30:11.559]                             version <- utils::packageVersion("future")
[09:30:11.559]                         }
[09:30:11.559]                         else {
[09:30:11.559]                           version <- NULL
[09:30:11.559]                         }
[09:30:11.559]                         if (!has_future || version < "1.8.0") {
[09:30:11.559]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:11.559]                             "", base::R.version$version.string), 
[09:30:11.559]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:11.559]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:11.559]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:11.559]                               "release", "version")], collapse = " "), 
[09:30:11.559]                             hostname = base::Sys.info()[["nodename"]])
[09:30:11.559]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:11.559]                             info)
[09:30:11.559]                           info <- base::paste(info, collapse = "; ")
[09:30:11.559]                           if (!has_future) {
[09:30:11.559]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:11.559]                               info)
[09:30:11.559]                           }
[09:30:11.559]                           else {
[09:30:11.559]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:11.559]                               info, version)
[09:30:11.559]                           }
[09:30:11.559]                           base::stop(msg)
[09:30:11.559]                         }
[09:30:11.559]                       })
[09:30:11.559]                     }
[09:30:11.559]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:11.559]                     base::options(mc.cores = 1L)
[09:30:11.559]                   }
[09:30:11.559]                   ...future.strategy.old <- future::plan("list")
[09:30:11.559]                   options(future.plan = NULL)
[09:30:11.559]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:11.559]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:11.559]                 }
[09:30:11.559]                 ...future.workdir <- getwd()
[09:30:11.559]             }
[09:30:11.559]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:11.559]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:11.559]         }
[09:30:11.559]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:11.559]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:11.559]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:11.559]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:11.559]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:11.559]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:11.559]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:11.559]             base::names(...future.oldOptions))
[09:30:11.559]     }
[09:30:11.559]     if (FALSE) {
[09:30:11.559]     }
[09:30:11.559]     else {
[09:30:11.559]         if (TRUE) {
[09:30:11.559]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:11.559]                 open = "w")
[09:30:11.559]         }
[09:30:11.559]         else {
[09:30:11.559]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:11.559]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:11.559]         }
[09:30:11.559]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:11.559]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:11.559]             base::sink(type = "output", split = FALSE)
[09:30:11.559]             base::close(...future.stdout)
[09:30:11.559]         }, add = TRUE)
[09:30:11.559]     }
[09:30:11.559]     ...future.frame <- base::sys.nframe()
[09:30:11.559]     ...future.conditions <- base::list()
[09:30:11.559]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:11.559]     if (FALSE) {
[09:30:11.559]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:11.559]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:11.559]     }
[09:30:11.559]     ...future.result <- base::tryCatch({
[09:30:11.559]         base::withCallingHandlers({
[09:30:11.559]             ...future.value <- base::withVisible(base::local({
[09:30:11.559]                 withCallingHandlers({
[09:30:11.559]                   {
[09:30:11.559]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:11.559]                     if (!identical(...future.globals.maxSize.org, 
[09:30:11.559]                       ...future.globals.maxSize)) {
[09:30:11.559]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:11.559]                       on.exit(options(oopts), add = TRUE)
[09:30:11.559]                     }
[09:30:11.559]                     {
[09:30:11.559]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:11.559]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:30:11.559]                         USE.NAMES = FALSE)
[09:30:11.559]                       do.call(mapply, args = args)
[09:30:11.559]                     }
[09:30:11.559]                   }
[09:30:11.559]                 }, immediateCondition = function(cond) {
[09:30:11.559]                   save_rds <- function (object, pathname, ...) 
[09:30:11.559]                   {
[09:30:11.559]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:30:11.559]                     if (file_test("-f", pathname_tmp)) {
[09:30:11.559]                       fi_tmp <- file.info(pathname_tmp)
[09:30:11.559]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:30:11.559]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:11.559]                         fi_tmp[["mtime"]])
[09:30:11.559]                     }
[09:30:11.559]                     tryCatch({
[09:30:11.559]                       saveRDS(object, file = pathname_tmp, ...)
[09:30:11.559]                     }, error = function(ex) {
[09:30:11.559]                       msg <- conditionMessage(ex)
[09:30:11.559]                       fi_tmp <- file.info(pathname_tmp)
[09:30:11.559]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:30:11.559]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:11.559]                         fi_tmp[["mtime"]], msg)
[09:30:11.559]                       ex$message <- msg
[09:30:11.559]                       stop(ex)
[09:30:11.559]                     })
[09:30:11.559]                     stopifnot(file_test("-f", pathname_tmp))
[09:30:11.559]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:30:11.559]                     if (!res || file_test("-f", pathname_tmp)) {
[09:30:11.559]                       fi_tmp <- file.info(pathname_tmp)
[09:30:11.559]                       fi <- file.info(pathname)
[09:30:11.559]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:30:11.559]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:11.559]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:30:11.559]                         fi[["size"]], fi[["mtime"]])
[09:30:11.559]                       stop(msg)
[09:30:11.559]                     }
[09:30:11.559]                     invisible(pathname)
[09:30:11.559]                   }
[09:30:11.559]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:30:11.559]                     rootPath = tempdir()) 
[09:30:11.559]                   {
[09:30:11.559]                     obj <- list(time = Sys.time(), condition = cond)
[09:30:11.559]                     file <- tempfile(pattern = class(cond)[1], 
[09:30:11.559]                       tmpdir = path, fileext = ".rds")
[09:30:11.559]                     save_rds(obj, file)
[09:30:11.559]                   }
[09:30:11.559]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0coFNd/.future/immediateConditions")
[09:30:11.559]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:11.559]                   {
[09:30:11.559]                     inherits <- base::inherits
[09:30:11.559]                     invokeRestart <- base::invokeRestart
[09:30:11.559]                     is.null <- base::is.null
[09:30:11.559]                     muffled <- FALSE
[09:30:11.559]                     if (inherits(cond, "message")) {
[09:30:11.559]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:11.559]                       if (muffled) 
[09:30:11.559]                         invokeRestart("muffleMessage")
[09:30:11.559]                     }
[09:30:11.559]                     else if (inherits(cond, "warning")) {
[09:30:11.559]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:11.559]                       if (muffled) 
[09:30:11.559]                         invokeRestart("muffleWarning")
[09:30:11.559]                     }
[09:30:11.559]                     else if (inherits(cond, "condition")) {
[09:30:11.559]                       if (!is.null(pattern)) {
[09:30:11.559]                         computeRestarts <- base::computeRestarts
[09:30:11.559]                         grepl <- base::grepl
[09:30:11.559]                         restarts <- computeRestarts(cond)
[09:30:11.559]                         for (restart in restarts) {
[09:30:11.559]                           name <- restart$name
[09:30:11.559]                           if (is.null(name)) 
[09:30:11.559]                             next
[09:30:11.559]                           if (!grepl(pattern, name)) 
[09:30:11.559]                             next
[09:30:11.559]                           invokeRestart(restart)
[09:30:11.559]                           muffled <- TRUE
[09:30:11.559]                           break
[09:30:11.559]                         }
[09:30:11.559]                       }
[09:30:11.559]                     }
[09:30:11.559]                     invisible(muffled)
[09:30:11.559]                   }
[09:30:11.559]                   muffleCondition(cond)
[09:30:11.559]                 })
[09:30:11.559]             }))
[09:30:11.559]             future::FutureResult(value = ...future.value$value, 
[09:30:11.559]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:11.559]                   ...future.rng), globalenv = if (FALSE) 
[09:30:11.559]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:11.559]                     ...future.globalenv.names))
[09:30:11.559]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:11.559]         }, condition = base::local({
[09:30:11.559]             c <- base::c
[09:30:11.559]             inherits <- base::inherits
[09:30:11.559]             invokeRestart <- base::invokeRestart
[09:30:11.559]             length <- base::length
[09:30:11.559]             list <- base::list
[09:30:11.559]             seq.int <- base::seq.int
[09:30:11.559]             signalCondition <- base::signalCondition
[09:30:11.559]             sys.calls <- base::sys.calls
[09:30:11.559]             `[[` <- base::`[[`
[09:30:11.559]             `+` <- base::`+`
[09:30:11.559]             `<<-` <- base::`<<-`
[09:30:11.559]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:11.559]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:11.559]                   3L)]
[09:30:11.559]             }
[09:30:11.559]             function(cond) {
[09:30:11.559]                 is_error <- inherits(cond, "error")
[09:30:11.559]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:11.559]                   NULL)
[09:30:11.559]                 if (is_error) {
[09:30:11.559]                   sessionInformation <- function() {
[09:30:11.559]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:11.559]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:11.559]                       search = base::search(), system = base::Sys.info())
[09:30:11.559]                   }
[09:30:11.559]                   ...future.conditions[[length(...future.conditions) + 
[09:30:11.559]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:11.559]                     cond$call), session = sessionInformation(), 
[09:30:11.559]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:11.559]                   signalCondition(cond)
[09:30:11.559]                 }
[09:30:11.559]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:11.559]                 "immediateCondition"))) {
[09:30:11.559]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:11.559]                   ...future.conditions[[length(...future.conditions) + 
[09:30:11.559]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:11.559]                   if (TRUE && !signal) {
[09:30:11.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:11.559]                     {
[09:30:11.559]                       inherits <- base::inherits
[09:30:11.559]                       invokeRestart <- base::invokeRestart
[09:30:11.559]                       is.null <- base::is.null
[09:30:11.559]                       muffled <- FALSE
[09:30:11.559]                       if (inherits(cond, "message")) {
[09:30:11.559]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:11.559]                         if (muffled) 
[09:30:11.559]                           invokeRestart("muffleMessage")
[09:30:11.559]                       }
[09:30:11.559]                       else if (inherits(cond, "warning")) {
[09:30:11.559]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:11.559]                         if (muffled) 
[09:30:11.559]                           invokeRestart("muffleWarning")
[09:30:11.559]                       }
[09:30:11.559]                       else if (inherits(cond, "condition")) {
[09:30:11.559]                         if (!is.null(pattern)) {
[09:30:11.559]                           computeRestarts <- base::computeRestarts
[09:30:11.559]                           grepl <- base::grepl
[09:30:11.559]                           restarts <- computeRestarts(cond)
[09:30:11.559]                           for (restart in restarts) {
[09:30:11.559]                             name <- restart$name
[09:30:11.559]                             if (is.null(name)) 
[09:30:11.559]                               next
[09:30:11.559]                             if (!grepl(pattern, name)) 
[09:30:11.559]                               next
[09:30:11.559]                             invokeRestart(restart)
[09:30:11.559]                             muffled <- TRUE
[09:30:11.559]                             break
[09:30:11.559]                           }
[09:30:11.559]                         }
[09:30:11.559]                       }
[09:30:11.559]                       invisible(muffled)
[09:30:11.559]                     }
[09:30:11.559]                     muffleCondition(cond, pattern = "^muffle")
[09:30:11.559]                   }
[09:30:11.559]                 }
[09:30:11.559]                 else {
[09:30:11.559]                   if (TRUE) {
[09:30:11.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:11.559]                     {
[09:30:11.559]                       inherits <- base::inherits
[09:30:11.559]                       invokeRestart <- base::invokeRestart
[09:30:11.559]                       is.null <- base::is.null
[09:30:11.559]                       muffled <- FALSE
[09:30:11.559]                       if (inherits(cond, "message")) {
[09:30:11.559]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:11.559]                         if (muffled) 
[09:30:11.559]                           invokeRestart("muffleMessage")
[09:30:11.559]                       }
[09:30:11.559]                       else if (inherits(cond, "warning")) {
[09:30:11.559]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:11.559]                         if (muffled) 
[09:30:11.559]                           invokeRestart("muffleWarning")
[09:30:11.559]                       }
[09:30:11.559]                       else if (inherits(cond, "condition")) {
[09:30:11.559]                         if (!is.null(pattern)) {
[09:30:11.559]                           computeRestarts <- base::computeRestarts
[09:30:11.559]                           grepl <- base::grepl
[09:30:11.559]                           restarts <- computeRestarts(cond)
[09:30:11.559]                           for (restart in restarts) {
[09:30:11.559]                             name <- restart$name
[09:30:11.559]                             if (is.null(name)) 
[09:30:11.559]                               next
[09:30:11.559]                             if (!grepl(pattern, name)) 
[09:30:11.559]                               next
[09:30:11.559]                             invokeRestart(restart)
[09:30:11.559]                             muffled <- TRUE
[09:30:11.559]                             break
[09:30:11.559]                           }
[09:30:11.559]                         }
[09:30:11.559]                       }
[09:30:11.559]                       invisible(muffled)
[09:30:11.559]                     }
[09:30:11.559]                     muffleCondition(cond, pattern = "^muffle")
[09:30:11.559]                   }
[09:30:11.559]                 }
[09:30:11.559]             }
[09:30:11.559]         }))
[09:30:11.559]     }, error = function(ex) {
[09:30:11.559]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:11.559]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:11.559]                 ...future.rng), started = ...future.startTime, 
[09:30:11.559]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:11.559]             version = "1.8"), class = "FutureResult")
[09:30:11.559]     }, finally = {
[09:30:11.559]         if (!identical(...future.workdir, getwd())) 
[09:30:11.559]             setwd(...future.workdir)
[09:30:11.559]         {
[09:30:11.559]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:11.559]                 ...future.oldOptions$nwarnings <- NULL
[09:30:11.559]             }
[09:30:11.559]             base::options(...future.oldOptions)
[09:30:11.559]             if (.Platform$OS.type == "windows") {
[09:30:11.559]                 old_names <- names(...future.oldEnvVars)
[09:30:11.559]                 envs <- base::Sys.getenv()
[09:30:11.559]                 names <- names(envs)
[09:30:11.559]                 common <- intersect(names, old_names)
[09:30:11.559]                 added <- setdiff(names, old_names)
[09:30:11.559]                 removed <- setdiff(old_names, names)
[09:30:11.559]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:11.559]                   envs[common]]
[09:30:11.559]                 NAMES <- toupper(changed)
[09:30:11.559]                 args <- list()
[09:30:11.559]                 for (kk in seq_along(NAMES)) {
[09:30:11.559]                   name <- changed[[kk]]
[09:30:11.559]                   NAME <- NAMES[[kk]]
[09:30:11.559]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:11.559]                     next
[09:30:11.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:11.559]                 }
[09:30:11.559]                 NAMES <- toupper(added)
[09:30:11.559]                 for (kk in seq_along(NAMES)) {
[09:30:11.559]                   name <- added[[kk]]
[09:30:11.559]                   NAME <- NAMES[[kk]]
[09:30:11.559]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:11.559]                     next
[09:30:11.559]                   args[[name]] <- ""
[09:30:11.559]                 }
[09:30:11.559]                 NAMES <- toupper(removed)
[09:30:11.559]                 for (kk in seq_along(NAMES)) {
[09:30:11.559]                   name <- removed[[kk]]
[09:30:11.559]                   NAME <- NAMES[[kk]]
[09:30:11.559]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:11.559]                     next
[09:30:11.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:11.559]                 }
[09:30:11.559]                 if (length(args) > 0) 
[09:30:11.559]                   base::do.call(base::Sys.setenv, args = args)
[09:30:11.559]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:11.559]             }
[09:30:11.559]             else {
[09:30:11.559]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:11.559]             }
[09:30:11.559]             {
[09:30:11.559]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:11.559]                   0L) {
[09:30:11.559]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:11.559]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:11.559]                   base::options(opts)
[09:30:11.559]                 }
[09:30:11.559]                 {
[09:30:11.559]                   {
[09:30:11.559]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:11.559]                     NULL
[09:30:11.559]                   }
[09:30:11.559]                   options(future.plan = NULL)
[09:30:11.559]                   if (is.na(NA_character_)) 
[09:30:11.559]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:11.559]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:11.559]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:11.559]                     .init = FALSE)
[09:30:11.559]                 }
[09:30:11.559]             }
[09:30:11.559]         }
[09:30:11.559]     })
[09:30:11.559]     if (TRUE) {
[09:30:11.559]         base::sink(type = "output", split = FALSE)
[09:30:11.559]         if (TRUE) {
[09:30:11.559]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:11.559]         }
[09:30:11.559]         else {
[09:30:11.559]             ...future.result["stdout"] <- base::list(NULL)
[09:30:11.559]         }
[09:30:11.559]         base::close(...future.stdout)
[09:30:11.559]         ...future.stdout <- NULL
[09:30:11.559]     }
[09:30:11.559]     ...future.result$conditions <- ...future.conditions
[09:30:11.559]     ...future.result$finished <- base::Sys.time()
[09:30:11.559]     ...future.result
[09:30:11.559] }
[09:30:11.561] assign_globals() ...
[09:30:11.561] List of 5
[09:30:11.561]  $ ...future.FUN            :function (x, y)  
[09:30:11.561]  $ MoreArgs                 : NULL
[09:30:11.561]  $ ...future.elements_ii    :List of 2
[09:30:11.561]   ..$ :List of 1
[09:30:11.561]   .. ..$ : int 1
[09:30:11.561]   ..$ :List of 1
[09:30:11.561]   .. ..$ : int 0
[09:30:11.561]  $ ...future.seeds_ii       : NULL
[09:30:11.561]  $ ...future.globals.maxSize: NULL
[09:30:11.561]  - attr(*, "where")=List of 5
[09:30:11.561]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:11.561]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:30:11.561]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:11.561]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:11.561]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:11.561]  - attr(*, "resolved")= logi FALSE
[09:30:11.561]  - attr(*, "total_size")= num 6368
[09:30:11.561]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:11.561]  - attr(*, "already-done")= logi TRUE
[09:30:11.567] - reassign environment for ‘...future.FUN’
[09:30:11.567] - copied ‘...future.FUN’ to environment
[09:30:11.567] - copied ‘MoreArgs’ to environment
[09:30:11.567] - copied ‘...future.elements_ii’ to environment
[09:30:11.568] - copied ‘...future.seeds_ii’ to environment
[09:30:11.568] - copied ‘...future.globals.maxSize’ to environment
[09:30:11.568] assign_globals() ... done
[09:30:11.568] requestCore(): workers = 2
[09:30:11.570] MulticoreFuture started
[09:30:11.571] - Launch lazy future ... done
[09:30:11.571] run() for ‘MulticoreFuture’ ... done
[09:30:11.571] plan(): Setting new future strategy stack:
[09:30:11.572] Created future:
[09:30:11.572] List of future strategies:
[09:30:11.572] 1. sequential:
[09:30:11.572]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:11.572]    - tweaked: FALSE
[09:30:11.572]    - call: NULL
[09:30:11.574] plan(): nbrOfWorkers() = 1
[09:30:11.572] MulticoreFuture:
[09:30:11.572] Label: ‘future_mapply-1’
[09:30:11.572] Expression:
[09:30:11.572] {
[09:30:11.572]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:11.572]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:11.572]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:11.572]         on.exit(options(oopts), add = TRUE)
[09:30:11.572]     }
[09:30:11.572]     {
[09:30:11.572]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:11.572]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:30:11.572]         do.call(mapply, args = args)
[09:30:11.572]     }
[09:30:11.572] }
[09:30:11.572] Lazy evaluation: FALSE
[09:30:11.572] Asynchronous evaluation: TRUE
[09:30:11.572] Local evaluation: TRUE
[09:30:11.572] Environment: R_GlobalEnv
[09:30:11.572] Capture standard output: TRUE
[09:30:11.572] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:11.572] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:11.572] Packages: <none>
[09:30:11.572] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:11.572] Resolved: FALSE
[09:30:11.572] Value: <not collected>
[09:30:11.572] Conditions captured: <none>
[09:30:11.572] Early signaling: FALSE
[09:30:11.572] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:11.572] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:11.585] Chunk #1 of 2 ... DONE
[09:30:11.586] Chunk #2 of 2 ...
[09:30:11.586]  - Finding globals in '...' for chunk #2 ...
[09:30:11.586] getGlobalsAndPackages() ...
[09:30:11.586] Searching for globals...
[09:30:11.587] 
[09:30:11.587] Searching for globals ... DONE
[09:30:11.587] - globals: [0] <none>
[09:30:11.587] getGlobalsAndPackages() ... DONE
[09:30:11.588]    + additional globals found: [n=0] 
[09:30:11.588]    + additional namespaces needed: [n=0] 
[09:30:11.588]  - Finding globals in '...' for chunk #2 ... DONE
[09:30:11.588]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:11.588]  - seeds: <none>
[09:30:11.589]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:11.589] getGlobalsAndPackages() ...
[09:30:11.589] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:11.589] Resolving globals: FALSE
[09:30:11.590] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[09:30:11.591] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:30:11.591] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:11.591] 
[09:30:11.591] getGlobalsAndPackages() ... DONE
[09:30:11.592] run() for ‘Future’ ...
[09:30:11.592] - state: ‘created’
[09:30:11.592] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:30:11.597] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:11.597] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:30:11.597]   - Field: ‘label’
[09:30:11.598]   - Field: ‘local’
[09:30:11.598]   - Field: ‘owner’
[09:30:11.598]   - Field: ‘envir’
[09:30:11.598]   - Field: ‘workers’
[09:30:11.598]   - Field: ‘packages’
[09:30:11.598]   - Field: ‘gc’
[09:30:11.598]   - Field: ‘job’
[09:30:11.599]   - Field: ‘conditions’
[09:30:11.599]   - Field: ‘expr’
[09:30:11.599]   - Field: ‘uuid’
[09:30:11.599]   - Field: ‘seed’
[09:30:11.599]   - Field: ‘version’
[09:30:11.599]   - Field: ‘result’
[09:30:11.599]   - Field: ‘asynchronous’
[09:30:11.599]   - Field: ‘calls’
[09:30:11.600]   - Field: ‘globals’
[09:30:11.600]   - Field: ‘stdout’
[09:30:11.600]   - Field: ‘earlySignal’
[09:30:11.600]   - Field: ‘lazy’
[09:30:11.600]   - Field: ‘state’
[09:30:11.600] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:30:11.600] - Launch lazy future ...
[09:30:11.601] Packages needed by the future expression (n = 0): <none>
[09:30:11.601] Packages needed by future strategies (n = 0): <none>
[09:30:11.602] {
[09:30:11.602]     {
[09:30:11.602]         {
[09:30:11.602]             ...future.startTime <- base::Sys.time()
[09:30:11.602]             {
[09:30:11.602]                 {
[09:30:11.602]                   {
[09:30:11.602]                     {
[09:30:11.602]                       base::local({
[09:30:11.602]                         has_future <- base::requireNamespace("future", 
[09:30:11.602]                           quietly = TRUE)
[09:30:11.602]                         if (has_future) {
[09:30:11.602]                           ns <- base::getNamespace("future")
[09:30:11.602]                           version <- ns[[".package"]][["version"]]
[09:30:11.602]                           if (is.null(version)) 
[09:30:11.602]                             version <- utils::packageVersion("future")
[09:30:11.602]                         }
[09:30:11.602]                         else {
[09:30:11.602]                           version <- NULL
[09:30:11.602]                         }
[09:30:11.602]                         if (!has_future || version < "1.8.0") {
[09:30:11.602]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:11.602]                             "", base::R.version$version.string), 
[09:30:11.602]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:11.602]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:11.602]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:11.602]                               "release", "version")], collapse = " "), 
[09:30:11.602]                             hostname = base::Sys.info()[["nodename"]])
[09:30:11.602]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:11.602]                             info)
[09:30:11.602]                           info <- base::paste(info, collapse = "; ")
[09:30:11.602]                           if (!has_future) {
[09:30:11.602]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:11.602]                               info)
[09:30:11.602]                           }
[09:30:11.602]                           else {
[09:30:11.602]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:11.602]                               info, version)
[09:30:11.602]                           }
[09:30:11.602]                           base::stop(msg)
[09:30:11.602]                         }
[09:30:11.602]                       })
[09:30:11.602]                     }
[09:30:11.602]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:11.602]                     base::options(mc.cores = 1L)
[09:30:11.602]                   }
[09:30:11.602]                   ...future.strategy.old <- future::plan("list")
[09:30:11.602]                   options(future.plan = NULL)
[09:30:11.602]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:11.602]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:11.602]                 }
[09:30:11.602]                 ...future.workdir <- getwd()
[09:30:11.602]             }
[09:30:11.602]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:11.602]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:11.602]         }
[09:30:11.602]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:11.602]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:11.602]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:11.602]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:11.602]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:11.602]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:11.602]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:11.602]             base::names(...future.oldOptions))
[09:30:11.602]     }
[09:30:11.602]     if (FALSE) {
[09:30:11.602]     }
[09:30:11.602]     else {
[09:30:11.602]         if (TRUE) {
[09:30:11.602]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:11.602]                 open = "w")
[09:30:11.602]         }
[09:30:11.602]         else {
[09:30:11.602]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:11.602]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:11.602]         }
[09:30:11.602]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:11.602]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:11.602]             base::sink(type = "output", split = FALSE)
[09:30:11.602]             base::close(...future.stdout)
[09:30:11.602]         }, add = TRUE)
[09:30:11.602]     }
[09:30:11.602]     ...future.frame <- base::sys.nframe()
[09:30:11.602]     ...future.conditions <- base::list()
[09:30:11.602]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:11.602]     if (FALSE) {
[09:30:11.602]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:11.602]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:11.602]     }
[09:30:11.602]     ...future.result <- base::tryCatch({
[09:30:11.602]         base::withCallingHandlers({
[09:30:11.602]             ...future.value <- base::withVisible(base::local({
[09:30:11.602]                 withCallingHandlers({
[09:30:11.602]                   {
[09:30:11.602]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:11.602]                     if (!identical(...future.globals.maxSize.org, 
[09:30:11.602]                       ...future.globals.maxSize)) {
[09:30:11.602]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:11.602]                       on.exit(options(oopts), add = TRUE)
[09:30:11.602]                     }
[09:30:11.602]                     {
[09:30:11.602]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:11.602]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:30:11.602]                         USE.NAMES = FALSE)
[09:30:11.602]                       do.call(mapply, args = args)
[09:30:11.602]                     }
[09:30:11.602]                   }
[09:30:11.602]                 }, immediateCondition = function(cond) {
[09:30:11.602]                   save_rds <- function (object, pathname, ...) 
[09:30:11.602]                   {
[09:30:11.602]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:30:11.602]                     if (file_test("-f", pathname_tmp)) {
[09:30:11.602]                       fi_tmp <- file.info(pathname_tmp)
[09:30:11.602]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:30:11.602]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:11.602]                         fi_tmp[["mtime"]])
[09:30:11.602]                     }
[09:30:11.602]                     tryCatch({
[09:30:11.602]                       saveRDS(object, file = pathname_tmp, ...)
[09:30:11.602]                     }, error = function(ex) {
[09:30:11.602]                       msg <- conditionMessage(ex)
[09:30:11.602]                       fi_tmp <- file.info(pathname_tmp)
[09:30:11.602]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:30:11.602]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:11.602]                         fi_tmp[["mtime"]], msg)
[09:30:11.602]                       ex$message <- msg
[09:30:11.602]                       stop(ex)
[09:30:11.602]                     })
[09:30:11.602]                     stopifnot(file_test("-f", pathname_tmp))
[09:30:11.602]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:30:11.602]                     if (!res || file_test("-f", pathname_tmp)) {
[09:30:11.602]                       fi_tmp <- file.info(pathname_tmp)
[09:30:11.602]                       fi <- file.info(pathname)
[09:30:11.602]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:30:11.602]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:11.602]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:30:11.602]                         fi[["size"]], fi[["mtime"]])
[09:30:11.602]                       stop(msg)
[09:30:11.602]                     }
[09:30:11.602]                     invisible(pathname)
[09:30:11.602]                   }
[09:30:11.602]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:30:11.602]                     rootPath = tempdir()) 
[09:30:11.602]                   {
[09:30:11.602]                     obj <- list(time = Sys.time(), condition = cond)
[09:30:11.602]                     file <- tempfile(pattern = class(cond)[1], 
[09:30:11.602]                       tmpdir = path, fileext = ".rds")
[09:30:11.602]                     save_rds(obj, file)
[09:30:11.602]                   }
[09:30:11.602]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0coFNd/.future/immediateConditions")
[09:30:11.602]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:11.602]                   {
[09:30:11.602]                     inherits <- base::inherits
[09:30:11.602]                     invokeRestart <- base::invokeRestart
[09:30:11.602]                     is.null <- base::is.null
[09:30:11.602]                     muffled <- FALSE
[09:30:11.602]                     if (inherits(cond, "message")) {
[09:30:11.602]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:11.602]                       if (muffled) 
[09:30:11.602]                         invokeRestart("muffleMessage")
[09:30:11.602]                     }
[09:30:11.602]                     else if (inherits(cond, "warning")) {
[09:30:11.602]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:11.602]                       if (muffled) 
[09:30:11.602]                         invokeRestart("muffleWarning")
[09:30:11.602]                     }
[09:30:11.602]                     else if (inherits(cond, "condition")) {
[09:30:11.602]                       if (!is.null(pattern)) {
[09:30:11.602]                         computeRestarts <- base::computeRestarts
[09:30:11.602]                         grepl <- base::grepl
[09:30:11.602]                         restarts <- computeRestarts(cond)
[09:30:11.602]                         for (restart in restarts) {
[09:30:11.602]                           name <- restart$name
[09:30:11.602]                           if (is.null(name)) 
[09:30:11.602]                             next
[09:30:11.602]                           if (!grepl(pattern, name)) 
[09:30:11.602]                             next
[09:30:11.602]                           invokeRestart(restart)
[09:30:11.602]                           muffled <- TRUE
[09:30:11.602]                           break
[09:30:11.602]                         }
[09:30:11.602]                       }
[09:30:11.602]                     }
[09:30:11.602]                     invisible(muffled)
[09:30:11.602]                   }
[09:30:11.602]                   muffleCondition(cond)
[09:30:11.602]                 })
[09:30:11.602]             }))
[09:30:11.602]             future::FutureResult(value = ...future.value$value, 
[09:30:11.602]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:11.602]                   ...future.rng), globalenv = if (FALSE) 
[09:30:11.602]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:11.602]                     ...future.globalenv.names))
[09:30:11.602]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:11.602]         }, condition = base::local({
[09:30:11.602]             c <- base::c
[09:30:11.602]             inherits <- base::inherits
[09:30:11.602]             invokeRestart <- base::invokeRestart
[09:30:11.602]             length <- base::length
[09:30:11.602]             list <- base::list
[09:30:11.602]             seq.int <- base::seq.int
[09:30:11.602]             signalCondition <- base::signalCondition
[09:30:11.602]             sys.calls <- base::sys.calls
[09:30:11.602]             `[[` <- base::`[[`
[09:30:11.602]             `+` <- base::`+`
[09:30:11.602]             `<<-` <- base::`<<-`
[09:30:11.602]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:11.602]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:11.602]                   3L)]
[09:30:11.602]             }
[09:30:11.602]             function(cond) {
[09:30:11.602]                 is_error <- inherits(cond, "error")
[09:30:11.602]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:11.602]                   NULL)
[09:30:11.602]                 if (is_error) {
[09:30:11.602]                   sessionInformation <- function() {
[09:30:11.602]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:11.602]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:11.602]                       search = base::search(), system = base::Sys.info())
[09:30:11.602]                   }
[09:30:11.602]                   ...future.conditions[[length(...future.conditions) + 
[09:30:11.602]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:11.602]                     cond$call), session = sessionInformation(), 
[09:30:11.602]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:11.602]                   signalCondition(cond)
[09:30:11.602]                 }
[09:30:11.602]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:11.602]                 "immediateCondition"))) {
[09:30:11.602]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:11.602]                   ...future.conditions[[length(...future.conditions) + 
[09:30:11.602]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:11.602]                   if (TRUE && !signal) {
[09:30:11.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:11.602]                     {
[09:30:11.602]                       inherits <- base::inherits
[09:30:11.602]                       invokeRestart <- base::invokeRestart
[09:30:11.602]                       is.null <- base::is.null
[09:30:11.602]                       muffled <- FALSE
[09:30:11.602]                       if (inherits(cond, "message")) {
[09:30:11.602]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:11.602]                         if (muffled) 
[09:30:11.602]                           invokeRestart("muffleMessage")
[09:30:11.602]                       }
[09:30:11.602]                       else if (inherits(cond, "warning")) {
[09:30:11.602]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:11.602]                         if (muffled) 
[09:30:11.602]                           invokeRestart("muffleWarning")
[09:30:11.602]                       }
[09:30:11.602]                       else if (inherits(cond, "condition")) {
[09:30:11.602]                         if (!is.null(pattern)) {
[09:30:11.602]                           computeRestarts <- base::computeRestarts
[09:30:11.602]                           grepl <- base::grepl
[09:30:11.602]                           restarts <- computeRestarts(cond)
[09:30:11.602]                           for (restart in restarts) {
[09:30:11.602]                             name <- restart$name
[09:30:11.602]                             if (is.null(name)) 
[09:30:11.602]                               next
[09:30:11.602]                             if (!grepl(pattern, name)) 
[09:30:11.602]                               next
[09:30:11.602]                             invokeRestart(restart)
[09:30:11.602]                             muffled <- TRUE
[09:30:11.602]                             break
[09:30:11.602]                           }
[09:30:11.602]                         }
[09:30:11.602]                       }
[09:30:11.602]                       invisible(muffled)
[09:30:11.602]                     }
[09:30:11.602]                     muffleCondition(cond, pattern = "^muffle")
[09:30:11.602]                   }
[09:30:11.602]                 }
[09:30:11.602]                 else {
[09:30:11.602]                   if (TRUE) {
[09:30:11.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:11.602]                     {
[09:30:11.602]                       inherits <- base::inherits
[09:30:11.602]                       invokeRestart <- base::invokeRestart
[09:30:11.602]                       is.null <- base::is.null
[09:30:11.602]                       muffled <- FALSE
[09:30:11.602]                       if (inherits(cond, "message")) {
[09:30:11.602]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:11.602]                         if (muffled) 
[09:30:11.602]                           invokeRestart("muffleMessage")
[09:30:11.602]                       }
[09:30:11.602]                       else if (inherits(cond, "warning")) {
[09:30:11.602]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:11.602]                         if (muffled) 
[09:30:11.602]                           invokeRestart("muffleWarning")
[09:30:11.602]                       }
[09:30:11.602]                       else if (inherits(cond, "condition")) {
[09:30:11.602]                         if (!is.null(pattern)) {
[09:30:11.602]                           computeRestarts <- base::computeRestarts
[09:30:11.602]                           grepl <- base::grepl
[09:30:11.602]                           restarts <- computeRestarts(cond)
[09:30:11.602]                           for (restart in restarts) {
[09:30:11.602]                             name <- restart$name
[09:30:11.602]                             if (is.null(name)) 
[09:30:11.602]                               next
[09:30:11.602]                             if (!grepl(pattern, name)) 
[09:30:11.602]                               next
[09:30:11.602]                             invokeRestart(restart)
[09:30:11.602]                             muffled <- TRUE
[09:30:11.602]                             break
[09:30:11.602]                           }
[09:30:11.602]                         }
[09:30:11.602]                       }
[09:30:11.602]                       invisible(muffled)
[09:30:11.602]                     }
[09:30:11.602]                     muffleCondition(cond, pattern = "^muffle")
[09:30:11.602]                   }
[09:30:11.602]                 }
[09:30:11.602]             }
[09:30:11.602]         }))
[09:30:11.602]     }, error = function(ex) {
[09:30:11.602]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:11.602]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:11.602]                 ...future.rng), started = ...future.startTime, 
[09:30:11.602]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:11.602]             version = "1.8"), class = "FutureResult")
[09:30:11.602]     }, finally = {
[09:30:11.602]         if (!identical(...future.workdir, getwd())) 
[09:30:11.602]             setwd(...future.workdir)
[09:30:11.602]         {
[09:30:11.602]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:11.602]                 ...future.oldOptions$nwarnings <- NULL
[09:30:11.602]             }
[09:30:11.602]             base::options(...future.oldOptions)
[09:30:11.602]             if (.Platform$OS.type == "windows") {
[09:30:11.602]                 old_names <- names(...future.oldEnvVars)
[09:30:11.602]                 envs <- base::Sys.getenv()
[09:30:11.602]                 names <- names(envs)
[09:30:11.602]                 common <- intersect(names, old_names)
[09:30:11.602]                 added <- setdiff(names, old_names)
[09:30:11.602]                 removed <- setdiff(old_names, names)
[09:30:11.602]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:11.602]                   envs[common]]
[09:30:11.602]                 NAMES <- toupper(changed)
[09:30:11.602]                 args <- list()
[09:30:11.602]                 for (kk in seq_along(NAMES)) {
[09:30:11.602]                   name <- changed[[kk]]
[09:30:11.602]                   NAME <- NAMES[[kk]]
[09:30:11.602]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:11.602]                     next
[09:30:11.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:11.602]                 }
[09:30:11.602]                 NAMES <- toupper(added)
[09:30:11.602]                 for (kk in seq_along(NAMES)) {
[09:30:11.602]                   name <- added[[kk]]
[09:30:11.602]                   NAME <- NAMES[[kk]]
[09:30:11.602]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:11.602]                     next
[09:30:11.602]                   args[[name]] <- ""
[09:30:11.602]                 }
[09:30:11.602]                 NAMES <- toupper(removed)
[09:30:11.602]                 for (kk in seq_along(NAMES)) {
[09:30:11.602]                   name <- removed[[kk]]
[09:30:11.602]                   NAME <- NAMES[[kk]]
[09:30:11.602]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:11.602]                     next
[09:30:11.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:11.602]                 }
[09:30:11.602]                 if (length(args) > 0) 
[09:30:11.602]                   base::do.call(base::Sys.setenv, args = args)
[09:30:11.602]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:11.602]             }
[09:30:11.602]             else {
[09:30:11.602]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:11.602]             }
[09:30:11.602]             {
[09:30:11.602]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:11.602]                   0L) {
[09:30:11.602]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:11.602]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:11.602]                   base::options(opts)
[09:30:11.602]                 }
[09:30:11.602]                 {
[09:30:11.602]                   {
[09:30:11.602]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:11.602]                     NULL
[09:30:11.602]                   }
[09:30:11.602]                   options(future.plan = NULL)
[09:30:11.602]                   if (is.na(NA_character_)) 
[09:30:11.602]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:11.602]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:11.602]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:11.602]                     .init = FALSE)
[09:30:11.602]                 }
[09:30:11.602]             }
[09:30:11.602]         }
[09:30:11.602]     })
[09:30:11.602]     if (TRUE) {
[09:30:11.602]         base::sink(type = "output", split = FALSE)
[09:30:11.602]         if (TRUE) {
[09:30:11.602]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:11.602]         }
[09:30:11.602]         else {
[09:30:11.602]             ...future.result["stdout"] <- base::list(NULL)
[09:30:11.602]         }
[09:30:11.602]         base::close(...future.stdout)
[09:30:11.602]         ...future.stdout <- NULL
[09:30:11.602]     }
[09:30:11.602]     ...future.result$conditions <- ...future.conditions
[09:30:11.602]     ...future.result$finished <- base::Sys.time()
[09:30:11.602]     ...future.result
[09:30:11.602] }
[09:30:11.605] assign_globals() ...
[09:30:11.605] List of 5
[09:30:11.605]  $ ...future.FUN            :function (x, y)  
[09:30:11.605]  $ MoreArgs                 : NULL
[09:30:11.605]  $ ...future.elements_ii    :List of 2
[09:30:11.605]   ..$ :List of 1
[09:30:11.605]   .. ..$ : int 0
[09:30:11.605]   ..$ :List of 1
[09:30:11.605]   .. ..$ : int 1
[09:30:11.605]  $ ...future.seeds_ii       : NULL
[09:30:11.605]  $ ...future.globals.maxSize: NULL
[09:30:11.605]  - attr(*, "where")=List of 5
[09:30:11.605]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:11.605]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:30:11.605]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:11.605]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:11.605]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:11.605]  - attr(*, "resolved")= logi FALSE
[09:30:11.605]  - attr(*, "total_size")= num 6368
[09:30:11.605]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:11.605]  - attr(*, "already-done")= logi TRUE
[09:30:11.612] - reassign environment for ‘...future.FUN’
[09:30:11.612] - copied ‘...future.FUN’ to environment
[09:30:11.612] - copied ‘MoreArgs’ to environment
[09:30:11.613] - copied ‘...future.elements_ii’ to environment
[09:30:11.613] - copied ‘...future.seeds_ii’ to environment
[09:30:11.613] - copied ‘...future.globals.maxSize’ to environment
[09:30:11.613] assign_globals() ... done
[09:30:11.613] requestCore(): workers = 2
[09:30:11.615] MulticoreFuture started
[09:30:11.616] - Launch lazy future ... done
[09:30:11.616] run() for ‘MulticoreFuture’ ... done
[09:30:11.616] Created future:
[09:30:11.616] plan(): Setting new future strategy stack:
[09:30:11.617] List of future strategies:
[09:30:11.617] 1. sequential:
[09:30:11.617]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:11.617]    - tweaked: FALSE
[09:30:11.617]    - call: NULL
[09:30:11.618] plan(): nbrOfWorkers() = 1
[09:30:11.620] plan(): Setting new future strategy stack:
[09:30:11.620] List of future strategies:
[09:30:11.620] 1. multicore:
[09:30:11.620]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:30:11.620]    - tweaked: FALSE
[09:30:11.620]    - call: plan(strategy)
[09:30:11.625] plan(): nbrOfWorkers() = 2
[09:30:11.616] MulticoreFuture:
[09:30:11.616] Label: ‘future_mapply-2’
[09:30:11.616] Expression:
[09:30:11.616] {
[09:30:11.616]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:11.616]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:11.616]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:11.616]         on.exit(options(oopts), add = TRUE)
[09:30:11.616]     }
[09:30:11.616]     {
[09:30:11.616]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:11.616]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:30:11.616]         do.call(mapply, args = args)
[09:30:11.616]     }
[09:30:11.616] }
[09:30:11.616] Lazy evaluation: FALSE
[09:30:11.616] Asynchronous evaluation: TRUE
[09:30:11.616] Local evaluation: TRUE
[09:30:11.616] Environment: R_GlobalEnv
[09:30:11.616] Capture standard output: TRUE
[09:30:11.616] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:11.616] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:11.616] Packages: <none>
[09:30:11.616] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:11.616] Resolved: TRUE
[09:30:11.616] Value: <not collected>
[09:30:11.616] Conditions captured: <none>
[09:30:11.616] Early signaling: FALSE
[09:30:11.616] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:11.616] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:11.626] Chunk #2 of 2 ... DONE
[09:30:11.626] Launching 2 futures (chunks) ... DONE
[09:30:11.626] Resolving 2 futures (chunks) ...
[09:30:11.626] resolve() on list ...
[09:30:11.626]  recursive: 0
[09:30:11.626]  length: 2
[09:30:11.626] 
[09:30:11.637] Future #2
[09:30:11.637] result() for MulticoreFuture ...
[09:30:11.638] result() for MulticoreFuture ...
[09:30:11.638] result() for MulticoreFuture ... done
[09:30:11.638] result() for MulticoreFuture ... done
[09:30:11.639] result() for MulticoreFuture ...
[09:30:11.639] result() for MulticoreFuture ... done
[09:30:11.639] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:30:11.639] - nx: 2
[09:30:11.639] - relay: TRUE
[09:30:11.639] - stdout: TRUE
[09:30:11.639] - signal: TRUE
[09:30:11.640] - resignal: FALSE
[09:30:11.640] - force: TRUE
[09:30:11.640] - relayed: [n=2] FALSE, FALSE
[09:30:11.640] - queued futures: [n=2] FALSE, FALSE
[09:30:11.640]  - until=1
[09:30:11.640]  - relaying element #1
[09:30:11.640] - relayed: [n=2] FALSE, FALSE
[09:30:11.643] - queued futures: [n=2] FALSE, TRUE
[09:30:11.643] signalConditionsASAP(NULL, pos=2) ... done
[09:30:11.644]  length: 1 (resolved future 2)
[09:30:12.077] plan(): Setting new future strategy stack:
[09:30:12.077] List of future strategies:
[09:30:12.077] 1. multicore:
[09:30:12.077]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:30:12.077]    - tweaked: FALSE
[09:30:12.077]    - call: plan(strategy)
[09:30:12.081] plan(): nbrOfWorkers() = 2
[09:30:12.083] Future #1
[09:30:12.084] result() for MulticoreFuture ...
[09:30:12.084] result() for MulticoreFuture ...
[09:30:12.084] result() for MulticoreFuture ... done
[09:30:12.085] result() for MulticoreFuture ... done
[09:30:12.085] result() for MulticoreFuture ...
[09:30:12.085] result() for MulticoreFuture ... done
[09:30:12.085] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:30:12.085] - nx: 2
[09:30:12.085] - relay: TRUE
[09:30:12.085] - stdout: TRUE
[09:30:12.085] - signal: TRUE
[09:30:12.085] - resignal: FALSE
[09:30:12.086] - force: TRUE
[09:30:12.086] - relayed: [n=2] FALSE, FALSE
[09:30:12.086] - queued futures: [n=2] FALSE, TRUE
[09:30:12.086]  - until=1
[09:30:12.086]  - relaying element #1
[09:30:12.086] result() for MulticoreFuture ...
[09:30:12.086] result() for MulticoreFuture ... done
[09:30:12.086] result() for MulticoreFuture ...
[09:30:12.087] result() for MulticoreFuture ... done
[09:30:12.087] result() for MulticoreFuture ...
[09:30:12.087] result() for MulticoreFuture ... done
[09:30:12.087] result() for MulticoreFuture ...
[09:30:12.087] result() for MulticoreFuture ... done
[09:30:12.087] - relayed: [n=2] TRUE, FALSE
[09:30:12.087] - queued futures: [n=2] TRUE, TRUE
[09:30:12.087] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:30:12.088]  length: 0 (resolved future 1)
[09:30:12.088] Relaying remaining futures
[09:30:12.088] signalConditionsASAP(NULL, pos=0) ...
[09:30:12.088] - nx: 2
[09:30:12.088] - relay: TRUE
[09:30:12.088] - stdout: TRUE
[09:30:12.088] - signal: TRUE
[09:30:12.088] - resignal: FALSE
[09:30:12.088] - force: TRUE
[09:30:12.089] - relayed: [n=2] TRUE, FALSE
[09:30:12.089] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:30:12.089]  - relaying element #2
[09:30:12.089] result() for MulticoreFuture ...
[09:30:12.089] result() for MulticoreFuture ... done
[09:30:12.089] result() for MulticoreFuture ...
[09:30:12.089] result() for MulticoreFuture ... done
[09:30:12.089] result() for MulticoreFuture ...
[09:30:12.090] result() for MulticoreFuture ... done
[09:30:12.090] result() for MulticoreFuture ...
[09:30:12.090] result() for MulticoreFuture ... done
[09:30:12.090] - relayed: [n=2] TRUE, TRUE
[09:30:12.090] - queued futures: [n=2] TRUE, TRUE
[09:30:12.090] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[09:30:12.090] resolve() on list ... DONE
[09:30:12.090] result() for MulticoreFuture ...
[09:30:12.090] result() for MulticoreFuture ... done
[09:30:12.091] result() for MulticoreFuture ...
[09:30:12.091] result() for MulticoreFuture ... done
[09:30:12.091] result() for MulticoreFuture ...
[09:30:12.091] result() for MulticoreFuture ... done
[09:30:12.091] result() for MulticoreFuture ...
[09:30:12.091] result() for MulticoreFuture ... done
[09:30:12.091]  - Number of value chunks collected: 2
[09:30:12.091] Resolving 2 futures (chunks) ... DONE
[09:30:12.091] Reducing values from 2 chunks ...
[09:30:12.091]  - Number of values collected after concatenation: 2
[09:30:12.092]  - Number of values expected: 2
[09:30:12.092] Reducing values from 2 chunks ... DONE
[09:30:12.092] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[09:30:12.092] future_mapply() ...
[09:30:12.097] Number of chunks: 2
[09:30:12.097] getGlobalsAndPackagesXApply() ...
[09:30:12.097]  - future.globals: TRUE
[09:30:12.097] getGlobalsAndPackages() ...
[09:30:12.097] Searching for globals...
[09:30:12.099] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[09:30:12.099] Searching for globals ... DONE
[09:30:12.099] Resolving globals: FALSE
[09:30:12.100] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[09:30:12.100] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[09:30:12.100] - globals: [1] ‘FUN’
[09:30:12.100] 
[09:30:12.100] getGlobalsAndPackages() ... DONE
[09:30:12.100]  - globals found/used: [n=1] ‘FUN’
[09:30:12.101]  - needed namespaces: [n=0] 
[09:30:12.101] Finding globals ... DONE
[09:30:12.101] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:30:12.101] List of 2
[09:30:12.101]  $ ...future.FUN:function (x, y)  
[09:30:12.101]  $ MoreArgs     : NULL
[09:30:12.101]  - attr(*, "where")=List of 2
[09:30:12.101]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:12.101]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:30:12.101]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:12.101]  - attr(*, "resolved")= logi FALSE
[09:30:12.101]  - attr(*, "total_size")= num NA
[09:30:12.104] Packages to be attached in all futures: [n=0] 
[09:30:12.104] getGlobalsAndPackagesXApply() ... DONE
[09:30:12.104] Number of futures (= number of chunks): 2
[09:30:12.104] Launching 2 futures (chunks) ...
[09:30:12.104] Chunk #1 of 2 ...
[09:30:12.104]  - Finding globals in '...' for chunk #1 ...
[09:30:12.105] getGlobalsAndPackages() ...
[09:30:12.105] Searching for globals...
[09:30:12.105] 
[09:30:12.105] Searching for globals ... DONE
[09:30:12.105] - globals: [0] <none>
[09:30:12.105] getGlobalsAndPackages() ... DONE
[09:30:12.105]    + additional globals found: [n=0] 
[09:30:12.105]    + additional namespaces needed: [n=0] 
[09:30:12.105]  - Finding globals in '...' for chunk #1 ... DONE
[09:30:12.106]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:12.106]  - seeds: <none>
[09:30:12.106]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:12.106] getGlobalsAndPackages() ...
[09:30:12.106] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:12.106] Resolving globals: FALSE
[09:30:12.106] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[09:30:12.107] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:30:12.107] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:12.107] 
[09:30:12.107] getGlobalsAndPackages() ... DONE
[09:30:12.108] run() for ‘Future’ ...
[09:30:12.108] - state: ‘created’
[09:30:12.108] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:30:12.113] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:12.113] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:30:12.113]   - Field: ‘label’
[09:30:12.113]   - Field: ‘local’
[09:30:12.114]   - Field: ‘owner’
[09:30:12.114]   - Field: ‘envir’
[09:30:12.114]   - Field: ‘workers’
[09:30:12.114]   - Field: ‘packages’
[09:30:12.114]   - Field: ‘gc’
[09:30:12.114]   - Field: ‘job’
[09:30:12.114]   - Field: ‘conditions’
[09:30:12.114]   - Field: ‘expr’
[09:30:12.114]   - Field: ‘uuid’
[09:30:12.114]   - Field: ‘seed’
[09:30:12.115]   - Field: ‘version’
[09:30:12.115]   - Field: ‘result’
[09:30:12.115]   - Field: ‘asynchronous’
[09:30:12.115]   - Field: ‘calls’
[09:30:12.115]   - Field: ‘globals’
[09:30:12.115]   - Field: ‘stdout’
[09:30:12.115]   - Field: ‘earlySignal’
[09:30:12.115]   - Field: ‘lazy’
[09:30:12.115]   - Field: ‘state’
[09:30:12.115] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:30:12.115] - Launch lazy future ...
[09:30:12.116] Packages needed by the future expression (n = 0): <none>
[09:30:12.116] Packages needed by future strategies (n = 0): <none>
[09:30:12.116] {
[09:30:12.116]     {
[09:30:12.116]         {
[09:30:12.116]             ...future.startTime <- base::Sys.time()
[09:30:12.116]             {
[09:30:12.116]                 {
[09:30:12.116]                   {
[09:30:12.116]                     {
[09:30:12.116]                       base::local({
[09:30:12.116]                         has_future <- base::requireNamespace("future", 
[09:30:12.116]                           quietly = TRUE)
[09:30:12.116]                         if (has_future) {
[09:30:12.116]                           ns <- base::getNamespace("future")
[09:30:12.116]                           version <- ns[[".package"]][["version"]]
[09:30:12.116]                           if (is.null(version)) 
[09:30:12.116]                             version <- utils::packageVersion("future")
[09:30:12.116]                         }
[09:30:12.116]                         else {
[09:30:12.116]                           version <- NULL
[09:30:12.116]                         }
[09:30:12.116]                         if (!has_future || version < "1.8.0") {
[09:30:12.116]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:12.116]                             "", base::R.version$version.string), 
[09:30:12.116]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:12.116]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:12.116]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:12.116]                               "release", "version")], collapse = " "), 
[09:30:12.116]                             hostname = base::Sys.info()[["nodename"]])
[09:30:12.116]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:12.116]                             info)
[09:30:12.116]                           info <- base::paste(info, collapse = "; ")
[09:30:12.116]                           if (!has_future) {
[09:30:12.116]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:12.116]                               info)
[09:30:12.116]                           }
[09:30:12.116]                           else {
[09:30:12.116]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:12.116]                               info, version)
[09:30:12.116]                           }
[09:30:12.116]                           base::stop(msg)
[09:30:12.116]                         }
[09:30:12.116]                       })
[09:30:12.116]                     }
[09:30:12.116]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:12.116]                     base::options(mc.cores = 1L)
[09:30:12.116]                   }
[09:30:12.116]                   ...future.strategy.old <- future::plan("list")
[09:30:12.116]                   options(future.plan = NULL)
[09:30:12.116]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:12.116]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:12.116]                 }
[09:30:12.116]                 ...future.workdir <- getwd()
[09:30:12.116]             }
[09:30:12.116]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:12.116]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:12.116]         }
[09:30:12.116]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:12.116]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:12.116]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:12.116]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:12.116]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:12.116]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:12.116]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:12.116]             base::names(...future.oldOptions))
[09:30:12.116]     }
[09:30:12.116]     if (TRUE) {
[09:30:12.116]     }
[09:30:12.116]     else {
[09:30:12.116]         if (NA) {
[09:30:12.116]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:12.116]                 open = "w")
[09:30:12.116]         }
[09:30:12.116]         else {
[09:30:12.116]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:12.116]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:12.116]         }
[09:30:12.116]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:12.116]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:12.116]             base::sink(type = "output", split = FALSE)
[09:30:12.116]             base::close(...future.stdout)
[09:30:12.116]         }, add = TRUE)
[09:30:12.116]     }
[09:30:12.116]     ...future.frame <- base::sys.nframe()
[09:30:12.116]     ...future.conditions <- base::list()
[09:30:12.116]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:12.116]     if (FALSE) {
[09:30:12.116]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:12.116]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:12.116]     }
[09:30:12.116]     ...future.result <- base::tryCatch({
[09:30:12.116]         base::withCallingHandlers({
[09:30:12.116]             ...future.value <- base::withVisible(base::local({
[09:30:12.116]                 withCallingHandlers({
[09:30:12.116]                   {
[09:30:12.116]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:12.116]                     if (!identical(...future.globals.maxSize.org, 
[09:30:12.116]                       ...future.globals.maxSize)) {
[09:30:12.116]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:12.116]                       on.exit(options(oopts), add = TRUE)
[09:30:12.116]                     }
[09:30:12.116]                     {
[09:30:12.116]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:12.116]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:30:12.116]                         USE.NAMES = FALSE)
[09:30:12.116]                       do.call(mapply, args = args)
[09:30:12.116]                     }
[09:30:12.116]                   }
[09:30:12.116]                 }, immediateCondition = function(cond) {
[09:30:12.116]                   save_rds <- function (object, pathname, ...) 
[09:30:12.116]                   {
[09:30:12.116]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:30:12.116]                     if (file_test("-f", pathname_tmp)) {
[09:30:12.116]                       fi_tmp <- file.info(pathname_tmp)
[09:30:12.116]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:30:12.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:12.116]                         fi_tmp[["mtime"]])
[09:30:12.116]                     }
[09:30:12.116]                     tryCatch({
[09:30:12.116]                       saveRDS(object, file = pathname_tmp, ...)
[09:30:12.116]                     }, error = function(ex) {
[09:30:12.116]                       msg <- conditionMessage(ex)
[09:30:12.116]                       fi_tmp <- file.info(pathname_tmp)
[09:30:12.116]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:30:12.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:12.116]                         fi_tmp[["mtime"]], msg)
[09:30:12.116]                       ex$message <- msg
[09:30:12.116]                       stop(ex)
[09:30:12.116]                     })
[09:30:12.116]                     stopifnot(file_test("-f", pathname_tmp))
[09:30:12.116]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:30:12.116]                     if (!res || file_test("-f", pathname_tmp)) {
[09:30:12.116]                       fi_tmp <- file.info(pathname_tmp)
[09:30:12.116]                       fi <- file.info(pathname)
[09:30:12.116]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:30:12.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:12.116]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:30:12.116]                         fi[["size"]], fi[["mtime"]])
[09:30:12.116]                       stop(msg)
[09:30:12.116]                     }
[09:30:12.116]                     invisible(pathname)
[09:30:12.116]                   }
[09:30:12.116]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:30:12.116]                     rootPath = tempdir()) 
[09:30:12.116]                   {
[09:30:12.116]                     obj <- list(time = Sys.time(), condition = cond)
[09:30:12.116]                     file <- tempfile(pattern = class(cond)[1], 
[09:30:12.116]                       tmpdir = path, fileext = ".rds")
[09:30:12.116]                     save_rds(obj, file)
[09:30:12.116]                   }
[09:30:12.116]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0coFNd/.future/immediateConditions")
[09:30:12.116]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:12.116]                   {
[09:30:12.116]                     inherits <- base::inherits
[09:30:12.116]                     invokeRestart <- base::invokeRestart
[09:30:12.116]                     is.null <- base::is.null
[09:30:12.116]                     muffled <- FALSE
[09:30:12.116]                     if (inherits(cond, "message")) {
[09:30:12.116]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:12.116]                       if (muffled) 
[09:30:12.116]                         invokeRestart("muffleMessage")
[09:30:12.116]                     }
[09:30:12.116]                     else if (inherits(cond, "warning")) {
[09:30:12.116]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:12.116]                       if (muffled) 
[09:30:12.116]                         invokeRestart("muffleWarning")
[09:30:12.116]                     }
[09:30:12.116]                     else if (inherits(cond, "condition")) {
[09:30:12.116]                       if (!is.null(pattern)) {
[09:30:12.116]                         computeRestarts <- base::computeRestarts
[09:30:12.116]                         grepl <- base::grepl
[09:30:12.116]                         restarts <- computeRestarts(cond)
[09:30:12.116]                         for (restart in restarts) {
[09:30:12.116]                           name <- restart$name
[09:30:12.116]                           if (is.null(name)) 
[09:30:12.116]                             next
[09:30:12.116]                           if (!grepl(pattern, name)) 
[09:30:12.116]                             next
[09:30:12.116]                           invokeRestart(restart)
[09:30:12.116]                           muffled <- TRUE
[09:30:12.116]                           break
[09:30:12.116]                         }
[09:30:12.116]                       }
[09:30:12.116]                     }
[09:30:12.116]                     invisible(muffled)
[09:30:12.116]                   }
[09:30:12.116]                   muffleCondition(cond)
[09:30:12.116]                 })
[09:30:12.116]             }))
[09:30:12.116]             future::FutureResult(value = ...future.value$value, 
[09:30:12.116]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:12.116]                   ...future.rng), globalenv = if (FALSE) 
[09:30:12.116]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:12.116]                     ...future.globalenv.names))
[09:30:12.116]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:12.116]         }, condition = base::local({
[09:30:12.116]             c <- base::c
[09:30:12.116]             inherits <- base::inherits
[09:30:12.116]             invokeRestart <- base::invokeRestart
[09:30:12.116]             length <- base::length
[09:30:12.116]             list <- base::list
[09:30:12.116]             seq.int <- base::seq.int
[09:30:12.116]             signalCondition <- base::signalCondition
[09:30:12.116]             sys.calls <- base::sys.calls
[09:30:12.116]             `[[` <- base::`[[`
[09:30:12.116]             `+` <- base::`+`
[09:30:12.116]             `<<-` <- base::`<<-`
[09:30:12.116]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:12.116]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:12.116]                   3L)]
[09:30:12.116]             }
[09:30:12.116]             function(cond) {
[09:30:12.116]                 is_error <- inherits(cond, "error")
[09:30:12.116]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:12.116]                   NULL)
[09:30:12.116]                 if (is_error) {
[09:30:12.116]                   sessionInformation <- function() {
[09:30:12.116]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:12.116]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:12.116]                       search = base::search(), system = base::Sys.info())
[09:30:12.116]                   }
[09:30:12.116]                   ...future.conditions[[length(...future.conditions) + 
[09:30:12.116]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:12.116]                     cond$call), session = sessionInformation(), 
[09:30:12.116]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:12.116]                   signalCondition(cond)
[09:30:12.116]                 }
[09:30:12.116]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:12.116]                 "immediateCondition"))) {
[09:30:12.116]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:12.116]                   ...future.conditions[[length(...future.conditions) + 
[09:30:12.116]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:12.116]                   if (TRUE && !signal) {
[09:30:12.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:12.116]                     {
[09:30:12.116]                       inherits <- base::inherits
[09:30:12.116]                       invokeRestart <- base::invokeRestart
[09:30:12.116]                       is.null <- base::is.null
[09:30:12.116]                       muffled <- FALSE
[09:30:12.116]                       if (inherits(cond, "message")) {
[09:30:12.116]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:12.116]                         if (muffled) 
[09:30:12.116]                           invokeRestart("muffleMessage")
[09:30:12.116]                       }
[09:30:12.116]                       else if (inherits(cond, "warning")) {
[09:30:12.116]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:12.116]                         if (muffled) 
[09:30:12.116]                           invokeRestart("muffleWarning")
[09:30:12.116]                       }
[09:30:12.116]                       else if (inherits(cond, "condition")) {
[09:30:12.116]                         if (!is.null(pattern)) {
[09:30:12.116]                           computeRestarts <- base::computeRestarts
[09:30:12.116]                           grepl <- base::grepl
[09:30:12.116]                           restarts <- computeRestarts(cond)
[09:30:12.116]                           for (restart in restarts) {
[09:30:12.116]                             name <- restart$name
[09:30:12.116]                             if (is.null(name)) 
[09:30:12.116]                               next
[09:30:12.116]                             if (!grepl(pattern, name)) 
[09:30:12.116]                               next
[09:30:12.116]                             invokeRestart(restart)
[09:30:12.116]                             muffled <- TRUE
[09:30:12.116]                             break
[09:30:12.116]                           }
[09:30:12.116]                         }
[09:30:12.116]                       }
[09:30:12.116]                       invisible(muffled)
[09:30:12.116]                     }
[09:30:12.116]                     muffleCondition(cond, pattern = "^muffle")
[09:30:12.116]                   }
[09:30:12.116]                 }
[09:30:12.116]                 else {
[09:30:12.116]                   if (TRUE) {
[09:30:12.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:12.116]                     {
[09:30:12.116]                       inherits <- base::inherits
[09:30:12.116]                       invokeRestart <- base::invokeRestart
[09:30:12.116]                       is.null <- base::is.null
[09:30:12.116]                       muffled <- FALSE
[09:30:12.116]                       if (inherits(cond, "message")) {
[09:30:12.116]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:12.116]                         if (muffled) 
[09:30:12.116]                           invokeRestart("muffleMessage")
[09:30:12.116]                       }
[09:30:12.116]                       else if (inherits(cond, "warning")) {
[09:30:12.116]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:12.116]                         if (muffled) 
[09:30:12.116]                           invokeRestart("muffleWarning")
[09:30:12.116]                       }
[09:30:12.116]                       else if (inherits(cond, "condition")) {
[09:30:12.116]                         if (!is.null(pattern)) {
[09:30:12.116]                           computeRestarts <- base::computeRestarts
[09:30:12.116]                           grepl <- base::grepl
[09:30:12.116]                           restarts <- computeRestarts(cond)
[09:30:12.116]                           for (restart in restarts) {
[09:30:12.116]                             name <- restart$name
[09:30:12.116]                             if (is.null(name)) 
[09:30:12.116]                               next
[09:30:12.116]                             if (!grepl(pattern, name)) 
[09:30:12.116]                               next
[09:30:12.116]                             invokeRestart(restart)
[09:30:12.116]                             muffled <- TRUE
[09:30:12.116]                             break
[09:30:12.116]                           }
[09:30:12.116]                         }
[09:30:12.116]                       }
[09:30:12.116]                       invisible(muffled)
[09:30:12.116]                     }
[09:30:12.116]                     muffleCondition(cond, pattern = "^muffle")
[09:30:12.116]                   }
[09:30:12.116]                 }
[09:30:12.116]             }
[09:30:12.116]         }))
[09:30:12.116]     }, error = function(ex) {
[09:30:12.116]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:12.116]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:12.116]                 ...future.rng), started = ...future.startTime, 
[09:30:12.116]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:12.116]             version = "1.8"), class = "FutureResult")
[09:30:12.116]     }, finally = {
[09:30:12.116]         if (!identical(...future.workdir, getwd())) 
[09:30:12.116]             setwd(...future.workdir)
[09:30:12.116]         {
[09:30:12.116]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:12.116]                 ...future.oldOptions$nwarnings <- NULL
[09:30:12.116]             }
[09:30:12.116]             base::options(...future.oldOptions)
[09:30:12.116]             if (.Platform$OS.type == "windows") {
[09:30:12.116]                 old_names <- names(...future.oldEnvVars)
[09:30:12.116]                 envs <- base::Sys.getenv()
[09:30:12.116]                 names <- names(envs)
[09:30:12.116]                 common <- intersect(names, old_names)
[09:30:12.116]                 added <- setdiff(names, old_names)
[09:30:12.116]                 removed <- setdiff(old_names, names)
[09:30:12.116]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:12.116]                   envs[common]]
[09:30:12.116]                 NAMES <- toupper(changed)
[09:30:12.116]                 args <- list()
[09:30:12.116]                 for (kk in seq_along(NAMES)) {
[09:30:12.116]                   name <- changed[[kk]]
[09:30:12.116]                   NAME <- NAMES[[kk]]
[09:30:12.116]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:12.116]                     next
[09:30:12.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:12.116]                 }
[09:30:12.116]                 NAMES <- toupper(added)
[09:30:12.116]                 for (kk in seq_along(NAMES)) {
[09:30:12.116]                   name <- added[[kk]]
[09:30:12.116]                   NAME <- NAMES[[kk]]
[09:30:12.116]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:12.116]                     next
[09:30:12.116]                   args[[name]] <- ""
[09:30:12.116]                 }
[09:30:12.116]                 NAMES <- toupper(removed)
[09:30:12.116]                 for (kk in seq_along(NAMES)) {
[09:30:12.116]                   name <- removed[[kk]]
[09:30:12.116]                   NAME <- NAMES[[kk]]
[09:30:12.116]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:12.116]                     next
[09:30:12.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:12.116]                 }
[09:30:12.116]                 if (length(args) > 0) 
[09:30:12.116]                   base::do.call(base::Sys.setenv, args = args)
[09:30:12.116]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:12.116]             }
[09:30:12.116]             else {
[09:30:12.116]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:12.116]             }
[09:30:12.116]             {
[09:30:12.116]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:12.116]                   0L) {
[09:30:12.116]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:12.116]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:12.116]                   base::options(opts)
[09:30:12.116]                 }
[09:30:12.116]                 {
[09:30:12.116]                   {
[09:30:12.116]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:12.116]                     NULL
[09:30:12.116]                   }
[09:30:12.116]                   options(future.plan = NULL)
[09:30:12.116]                   if (is.na(NA_character_)) 
[09:30:12.116]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:12.116]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:12.116]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:12.116]                     .init = FALSE)
[09:30:12.116]                 }
[09:30:12.116]             }
[09:30:12.116]         }
[09:30:12.116]     })
[09:30:12.116]     if (FALSE) {
[09:30:12.116]         base::sink(type = "output", split = FALSE)
[09:30:12.116]         if (NA) {
[09:30:12.116]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:12.116]         }
[09:30:12.116]         else {
[09:30:12.116]             ...future.result["stdout"] <- base::list(NULL)
[09:30:12.116]         }
[09:30:12.116]         base::close(...future.stdout)
[09:30:12.116]         ...future.stdout <- NULL
[09:30:12.116]     }
[09:30:12.116]     ...future.result$conditions <- ...future.conditions
[09:30:12.116]     ...future.result$finished <- base::Sys.time()
[09:30:12.116]     ...future.result
[09:30:12.116] }
[09:30:12.119] assign_globals() ...
[09:30:12.119] List of 5
[09:30:12.119]  $ ...future.FUN            :function (x, y)  
[09:30:12.119]  $ MoreArgs                 : NULL
[09:30:12.119]  $ ...future.elements_ii    :List of 2
[09:30:12.119]   ..$ :List of 1
[09:30:12.119]   .. ..$ : int 1
[09:30:12.119]   ..$ :List of 1
[09:30:12.119]   .. ..$ : int 0
[09:30:12.119]  $ ...future.seeds_ii       : NULL
[09:30:12.119]  $ ...future.globals.maxSize: NULL
[09:30:12.119]  - attr(*, "where")=List of 5
[09:30:12.119]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:12.119]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:30:12.119]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:12.119]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:12.119]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:12.119]  - attr(*, "resolved")= logi FALSE
[09:30:12.119]  - attr(*, "total_size")= num 6368
[09:30:12.119]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:12.119]  - attr(*, "already-done")= logi TRUE
[09:30:12.124] - reassign environment for ‘...future.FUN’
[09:30:12.124] - copied ‘...future.FUN’ to environment
[09:30:12.124] - copied ‘MoreArgs’ to environment
[09:30:12.124] - copied ‘...future.elements_ii’ to environment
[09:30:12.124] - copied ‘...future.seeds_ii’ to environment
[09:30:12.124] - copied ‘...future.globals.maxSize’ to environment
[09:30:12.124] assign_globals() ... done
[09:30:12.124] requestCore(): workers = 2
[09:30:12.126] MulticoreFuture started
[09:30:12.127] - Launch lazy future ... done
[09:30:12.127] run() for ‘MulticoreFuture’ ... done
[09:30:12.127] Created future:
[09:30:12.127] plan(): Setting new future strategy stack:
[09:30:12.128] List of future strategies:
[09:30:12.128] 1. sequential:
[09:30:12.128]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:12.128]    - tweaked: FALSE
[09:30:12.128]    - call: NULL
[09:30:12.128] plan(): nbrOfWorkers() = 1
[09:30:12.127] MulticoreFuture:
[09:30:12.127] Label: ‘future_mapply-1’
[09:30:12.127] Expression:
[09:30:12.127] {
[09:30:12.127]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:12.127]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:12.127]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:12.127]         on.exit(options(oopts), add = TRUE)
[09:30:12.127]     }
[09:30:12.127]     {
[09:30:12.127]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:12.127]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:30:12.127]         do.call(mapply, args = args)
[09:30:12.127]     }
[09:30:12.127] }
[09:30:12.127] Lazy evaluation: FALSE
[09:30:12.127] Asynchronous evaluation: TRUE
[09:30:12.127] Local evaluation: TRUE
[09:30:12.127] Environment: R_GlobalEnv
[09:30:12.127] Capture standard output: NA
[09:30:12.127] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:12.127] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:12.127] Packages: <none>
[09:30:12.127] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:12.127] Resolved: FALSE
[09:30:12.127] Value: <not collected>
[09:30:12.127] Conditions captured: <none>
[09:30:12.127] Early signaling: FALSE
[09:30:12.127] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:12.127] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:12.140] Chunk #1 of 2 ... DONE
[09:30:12.140] Chunk #2 of 2 ...
[09:30:12.140]  - Finding globals in '...' for chunk #2 ...
[09:30:12.140] getGlobalsAndPackages() ...
[09:30:12.141] Searching for globals...
[09:30:12.141] 
[09:30:12.141] Searching for globals ... DONE
[09:30:12.142] - globals: [0] <none>
[09:30:12.142] getGlobalsAndPackages() ... DONE
[09:30:12.142]    + additional globals found: [n=0] 
[09:30:12.142]    + additional namespaces needed: [n=0] 
[09:30:12.142]  - Finding globals in '...' for chunk #2 ... DONE
[09:30:12.142]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:12.142]  - seeds: <none>
[09:30:12.143]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:12.143] getGlobalsAndPackages() ...
[09:30:12.143] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:12.143] Resolving globals: FALSE
[09:30:12.144] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[09:30:12.145] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:30:12.145] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:12.145] 
[09:30:12.146] getGlobalsAndPackages() ... DONE
[09:30:12.146] run() for ‘Future’ ...
[09:30:12.146] - state: ‘created’
[09:30:12.147] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:30:12.152] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:12.152] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:30:12.152]   - Field: ‘label’
[09:30:12.152]   - Field: ‘local’
[09:30:12.152]   - Field: ‘owner’
[09:30:12.152]   - Field: ‘envir’
[09:30:12.153]   - Field: ‘workers’
[09:30:12.153]   - Field: ‘packages’
[09:30:12.153]   - Field: ‘gc’
[09:30:12.153]   - Field: ‘job’
[09:30:12.153]   - Field: ‘conditions’
[09:30:12.153]   - Field: ‘expr’
[09:30:12.153]   - Field: ‘uuid’
[09:30:12.153]   - Field: ‘seed’
[09:30:12.154]   - Field: ‘version’
[09:30:12.154]   - Field: ‘result’
[09:30:12.154]   - Field: ‘asynchronous’
[09:30:12.154]   - Field: ‘calls’
[09:30:12.154]   - Field: ‘globals’
[09:30:12.154]   - Field: ‘stdout’
[09:30:12.154]   - Field: ‘earlySignal’
[09:30:12.155]   - Field: ‘lazy’
[09:30:12.155]   - Field: ‘state’
[09:30:12.155] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:30:12.155] - Launch lazy future ...
[09:30:12.155] Packages needed by the future expression (n = 0): <none>
[09:30:12.156] Packages needed by future strategies (n = 0): <none>
[09:30:12.156] {
[09:30:12.156]     {
[09:30:12.156]         {
[09:30:12.156]             ...future.startTime <- base::Sys.time()
[09:30:12.156]             {
[09:30:12.156]                 {
[09:30:12.156]                   {
[09:30:12.156]                     {
[09:30:12.156]                       base::local({
[09:30:12.156]                         has_future <- base::requireNamespace("future", 
[09:30:12.156]                           quietly = TRUE)
[09:30:12.156]                         if (has_future) {
[09:30:12.156]                           ns <- base::getNamespace("future")
[09:30:12.156]                           version <- ns[[".package"]][["version"]]
[09:30:12.156]                           if (is.null(version)) 
[09:30:12.156]                             version <- utils::packageVersion("future")
[09:30:12.156]                         }
[09:30:12.156]                         else {
[09:30:12.156]                           version <- NULL
[09:30:12.156]                         }
[09:30:12.156]                         if (!has_future || version < "1.8.0") {
[09:30:12.156]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:12.156]                             "", base::R.version$version.string), 
[09:30:12.156]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:12.156]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:12.156]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:12.156]                               "release", "version")], collapse = " "), 
[09:30:12.156]                             hostname = base::Sys.info()[["nodename"]])
[09:30:12.156]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:12.156]                             info)
[09:30:12.156]                           info <- base::paste(info, collapse = "; ")
[09:30:12.156]                           if (!has_future) {
[09:30:12.156]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:12.156]                               info)
[09:30:12.156]                           }
[09:30:12.156]                           else {
[09:30:12.156]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:12.156]                               info, version)
[09:30:12.156]                           }
[09:30:12.156]                           base::stop(msg)
[09:30:12.156]                         }
[09:30:12.156]                       })
[09:30:12.156]                     }
[09:30:12.156]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:12.156]                     base::options(mc.cores = 1L)
[09:30:12.156]                   }
[09:30:12.156]                   ...future.strategy.old <- future::plan("list")
[09:30:12.156]                   options(future.plan = NULL)
[09:30:12.156]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:12.156]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:12.156]                 }
[09:30:12.156]                 ...future.workdir <- getwd()
[09:30:12.156]             }
[09:30:12.156]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:12.156]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:12.156]         }
[09:30:12.156]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:12.156]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:12.156]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:12.156]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:12.156]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:12.156]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:12.156]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:12.156]             base::names(...future.oldOptions))
[09:30:12.156]     }
[09:30:12.156]     if (TRUE) {
[09:30:12.156]     }
[09:30:12.156]     else {
[09:30:12.156]         if (NA) {
[09:30:12.156]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:12.156]                 open = "w")
[09:30:12.156]         }
[09:30:12.156]         else {
[09:30:12.156]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:12.156]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:12.156]         }
[09:30:12.156]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:12.156]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:12.156]             base::sink(type = "output", split = FALSE)
[09:30:12.156]             base::close(...future.stdout)
[09:30:12.156]         }, add = TRUE)
[09:30:12.156]     }
[09:30:12.156]     ...future.frame <- base::sys.nframe()
[09:30:12.156]     ...future.conditions <- base::list()
[09:30:12.156]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:12.156]     if (FALSE) {
[09:30:12.156]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:12.156]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:12.156]     }
[09:30:12.156]     ...future.result <- base::tryCatch({
[09:30:12.156]         base::withCallingHandlers({
[09:30:12.156]             ...future.value <- base::withVisible(base::local({
[09:30:12.156]                 withCallingHandlers({
[09:30:12.156]                   {
[09:30:12.156]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:12.156]                     if (!identical(...future.globals.maxSize.org, 
[09:30:12.156]                       ...future.globals.maxSize)) {
[09:30:12.156]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:12.156]                       on.exit(options(oopts), add = TRUE)
[09:30:12.156]                     }
[09:30:12.156]                     {
[09:30:12.156]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:12.156]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:30:12.156]                         USE.NAMES = FALSE)
[09:30:12.156]                       do.call(mapply, args = args)
[09:30:12.156]                     }
[09:30:12.156]                   }
[09:30:12.156]                 }, immediateCondition = function(cond) {
[09:30:12.156]                   save_rds <- function (object, pathname, ...) 
[09:30:12.156]                   {
[09:30:12.156]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:30:12.156]                     if (file_test("-f", pathname_tmp)) {
[09:30:12.156]                       fi_tmp <- file.info(pathname_tmp)
[09:30:12.156]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:30:12.156]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:12.156]                         fi_tmp[["mtime"]])
[09:30:12.156]                     }
[09:30:12.156]                     tryCatch({
[09:30:12.156]                       saveRDS(object, file = pathname_tmp, ...)
[09:30:12.156]                     }, error = function(ex) {
[09:30:12.156]                       msg <- conditionMessage(ex)
[09:30:12.156]                       fi_tmp <- file.info(pathname_tmp)
[09:30:12.156]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:30:12.156]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:12.156]                         fi_tmp[["mtime"]], msg)
[09:30:12.156]                       ex$message <- msg
[09:30:12.156]                       stop(ex)
[09:30:12.156]                     })
[09:30:12.156]                     stopifnot(file_test("-f", pathname_tmp))
[09:30:12.156]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:30:12.156]                     if (!res || file_test("-f", pathname_tmp)) {
[09:30:12.156]                       fi_tmp <- file.info(pathname_tmp)
[09:30:12.156]                       fi <- file.info(pathname)
[09:30:12.156]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:30:12.156]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:30:12.156]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:30:12.156]                         fi[["size"]], fi[["mtime"]])
[09:30:12.156]                       stop(msg)
[09:30:12.156]                     }
[09:30:12.156]                     invisible(pathname)
[09:30:12.156]                   }
[09:30:12.156]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:30:12.156]                     rootPath = tempdir()) 
[09:30:12.156]                   {
[09:30:12.156]                     obj <- list(time = Sys.time(), condition = cond)
[09:30:12.156]                     file <- tempfile(pattern = class(cond)[1], 
[09:30:12.156]                       tmpdir = path, fileext = ".rds")
[09:30:12.156]                     save_rds(obj, file)
[09:30:12.156]                   }
[09:30:12.156]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0coFNd/.future/immediateConditions")
[09:30:12.156]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:12.156]                   {
[09:30:12.156]                     inherits <- base::inherits
[09:30:12.156]                     invokeRestart <- base::invokeRestart
[09:30:12.156]                     is.null <- base::is.null
[09:30:12.156]                     muffled <- FALSE
[09:30:12.156]                     if (inherits(cond, "message")) {
[09:30:12.156]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:12.156]                       if (muffled) 
[09:30:12.156]                         invokeRestart("muffleMessage")
[09:30:12.156]                     }
[09:30:12.156]                     else if (inherits(cond, "warning")) {
[09:30:12.156]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:12.156]                       if (muffled) 
[09:30:12.156]                         invokeRestart("muffleWarning")
[09:30:12.156]                     }
[09:30:12.156]                     else if (inherits(cond, "condition")) {
[09:30:12.156]                       if (!is.null(pattern)) {
[09:30:12.156]                         computeRestarts <- base::computeRestarts
[09:30:12.156]                         grepl <- base::grepl
[09:30:12.156]                         restarts <- computeRestarts(cond)
[09:30:12.156]                         for (restart in restarts) {
[09:30:12.156]                           name <- restart$name
[09:30:12.156]                           if (is.null(name)) 
[09:30:12.156]                             next
[09:30:12.156]                           if (!grepl(pattern, name)) 
[09:30:12.156]                             next
[09:30:12.156]                           invokeRestart(restart)
[09:30:12.156]                           muffled <- TRUE
[09:30:12.156]                           break
[09:30:12.156]                         }
[09:30:12.156]                       }
[09:30:12.156]                     }
[09:30:12.156]                     invisible(muffled)
[09:30:12.156]                   }
[09:30:12.156]                   muffleCondition(cond)
[09:30:12.156]                 })
[09:30:12.156]             }))
[09:30:12.156]             future::FutureResult(value = ...future.value$value, 
[09:30:12.156]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:12.156]                   ...future.rng), globalenv = if (FALSE) 
[09:30:12.156]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:12.156]                     ...future.globalenv.names))
[09:30:12.156]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:12.156]         }, condition = base::local({
[09:30:12.156]             c <- base::c
[09:30:12.156]             inherits <- base::inherits
[09:30:12.156]             invokeRestart <- base::invokeRestart
[09:30:12.156]             length <- base::length
[09:30:12.156]             list <- base::list
[09:30:12.156]             seq.int <- base::seq.int
[09:30:12.156]             signalCondition <- base::signalCondition
[09:30:12.156]             sys.calls <- base::sys.calls
[09:30:12.156]             `[[` <- base::`[[`
[09:30:12.156]             `+` <- base::`+`
[09:30:12.156]             `<<-` <- base::`<<-`
[09:30:12.156]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:12.156]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:12.156]                   3L)]
[09:30:12.156]             }
[09:30:12.156]             function(cond) {
[09:30:12.156]                 is_error <- inherits(cond, "error")
[09:30:12.156]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:12.156]                   NULL)
[09:30:12.156]                 if (is_error) {
[09:30:12.156]                   sessionInformation <- function() {
[09:30:12.156]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:12.156]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:12.156]                       search = base::search(), system = base::Sys.info())
[09:30:12.156]                   }
[09:30:12.156]                   ...future.conditions[[length(...future.conditions) + 
[09:30:12.156]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:12.156]                     cond$call), session = sessionInformation(), 
[09:30:12.156]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:12.156]                   signalCondition(cond)
[09:30:12.156]                 }
[09:30:12.156]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:12.156]                 "immediateCondition"))) {
[09:30:12.156]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:12.156]                   ...future.conditions[[length(...future.conditions) + 
[09:30:12.156]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:12.156]                   if (TRUE && !signal) {
[09:30:12.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:12.156]                     {
[09:30:12.156]                       inherits <- base::inherits
[09:30:12.156]                       invokeRestart <- base::invokeRestart
[09:30:12.156]                       is.null <- base::is.null
[09:30:12.156]                       muffled <- FALSE
[09:30:12.156]                       if (inherits(cond, "message")) {
[09:30:12.156]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:12.156]                         if (muffled) 
[09:30:12.156]                           invokeRestart("muffleMessage")
[09:30:12.156]                       }
[09:30:12.156]                       else if (inherits(cond, "warning")) {
[09:30:12.156]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:12.156]                         if (muffled) 
[09:30:12.156]                           invokeRestart("muffleWarning")
[09:30:12.156]                       }
[09:30:12.156]                       else if (inherits(cond, "condition")) {
[09:30:12.156]                         if (!is.null(pattern)) {
[09:30:12.156]                           computeRestarts <- base::computeRestarts
[09:30:12.156]                           grepl <- base::grepl
[09:30:12.156]                           restarts <- computeRestarts(cond)
[09:30:12.156]                           for (restart in restarts) {
[09:30:12.156]                             name <- restart$name
[09:30:12.156]                             if (is.null(name)) 
[09:30:12.156]                               next
[09:30:12.156]                             if (!grepl(pattern, name)) 
[09:30:12.156]                               next
[09:30:12.156]                             invokeRestart(restart)
[09:30:12.156]                             muffled <- TRUE
[09:30:12.156]                             break
[09:30:12.156]                           }
[09:30:12.156]                         }
[09:30:12.156]                       }
[09:30:12.156]                       invisible(muffled)
[09:30:12.156]                     }
[09:30:12.156]                     muffleCondition(cond, pattern = "^muffle")
[09:30:12.156]                   }
[09:30:12.156]                 }
[09:30:12.156]                 else {
[09:30:12.156]                   if (TRUE) {
[09:30:12.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:12.156]                     {
[09:30:12.156]                       inherits <- base::inherits
[09:30:12.156]                       invokeRestart <- base::invokeRestart
[09:30:12.156]                       is.null <- base::is.null
[09:30:12.156]                       muffled <- FALSE
[09:30:12.156]                       if (inherits(cond, "message")) {
[09:30:12.156]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:12.156]                         if (muffled) 
[09:30:12.156]                           invokeRestart("muffleMessage")
[09:30:12.156]                       }
[09:30:12.156]                       else if (inherits(cond, "warning")) {
[09:30:12.156]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:12.156]                         if (muffled) 
[09:30:12.156]                           invokeRestart("muffleWarning")
[09:30:12.156]                       }
[09:30:12.156]                       else if (inherits(cond, "condition")) {
[09:30:12.156]                         if (!is.null(pattern)) {
[09:30:12.156]                           computeRestarts <- base::computeRestarts
[09:30:12.156]                           grepl <- base::grepl
[09:30:12.156]                           restarts <- computeRestarts(cond)
[09:30:12.156]                           for (restart in restarts) {
[09:30:12.156]                             name <- restart$name
[09:30:12.156]                             if (is.null(name)) 
[09:30:12.156]                               next
[09:30:12.156]                             if (!grepl(pattern, name)) 
[09:30:12.156]                               next
[09:30:12.156]                             invokeRestart(restart)
[09:30:12.156]                             muffled <- TRUE
[09:30:12.156]                             break
[09:30:12.156]                           }
[09:30:12.156]                         }
[09:30:12.156]                       }
[09:30:12.156]                       invisible(muffled)
[09:30:12.156]                     }
[09:30:12.156]                     muffleCondition(cond, pattern = "^muffle")
[09:30:12.156]                   }
[09:30:12.156]                 }
[09:30:12.156]             }
[09:30:12.156]         }))
[09:30:12.156]     }, error = function(ex) {
[09:30:12.156]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:12.156]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:12.156]                 ...future.rng), started = ...future.startTime, 
[09:30:12.156]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:12.156]             version = "1.8"), class = "FutureResult")
[09:30:12.156]     }, finally = {
[09:30:12.156]         if (!identical(...future.workdir, getwd())) 
[09:30:12.156]             setwd(...future.workdir)
[09:30:12.156]         {
[09:30:12.156]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:12.156]                 ...future.oldOptions$nwarnings <- NULL
[09:30:12.156]             }
[09:30:12.156]             base::options(...future.oldOptions)
[09:30:12.156]             if (.Platform$OS.type == "windows") {
[09:30:12.156]                 old_names <- names(...future.oldEnvVars)
[09:30:12.156]                 envs <- base::Sys.getenv()
[09:30:12.156]                 names <- names(envs)
[09:30:12.156]                 common <- intersect(names, old_names)
[09:30:12.156]                 added <- setdiff(names, old_names)
[09:30:12.156]                 removed <- setdiff(old_names, names)
[09:30:12.156]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:12.156]                   envs[common]]
[09:30:12.156]                 NAMES <- toupper(changed)
[09:30:12.156]                 args <- list()
[09:30:12.156]                 for (kk in seq_along(NAMES)) {
[09:30:12.156]                   name <- changed[[kk]]
[09:30:12.156]                   NAME <- NAMES[[kk]]
[09:30:12.156]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:12.156]                     next
[09:30:12.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:12.156]                 }
[09:30:12.156]                 NAMES <- toupper(added)
[09:30:12.156]                 for (kk in seq_along(NAMES)) {
[09:30:12.156]                   name <- added[[kk]]
[09:30:12.156]                   NAME <- NAMES[[kk]]
[09:30:12.156]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:12.156]                     next
[09:30:12.156]                   args[[name]] <- ""
[09:30:12.156]                 }
[09:30:12.156]                 NAMES <- toupper(removed)
[09:30:12.156]                 for (kk in seq_along(NAMES)) {
[09:30:12.156]                   name <- removed[[kk]]
[09:30:12.156]                   NAME <- NAMES[[kk]]
[09:30:12.156]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:12.156]                     next
[09:30:12.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:12.156]                 }
[09:30:12.156]                 if (length(args) > 0) 
[09:30:12.156]                   base::do.call(base::Sys.setenv, args = args)
[09:30:12.156]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:12.156]             }
[09:30:12.156]             else {
[09:30:12.156]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:12.156]             }
[09:30:12.156]             {
[09:30:12.156]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:12.156]                   0L) {
[09:30:12.156]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:12.156]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:12.156]                   base::options(opts)
[09:30:12.156]                 }
[09:30:12.156]                 {
[09:30:12.156]                   {
[09:30:12.156]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:12.156]                     NULL
[09:30:12.156]                   }
[09:30:12.156]                   options(future.plan = NULL)
[09:30:12.156]                   if (is.na(NA_character_)) 
[09:30:12.156]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:12.156]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:12.156]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:12.156]                     .init = FALSE)
[09:30:12.156]                 }
[09:30:12.156]             }
[09:30:12.156]         }
[09:30:12.156]     })
[09:30:12.156]     if (FALSE) {
[09:30:12.156]         base::sink(type = "output", split = FALSE)
[09:30:12.156]         if (NA) {
[09:30:12.156]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:12.156]         }
[09:30:12.156]         else {
[09:30:12.156]             ...future.result["stdout"] <- base::list(NULL)
[09:30:12.156]         }
[09:30:12.156]         base::close(...future.stdout)
[09:30:12.156]         ...future.stdout <- NULL
[09:30:12.156]     }
[09:30:12.156]     ...future.result$conditions <- ...future.conditions
[09:30:12.156]     ...future.result$finished <- base::Sys.time()
[09:30:12.156]     ...future.result
[09:30:12.156] }
[09:30:12.160] assign_globals() ...
[09:30:12.160] List of 5
[09:30:12.160]  $ ...future.FUN            :function (x, y)  
[09:30:12.160]  $ MoreArgs                 : NULL
[09:30:12.160]  $ ...future.elements_ii    :List of 2
[09:30:12.160]   ..$ :List of 1
[09:30:12.160]   .. ..$ : int 0
[09:30:12.160]   ..$ :List of 1
[09:30:12.160]   .. ..$ : int 1
[09:30:12.160]  $ ...future.seeds_ii       : NULL
[09:30:12.160]  $ ...future.globals.maxSize: NULL
[09:30:12.160]  - attr(*, "where")=List of 5
[09:30:12.160]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:30:12.160]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:30:12.160]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:30:12.160]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:30:12.160]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:30:12.160]  - attr(*, "resolved")= logi FALSE
[09:30:12.160]  - attr(*, "total_size")= num 6368
[09:30:12.160]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:12.160]  - attr(*, "already-done")= logi TRUE
[09:30:12.177] - reassign environment for ‘...future.FUN’
[09:30:12.177] - copied ‘...future.FUN’ to environment
[09:30:12.177] - copied ‘MoreArgs’ to environment
[09:30:12.177] - copied ‘...future.elements_ii’ to environment
[09:30:12.177] - copied ‘...future.seeds_ii’ to environment
[09:30:12.177] - copied ‘...future.globals.maxSize’ to environment
[09:30:12.177] assign_globals() ... done
[09:30:12.178] requestCore(): workers = 2
[09:30:12.180] MulticoreFuture started
[09:30:12.180] - Launch lazy future ... done
[09:30:12.180] run() for ‘MulticoreFuture’ ... done
[09:30:12.181] Created future:
[09:30:12.181] plan(): Setting new future strategy stack:
[09:30:12.181] List of future strategies:
[09:30:12.181] 1. sequential:
[09:30:12.181]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:12.181]    - tweaked: FALSE
[09:30:12.181]    - call: NULL
[09:30:12.182] plan(): nbrOfWorkers() = 1
[09:30:12.185] plan(): Setting new future strategy stack:
[09:30:12.185] List of future strategies:
[09:30:12.185] 1. multicore:
[09:30:12.185]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:30:12.185]    - tweaked: FALSE
[09:30:12.185]    - call: plan(strategy)
[09:30:12.190] plan(): nbrOfWorkers() = 2
[09:30:12.181] MulticoreFuture:
[09:30:12.181] Label: ‘future_mapply-2’
[09:30:12.181] Expression:
[09:30:12.181] {
[09:30:12.181]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:12.181]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:12.181]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:12.181]         on.exit(options(oopts), add = TRUE)
[09:30:12.181]     }
[09:30:12.181]     {
[09:30:12.181]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:12.181]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:30:12.181]         do.call(mapply, args = args)
[09:30:12.181]     }
[09:30:12.181] }
[09:30:12.181] Lazy evaluation: FALSE
[09:30:12.181] Asynchronous evaluation: TRUE
[09:30:12.181] Local evaluation: TRUE
[09:30:12.181] Environment: R_GlobalEnv
[09:30:12.181] Capture standard output: NA
[09:30:12.181] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:12.181] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:12.181] Packages: <none>
[09:30:12.181] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:12.181] Resolved: TRUE
[09:30:12.181] Value: <not collected>
[09:30:12.181] Conditions captured: <none>
[09:30:12.181] Early signaling: FALSE
[09:30:12.181] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:12.181] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:12.191] Chunk #2 of 2 ... DONE
[09:30:12.191] Launching 2 futures (chunks) ... DONE
[09:30:12.191] Resolving 2 futures (chunks) ...
[09:30:12.191] resolve() on list ...
[09:30:12.192]  recursive: 0
[09:30:12.192]  length: 2
[09:30:12.192] 
[09:30:12.203] Future #2
[09:30:12.203] result() for MulticoreFuture ...
[09:30:12.204] result() for MulticoreFuture ...
[09:30:12.204] result() for MulticoreFuture ... done
[09:30:12.204] result() for MulticoreFuture ... done
[09:30:12.204] result() for MulticoreFuture ...
[09:30:12.204] result() for MulticoreFuture ... done
[09:30:12.205] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:30:12.205] - nx: 2
[09:30:12.205] - relay: TRUE
[09:30:12.205] - stdout: TRUE
[09:30:12.205] - signal: TRUE
[09:30:12.205] - resignal: FALSE
[09:30:12.205] - force: TRUE
[09:30:12.206] - relayed: [n=2] FALSE, FALSE
[09:30:12.206] - queued futures: [n=2] FALSE, FALSE
[09:30:12.206]  - until=1
[09:30:12.206]  - relaying element #1
[09:30:12.206] - relayed: [n=2] FALSE, FALSE
[09:30:12.206] - queued futures: [n=2] FALSE, TRUE
[09:30:12.206] signalConditionsASAP(NULL, pos=2) ... done
[09:30:12.206]  length: 1 (resolved future 2)
[09:30:12.631] plan(): Setting new future strategy stack:
[09:30:12.631] List of future strategies:
[09:30:12.631] 1. multicore:
[09:30:12.631]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:30:12.631]    - tweaked: FALSE
[09:30:12.631]    - call: plan(strategy)
[09:30:12.636] plan(): nbrOfWorkers() = 2
[09:30:12.645] Future #1
[09:30:12.645] result() for MulticoreFuture ...
[09:30:12.646] result() for MulticoreFuture ...
[09:30:12.646] result() for MulticoreFuture ... done
[09:30:12.646] result() for MulticoreFuture ... done
[09:30:12.646] result() for MulticoreFuture ...
[09:30:12.646] result() for MulticoreFuture ... done
[09:30:12.647] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:30:12.647] - nx: 2
[09:30:12.647] - relay: TRUE
[09:30:12.647] - stdout: TRUE
[09:30:12.647] - signal: TRUE
[09:30:12.647] - resignal: FALSE
[09:30:12.647] - force: TRUE
[09:30:12.648] - relayed: [n=2] FALSE, FALSE
[09:30:12.648] - queued futures: [n=2] FALSE, TRUE
[09:30:12.648]  - until=1
[09:30:12.648]  - relaying element #1
[09:30:12.648] result() for MulticoreFuture ...
[09:30:12.648] result() for MulticoreFuture ... done
[09:30:12.649] result() for MulticoreFuture ...
[09:30:12.649] result() for MulticoreFuture ... done
[09:30:12.649] result() for MulticoreFuture ...
[09:30:12.649] result() for MulticoreFuture ... done
[09:30:12.649] result() for MulticoreFuture ...
[09:30:12.649] result() for MulticoreFuture ... done
[09:30:12.649] - relayed: [n=2] TRUE, FALSE
[09:30:12.650] - queued futures: [n=2] TRUE, TRUE
[09:30:12.650] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:30:12.650]  length: 0 (resolved future 1)
[09:30:12.650] Relaying remaining futures
[09:30:12.650] signalConditionsASAP(NULL, pos=0) ...
[09:30:12.650] - nx: 2
[09:30:12.651] - relay: TRUE
[09:30:12.651] - stdout: TRUE
[09:30:12.651] - signal: TRUE
[09:30:12.651] - resignal: FALSE
[09:30:12.651] - force: TRUE
[09:30:12.651] - relayed: [n=2] TRUE, FALSE
[09:30:12.651] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:30:12.651]  - relaying element #2
[09:30:12.652] result() for MulticoreFuture ...
[09:30:12.652] result() for MulticoreFuture ... done
[09:30:12.652] result() for MulticoreFuture ...
[09:30:12.652] result() for MulticoreFuture ... done
[09:30:12.652] result() for MulticoreFuture ...
[09:30:12.652] result() for MulticoreFuture ... done
[09:30:12.652] result() for MulticoreFuture ...
[09:30:12.652] result() for MulticoreFuture ... done
[09:30:12.653] - relayed: [n=2] TRUE, TRUE
[09:30:12.653] - queued futures: [n=2] TRUE, TRUE
[09:30:12.653] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[09:30:12.653] resolve() on list ... DONE
[09:30:12.653] result() for MulticoreFuture ...
[09:30:12.653] result() for MulticoreFuture ... done
[09:30:12.653] result() for MulticoreFuture ...
[09:30:12.653] result() for MulticoreFuture ... done
[09:30:12.653] result() for MulticoreFuture ...
[09:30:12.654] result() for MulticoreFuture ... done
[09:30:12.654] result() for MulticoreFuture ...
[09:30:12.654] result() for MulticoreFuture ... done
[09:30:12.654]  - Number of value chunks collected: 2
[09:30:12.654] Resolving 2 futures (chunks) ... DONE
[09:30:12.654] Reducing values from 2 chunks ...
[09:30:12.654]  - Number of values collected after concatenation: 2
[09:30:12.654]  - Number of values expected: 2
[09:30:12.654] Reducing values from 2 chunks ... DONE
[09:30:12.655] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[09:30:12.655] plan(): Setting new future strategy stack:
[09:30:12.655] List of future strategies:
[09:30:12.655] 1. multisession:
[09:30:12.655]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:30:12.655]    - tweaked: FALSE
[09:30:12.655]    - call: plan(strategy)
[09:30:12.656] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[09:30:12.656] multisession:
[09:30:12.656] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:30:12.656] - tweaked: FALSE
[09:30:12.656] - call: plan(strategy)
[09:30:12.662] getGlobalsAndPackages() ...
[09:30:12.662] Not searching for globals
[09:30:12.662] - globals: [0] <none>
[09:30:12.662] getGlobalsAndPackages() ... DONE
[09:30:12.663] [local output] makeClusterPSOCK() ...
[09:30:12.705] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[09:30:12.706] [local output] Base port: 11829
[09:30:12.706] [local output] Getting setup options for 2 cluster nodes ...
[09:30:12.706] [local output]  - Node 1 of 2 ...
[09:30:12.706] [local output] localMachine=TRUE => revtunnel=FALSE

[09:30:12.707] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp0coFNd/worker.rank=1.parallelly.parent=37813.93b53190fbf0.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp0coFNd/worker.rank=1.parallelly.parent=37813.93b53190fbf0.pid")'’
[09:30:12.893] - Possible to infer worker's PID: TRUE
[09:30:12.894] [local output] Rscript port: 11829

[09:30:12.894] [local output]  - Node 2 of 2 ...
[09:30:12.894] [local output] localMachine=TRUE => revtunnel=FALSE

[09:30:12.895] [local output] Rscript port: 11829

[09:30:12.895] [local output] Getting setup options for 2 cluster nodes ... done
[09:30:12.896] [local output]  - Parallel setup requested for some PSOCK nodes
[09:30:12.896] [local output] Setting up PSOCK nodes in parallel
[09:30:12.896] List of 36
[09:30:12.896]  $ worker          : chr "localhost"
[09:30:12.896]   ..- attr(*, "localhost")= logi TRUE
[09:30:12.896]  $ master          : chr "localhost"
[09:30:12.896]  $ port            : int 11829
[09:30:12.896]  $ connectTimeout  : num 120
[09:30:12.896]  $ timeout         : num 2592000
[09:30:12.896]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[09:30:12.896]  $ homogeneous     : logi TRUE
[09:30:12.896]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[09:30:12.896]  $ rscript_envs    : NULL
[09:30:12.896]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:30:12.896]  $ rscript_startup : NULL
[09:30:12.896]  $ rscript_sh      : chr "sh"
[09:30:12.896]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:30:12.896]  $ methods         : logi TRUE
[09:30:12.896]  $ socketOptions   : chr "no-delay"
[09:30:12.896]  $ useXDR          : logi FALSE
[09:30:12.896]  $ outfile         : chr "/dev/null"
[09:30:12.896]  $ renice          : int NA
[09:30:12.896]  $ rshcmd          : NULL
[09:30:12.896]  $ user            : chr(0) 
[09:30:12.896]  $ revtunnel       : logi FALSE
[09:30:12.896]  $ rshlogfile      : NULL
[09:30:12.896]  $ rshopts         : chr(0) 
[09:30:12.896]  $ rank            : int 1
[09:30:12.896]  $ manual          : logi FALSE
[09:30:12.896]  $ dryrun          : logi FALSE
[09:30:12.896]  $ quiet           : logi FALSE
[09:30:12.896]  $ setup_strategy  : chr "parallel"
[09:30:12.896]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:30:12.896]  $ pidfile         : chr "/tmp/Rtmp0coFNd/worker.rank=1.parallelly.parent=37813.93b53190fbf0.pid"
[09:30:12.896]  $ rshcmd_label    : NULL
[09:30:12.896]  $ rsh_call        : NULL
[09:30:12.896]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:30:12.896]  $ localMachine    : logi TRUE
[09:30:12.896]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[09:30:12.896]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[09:30:12.896]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[09:30:12.896]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[09:30:12.896]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[09:30:12.896]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[09:30:12.896]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[09:30:12.896]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[09:30:12.896]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[09:30:12.896]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[09:30:12.896]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[09:30:12.896]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[09:30:12.896]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[09:30:12.896]  $ arguments       :List of 28
[09:30:12.896]   ..$ worker          : chr "localhost"
[09:30:12.896]   ..$ master          : NULL
[09:30:12.896]   ..$ port            : int 11829
[09:30:12.896]   ..$ connectTimeout  : num 120
[09:30:12.896]   ..$ timeout         : num 2592000
[09:30:12.896]   ..$ rscript         : NULL
[09:30:12.896]   ..$ homogeneous     : NULL
[09:30:12.896]   ..$ rscript_args    : NULL
[09:30:12.896]   ..$ rscript_envs    : NULL
[09:30:12.896]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:30:12.896]   ..$ rscript_startup : NULL
[09:30:12.896]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[09:30:12.896]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:30:12.896]   ..$ methods         : logi TRUE
[09:30:12.896]   ..$ socketOptions   : chr "no-delay"
[09:30:12.896]   ..$ useXDR          : logi FALSE
[09:30:12.896]   ..$ outfile         : chr "/dev/null"
[09:30:12.896]   ..$ renice          : int NA
[09:30:12.896]   ..$ rshcmd          : NULL
[09:30:12.896]   ..$ user            : NULL
[09:30:12.896]   ..$ revtunnel       : logi NA
[09:30:12.896]   ..$ rshlogfile      : NULL
[09:30:12.896]   ..$ rshopts         : NULL
[09:30:12.896]   ..$ rank            : int 1
[09:30:12.896]   ..$ manual          : logi FALSE
[09:30:12.896]   ..$ dryrun          : logi FALSE
[09:30:12.896]   ..$ quiet           : logi FALSE
[09:30:12.896]   ..$ setup_strategy  : chr "parallel"
[09:30:12.896]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[09:30:12.914] [local output] System call to launch all workers:
[09:30:12.914] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp0coFNd/worker.rank=1.parallelly.parent=37813.93b53190fbf0.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11829 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[09:30:12.914] [local output] Starting PSOCK main server
[09:30:12.919] [local output] Workers launched
[09:30:12.920] [local output] Waiting for workers to connect back
[09:30:12.920]  - [local output] 0 workers out of 2 ready
[09:30:13.181]  - [local output] 0 workers out of 2 ready
[09:30:13.181]  - [local output] 1 workers out of 2 ready
[09:30:13.182]  - [local output] 1 workers out of 2 ready
[09:30:13.183]  - [local output] 2 workers out of 2 ready
[09:30:13.183] [local output] Launching of workers completed
[09:30:13.183] [local output] Collecting session information from workers
[09:30:13.184] [local output]  - Worker #1 of 2
[09:30:13.184] [local output]  - Worker #2 of 2
[09:30:13.184] [local output] makeClusterPSOCK() ... done
[09:30:13.195] Packages needed by the future expression (n = 0): <none>
[09:30:13.196] Packages needed by future strategies (n = 0): <none>
[09:30:13.196] {
[09:30:13.196]     {
[09:30:13.196]         {
[09:30:13.196]             ...future.startTime <- base::Sys.time()
[09:30:13.196]             {
[09:30:13.196]                 {
[09:30:13.196]                   {
[09:30:13.196]                     {
[09:30:13.196]                       base::local({
[09:30:13.196]                         has_future <- base::requireNamespace("future", 
[09:30:13.196]                           quietly = TRUE)
[09:30:13.196]                         if (has_future) {
[09:30:13.196]                           ns <- base::getNamespace("future")
[09:30:13.196]                           version <- ns[[".package"]][["version"]]
[09:30:13.196]                           if (is.null(version)) 
[09:30:13.196]                             version <- utils::packageVersion("future")
[09:30:13.196]                         }
[09:30:13.196]                         else {
[09:30:13.196]                           version <- NULL
[09:30:13.196]                         }
[09:30:13.196]                         if (!has_future || version < "1.8.0") {
[09:30:13.196]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:13.196]                             "", base::R.version$version.string), 
[09:30:13.196]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:13.196]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:13.196]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:13.196]                               "release", "version")], collapse = " "), 
[09:30:13.196]                             hostname = base::Sys.info()[["nodename"]])
[09:30:13.196]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:13.196]                             info)
[09:30:13.196]                           info <- base::paste(info, collapse = "; ")
[09:30:13.196]                           if (!has_future) {
[09:30:13.196]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:13.196]                               info)
[09:30:13.196]                           }
[09:30:13.196]                           else {
[09:30:13.196]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:13.196]                               info, version)
[09:30:13.196]                           }
[09:30:13.196]                           base::stop(msg)
[09:30:13.196]                         }
[09:30:13.196]                       })
[09:30:13.196]                     }
[09:30:13.196]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:13.196]                     base::options(mc.cores = 1L)
[09:30:13.196]                   }
[09:30:13.196]                   ...future.strategy.old <- future::plan("list")
[09:30:13.196]                   options(future.plan = NULL)
[09:30:13.196]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:13.196]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:13.196]                 }
[09:30:13.196]                 ...future.workdir <- getwd()
[09:30:13.196]             }
[09:30:13.196]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:13.196]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:13.196]         }
[09:30:13.196]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:13.196]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:30:13.196]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:13.196]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:13.196]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:13.196]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:13.196]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:13.196]             base::names(...future.oldOptions))
[09:30:13.196]     }
[09:30:13.196]     if (FALSE) {
[09:30:13.196]     }
[09:30:13.196]     else {
[09:30:13.196]         if (TRUE) {
[09:30:13.196]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:13.196]                 open = "w")
[09:30:13.196]         }
[09:30:13.196]         else {
[09:30:13.196]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:13.196]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:13.196]         }
[09:30:13.196]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:13.196]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:13.196]             base::sink(type = "output", split = FALSE)
[09:30:13.196]             base::close(...future.stdout)
[09:30:13.196]         }, add = TRUE)
[09:30:13.196]     }
[09:30:13.196]     ...future.frame <- base::sys.nframe()
[09:30:13.196]     ...future.conditions <- base::list()
[09:30:13.196]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:13.196]     if (FALSE) {
[09:30:13.196]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:13.196]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:13.196]     }
[09:30:13.196]     ...future.result <- base::tryCatch({
[09:30:13.196]         base::withCallingHandlers({
[09:30:13.196]             ...future.value <- base::withVisible(base::local({
[09:30:13.196]                 ...future.makeSendCondition <- base::local({
[09:30:13.196]                   sendCondition <- NULL
[09:30:13.196]                   function(frame = 1L) {
[09:30:13.196]                     if (is.function(sendCondition)) 
[09:30:13.196]                       return(sendCondition)
[09:30:13.196]                     ns <- getNamespace("parallel")
[09:30:13.196]                     if (exists("sendData", mode = "function", 
[09:30:13.196]                       envir = ns)) {
[09:30:13.196]                       parallel_sendData <- get("sendData", mode = "function", 
[09:30:13.196]                         envir = ns)
[09:30:13.196]                       envir <- sys.frame(frame)
[09:30:13.196]                       master <- NULL
[09:30:13.196]                       while (!identical(envir, .GlobalEnv) && 
[09:30:13.196]                         !identical(envir, emptyenv())) {
[09:30:13.196]                         if (exists("master", mode = "list", envir = envir, 
[09:30:13.196]                           inherits = FALSE)) {
[09:30:13.196]                           master <- get("master", mode = "list", 
[09:30:13.196]                             envir = envir, inherits = FALSE)
[09:30:13.196]                           if (inherits(master, c("SOCKnode", 
[09:30:13.196]                             "SOCK0node"))) {
[09:30:13.196]                             sendCondition <<- function(cond) {
[09:30:13.196]                               data <- list(type = "VALUE", value = cond, 
[09:30:13.196]                                 success = TRUE)
[09:30:13.196]                               parallel_sendData(master, data)
[09:30:13.196]                             }
[09:30:13.196]                             return(sendCondition)
[09:30:13.196]                           }
[09:30:13.196]                         }
[09:30:13.196]                         frame <- frame + 1L
[09:30:13.196]                         envir <- sys.frame(frame)
[09:30:13.196]                       }
[09:30:13.196]                     }
[09:30:13.196]                     sendCondition <<- function(cond) NULL
[09:30:13.196]                   }
[09:30:13.196]                 })
[09:30:13.196]                 withCallingHandlers({
[09:30:13.196]                   NA
[09:30:13.196]                 }, immediateCondition = function(cond) {
[09:30:13.196]                   sendCondition <- ...future.makeSendCondition()
[09:30:13.196]                   sendCondition(cond)
[09:30:13.196]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:13.196]                   {
[09:30:13.196]                     inherits <- base::inherits
[09:30:13.196]                     invokeRestart <- base::invokeRestart
[09:30:13.196]                     is.null <- base::is.null
[09:30:13.196]                     muffled <- FALSE
[09:30:13.196]                     if (inherits(cond, "message")) {
[09:30:13.196]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:13.196]                       if (muffled) 
[09:30:13.196]                         invokeRestart("muffleMessage")
[09:30:13.196]                     }
[09:30:13.196]                     else if (inherits(cond, "warning")) {
[09:30:13.196]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:13.196]                       if (muffled) 
[09:30:13.196]                         invokeRestart("muffleWarning")
[09:30:13.196]                     }
[09:30:13.196]                     else if (inherits(cond, "condition")) {
[09:30:13.196]                       if (!is.null(pattern)) {
[09:30:13.196]                         computeRestarts <- base::computeRestarts
[09:30:13.196]                         grepl <- base::grepl
[09:30:13.196]                         restarts <- computeRestarts(cond)
[09:30:13.196]                         for (restart in restarts) {
[09:30:13.196]                           name <- restart$name
[09:30:13.196]                           if (is.null(name)) 
[09:30:13.196]                             next
[09:30:13.196]                           if (!grepl(pattern, name)) 
[09:30:13.196]                             next
[09:30:13.196]                           invokeRestart(restart)
[09:30:13.196]                           muffled <- TRUE
[09:30:13.196]                           break
[09:30:13.196]                         }
[09:30:13.196]                       }
[09:30:13.196]                     }
[09:30:13.196]                     invisible(muffled)
[09:30:13.196]                   }
[09:30:13.196]                   muffleCondition(cond)
[09:30:13.196]                 })
[09:30:13.196]             }))
[09:30:13.196]             future::FutureResult(value = ...future.value$value, 
[09:30:13.196]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:13.196]                   ...future.rng), globalenv = if (FALSE) 
[09:30:13.196]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:13.196]                     ...future.globalenv.names))
[09:30:13.196]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:13.196]         }, condition = base::local({
[09:30:13.196]             c <- base::c
[09:30:13.196]             inherits <- base::inherits
[09:30:13.196]             invokeRestart <- base::invokeRestart
[09:30:13.196]             length <- base::length
[09:30:13.196]             list <- base::list
[09:30:13.196]             seq.int <- base::seq.int
[09:30:13.196]             signalCondition <- base::signalCondition
[09:30:13.196]             sys.calls <- base::sys.calls
[09:30:13.196]             `[[` <- base::`[[`
[09:30:13.196]             `+` <- base::`+`
[09:30:13.196]             `<<-` <- base::`<<-`
[09:30:13.196]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:13.196]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:13.196]                   3L)]
[09:30:13.196]             }
[09:30:13.196]             function(cond) {
[09:30:13.196]                 is_error <- inherits(cond, "error")
[09:30:13.196]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:13.196]                   NULL)
[09:30:13.196]                 if (is_error) {
[09:30:13.196]                   sessionInformation <- function() {
[09:30:13.196]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:13.196]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:13.196]                       search = base::search(), system = base::Sys.info())
[09:30:13.196]                   }
[09:30:13.196]                   ...future.conditions[[length(...future.conditions) + 
[09:30:13.196]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:13.196]                     cond$call), session = sessionInformation(), 
[09:30:13.196]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:13.196]                   signalCondition(cond)
[09:30:13.196]                 }
[09:30:13.196]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:13.196]                 "immediateCondition"))) {
[09:30:13.196]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:13.196]                   ...future.conditions[[length(...future.conditions) + 
[09:30:13.196]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:13.196]                   if (TRUE && !signal) {
[09:30:13.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:13.196]                     {
[09:30:13.196]                       inherits <- base::inherits
[09:30:13.196]                       invokeRestart <- base::invokeRestart
[09:30:13.196]                       is.null <- base::is.null
[09:30:13.196]                       muffled <- FALSE
[09:30:13.196]                       if (inherits(cond, "message")) {
[09:30:13.196]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:13.196]                         if (muffled) 
[09:30:13.196]                           invokeRestart("muffleMessage")
[09:30:13.196]                       }
[09:30:13.196]                       else if (inherits(cond, "warning")) {
[09:30:13.196]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:13.196]                         if (muffled) 
[09:30:13.196]                           invokeRestart("muffleWarning")
[09:30:13.196]                       }
[09:30:13.196]                       else if (inherits(cond, "condition")) {
[09:30:13.196]                         if (!is.null(pattern)) {
[09:30:13.196]                           computeRestarts <- base::computeRestarts
[09:30:13.196]                           grepl <- base::grepl
[09:30:13.196]                           restarts <- computeRestarts(cond)
[09:30:13.196]                           for (restart in restarts) {
[09:30:13.196]                             name <- restart$name
[09:30:13.196]                             if (is.null(name)) 
[09:30:13.196]                               next
[09:30:13.196]                             if (!grepl(pattern, name)) 
[09:30:13.196]                               next
[09:30:13.196]                             invokeRestart(restart)
[09:30:13.196]                             muffled <- TRUE
[09:30:13.196]                             break
[09:30:13.196]                           }
[09:30:13.196]                         }
[09:30:13.196]                       }
[09:30:13.196]                       invisible(muffled)
[09:30:13.196]                     }
[09:30:13.196]                     muffleCondition(cond, pattern = "^muffle")
[09:30:13.196]                   }
[09:30:13.196]                 }
[09:30:13.196]                 else {
[09:30:13.196]                   if (TRUE) {
[09:30:13.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:13.196]                     {
[09:30:13.196]                       inherits <- base::inherits
[09:30:13.196]                       invokeRestart <- base::invokeRestart
[09:30:13.196]                       is.null <- base::is.null
[09:30:13.196]                       muffled <- FALSE
[09:30:13.196]                       if (inherits(cond, "message")) {
[09:30:13.196]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:13.196]                         if (muffled) 
[09:30:13.196]                           invokeRestart("muffleMessage")
[09:30:13.196]                       }
[09:30:13.196]                       else if (inherits(cond, "warning")) {
[09:30:13.196]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:13.196]                         if (muffled) 
[09:30:13.196]                           invokeRestart("muffleWarning")
[09:30:13.196]                       }
[09:30:13.196]                       else if (inherits(cond, "condition")) {
[09:30:13.196]                         if (!is.null(pattern)) {
[09:30:13.196]                           computeRestarts <- base::computeRestarts
[09:30:13.196]                           grepl <- base::grepl
[09:30:13.196]                           restarts <- computeRestarts(cond)
[09:30:13.196]                           for (restart in restarts) {
[09:30:13.196]                             name <- restart$name
[09:30:13.196]                             if (is.null(name)) 
[09:30:13.196]                               next
[09:30:13.196]                             if (!grepl(pattern, name)) 
[09:30:13.196]                               next
[09:30:13.196]                             invokeRestart(restart)
[09:30:13.196]                             muffled <- TRUE
[09:30:13.196]                             break
[09:30:13.196]                           }
[09:30:13.196]                         }
[09:30:13.196]                       }
[09:30:13.196]                       invisible(muffled)
[09:30:13.196]                     }
[09:30:13.196]                     muffleCondition(cond, pattern = "^muffle")
[09:30:13.196]                   }
[09:30:13.196]                 }
[09:30:13.196]             }
[09:30:13.196]         }))
[09:30:13.196]     }, error = function(ex) {
[09:30:13.196]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:13.196]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:13.196]                 ...future.rng), started = ...future.startTime, 
[09:30:13.196]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:13.196]             version = "1.8"), class = "FutureResult")
[09:30:13.196]     }, finally = {
[09:30:13.196]         if (!identical(...future.workdir, getwd())) 
[09:30:13.196]             setwd(...future.workdir)
[09:30:13.196]         {
[09:30:13.196]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:13.196]                 ...future.oldOptions$nwarnings <- NULL
[09:30:13.196]             }
[09:30:13.196]             base::options(...future.oldOptions)
[09:30:13.196]             if (.Platform$OS.type == "windows") {
[09:30:13.196]                 old_names <- names(...future.oldEnvVars)
[09:30:13.196]                 envs <- base::Sys.getenv()
[09:30:13.196]                 names <- names(envs)
[09:30:13.196]                 common <- intersect(names, old_names)
[09:30:13.196]                 added <- setdiff(names, old_names)
[09:30:13.196]                 removed <- setdiff(old_names, names)
[09:30:13.196]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:13.196]                   envs[common]]
[09:30:13.196]                 NAMES <- toupper(changed)
[09:30:13.196]                 args <- list()
[09:30:13.196]                 for (kk in seq_along(NAMES)) {
[09:30:13.196]                   name <- changed[[kk]]
[09:30:13.196]                   NAME <- NAMES[[kk]]
[09:30:13.196]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:13.196]                     next
[09:30:13.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:13.196]                 }
[09:30:13.196]                 NAMES <- toupper(added)
[09:30:13.196]                 for (kk in seq_along(NAMES)) {
[09:30:13.196]                   name <- added[[kk]]
[09:30:13.196]                   NAME <- NAMES[[kk]]
[09:30:13.196]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:13.196]                     next
[09:30:13.196]                   args[[name]] <- ""
[09:30:13.196]                 }
[09:30:13.196]                 NAMES <- toupper(removed)
[09:30:13.196]                 for (kk in seq_along(NAMES)) {
[09:30:13.196]                   name <- removed[[kk]]
[09:30:13.196]                   NAME <- NAMES[[kk]]
[09:30:13.196]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:13.196]                     next
[09:30:13.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:13.196]                 }
[09:30:13.196]                 if (length(args) > 0) 
[09:30:13.196]                   base::do.call(base::Sys.setenv, args = args)
[09:30:13.196]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:13.196]             }
[09:30:13.196]             else {
[09:30:13.196]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:13.196]             }
[09:30:13.196]             {
[09:30:13.196]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:13.196]                   0L) {
[09:30:13.196]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:13.196]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:13.196]                   base::options(opts)
[09:30:13.196]                 }
[09:30:13.196]                 {
[09:30:13.196]                   {
[09:30:13.196]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:13.196]                     NULL
[09:30:13.196]                   }
[09:30:13.196]                   options(future.plan = NULL)
[09:30:13.196]                   if (is.na(NA_character_)) 
[09:30:13.196]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:13.196]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:13.196]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:13.196]                     .init = FALSE)
[09:30:13.196]                 }
[09:30:13.196]             }
[09:30:13.196]         }
[09:30:13.196]     })
[09:30:13.196]     if (TRUE) {
[09:30:13.196]         base::sink(type = "output", split = FALSE)
[09:30:13.196]         if (TRUE) {
[09:30:13.196]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:13.196]         }
[09:30:13.196]         else {
[09:30:13.196]             ...future.result["stdout"] <- base::list(NULL)
[09:30:13.196]         }
[09:30:13.196]         base::close(...future.stdout)
[09:30:13.196]         ...future.stdout <- NULL
[09:30:13.196]     }
[09:30:13.196]     ...future.result$conditions <- ...future.conditions
[09:30:13.196]     ...future.result$finished <- base::Sys.time()
[09:30:13.196]     ...future.result
[09:30:13.196] }
[09:30:13.247] MultisessionFuture started
[09:30:13.247] result() for ClusterFuture ...
[09:30:13.248] receiveMessageFromWorker() for ClusterFuture ...
[09:30:13.248] - Validating connection of MultisessionFuture
[09:30:13.279] - received message: FutureResult
[09:30:13.279] - Received FutureResult
[09:30:13.279] - Erased future from FutureRegistry
[09:30:13.279] result() for ClusterFuture ...
[09:30:13.279] - result already collected: FutureResult
[09:30:13.279] result() for ClusterFuture ... done
[09:30:13.280] receiveMessageFromWorker() for ClusterFuture ... done
[09:30:13.280] result() for ClusterFuture ... done
[09:30:13.280] result() for ClusterFuture ...
[09:30:13.280] - result already collected: FutureResult
[09:30:13.280] result() for ClusterFuture ... done
[09:30:13.280] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[09:30:13.284] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[09:30:13.284] future_lapply() ...
[09:30:13.289] Number of chunks: 2
[09:30:13.289] getGlobalsAndPackagesXApply() ...
[09:30:13.289]  - future.globals: TRUE
[09:30:13.289] getGlobalsAndPackages() ...
[09:30:13.289] Searching for globals...
[09:30:13.291] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[09:30:13.291] Searching for globals ... DONE
[09:30:13.291] Resolving globals: FALSE
[09:30:13.292] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[09:30:13.292] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[09:30:13.292] - globals: [1] ‘FUN’
[09:30:13.292] 
[09:30:13.292] getGlobalsAndPackages() ... DONE
[09:30:13.293]  - globals found/used: [n=1] ‘FUN’
[09:30:13.293]  - needed namespaces: [n=0] 
[09:30:13.293] Finding globals ... DONE
[09:30:13.293]  - use_args: TRUE
[09:30:13.293]  - Getting '...' globals ...
[09:30:13.293] resolve() on list ...
[09:30:13.294]  recursive: 0
[09:30:13.294]  length: 1
[09:30:13.294]  elements: ‘...’
[09:30:13.294]  length: 0 (resolved future 1)
[09:30:13.294] resolve() on list ... DONE
[09:30:13.294]    - '...' content: [n=0] 
[09:30:13.294] List of 1
[09:30:13.294]  $ ...: list()
[09:30:13.294]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:13.294]  - attr(*, "where")=List of 1
[09:30:13.294]   ..$ ...:<environment: 0x55c104dd01e0> 
[09:30:13.294]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:13.294]  - attr(*, "resolved")= logi TRUE
[09:30:13.294]  - attr(*, "total_size")= num NA
[09:30:13.297]  - Getting '...' globals ... DONE
[09:30:13.298] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:30:13.298] List of 2
[09:30:13.298]  $ ...future.FUN:function (x)  
[09:30:13.298]  $ ...          : list()
[09:30:13.298]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:13.298]  - attr(*, "where")=List of 2
[09:30:13.298]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:13.298]   ..$ ...          :<environment: 0x55c104dd01e0> 
[09:30:13.298]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:13.298]  - attr(*, "resolved")= logi FALSE
[09:30:13.298]  - attr(*, "total_size")= num 4720
[09:30:13.301] Packages to be attached in all futures: [n=0] 
[09:30:13.301] getGlobalsAndPackagesXApply() ... DONE
[09:30:13.301] Number of futures (= number of chunks): 2
[09:30:13.302] Launching 2 futures (chunks) ...
[09:30:13.302] Chunk #1 of 2 ...
[09:30:13.302]  - Finding globals in 'X' for chunk #1 ...
[09:30:13.302] getGlobalsAndPackages() ...
[09:30:13.302] Searching for globals...
[09:30:13.302] 
[09:30:13.302] Searching for globals ... DONE
[09:30:13.303] - globals: [0] <none>
[09:30:13.303] getGlobalsAndPackages() ... DONE
[09:30:13.303]    + additional globals found: [n=0] 
[09:30:13.303]    + additional namespaces needed: [n=0] 
[09:30:13.303]  - Finding globals in 'X' for chunk #1 ... DONE
[09:30:13.303]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:13.303]  - seeds: <none>
[09:30:13.303]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:13.303] getGlobalsAndPackages() ...
[09:30:13.304] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:13.304] Resolving globals: FALSE
[09:30:13.304] Tweak future expression to call with '...' arguments ...
[09:30:13.304] {
[09:30:13.304]     do.call(function(...) {
[09:30:13.304]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:13.304]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:13.304]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:13.304]             on.exit(options(oopts), add = TRUE)
[09:30:13.304]         }
[09:30:13.304]         {
[09:30:13.304]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:13.304]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:13.304]                 ...future.FUN(...future.X_jj, ...)
[09:30:13.304]             })
[09:30:13.304]         }
[09:30:13.304]     }, args = future.call.arguments)
[09:30:13.304] }
[09:30:13.304] Tweak future expression to call with '...' arguments ... DONE
[09:30:13.305] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:13.305] 
[09:30:13.305] getGlobalsAndPackages() ... DONE
[09:30:13.305] run() for ‘Future’ ...
[09:30:13.305] - state: ‘created’
[09:30:13.306] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:30:13.320] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:13.320] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:30:13.320]   - Field: ‘node’
[09:30:13.320]   - Field: ‘label’
[09:30:13.320]   - Field: ‘local’
[09:30:13.320]   - Field: ‘owner’
[09:30:13.320]   - Field: ‘envir’
[09:30:13.320]   - Field: ‘workers’
[09:30:13.321]   - Field: ‘packages’
[09:30:13.321]   - Field: ‘gc’
[09:30:13.321]   - Field: ‘conditions’
[09:30:13.321]   - Field: ‘persistent’
[09:30:13.321]   - Field: ‘expr’
[09:30:13.321]   - Field: ‘uuid’
[09:30:13.321]   - Field: ‘seed’
[09:30:13.321]   - Field: ‘version’
[09:30:13.321]   - Field: ‘result’
[09:30:13.322]   - Field: ‘asynchronous’
[09:30:13.322]   - Field: ‘calls’
[09:30:13.322]   - Field: ‘globals’
[09:30:13.322]   - Field: ‘stdout’
[09:30:13.322]   - Field: ‘earlySignal’
[09:30:13.322]   - Field: ‘lazy’
[09:30:13.322]   - Field: ‘state’
[09:30:13.322] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:30:13.322] - Launch lazy future ...
[09:30:13.323] Packages needed by the future expression (n = 0): <none>
[09:30:13.323] Packages needed by future strategies (n = 0): <none>
[09:30:13.323] {
[09:30:13.323]     {
[09:30:13.323]         {
[09:30:13.323]             ...future.startTime <- base::Sys.time()
[09:30:13.323]             {
[09:30:13.323]                 {
[09:30:13.323]                   {
[09:30:13.323]                     {
[09:30:13.323]                       base::local({
[09:30:13.323]                         has_future <- base::requireNamespace("future", 
[09:30:13.323]                           quietly = TRUE)
[09:30:13.323]                         if (has_future) {
[09:30:13.323]                           ns <- base::getNamespace("future")
[09:30:13.323]                           version <- ns[[".package"]][["version"]]
[09:30:13.323]                           if (is.null(version)) 
[09:30:13.323]                             version <- utils::packageVersion("future")
[09:30:13.323]                         }
[09:30:13.323]                         else {
[09:30:13.323]                           version <- NULL
[09:30:13.323]                         }
[09:30:13.323]                         if (!has_future || version < "1.8.0") {
[09:30:13.323]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:13.323]                             "", base::R.version$version.string), 
[09:30:13.323]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:13.323]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:13.323]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:13.323]                               "release", "version")], collapse = " "), 
[09:30:13.323]                             hostname = base::Sys.info()[["nodename"]])
[09:30:13.323]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:13.323]                             info)
[09:30:13.323]                           info <- base::paste(info, collapse = "; ")
[09:30:13.323]                           if (!has_future) {
[09:30:13.323]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:13.323]                               info)
[09:30:13.323]                           }
[09:30:13.323]                           else {
[09:30:13.323]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:13.323]                               info, version)
[09:30:13.323]                           }
[09:30:13.323]                           base::stop(msg)
[09:30:13.323]                         }
[09:30:13.323]                       })
[09:30:13.323]                     }
[09:30:13.323]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:13.323]                     base::options(mc.cores = 1L)
[09:30:13.323]                   }
[09:30:13.323]                   ...future.strategy.old <- future::plan("list")
[09:30:13.323]                   options(future.plan = NULL)
[09:30:13.323]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:13.323]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:13.323]                 }
[09:30:13.323]                 ...future.workdir <- getwd()
[09:30:13.323]             }
[09:30:13.323]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:13.323]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:13.323]         }
[09:30:13.323]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:13.323]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:13.323]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:13.323]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:13.323]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:13.323]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:13.323]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:13.323]             base::names(...future.oldOptions))
[09:30:13.323]     }
[09:30:13.323]     if (FALSE) {
[09:30:13.323]     }
[09:30:13.323]     else {
[09:30:13.323]         if (FALSE) {
[09:30:13.323]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:13.323]                 open = "w")
[09:30:13.323]         }
[09:30:13.323]         else {
[09:30:13.323]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:13.323]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:13.323]         }
[09:30:13.323]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:13.323]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:13.323]             base::sink(type = "output", split = FALSE)
[09:30:13.323]             base::close(...future.stdout)
[09:30:13.323]         }, add = TRUE)
[09:30:13.323]     }
[09:30:13.323]     ...future.frame <- base::sys.nframe()
[09:30:13.323]     ...future.conditions <- base::list()
[09:30:13.323]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:13.323]     if (FALSE) {
[09:30:13.323]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:13.323]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:13.323]     }
[09:30:13.323]     ...future.result <- base::tryCatch({
[09:30:13.323]         base::withCallingHandlers({
[09:30:13.323]             ...future.value <- base::withVisible(base::local({
[09:30:13.323]                 ...future.makeSendCondition <- base::local({
[09:30:13.323]                   sendCondition <- NULL
[09:30:13.323]                   function(frame = 1L) {
[09:30:13.323]                     if (is.function(sendCondition)) 
[09:30:13.323]                       return(sendCondition)
[09:30:13.323]                     ns <- getNamespace("parallel")
[09:30:13.323]                     if (exists("sendData", mode = "function", 
[09:30:13.323]                       envir = ns)) {
[09:30:13.323]                       parallel_sendData <- get("sendData", mode = "function", 
[09:30:13.323]                         envir = ns)
[09:30:13.323]                       envir <- sys.frame(frame)
[09:30:13.323]                       master <- NULL
[09:30:13.323]                       while (!identical(envir, .GlobalEnv) && 
[09:30:13.323]                         !identical(envir, emptyenv())) {
[09:30:13.323]                         if (exists("master", mode = "list", envir = envir, 
[09:30:13.323]                           inherits = FALSE)) {
[09:30:13.323]                           master <- get("master", mode = "list", 
[09:30:13.323]                             envir = envir, inherits = FALSE)
[09:30:13.323]                           if (inherits(master, c("SOCKnode", 
[09:30:13.323]                             "SOCK0node"))) {
[09:30:13.323]                             sendCondition <<- function(cond) {
[09:30:13.323]                               data <- list(type = "VALUE", value = cond, 
[09:30:13.323]                                 success = TRUE)
[09:30:13.323]                               parallel_sendData(master, data)
[09:30:13.323]                             }
[09:30:13.323]                             return(sendCondition)
[09:30:13.323]                           }
[09:30:13.323]                         }
[09:30:13.323]                         frame <- frame + 1L
[09:30:13.323]                         envir <- sys.frame(frame)
[09:30:13.323]                       }
[09:30:13.323]                     }
[09:30:13.323]                     sendCondition <<- function(cond) NULL
[09:30:13.323]                   }
[09:30:13.323]                 })
[09:30:13.323]                 withCallingHandlers({
[09:30:13.323]                   {
[09:30:13.323]                     do.call(function(...) {
[09:30:13.323]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:13.323]                       if (!identical(...future.globals.maxSize.org, 
[09:30:13.323]                         ...future.globals.maxSize)) {
[09:30:13.323]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:13.323]                         on.exit(options(oopts), add = TRUE)
[09:30:13.323]                       }
[09:30:13.323]                       {
[09:30:13.323]                         lapply(seq_along(...future.elements_ii), 
[09:30:13.323]                           FUN = function(jj) {
[09:30:13.323]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:13.323]                             ...future.FUN(...future.X_jj, ...)
[09:30:13.323]                           })
[09:30:13.323]                       }
[09:30:13.323]                     }, args = future.call.arguments)
[09:30:13.323]                   }
[09:30:13.323]                 }, immediateCondition = function(cond) {
[09:30:13.323]                   sendCondition <- ...future.makeSendCondition()
[09:30:13.323]                   sendCondition(cond)
[09:30:13.323]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:13.323]                   {
[09:30:13.323]                     inherits <- base::inherits
[09:30:13.323]                     invokeRestart <- base::invokeRestart
[09:30:13.323]                     is.null <- base::is.null
[09:30:13.323]                     muffled <- FALSE
[09:30:13.323]                     if (inherits(cond, "message")) {
[09:30:13.323]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:13.323]                       if (muffled) 
[09:30:13.323]                         invokeRestart("muffleMessage")
[09:30:13.323]                     }
[09:30:13.323]                     else if (inherits(cond, "warning")) {
[09:30:13.323]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:13.323]                       if (muffled) 
[09:30:13.323]                         invokeRestart("muffleWarning")
[09:30:13.323]                     }
[09:30:13.323]                     else if (inherits(cond, "condition")) {
[09:30:13.323]                       if (!is.null(pattern)) {
[09:30:13.323]                         computeRestarts <- base::computeRestarts
[09:30:13.323]                         grepl <- base::grepl
[09:30:13.323]                         restarts <- computeRestarts(cond)
[09:30:13.323]                         for (restart in restarts) {
[09:30:13.323]                           name <- restart$name
[09:30:13.323]                           if (is.null(name)) 
[09:30:13.323]                             next
[09:30:13.323]                           if (!grepl(pattern, name)) 
[09:30:13.323]                             next
[09:30:13.323]                           invokeRestart(restart)
[09:30:13.323]                           muffled <- TRUE
[09:30:13.323]                           break
[09:30:13.323]                         }
[09:30:13.323]                       }
[09:30:13.323]                     }
[09:30:13.323]                     invisible(muffled)
[09:30:13.323]                   }
[09:30:13.323]                   muffleCondition(cond)
[09:30:13.323]                 })
[09:30:13.323]             }))
[09:30:13.323]             future::FutureResult(value = ...future.value$value, 
[09:30:13.323]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:13.323]                   ...future.rng), globalenv = if (FALSE) 
[09:30:13.323]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:13.323]                     ...future.globalenv.names))
[09:30:13.323]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:13.323]         }, condition = base::local({
[09:30:13.323]             c <- base::c
[09:30:13.323]             inherits <- base::inherits
[09:30:13.323]             invokeRestart <- base::invokeRestart
[09:30:13.323]             length <- base::length
[09:30:13.323]             list <- base::list
[09:30:13.323]             seq.int <- base::seq.int
[09:30:13.323]             signalCondition <- base::signalCondition
[09:30:13.323]             sys.calls <- base::sys.calls
[09:30:13.323]             `[[` <- base::`[[`
[09:30:13.323]             `+` <- base::`+`
[09:30:13.323]             `<<-` <- base::`<<-`
[09:30:13.323]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:13.323]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:13.323]                   3L)]
[09:30:13.323]             }
[09:30:13.323]             function(cond) {
[09:30:13.323]                 is_error <- inherits(cond, "error")
[09:30:13.323]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:13.323]                   NULL)
[09:30:13.323]                 if (is_error) {
[09:30:13.323]                   sessionInformation <- function() {
[09:30:13.323]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:13.323]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:13.323]                       search = base::search(), system = base::Sys.info())
[09:30:13.323]                   }
[09:30:13.323]                   ...future.conditions[[length(...future.conditions) + 
[09:30:13.323]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:13.323]                     cond$call), session = sessionInformation(), 
[09:30:13.323]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:13.323]                   signalCondition(cond)
[09:30:13.323]                 }
[09:30:13.323]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:13.323]                 "immediateCondition"))) {
[09:30:13.323]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:13.323]                   ...future.conditions[[length(...future.conditions) + 
[09:30:13.323]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:13.323]                   if (TRUE && !signal) {
[09:30:13.323]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:13.323]                     {
[09:30:13.323]                       inherits <- base::inherits
[09:30:13.323]                       invokeRestart <- base::invokeRestart
[09:30:13.323]                       is.null <- base::is.null
[09:30:13.323]                       muffled <- FALSE
[09:30:13.323]                       if (inherits(cond, "message")) {
[09:30:13.323]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:13.323]                         if (muffled) 
[09:30:13.323]                           invokeRestart("muffleMessage")
[09:30:13.323]                       }
[09:30:13.323]                       else if (inherits(cond, "warning")) {
[09:30:13.323]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:13.323]                         if (muffled) 
[09:30:13.323]                           invokeRestart("muffleWarning")
[09:30:13.323]                       }
[09:30:13.323]                       else if (inherits(cond, "condition")) {
[09:30:13.323]                         if (!is.null(pattern)) {
[09:30:13.323]                           computeRestarts <- base::computeRestarts
[09:30:13.323]                           grepl <- base::grepl
[09:30:13.323]                           restarts <- computeRestarts(cond)
[09:30:13.323]                           for (restart in restarts) {
[09:30:13.323]                             name <- restart$name
[09:30:13.323]                             if (is.null(name)) 
[09:30:13.323]                               next
[09:30:13.323]                             if (!grepl(pattern, name)) 
[09:30:13.323]                               next
[09:30:13.323]                             invokeRestart(restart)
[09:30:13.323]                             muffled <- TRUE
[09:30:13.323]                             break
[09:30:13.323]                           }
[09:30:13.323]                         }
[09:30:13.323]                       }
[09:30:13.323]                       invisible(muffled)
[09:30:13.323]                     }
[09:30:13.323]                     muffleCondition(cond, pattern = "^muffle")
[09:30:13.323]                   }
[09:30:13.323]                 }
[09:30:13.323]                 else {
[09:30:13.323]                   if (TRUE) {
[09:30:13.323]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:13.323]                     {
[09:30:13.323]                       inherits <- base::inherits
[09:30:13.323]                       invokeRestart <- base::invokeRestart
[09:30:13.323]                       is.null <- base::is.null
[09:30:13.323]                       muffled <- FALSE
[09:30:13.323]                       if (inherits(cond, "message")) {
[09:30:13.323]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:13.323]                         if (muffled) 
[09:30:13.323]                           invokeRestart("muffleMessage")
[09:30:13.323]                       }
[09:30:13.323]                       else if (inherits(cond, "warning")) {
[09:30:13.323]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:13.323]                         if (muffled) 
[09:30:13.323]                           invokeRestart("muffleWarning")
[09:30:13.323]                       }
[09:30:13.323]                       else if (inherits(cond, "condition")) {
[09:30:13.323]                         if (!is.null(pattern)) {
[09:30:13.323]                           computeRestarts <- base::computeRestarts
[09:30:13.323]                           grepl <- base::grepl
[09:30:13.323]                           restarts <- computeRestarts(cond)
[09:30:13.323]                           for (restart in restarts) {
[09:30:13.323]                             name <- restart$name
[09:30:13.323]                             if (is.null(name)) 
[09:30:13.323]                               next
[09:30:13.323]                             if (!grepl(pattern, name)) 
[09:30:13.323]                               next
[09:30:13.323]                             invokeRestart(restart)
[09:30:13.323]                             muffled <- TRUE
[09:30:13.323]                             break
[09:30:13.323]                           }
[09:30:13.323]                         }
[09:30:13.323]                       }
[09:30:13.323]                       invisible(muffled)
[09:30:13.323]                     }
[09:30:13.323]                     muffleCondition(cond, pattern = "^muffle")
[09:30:13.323]                   }
[09:30:13.323]                 }
[09:30:13.323]             }
[09:30:13.323]         }))
[09:30:13.323]     }, error = function(ex) {
[09:30:13.323]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:13.323]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:13.323]                 ...future.rng), started = ...future.startTime, 
[09:30:13.323]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:13.323]             version = "1.8"), class = "FutureResult")
[09:30:13.323]     }, finally = {
[09:30:13.323]         if (!identical(...future.workdir, getwd())) 
[09:30:13.323]             setwd(...future.workdir)
[09:30:13.323]         {
[09:30:13.323]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:13.323]                 ...future.oldOptions$nwarnings <- NULL
[09:30:13.323]             }
[09:30:13.323]             base::options(...future.oldOptions)
[09:30:13.323]             if (.Platform$OS.type == "windows") {
[09:30:13.323]                 old_names <- names(...future.oldEnvVars)
[09:30:13.323]                 envs <- base::Sys.getenv()
[09:30:13.323]                 names <- names(envs)
[09:30:13.323]                 common <- intersect(names, old_names)
[09:30:13.323]                 added <- setdiff(names, old_names)
[09:30:13.323]                 removed <- setdiff(old_names, names)
[09:30:13.323]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:13.323]                   envs[common]]
[09:30:13.323]                 NAMES <- toupper(changed)
[09:30:13.323]                 args <- list()
[09:30:13.323]                 for (kk in seq_along(NAMES)) {
[09:30:13.323]                   name <- changed[[kk]]
[09:30:13.323]                   NAME <- NAMES[[kk]]
[09:30:13.323]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:13.323]                     next
[09:30:13.323]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:13.323]                 }
[09:30:13.323]                 NAMES <- toupper(added)
[09:30:13.323]                 for (kk in seq_along(NAMES)) {
[09:30:13.323]                   name <- added[[kk]]
[09:30:13.323]                   NAME <- NAMES[[kk]]
[09:30:13.323]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:13.323]                     next
[09:30:13.323]                   args[[name]] <- ""
[09:30:13.323]                 }
[09:30:13.323]                 NAMES <- toupper(removed)
[09:30:13.323]                 for (kk in seq_along(NAMES)) {
[09:30:13.323]                   name <- removed[[kk]]
[09:30:13.323]                   NAME <- NAMES[[kk]]
[09:30:13.323]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:13.323]                     next
[09:30:13.323]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:13.323]                 }
[09:30:13.323]                 if (length(args) > 0) 
[09:30:13.323]                   base::do.call(base::Sys.setenv, args = args)
[09:30:13.323]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:13.323]             }
[09:30:13.323]             else {
[09:30:13.323]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:13.323]             }
[09:30:13.323]             {
[09:30:13.323]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:13.323]                   0L) {
[09:30:13.323]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:13.323]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:13.323]                   base::options(opts)
[09:30:13.323]                 }
[09:30:13.323]                 {
[09:30:13.323]                   {
[09:30:13.323]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:13.323]                     NULL
[09:30:13.323]                   }
[09:30:13.323]                   options(future.plan = NULL)
[09:30:13.323]                   if (is.na(NA_character_)) 
[09:30:13.323]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:13.323]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:13.323]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:13.323]                     .init = FALSE)
[09:30:13.323]                 }
[09:30:13.323]             }
[09:30:13.323]         }
[09:30:13.323]     })
[09:30:13.323]     if (TRUE) {
[09:30:13.323]         base::sink(type = "output", split = FALSE)
[09:30:13.323]         if (FALSE) {
[09:30:13.323]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:13.323]         }
[09:30:13.323]         else {
[09:30:13.323]             ...future.result["stdout"] <- base::list(NULL)
[09:30:13.323]         }
[09:30:13.323]         base::close(...future.stdout)
[09:30:13.323]         ...future.stdout <- NULL
[09:30:13.323]     }
[09:30:13.323]     ...future.result$conditions <- ...future.conditions
[09:30:13.323]     ...future.result$finished <- base::Sys.time()
[09:30:13.323]     ...future.result
[09:30:13.323] }
[09:30:13.326] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[09:30:13.327] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[09:30:13.327] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[09:30:13.327] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:30:13.328] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:30:13.328] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[09:30:13.328] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[09:30:13.328] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:30:13.329] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:30:13.329] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:30:13.329] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:30:13.329] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[09:30:13.330] MultisessionFuture started
[09:30:13.330] - Launch lazy future ... done
[09:30:13.330] run() for ‘MultisessionFuture’ ... done
[09:30:13.330] Created future:
[09:30:13.330] MultisessionFuture:
[09:30:13.330] Label: ‘future_lapply-1’
[09:30:13.330] Expression:
[09:30:13.330] {
[09:30:13.330]     do.call(function(...) {
[09:30:13.330]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:13.330]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:13.330]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:13.330]             on.exit(options(oopts), add = TRUE)
[09:30:13.330]         }
[09:30:13.330]         {
[09:30:13.330]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:13.330]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:13.330]                 ...future.FUN(...future.X_jj, ...)
[09:30:13.330]             })
[09:30:13.330]         }
[09:30:13.330]     }, args = future.call.arguments)
[09:30:13.330] }
[09:30:13.330] Lazy evaluation: FALSE
[09:30:13.330] Asynchronous evaluation: TRUE
[09:30:13.330] Local evaluation: TRUE
[09:30:13.330] Environment: R_GlobalEnv
[09:30:13.330] Capture standard output: FALSE
[09:30:13.330] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:13.330] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:13.330] Packages: <none>
[09:30:13.330] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:13.330] Resolved: FALSE
[09:30:13.330] Value: <not collected>
[09:30:13.330] Conditions captured: <none>
[09:30:13.330] Early signaling: FALSE
[09:30:13.330] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:13.330] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:13.342] Chunk #1 of 2 ... DONE
[09:30:13.343] Chunk #2 of 2 ...
[09:30:13.343]  - Finding globals in 'X' for chunk #2 ...
[09:30:13.343] getGlobalsAndPackages() ...
[09:30:13.343] Searching for globals...
[09:30:13.343] 
[09:30:13.343] Searching for globals ... DONE
[09:30:13.344] - globals: [0] <none>
[09:30:13.344] getGlobalsAndPackages() ... DONE
[09:30:13.344]    + additional globals found: [n=0] 
[09:30:13.344]    + additional namespaces needed: [n=0] 
[09:30:13.344]  - Finding globals in 'X' for chunk #2 ... DONE
[09:30:13.344]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:13.344]  - seeds: <none>
[09:30:13.344]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:13.345] getGlobalsAndPackages() ...
[09:30:13.345] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:13.345] Resolving globals: FALSE
[09:30:13.345] Tweak future expression to call with '...' arguments ...
[09:30:13.345] {
[09:30:13.345]     do.call(function(...) {
[09:30:13.345]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:13.345]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:13.345]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:13.345]             on.exit(options(oopts), add = TRUE)
[09:30:13.345]         }
[09:30:13.345]         {
[09:30:13.345]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:13.345]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:13.345]                 ...future.FUN(...future.X_jj, ...)
[09:30:13.345]             })
[09:30:13.345]         }
[09:30:13.345]     }, args = future.call.arguments)
[09:30:13.345] }
[09:30:13.345] Tweak future expression to call with '...' arguments ... DONE
[09:30:13.346] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:13.346] 
[09:30:13.346] getGlobalsAndPackages() ... DONE
[09:30:13.346] run() for ‘Future’ ...
[09:30:13.346] - state: ‘created’
[09:30:13.347] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:30:13.361] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:13.361] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:30:13.361]   - Field: ‘node’
[09:30:13.361]   - Field: ‘label’
[09:30:13.361]   - Field: ‘local’
[09:30:13.361]   - Field: ‘owner’
[09:30:13.361]   - Field: ‘envir’
[09:30:13.361]   - Field: ‘workers’
[09:30:13.361]   - Field: ‘packages’
[09:30:13.362]   - Field: ‘gc’
[09:30:13.362]   - Field: ‘conditions’
[09:30:13.362]   - Field: ‘persistent’
[09:30:13.362]   - Field: ‘expr’
[09:30:13.362]   - Field: ‘uuid’
[09:30:13.362]   - Field: ‘seed’
[09:30:13.362]   - Field: ‘version’
[09:30:13.362]   - Field: ‘result’
[09:30:13.362]   - Field: ‘asynchronous’
[09:30:13.363]   - Field: ‘calls’
[09:30:13.363]   - Field: ‘globals’
[09:30:13.363]   - Field: ‘stdout’
[09:30:13.363]   - Field: ‘earlySignal’
[09:30:13.363]   - Field: ‘lazy’
[09:30:13.363]   - Field: ‘state’
[09:30:13.363] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:30:13.363] - Launch lazy future ...
[09:30:13.364] Packages needed by the future expression (n = 0): <none>
[09:30:13.364] Packages needed by future strategies (n = 0): <none>
[09:30:13.364] {
[09:30:13.364]     {
[09:30:13.364]         {
[09:30:13.364]             ...future.startTime <- base::Sys.time()
[09:30:13.364]             {
[09:30:13.364]                 {
[09:30:13.364]                   {
[09:30:13.364]                     {
[09:30:13.364]                       base::local({
[09:30:13.364]                         has_future <- base::requireNamespace("future", 
[09:30:13.364]                           quietly = TRUE)
[09:30:13.364]                         if (has_future) {
[09:30:13.364]                           ns <- base::getNamespace("future")
[09:30:13.364]                           version <- ns[[".package"]][["version"]]
[09:30:13.364]                           if (is.null(version)) 
[09:30:13.364]                             version <- utils::packageVersion("future")
[09:30:13.364]                         }
[09:30:13.364]                         else {
[09:30:13.364]                           version <- NULL
[09:30:13.364]                         }
[09:30:13.364]                         if (!has_future || version < "1.8.0") {
[09:30:13.364]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:13.364]                             "", base::R.version$version.string), 
[09:30:13.364]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:13.364]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:13.364]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:13.364]                               "release", "version")], collapse = " "), 
[09:30:13.364]                             hostname = base::Sys.info()[["nodename"]])
[09:30:13.364]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:13.364]                             info)
[09:30:13.364]                           info <- base::paste(info, collapse = "; ")
[09:30:13.364]                           if (!has_future) {
[09:30:13.364]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:13.364]                               info)
[09:30:13.364]                           }
[09:30:13.364]                           else {
[09:30:13.364]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:13.364]                               info, version)
[09:30:13.364]                           }
[09:30:13.364]                           base::stop(msg)
[09:30:13.364]                         }
[09:30:13.364]                       })
[09:30:13.364]                     }
[09:30:13.364]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:13.364]                     base::options(mc.cores = 1L)
[09:30:13.364]                   }
[09:30:13.364]                   ...future.strategy.old <- future::plan("list")
[09:30:13.364]                   options(future.plan = NULL)
[09:30:13.364]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:13.364]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:13.364]                 }
[09:30:13.364]                 ...future.workdir <- getwd()
[09:30:13.364]             }
[09:30:13.364]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:13.364]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:13.364]         }
[09:30:13.364]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:13.364]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:13.364]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:13.364]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:13.364]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:13.364]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:13.364]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:13.364]             base::names(...future.oldOptions))
[09:30:13.364]     }
[09:30:13.364]     if (FALSE) {
[09:30:13.364]     }
[09:30:13.364]     else {
[09:30:13.364]         if (FALSE) {
[09:30:13.364]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:13.364]                 open = "w")
[09:30:13.364]         }
[09:30:13.364]         else {
[09:30:13.364]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:13.364]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:13.364]         }
[09:30:13.364]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:13.364]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:13.364]             base::sink(type = "output", split = FALSE)
[09:30:13.364]             base::close(...future.stdout)
[09:30:13.364]         }, add = TRUE)
[09:30:13.364]     }
[09:30:13.364]     ...future.frame <- base::sys.nframe()
[09:30:13.364]     ...future.conditions <- base::list()
[09:30:13.364]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:13.364]     if (FALSE) {
[09:30:13.364]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:13.364]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:13.364]     }
[09:30:13.364]     ...future.result <- base::tryCatch({
[09:30:13.364]         base::withCallingHandlers({
[09:30:13.364]             ...future.value <- base::withVisible(base::local({
[09:30:13.364]                 ...future.makeSendCondition <- base::local({
[09:30:13.364]                   sendCondition <- NULL
[09:30:13.364]                   function(frame = 1L) {
[09:30:13.364]                     if (is.function(sendCondition)) 
[09:30:13.364]                       return(sendCondition)
[09:30:13.364]                     ns <- getNamespace("parallel")
[09:30:13.364]                     if (exists("sendData", mode = "function", 
[09:30:13.364]                       envir = ns)) {
[09:30:13.364]                       parallel_sendData <- get("sendData", mode = "function", 
[09:30:13.364]                         envir = ns)
[09:30:13.364]                       envir <- sys.frame(frame)
[09:30:13.364]                       master <- NULL
[09:30:13.364]                       while (!identical(envir, .GlobalEnv) && 
[09:30:13.364]                         !identical(envir, emptyenv())) {
[09:30:13.364]                         if (exists("master", mode = "list", envir = envir, 
[09:30:13.364]                           inherits = FALSE)) {
[09:30:13.364]                           master <- get("master", mode = "list", 
[09:30:13.364]                             envir = envir, inherits = FALSE)
[09:30:13.364]                           if (inherits(master, c("SOCKnode", 
[09:30:13.364]                             "SOCK0node"))) {
[09:30:13.364]                             sendCondition <<- function(cond) {
[09:30:13.364]                               data <- list(type = "VALUE", value = cond, 
[09:30:13.364]                                 success = TRUE)
[09:30:13.364]                               parallel_sendData(master, data)
[09:30:13.364]                             }
[09:30:13.364]                             return(sendCondition)
[09:30:13.364]                           }
[09:30:13.364]                         }
[09:30:13.364]                         frame <- frame + 1L
[09:30:13.364]                         envir <- sys.frame(frame)
[09:30:13.364]                       }
[09:30:13.364]                     }
[09:30:13.364]                     sendCondition <<- function(cond) NULL
[09:30:13.364]                   }
[09:30:13.364]                 })
[09:30:13.364]                 withCallingHandlers({
[09:30:13.364]                   {
[09:30:13.364]                     do.call(function(...) {
[09:30:13.364]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:13.364]                       if (!identical(...future.globals.maxSize.org, 
[09:30:13.364]                         ...future.globals.maxSize)) {
[09:30:13.364]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:13.364]                         on.exit(options(oopts), add = TRUE)
[09:30:13.364]                       }
[09:30:13.364]                       {
[09:30:13.364]                         lapply(seq_along(...future.elements_ii), 
[09:30:13.364]                           FUN = function(jj) {
[09:30:13.364]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:13.364]                             ...future.FUN(...future.X_jj, ...)
[09:30:13.364]                           })
[09:30:13.364]                       }
[09:30:13.364]                     }, args = future.call.arguments)
[09:30:13.364]                   }
[09:30:13.364]                 }, immediateCondition = function(cond) {
[09:30:13.364]                   sendCondition <- ...future.makeSendCondition()
[09:30:13.364]                   sendCondition(cond)
[09:30:13.364]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:13.364]                   {
[09:30:13.364]                     inherits <- base::inherits
[09:30:13.364]                     invokeRestart <- base::invokeRestart
[09:30:13.364]                     is.null <- base::is.null
[09:30:13.364]                     muffled <- FALSE
[09:30:13.364]                     if (inherits(cond, "message")) {
[09:30:13.364]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:13.364]                       if (muffled) 
[09:30:13.364]                         invokeRestart("muffleMessage")
[09:30:13.364]                     }
[09:30:13.364]                     else if (inherits(cond, "warning")) {
[09:30:13.364]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:13.364]                       if (muffled) 
[09:30:13.364]                         invokeRestart("muffleWarning")
[09:30:13.364]                     }
[09:30:13.364]                     else if (inherits(cond, "condition")) {
[09:30:13.364]                       if (!is.null(pattern)) {
[09:30:13.364]                         computeRestarts <- base::computeRestarts
[09:30:13.364]                         grepl <- base::grepl
[09:30:13.364]                         restarts <- computeRestarts(cond)
[09:30:13.364]                         for (restart in restarts) {
[09:30:13.364]                           name <- restart$name
[09:30:13.364]                           if (is.null(name)) 
[09:30:13.364]                             next
[09:30:13.364]                           if (!grepl(pattern, name)) 
[09:30:13.364]                             next
[09:30:13.364]                           invokeRestart(restart)
[09:30:13.364]                           muffled <- TRUE
[09:30:13.364]                           break
[09:30:13.364]                         }
[09:30:13.364]                       }
[09:30:13.364]                     }
[09:30:13.364]                     invisible(muffled)
[09:30:13.364]                   }
[09:30:13.364]                   muffleCondition(cond)
[09:30:13.364]                 })
[09:30:13.364]             }))
[09:30:13.364]             future::FutureResult(value = ...future.value$value, 
[09:30:13.364]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:13.364]                   ...future.rng), globalenv = if (FALSE) 
[09:30:13.364]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:13.364]                     ...future.globalenv.names))
[09:30:13.364]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:13.364]         }, condition = base::local({
[09:30:13.364]             c <- base::c
[09:30:13.364]             inherits <- base::inherits
[09:30:13.364]             invokeRestart <- base::invokeRestart
[09:30:13.364]             length <- base::length
[09:30:13.364]             list <- base::list
[09:30:13.364]             seq.int <- base::seq.int
[09:30:13.364]             signalCondition <- base::signalCondition
[09:30:13.364]             sys.calls <- base::sys.calls
[09:30:13.364]             `[[` <- base::`[[`
[09:30:13.364]             `+` <- base::`+`
[09:30:13.364]             `<<-` <- base::`<<-`
[09:30:13.364]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:13.364]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:13.364]                   3L)]
[09:30:13.364]             }
[09:30:13.364]             function(cond) {
[09:30:13.364]                 is_error <- inherits(cond, "error")
[09:30:13.364]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:13.364]                   NULL)
[09:30:13.364]                 if (is_error) {
[09:30:13.364]                   sessionInformation <- function() {
[09:30:13.364]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:13.364]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:13.364]                       search = base::search(), system = base::Sys.info())
[09:30:13.364]                   }
[09:30:13.364]                   ...future.conditions[[length(...future.conditions) + 
[09:30:13.364]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:13.364]                     cond$call), session = sessionInformation(), 
[09:30:13.364]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:13.364]                   signalCondition(cond)
[09:30:13.364]                 }
[09:30:13.364]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:13.364]                 "immediateCondition"))) {
[09:30:13.364]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:13.364]                   ...future.conditions[[length(...future.conditions) + 
[09:30:13.364]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:13.364]                   if (TRUE && !signal) {
[09:30:13.364]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:13.364]                     {
[09:30:13.364]                       inherits <- base::inherits
[09:30:13.364]                       invokeRestart <- base::invokeRestart
[09:30:13.364]                       is.null <- base::is.null
[09:30:13.364]                       muffled <- FALSE
[09:30:13.364]                       if (inherits(cond, "message")) {
[09:30:13.364]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:13.364]                         if (muffled) 
[09:30:13.364]                           invokeRestart("muffleMessage")
[09:30:13.364]                       }
[09:30:13.364]                       else if (inherits(cond, "warning")) {
[09:30:13.364]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:13.364]                         if (muffled) 
[09:30:13.364]                           invokeRestart("muffleWarning")
[09:30:13.364]                       }
[09:30:13.364]                       else if (inherits(cond, "condition")) {
[09:30:13.364]                         if (!is.null(pattern)) {
[09:30:13.364]                           computeRestarts <- base::computeRestarts
[09:30:13.364]                           grepl <- base::grepl
[09:30:13.364]                           restarts <- computeRestarts(cond)
[09:30:13.364]                           for (restart in restarts) {
[09:30:13.364]                             name <- restart$name
[09:30:13.364]                             if (is.null(name)) 
[09:30:13.364]                               next
[09:30:13.364]                             if (!grepl(pattern, name)) 
[09:30:13.364]                               next
[09:30:13.364]                             invokeRestart(restart)
[09:30:13.364]                             muffled <- TRUE
[09:30:13.364]                             break
[09:30:13.364]                           }
[09:30:13.364]                         }
[09:30:13.364]                       }
[09:30:13.364]                       invisible(muffled)
[09:30:13.364]                     }
[09:30:13.364]                     muffleCondition(cond, pattern = "^muffle")
[09:30:13.364]                   }
[09:30:13.364]                 }
[09:30:13.364]                 else {
[09:30:13.364]                   if (TRUE) {
[09:30:13.364]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:13.364]                     {
[09:30:13.364]                       inherits <- base::inherits
[09:30:13.364]                       invokeRestart <- base::invokeRestart
[09:30:13.364]                       is.null <- base::is.null
[09:30:13.364]                       muffled <- FALSE
[09:30:13.364]                       if (inherits(cond, "message")) {
[09:30:13.364]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:13.364]                         if (muffled) 
[09:30:13.364]                           invokeRestart("muffleMessage")
[09:30:13.364]                       }
[09:30:13.364]                       else if (inherits(cond, "warning")) {
[09:30:13.364]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:13.364]                         if (muffled) 
[09:30:13.364]                           invokeRestart("muffleWarning")
[09:30:13.364]                       }
[09:30:13.364]                       else if (inherits(cond, "condition")) {
[09:30:13.364]                         if (!is.null(pattern)) {
[09:30:13.364]                           computeRestarts <- base::computeRestarts
[09:30:13.364]                           grepl <- base::grepl
[09:30:13.364]                           restarts <- computeRestarts(cond)
[09:30:13.364]                           for (restart in restarts) {
[09:30:13.364]                             name <- restart$name
[09:30:13.364]                             if (is.null(name)) 
[09:30:13.364]                               next
[09:30:13.364]                             if (!grepl(pattern, name)) 
[09:30:13.364]                               next
[09:30:13.364]                             invokeRestart(restart)
[09:30:13.364]                             muffled <- TRUE
[09:30:13.364]                             break
[09:30:13.364]                           }
[09:30:13.364]                         }
[09:30:13.364]                       }
[09:30:13.364]                       invisible(muffled)
[09:30:13.364]                     }
[09:30:13.364]                     muffleCondition(cond, pattern = "^muffle")
[09:30:13.364]                   }
[09:30:13.364]                 }
[09:30:13.364]             }
[09:30:13.364]         }))
[09:30:13.364]     }, error = function(ex) {
[09:30:13.364]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:13.364]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:13.364]                 ...future.rng), started = ...future.startTime, 
[09:30:13.364]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:13.364]             version = "1.8"), class = "FutureResult")
[09:30:13.364]     }, finally = {
[09:30:13.364]         if (!identical(...future.workdir, getwd())) 
[09:30:13.364]             setwd(...future.workdir)
[09:30:13.364]         {
[09:30:13.364]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:13.364]                 ...future.oldOptions$nwarnings <- NULL
[09:30:13.364]             }
[09:30:13.364]             base::options(...future.oldOptions)
[09:30:13.364]             if (.Platform$OS.type == "windows") {
[09:30:13.364]                 old_names <- names(...future.oldEnvVars)
[09:30:13.364]                 envs <- base::Sys.getenv()
[09:30:13.364]                 names <- names(envs)
[09:30:13.364]                 common <- intersect(names, old_names)
[09:30:13.364]                 added <- setdiff(names, old_names)
[09:30:13.364]                 removed <- setdiff(old_names, names)
[09:30:13.364]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:13.364]                   envs[common]]
[09:30:13.364]                 NAMES <- toupper(changed)
[09:30:13.364]                 args <- list()
[09:30:13.364]                 for (kk in seq_along(NAMES)) {
[09:30:13.364]                   name <- changed[[kk]]
[09:30:13.364]                   NAME <- NAMES[[kk]]
[09:30:13.364]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:13.364]                     next
[09:30:13.364]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:13.364]                 }
[09:30:13.364]                 NAMES <- toupper(added)
[09:30:13.364]                 for (kk in seq_along(NAMES)) {
[09:30:13.364]                   name <- added[[kk]]
[09:30:13.364]                   NAME <- NAMES[[kk]]
[09:30:13.364]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:13.364]                     next
[09:30:13.364]                   args[[name]] <- ""
[09:30:13.364]                 }
[09:30:13.364]                 NAMES <- toupper(removed)
[09:30:13.364]                 for (kk in seq_along(NAMES)) {
[09:30:13.364]                   name <- removed[[kk]]
[09:30:13.364]                   NAME <- NAMES[[kk]]
[09:30:13.364]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:13.364]                     next
[09:30:13.364]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:13.364]                 }
[09:30:13.364]                 if (length(args) > 0) 
[09:30:13.364]                   base::do.call(base::Sys.setenv, args = args)
[09:30:13.364]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:13.364]             }
[09:30:13.364]             else {
[09:30:13.364]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:13.364]             }
[09:30:13.364]             {
[09:30:13.364]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:13.364]                   0L) {
[09:30:13.364]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:13.364]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:13.364]                   base::options(opts)
[09:30:13.364]                 }
[09:30:13.364]                 {
[09:30:13.364]                   {
[09:30:13.364]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:13.364]                     NULL
[09:30:13.364]                   }
[09:30:13.364]                   options(future.plan = NULL)
[09:30:13.364]                   if (is.na(NA_character_)) 
[09:30:13.364]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:13.364]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:13.364]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:13.364]                     .init = FALSE)
[09:30:13.364]                 }
[09:30:13.364]             }
[09:30:13.364]         }
[09:30:13.364]     })
[09:30:13.364]     if (TRUE) {
[09:30:13.364]         base::sink(type = "output", split = FALSE)
[09:30:13.364]         if (FALSE) {
[09:30:13.364]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:13.364]         }
[09:30:13.364]         else {
[09:30:13.364]             ...future.result["stdout"] <- base::list(NULL)
[09:30:13.364]         }
[09:30:13.364]         base::close(...future.stdout)
[09:30:13.364]         ...future.stdout <- NULL
[09:30:13.364]     }
[09:30:13.364]     ...future.result$conditions <- ...future.conditions
[09:30:13.364]     ...future.result$finished <- base::Sys.time()
[09:30:13.364]     ...future.result
[09:30:13.364] }
[09:30:13.418] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[09:30:13.418] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[09:30:13.419] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[09:30:13.419] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:30:13.419] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:30:13.420] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[09:30:13.420] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[09:30:13.420] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:30:13.421] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:30:13.421] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:30:13.421] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:30:13.421] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[09:30:13.422] MultisessionFuture started
[09:30:13.422] - Launch lazy future ... done
[09:30:13.422] run() for ‘MultisessionFuture’ ... done
[09:30:13.422] Created future:
[09:30:13.423] MultisessionFuture:
[09:30:13.423] Label: ‘future_lapply-2’
[09:30:13.423] Expression:
[09:30:13.423] {
[09:30:13.423]     do.call(function(...) {
[09:30:13.423]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:13.423]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:13.423]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:13.423]             on.exit(options(oopts), add = TRUE)
[09:30:13.423]         }
[09:30:13.423]         {
[09:30:13.423]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:13.423]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:13.423]                 ...future.FUN(...future.X_jj, ...)
[09:30:13.423]             })
[09:30:13.423]         }
[09:30:13.423]     }, args = future.call.arguments)
[09:30:13.423] }
[09:30:13.423] Lazy evaluation: FALSE
[09:30:13.423] Asynchronous evaluation: TRUE
[09:30:13.423] Local evaluation: TRUE
[09:30:13.423] Environment: R_GlobalEnv
[09:30:13.423] Capture standard output: FALSE
[09:30:13.423] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:13.423] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:13.423] Packages: <none>
[09:30:13.423] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:13.423] Resolved: FALSE
[09:30:13.423] Value: <not collected>
[09:30:13.423] Conditions captured: <none>
[09:30:13.423] Early signaling: FALSE
[09:30:13.423] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:13.423] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:13.434] Chunk #2 of 2 ... DONE
[09:30:13.435] Launching 2 futures (chunks) ... DONE
[09:30:13.435] Resolving 2 futures (chunks) ...
[09:30:13.435] resolve() on list ...
[09:30:13.435]  recursive: 0
[09:30:13.435]  length: 2
[09:30:13.435] 
[09:30:13.512] receiveMessageFromWorker() for ClusterFuture ...
[09:30:13.512] - Validating connection of MultisessionFuture
[09:30:13.512] - received message: FutureResult
[09:30:13.512] - Received FutureResult
[09:30:13.513] - Erased future from FutureRegistry
[09:30:13.513] result() for ClusterFuture ...
[09:30:13.513] - result already collected: FutureResult
[09:30:13.513] result() for ClusterFuture ... done
[09:30:13.513] receiveMessageFromWorker() for ClusterFuture ... done
[09:30:13.513] Future #2
[09:30:13.513] result() for ClusterFuture ...
[09:30:13.513] - result already collected: FutureResult
[09:30:13.513] result() for ClusterFuture ... done
[09:30:13.513] result() for ClusterFuture ...
[09:30:13.513] - result already collected: FutureResult
[09:30:13.514] result() for ClusterFuture ... done
[09:30:13.514] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:30:13.514] - nx: 2
[09:30:13.514] - relay: TRUE
[09:30:13.514] - stdout: TRUE
[09:30:13.514] - signal: TRUE
[09:30:13.514] - resignal: FALSE
[09:30:13.514] - force: TRUE
[09:30:13.514] - relayed: [n=2] FALSE, FALSE
[09:30:13.514] - queued futures: [n=2] FALSE, FALSE
[09:30:13.514]  - until=1
[09:30:13.514]  - relaying element #1
[09:30:13.515] - relayed: [n=2] FALSE, FALSE
[09:30:13.515] - queued futures: [n=2] FALSE, TRUE
[09:30:13.515] signalConditionsASAP(NULL, pos=2) ... done
[09:30:13.515]  length: 1 (resolved future 2)
[09:30:13.876] receiveMessageFromWorker() for ClusterFuture ...
[09:30:13.876] - Validating connection of MultisessionFuture
[09:30:13.876] - received message: FutureResult
[09:30:13.876] - Received FutureResult
[09:30:13.877] - Erased future from FutureRegistry
[09:30:13.877] result() for ClusterFuture ...
[09:30:13.877] - result already collected: FutureResult
[09:30:13.877] result() for ClusterFuture ... done
[09:30:13.877] receiveMessageFromWorker() for ClusterFuture ... done
[09:30:13.877] Future #1
[09:30:13.878] result() for ClusterFuture ...
[09:30:13.878] - result already collected: FutureResult
[09:30:13.878] result() for ClusterFuture ... done
[09:30:13.878] result() for ClusterFuture ...
[09:30:13.878] - result already collected: FutureResult
[09:30:13.878] result() for ClusterFuture ... done
[09:30:13.879] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:30:13.879] - nx: 2
[09:30:13.879] - relay: TRUE
[09:30:13.879] - stdout: TRUE
[09:30:13.879] - signal: TRUE
[09:30:13.879] - resignal: FALSE
[09:30:13.880] - force: TRUE
[09:30:13.880] - relayed: [n=2] FALSE, FALSE
[09:30:13.880] - queued futures: [n=2] FALSE, TRUE
[09:30:13.880]  - until=1
[09:30:13.880]  - relaying element #1
[09:30:13.880] result() for ClusterFuture ...
[09:30:13.881] - result already collected: FutureResult
[09:30:13.881] result() for ClusterFuture ... done
[09:30:13.881] result() for ClusterFuture ...
[09:30:13.881] - result already collected: FutureResult
[09:30:13.881] result() for ClusterFuture ... done
[09:30:13.882] result() for ClusterFuture ...
[09:30:13.882] - result already collected: FutureResult
[09:30:13.882] result() for ClusterFuture ... done
[09:30:13.882] result() for ClusterFuture ...
[09:30:13.882] - result already collected: FutureResult
[09:30:13.882] result() for ClusterFuture ... done
[09:30:13.882] - relayed: [n=2] TRUE, FALSE
[09:30:13.883] - queued futures: [n=2] TRUE, TRUE
[09:30:13.883] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:30:13.883]  length: 0 (resolved future 1)
[09:30:13.883] Relaying remaining futures
[09:30:13.883] signalConditionsASAP(NULL, pos=0) ...
[09:30:13.884] - nx: 2
[09:30:13.884] - relay: TRUE
[09:30:13.884] - stdout: TRUE
[09:30:13.884] - signal: TRUE
[09:30:13.884] - resignal: FALSE
[09:30:13.884] - force: TRUE
[09:30:13.884] - relayed: [n=2] TRUE, FALSE
[09:30:13.885] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:30:13.885]  - relaying element #2
[09:30:13.885] result() for ClusterFuture ...
[09:30:13.885] - result already collected: FutureResult
[09:30:13.885] result() for ClusterFuture ... done
[09:30:13.886] result() for ClusterFuture ...
[09:30:13.886] - result already collected: FutureResult
[09:30:13.886] result() for ClusterFuture ... done
[09:30:13.886] result() for ClusterFuture ...
[09:30:13.886] - result already collected: FutureResult
[09:30:13.886] result() for ClusterFuture ... done
[09:30:13.887] result() for ClusterFuture ...
[09:30:13.887] - result already collected: FutureResult
[09:30:13.887] result() for ClusterFuture ... done
[09:30:13.887] - relayed: [n=2] TRUE, TRUE
[09:30:13.887] - queued futures: [n=2] TRUE, TRUE
[09:30:13.887] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[09:30:13.888] resolve() on list ... DONE
[09:30:13.888] result() for ClusterFuture ...
[09:30:13.888] - result already collected: FutureResult
[09:30:13.888] result() for ClusterFuture ... done
[09:30:13.888] result() for ClusterFuture ...
[09:30:13.888] - result already collected: FutureResult
[09:30:13.889] result() for ClusterFuture ... done
[09:30:13.889] result() for ClusterFuture ...
[09:30:13.889] - result already collected: FutureResult
[09:30:13.889] result() for ClusterFuture ... done
[09:30:13.889] result() for ClusterFuture ...
[09:30:13.889] - result already collected: FutureResult
[09:30:13.890] result() for ClusterFuture ... done
[09:30:13.890]  - Number of value chunks collected: 2
[09:30:13.890] Resolving 2 futures (chunks) ... DONE
[09:30:13.890] Reducing values from 2 chunks ...
[09:30:13.890]  - Number of values collected after concatenation: 2
[09:30:13.890]  - Number of values expected: 2
[09:30:13.891] Reducing values from 2 chunks ... DONE
[09:30:13.891] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[09:30:13.891] future_lapply() ...
[09:30:13.898] Number of chunks: 2
[09:30:13.898] getGlobalsAndPackagesXApply() ...
[09:30:13.898]  - future.globals: TRUE
[09:30:13.898] getGlobalsAndPackages() ...
[09:30:13.898] Searching for globals...
[09:30:13.901] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[09:30:13.901] Searching for globals ... DONE
[09:30:13.901] Resolving globals: FALSE
[09:30:13.902] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[09:30:13.903] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[09:30:13.903] - globals: [1] ‘FUN’
[09:30:13.903] 
[09:30:13.903] getGlobalsAndPackages() ... DONE
[09:30:13.903]  - globals found/used: [n=1] ‘FUN’
[09:30:13.903]  - needed namespaces: [n=0] 
[09:30:13.904] Finding globals ... DONE
[09:30:13.904]  - use_args: TRUE
[09:30:13.904]  - Getting '...' globals ...
[09:30:13.905] resolve() on list ...
[09:30:13.905]  recursive: 0
[09:30:13.905]  length: 1
[09:30:13.905]  elements: ‘...’
[09:30:13.905]  length: 0 (resolved future 1)
[09:30:13.905] resolve() on list ... DONE
[09:30:13.906]    - '...' content: [n=0] 
[09:30:13.906] List of 1
[09:30:13.906]  $ ...: list()
[09:30:13.906]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:13.906]  - attr(*, "where")=List of 1
[09:30:13.906]   ..$ ...:<environment: 0x55c102115530> 
[09:30:13.906]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:13.906]  - attr(*, "resolved")= logi TRUE
[09:30:13.906]  - attr(*, "total_size")= num NA
[09:30:13.910]  - Getting '...' globals ... DONE
[09:30:13.911] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:30:13.911] List of 2
[09:30:13.911]  $ ...future.FUN:function (x)  
[09:30:13.911]  $ ...          : list()
[09:30:13.911]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:13.911]  - attr(*, "where")=List of 2
[09:30:13.911]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:13.911]   ..$ ...          :<environment: 0x55c102115530> 
[09:30:13.911]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:13.911]  - attr(*, "resolved")= logi FALSE
[09:30:13.911]  - attr(*, "total_size")= num 4720
[09:30:13.916] Packages to be attached in all futures: [n=0] 
[09:30:13.916] getGlobalsAndPackagesXApply() ... DONE
[09:30:13.916] Number of futures (= number of chunks): 2
[09:30:13.917] Launching 2 futures (chunks) ...
[09:30:13.917] Chunk #1 of 2 ...
[09:30:13.917]  - Finding globals in 'X' for chunk #1 ...
[09:30:13.917] getGlobalsAndPackages() ...
[09:30:13.917] Searching for globals...
[09:30:13.918] 
[09:30:13.918] Searching for globals ... DONE
[09:30:13.918] - globals: [0] <none>
[09:30:13.918] getGlobalsAndPackages() ... DONE
[09:30:13.918]    + additional globals found: [n=0] 
[09:30:13.919]    + additional namespaces needed: [n=0] 
[09:30:13.919]  - Finding globals in 'X' for chunk #1 ... DONE
[09:30:13.919]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:13.919]  - seeds: <none>
[09:30:13.919]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:13.919] getGlobalsAndPackages() ...
[09:30:13.920] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:13.920] Resolving globals: FALSE
[09:30:13.920] Tweak future expression to call with '...' arguments ...
[09:30:13.920] {
[09:30:13.920]     do.call(function(...) {
[09:30:13.920]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:13.920]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:13.920]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:13.920]             on.exit(options(oopts), add = TRUE)
[09:30:13.920]         }
[09:30:13.920]         {
[09:30:13.920]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:13.920]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:13.920]                 ...future.FUN(...future.X_jj, ...)
[09:30:13.920]             })
[09:30:13.920]         }
[09:30:13.920]     }, args = future.call.arguments)
[09:30:13.920] }
[09:30:13.921] Tweak future expression to call with '...' arguments ... DONE
[09:30:13.921] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:13.921] 
[09:30:13.922] getGlobalsAndPackages() ... DONE
[09:30:13.922] run() for ‘Future’ ...
[09:30:13.922] - state: ‘created’
[09:30:13.923] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:30:13.937] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:13.937] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:30:13.937]   - Field: ‘node’
[09:30:13.937]   - Field: ‘label’
[09:30:13.937]   - Field: ‘local’
[09:30:13.937]   - Field: ‘owner’
[09:30:13.937]   - Field: ‘envir’
[09:30:13.937]   - Field: ‘workers’
[09:30:13.938]   - Field: ‘packages’
[09:30:13.938]   - Field: ‘gc’
[09:30:13.938]   - Field: ‘conditions’
[09:30:13.938]   - Field: ‘persistent’
[09:30:13.938]   - Field: ‘expr’
[09:30:13.938]   - Field: ‘uuid’
[09:30:13.938]   - Field: ‘seed’
[09:30:13.938]   - Field: ‘version’
[09:30:13.938]   - Field: ‘result’
[09:30:13.938]   - Field: ‘asynchronous’
[09:30:13.938]   - Field: ‘calls’
[09:30:13.939]   - Field: ‘globals’
[09:30:13.939]   - Field: ‘stdout’
[09:30:13.939]   - Field: ‘earlySignal’
[09:30:13.939]   - Field: ‘lazy’
[09:30:13.939]   - Field: ‘state’
[09:30:13.939] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:30:13.939] - Launch lazy future ...
[09:30:13.939] Packages needed by the future expression (n = 0): <none>
[09:30:13.939] Packages needed by future strategies (n = 0): <none>
[09:30:13.940] {
[09:30:13.940]     {
[09:30:13.940]         {
[09:30:13.940]             ...future.startTime <- base::Sys.time()
[09:30:13.940]             {
[09:30:13.940]                 {
[09:30:13.940]                   {
[09:30:13.940]                     {
[09:30:13.940]                       base::local({
[09:30:13.940]                         has_future <- base::requireNamespace("future", 
[09:30:13.940]                           quietly = TRUE)
[09:30:13.940]                         if (has_future) {
[09:30:13.940]                           ns <- base::getNamespace("future")
[09:30:13.940]                           version <- ns[[".package"]][["version"]]
[09:30:13.940]                           if (is.null(version)) 
[09:30:13.940]                             version <- utils::packageVersion("future")
[09:30:13.940]                         }
[09:30:13.940]                         else {
[09:30:13.940]                           version <- NULL
[09:30:13.940]                         }
[09:30:13.940]                         if (!has_future || version < "1.8.0") {
[09:30:13.940]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:13.940]                             "", base::R.version$version.string), 
[09:30:13.940]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:13.940]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:13.940]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:13.940]                               "release", "version")], collapse = " "), 
[09:30:13.940]                             hostname = base::Sys.info()[["nodename"]])
[09:30:13.940]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:13.940]                             info)
[09:30:13.940]                           info <- base::paste(info, collapse = "; ")
[09:30:13.940]                           if (!has_future) {
[09:30:13.940]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:13.940]                               info)
[09:30:13.940]                           }
[09:30:13.940]                           else {
[09:30:13.940]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:13.940]                               info, version)
[09:30:13.940]                           }
[09:30:13.940]                           base::stop(msg)
[09:30:13.940]                         }
[09:30:13.940]                       })
[09:30:13.940]                     }
[09:30:13.940]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:13.940]                     base::options(mc.cores = 1L)
[09:30:13.940]                   }
[09:30:13.940]                   ...future.strategy.old <- future::plan("list")
[09:30:13.940]                   options(future.plan = NULL)
[09:30:13.940]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:13.940]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:13.940]                 }
[09:30:13.940]                 ...future.workdir <- getwd()
[09:30:13.940]             }
[09:30:13.940]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:13.940]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:13.940]         }
[09:30:13.940]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:13.940]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:13.940]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:13.940]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:13.940]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:13.940]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:13.940]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:13.940]             base::names(...future.oldOptions))
[09:30:13.940]     }
[09:30:13.940]     if (FALSE) {
[09:30:13.940]     }
[09:30:13.940]     else {
[09:30:13.940]         if (TRUE) {
[09:30:13.940]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:13.940]                 open = "w")
[09:30:13.940]         }
[09:30:13.940]         else {
[09:30:13.940]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:13.940]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:13.940]         }
[09:30:13.940]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:13.940]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:13.940]             base::sink(type = "output", split = FALSE)
[09:30:13.940]             base::close(...future.stdout)
[09:30:13.940]         }, add = TRUE)
[09:30:13.940]     }
[09:30:13.940]     ...future.frame <- base::sys.nframe()
[09:30:13.940]     ...future.conditions <- base::list()
[09:30:13.940]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:13.940]     if (FALSE) {
[09:30:13.940]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:13.940]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:13.940]     }
[09:30:13.940]     ...future.result <- base::tryCatch({
[09:30:13.940]         base::withCallingHandlers({
[09:30:13.940]             ...future.value <- base::withVisible(base::local({
[09:30:13.940]                 ...future.makeSendCondition <- base::local({
[09:30:13.940]                   sendCondition <- NULL
[09:30:13.940]                   function(frame = 1L) {
[09:30:13.940]                     if (is.function(sendCondition)) 
[09:30:13.940]                       return(sendCondition)
[09:30:13.940]                     ns <- getNamespace("parallel")
[09:30:13.940]                     if (exists("sendData", mode = "function", 
[09:30:13.940]                       envir = ns)) {
[09:30:13.940]                       parallel_sendData <- get("sendData", mode = "function", 
[09:30:13.940]                         envir = ns)
[09:30:13.940]                       envir <- sys.frame(frame)
[09:30:13.940]                       master <- NULL
[09:30:13.940]                       while (!identical(envir, .GlobalEnv) && 
[09:30:13.940]                         !identical(envir, emptyenv())) {
[09:30:13.940]                         if (exists("master", mode = "list", envir = envir, 
[09:30:13.940]                           inherits = FALSE)) {
[09:30:13.940]                           master <- get("master", mode = "list", 
[09:30:13.940]                             envir = envir, inherits = FALSE)
[09:30:13.940]                           if (inherits(master, c("SOCKnode", 
[09:30:13.940]                             "SOCK0node"))) {
[09:30:13.940]                             sendCondition <<- function(cond) {
[09:30:13.940]                               data <- list(type = "VALUE", value = cond, 
[09:30:13.940]                                 success = TRUE)
[09:30:13.940]                               parallel_sendData(master, data)
[09:30:13.940]                             }
[09:30:13.940]                             return(sendCondition)
[09:30:13.940]                           }
[09:30:13.940]                         }
[09:30:13.940]                         frame <- frame + 1L
[09:30:13.940]                         envir <- sys.frame(frame)
[09:30:13.940]                       }
[09:30:13.940]                     }
[09:30:13.940]                     sendCondition <<- function(cond) NULL
[09:30:13.940]                   }
[09:30:13.940]                 })
[09:30:13.940]                 withCallingHandlers({
[09:30:13.940]                   {
[09:30:13.940]                     do.call(function(...) {
[09:30:13.940]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:13.940]                       if (!identical(...future.globals.maxSize.org, 
[09:30:13.940]                         ...future.globals.maxSize)) {
[09:30:13.940]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:13.940]                         on.exit(options(oopts), add = TRUE)
[09:30:13.940]                       }
[09:30:13.940]                       {
[09:30:13.940]                         lapply(seq_along(...future.elements_ii), 
[09:30:13.940]                           FUN = function(jj) {
[09:30:13.940]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:13.940]                             ...future.FUN(...future.X_jj, ...)
[09:30:13.940]                           })
[09:30:13.940]                       }
[09:30:13.940]                     }, args = future.call.arguments)
[09:30:13.940]                   }
[09:30:13.940]                 }, immediateCondition = function(cond) {
[09:30:13.940]                   sendCondition <- ...future.makeSendCondition()
[09:30:13.940]                   sendCondition(cond)
[09:30:13.940]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:13.940]                   {
[09:30:13.940]                     inherits <- base::inherits
[09:30:13.940]                     invokeRestart <- base::invokeRestart
[09:30:13.940]                     is.null <- base::is.null
[09:30:13.940]                     muffled <- FALSE
[09:30:13.940]                     if (inherits(cond, "message")) {
[09:30:13.940]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:13.940]                       if (muffled) 
[09:30:13.940]                         invokeRestart("muffleMessage")
[09:30:13.940]                     }
[09:30:13.940]                     else if (inherits(cond, "warning")) {
[09:30:13.940]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:13.940]                       if (muffled) 
[09:30:13.940]                         invokeRestart("muffleWarning")
[09:30:13.940]                     }
[09:30:13.940]                     else if (inherits(cond, "condition")) {
[09:30:13.940]                       if (!is.null(pattern)) {
[09:30:13.940]                         computeRestarts <- base::computeRestarts
[09:30:13.940]                         grepl <- base::grepl
[09:30:13.940]                         restarts <- computeRestarts(cond)
[09:30:13.940]                         for (restart in restarts) {
[09:30:13.940]                           name <- restart$name
[09:30:13.940]                           if (is.null(name)) 
[09:30:13.940]                             next
[09:30:13.940]                           if (!grepl(pattern, name)) 
[09:30:13.940]                             next
[09:30:13.940]                           invokeRestart(restart)
[09:30:13.940]                           muffled <- TRUE
[09:30:13.940]                           break
[09:30:13.940]                         }
[09:30:13.940]                       }
[09:30:13.940]                     }
[09:30:13.940]                     invisible(muffled)
[09:30:13.940]                   }
[09:30:13.940]                   muffleCondition(cond)
[09:30:13.940]                 })
[09:30:13.940]             }))
[09:30:13.940]             future::FutureResult(value = ...future.value$value, 
[09:30:13.940]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:13.940]                   ...future.rng), globalenv = if (FALSE) 
[09:30:13.940]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:13.940]                     ...future.globalenv.names))
[09:30:13.940]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:13.940]         }, condition = base::local({
[09:30:13.940]             c <- base::c
[09:30:13.940]             inherits <- base::inherits
[09:30:13.940]             invokeRestart <- base::invokeRestart
[09:30:13.940]             length <- base::length
[09:30:13.940]             list <- base::list
[09:30:13.940]             seq.int <- base::seq.int
[09:30:13.940]             signalCondition <- base::signalCondition
[09:30:13.940]             sys.calls <- base::sys.calls
[09:30:13.940]             `[[` <- base::`[[`
[09:30:13.940]             `+` <- base::`+`
[09:30:13.940]             `<<-` <- base::`<<-`
[09:30:13.940]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:13.940]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:13.940]                   3L)]
[09:30:13.940]             }
[09:30:13.940]             function(cond) {
[09:30:13.940]                 is_error <- inherits(cond, "error")
[09:30:13.940]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:13.940]                   NULL)
[09:30:13.940]                 if (is_error) {
[09:30:13.940]                   sessionInformation <- function() {
[09:30:13.940]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:13.940]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:13.940]                       search = base::search(), system = base::Sys.info())
[09:30:13.940]                   }
[09:30:13.940]                   ...future.conditions[[length(...future.conditions) + 
[09:30:13.940]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:13.940]                     cond$call), session = sessionInformation(), 
[09:30:13.940]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:13.940]                   signalCondition(cond)
[09:30:13.940]                 }
[09:30:13.940]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:13.940]                 "immediateCondition"))) {
[09:30:13.940]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:13.940]                   ...future.conditions[[length(...future.conditions) + 
[09:30:13.940]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:13.940]                   if (TRUE && !signal) {
[09:30:13.940]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:13.940]                     {
[09:30:13.940]                       inherits <- base::inherits
[09:30:13.940]                       invokeRestart <- base::invokeRestart
[09:30:13.940]                       is.null <- base::is.null
[09:30:13.940]                       muffled <- FALSE
[09:30:13.940]                       if (inherits(cond, "message")) {
[09:30:13.940]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:13.940]                         if (muffled) 
[09:30:13.940]                           invokeRestart("muffleMessage")
[09:30:13.940]                       }
[09:30:13.940]                       else if (inherits(cond, "warning")) {
[09:30:13.940]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:13.940]                         if (muffled) 
[09:30:13.940]                           invokeRestart("muffleWarning")
[09:30:13.940]                       }
[09:30:13.940]                       else if (inherits(cond, "condition")) {
[09:30:13.940]                         if (!is.null(pattern)) {
[09:30:13.940]                           computeRestarts <- base::computeRestarts
[09:30:13.940]                           grepl <- base::grepl
[09:30:13.940]                           restarts <- computeRestarts(cond)
[09:30:13.940]                           for (restart in restarts) {
[09:30:13.940]                             name <- restart$name
[09:30:13.940]                             if (is.null(name)) 
[09:30:13.940]                               next
[09:30:13.940]                             if (!grepl(pattern, name)) 
[09:30:13.940]                               next
[09:30:13.940]                             invokeRestart(restart)
[09:30:13.940]                             muffled <- TRUE
[09:30:13.940]                             break
[09:30:13.940]                           }
[09:30:13.940]                         }
[09:30:13.940]                       }
[09:30:13.940]                       invisible(muffled)
[09:30:13.940]                     }
[09:30:13.940]                     muffleCondition(cond, pattern = "^muffle")
[09:30:13.940]                   }
[09:30:13.940]                 }
[09:30:13.940]                 else {
[09:30:13.940]                   if (TRUE) {
[09:30:13.940]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:13.940]                     {
[09:30:13.940]                       inherits <- base::inherits
[09:30:13.940]                       invokeRestart <- base::invokeRestart
[09:30:13.940]                       is.null <- base::is.null
[09:30:13.940]                       muffled <- FALSE
[09:30:13.940]                       if (inherits(cond, "message")) {
[09:30:13.940]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:13.940]                         if (muffled) 
[09:30:13.940]                           invokeRestart("muffleMessage")
[09:30:13.940]                       }
[09:30:13.940]                       else if (inherits(cond, "warning")) {
[09:30:13.940]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:13.940]                         if (muffled) 
[09:30:13.940]                           invokeRestart("muffleWarning")
[09:30:13.940]                       }
[09:30:13.940]                       else if (inherits(cond, "condition")) {
[09:30:13.940]                         if (!is.null(pattern)) {
[09:30:13.940]                           computeRestarts <- base::computeRestarts
[09:30:13.940]                           grepl <- base::grepl
[09:30:13.940]                           restarts <- computeRestarts(cond)
[09:30:13.940]                           for (restart in restarts) {
[09:30:13.940]                             name <- restart$name
[09:30:13.940]                             if (is.null(name)) 
[09:30:13.940]                               next
[09:30:13.940]                             if (!grepl(pattern, name)) 
[09:30:13.940]                               next
[09:30:13.940]                             invokeRestart(restart)
[09:30:13.940]                             muffled <- TRUE
[09:30:13.940]                             break
[09:30:13.940]                           }
[09:30:13.940]                         }
[09:30:13.940]                       }
[09:30:13.940]                       invisible(muffled)
[09:30:13.940]                     }
[09:30:13.940]                     muffleCondition(cond, pattern = "^muffle")
[09:30:13.940]                   }
[09:30:13.940]                 }
[09:30:13.940]             }
[09:30:13.940]         }))
[09:30:13.940]     }, error = function(ex) {
[09:30:13.940]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:13.940]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:13.940]                 ...future.rng), started = ...future.startTime, 
[09:30:13.940]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:13.940]             version = "1.8"), class = "FutureResult")
[09:30:13.940]     }, finally = {
[09:30:13.940]         if (!identical(...future.workdir, getwd())) 
[09:30:13.940]             setwd(...future.workdir)
[09:30:13.940]         {
[09:30:13.940]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:13.940]                 ...future.oldOptions$nwarnings <- NULL
[09:30:13.940]             }
[09:30:13.940]             base::options(...future.oldOptions)
[09:30:13.940]             if (.Platform$OS.type == "windows") {
[09:30:13.940]                 old_names <- names(...future.oldEnvVars)
[09:30:13.940]                 envs <- base::Sys.getenv()
[09:30:13.940]                 names <- names(envs)
[09:30:13.940]                 common <- intersect(names, old_names)
[09:30:13.940]                 added <- setdiff(names, old_names)
[09:30:13.940]                 removed <- setdiff(old_names, names)
[09:30:13.940]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:13.940]                   envs[common]]
[09:30:13.940]                 NAMES <- toupper(changed)
[09:30:13.940]                 args <- list()
[09:30:13.940]                 for (kk in seq_along(NAMES)) {
[09:30:13.940]                   name <- changed[[kk]]
[09:30:13.940]                   NAME <- NAMES[[kk]]
[09:30:13.940]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:13.940]                     next
[09:30:13.940]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:13.940]                 }
[09:30:13.940]                 NAMES <- toupper(added)
[09:30:13.940]                 for (kk in seq_along(NAMES)) {
[09:30:13.940]                   name <- added[[kk]]
[09:30:13.940]                   NAME <- NAMES[[kk]]
[09:30:13.940]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:13.940]                     next
[09:30:13.940]                   args[[name]] <- ""
[09:30:13.940]                 }
[09:30:13.940]                 NAMES <- toupper(removed)
[09:30:13.940]                 for (kk in seq_along(NAMES)) {
[09:30:13.940]                   name <- removed[[kk]]
[09:30:13.940]                   NAME <- NAMES[[kk]]
[09:30:13.940]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:13.940]                     next
[09:30:13.940]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:13.940]                 }
[09:30:13.940]                 if (length(args) > 0) 
[09:30:13.940]                   base::do.call(base::Sys.setenv, args = args)
[09:30:13.940]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:13.940]             }
[09:30:13.940]             else {
[09:30:13.940]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:13.940]             }
[09:30:13.940]             {
[09:30:13.940]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:13.940]                   0L) {
[09:30:13.940]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:13.940]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:13.940]                   base::options(opts)
[09:30:13.940]                 }
[09:30:13.940]                 {
[09:30:13.940]                   {
[09:30:13.940]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:13.940]                     NULL
[09:30:13.940]                   }
[09:30:13.940]                   options(future.plan = NULL)
[09:30:13.940]                   if (is.na(NA_character_)) 
[09:30:13.940]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:13.940]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:13.940]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:13.940]                     .init = FALSE)
[09:30:13.940]                 }
[09:30:13.940]             }
[09:30:13.940]         }
[09:30:13.940]     })
[09:30:13.940]     if (TRUE) {
[09:30:13.940]         base::sink(type = "output", split = FALSE)
[09:30:13.940]         if (TRUE) {
[09:30:13.940]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:13.940]         }
[09:30:13.940]         else {
[09:30:13.940]             ...future.result["stdout"] <- base::list(NULL)
[09:30:13.940]         }
[09:30:13.940]         base::close(...future.stdout)
[09:30:13.940]         ...future.stdout <- NULL
[09:30:13.940]     }
[09:30:13.940]     ...future.result$conditions <- ...future.conditions
[09:30:13.940]     ...future.result$finished <- base::Sys.time()
[09:30:13.940]     ...future.result
[09:30:13.940] }
[09:30:13.943] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[09:30:13.943] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[09:30:13.943] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[09:30:13.943] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:30:13.944] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:30:13.944] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[09:30:13.944] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[09:30:13.944] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:30:13.945] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:30:13.945] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:30:13.945] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:30:13.945] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[09:30:13.946] MultisessionFuture started
[09:30:13.946] - Launch lazy future ... done
[09:30:13.946] run() for ‘MultisessionFuture’ ... done
[09:30:13.946] Created future:
[09:30:13.946] MultisessionFuture:
[09:30:13.946] Label: ‘future_lapply-1’
[09:30:13.946] Expression:
[09:30:13.946] {
[09:30:13.946]     do.call(function(...) {
[09:30:13.946]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:13.946]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:13.946]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:13.946]             on.exit(options(oopts), add = TRUE)
[09:30:13.946]         }
[09:30:13.946]         {
[09:30:13.946]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:13.946]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:13.946]                 ...future.FUN(...future.X_jj, ...)
[09:30:13.946]             })
[09:30:13.946]         }
[09:30:13.946]     }, args = future.call.arguments)
[09:30:13.946] }
[09:30:13.946] Lazy evaluation: FALSE
[09:30:13.946] Asynchronous evaluation: TRUE
[09:30:13.946] Local evaluation: TRUE
[09:30:13.946] Environment: R_GlobalEnv
[09:30:13.946] Capture standard output: TRUE
[09:30:13.946] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:13.946] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:13.946] Packages: <none>
[09:30:13.946] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:13.946] Resolved: FALSE
[09:30:13.946] Value: <not collected>
[09:30:13.946] Conditions captured: <none>
[09:30:13.946] Early signaling: FALSE
[09:30:13.946] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:13.946] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:13.958] Chunk #1 of 2 ... DONE
[09:30:13.958] Chunk #2 of 2 ...
[09:30:13.959]  - Finding globals in 'X' for chunk #2 ...
[09:30:13.959] getGlobalsAndPackages() ...
[09:30:13.959] Searching for globals...
[09:30:13.959] 
[09:30:13.959] Searching for globals ... DONE
[09:30:13.959] - globals: [0] <none>
[09:30:13.959] getGlobalsAndPackages() ... DONE
[09:30:13.959]    + additional globals found: [n=0] 
[09:30:13.959]    + additional namespaces needed: [n=0] 
[09:30:13.959]  - Finding globals in 'X' for chunk #2 ... DONE
[09:30:13.960]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:13.960]  - seeds: <none>
[09:30:13.960]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:13.960] getGlobalsAndPackages() ...
[09:30:13.960] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:13.960] Resolving globals: FALSE
[09:30:13.960] Tweak future expression to call with '...' arguments ...
[09:30:13.960] {
[09:30:13.960]     do.call(function(...) {
[09:30:13.960]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:13.960]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:13.960]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:13.960]             on.exit(options(oopts), add = TRUE)
[09:30:13.960]         }
[09:30:13.960]         {
[09:30:13.960]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:13.960]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:13.960]                 ...future.FUN(...future.X_jj, ...)
[09:30:13.960]             })
[09:30:13.960]         }
[09:30:13.960]     }, args = future.call.arguments)
[09:30:13.960] }
[09:30:13.961] Tweak future expression to call with '...' arguments ... DONE
[09:30:13.961] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:13.961] 
[09:30:13.961] getGlobalsAndPackages() ... DONE
[09:30:13.961] run() for ‘Future’ ...
[09:30:13.961] - state: ‘created’
[09:30:13.962] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:30:13.975] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:13.975] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:30:13.975]   - Field: ‘node’
[09:30:13.975]   - Field: ‘label’
[09:30:13.976]   - Field: ‘local’
[09:30:13.976]   - Field: ‘owner’
[09:30:13.976]   - Field: ‘envir’
[09:30:13.976]   - Field: ‘workers’
[09:30:13.976]   - Field: ‘packages’
[09:30:13.976]   - Field: ‘gc’
[09:30:13.976]   - Field: ‘conditions’
[09:30:13.976]   - Field: ‘persistent’
[09:30:13.976]   - Field: ‘expr’
[09:30:13.976]   - Field: ‘uuid’
[09:30:13.976]   - Field: ‘seed’
[09:30:13.977]   - Field: ‘version’
[09:30:13.977]   - Field: ‘result’
[09:30:13.977]   - Field: ‘asynchronous’
[09:30:13.977]   - Field: ‘calls’
[09:30:13.977]   - Field: ‘globals’
[09:30:13.977]   - Field: ‘stdout’
[09:30:13.977]   - Field: ‘earlySignal’
[09:30:13.977]   - Field: ‘lazy’
[09:30:13.977]   - Field: ‘state’
[09:30:13.977] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:30:13.977] - Launch lazy future ...
[09:30:13.978] Packages needed by the future expression (n = 0): <none>
[09:30:13.978] Packages needed by future strategies (n = 0): <none>
[09:30:13.978] {
[09:30:13.978]     {
[09:30:13.978]         {
[09:30:13.978]             ...future.startTime <- base::Sys.time()
[09:30:13.978]             {
[09:30:13.978]                 {
[09:30:13.978]                   {
[09:30:13.978]                     {
[09:30:13.978]                       base::local({
[09:30:13.978]                         has_future <- base::requireNamespace("future", 
[09:30:13.978]                           quietly = TRUE)
[09:30:13.978]                         if (has_future) {
[09:30:13.978]                           ns <- base::getNamespace("future")
[09:30:13.978]                           version <- ns[[".package"]][["version"]]
[09:30:13.978]                           if (is.null(version)) 
[09:30:13.978]                             version <- utils::packageVersion("future")
[09:30:13.978]                         }
[09:30:13.978]                         else {
[09:30:13.978]                           version <- NULL
[09:30:13.978]                         }
[09:30:13.978]                         if (!has_future || version < "1.8.0") {
[09:30:13.978]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:13.978]                             "", base::R.version$version.string), 
[09:30:13.978]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:13.978]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:13.978]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:13.978]                               "release", "version")], collapse = " "), 
[09:30:13.978]                             hostname = base::Sys.info()[["nodename"]])
[09:30:13.978]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:13.978]                             info)
[09:30:13.978]                           info <- base::paste(info, collapse = "; ")
[09:30:13.978]                           if (!has_future) {
[09:30:13.978]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:13.978]                               info)
[09:30:13.978]                           }
[09:30:13.978]                           else {
[09:30:13.978]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:13.978]                               info, version)
[09:30:13.978]                           }
[09:30:13.978]                           base::stop(msg)
[09:30:13.978]                         }
[09:30:13.978]                       })
[09:30:13.978]                     }
[09:30:13.978]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:13.978]                     base::options(mc.cores = 1L)
[09:30:13.978]                   }
[09:30:13.978]                   ...future.strategy.old <- future::plan("list")
[09:30:13.978]                   options(future.plan = NULL)
[09:30:13.978]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:13.978]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:13.978]                 }
[09:30:13.978]                 ...future.workdir <- getwd()
[09:30:13.978]             }
[09:30:13.978]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:13.978]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:13.978]         }
[09:30:13.978]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:13.978]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:13.978]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:13.978]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:13.978]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:13.978]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:13.978]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:13.978]             base::names(...future.oldOptions))
[09:30:13.978]     }
[09:30:13.978]     if (FALSE) {
[09:30:13.978]     }
[09:30:13.978]     else {
[09:30:13.978]         if (TRUE) {
[09:30:13.978]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:13.978]                 open = "w")
[09:30:13.978]         }
[09:30:13.978]         else {
[09:30:13.978]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:13.978]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:13.978]         }
[09:30:13.978]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:13.978]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:13.978]             base::sink(type = "output", split = FALSE)
[09:30:13.978]             base::close(...future.stdout)
[09:30:13.978]         }, add = TRUE)
[09:30:13.978]     }
[09:30:13.978]     ...future.frame <- base::sys.nframe()
[09:30:13.978]     ...future.conditions <- base::list()
[09:30:13.978]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:13.978]     if (FALSE) {
[09:30:13.978]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:13.978]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:13.978]     }
[09:30:13.978]     ...future.result <- base::tryCatch({
[09:30:13.978]         base::withCallingHandlers({
[09:30:13.978]             ...future.value <- base::withVisible(base::local({
[09:30:13.978]                 ...future.makeSendCondition <- base::local({
[09:30:13.978]                   sendCondition <- NULL
[09:30:13.978]                   function(frame = 1L) {
[09:30:13.978]                     if (is.function(sendCondition)) 
[09:30:13.978]                       return(sendCondition)
[09:30:13.978]                     ns <- getNamespace("parallel")
[09:30:13.978]                     if (exists("sendData", mode = "function", 
[09:30:13.978]                       envir = ns)) {
[09:30:13.978]                       parallel_sendData <- get("sendData", mode = "function", 
[09:30:13.978]                         envir = ns)
[09:30:13.978]                       envir <- sys.frame(frame)
[09:30:13.978]                       master <- NULL
[09:30:13.978]                       while (!identical(envir, .GlobalEnv) && 
[09:30:13.978]                         !identical(envir, emptyenv())) {
[09:30:13.978]                         if (exists("master", mode = "list", envir = envir, 
[09:30:13.978]                           inherits = FALSE)) {
[09:30:13.978]                           master <- get("master", mode = "list", 
[09:30:13.978]                             envir = envir, inherits = FALSE)
[09:30:13.978]                           if (inherits(master, c("SOCKnode", 
[09:30:13.978]                             "SOCK0node"))) {
[09:30:13.978]                             sendCondition <<- function(cond) {
[09:30:13.978]                               data <- list(type = "VALUE", value = cond, 
[09:30:13.978]                                 success = TRUE)
[09:30:13.978]                               parallel_sendData(master, data)
[09:30:13.978]                             }
[09:30:13.978]                             return(sendCondition)
[09:30:13.978]                           }
[09:30:13.978]                         }
[09:30:13.978]                         frame <- frame + 1L
[09:30:13.978]                         envir <- sys.frame(frame)
[09:30:13.978]                       }
[09:30:13.978]                     }
[09:30:13.978]                     sendCondition <<- function(cond) NULL
[09:30:13.978]                   }
[09:30:13.978]                 })
[09:30:13.978]                 withCallingHandlers({
[09:30:13.978]                   {
[09:30:13.978]                     do.call(function(...) {
[09:30:13.978]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:13.978]                       if (!identical(...future.globals.maxSize.org, 
[09:30:13.978]                         ...future.globals.maxSize)) {
[09:30:13.978]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:13.978]                         on.exit(options(oopts), add = TRUE)
[09:30:13.978]                       }
[09:30:13.978]                       {
[09:30:13.978]                         lapply(seq_along(...future.elements_ii), 
[09:30:13.978]                           FUN = function(jj) {
[09:30:13.978]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:13.978]                             ...future.FUN(...future.X_jj, ...)
[09:30:13.978]                           })
[09:30:13.978]                       }
[09:30:13.978]                     }, args = future.call.arguments)
[09:30:13.978]                   }
[09:30:13.978]                 }, immediateCondition = function(cond) {
[09:30:13.978]                   sendCondition <- ...future.makeSendCondition()
[09:30:13.978]                   sendCondition(cond)
[09:30:13.978]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:13.978]                   {
[09:30:13.978]                     inherits <- base::inherits
[09:30:13.978]                     invokeRestart <- base::invokeRestart
[09:30:13.978]                     is.null <- base::is.null
[09:30:13.978]                     muffled <- FALSE
[09:30:13.978]                     if (inherits(cond, "message")) {
[09:30:13.978]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:13.978]                       if (muffled) 
[09:30:13.978]                         invokeRestart("muffleMessage")
[09:30:13.978]                     }
[09:30:13.978]                     else if (inherits(cond, "warning")) {
[09:30:13.978]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:13.978]                       if (muffled) 
[09:30:13.978]                         invokeRestart("muffleWarning")
[09:30:13.978]                     }
[09:30:13.978]                     else if (inherits(cond, "condition")) {
[09:30:13.978]                       if (!is.null(pattern)) {
[09:30:13.978]                         computeRestarts <- base::computeRestarts
[09:30:13.978]                         grepl <- base::grepl
[09:30:13.978]                         restarts <- computeRestarts(cond)
[09:30:13.978]                         for (restart in restarts) {
[09:30:13.978]                           name <- restart$name
[09:30:13.978]                           if (is.null(name)) 
[09:30:13.978]                             next
[09:30:13.978]                           if (!grepl(pattern, name)) 
[09:30:13.978]                             next
[09:30:13.978]                           invokeRestart(restart)
[09:30:13.978]                           muffled <- TRUE
[09:30:13.978]                           break
[09:30:13.978]                         }
[09:30:13.978]                       }
[09:30:13.978]                     }
[09:30:13.978]                     invisible(muffled)
[09:30:13.978]                   }
[09:30:13.978]                   muffleCondition(cond)
[09:30:13.978]                 })
[09:30:13.978]             }))
[09:30:13.978]             future::FutureResult(value = ...future.value$value, 
[09:30:13.978]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:13.978]                   ...future.rng), globalenv = if (FALSE) 
[09:30:13.978]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:13.978]                     ...future.globalenv.names))
[09:30:13.978]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:13.978]         }, condition = base::local({
[09:30:13.978]             c <- base::c
[09:30:13.978]             inherits <- base::inherits
[09:30:13.978]             invokeRestart <- base::invokeRestart
[09:30:13.978]             length <- base::length
[09:30:13.978]             list <- base::list
[09:30:13.978]             seq.int <- base::seq.int
[09:30:13.978]             signalCondition <- base::signalCondition
[09:30:13.978]             sys.calls <- base::sys.calls
[09:30:13.978]             `[[` <- base::`[[`
[09:30:13.978]             `+` <- base::`+`
[09:30:13.978]             `<<-` <- base::`<<-`
[09:30:13.978]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:13.978]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:13.978]                   3L)]
[09:30:13.978]             }
[09:30:13.978]             function(cond) {
[09:30:13.978]                 is_error <- inherits(cond, "error")
[09:30:13.978]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:13.978]                   NULL)
[09:30:13.978]                 if (is_error) {
[09:30:13.978]                   sessionInformation <- function() {
[09:30:13.978]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:13.978]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:13.978]                       search = base::search(), system = base::Sys.info())
[09:30:13.978]                   }
[09:30:13.978]                   ...future.conditions[[length(...future.conditions) + 
[09:30:13.978]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:13.978]                     cond$call), session = sessionInformation(), 
[09:30:13.978]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:13.978]                   signalCondition(cond)
[09:30:13.978]                 }
[09:30:13.978]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:13.978]                 "immediateCondition"))) {
[09:30:13.978]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:13.978]                   ...future.conditions[[length(...future.conditions) + 
[09:30:13.978]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:13.978]                   if (TRUE && !signal) {
[09:30:13.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:13.978]                     {
[09:30:13.978]                       inherits <- base::inherits
[09:30:13.978]                       invokeRestart <- base::invokeRestart
[09:30:13.978]                       is.null <- base::is.null
[09:30:13.978]                       muffled <- FALSE
[09:30:13.978]                       if (inherits(cond, "message")) {
[09:30:13.978]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:13.978]                         if (muffled) 
[09:30:13.978]                           invokeRestart("muffleMessage")
[09:30:13.978]                       }
[09:30:13.978]                       else if (inherits(cond, "warning")) {
[09:30:13.978]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:13.978]                         if (muffled) 
[09:30:13.978]                           invokeRestart("muffleWarning")
[09:30:13.978]                       }
[09:30:13.978]                       else if (inherits(cond, "condition")) {
[09:30:13.978]                         if (!is.null(pattern)) {
[09:30:13.978]                           computeRestarts <- base::computeRestarts
[09:30:13.978]                           grepl <- base::grepl
[09:30:13.978]                           restarts <- computeRestarts(cond)
[09:30:13.978]                           for (restart in restarts) {
[09:30:13.978]                             name <- restart$name
[09:30:13.978]                             if (is.null(name)) 
[09:30:13.978]                               next
[09:30:13.978]                             if (!grepl(pattern, name)) 
[09:30:13.978]                               next
[09:30:13.978]                             invokeRestart(restart)
[09:30:13.978]                             muffled <- TRUE
[09:30:13.978]                             break
[09:30:13.978]                           }
[09:30:13.978]                         }
[09:30:13.978]                       }
[09:30:13.978]                       invisible(muffled)
[09:30:13.978]                     }
[09:30:13.978]                     muffleCondition(cond, pattern = "^muffle")
[09:30:13.978]                   }
[09:30:13.978]                 }
[09:30:13.978]                 else {
[09:30:13.978]                   if (TRUE) {
[09:30:13.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:13.978]                     {
[09:30:13.978]                       inherits <- base::inherits
[09:30:13.978]                       invokeRestart <- base::invokeRestart
[09:30:13.978]                       is.null <- base::is.null
[09:30:13.978]                       muffled <- FALSE
[09:30:13.978]                       if (inherits(cond, "message")) {
[09:30:13.978]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:13.978]                         if (muffled) 
[09:30:13.978]                           invokeRestart("muffleMessage")
[09:30:13.978]                       }
[09:30:13.978]                       else if (inherits(cond, "warning")) {
[09:30:13.978]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:13.978]                         if (muffled) 
[09:30:13.978]                           invokeRestart("muffleWarning")
[09:30:13.978]                       }
[09:30:13.978]                       else if (inherits(cond, "condition")) {
[09:30:13.978]                         if (!is.null(pattern)) {
[09:30:13.978]                           computeRestarts <- base::computeRestarts
[09:30:13.978]                           grepl <- base::grepl
[09:30:13.978]                           restarts <- computeRestarts(cond)
[09:30:13.978]                           for (restart in restarts) {
[09:30:13.978]                             name <- restart$name
[09:30:13.978]                             if (is.null(name)) 
[09:30:13.978]                               next
[09:30:13.978]                             if (!grepl(pattern, name)) 
[09:30:13.978]                               next
[09:30:13.978]                             invokeRestart(restart)
[09:30:13.978]                             muffled <- TRUE
[09:30:13.978]                             break
[09:30:13.978]                           }
[09:30:13.978]                         }
[09:30:13.978]                       }
[09:30:13.978]                       invisible(muffled)
[09:30:13.978]                     }
[09:30:13.978]                     muffleCondition(cond, pattern = "^muffle")
[09:30:13.978]                   }
[09:30:13.978]                 }
[09:30:13.978]             }
[09:30:13.978]         }))
[09:30:13.978]     }, error = function(ex) {
[09:30:13.978]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:13.978]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:13.978]                 ...future.rng), started = ...future.startTime, 
[09:30:13.978]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:13.978]             version = "1.8"), class = "FutureResult")
[09:30:13.978]     }, finally = {
[09:30:13.978]         if (!identical(...future.workdir, getwd())) 
[09:30:13.978]             setwd(...future.workdir)
[09:30:13.978]         {
[09:30:13.978]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:13.978]                 ...future.oldOptions$nwarnings <- NULL
[09:30:13.978]             }
[09:30:13.978]             base::options(...future.oldOptions)
[09:30:13.978]             if (.Platform$OS.type == "windows") {
[09:30:13.978]                 old_names <- names(...future.oldEnvVars)
[09:30:13.978]                 envs <- base::Sys.getenv()
[09:30:13.978]                 names <- names(envs)
[09:30:13.978]                 common <- intersect(names, old_names)
[09:30:13.978]                 added <- setdiff(names, old_names)
[09:30:13.978]                 removed <- setdiff(old_names, names)
[09:30:13.978]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:13.978]                   envs[common]]
[09:30:13.978]                 NAMES <- toupper(changed)
[09:30:13.978]                 args <- list()
[09:30:13.978]                 for (kk in seq_along(NAMES)) {
[09:30:13.978]                   name <- changed[[kk]]
[09:30:13.978]                   NAME <- NAMES[[kk]]
[09:30:13.978]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:13.978]                     next
[09:30:13.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:13.978]                 }
[09:30:13.978]                 NAMES <- toupper(added)
[09:30:13.978]                 for (kk in seq_along(NAMES)) {
[09:30:13.978]                   name <- added[[kk]]
[09:30:13.978]                   NAME <- NAMES[[kk]]
[09:30:13.978]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:13.978]                     next
[09:30:13.978]                   args[[name]] <- ""
[09:30:13.978]                 }
[09:30:13.978]                 NAMES <- toupper(removed)
[09:30:13.978]                 for (kk in seq_along(NAMES)) {
[09:30:13.978]                   name <- removed[[kk]]
[09:30:13.978]                   NAME <- NAMES[[kk]]
[09:30:13.978]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:13.978]                     next
[09:30:13.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:13.978]                 }
[09:30:13.978]                 if (length(args) > 0) 
[09:30:13.978]                   base::do.call(base::Sys.setenv, args = args)
[09:30:13.978]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:13.978]             }
[09:30:13.978]             else {
[09:30:13.978]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:13.978]             }
[09:30:13.978]             {
[09:30:13.978]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:13.978]                   0L) {
[09:30:13.978]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:13.978]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:13.978]                   base::options(opts)
[09:30:13.978]                 }
[09:30:13.978]                 {
[09:30:13.978]                   {
[09:30:13.978]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:13.978]                     NULL
[09:30:13.978]                   }
[09:30:13.978]                   options(future.plan = NULL)
[09:30:13.978]                   if (is.na(NA_character_)) 
[09:30:13.978]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:13.978]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:13.978]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:13.978]                     .init = FALSE)
[09:30:13.978]                 }
[09:30:13.978]             }
[09:30:13.978]         }
[09:30:13.978]     })
[09:30:13.978]     if (TRUE) {
[09:30:13.978]         base::sink(type = "output", split = FALSE)
[09:30:13.978]         if (TRUE) {
[09:30:13.978]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:13.978]         }
[09:30:13.978]         else {
[09:30:13.978]             ...future.result["stdout"] <- base::list(NULL)
[09:30:13.978]         }
[09:30:13.978]         base::close(...future.stdout)
[09:30:13.978]         ...future.stdout <- NULL
[09:30:13.978]     }
[09:30:13.978]     ...future.result$conditions <- ...future.conditions
[09:30:13.978]     ...future.result$finished <- base::Sys.time()
[09:30:13.978]     ...future.result
[09:30:13.978] }
[09:30:13.981] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[09:30:13.981] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[09:30:13.981] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[09:30:13.982] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:30:13.982] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:30:13.982] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[09:30:13.982] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[09:30:13.982] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:30:13.983] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:30:13.983] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:30:13.983] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:30:13.983] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[09:30:13.984] MultisessionFuture started
[09:30:13.984] - Launch lazy future ... done
[09:30:13.984] run() for ‘MultisessionFuture’ ... done
[09:30:13.984] Created future:
[09:30:13.984] MultisessionFuture:
[09:30:13.984] Label: ‘future_lapply-2’
[09:30:13.984] Expression:
[09:30:13.984] {
[09:30:13.984]     do.call(function(...) {
[09:30:13.984]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:13.984]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:13.984]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:13.984]             on.exit(options(oopts), add = TRUE)
[09:30:13.984]         }
[09:30:13.984]         {
[09:30:13.984]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:13.984]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:13.984]                 ...future.FUN(...future.X_jj, ...)
[09:30:13.984]             })
[09:30:13.984]         }
[09:30:13.984]     }, args = future.call.arguments)
[09:30:13.984] }
[09:30:13.984] Lazy evaluation: FALSE
[09:30:13.984] Asynchronous evaluation: TRUE
[09:30:13.984] Local evaluation: TRUE
[09:30:13.984] Environment: R_GlobalEnv
[09:30:13.984] Capture standard output: TRUE
[09:30:13.984] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:13.984] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:13.984] Packages: <none>
[09:30:13.984] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:13.984] Resolved: FALSE
[09:30:13.984] Value: <not collected>
[09:30:13.984] Conditions captured: <none>
[09:30:13.984] Early signaling: FALSE
[09:30:13.984] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:13.984] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:13.995] Chunk #2 of 2 ... DONE
[09:30:13.996] Launching 2 futures (chunks) ... DONE
[09:30:13.996] Resolving 2 futures (chunks) ...
[09:30:13.996] resolve() on list ...
[09:30:13.996]  recursive: 0
[09:30:13.996]  length: 2
[09:30:13.996] 
[09:30:14.038] receiveMessageFromWorker() for ClusterFuture ...
[09:30:14.038] - Validating connection of MultisessionFuture
[09:30:14.039] - received message: FutureResult
[09:30:14.039] - Received FutureResult
[09:30:14.039] - Erased future from FutureRegistry
[09:30:14.039] result() for ClusterFuture ...
[09:30:14.039] - result already collected: FutureResult
[09:30:14.039] result() for ClusterFuture ... done
[09:30:14.039] receiveMessageFromWorker() for ClusterFuture ... done
[09:30:14.039] Future #2
[09:30:14.040] result() for ClusterFuture ...
[09:30:14.040] - result already collected: FutureResult
[09:30:14.040] result() for ClusterFuture ... done
[09:30:14.040] result() for ClusterFuture ...
[09:30:14.040] - result already collected: FutureResult
[09:30:14.040] result() for ClusterFuture ... done
[09:30:14.040] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:30:14.040] - nx: 2
[09:30:14.040] - relay: TRUE
[09:30:14.040] - stdout: TRUE
[09:30:14.040] - signal: TRUE
[09:30:14.041] - resignal: FALSE
[09:30:14.041] - force: TRUE
[09:30:14.041] - relayed: [n=2] FALSE, FALSE
[09:30:14.041] - queued futures: [n=2] FALSE, FALSE
[09:30:14.041]  - until=1
[09:30:14.041]  - relaying element #1
[09:30:14.041] - relayed: [n=2] FALSE, FALSE
[09:30:14.041] - queued futures: [n=2] FALSE, TRUE
[09:30:14.041] signalConditionsASAP(NULL, pos=2) ... done
[09:30:14.041]  length: 1 (resolved future 2)
[09:30:14.490] receiveMessageFromWorker() for ClusterFuture ...
[09:30:14.490] - Validating connection of MultisessionFuture
[09:30:14.490] - received message: FutureResult
[09:30:14.491] - Received FutureResult
[09:30:14.491] - Erased future from FutureRegistry
[09:30:14.491] result() for ClusterFuture ...
[09:30:14.491] - result already collected: FutureResult
[09:30:14.491] result() for ClusterFuture ... done
[09:30:14.491] receiveMessageFromWorker() for ClusterFuture ... done
[09:30:14.491] Future #1
[09:30:14.491] result() for ClusterFuture ...
[09:30:14.491] - result already collected: FutureResult
[09:30:14.491] result() for ClusterFuture ... done
[09:30:14.491] result() for ClusterFuture ...
[09:30:14.492] - result already collected: FutureResult
[09:30:14.492] result() for ClusterFuture ... done
[09:30:14.492] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:30:14.492] - nx: 2
[09:30:14.492] - relay: TRUE
[09:30:14.492] - stdout: TRUE
[09:30:14.492] - signal: TRUE
[09:30:14.492] - resignal: FALSE
[09:30:14.492] - force: TRUE
[09:30:14.492] - relayed: [n=2] FALSE, FALSE
[09:30:14.492] - queued futures: [n=2] FALSE, TRUE
[09:30:14.492]  - until=1
[09:30:14.493]  - relaying element #1
[09:30:14.493] result() for ClusterFuture ...
[09:30:14.493] - result already collected: FutureResult
[09:30:14.493] result() for ClusterFuture ... done
[09:30:14.493] result() for ClusterFuture ...
[09:30:14.493] - result already collected: FutureResult
[09:30:14.493] result() for ClusterFuture ... done
[09:30:14.493] result() for ClusterFuture ...
[09:30:14.493] - result already collected: FutureResult
[09:30:14.493] result() for ClusterFuture ... done
[09:30:14.493] result() for ClusterFuture ...
[09:30:14.494] - result already collected: FutureResult
[09:30:14.494] result() for ClusterFuture ... done
[09:30:14.494] - relayed: [n=2] TRUE, FALSE
[09:30:14.494] - queued futures: [n=2] TRUE, TRUE
[09:30:14.494] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:30:14.494]  length: 0 (resolved future 1)
[09:30:14.494] Relaying remaining futures
[09:30:14.494] signalConditionsASAP(NULL, pos=0) ...
[09:30:14.494] - nx: 2
[09:30:14.494] - relay: TRUE
[09:30:14.494] - stdout: TRUE
[09:30:14.494] - signal: TRUE
[09:30:14.495] - resignal: FALSE
[09:30:14.495] - force: TRUE
[09:30:14.495] - relayed: [n=2] TRUE, FALSE
[09:30:14.495] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:30:14.495]  - relaying element #2
[09:30:14.495] result() for ClusterFuture ...
[09:30:14.495] - result already collected: FutureResult
[09:30:14.495] result() for ClusterFuture ... done
[09:30:14.495] result() for ClusterFuture ...
[09:30:14.495] - result already collected: FutureResult
[09:30:14.497] result() for ClusterFuture ... done
[09:30:14.497] result() for ClusterFuture ...
[09:30:14.497] - result already collected: FutureResult
[09:30:14.497] result() for ClusterFuture ... done
[09:30:14.498] result() for ClusterFuture ...
[09:30:14.498] - result already collected: FutureResult
[09:30:14.498] result() for ClusterFuture ... done
[09:30:14.498] - relayed: [n=2] TRUE, TRUE
[09:30:14.498] - queued futures: [n=2] TRUE, TRUE
[09:30:14.498] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[09:30:14.498] resolve() on list ... DONE
[09:30:14.498] result() for ClusterFuture ...
[09:30:14.498] - result already collected: FutureResult
[09:30:14.498] result() for ClusterFuture ... done
[09:30:14.498] result() for ClusterFuture ...
[09:30:14.498] - result already collected: FutureResult
[09:30:14.499] result() for ClusterFuture ... done
[09:30:14.499] result() for ClusterFuture ...
[09:30:14.499] - result already collected: FutureResult
[09:30:14.499] result() for ClusterFuture ... done
[09:30:14.499] result() for ClusterFuture ...
[09:30:14.499] - result already collected: FutureResult
[09:30:14.499] result() for ClusterFuture ... done
[09:30:14.499]  - Number of value chunks collected: 2
[09:30:14.499] Resolving 2 futures (chunks) ... DONE
[09:30:14.499] Reducing values from 2 chunks ...
[09:30:14.499]  - Number of values collected after concatenation: 2
[09:30:14.500]  - Number of values expected: 2
[09:30:14.500] Reducing values from 2 chunks ... DONE
[09:30:14.500] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[09:30:14.500] future_lapply() ...
[09:30:14.504] Number of chunks: 2
[09:30:14.504] getGlobalsAndPackagesXApply() ...
[09:30:14.505]  - future.globals: TRUE
[09:30:14.505] getGlobalsAndPackages() ...
[09:30:14.505] Searching for globals...
[09:30:14.506] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[09:30:14.506] Searching for globals ... DONE
[09:30:14.506] Resolving globals: FALSE
[09:30:14.507] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[09:30:14.507] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[09:30:14.507] - globals: [1] ‘FUN’
[09:30:14.507] 
[09:30:14.507] getGlobalsAndPackages() ... DONE
[09:30:14.507]  - globals found/used: [n=1] ‘FUN’
[09:30:14.507]  - needed namespaces: [n=0] 
[09:30:14.507] Finding globals ... DONE
[09:30:14.508]  - use_args: TRUE
[09:30:14.508]  - Getting '...' globals ...
[09:30:14.508] resolve() on list ...
[09:30:14.508]  recursive: 0
[09:30:14.508]  length: 1
[09:30:14.508]  elements: ‘...’
[09:30:14.508]  length: 0 (resolved future 1)
[09:30:14.508] resolve() on list ... DONE
[09:30:14.509]    - '...' content: [n=0] 
[09:30:14.509] List of 1
[09:30:14.509]  $ ...: list()
[09:30:14.509]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:14.509]  - attr(*, "where")=List of 1
[09:30:14.509]   ..$ ...:<environment: 0x55c104365f48> 
[09:30:14.509]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:14.509]  - attr(*, "resolved")= logi TRUE
[09:30:14.509]  - attr(*, "total_size")= num NA
[09:30:14.511]  - Getting '...' globals ... DONE
[09:30:14.511] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:30:14.511] List of 2
[09:30:14.511]  $ ...future.FUN:function (x)  
[09:30:14.511]  $ ...          : list()
[09:30:14.511]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:30:14.511]  - attr(*, "where")=List of 2
[09:30:14.511]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:14.511]   ..$ ...          :<environment: 0x55c104365f48> 
[09:30:14.511]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:14.511]  - attr(*, "resolved")= logi FALSE
[09:30:14.511]  - attr(*, "total_size")= num 4720
[09:30:14.514] Packages to be attached in all futures: [n=0] 
[09:30:14.514] getGlobalsAndPackagesXApply() ... DONE
[09:30:14.514] Number of futures (= number of chunks): 2
[09:30:14.514] Launching 2 futures (chunks) ...
[09:30:14.514] Chunk #1 of 2 ...
[09:30:14.514]  - Finding globals in 'X' for chunk #1 ...
[09:30:14.514] getGlobalsAndPackages() ...
[09:30:14.515] Searching for globals...
[09:30:14.515] 
[09:30:14.515] Searching for globals ... DONE
[09:30:14.515] - globals: [0] <none>
[09:30:14.515] getGlobalsAndPackages() ... DONE
[09:30:14.515]    + additional globals found: [n=0] 
[09:30:14.515]    + additional namespaces needed: [n=0] 
[09:30:14.515]  - Finding globals in 'X' for chunk #1 ... DONE
[09:30:14.515]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:14.515]  - seeds: <none>
[09:30:14.516]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:14.516] getGlobalsAndPackages() ...
[09:30:14.516] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:14.516] Resolving globals: FALSE
[09:30:14.516] Tweak future expression to call with '...' arguments ...
[09:30:14.516] {
[09:30:14.516]     do.call(function(...) {
[09:30:14.516]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:14.516]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:14.516]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:14.516]             on.exit(options(oopts), add = TRUE)
[09:30:14.516]         }
[09:30:14.516]         {
[09:30:14.516]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:14.516]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:14.516]                 ...future.FUN(...future.X_jj, ...)
[09:30:14.516]             })
[09:30:14.516]         }
[09:30:14.516]     }, args = future.call.arguments)
[09:30:14.516] }
[09:30:14.516] Tweak future expression to call with '...' arguments ... DONE
[09:30:14.517] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:14.517] 
[09:30:14.517] getGlobalsAndPackages() ... DONE
[09:30:14.517] run() for ‘Future’ ...
[09:30:14.517] - state: ‘created’
[09:30:14.517] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:30:14.533] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:14.533] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:30:14.533]   - Field: ‘node’
[09:30:14.533]   - Field: ‘label’
[09:30:14.533]   - Field: ‘local’
[09:30:14.534]   - Field: ‘owner’
[09:30:14.534]   - Field: ‘envir’
[09:30:14.534]   - Field: ‘workers’
[09:30:14.534]   - Field: ‘packages’
[09:30:14.534]   - Field: ‘gc’
[09:30:14.534]   - Field: ‘conditions’
[09:30:14.534]   - Field: ‘persistent’
[09:30:14.534]   - Field: ‘expr’
[09:30:14.534]   - Field: ‘uuid’
[09:30:14.534]   - Field: ‘seed’
[09:30:14.534]   - Field: ‘version’
[09:30:14.535]   - Field: ‘result’
[09:30:14.535]   - Field: ‘asynchronous’
[09:30:14.535]   - Field: ‘calls’
[09:30:14.535]   - Field: ‘globals’
[09:30:14.535]   - Field: ‘stdout’
[09:30:14.535]   - Field: ‘earlySignal’
[09:30:14.535]   - Field: ‘lazy’
[09:30:14.535]   - Field: ‘state’
[09:30:14.535] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:30:14.535] - Launch lazy future ...
[09:30:14.536] Packages needed by the future expression (n = 0): <none>
[09:30:14.536] Packages needed by future strategies (n = 0): <none>
[09:30:14.536] {
[09:30:14.536]     {
[09:30:14.536]         {
[09:30:14.536]             ...future.startTime <- base::Sys.time()
[09:30:14.536]             {
[09:30:14.536]                 {
[09:30:14.536]                   {
[09:30:14.536]                     {
[09:30:14.536]                       base::local({
[09:30:14.536]                         has_future <- base::requireNamespace("future", 
[09:30:14.536]                           quietly = TRUE)
[09:30:14.536]                         if (has_future) {
[09:30:14.536]                           ns <- base::getNamespace("future")
[09:30:14.536]                           version <- ns[[".package"]][["version"]]
[09:30:14.536]                           if (is.null(version)) 
[09:30:14.536]                             version <- utils::packageVersion("future")
[09:30:14.536]                         }
[09:30:14.536]                         else {
[09:30:14.536]                           version <- NULL
[09:30:14.536]                         }
[09:30:14.536]                         if (!has_future || version < "1.8.0") {
[09:30:14.536]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:14.536]                             "", base::R.version$version.string), 
[09:30:14.536]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:14.536]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:14.536]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:14.536]                               "release", "version")], collapse = " "), 
[09:30:14.536]                             hostname = base::Sys.info()[["nodename"]])
[09:30:14.536]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:14.536]                             info)
[09:30:14.536]                           info <- base::paste(info, collapse = "; ")
[09:30:14.536]                           if (!has_future) {
[09:30:14.536]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:14.536]                               info)
[09:30:14.536]                           }
[09:30:14.536]                           else {
[09:30:14.536]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:14.536]                               info, version)
[09:30:14.536]                           }
[09:30:14.536]                           base::stop(msg)
[09:30:14.536]                         }
[09:30:14.536]                       })
[09:30:14.536]                     }
[09:30:14.536]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:14.536]                     base::options(mc.cores = 1L)
[09:30:14.536]                   }
[09:30:14.536]                   ...future.strategy.old <- future::plan("list")
[09:30:14.536]                   options(future.plan = NULL)
[09:30:14.536]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:14.536]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:14.536]                 }
[09:30:14.536]                 ...future.workdir <- getwd()
[09:30:14.536]             }
[09:30:14.536]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:14.536]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:14.536]         }
[09:30:14.536]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:14.536]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:14.536]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:14.536]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:14.536]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:14.536]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:14.536]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:14.536]             base::names(...future.oldOptions))
[09:30:14.536]     }
[09:30:14.536]     if (TRUE) {
[09:30:14.536]     }
[09:30:14.536]     else {
[09:30:14.536]         if (NA) {
[09:30:14.536]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:14.536]                 open = "w")
[09:30:14.536]         }
[09:30:14.536]         else {
[09:30:14.536]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:14.536]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:14.536]         }
[09:30:14.536]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:14.536]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:14.536]             base::sink(type = "output", split = FALSE)
[09:30:14.536]             base::close(...future.stdout)
[09:30:14.536]         }, add = TRUE)
[09:30:14.536]     }
[09:30:14.536]     ...future.frame <- base::sys.nframe()
[09:30:14.536]     ...future.conditions <- base::list()
[09:30:14.536]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:14.536]     if (FALSE) {
[09:30:14.536]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:14.536]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:14.536]     }
[09:30:14.536]     ...future.result <- base::tryCatch({
[09:30:14.536]         base::withCallingHandlers({
[09:30:14.536]             ...future.value <- base::withVisible(base::local({
[09:30:14.536]                 ...future.makeSendCondition <- base::local({
[09:30:14.536]                   sendCondition <- NULL
[09:30:14.536]                   function(frame = 1L) {
[09:30:14.536]                     if (is.function(sendCondition)) 
[09:30:14.536]                       return(sendCondition)
[09:30:14.536]                     ns <- getNamespace("parallel")
[09:30:14.536]                     if (exists("sendData", mode = "function", 
[09:30:14.536]                       envir = ns)) {
[09:30:14.536]                       parallel_sendData <- get("sendData", mode = "function", 
[09:30:14.536]                         envir = ns)
[09:30:14.536]                       envir <- sys.frame(frame)
[09:30:14.536]                       master <- NULL
[09:30:14.536]                       while (!identical(envir, .GlobalEnv) && 
[09:30:14.536]                         !identical(envir, emptyenv())) {
[09:30:14.536]                         if (exists("master", mode = "list", envir = envir, 
[09:30:14.536]                           inherits = FALSE)) {
[09:30:14.536]                           master <- get("master", mode = "list", 
[09:30:14.536]                             envir = envir, inherits = FALSE)
[09:30:14.536]                           if (inherits(master, c("SOCKnode", 
[09:30:14.536]                             "SOCK0node"))) {
[09:30:14.536]                             sendCondition <<- function(cond) {
[09:30:14.536]                               data <- list(type = "VALUE", value = cond, 
[09:30:14.536]                                 success = TRUE)
[09:30:14.536]                               parallel_sendData(master, data)
[09:30:14.536]                             }
[09:30:14.536]                             return(sendCondition)
[09:30:14.536]                           }
[09:30:14.536]                         }
[09:30:14.536]                         frame <- frame + 1L
[09:30:14.536]                         envir <- sys.frame(frame)
[09:30:14.536]                       }
[09:30:14.536]                     }
[09:30:14.536]                     sendCondition <<- function(cond) NULL
[09:30:14.536]                   }
[09:30:14.536]                 })
[09:30:14.536]                 withCallingHandlers({
[09:30:14.536]                   {
[09:30:14.536]                     do.call(function(...) {
[09:30:14.536]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:14.536]                       if (!identical(...future.globals.maxSize.org, 
[09:30:14.536]                         ...future.globals.maxSize)) {
[09:30:14.536]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:14.536]                         on.exit(options(oopts), add = TRUE)
[09:30:14.536]                       }
[09:30:14.536]                       {
[09:30:14.536]                         lapply(seq_along(...future.elements_ii), 
[09:30:14.536]                           FUN = function(jj) {
[09:30:14.536]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:14.536]                             ...future.FUN(...future.X_jj, ...)
[09:30:14.536]                           })
[09:30:14.536]                       }
[09:30:14.536]                     }, args = future.call.arguments)
[09:30:14.536]                   }
[09:30:14.536]                 }, immediateCondition = function(cond) {
[09:30:14.536]                   sendCondition <- ...future.makeSendCondition()
[09:30:14.536]                   sendCondition(cond)
[09:30:14.536]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:14.536]                   {
[09:30:14.536]                     inherits <- base::inherits
[09:30:14.536]                     invokeRestart <- base::invokeRestart
[09:30:14.536]                     is.null <- base::is.null
[09:30:14.536]                     muffled <- FALSE
[09:30:14.536]                     if (inherits(cond, "message")) {
[09:30:14.536]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:14.536]                       if (muffled) 
[09:30:14.536]                         invokeRestart("muffleMessage")
[09:30:14.536]                     }
[09:30:14.536]                     else if (inherits(cond, "warning")) {
[09:30:14.536]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:14.536]                       if (muffled) 
[09:30:14.536]                         invokeRestart("muffleWarning")
[09:30:14.536]                     }
[09:30:14.536]                     else if (inherits(cond, "condition")) {
[09:30:14.536]                       if (!is.null(pattern)) {
[09:30:14.536]                         computeRestarts <- base::computeRestarts
[09:30:14.536]                         grepl <- base::grepl
[09:30:14.536]                         restarts <- computeRestarts(cond)
[09:30:14.536]                         for (restart in restarts) {
[09:30:14.536]                           name <- restart$name
[09:30:14.536]                           if (is.null(name)) 
[09:30:14.536]                             next
[09:30:14.536]                           if (!grepl(pattern, name)) 
[09:30:14.536]                             next
[09:30:14.536]                           invokeRestart(restart)
[09:30:14.536]                           muffled <- TRUE
[09:30:14.536]                           break
[09:30:14.536]                         }
[09:30:14.536]                       }
[09:30:14.536]                     }
[09:30:14.536]                     invisible(muffled)
[09:30:14.536]                   }
[09:30:14.536]                   muffleCondition(cond)
[09:30:14.536]                 })
[09:30:14.536]             }))
[09:30:14.536]             future::FutureResult(value = ...future.value$value, 
[09:30:14.536]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:14.536]                   ...future.rng), globalenv = if (FALSE) 
[09:30:14.536]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:14.536]                     ...future.globalenv.names))
[09:30:14.536]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:14.536]         }, condition = base::local({
[09:30:14.536]             c <- base::c
[09:30:14.536]             inherits <- base::inherits
[09:30:14.536]             invokeRestart <- base::invokeRestart
[09:30:14.536]             length <- base::length
[09:30:14.536]             list <- base::list
[09:30:14.536]             seq.int <- base::seq.int
[09:30:14.536]             signalCondition <- base::signalCondition
[09:30:14.536]             sys.calls <- base::sys.calls
[09:30:14.536]             `[[` <- base::`[[`
[09:30:14.536]             `+` <- base::`+`
[09:30:14.536]             `<<-` <- base::`<<-`
[09:30:14.536]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:14.536]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:14.536]                   3L)]
[09:30:14.536]             }
[09:30:14.536]             function(cond) {
[09:30:14.536]                 is_error <- inherits(cond, "error")
[09:30:14.536]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:14.536]                   NULL)
[09:30:14.536]                 if (is_error) {
[09:30:14.536]                   sessionInformation <- function() {
[09:30:14.536]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:14.536]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:14.536]                       search = base::search(), system = base::Sys.info())
[09:30:14.536]                   }
[09:30:14.536]                   ...future.conditions[[length(...future.conditions) + 
[09:30:14.536]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:14.536]                     cond$call), session = sessionInformation(), 
[09:30:14.536]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:14.536]                   signalCondition(cond)
[09:30:14.536]                 }
[09:30:14.536]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:14.536]                 "immediateCondition"))) {
[09:30:14.536]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:14.536]                   ...future.conditions[[length(...future.conditions) + 
[09:30:14.536]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:14.536]                   if (TRUE && !signal) {
[09:30:14.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:14.536]                     {
[09:30:14.536]                       inherits <- base::inherits
[09:30:14.536]                       invokeRestart <- base::invokeRestart
[09:30:14.536]                       is.null <- base::is.null
[09:30:14.536]                       muffled <- FALSE
[09:30:14.536]                       if (inherits(cond, "message")) {
[09:30:14.536]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:14.536]                         if (muffled) 
[09:30:14.536]                           invokeRestart("muffleMessage")
[09:30:14.536]                       }
[09:30:14.536]                       else if (inherits(cond, "warning")) {
[09:30:14.536]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:14.536]                         if (muffled) 
[09:30:14.536]                           invokeRestart("muffleWarning")
[09:30:14.536]                       }
[09:30:14.536]                       else if (inherits(cond, "condition")) {
[09:30:14.536]                         if (!is.null(pattern)) {
[09:30:14.536]                           computeRestarts <- base::computeRestarts
[09:30:14.536]                           grepl <- base::grepl
[09:30:14.536]                           restarts <- computeRestarts(cond)
[09:30:14.536]                           for (restart in restarts) {
[09:30:14.536]                             name <- restart$name
[09:30:14.536]                             if (is.null(name)) 
[09:30:14.536]                               next
[09:30:14.536]                             if (!grepl(pattern, name)) 
[09:30:14.536]                               next
[09:30:14.536]                             invokeRestart(restart)
[09:30:14.536]                             muffled <- TRUE
[09:30:14.536]                             break
[09:30:14.536]                           }
[09:30:14.536]                         }
[09:30:14.536]                       }
[09:30:14.536]                       invisible(muffled)
[09:30:14.536]                     }
[09:30:14.536]                     muffleCondition(cond, pattern = "^muffle")
[09:30:14.536]                   }
[09:30:14.536]                 }
[09:30:14.536]                 else {
[09:30:14.536]                   if (TRUE) {
[09:30:14.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:14.536]                     {
[09:30:14.536]                       inherits <- base::inherits
[09:30:14.536]                       invokeRestart <- base::invokeRestart
[09:30:14.536]                       is.null <- base::is.null
[09:30:14.536]                       muffled <- FALSE
[09:30:14.536]                       if (inherits(cond, "message")) {
[09:30:14.536]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:14.536]                         if (muffled) 
[09:30:14.536]                           invokeRestart("muffleMessage")
[09:30:14.536]                       }
[09:30:14.536]                       else if (inherits(cond, "warning")) {
[09:30:14.536]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:14.536]                         if (muffled) 
[09:30:14.536]                           invokeRestart("muffleWarning")
[09:30:14.536]                       }
[09:30:14.536]                       else if (inherits(cond, "condition")) {
[09:30:14.536]                         if (!is.null(pattern)) {
[09:30:14.536]                           computeRestarts <- base::computeRestarts
[09:30:14.536]                           grepl <- base::grepl
[09:30:14.536]                           restarts <- computeRestarts(cond)
[09:30:14.536]                           for (restart in restarts) {
[09:30:14.536]                             name <- restart$name
[09:30:14.536]                             if (is.null(name)) 
[09:30:14.536]                               next
[09:30:14.536]                             if (!grepl(pattern, name)) 
[09:30:14.536]                               next
[09:30:14.536]                             invokeRestart(restart)
[09:30:14.536]                             muffled <- TRUE
[09:30:14.536]                             break
[09:30:14.536]                           }
[09:30:14.536]                         }
[09:30:14.536]                       }
[09:30:14.536]                       invisible(muffled)
[09:30:14.536]                     }
[09:30:14.536]                     muffleCondition(cond, pattern = "^muffle")
[09:30:14.536]                   }
[09:30:14.536]                 }
[09:30:14.536]             }
[09:30:14.536]         }))
[09:30:14.536]     }, error = function(ex) {
[09:30:14.536]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:14.536]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:14.536]                 ...future.rng), started = ...future.startTime, 
[09:30:14.536]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:14.536]             version = "1.8"), class = "FutureResult")
[09:30:14.536]     }, finally = {
[09:30:14.536]         if (!identical(...future.workdir, getwd())) 
[09:30:14.536]             setwd(...future.workdir)
[09:30:14.536]         {
[09:30:14.536]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:14.536]                 ...future.oldOptions$nwarnings <- NULL
[09:30:14.536]             }
[09:30:14.536]             base::options(...future.oldOptions)
[09:30:14.536]             if (.Platform$OS.type == "windows") {
[09:30:14.536]                 old_names <- names(...future.oldEnvVars)
[09:30:14.536]                 envs <- base::Sys.getenv()
[09:30:14.536]                 names <- names(envs)
[09:30:14.536]                 common <- intersect(names, old_names)
[09:30:14.536]                 added <- setdiff(names, old_names)
[09:30:14.536]                 removed <- setdiff(old_names, names)
[09:30:14.536]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:14.536]                   envs[common]]
[09:30:14.536]                 NAMES <- toupper(changed)
[09:30:14.536]                 args <- list()
[09:30:14.536]                 for (kk in seq_along(NAMES)) {
[09:30:14.536]                   name <- changed[[kk]]
[09:30:14.536]                   NAME <- NAMES[[kk]]
[09:30:14.536]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:14.536]                     next
[09:30:14.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:14.536]                 }
[09:30:14.536]                 NAMES <- toupper(added)
[09:30:14.536]                 for (kk in seq_along(NAMES)) {
[09:30:14.536]                   name <- added[[kk]]
[09:30:14.536]                   NAME <- NAMES[[kk]]
[09:30:14.536]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:14.536]                     next
[09:30:14.536]                   args[[name]] <- ""
[09:30:14.536]                 }
[09:30:14.536]                 NAMES <- toupper(removed)
[09:30:14.536]                 for (kk in seq_along(NAMES)) {
[09:30:14.536]                   name <- removed[[kk]]
[09:30:14.536]                   NAME <- NAMES[[kk]]
[09:30:14.536]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:14.536]                     next
[09:30:14.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:14.536]                 }
[09:30:14.536]                 if (length(args) > 0) 
[09:30:14.536]                   base::do.call(base::Sys.setenv, args = args)
[09:30:14.536]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:14.536]             }
[09:30:14.536]             else {
[09:30:14.536]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:14.536]             }
[09:30:14.536]             {
[09:30:14.536]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:14.536]                   0L) {
[09:30:14.536]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:14.536]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:14.536]                   base::options(opts)
[09:30:14.536]                 }
[09:30:14.536]                 {
[09:30:14.536]                   {
[09:30:14.536]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:14.536]                     NULL
[09:30:14.536]                   }
[09:30:14.536]                   options(future.plan = NULL)
[09:30:14.536]                   if (is.na(NA_character_)) 
[09:30:14.536]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:14.536]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:14.536]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:14.536]                     .init = FALSE)
[09:30:14.536]                 }
[09:30:14.536]             }
[09:30:14.536]         }
[09:30:14.536]     })
[09:30:14.536]     if (FALSE) {
[09:30:14.536]         base::sink(type = "output", split = FALSE)
[09:30:14.536]         if (NA) {
[09:30:14.536]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:14.536]         }
[09:30:14.536]         else {
[09:30:14.536]             ...future.result["stdout"] <- base::list(NULL)
[09:30:14.536]         }
[09:30:14.536]         base::close(...future.stdout)
[09:30:14.536]         ...future.stdout <- NULL
[09:30:14.536]     }
[09:30:14.536]     ...future.result$conditions <- ...future.conditions
[09:30:14.536]     ...future.result$finished <- base::Sys.time()
[09:30:14.536]     ...future.result
[09:30:14.536] }
[09:30:14.539] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[09:30:14.539] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[09:30:14.539] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[09:30:14.539] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:30:14.540] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:30:14.540] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[09:30:14.540] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[09:30:14.540] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:30:14.541] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:30:14.541] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:30:14.541] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:30:14.541] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[09:30:14.542] MultisessionFuture started
[09:30:14.542] - Launch lazy future ... done
[09:30:14.542] run() for ‘MultisessionFuture’ ... done
[09:30:14.542] Created future:
[09:30:14.542] MultisessionFuture:
[09:30:14.542] Label: ‘future_lapply-1’
[09:30:14.542] Expression:
[09:30:14.542] {
[09:30:14.542]     do.call(function(...) {
[09:30:14.542]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:14.542]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:14.542]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:14.542]             on.exit(options(oopts), add = TRUE)
[09:30:14.542]         }
[09:30:14.542]         {
[09:30:14.542]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:14.542]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:14.542]                 ...future.FUN(...future.X_jj, ...)
[09:30:14.542]             })
[09:30:14.542]         }
[09:30:14.542]     }, args = future.call.arguments)
[09:30:14.542] }
[09:30:14.542] Lazy evaluation: FALSE
[09:30:14.542] Asynchronous evaluation: TRUE
[09:30:14.542] Local evaluation: TRUE
[09:30:14.542] Environment: R_GlobalEnv
[09:30:14.542] Capture standard output: NA
[09:30:14.542] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:14.542] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:14.542] Packages: <none>
[09:30:14.542] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:14.542] Resolved: FALSE
[09:30:14.542] Value: <not collected>
[09:30:14.542] Conditions captured: <none>
[09:30:14.542] Early signaling: FALSE
[09:30:14.542] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:14.542] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:14.554] Chunk #1 of 2 ... DONE
[09:30:14.554] Chunk #2 of 2 ...
[09:30:14.554]  - Finding globals in 'X' for chunk #2 ...
[09:30:14.554] getGlobalsAndPackages() ...
[09:30:14.554] Searching for globals...
[09:30:14.555] 
[09:30:14.555] Searching for globals ... DONE
[09:30:14.555] - globals: [0] <none>
[09:30:14.555] getGlobalsAndPackages() ... DONE
[09:30:14.555]    + additional globals found: [n=0] 
[09:30:14.555]    + additional namespaces needed: [n=0] 
[09:30:14.555]  - Finding globals in 'X' for chunk #2 ... DONE
[09:30:14.555]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:14.555]  - seeds: <none>
[09:30:14.555]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:14.556] getGlobalsAndPackages() ...
[09:30:14.556] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:14.556] Resolving globals: FALSE
[09:30:14.556] Tweak future expression to call with '...' arguments ...
[09:30:14.556] {
[09:30:14.556]     do.call(function(...) {
[09:30:14.556]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:14.556]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:14.556]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:14.556]             on.exit(options(oopts), add = TRUE)
[09:30:14.556]         }
[09:30:14.556]         {
[09:30:14.556]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:14.556]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:14.556]                 ...future.FUN(...future.X_jj, ...)
[09:30:14.556]             })
[09:30:14.556]         }
[09:30:14.556]     }, args = future.call.arguments)
[09:30:14.556] }
[09:30:14.556] Tweak future expression to call with '...' arguments ... DONE
[09:30:14.557] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:14.557] 
[09:30:14.557] getGlobalsAndPackages() ... DONE
[09:30:14.557] run() for ‘Future’ ...
[09:30:14.557] - state: ‘created’
[09:30:14.557] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:30:14.570] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:14.570] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:30:14.571]   - Field: ‘node’
[09:30:14.571]   - Field: ‘label’
[09:30:14.571]   - Field: ‘local’
[09:30:14.571]   - Field: ‘owner’
[09:30:14.571]   - Field: ‘envir’
[09:30:14.571]   - Field: ‘workers’
[09:30:14.571]   - Field: ‘packages’
[09:30:14.571]   - Field: ‘gc’
[09:30:14.571]   - Field: ‘conditions’
[09:30:14.571]   - Field: ‘persistent’
[09:30:14.571]   - Field: ‘expr’
[09:30:14.572]   - Field: ‘uuid’
[09:30:14.572]   - Field: ‘seed’
[09:30:14.572]   - Field: ‘version’
[09:30:14.572]   - Field: ‘result’
[09:30:14.572]   - Field: ‘asynchronous’
[09:30:14.572]   - Field: ‘calls’
[09:30:14.572]   - Field: ‘globals’
[09:30:14.572]   - Field: ‘stdout’
[09:30:14.572]   - Field: ‘earlySignal’
[09:30:14.572]   - Field: ‘lazy’
[09:30:14.572]   - Field: ‘state’
[09:30:14.573] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:30:14.573] - Launch lazy future ...
[09:30:14.573] Packages needed by the future expression (n = 0): <none>
[09:30:14.573] Packages needed by future strategies (n = 0): <none>
[09:30:14.573] {
[09:30:14.573]     {
[09:30:14.573]         {
[09:30:14.573]             ...future.startTime <- base::Sys.time()
[09:30:14.573]             {
[09:30:14.573]                 {
[09:30:14.573]                   {
[09:30:14.573]                     {
[09:30:14.573]                       base::local({
[09:30:14.573]                         has_future <- base::requireNamespace("future", 
[09:30:14.573]                           quietly = TRUE)
[09:30:14.573]                         if (has_future) {
[09:30:14.573]                           ns <- base::getNamespace("future")
[09:30:14.573]                           version <- ns[[".package"]][["version"]]
[09:30:14.573]                           if (is.null(version)) 
[09:30:14.573]                             version <- utils::packageVersion("future")
[09:30:14.573]                         }
[09:30:14.573]                         else {
[09:30:14.573]                           version <- NULL
[09:30:14.573]                         }
[09:30:14.573]                         if (!has_future || version < "1.8.0") {
[09:30:14.573]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:14.573]                             "", base::R.version$version.string), 
[09:30:14.573]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:14.573]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:14.573]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:14.573]                               "release", "version")], collapse = " "), 
[09:30:14.573]                             hostname = base::Sys.info()[["nodename"]])
[09:30:14.573]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:14.573]                             info)
[09:30:14.573]                           info <- base::paste(info, collapse = "; ")
[09:30:14.573]                           if (!has_future) {
[09:30:14.573]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:14.573]                               info)
[09:30:14.573]                           }
[09:30:14.573]                           else {
[09:30:14.573]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:14.573]                               info, version)
[09:30:14.573]                           }
[09:30:14.573]                           base::stop(msg)
[09:30:14.573]                         }
[09:30:14.573]                       })
[09:30:14.573]                     }
[09:30:14.573]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:14.573]                     base::options(mc.cores = 1L)
[09:30:14.573]                   }
[09:30:14.573]                   ...future.strategy.old <- future::plan("list")
[09:30:14.573]                   options(future.plan = NULL)
[09:30:14.573]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:14.573]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:14.573]                 }
[09:30:14.573]                 ...future.workdir <- getwd()
[09:30:14.573]             }
[09:30:14.573]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:14.573]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:14.573]         }
[09:30:14.573]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:14.573]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:14.573]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:14.573]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:14.573]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:14.573]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:14.573]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:14.573]             base::names(...future.oldOptions))
[09:30:14.573]     }
[09:30:14.573]     if (TRUE) {
[09:30:14.573]     }
[09:30:14.573]     else {
[09:30:14.573]         if (NA) {
[09:30:14.573]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:14.573]                 open = "w")
[09:30:14.573]         }
[09:30:14.573]         else {
[09:30:14.573]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:14.573]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:14.573]         }
[09:30:14.573]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:14.573]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:14.573]             base::sink(type = "output", split = FALSE)
[09:30:14.573]             base::close(...future.stdout)
[09:30:14.573]         }, add = TRUE)
[09:30:14.573]     }
[09:30:14.573]     ...future.frame <- base::sys.nframe()
[09:30:14.573]     ...future.conditions <- base::list()
[09:30:14.573]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:14.573]     if (FALSE) {
[09:30:14.573]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:14.573]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:14.573]     }
[09:30:14.573]     ...future.result <- base::tryCatch({
[09:30:14.573]         base::withCallingHandlers({
[09:30:14.573]             ...future.value <- base::withVisible(base::local({
[09:30:14.573]                 ...future.makeSendCondition <- base::local({
[09:30:14.573]                   sendCondition <- NULL
[09:30:14.573]                   function(frame = 1L) {
[09:30:14.573]                     if (is.function(sendCondition)) 
[09:30:14.573]                       return(sendCondition)
[09:30:14.573]                     ns <- getNamespace("parallel")
[09:30:14.573]                     if (exists("sendData", mode = "function", 
[09:30:14.573]                       envir = ns)) {
[09:30:14.573]                       parallel_sendData <- get("sendData", mode = "function", 
[09:30:14.573]                         envir = ns)
[09:30:14.573]                       envir <- sys.frame(frame)
[09:30:14.573]                       master <- NULL
[09:30:14.573]                       while (!identical(envir, .GlobalEnv) && 
[09:30:14.573]                         !identical(envir, emptyenv())) {
[09:30:14.573]                         if (exists("master", mode = "list", envir = envir, 
[09:30:14.573]                           inherits = FALSE)) {
[09:30:14.573]                           master <- get("master", mode = "list", 
[09:30:14.573]                             envir = envir, inherits = FALSE)
[09:30:14.573]                           if (inherits(master, c("SOCKnode", 
[09:30:14.573]                             "SOCK0node"))) {
[09:30:14.573]                             sendCondition <<- function(cond) {
[09:30:14.573]                               data <- list(type = "VALUE", value = cond, 
[09:30:14.573]                                 success = TRUE)
[09:30:14.573]                               parallel_sendData(master, data)
[09:30:14.573]                             }
[09:30:14.573]                             return(sendCondition)
[09:30:14.573]                           }
[09:30:14.573]                         }
[09:30:14.573]                         frame <- frame + 1L
[09:30:14.573]                         envir <- sys.frame(frame)
[09:30:14.573]                       }
[09:30:14.573]                     }
[09:30:14.573]                     sendCondition <<- function(cond) NULL
[09:30:14.573]                   }
[09:30:14.573]                 })
[09:30:14.573]                 withCallingHandlers({
[09:30:14.573]                   {
[09:30:14.573]                     do.call(function(...) {
[09:30:14.573]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:14.573]                       if (!identical(...future.globals.maxSize.org, 
[09:30:14.573]                         ...future.globals.maxSize)) {
[09:30:14.573]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:14.573]                         on.exit(options(oopts), add = TRUE)
[09:30:14.573]                       }
[09:30:14.573]                       {
[09:30:14.573]                         lapply(seq_along(...future.elements_ii), 
[09:30:14.573]                           FUN = function(jj) {
[09:30:14.573]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:14.573]                             ...future.FUN(...future.X_jj, ...)
[09:30:14.573]                           })
[09:30:14.573]                       }
[09:30:14.573]                     }, args = future.call.arguments)
[09:30:14.573]                   }
[09:30:14.573]                 }, immediateCondition = function(cond) {
[09:30:14.573]                   sendCondition <- ...future.makeSendCondition()
[09:30:14.573]                   sendCondition(cond)
[09:30:14.573]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:14.573]                   {
[09:30:14.573]                     inherits <- base::inherits
[09:30:14.573]                     invokeRestart <- base::invokeRestart
[09:30:14.573]                     is.null <- base::is.null
[09:30:14.573]                     muffled <- FALSE
[09:30:14.573]                     if (inherits(cond, "message")) {
[09:30:14.573]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:14.573]                       if (muffled) 
[09:30:14.573]                         invokeRestart("muffleMessage")
[09:30:14.573]                     }
[09:30:14.573]                     else if (inherits(cond, "warning")) {
[09:30:14.573]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:14.573]                       if (muffled) 
[09:30:14.573]                         invokeRestart("muffleWarning")
[09:30:14.573]                     }
[09:30:14.573]                     else if (inherits(cond, "condition")) {
[09:30:14.573]                       if (!is.null(pattern)) {
[09:30:14.573]                         computeRestarts <- base::computeRestarts
[09:30:14.573]                         grepl <- base::grepl
[09:30:14.573]                         restarts <- computeRestarts(cond)
[09:30:14.573]                         for (restart in restarts) {
[09:30:14.573]                           name <- restart$name
[09:30:14.573]                           if (is.null(name)) 
[09:30:14.573]                             next
[09:30:14.573]                           if (!grepl(pattern, name)) 
[09:30:14.573]                             next
[09:30:14.573]                           invokeRestart(restart)
[09:30:14.573]                           muffled <- TRUE
[09:30:14.573]                           break
[09:30:14.573]                         }
[09:30:14.573]                       }
[09:30:14.573]                     }
[09:30:14.573]                     invisible(muffled)
[09:30:14.573]                   }
[09:30:14.573]                   muffleCondition(cond)
[09:30:14.573]                 })
[09:30:14.573]             }))
[09:30:14.573]             future::FutureResult(value = ...future.value$value, 
[09:30:14.573]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:14.573]                   ...future.rng), globalenv = if (FALSE) 
[09:30:14.573]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:14.573]                     ...future.globalenv.names))
[09:30:14.573]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:14.573]         }, condition = base::local({
[09:30:14.573]             c <- base::c
[09:30:14.573]             inherits <- base::inherits
[09:30:14.573]             invokeRestart <- base::invokeRestart
[09:30:14.573]             length <- base::length
[09:30:14.573]             list <- base::list
[09:30:14.573]             seq.int <- base::seq.int
[09:30:14.573]             signalCondition <- base::signalCondition
[09:30:14.573]             sys.calls <- base::sys.calls
[09:30:14.573]             `[[` <- base::`[[`
[09:30:14.573]             `+` <- base::`+`
[09:30:14.573]             `<<-` <- base::`<<-`
[09:30:14.573]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:14.573]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:14.573]                   3L)]
[09:30:14.573]             }
[09:30:14.573]             function(cond) {
[09:30:14.573]                 is_error <- inherits(cond, "error")
[09:30:14.573]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:14.573]                   NULL)
[09:30:14.573]                 if (is_error) {
[09:30:14.573]                   sessionInformation <- function() {
[09:30:14.573]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:14.573]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:14.573]                       search = base::search(), system = base::Sys.info())
[09:30:14.573]                   }
[09:30:14.573]                   ...future.conditions[[length(...future.conditions) + 
[09:30:14.573]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:14.573]                     cond$call), session = sessionInformation(), 
[09:30:14.573]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:14.573]                   signalCondition(cond)
[09:30:14.573]                 }
[09:30:14.573]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:14.573]                 "immediateCondition"))) {
[09:30:14.573]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:14.573]                   ...future.conditions[[length(...future.conditions) + 
[09:30:14.573]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:14.573]                   if (TRUE && !signal) {
[09:30:14.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:14.573]                     {
[09:30:14.573]                       inherits <- base::inherits
[09:30:14.573]                       invokeRestart <- base::invokeRestart
[09:30:14.573]                       is.null <- base::is.null
[09:30:14.573]                       muffled <- FALSE
[09:30:14.573]                       if (inherits(cond, "message")) {
[09:30:14.573]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:14.573]                         if (muffled) 
[09:30:14.573]                           invokeRestart("muffleMessage")
[09:30:14.573]                       }
[09:30:14.573]                       else if (inherits(cond, "warning")) {
[09:30:14.573]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:14.573]                         if (muffled) 
[09:30:14.573]                           invokeRestart("muffleWarning")
[09:30:14.573]                       }
[09:30:14.573]                       else if (inherits(cond, "condition")) {
[09:30:14.573]                         if (!is.null(pattern)) {
[09:30:14.573]                           computeRestarts <- base::computeRestarts
[09:30:14.573]                           grepl <- base::grepl
[09:30:14.573]                           restarts <- computeRestarts(cond)
[09:30:14.573]                           for (restart in restarts) {
[09:30:14.573]                             name <- restart$name
[09:30:14.573]                             if (is.null(name)) 
[09:30:14.573]                               next
[09:30:14.573]                             if (!grepl(pattern, name)) 
[09:30:14.573]                               next
[09:30:14.573]                             invokeRestart(restart)
[09:30:14.573]                             muffled <- TRUE
[09:30:14.573]                             break
[09:30:14.573]                           }
[09:30:14.573]                         }
[09:30:14.573]                       }
[09:30:14.573]                       invisible(muffled)
[09:30:14.573]                     }
[09:30:14.573]                     muffleCondition(cond, pattern = "^muffle")
[09:30:14.573]                   }
[09:30:14.573]                 }
[09:30:14.573]                 else {
[09:30:14.573]                   if (TRUE) {
[09:30:14.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:14.573]                     {
[09:30:14.573]                       inherits <- base::inherits
[09:30:14.573]                       invokeRestart <- base::invokeRestart
[09:30:14.573]                       is.null <- base::is.null
[09:30:14.573]                       muffled <- FALSE
[09:30:14.573]                       if (inherits(cond, "message")) {
[09:30:14.573]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:14.573]                         if (muffled) 
[09:30:14.573]                           invokeRestart("muffleMessage")
[09:30:14.573]                       }
[09:30:14.573]                       else if (inherits(cond, "warning")) {
[09:30:14.573]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:14.573]                         if (muffled) 
[09:30:14.573]                           invokeRestart("muffleWarning")
[09:30:14.573]                       }
[09:30:14.573]                       else if (inherits(cond, "condition")) {
[09:30:14.573]                         if (!is.null(pattern)) {
[09:30:14.573]                           computeRestarts <- base::computeRestarts
[09:30:14.573]                           grepl <- base::grepl
[09:30:14.573]                           restarts <- computeRestarts(cond)
[09:30:14.573]                           for (restart in restarts) {
[09:30:14.573]                             name <- restart$name
[09:30:14.573]                             if (is.null(name)) 
[09:30:14.573]                               next
[09:30:14.573]                             if (!grepl(pattern, name)) 
[09:30:14.573]                               next
[09:30:14.573]                             invokeRestart(restart)
[09:30:14.573]                             muffled <- TRUE
[09:30:14.573]                             break
[09:30:14.573]                           }
[09:30:14.573]                         }
[09:30:14.573]                       }
[09:30:14.573]                       invisible(muffled)
[09:30:14.573]                     }
[09:30:14.573]                     muffleCondition(cond, pattern = "^muffle")
[09:30:14.573]                   }
[09:30:14.573]                 }
[09:30:14.573]             }
[09:30:14.573]         }))
[09:30:14.573]     }, error = function(ex) {
[09:30:14.573]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:14.573]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:14.573]                 ...future.rng), started = ...future.startTime, 
[09:30:14.573]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:14.573]             version = "1.8"), class = "FutureResult")
[09:30:14.573]     }, finally = {
[09:30:14.573]         if (!identical(...future.workdir, getwd())) 
[09:30:14.573]             setwd(...future.workdir)
[09:30:14.573]         {
[09:30:14.573]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:14.573]                 ...future.oldOptions$nwarnings <- NULL
[09:30:14.573]             }
[09:30:14.573]             base::options(...future.oldOptions)
[09:30:14.573]             if (.Platform$OS.type == "windows") {
[09:30:14.573]                 old_names <- names(...future.oldEnvVars)
[09:30:14.573]                 envs <- base::Sys.getenv()
[09:30:14.573]                 names <- names(envs)
[09:30:14.573]                 common <- intersect(names, old_names)
[09:30:14.573]                 added <- setdiff(names, old_names)
[09:30:14.573]                 removed <- setdiff(old_names, names)
[09:30:14.573]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:14.573]                   envs[common]]
[09:30:14.573]                 NAMES <- toupper(changed)
[09:30:14.573]                 args <- list()
[09:30:14.573]                 for (kk in seq_along(NAMES)) {
[09:30:14.573]                   name <- changed[[kk]]
[09:30:14.573]                   NAME <- NAMES[[kk]]
[09:30:14.573]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:14.573]                     next
[09:30:14.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:14.573]                 }
[09:30:14.573]                 NAMES <- toupper(added)
[09:30:14.573]                 for (kk in seq_along(NAMES)) {
[09:30:14.573]                   name <- added[[kk]]
[09:30:14.573]                   NAME <- NAMES[[kk]]
[09:30:14.573]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:14.573]                     next
[09:30:14.573]                   args[[name]] <- ""
[09:30:14.573]                 }
[09:30:14.573]                 NAMES <- toupper(removed)
[09:30:14.573]                 for (kk in seq_along(NAMES)) {
[09:30:14.573]                   name <- removed[[kk]]
[09:30:14.573]                   NAME <- NAMES[[kk]]
[09:30:14.573]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:14.573]                     next
[09:30:14.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:14.573]                 }
[09:30:14.573]                 if (length(args) > 0) 
[09:30:14.573]                   base::do.call(base::Sys.setenv, args = args)
[09:30:14.573]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:14.573]             }
[09:30:14.573]             else {
[09:30:14.573]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:14.573]             }
[09:30:14.573]             {
[09:30:14.573]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:14.573]                   0L) {
[09:30:14.573]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:14.573]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:14.573]                   base::options(opts)
[09:30:14.573]                 }
[09:30:14.573]                 {
[09:30:14.573]                   {
[09:30:14.573]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:14.573]                     NULL
[09:30:14.573]                   }
[09:30:14.573]                   options(future.plan = NULL)
[09:30:14.573]                   if (is.na(NA_character_)) 
[09:30:14.573]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:14.573]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:14.573]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:14.573]                     .init = FALSE)
[09:30:14.573]                 }
[09:30:14.573]             }
[09:30:14.573]         }
[09:30:14.573]     })
[09:30:14.573]     if (FALSE) {
[09:30:14.573]         base::sink(type = "output", split = FALSE)
[09:30:14.573]         if (NA) {
[09:30:14.573]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:14.573]         }
[09:30:14.573]         else {
[09:30:14.573]             ...future.result["stdout"] <- base::list(NULL)
[09:30:14.573]         }
[09:30:14.573]         base::close(...future.stdout)
[09:30:14.573]         ...future.stdout <- NULL
[09:30:14.573]     }
[09:30:14.573]     ...future.result$conditions <- ...future.conditions
[09:30:14.573]     ...future.result$finished <- base::Sys.time()
[09:30:14.573]     ...future.result
[09:30:14.573] }
[09:30:14.576] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[09:30:14.576] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[09:30:14.576] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[09:30:14.577] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:30:14.580] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:30:14.580] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[09:30:14.580] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[09:30:14.580] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:30:14.581] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:30:14.581] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:30:14.581] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:30:14.581] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[09:30:14.582] MultisessionFuture started
[09:30:14.582] - Launch lazy future ... done
[09:30:14.582] run() for ‘MultisessionFuture’ ... done
[09:30:14.582] Created future:
[09:30:14.582] MultisessionFuture:
[09:30:14.582] Label: ‘future_lapply-2’
[09:30:14.582] Expression:
[09:30:14.582] {
[09:30:14.582]     do.call(function(...) {
[09:30:14.582]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:14.582]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:14.582]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:14.582]             on.exit(options(oopts), add = TRUE)
[09:30:14.582]         }
[09:30:14.582]         {
[09:30:14.582]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:30:14.582]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:30:14.582]                 ...future.FUN(...future.X_jj, ...)
[09:30:14.582]             })
[09:30:14.582]         }
[09:30:14.582]     }, args = future.call.arguments)
[09:30:14.582] }
[09:30:14.582] Lazy evaluation: FALSE
[09:30:14.582] Asynchronous evaluation: TRUE
[09:30:14.582] Local evaluation: TRUE
[09:30:14.582] Environment: R_GlobalEnv
[09:30:14.582] Capture standard output: NA
[09:30:14.582] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:14.582] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:14.582] Packages: <none>
[09:30:14.582] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:14.582] Resolved: FALSE
[09:30:14.582] Value: <not collected>
[09:30:14.582] Conditions captured: <none>
[09:30:14.582] Early signaling: FALSE
[09:30:14.582] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:14.582] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:14.593] Chunk #2 of 2 ... DONE
[09:30:14.594] Launching 2 futures (chunks) ... DONE
[09:30:14.594] Resolving 2 futures (chunks) ...
[09:30:14.594] resolve() on list ...
[09:30:14.594]  recursive: 0
[09:30:14.594]  length: 2
[09:30:14.594] 
[09:30:14.636] receiveMessageFromWorker() for ClusterFuture ...
[09:30:14.636] - Validating connection of MultisessionFuture
[09:30:14.637] - received message: FutureResult
[09:30:14.637] - Received FutureResult
[09:30:14.637] - Erased future from FutureRegistry
[09:30:14.637] result() for ClusterFuture ...
[09:30:14.637] - result already collected: FutureResult
[09:30:14.638] result() for ClusterFuture ... done
[09:30:14.638] receiveMessageFromWorker() for ClusterFuture ... done
[09:30:14.638] Future #2
[09:30:14.638] result() for ClusterFuture ...
[09:30:14.638] - result already collected: FutureResult
[09:30:14.638] result() for ClusterFuture ... done
[09:30:14.639] result() for ClusterFuture ...
[09:30:14.639] - result already collected: FutureResult
[09:30:14.639] result() for ClusterFuture ... done
[09:30:14.639] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:30:14.639] - nx: 2
[09:30:14.639] - relay: TRUE
[09:30:14.640] - stdout: TRUE
[09:30:14.640] - signal: TRUE
[09:30:14.640] - resignal: FALSE
[09:30:14.640] - force: TRUE
[09:30:14.640] - relayed: [n=2] FALSE, FALSE
[09:30:14.640] - queued futures: [n=2] FALSE, FALSE
[09:30:14.640]  - until=1
[09:30:14.641]  - relaying element #1
[09:30:14.641] - relayed: [n=2] FALSE, FALSE
[09:30:14.641] - queued futures: [n=2] FALSE, TRUE
[09:30:14.641] signalConditionsASAP(NULL, pos=2) ... done
[09:30:14.641]  length: 1 (resolved future 2)
[09:30:15.086] receiveMessageFromWorker() for ClusterFuture ...
[09:30:15.086] - Validating connection of MultisessionFuture
[09:30:15.087] - received message: FutureResult
[09:30:15.087] - Received FutureResult
[09:30:15.087] - Erased future from FutureRegistry
[09:30:15.087] result() for ClusterFuture ...
[09:30:15.087] - result already collected: FutureResult
[09:30:15.087] result() for ClusterFuture ... done
[09:30:15.087] receiveMessageFromWorker() for ClusterFuture ... done
[09:30:15.087] Future #1
[09:30:15.087] result() for ClusterFuture ...
[09:30:15.087] - result already collected: FutureResult
[09:30:15.088] result() for ClusterFuture ... done
[09:30:15.088] result() for ClusterFuture ...
[09:30:15.088] - result already collected: FutureResult
[09:30:15.088] result() for ClusterFuture ... done
[09:30:15.088] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:30:15.088] - nx: 2
[09:30:15.088] - relay: TRUE
[09:30:15.088] - stdout: TRUE
[09:30:15.088] - signal: TRUE
[09:30:15.088] - resignal: FALSE
[09:30:15.088] - force: TRUE
[09:30:15.088] - relayed: [n=2] FALSE, FALSE
[09:30:15.089] - queued futures: [n=2] FALSE, TRUE
[09:30:15.089]  - until=1
[09:30:15.089]  - relaying element #1
[09:30:15.089] result() for ClusterFuture ...
[09:30:15.089] - result already collected: FutureResult
[09:30:15.089] result() for ClusterFuture ... done
[09:30:15.089] result() for ClusterFuture ...
[09:30:15.089] - result already collected: FutureResult
[09:30:15.089] result() for ClusterFuture ... done
[09:30:15.089] result() for ClusterFuture ...
[09:30:15.089] - result already collected: FutureResult
[09:30:15.089] result() for ClusterFuture ... done
[09:30:15.090] result() for ClusterFuture ...
[09:30:15.090] - result already collected: FutureResult
[09:30:15.090] result() for ClusterFuture ... done
[09:30:15.090] - relayed: [n=2] TRUE, FALSE
[09:30:15.090] - queued futures: [n=2] TRUE, TRUE
[09:30:15.090] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:30:15.090]  length: 0 (resolved future 1)
[09:30:15.090] Relaying remaining futures
[09:30:15.090] signalConditionsASAP(NULL, pos=0) ...
[09:30:15.090] - nx: 2
[09:30:15.090] - relay: TRUE
[09:30:15.090] - stdout: TRUE
[09:30:15.091] - signal: TRUE
[09:30:15.091] - resignal: FALSE
[09:30:15.091] - force: TRUE
[09:30:15.091] - relayed: [n=2] TRUE, FALSE
[09:30:15.091] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:30:15.091]  - relaying element #2
[09:30:15.091] result() for ClusterFuture ...
[09:30:15.091] - result already collected: FutureResult
[09:30:15.091] result() for ClusterFuture ... done
[09:30:15.091] result() for ClusterFuture ...
[09:30:15.091] - result already collected: FutureResult
[09:30:15.092] result() for ClusterFuture ... done
[09:30:15.092] result() for ClusterFuture ...
[09:30:15.092] - result already collected: FutureResult
[09:30:15.092] result() for ClusterFuture ... done
[09:30:15.092] result() for ClusterFuture ...
[09:30:15.092] - result already collected: FutureResult
[09:30:15.092] result() for ClusterFuture ... done
[09:30:15.092] - relayed: [n=2] TRUE, TRUE
[09:30:15.092] - queued futures: [n=2] TRUE, TRUE
[09:30:15.092] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[09:30:15.092] resolve() on list ... DONE
[09:30:15.093] result() for ClusterFuture ...
[09:30:15.093] - result already collected: FutureResult
[09:30:15.093] result() for ClusterFuture ... done
[09:30:15.093] result() for ClusterFuture ...
[09:30:15.093] - result already collected: FutureResult
[09:30:15.093] result() for ClusterFuture ... done
[09:30:15.093] result() for ClusterFuture ...
[09:30:15.093] - result already collected: FutureResult
[09:30:15.093] result() for ClusterFuture ... done
[09:30:15.093] result() for ClusterFuture ...
[09:30:15.093] - result already collected: FutureResult
[09:30:15.093] result() for ClusterFuture ... done
[09:30:15.094]  - Number of value chunks collected: 2
[09:30:15.094] Resolving 2 futures (chunks) ... DONE
[09:30:15.094] Reducing values from 2 chunks ...
[09:30:15.094]  - Number of values collected after concatenation: 2
[09:30:15.094]  - Number of values expected: 2
[09:30:15.094] Reducing values from 2 chunks ... DONE
[09:30:15.094] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[09:30:15.094] future_mapply() ...
[09:30:15.098] Number of chunks: 2
[09:30:15.098] getGlobalsAndPackagesXApply() ...
[09:30:15.098]  - future.globals: TRUE
[09:30:15.099] getGlobalsAndPackages() ...
[09:30:15.099] Searching for globals...
[09:30:15.100] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[09:30:15.100] Searching for globals ... DONE
[09:30:15.100] Resolving globals: FALSE
[09:30:15.101] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[09:30:15.101] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[09:30:15.101] - globals: [1] ‘FUN’
[09:30:15.101] 
[09:30:15.101] getGlobalsAndPackages() ... DONE
[09:30:15.101]  - globals found/used: [n=1] ‘FUN’
[09:30:15.102]  - needed namespaces: [n=0] 
[09:30:15.102] Finding globals ... DONE
[09:30:15.102] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:30:15.102] List of 2
[09:30:15.102]  $ ...future.FUN:function (x, y)  
[09:30:15.102]  $ MoreArgs     : NULL
[09:30:15.102]  - attr(*, "where")=List of 2
[09:30:15.102]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:15.102]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:30:15.102]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:15.102]  - attr(*, "resolved")= logi FALSE
[09:30:15.102]  - attr(*, "total_size")= num NA
[09:30:15.104] Packages to be attached in all futures: [n=0] 
[09:30:15.105] getGlobalsAndPackagesXApply() ... DONE
[09:30:15.105] Number of futures (= number of chunks): 2
[09:30:15.105] Launching 2 futures (chunks) ...
[09:30:15.105] Chunk #1 of 2 ...
[09:30:15.105]  - Finding globals in '...' for chunk #1 ...
[09:30:15.105] getGlobalsAndPackages() ...
[09:30:15.105] Searching for globals...
[09:30:15.106] 
[09:30:15.106] Searching for globals ... DONE
[09:30:15.106] - globals: [0] <none>
[09:30:15.106] getGlobalsAndPackages() ... DONE
[09:30:15.106]    + additional globals found: [n=0] 
[09:30:15.106]    + additional namespaces needed: [n=0] 
[09:30:15.106]  - Finding globals in '...' for chunk #1 ... DONE
[09:30:15.106]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:15.106]  - seeds: <none>
[09:30:15.106]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:15.106] getGlobalsAndPackages() ...
[09:30:15.107] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:15.107] Resolving globals: FALSE
[09:30:15.107] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[09:30:15.109] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:30:15.109] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:15.110] 
[09:30:15.110] getGlobalsAndPackages() ... DONE
[09:30:15.110] run() for ‘Future’ ...
[09:30:15.110] - state: ‘created’
[09:30:15.110] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:30:15.124] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:15.124] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:30:15.124]   - Field: ‘node’
[09:30:15.124]   - Field: ‘label’
[09:30:15.124]   - Field: ‘local’
[09:30:15.124]   - Field: ‘owner’
[09:30:15.124]   - Field: ‘envir’
[09:30:15.125]   - Field: ‘workers’
[09:30:15.125]   - Field: ‘packages’
[09:30:15.125]   - Field: ‘gc’
[09:30:15.125]   - Field: ‘conditions’
[09:30:15.125]   - Field: ‘persistent’
[09:30:15.125]   - Field: ‘expr’
[09:30:15.125]   - Field: ‘uuid’
[09:30:15.125]   - Field: ‘seed’
[09:30:15.125]   - Field: ‘version’
[09:30:15.125]   - Field: ‘result’
[09:30:15.125]   - Field: ‘asynchronous’
[09:30:15.126]   - Field: ‘calls’
[09:30:15.126]   - Field: ‘globals’
[09:30:15.126]   - Field: ‘stdout’
[09:30:15.126]   - Field: ‘earlySignal’
[09:30:15.126]   - Field: ‘lazy’
[09:30:15.126]   - Field: ‘state’
[09:30:15.126] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:30:15.126] - Launch lazy future ...
[09:30:15.126] Packages needed by the future expression (n = 0): <none>
[09:30:15.126] Packages needed by future strategies (n = 0): <none>
[09:30:15.127] {
[09:30:15.127]     {
[09:30:15.127]         {
[09:30:15.127]             ...future.startTime <- base::Sys.time()
[09:30:15.127]             {
[09:30:15.127]                 {
[09:30:15.127]                   {
[09:30:15.127]                     {
[09:30:15.127]                       base::local({
[09:30:15.127]                         has_future <- base::requireNamespace("future", 
[09:30:15.127]                           quietly = TRUE)
[09:30:15.127]                         if (has_future) {
[09:30:15.127]                           ns <- base::getNamespace("future")
[09:30:15.127]                           version <- ns[[".package"]][["version"]]
[09:30:15.127]                           if (is.null(version)) 
[09:30:15.127]                             version <- utils::packageVersion("future")
[09:30:15.127]                         }
[09:30:15.127]                         else {
[09:30:15.127]                           version <- NULL
[09:30:15.127]                         }
[09:30:15.127]                         if (!has_future || version < "1.8.0") {
[09:30:15.127]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:15.127]                             "", base::R.version$version.string), 
[09:30:15.127]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:15.127]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:15.127]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:15.127]                               "release", "version")], collapse = " "), 
[09:30:15.127]                             hostname = base::Sys.info()[["nodename"]])
[09:30:15.127]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:15.127]                             info)
[09:30:15.127]                           info <- base::paste(info, collapse = "; ")
[09:30:15.127]                           if (!has_future) {
[09:30:15.127]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:15.127]                               info)
[09:30:15.127]                           }
[09:30:15.127]                           else {
[09:30:15.127]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:15.127]                               info, version)
[09:30:15.127]                           }
[09:30:15.127]                           base::stop(msg)
[09:30:15.127]                         }
[09:30:15.127]                       })
[09:30:15.127]                     }
[09:30:15.127]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:15.127]                     base::options(mc.cores = 1L)
[09:30:15.127]                   }
[09:30:15.127]                   ...future.strategy.old <- future::plan("list")
[09:30:15.127]                   options(future.plan = NULL)
[09:30:15.127]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:15.127]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:15.127]                 }
[09:30:15.127]                 ...future.workdir <- getwd()
[09:30:15.127]             }
[09:30:15.127]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:15.127]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:15.127]         }
[09:30:15.127]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:15.127]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:15.127]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:15.127]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:15.127]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:15.127]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:15.127]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:15.127]             base::names(...future.oldOptions))
[09:30:15.127]     }
[09:30:15.127]     if (FALSE) {
[09:30:15.127]     }
[09:30:15.127]     else {
[09:30:15.127]         if (FALSE) {
[09:30:15.127]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:15.127]                 open = "w")
[09:30:15.127]         }
[09:30:15.127]         else {
[09:30:15.127]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:15.127]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:15.127]         }
[09:30:15.127]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:15.127]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:15.127]             base::sink(type = "output", split = FALSE)
[09:30:15.127]             base::close(...future.stdout)
[09:30:15.127]         }, add = TRUE)
[09:30:15.127]     }
[09:30:15.127]     ...future.frame <- base::sys.nframe()
[09:30:15.127]     ...future.conditions <- base::list()
[09:30:15.127]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:15.127]     if (FALSE) {
[09:30:15.127]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:15.127]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:15.127]     }
[09:30:15.127]     ...future.result <- base::tryCatch({
[09:30:15.127]         base::withCallingHandlers({
[09:30:15.127]             ...future.value <- base::withVisible(base::local({
[09:30:15.127]                 ...future.makeSendCondition <- base::local({
[09:30:15.127]                   sendCondition <- NULL
[09:30:15.127]                   function(frame = 1L) {
[09:30:15.127]                     if (is.function(sendCondition)) 
[09:30:15.127]                       return(sendCondition)
[09:30:15.127]                     ns <- getNamespace("parallel")
[09:30:15.127]                     if (exists("sendData", mode = "function", 
[09:30:15.127]                       envir = ns)) {
[09:30:15.127]                       parallel_sendData <- get("sendData", mode = "function", 
[09:30:15.127]                         envir = ns)
[09:30:15.127]                       envir <- sys.frame(frame)
[09:30:15.127]                       master <- NULL
[09:30:15.127]                       while (!identical(envir, .GlobalEnv) && 
[09:30:15.127]                         !identical(envir, emptyenv())) {
[09:30:15.127]                         if (exists("master", mode = "list", envir = envir, 
[09:30:15.127]                           inherits = FALSE)) {
[09:30:15.127]                           master <- get("master", mode = "list", 
[09:30:15.127]                             envir = envir, inherits = FALSE)
[09:30:15.127]                           if (inherits(master, c("SOCKnode", 
[09:30:15.127]                             "SOCK0node"))) {
[09:30:15.127]                             sendCondition <<- function(cond) {
[09:30:15.127]                               data <- list(type = "VALUE", value = cond, 
[09:30:15.127]                                 success = TRUE)
[09:30:15.127]                               parallel_sendData(master, data)
[09:30:15.127]                             }
[09:30:15.127]                             return(sendCondition)
[09:30:15.127]                           }
[09:30:15.127]                         }
[09:30:15.127]                         frame <- frame + 1L
[09:30:15.127]                         envir <- sys.frame(frame)
[09:30:15.127]                       }
[09:30:15.127]                     }
[09:30:15.127]                     sendCondition <<- function(cond) NULL
[09:30:15.127]                   }
[09:30:15.127]                 })
[09:30:15.127]                 withCallingHandlers({
[09:30:15.127]                   {
[09:30:15.127]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:15.127]                     if (!identical(...future.globals.maxSize.org, 
[09:30:15.127]                       ...future.globals.maxSize)) {
[09:30:15.127]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:15.127]                       on.exit(options(oopts), add = TRUE)
[09:30:15.127]                     }
[09:30:15.127]                     {
[09:30:15.127]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:15.127]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:30:15.127]                         USE.NAMES = FALSE)
[09:30:15.127]                       do.call(mapply, args = args)
[09:30:15.127]                     }
[09:30:15.127]                   }
[09:30:15.127]                 }, immediateCondition = function(cond) {
[09:30:15.127]                   sendCondition <- ...future.makeSendCondition()
[09:30:15.127]                   sendCondition(cond)
[09:30:15.127]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:15.127]                   {
[09:30:15.127]                     inherits <- base::inherits
[09:30:15.127]                     invokeRestart <- base::invokeRestart
[09:30:15.127]                     is.null <- base::is.null
[09:30:15.127]                     muffled <- FALSE
[09:30:15.127]                     if (inherits(cond, "message")) {
[09:30:15.127]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:15.127]                       if (muffled) 
[09:30:15.127]                         invokeRestart("muffleMessage")
[09:30:15.127]                     }
[09:30:15.127]                     else if (inherits(cond, "warning")) {
[09:30:15.127]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:15.127]                       if (muffled) 
[09:30:15.127]                         invokeRestart("muffleWarning")
[09:30:15.127]                     }
[09:30:15.127]                     else if (inherits(cond, "condition")) {
[09:30:15.127]                       if (!is.null(pattern)) {
[09:30:15.127]                         computeRestarts <- base::computeRestarts
[09:30:15.127]                         grepl <- base::grepl
[09:30:15.127]                         restarts <- computeRestarts(cond)
[09:30:15.127]                         for (restart in restarts) {
[09:30:15.127]                           name <- restart$name
[09:30:15.127]                           if (is.null(name)) 
[09:30:15.127]                             next
[09:30:15.127]                           if (!grepl(pattern, name)) 
[09:30:15.127]                             next
[09:30:15.127]                           invokeRestart(restart)
[09:30:15.127]                           muffled <- TRUE
[09:30:15.127]                           break
[09:30:15.127]                         }
[09:30:15.127]                       }
[09:30:15.127]                     }
[09:30:15.127]                     invisible(muffled)
[09:30:15.127]                   }
[09:30:15.127]                   muffleCondition(cond)
[09:30:15.127]                 })
[09:30:15.127]             }))
[09:30:15.127]             future::FutureResult(value = ...future.value$value, 
[09:30:15.127]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:15.127]                   ...future.rng), globalenv = if (FALSE) 
[09:30:15.127]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:15.127]                     ...future.globalenv.names))
[09:30:15.127]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:15.127]         }, condition = base::local({
[09:30:15.127]             c <- base::c
[09:30:15.127]             inherits <- base::inherits
[09:30:15.127]             invokeRestart <- base::invokeRestart
[09:30:15.127]             length <- base::length
[09:30:15.127]             list <- base::list
[09:30:15.127]             seq.int <- base::seq.int
[09:30:15.127]             signalCondition <- base::signalCondition
[09:30:15.127]             sys.calls <- base::sys.calls
[09:30:15.127]             `[[` <- base::`[[`
[09:30:15.127]             `+` <- base::`+`
[09:30:15.127]             `<<-` <- base::`<<-`
[09:30:15.127]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:15.127]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:15.127]                   3L)]
[09:30:15.127]             }
[09:30:15.127]             function(cond) {
[09:30:15.127]                 is_error <- inherits(cond, "error")
[09:30:15.127]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:15.127]                   NULL)
[09:30:15.127]                 if (is_error) {
[09:30:15.127]                   sessionInformation <- function() {
[09:30:15.127]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:15.127]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:15.127]                       search = base::search(), system = base::Sys.info())
[09:30:15.127]                   }
[09:30:15.127]                   ...future.conditions[[length(...future.conditions) + 
[09:30:15.127]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:15.127]                     cond$call), session = sessionInformation(), 
[09:30:15.127]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:15.127]                   signalCondition(cond)
[09:30:15.127]                 }
[09:30:15.127]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:15.127]                 "immediateCondition"))) {
[09:30:15.127]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:15.127]                   ...future.conditions[[length(...future.conditions) + 
[09:30:15.127]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:15.127]                   if (TRUE && !signal) {
[09:30:15.127]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:15.127]                     {
[09:30:15.127]                       inherits <- base::inherits
[09:30:15.127]                       invokeRestart <- base::invokeRestart
[09:30:15.127]                       is.null <- base::is.null
[09:30:15.127]                       muffled <- FALSE
[09:30:15.127]                       if (inherits(cond, "message")) {
[09:30:15.127]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:15.127]                         if (muffled) 
[09:30:15.127]                           invokeRestart("muffleMessage")
[09:30:15.127]                       }
[09:30:15.127]                       else if (inherits(cond, "warning")) {
[09:30:15.127]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:15.127]                         if (muffled) 
[09:30:15.127]                           invokeRestart("muffleWarning")
[09:30:15.127]                       }
[09:30:15.127]                       else if (inherits(cond, "condition")) {
[09:30:15.127]                         if (!is.null(pattern)) {
[09:30:15.127]                           computeRestarts <- base::computeRestarts
[09:30:15.127]                           grepl <- base::grepl
[09:30:15.127]                           restarts <- computeRestarts(cond)
[09:30:15.127]                           for (restart in restarts) {
[09:30:15.127]                             name <- restart$name
[09:30:15.127]                             if (is.null(name)) 
[09:30:15.127]                               next
[09:30:15.127]                             if (!grepl(pattern, name)) 
[09:30:15.127]                               next
[09:30:15.127]                             invokeRestart(restart)
[09:30:15.127]                             muffled <- TRUE
[09:30:15.127]                             break
[09:30:15.127]                           }
[09:30:15.127]                         }
[09:30:15.127]                       }
[09:30:15.127]                       invisible(muffled)
[09:30:15.127]                     }
[09:30:15.127]                     muffleCondition(cond, pattern = "^muffle")
[09:30:15.127]                   }
[09:30:15.127]                 }
[09:30:15.127]                 else {
[09:30:15.127]                   if (TRUE) {
[09:30:15.127]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:15.127]                     {
[09:30:15.127]                       inherits <- base::inherits
[09:30:15.127]                       invokeRestart <- base::invokeRestart
[09:30:15.127]                       is.null <- base::is.null
[09:30:15.127]                       muffled <- FALSE
[09:30:15.127]                       if (inherits(cond, "message")) {
[09:30:15.127]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:15.127]                         if (muffled) 
[09:30:15.127]                           invokeRestart("muffleMessage")
[09:30:15.127]                       }
[09:30:15.127]                       else if (inherits(cond, "warning")) {
[09:30:15.127]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:15.127]                         if (muffled) 
[09:30:15.127]                           invokeRestart("muffleWarning")
[09:30:15.127]                       }
[09:30:15.127]                       else if (inherits(cond, "condition")) {
[09:30:15.127]                         if (!is.null(pattern)) {
[09:30:15.127]                           computeRestarts <- base::computeRestarts
[09:30:15.127]                           grepl <- base::grepl
[09:30:15.127]                           restarts <- computeRestarts(cond)
[09:30:15.127]                           for (restart in restarts) {
[09:30:15.127]                             name <- restart$name
[09:30:15.127]                             if (is.null(name)) 
[09:30:15.127]                               next
[09:30:15.127]                             if (!grepl(pattern, name)) 
[09:30:15.127]                               next
[09:30:15.127]                             invokeRestart(restart)
[09:30:15.127]                             muffled <- TRUE
[09:30:15.127]                             break
[09:30:15.127]                           }
[09:30:15.127]                         }
[09:30:15.127]                       }
[09:30:15.127]                       invisible(muffled)
[09:30:15.127]                     }
[09:30:15.127]                     muffleCondition(cond, pattern = "^muffle")
[09:30:15.127]                   }
[09:30:15.127]                 }
[09:30:15.127]             }
[09:30:15.127]         }))
[09:30:15.127]     }, error = function(ex) {
[09:30:15.127]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:15.127]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:15.127]                 ...future.rng), started = ...future.startTime, 
[09:30:15.127]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:15.127]             version = "1.8"), class = "FutureResult")
[09:30:15.127]     }, finally = {
[09:30:15.127]         if (!identical(...future.workdir, getwd())) 
[09:30:15.127]             setwd(...future.workdir)
[09:30:15.127]         {
[09:30:15.127]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:15.127]                 ...future.oldOptions$nwarnings <- NULL
[09:30:15.127]             }
[09:30:15.127]             base::options(...future.oldOptions)
[09:30:15.127]             if (.Platform$OS.type == "windows") {
[09:30:15.127]                 old_names <- names(...future.oldEnvVars)
[09:30:15.127]                 envs <- base::Sys.getenv()
[09:30:15.127]                 names <- names(envs)
[09:30:15.127]                 common <- intersect(names, old_names)
[09:30:15.127]                 added <- setdiff(names, old_names)
[09:30:15.127]                 removed <- setdiff(old_names, names)
[09:30:15.127]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:15.127]                   envs[common]]
[09:30:15.127]                 NAMES <- toupper(changed)
[09:30:15.127]                 args <- list()
[09:30:15.127]                 for (kk in seq_along(NAMES)) {
[09:30:15.127]                   name <- changed[[kk]]
[09:30:15.127]                   NAME <- NAMES[[kk]]
[09:30:15.127]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:15.127]                     next
[09:30:15.127]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:15.127]                 }
[09:30:15.127]                 NAMES <- toupper(added)
[09:30:15.127]                 for (kk in seq_along(NAMES)) {
[09:30:15.127]                   name <- added[[kk]]
[09:30:15.127]                   NAME <- NAMES[[kk]]
[09:30:15.127]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:15.127]                     next
[09:30:15.127]                   args[[name]] <- ""
[09:30:15.127]                 }
[09:30:15.127]                 NAMES <- toupper(removed)
[09:30:15.127]                 for (kk in seq_along(NAMES)) {
[09:30:15.127]                   name <- removed[[kk]]
[09:30:15.127]                   NAME <- NAMES[[kk]]
[09:30:15.127]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:15.127]                     next
[09:30:15.127]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:15.127]                 }
[09:30:15.127]                 if (length(args) > 0) 
[09:30:15.127]                   base::do.call(base::Sys.setenv, args = args)
[09:30:15.127]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:15.127]             }
[09:30:15.127]             else {
[09:30:15.127]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:15.127]             }
[09:30:15.127]             {
[09:30:15.127]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:15.127]                   0L) {
[09:30:15.127]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:15.127]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:15.127]                   base::options(opts)
[09:30:15.127]                 }
[09:30:15.127]                 {
[09:30:15.127]                   {
[09:30:15.127]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:15.127]                     NULL
[09:30:15.127]                   }
[09:30:15.127]                   options(future.plan = NULL)
[09:30:15.127]                   if (is.na(NA_character_)) 
[09:30:15.127]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:15.127]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:15.127]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:15.127]                     .init = FALSE)
[09:30:15.127]                 }
[09:30:15.127]             }
[09:30:15.127]         }
[09:30:15.127]     })
[09:30:15.127]     if (TRUE) {
[09:30:15.127]         base::sink(type = "output", split = FALSE)
[09:30:15.127]         if (FALSE) {
[09:30:15.127]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:15.127]         }
[09:30:15.127]         else {
[09:30:15.127]             ...future.result["stdout"] <- base::list(NULL)
[09:30:15.127]         }
[09:30:15.127]         base::close(...future.stdout)
[09:30:15.127]         ...future.stdout <- NULL
[09:30:15.127]     }
[09:30:15.127]     ...future.result$conditions <- ...future.conditions
[09:30:15.127]     ...future.result$finished <- base::Sys.time()
[09:30:15.127]     ...future.result
[09:30:15.127] }
[09:30:15.129] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[09:30:15.130] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[09:30:15.130] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[09:30:15.130] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:30:15.130] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:30:15.131] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[09:30:15.131] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[09:30:15.131] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:30:15.131] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:30:15.131] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:30:15.132] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:30:15.132] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[09:30:15.132] MultisessionFuture started
[09:30:15.132] - Launch lazy future ... done
[09:30:15.132] run() for ‘MultisessionFuture’ ... done
[09:30:15.133] Created future:
[09:30:15.133] MultisessionFuture:
[09:30:15.133] Label: ‘future_mapply-1’
[09:30:15.133] Expression:
[09:30:15.133] {
[09:30:15.133]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:15.133]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:15.133]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:15.133]         on.exit(options(oopts), add = TRUE)
[09:30:15.133]     }
[09:30:15.133]     {
[09:30:15.133]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:15.133]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:30:15.133]         do.call(mapply, args = args)
[09:30:15.133]     }
[09:30:15.133] }
[09:30:15.133] Lazy evaluation: FALSE
[09:30:15.133] Asynchronous evaluation: TRUE
[09:30:15.133] Local evaluation: TRUE
[09:30:15.133] Environment: R_GlobalEnv
[09:30:15.133] Capture standard output: FALSE
[09:30:15.133] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:15.133] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:15.133] Packages: <none>
[09:30:15.133] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:15.133] Resolved: FALSE
[09:30:15.133] Value: <not collected>
[09:30:15.133] Conditions captured: <none>
[09:30:15.133] Early signaling: FALSE
[09:30:15.133] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:15.133] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:15.144] Chunk #1 of 2 ... DONE
[09:30:15.144] Chunk #2 of 2 ...
[09:30:15.144]  - Finding globals in '...' for chunk #2 ...
[09:30:15.144] getGlobalsAndPackages() ...
[09:30:15.144] Searching for globals...
[09:30:15.145] 
[09:30:15.145] Searching for globals ... DONE
[09:30:15.145] - globals: [0] <none>
[09:30:15.145] getGlobalsAndPackages() ... DONE
[09:30:15.145]    + additional globals found: [n=0] 
[09:30:15.145]    + additional namespaces needed: [n=0] 
[09:30:15.145]  - Finding globals in '...' for chunk #2 ... DONE
[09:30:15.145]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:15.145]  - seeds: <none>
[09:30:15.146]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:15.146] getGlobalsAndPackages() ...
[09:30:15.146] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:15.146] Resolving globals: FALSE
[09:30:15.146] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[09:30:15.147] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:30:15.147] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:15.147] 
[09:30:15.147] getGlobalsAndPackages() ... DONE
[09:30:15.147] run() for ‘Future’ ...
[09:30:15.147] - state: ‘created’
[09:30:15.148] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:30:15.161] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:15.161] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:30:15.161]   - Field: ‘node’
[09:30:15.162]   - Field: ‘label’
[09:30:15.162]   - Field: ‘local’
[09:30:15.162]   - Field: ‘owner’
[09:30:15.162]   - Field: ‘envir’
[09:30:15.162]   - Field: ‘workers’
[09:30:15.162]   - Field: ‘packages’
[09:30:15.162]   - Field: ‘gc’
[09:30:15.162]   - Field: ‘conditions’
[09:30:15.162]   - Field: ‘persistent’
[09:30:15.162]   - Field: ‘expr’
[09:30:15.162]   - Field: ‘uuid’
[09:30:15.163]   - Field: ‘seed’
[09:30:15.163]   - Field: ‘version’
[09:30:15.163]   - Field: ‘result’
[09:30:15.163]   - Field: ‘asynchronous’
[09:30:15.163]   - Field: ‘calls’
[09:30:15.163]   - Field: ‘globals’
[09:30:15.163]   - Field: ‘stdout’
[09:30:15.163]   - Field: ‘earlySignal’
[09:30:15.163]   - Field: ‘lazy’
[09:30:15.163]   - Field: ‘state’
[09:30:15.163] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:30:15.163] - Launch lazy future ...
[09:30:15.164] Packages needed by the future expression (n = 0): <none>
[09:30:15.164] Packages needed by future strategies (n = 0): <none>
[09:30:15.164] {
[09:30:15.164]     {
[09:30:15.164]         {
[09:30:15.164]             ...future.startTime <- base::Sys.time()
[09:30:15.164]             {
[09:30:15.164]                 {
[09:30:15.164]                   {
[09:30:15.164]                     {
[09:30:15.164]                       base::local({
[09:30:15.164]                         has_future <- base::requireNamespace("future", 
[09:30:15.164]                           quietly = TRUE)
[09:30:15.164]                         if (has_future) {
[09:30:15.164]                           ns <- base::getNamespace("future")
[09:30:15.164]                           version <- ns[[".package"]][["version"]]
[09:30:15.164]                           if (is.null(version)) 
[09:30:15.164]                             version <- utils::packageVersion("future")
[09:30:15.164]                         }
[09:30:15.164]                         else {
[09:30:15.164]                           version <- NULL
[09:30:15.164]                         }
[09:30:15.164]                         if (!has_future || version < "1.8.0") {
[09:30:15.164]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:15.164]                             "", base::R.version$version.string), 
[09:30:15.164]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:15.164]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:15.164]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:15.164]                               "release", "version")], collapse = " "), 
[09:30:15.164]                             hostname = base::Sys.info()[["nodename"]])
[09:30:15.164]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:15.164]                             info)
[09:30:15.164]                           info <- base::paste(info, collapse = "; ")
[09:30:15.164]                           if (!has_future) {
[09:30:15.164]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:15.164]                               info)
[09:30:15.164]                           }
[09:30:15.164]                           else {
[09:30:15.164]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:15.164]                               info, version)
[09:30:15.164]                           }
[09:30:15.164]                           base::stop(msg)
[09:30:15.164]                         }
[09:30:15.164]                       })
[09:30:15.164]                     }
[09:30:15.164]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:15.164]                     base::options(mc.cores = 1L)
[09:30:15.164]                   }
[09:30:15.164]                   ...future.strategy.old <- future::plan("list")
[09:30:15.164]                   options(future.plan = NULL)
[09:30:15.164]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:15.164]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:15.164]                 }
[09:30:15.164]                 ...future.workdir <- getwd()
[09:30:15.164]             }
[09:30:15.164]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:15.164]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:15.164]         }
[09:30:15.164]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:15.164]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:15.164]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:15.164]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:15.164]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:15.164]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:15.164]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:15.164]             base::names(...future.oldOptions))
[09:30:15.164]     }
[09:30:15.164]     if (FALSE) {
[09:30:15.164]     }
[09:30:15.164]     else {
[09:30:15.164]         if (FALSE) {
[09:30:15.164]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:15.164]                 open = "w")
[09:30:15.164]         }
[09:30:15.164]         else {
[09:30:15.164]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:15.164]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:15.164]         }
[09:30:15.164]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:15.164]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:15.164]             base::sink(type = "output", split = FALSE)
[09:30:15.164]             base::close(...future.stdout)
[09:30:15.164]         }, add = TRUE)
[09:30:15.164]     }
[09:30:15.164]     ...future.frame <- base::sys.nframe()
[09:30:15.164]     ...future.conditions <- base::list()
[09:30:15.164]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:15.164]     if (FALSE) {
[09:30:15.164]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:15.164]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:15.164]     }
[09:30:15.164]     ...future.result <- base::tryCatch({
[09:30:15.164]         base::withCallingHandlers({
[09:30:15.164]             ...future.value <- base::withVisible(base::local({
[09:30:15.164]                 ...future.makeSendCondition <- base::local({
[09:30:15.164]                   sendCondition <- NULL
[09:30:15.164]                   function(frame = 1L) {
[09:30:15.164]                     if (is.function(sendCondition)) 
[09:30:15.164]                       return(sendCondition)
[09:30:15.164]                     ns <- getNamespace("parallel")
[09:30:15.164]                     if (exists("sendData", mode = "function", 
[09:30:15.164]                       envir = ns)) {
[09:30:15.164]                       parallel_sendData <- get("sendData", mode = "function", 
[09:30:15.164]                         envir = ns)
[09:30:15.164]                       envir <- sys.frame(frame)
[09:30:15.164]                       master <- NULL
[09:30:15.164]                       while (!identical(envir, .GlobalEnv) && 
[09:30:15.164]                         !identical(envir, emptyenv())) {
[09:30:15.164]                         if (exists("master", mode = "list", envir = envir, 
[09:30:15.164]                           inherits = FALSE)) {
[09:30:15.164]                           master <- get("master", mode = "list", 
[09:30:15.164]                             envir = envir, inherits = FALSE)
[09:30:15.164]                           if (inherits(master, c("SOCKnode", 
[09:30:15.164]                             "SOCK0node"))) {
[09:30:15.164]                             sendCondition <<- function(cond) {
[09:30:15.164]                               data <- list(type = "VALUE", value = cond, 
[09:30:15.164]                                 success = TRUE)
[09:30:15.164]                               parallel_sendData(master, data)
[09:30:15.164]                             }
[09:30:15.164]                             return(sendCondition)
[09:30:15.164]                           }
[09:30:15.164]                         }
[09:30:15.164]                         frame <- frame + 1L
[09:30:15.164]                         envir <- sys.frame(frame)
[09:30:15.164]                       }
[09:30:15.164]                     }
[09:30:15.164]                     sendCondition <<- function(cond) NULL
[09:30:15.164]                   }
[09:30:15.164]                 })
[09:30:15.164]                 withCallingHandlers({
[09:30:15.164]                   {
[09:30:15.164]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:15.164]                     if (!identical(...future.globals.maxSize.org, 
[09:30:15.164]                       ...future.globals.maxSize)) {
[09:30:15.164]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:15.164]                       on.exit(options(oopts), add = TRUE)
[09:30:15.164]                     }
[09:30:15.164]                     {
[09:30:15.164]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:15.164]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:30:15.164]                         USE.NAMES = FALSE)
[09:30:15.164]                       do.call(mapply, args = args)
[09:30:15.164]                     }
[09:30:15.164]                   }
[09:30:15.164]                 }, immediateCondition = function(cond) {
[09:30:15.164]                   sendCondition <- ...future.makeSendCondition()
[09:30:15.164]                   sendCondition(cond)
[09:30:15.164]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:15.164]                   {
[09:30:15.164]                     inherits <- base::inherits
[09:30:15.164]                     invokeRestart <- base::invokeRestart
[09:30:15.164]                     is.null <- base::is.null
[09:30:15.164]                     muffled <- FALSE
[09:30:15.164]                     if (inherits(cond, "message")) {
[09:30:15.164]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:15.164]                       if (muffled) 
[09:30:15.164]                         invokeRestart("muffleMessage")
[09:30:15.164]                     }
[09:30:15.164]                     else if (inherits(cond, "warning")) {
[09:30:15.164]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:15.164]                       if (muffled) 
[09:30:15.164]                         invokeRestart("muffleWarning")
[09:30:15.164]                     }
[09:30:15.164]                     else if (inherits(cond, "condition")) {
[09:30:15.164]                       if (!is.null(pattern)) {
[09:30:15.164]                         computeRestarts <- base::computeRestarts
[09:30:15.164]                         grepl <- base::grepl
[09:30:15.164]                         restarts <- computeRestarts(cond)
[09:30:15.164]                         for (restart in restarts) {
[09:30:15.164]                           name <- restart$name
[09:30:15.164]                           if (is.null(name)) 
[09:30:15.164]                             next
[09:30:15.164]                           if (!grepl(pattern, name)) 
[09:30:15.164]                             next
[09:30:15.164]                           invokeRestart(restart)
[09:30:15.164]                           muffled <- TRUE
[09:30:15.164]                           break
[09:30:15.164]                         }
[09:30:15.164]                       }
[09:30:15.164]                     }
[09:30:15.164]                     invisible(muffled)
[09:30:15.164]                   }
[09:30:15.164]                   muffleCondition(cond)
[09:30:15.164]                 })
[09:30:15.164]             }))
[09:30:15.164]             future::FutureResult(value = ...future.value$value, 
[09:30:15.164]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:15.164]                   ...future.rng), globalenv = if (FALSE) 
[09:30:15.164]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:15.164]                     ...future.globalenv.names))
[09:30:15.164]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:15.164]         }, condition = base::local({
[09:30:15.164]             c <- base::c
[09:30:15.164]             inherits <- base::inherits
[09:30:15.164]             invokeRestart <- base::invokeRestart
[09:30:15.164]             length <- base::length
[09:30:15.164]             list <- base::list
[09:30:15.164]             seq.int <- base::seq.int
[09:30:15.164]             signalCondition <- base::signalCondition
[09:30:15.164]             sys.calls <- base::sys.calls
[09:30:15.164]             `[[` <- base::`[[`
[09:30:15.164]             `+` <- base::`+`
[09:30:15.164]             `<<-` <- base::`<<-`
[09:30:15.164]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:15.164]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:15.164]                   3L)]
[09:30:15.164]             }
[09:30:15.164]             function(cond) {
[09:30:15.164]                 is_error <- inherits(cond, "error")
[09:30:15.164]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:15.164]                   NULL)
[09:30:15.164]                 if (is_error) {
[09:30:15.164]                   sessionInformation <- function() {
[09:30:15.164]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:15.164]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:15.164]                       search = base::search(), system = base::Sys.info())
[09:30:15.164]                   }
[09:30:15.164]                   ...future.conditions[[length(...future.conditions) + 
[09:30:15.164]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:15.164]                     cond$call), session = sessionInformation(), 
[09:30:15.164]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:15.164]                   signalCondition(cond)
[09:30:15.164]                 }
[09:30:15.164]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:15.164]                 "immediateCondition"))) {
[09:30:15.164]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:15.164]                   ...future.conditions[[length(...future.conditions) + 
[09:30:15.164]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:15.164]                   if (TRUE && !signal) {
[09:30:15.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:15.164]                     {
[09:30:15.164]                       inherits <- base::inherits
[09:30:15.164]                       invokeRestart <- base::invokeRestart
[09:30:15.164]                       is.null <- base::is.null
[09:30:15.164]                       muffled <- FALSE
[09:30:15.164]                       if (inherits(cond, "message")) {
[09:30:15.164]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:15.164]                         if (muffled) 
[09:30:15.164]                           invokeRestart("muffleMessage")
[09:30:15.164]                       }
[09:30:15.164]                       else if (inherits(cond, "warning")) {
[09:30:15.164]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:15.164]                         if (muffled) 
[09:30:15.164]                           invokeRestart("muffleWarning")
[09:30:15.164]                       }
[09:30:15.164]                       else if (inherits(cond, "condition")) {
[09:30:15.164]                         if (!is.null(pattern)) {
[09:30:15.164]                           computeRestarts <- base::computeRestarts
[09:30:15.164]                           grepl <- base::grepl
[09:30:15.164]                           restarts <- computeRestarts(cond)
[09:30:15.164]                           for (restart in restarts) {
[09:30:15.164]                             name <- restart$name
[09:30:15.164]                             if (is.null(name)) 
[09:30:15.164]                               next
[09:30:15.164]                             if (!grepl(pattern, name)) 
[09:30:15.164]                               next
[09:30:15.164]                             invokeRestart(restart)
[09:30:15.164]                             muffled <- TRUE
[09:30:15.164]                             break
[09:30:15.164]                           }
[09:30:15.164]                         }
[09:30:15.164]                       }
[09:30:15.164]                       invisible(muffled)
[09:30:15.164]                     }
[09:30:15.164]                     muffleCondition(cond, pattern = "^muffle")
[09:30:15.164]                   }
[09:30:15.164]                 }
[09:30:15.164]                 else {
[09:30:15.164]                   if (TRUE) {
[09:30:15.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:15.164]                     {
[09:30:15.164]                       inherits <- base::inherits
[09:30:15.164]                       invokeRestart <- base::invokeRestart
[09:30:15.164]                       is.null <- base::is.null
[09:30:15.164]                       muffled <- FALSE
[09:30:15.164]                       if (inherits(cond, "message")) {
[09:30:15.164]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:15.164]                         if (muffled) 
[09:30:15.164]                           invokeRestart("muffleMessage")
[09:30:15.164]                       }
[09:30:15.164]                       else if (inherits(cond, "warning")) {
[09:30:15.164]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:15.164]                         if (muffled) 
[09:30:15.164]                           invokeRestart("muffleWarning")
[09:30:15.164]                       }
[09:30:15.164]                       else if (inherits(cond, "condition")) {
[09:30:15.164]                         if (!is.null(pattern)) {
[09:30:15.164]                           computeRestarts <- base::computeRestarts
[09:30:15.164]                           grepl <- base::grepl
[09:30:15.164]                           restarts <- computeRestarts(cond)
[09:30:15.164]                           for (restart in restarts) {
[09:30:15.164]                             name <- restart$name
[09:30:15.164]                             if (is.null(name)) 
[09:30:15.164]                               next
[09:30:15.164]                             if (!grepl(pattern, name)) 
[09:30:15.164]                               next
[09:30:15.164]                             invokeRestart(restart)
[09:30:15.164]                             muffled <- TRUE
[09:30:15.164]                             break
[09:30:15.164]                           }
[09:30:15.164]                         }
[09:30:15.164]                       }
[09:30:15.164]                       invisible(muffled)
[09:30:15.164]                     }
[09:30:15.164]                     muffleCondition(cond, pattern = "^muffle")
[09:30:15.164]                   }
[09:30:15.164]                 }
[09:30:15.164]             }
[09:30:15.164]         }))
[09:30:15.164]     }, error = function(ex) {
[09:30:15.164]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:15.164]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:15.164]                 ...future.rng), started = ...future.startTime, 
[09:30:15.164]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:15.164]             version = "1.8"), class = "FutureResult")
[09:30:15.164]     }, finally = {
[09:30:15.164]         if (!identical(...future.workdir, getwd())) 
[09:30:15.164]             setwd(...future.workdir)
[09:30:15.164]         {
[09:30:15.164]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:15.164]                 ...future.oldOptions$nwarnings <- NULL
[09:30:15.164]             }
[09:30:15.164]             base::options(...future.oldOptions)
[09:30:15.164]             if (.Platform$OS.type == "windows") {
[09:30:15.164]                 old_names <- names(...future.oldEnvVars)
[09:30:15.164]                 envs <- base::Sys.getenv()
[09:30:15.164]                 names <- names(envs)
[09:30:15.164]                 common <- intersect(names, old_names)
[09:30:15.164]                 added <- setdiff(names, old_names)
[09:30:15.164]                 removed <- setdiff(old_names, names)
[09:30:15.164]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:15.164]                   envs[common]]
[09:30:15.164]                 NAMES <- toupper(changed)
[09:30:15.164]                 args <- list()
[09:30:15.164]                 for (kk in seq_along(NAMES)) {
[09:30:15.164]                   name <- changed[[kk]]
[09:30:15.164]                   NAME <- NAMES[[kk]]
[09:30:15.164]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:15.164]                     next
[09:30:15.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:15.164]                 }
[09:30:15.164]                 NAMES <- toupper(added)
[09:30:15.164]                 for (kk in seq_along(NAMES)) {
[09:30:15.164]                   name <- added[[kk]]
[09:30:15.164]                   NAME <- NAMES[[kk]]
[09:30:15.164]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:15.164]                     next
[09:30:15.164]                   args[[name]] <- ""
[09:30:15.164]                 }
[09:30:15.164]                 NAMES <- toupper(removed)
[09:30:15.164]                 for (kk in seq_along(NAMES)) {
[09:30:15.164]                   name <- removed[[kk]]
[09:30:15.164]                   NAME <- NAMES[[kk]]
[09:30:15.164]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:15.164]                     next
[09:30:15.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:15.164]                 }
[09:30:15.164]                 if (length(args) > 0) 
[09:30:15.164]                   base::do.call(base::Sys.setenv, args = args)
[09:30:15.164]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:15.164]             }
[09:30:15.164]             else {
[09:30:15.164]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:15.164]             }
[09:30:15.164]             {
[09:30:15.164]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:15.164]                   0L) {
[09:30:15.164]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:15.164]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:15.164]                   base::options(opts)
[09:30:15.164]                 }
[09:30:15.164]                 {
[09:30:15.164]                   {
[09:30:15.164]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:15.164]                     NULL
[09:30:15.164]                   }
[09:30:15.164]                   options(future.plan = NULL)
[09:30:15.164]                   if (is.na(NA_character_)) 
[09:30:15.164]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:15.164]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:15.164]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:15.164]                     .init = FALSE)
[09:30:15.164]                 }
[09:30:15.164]             }
[09:30:15.164]         }
[09:30:15.164]     })
[09:30:15.164]     if (TRUE) {
[09:30:15.164]         base::sink(type = "output", split = FALSE)
[09:30:15.164]         if (FALSE) {
[09:30:15.164]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:15.164]         }
[09:30:15.164]         else {
[09:30:15.164]             ...future.result["stdout"] <- base::list(NULL)
[09:30:15.164]         }
[09:30:15.164]         base::close(...future.stdout)
[09:30:15.164]         ...future.stdout <- NULL
[09:30:15.164]     }
[09:30:15.164]     ...future.result$conditions <- ...future.conditions
[09:30:15.164]     ...future.result$finished <- base::Sys.time()
[09:30:15.164]     ...future.result
[09:30:15.164] }
[09:30:15.167] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[09:30:15.167] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[09:30:15.167] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[09:30:15.167] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[09:30:15.168] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[09:30:15.168] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[09:30:15.168] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[09:30:15.169] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:30:15.169] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:30:15.169] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:30:15.169] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:30:15.169] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[09:30:15.170] MultisessionFuture started
[09:30:15.170] - Launch lazy future ... done
[09:30:15.170] run() for ‘MultisessionFuture’ ... done
[09:30:15.170] Created future:
[09:30:15.171] MultisessionFuture:
[09:30:15.171] Label: ‘future_mapply-2’
[09:30:15.171] Expression:
[09:30:15.171] {
[09:30:15.171]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:15.171]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:15.171]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:15.171]         on.exit(options(oopts), add = TRUE)
[09:30:15.171]     }
[09:30:15.171]     {
[09:30:15.171]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:15.171]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:30:15.171]         do.call(mapply, args = args)
[09:30:15.171]     }
[09:30:15.171] }
[09:30:15.171] Lazy evaluation: FALSE
[09:30:15.171] Asynchronous evaluation: TRUE
[09:30:15.171] Local evaluation: TRUE
[09:30:15.171] Environment: R_GlobalEnv
[09:30:15.171] Capture standard output: FALSE
[09:30:15.171] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:15.171] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:15.171] Packages: <none>
[09:30:15.171] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:15.171] Resolved: FALSE
[09:30:15.171] Value: <not collected>
[09:30:15.171] Conditions captured: <none>
[09:30:15.171] Early signaling: FALSE
[09:30:15.171] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:15.171] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:15.182] Chunk #2 of 2 ... DONE
[09:30:15.182] Launching 2 futures (chunks) ... DONE
[09:30:15.182] Resolving 2 futures (chunks) ...
[09:30:15.182] resolve() on list ...
[09:30:15.182]  recursive: 0
[09:30:15.182]  length: 2
[09:30:15.183] 
[09:30:15.224] receiveMessageFromWorker() for ClusterFuture ...
[09:30:15.225] - Validating connection of MultisessionFuture
[09:30:15.225] - received message: FutureResult
[09:30:15.225] - Received FutureResult
[09:30:15.225] - Erased future from FutureRegistry
[09:30:15.225] result() for ClusterFuture ...
[09:30:15.225] - result already collected: FutureResult
[09:30:15.225] result() for ClusterFuture ... done
[09:30:15.225] receiveMessageFromWorker() for ClusterFuture ... done
[09:30:15.225] Future #2
[09:30:15.226] result() for ClusterFuture ...
[09:30:15.226] - result already collected: FutureResult
[09:30:15.226] result() for ClusterFuture ... done
[09:30:15.226] result() for ClusterFuture ...
[09:30:15.226] - result already collected: FutureResult
[09:30:15.226] result() for ClusterFuture ... done
[09:30:15.226] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:30:15.226] - nx: 2
[09:30:15.226] - relay: TRUE
[09:30:15.226] - stdout: TRUE
[09:30:15.226] - signal: TRUE
[09:30:15.226] - resignal: FALSE
[09:30:15.227] - force: TRUE
[09:30:15.227] - relayed: [n=2] FALSE, FALSE
[09:30:15.227] - queued futures: [n=2] FALSE, FALSE
[09:30:15.227]  - until=1
[09:30:15.227]  - relaying element #1
[09:30:15.227] - relayed: [n=2] FALSE, FALSE
[09:30:15.227] - queued futures: [n=2] FALSE, TRUE
[09:30:15.227] signalConditionsASAP(NULL, pos=2) ... done
[09:30:15.227]  length: 1 (resolved future 2)
[09:30:15.678] receiveMessageFromWorker() for ClusterFuture ...
[09:30:15.679] - Validating connection of MultisessionFuture
[09:30:15.679] - received message: FutureResult
[09:30:15.679] - Received FutureResult
[09:30:15.679] - Erased future from FutureRegistry
[09:30:15.679] result() for ClusterFuture ...
[09:30:15.679] - result already collected: FutureResult
[09:30:15.679] result() for ClusterFuture ... done
[09:30:15.680] receiveMessageFromWorker() for ClusterFuture ... done
[09:30:15.680] Future #1
[09:30:15.680] result() for ClusterFuture ...
[09:30:15.680] - result already collected: FutureResult
[09:30:15.680] result() for ClusterFuture ... done
[09:30:15.680] result() for ClusterFuture ...
[09:30:15.680] - result already collected: FutureResult
[09:30:15.680] result() for ClusterFuture ... done
[09:30:15.680] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:30:15.680] - nx: 2
[09:30:15.680] - relay: TRUE
[09:30:15.681] - stdout: TRUE
[09:30:15.681] - signal: TRUE
[09:30:15.681] - resignal: FALSE
[09:30:15.681] - force: TRUE
[09:30:15.681] - relayed: [n=2] FALSE, FALSE
[09:30:15.681] - queued futures: [n=2] FALSE, TRUE
[09:30:15.681]  - until=1
[09:30:15.681]  - relaying element #1
[09:30:15.681] result() for ClusterFuture ...
[09:30:15.681] - result already collected: FutureResult
[09:30:15.681] result() for ClusterFuture ... done
[09:30:15.681] result() for ClusterFuture ...
[09:30:15.682] - result already collected: FutureResult
[09:30:15.682] result() for ClusterFuture ... done
[09:30:15.682] result() for ClusterFuture ...
[09:30:15.682] - result already collected: FutureResult
[09:30:15.682] result() for ClusterFuture ... done
[09:30:15.682] result() for ClusterFuture ...
[09:30:15.682] - result already collected: FutureResult
[09:30:15.682] result() for ClusterFuture ... done
[09:30:15.682] - relayed: [n=2] TRUE, FALSE
[09:30:15.682] - queued futures: [n=2] TRUE, TRUE
[09:30:15.682] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:30:15.682]  length: 0 (resolved future 1)
[09:30:15.683] Relaying remaining futures
[09:30:15.683] signalConditionsASAP(NULL, pos=0) ...
[09:30:15.683] - nx: 2
[09:30:15.683] - relay: TRUE
[09:30:15.683] - stdout: TRUE
[09:30:15.683] - signal: TRUE
[09:30:15.683] - resignal: FALSE
[09:30:15.683] - force: TRUE
[09:30:15.683] - relayed: [n=2] TRUE, FALSE
[09:30:15.683] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:30:15.683]  - relaying element #2
[09:30:15.684] result() for ClusterFuture ...
[09:30:15.684] - result already collected: FutureResult
[09:30:15.684] result() for ClusterFuture ... done
[09:30:15.684] result() for ClusterFuture ...
[09:30:15.684] - result already collected: FutureResult
[09:30:15.684] result() for ClusterFuture ... done
[09:30:15.684] result() for ClusterFuture ...
[09:30:15.684] - result already collected: FutureResult
[09:30:15.684] result() for ClusterFuture ... done
[09:30:15.684] result() for ClusterFuture ...
[09:30:15.684] - result already collected: FutureResult
[09:30:15.685] result() for ClusterFuture ... done
[09:30:15.685] - relayed: [n=2] TRUE, TRUE
[09:30:15.685] - queued futures: [n=2] TRUE, TRUE
[09:30:15.685] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[09:30:15.685] resolve() on list ... DONE
[09:30:15.685] result() for ClusterFuture ...
[09:30:15.685] - result already collected: FutureResult
[09:30:15.685] result() for ClusterFuture ... done
[09:30:15.685] result() for ClusterFuture ...
[09:30:15.685] - result already collected: FutureResult
[09:30:15.685] result() for ClusterFuture ... done
[09:30:15.685] result() for ClusterFuture ...
[09:30:15.686] - result already collected: FutureResult
[09:30:15.686] result() for ClusterFuture ... done
[09:30:15.686] result() for ClusterFuture ...
[09:30:15.686] - result already collected: FutureResult
[09:30:15.686] result() for ClusterFuture ... done
[09:30:15.686]  - Number of value chunks collected: 2
[09:30:15.686] Resolving 2 futures (chunks) ... DONE
[09:30:15.686] Reducing values from 2 chunks ...
[09:30:15.686]  - Number of values collected after concatenation: 2
[09:30:15.686]  - Number of values expected: 2
[09:30:15.686] Reducing values from 2 chunks ... DONE
[09:30:15.687] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[09:30:15.687] future_mapply() ...
[09:30:15.691] Number of chunks: 2
[09:30:15.691] getGlobalsAndPackagesXApply() ...
[09:30:15.691]  - future.globals: TRUE
[09:30:15.691] getGlobalsAndPackages() ...
[09:30:15.691] Searching for globals...
[09:30:15.693] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[09:30:15.693] Searching for globals ... DONE
[09:30:15.693] Resolving globals: FALSE
[09:30:15.694] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[09:30:15.694] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[09:30:15.694] - globals: [1] ‘FUN’
[09:30:15.694] 
[09:30:15.694] getGlobalsAndPackages() ... DONE
[09:30:15.694]  - globals found/used: [n=1] ‘FUN’
[09:30:15.695]  - needed namespaces: [n=0] 
[09:30:15.695] Finding globals ... DONE
[09:30:15.695] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:30:15.695] List of 2
[09:30:15.695]  $ ...future.FUN:function (x, y)  
[09:30:15.695]  $ MoreArgs     : NULL
[09:30:15.695]  - attr(*, "where")=List of 2
[09:30:15.695]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:15.695]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:30:15.695]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:15.695]  - attr(*, "resolved")= logi FALSE
[09:30:15.695]  - attr(*, "total_size")= num NA
[09:30:15.697] Packages to be attached in all futures: [n=0] 
[09:30:15.697] getGlobalsAndPackagesXApply() ... DONE
[09:30:15.698] Number of futures (= number of chunks): 2
[09:30:15.698] Launching 2 futures (chunks) ...
[09:30:15.698] Chunk #1 of 2 ...
[09:30:15.698]  - Finding globals in '...' for chunk #1 ...
[09:30:15.698] getGlobalsAndPackages() ...
[09:30:15.698] Searching for globals...
[09:30:15.698] 
[09:30:15.699] Searching for globals ... DONE
[09:30:15.699] - globals: [0] <none>
[09:30:15.699] getGlobalsAndPackages() ... DONE
[09:30:15.699]    + additional globals found: [n=0] 
[09:30:15.699]    + additional namespaces needed: [n=0] 
[09:30:15.699]  - Finding globals in '...' for chunk #1 ... DONE
[09:30:15.699]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:15.699]  - seeds: <none>
[09:30:15.699]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:15.699] getGlobalsAndPackages() ...
[09:30:15.699] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:15.700] Resolving globals: FALSE
[09:30:15.700] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[09:30:15.700] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:30:15.701] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:15.701] 
[09:30:15.701] getGlobalsAndPackages() ... DONE
[09:30:15.701] run() for ‘Future’ ...
[09:30:15.701] - state: ‘created’
[09:30:15.701] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:30:15.715] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:15.715] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:30:15.715]   - Field: ‘node’
[09:30:15.715]   - Field: ‘label’
[09:30:15.715]   - Field: ‘local’
[09:30:15.715]   - Field: ‘owner’
[09:30:15.715]   - Field: ‘envir’
[09:30:15.715]   - Field: ‘workers’
[09:30:15.716]   - Field: ‘packages’
[09:30:15.716]   - Field: ‘gc’
[09:30:15.716]   - Field: ‘conditions’
[09:30:15.716]   - Field: ‘persistent’
[09:30:15.716]   - Field: ‘expr’
[09:30:15.716]   - Field: ‘uuid’
[09:30:15.716]   - Field: ‘seed’
[09:30:15.716]   - Field: ‘version’
[09:30:15.716]   - Field: ‘result’
[09:30:15.716]   - Field: ‘asynchronous’
[09:30:15.717]   - Field: ‘calls’
[09:30:15.717]   - Field: ‘globals’
[09:30:15.717]   - Field: ‘stdout’
[09:30:15.717]   - Field: ‘earlySignal’
[09:30:15.717]   - Field: ‘lazy’
[09:30:15.717]   - Field: ‘state’
[09:30:15.717] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:30:15.717] - Launch lazy future ...
[09:30:15.717] Packages needed by the future expression (n = 0): <none>
[09:30:15.718] Packages needed by future strategies (n = 0): <none>
[09:30:15.718] {
[09:30:15.718]     {
[09:30:15.718]         {
[09:30:15.718]             ...future.startTime <- base::Sys.time()
[09:30:15.718]             {
[09:30:15.718]                 {
[09:30:15.718]                   {
[09:30:15.718]                     {
[09:30:15.718]                       base::local({
[09:30:15.718]                         has_future <- base::requireNamespace("future", 
[09:30:15.718]                           quietly = TRUE)
[09:30:15.718]                         if (has_future) {
[09:30:15.718]                           ns <- base::getNamespace("future")
[09:30:15.718]                           version <- ns[[".package"]][["version"]]
[09:30:15.718]                           if (is.null(version)) 
[09:30:15.718]                             version <- utils::packageVersion("future")
[09:30:15.718]                         }
[09:30:15.718]                         else {
[09:30:15.718]                           version <- NULL
[09:30:15.718]                         }
[09:30:15.718]                         if (!has_future || version < "1.8.0") {
[09:30:15.718]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:15.718]                             "", base::R.version$version.string), 
[09:30:15.718]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:15.718]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:15.718]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:15.718]                               "release", "version")], collapse = " "), 
[09:30:15.718]                             hostname = base::Sys.info()[["nodename"]])
[09:30:15.718]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:15.718]                             info)
[09:30:15.718]                           info <- base::paste(info, collapse = "; ")
[09:30:15.718]                           if (!has_future) {
[09:30:15.718]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:15.718]                               info)
[09:30:15.718]                           }
[09:30:15.718]                           else {
[09:30:15.718]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:15.718]                               info, version)
[09:30:15.718]                           }
[09:30:15.718]                           base::stop(msg)
[09:30:15.718]                         }
[09:30:15.718]                       })
[09:30:15.718]                     }
[09:30:15.718]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:15.718]                     base::options(mc.cores = 1L)
[09:30:15.718]                   }
[09:30:15.718]                   ...future.strategy.old <- future::plan("list")
[09:30:15.718]                   options(future.plan = NULL)
[09:30:15.718]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:15.718]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:15.718]                 }
[09:30:15.718]                 ...future.workdir <- getwd()
[09:30:15.718]             }
[09:30:15.718]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:15.718]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:15.718]         }
[09:30:15.718]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:15.718]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:15.718]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:15.718]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:15.718]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:15.718]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:15.718]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:15.718]             base::names(...future.oldOptions))
[09:30:15.718]     }
[09:30:15.718]     if (FALSE) {
[09:30:15.718]     }
[09:30:15.718]     else {
[09:30:15.718]         if (TRUE) {
[09:30:15.718]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:15.718]                 open = "w")
[09:30:15.718]         }
[09:30:15.718]         else {
[09:30:15.718]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:15.718]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:15.718]         }
[09:30:15.718]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:15.718]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:15.718]             base::sink(type = "output", split = FALSE)
[09:30:15.718]             base::close(...future.stdout)
[09:30:15.718]         }, add = TRUE)
[09:30:15.718]     }
[09:30:15.718]     ...future.frame <- base::sys.nframe()
[09:30:15.718]     ...future.conditions <- base::list()
[09:30:15.718]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:15.718]     if (FALSE) {
[09:30:15.718]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:15.718]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:15.718]     }
[09:30:15.718]     ...future.result <- base::tryCatch({
[09:30:15.718]         base::withCallingHandlers({
[09:30:15.718]             ...future.value <- base::withVisible(base::local({
[09:30:15.718]                 ...future.makeSendCondition <- base::local({
[09:30:15.718]                   sendCondition <- NULL
[09:30:15.718]                   function(frame = 1L) {
[09:30:15.718]                     if (is.function(sendCondition)) 
[09:30:15.718]                       return(sendCondition)
[09:30:15.718]                     ns <- getNamespace("parallel")
[09:30:15.718]                     if (exists("sendData", mode = "function", 
[09:30:15.718]                       envir = ns)) {
[09:30:15.718]                       parallel_sendData <- get("sendData", mode = "function", 
[09:30:15.718]                         envir = ns)
[09:30:15.718]                       envir <- sys.frame(frame)
[09:30:15.718]                       master <- NULL
[09:30:15.718]                       while (!identical(envir, .GlobalEnv) && 
[09:30:15.718]                         !identical(envir, emptyenv())) {
[09:30:15.718]                         if (exists("master", mode = "list", envir = envir, 
[09:30:15.718]                           inherits = FALSE)) {
[09:30:15.718]                           master <- get("master", mode = "list", 
[09:30:15.718]                             envir = envir, inherits = FALSE)
[09:30:15.718]                           if (inherits(master, c("SOCKnode", 
[09:30:15.718]                             "SOCK0node"))) {
[09:30:15.718]                             sendCondition <<- function(cond) {
[09:30:15.718]                               data <- list(type = "VALUE", value = cond, 
[09:30:15.718]                                 success = TRUE)
[09:30:15.718]                               parallel_sendData(master, data)
[09:30:15.718]                             }
[09:30:15.718]                             return(sendCondition)
[09:30:15.718]                           }
[09:30:15.718]                         }
[09:30:15.718]                         frame <- frame + 1L
[09:30:15.718]                         envir <- sys.frame(frame)
[09:30:15.718]                       }
[09:30:15.718]                     }
[09:30:15.718]                     sendCondition <<- function(cond) NULL
[09:30:15.718]                   }
[09:30:15.718]                 })
[09:30:15.718]                 withCallingHandlers({
[09:30:15.718]                   {
[09:30:15.718]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:15.718]                     if (!identical(...future.globals.maxSize.org, 
[09:30:15.718]                       ...future.globals.maxSize)) {
[09:30:15.718]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:15.718]                       on.exit(options(oopts), add = TRUE)
[09:30:15.718]                     }
[09:30:15.718]                     {
[09:30:15.718]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:15.718]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:30:15.718]                         USE.NAMES = FALSE)
[09:30:15.718]                       do.call(mapply, args = args)
[09:30:15.718]                     }
[09:30:15.718]                   }
[09:30:15.718]                 }, immediateCondition = function(cond) {
[09:30:15.718]                   sendCondition <- ...future.makeSendCondition()
[09:30:15.718]                   sendCondition(cond)
[09:30:15.718]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:15.718]                   {
[09:30:15.718]                     inherits <- base::inherits
[09:30:15.718]                     invokeRestart <- base::invokeRestart
[09:30:15.718]                     is.null <- base::is.null
[09:30:15.718]                     muffled <- FALSE
[09:30:15.718]                     if (inherits(cond, "message")) {
[09:30:15.718]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:15.718]                       if (muffled) 
[09:30:15.718]                         invokeRestart("muffleMessage")
[09:30:15.718]                     }
[09:30:15.718]                     else if (inherits(cond, "warning")) {
[09:30:15.718]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:15.718]                       if (muffled) 
[09:30:15.718]                         invokeRestart("muffleWarning")
[09:30:15.718]                     }
[09:30:15.718]                     else if (inherits(cond, "condition")) {
[09:30:15.718]                       if (!is.null(pattern)) {
[09:30:15.718]                         computeRestarts <- base::computeRestarts
[09:30:15.718]                         grepl <- base::grepl
[09:30:15.718]                         restarts <- computeRestarts(cond)
[09:30:15.718]                         for (restart in restarts) {
[09:30:15.718]                           name <- restart$name
[09:30:15.718]                           if (is.null(name)) 
[09:30:15.718]                             next
[09:30:15.718]                           if (!grepl(pattern, name)) 
[09:30:15.718]                             next
[09:30:15.718]                           invokeRestart(restart)
[09:30:15.718]                           muffled <- TRUE
[09:30:15.718]                           break
[09:30:15.718]                         }
[09:30:15.718]                       }
[09:30:15.718]                     }
[09:30:15.718]                     invisible(muffled)
[09:30:15.718]                   }
[09:30:15.718]                   muffleCondition(cond)
[09:30:15.718]                 })
[09:30:15.718]             }))
[09:30:15.718]             future::FutureResult(value = ...future.value$value, 
[09:30:15.718]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:15.718]                   ...future.rng), globalenv = if (FALSE) 
[09:30:15.718]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:15.718]                     ...future.globalenv.names))
[09:30:15.718]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:15.718]         }, condition = base::local({
[09:30:15.718]             c <- base::c
[09:30:15.718]             inherits <- base::inherits
[09:30:15.718]             invokeRestart <- base::invokeRestart
[09:30:15.718]             length <- base::length
[09:30:15.718]             list <- base::list
[09:30:15.718]             seq.int <- base::seq.int
[09:30:15.718]             signalCondition <- base::signalCondition
[09:30:15.718]             sys.calls <- base::sys.calls
[09:30:15.718]             `[[` <- base::`[[`
[09:30:15.718]             `+` <- base::`+`
[09:30:15.718]             `<<-` <- base::`<<-`
[09:30:15.718]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:15.718]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:15.718]                   3L)]
[09:30:15.718]             }
[09:30:15.718]             function(cond) {
[09:30:15.718]                 is_error <- inherits(cond, "error")
[09:30:15.718]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:15.718]                   NULL)
[09:30:15.718]                 if (is_error) {
[09:30:15.718]                   sessionInformation <- function() {
[09:30:15.718]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:15.718]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:15.718]                       search = base::search(), system = base::Sys.info())
[09:30:15.718]                   }
[09:30:15.718]                   ...future.conditions[[length(...future.conditions) + 
[09:30:15.718]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:15.718]                     cond$call), session = sessionInformation(), 
[09:30:15.718]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:15.718]                   signalCondition(cond)
[09:30:15.718]                 }
[09:30:15.718]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:15.718]                 "immediateCondition"))) {
[09:30:15.718]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:15.718]                   ...future.conditions[[length(...future.conditions) + 
[09:30:15.718]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:15.718]                   if (TRUE && !signal) {
[09:30:15.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:15.718]                     {
[09:30:15.718]                       inherits <- base::inherits
[09:30:15.718]                       invokeRestart <- base::invokeRestart
[09:30:15.718]                       is.null <- base::is.null
[09:30:15.718]                       muffled <- FALSE
[09:30:15.718]                       if (inherits(cond, "message")) {
[09:30:15.718]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:15.718]                         if (muffled) 
[09:30:15.718]                           invokeRestart("muffleMessage")
[09:30:15.718]                       }
[09:30:15.718]                       else if (inherits(cond, "warning")) {
[09:30:15.718]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:15.718]                         if (muffled) 
[09:30:15.718]                           invokeRestart("muffleWarning")
[09:30:15.718]                       }
[09:30:15.718]                       else if (inherits(cond, "condition")) {
[09:30:15.718]                         if (!is.null(pattern)) {
[09:30:15.718]                           computeRestarts <- base::computeRestarts
[09:30:15.718]                           grepl <- base::grepl
[09:30:15.718]                           restarts <- computeRestarts(cond)
[09:30:15.718]                           for (restart in restarts) {
[09:30:15.718]                             name <- restart$name
[09:30:15.718]                             if (is.null(name)) 
[09:30:15.718]                               next
[09:30:15.718]                             if (!grepl(pattern, name)) 
[09:30:15.718]                               next
[09:30:15.718]                             invokeRestart(restart)
[09:30:15.718]                             muffled <- TRUE
[09:30:15.718]                             break
[09:30:15.718]                           }
[09:30:15.718]                         }
[09:30:15.718]                       }
[09:30:15.718]                       invisible(muffled)
[09:30:15.718]                     }
[09:30:15.718]                     muffleCondition(cond, pattern = "^muffle")
[09:30:15.718]                   }
[09:30:15.718]                 }
[09:30:15.718]                 else {
[09:30:15.718]                   if (TRUE) {
[09:30:15.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:15.718]                     {
[09:30:15.718]                       inherits <- base::inherits
[09:30:15.718]                       invokeRestart <- base::invokeRestart
[09:30:15.718]                       is.null <- base::is.null
[09:30:15.718]                       muffled <- FALSE
[09:30:15.718]                       if (inherits(cond, "message")) {
[09:30:15.718]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:15.718]                         if (muffled) 
[09:30:15.718]                           invokeRestart("muffleMessage")
[09:30:15.718]                       }
[09:30:15.718]                       else if (inherits(cond, "warning")) {
[09:30:15.718]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:15.718]                         if (muffled) 
[09:30:15.718]                           invokeRestart("muffleWarning")
[09:30:15.718]                       }
[09:30:15.718]                       else if (inherits(cond, "condition")) {
[09:30:15.718]                         if (!is.null(pattern)) {
[09:30:15.718]                           computeRestarts <- base::computeRestarts
[09:30:15.718]                           grepl <- base::grepl
[09:30:15.718]                           restarts <- computeRestarts(cond)
[09:30:15.718]                           for (restart in restarts) {
[09:30:15.718]                             name <- restart$name
[09:30:15.718]                             if (is.null(name)) 
[09:30:15.718]                               next
[09:30:15.718]                             if (!grepl(pattern, name)) 
[09:30:15.718]                               next
[09:30:15.718]                             invokeRestart(restart)
[09:30:15.718]                             muffled <- TRUE
[09:30:15.718]                             break
[09:30:15.718]                           }
[09:30:15.718]                         }
[09:30:15.718]                       }
[09:30:15.718]                       invisible(muffled)
[09:30:15.718]                     }
[09:30:15.718]                     muffleCondition(cond, pattern = "^muffle")
[09:30:15.718]                   }
[09:30:15.718]                 }
[09:30:15.718]             }
[09:30:15.718]         }))
[09:30:15.718]     }, error = function(ex) {
[09:30:15.718]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:15.718]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:15.718]                 ...future.rng), started = ...future.startTime, 
[09:30:15.718]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:15.718]             version = "1.8"), class = "FutureResult")
[09:30:15.718]     }, finally = {
[09:30:15.718]         if (!identical(...future.workdir, getwd())) 
[09:30:15.718]             setwd(...future.workdir)
[09:30:15.718]         {
[09:30:15.718]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:15.718]                 ...future.oldOptions$nwarnings <- NULL
[09:30:15.718]             }
[09:30:15.718]             base::options(...future.oldOptions)
[09:30:15.718]             if (.Platform$OS.type == "windows") {
[09:30:15.718]                 old_names <- names(...future.oldEnvVars)
[09:30:15.718]                 envs <- base::Sys.getenv()
[09:30:15.718]                 names <- names(envs)
[09:30:15.718]                 common <- intersect(names, old_names)
[09:30:15.718]                 added <- setdiff(names, old_names)
[09:30:15.718]                 removed <- setdiff(old_names, names)
[09:30:15.718]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:15.718]                   envs[common]]
[09:30:15.718]                 NAMES <- toupper(changed)
[09:30:15.718]                 args <- list()
[09:30:15.718]                 for (kk in seq_along(NAMES)) {
[09:30:15.718]                   name <- changed[[kk]]
[09:30:15.718]                   NAME <- NAMES[[kk]]
[09:30:15.718]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:15.718]                     next
[09:30:15.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:15.718]                 }
[09:30:15.718]                 NAMES <- toupper(added)
[09:30:15.718]                 for (kk in seq_along(NAMES)) {
[09:30:15.718]                   name <- added[[kk]]
[09:30:15.718]                   NAME <- NAMES[[kk]]
[09:30:15.718]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:15.718]                     next
[09:30:15.718]                   args[[name]] <- ""
[09:30:15.718]                 }
[09:30:15.718]                 NAMES <- toupper(removed)
[09:30:15.718]                 for (kk in seq_along(NAMES)) {
[09:30:15.718]                   name <- removed[[kk]]
[09:30:15.718]                   NAME <- NAMES[[kk]]
[09:30:15.718]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:15.718]                     next
[09:30:15.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:15.718]                 }
[09:30:15.718]                 if (length(args) > 0) 
[09:30:15.718]                   base::do.call(base::Sys.setenv, args = args)
[09:30:15.718]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:15.718]             }
[09:30:15.718]             else {
[09:30:15.718]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:15.718]             }
[09:30:15.718]             {
[09:30:15.718]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:15.718]                   0L) {
[09:30:15.718]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:15.718]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:15.718]                   base::options(opts)
[09:30:15.718]                 }
[09:30:15.718]                 {
[09:30:15.718]                   {
[09:30:15.718]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:15.718]                     NULL
[09:30:15.718]                   }
[09:30:15.718]                   options(future.plan = NULL)
[09:30:15.718]                   if (is.na(NA_character_)) 
[09:30:15.718]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:15.718]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:15.718]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:15.718]                     .init = FALSE)
[09:30:15.718]                 }
[09:30:15.718]             }
[09:30:15.718]         }
[09:30:15.718]     })
[09:30:15.718]     if (TRUE) {
[09:30:15.718]         base::sink(type = "output", split = FALSE)
[09:30:15.718]         if (TRUE) {
[09:30:15.718]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:15.718]         }
[09:30:15.718]         else {
[09:30:15.718]             ...future.result["stdout"] <- base::list(NULL)
[09:30:15.718]         }
[09:30:15.718]         base::close(...future.stdout)
[09:30:15.718]         ...future.stdout <- NULL
[09:30:15.718]     }
[09:30:15.718]     ...future.result$conditions <- ...future.conditions
[09:30:15.718]     ...future.result$finished <- base::Sys.time()
[09:30:15.718]     ...future.result
[09:30:15.718] }
[09:30:15.721] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[09:30:15.721] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[09:30:15.721] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[09:30:15.721] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:30:15.721] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:30:15.722] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[09:30:15.722] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[09:30:15.722] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:30:15.722] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:30:15.722] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:30:15.723] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:30:15.723] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[09:30:15.723] MultisessionFuture started
[09:30:15.723] - Launch lazy future ... done
[09:30:15.723] run() for ‘MultisessionFuture’ ... done
[09:30:15.724] Created future:
[09:30:15.724] MultisessionFuture:
[09:30:15.724] Label: ‘future_mapply-1’
[09:30:15.724] Expression:
[09:30:15.724] {
[09:30:15.724]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:15.724]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:15.724]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:15.724]         on.exit(options(oopts), add = TRUE)
[09:30:15.724]     }
[09:30:15.724]     {
[09:30:15.724]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:15.724]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:30:15.724]         do.call(mapply, args = args)
[09:30:15.724]     }
[09:30:15.724] }
[09:30:15.724] Lazy evaluation: FALSE
[09:30:15.724] Asynchronous evaluation: TRUE
[09:30:15.724] Local evaluation: TRUE
[09:30:15.724] Environment: R_GlobalEnv
[09:30:15.724] Capture standard output: TRUE
[09:30:15.724] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:15.724] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:15.724] Packages: <none>
[09:30:15.724] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:15.724] Resolved: FALSE
[09:30:15.724] Value: <not collected>
[09:30:15.724] Conditions captured: <none>
[09:30:15.724] Early signaling: FALSE
[09:30:15.724] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:15.724] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:15.735] Chunk #1 of 2 ... DONE
[09:30:15.735] Chunk #2 of 2 ...
[09:30:15.735]  - Finding globals in '...' for chunk #2 ...
[09:30:15.735] getGlobalsAndPackages() ...
[09:30:15.735] Searching for globals...
[09:30:15.736] 
[09:30:15.736] Searching for globals ... DONE
[09:30:15.736] - globals: [0] <none>
[09:30:15.736] getGlobalsAndPackages() ... DONE
[09:30:15.736]    + additional globals found: [n=0] 
[09:30:15.736]    + additional namespaces needed: [n=0] 
[09:30:15.736]  - Finding globals in '...' for chunk #2 ... DONE
[09:30:15.737]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:15.737]  - seeds: <none>
[09:30:15.737]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:15.737] getGlobalsAndPackages() ...
[09:30:15.737] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:15.737] Resolving globals: FALSE
[09:30:15.737] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[09:30:15.738] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:30:15.738] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:15.738] 
[09:30:15.738] getGlobalsAndPackages() ... DONE
[09:30:15.738] run() for ‘Future’ ...
[09:30:15.738] - state: ‘created’
[09:30:15.739] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:30:15.753] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:15.753] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:30:15.753]   - Field: ‘node’
[09:30:15.753]   - Field: ‘label’
[09:30:15.754]   - Field: ‘local’
[09:30:15.754]   - Field: ‘owner’
[09:30:15.754]   - Field: ‘envir’
[09:30:15.754]   - Field: ‘workers’
[09:30:15.754]   - Field: ‘packages’
[09:30:15.754]   - Field: ‘gc’
[09:30:15.754]   - Field: ‘conditions’
[09:30:15.754]   - Field: ‘persistent’
[09:30:15.754]   - Field: ‘expr’
[09:30:15.754]   - Field: ‘uuid’
[09:30:15.754]   - Field: ‘seed’
[09:30:15.755]   - Field: ‘version’
[09:30:15.756]   - Field: ‘result’
[09:30:15.757]   - Field: ‘asynchronous’
[09:30:15.757]   - Field: ‘calls’
[09:30:15.757]   - Field: ‘globals’
[09:30:15.757]   - Field: ‘stdout’
[09:30:15.757]   - Field: ‘earlySignal’
[09:30:15.757]   - Field: ‘lazy’
[09:30:15.757]   - Field: ‘state’
[09:30:15.757] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:30:15.757] - Launch lazy future ...
[09:30:15.758] Packages needed by the future expression (n = 0): <none>
[09:30:15.758] Packages needed by future strategies (n = 0): <none>
[09:30:15.758] {
[09:30:15.758]     {
[09:30:15.758]         {
[09:30:15.758]             ...future.startTime <- base::Sys.time()
[09:30:15.758]             {
[09:30:15.758]                 {
[09:30:15.758]                   {
[09:30:15.758]                     {
[09:30:15.758]                       base::local({
[09:30:15.758]                         has_future <- base::requireNamespace("future", 
[09:30:15.758]                           quietly = TRUE)
[09:30:15.758]                         if (has_future) {
[09:30:15.758]                           ns <- base::getNamespace("future")
[09:30:15.758]                           version <- ns[[".package"]][["version"]]
[09:30:15.758]                           if (is.null(version)) 
[09:30:15.758]                             version <- utils::packageVersion("future")
[09:30:15.758]                         }
[09:30:15.758]                         else {
[09:30:15.758]                           version <- NULL
[09:30:15.758]                         }
[09:30:15.758]                         if (!has_future || version < "1.8.0") {
[09:30:15.758]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:15.758]                             "", base::R.version$version.string), 
[09:30:15.758]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:15.758]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:15.758]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:15.758]                               "release", "version")], collapse = " "), 
[09:30:15.758]                             hostname = base::Sys.info()[["nodename"]])
[09:30:15.758]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:15.758]                             info)
[09:30:15.758]                           info <- base::paste(info, collapse = "; ")
[09:30:15.758]                           if (!has_future) {
[09:30:15.758]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:15.758]                               info)
[09:30:15.758]                           }
[09:30:15.758]                           else {
[09:30:15.758]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:15.758]                               info, version)
[09:30:15.758]                           }
[09:30:15.758]                           base::stop(msg)
[09:30:15.758]                         }
[09:30:15.758]                       })
[09:30:15.758]                     }
[09:30:15.758]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:15.758]                     base::options(mc.cores = 1L)
[09:30:15.758]                   }
[09:30:15.758]                   ...future.strategy.old <- future::plan("list")
[09:30:15.758]                   options(future.plan = NULL)
[09:30:15.758]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:15.758]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:15.758]                 }
[09:30:15.758]                 ...future.workdir <- getwd()
[09:30:15.758]             }
[09:30:15.758]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:15.758]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:15.758]         }
[09:30:15.758]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:15.758]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:15.758]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:15.758]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:15.758]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:15.758]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:15.758]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:15.758]             base::names(...future.oldOptions))
[09:30:15.758]     }
[09:30:15.758]     if (FALSE) {
[09:30:15.758]     }
[09:30:15.758]     else {
[09:30:15.758]         if (TRUE) {
[09:30:15.758]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:15.758]                 open = "w")
[09:30:15.758]         }
[09:30:15.758]         else {
[09:30:15.758]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:15.758]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:15.758]         }
[09:30:15.758]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:15.758]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:15.758]             base::sink(type = "output", split = FALSE)
[09:30:15.758]             base::close(...future.stdout)
[09:30:15.758]         }, add = TRUE)
[09:30:15.758]     }
[09:30:15.758]     ...future.frame <- base::sys.nframe()
[09:30:15.758]     ...future.conditions <- base::list()
[09:30:15.758]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:15.758]     if (FALSE) {
[09:30:15.758]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:15.758]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:15.758]     }
[09:30:15.758]     ...future.result <- base::tryCatch({
[09:30:15.758]         base::withCallingHandlers({
[09:30:15.758]             ...future.value <- base::withVisible(base::local({
[09:30:15.758]                 ...future.makeSendCondition <- base::local({
[09:30:15.758]                   sendCondition <- NULL
[09:30:15.758]                   function(frame = 1L) {
[09:30:15.758]                     if (is.function(sendCondition)) 
[09:30:15.758]                       return(sendCondition)
[09:30:15.758]                     ns <- getNamespace("parallel")
[09:30:15.758]                     if (exists("sendData", mode = "function", 
[09:30:15.758]                       envir = ns)) {
[09:30:15.758]                       parallel_sendData <- get("sendData", mode = "function", 
[09:30:15.758]                         envir = ns)
[09:30:15.758]                       envir <- sys.frame(frame)
[09:30:15.758]                       master <- NULL
[09:30:15.758]                       while (!identical(envir, .GlobalEnv) && 
[09:30:15.758]                         !identical(envir, emptyenv())) {
[09:30:15.758]                         if (exists("master", mode = "list", envir = envir, 
[09:30:15.758]                           inherits = FALSE)) {
[09:30:15.758]                           master <- get("master", mode = "list", 
[09:30:15.758]                             envir = envir, inherits = FALSE)
[09:30:15.758]                           if (inherits(master, c("SOCKnode", 
[09:30:15.758]                             "SOCK0node"))) {
[09:30:15.758]                             sendCondition <<- function(cond) {
[09:30:15.758]                               data <- list(type = "VALUE", value = cond, 
[09:30:15.758]                                 success = TRUE)
[09:30:15.758]                               parallel_sendData(master, data)
[09:30:15.758]                             }
[09:30:15.758]                             return(sendCondition)
[09:30:15.758]                           }
[09:30:15.758]                         }
[09:30:15.758]                         frame <- frame + 1L
[09:30:15.758]                         envir <- sys.frame(frame)
[09:30:15.758]                       }
[09:30:15.758]                     }
[09:30:15.758]                     sendCondition <<- function(cond) NULL
[09:30:15.758]                   }
[09:30:15.758]                 })
[09:30:15.758]                 withCallingHandlers({
[09:30:15.758]                   {
[09:30:15.758]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:15.758]                     if (!identical(...future.globals.maxSize.org, 
[09:30:15.758]                       ...future.globals.maxSize)) {
[09:30:15.758]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:15.758]                       on.exit(options(oopts), add = TRUE)
[09:30:15.758]                     }
[09:30:15.758]                     {
[09:30:15.758]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:15.758]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:30:15.758]                         USE.NAMES = FALSE)
[09:30:15.758]                       do.call(mapply, args = args)
[09:30:15.758]                     }
[09:30:15.758]                   }
[09:30:15.758]                 }, immediateCondition = function(cond) {
[09:30:15.758]                   sendCondition <- ...future.makeSendCondition()
[09:30:15.758]                   sendCondition(cond)
[09:30:15.758]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:15.758]                   {
[09:30:15.758]                     inherits <- base::inherits
[09:30:15.758]                     invokeRestart <- base::invokeRestart
[09:30:15.758]                     is.null <- base::is.null
[09:30:15.758]                     muffled <- FALSE
[09:30:15.758]                     if (inherits(cond, "message")) {
[09:30:15.758]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:15.758]                       if (muffled) 
[09:30:15.758]                         invokeRestart("muffleMessage")
[09:30:15.758]                     }
[09:30:15.758]                     else if (inherits(cond, "warning")) {
[09:30:15.758]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:15.758]                       if (muffled) 
[09:30:15.758]                         invokeRestart("muffleWarning")
[09:30:15.758]                     }
[09:30:15.758]                     else if (inherits(cond, "condition")) {
[09:30:15.758]                       if (!is.null(pattern)) {
[09:30:15.758]                         computeRestarts <- base::computeRestarts
[09:30:15.758]                         grepl <- base::grepl
[09:30:15.758]                         restarts <- computeRestarts(cond)
[09:30:15.758]                         for (restart in restarts) {
[09:30:15.758]                           name <- restart$name
[09:30:15.758]                           if (is.null(name)) 
[09:30:15.758]                             next
[09:30:15.758]                           if (!grepl(pattern, name)) 
[09:30:15.758]                             next
[09:30:15.758]                           invokeRestart(restart)
[09:30:15.758]                           muffled <- TRUE
[09:30:15.758]                           break
[09:30:15.758]                         }
[09:30:15.758]                       }
[09:30:15.758]                     }
[09:30:15.758]                     invisible(muffled)
[09:30:15.758]                   }
[09:30:15.758]                   muffleCondition(cond)
[09:30:15.758]                 })
[09:30:15.758]             }))
[09:30:15.758]             future::FutureResult(value = ...future.value$value, 
[09:30:15.758]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:15.758]                   ...future.rng), globalenv = if (FALSE) 
[09:30:15.758]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:15.758]                     ...future.globalenv.names))
[09:30:15.758]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:15.758]         }, condition = base::local({
[09:30:15.758]             c <- base::c
[09:30:15.758]             inherits <- base::inherits
[09:30:15.758]             invokeRestart <- base::invokeRestart
[09:30:15.758]             length <- base::length
[09:30:15.758]             list <- base::list
[09:30:15.758]             seq.int <- base::seq.int
[09:30:15.758]             signalCondition <- base::signalCondition
[09:30:15.758]             sys.calls <- base::sys.calls
[09:30:15.758]             `[[` <- base::`[[`
[09:30:15.758]             `+` <- base::`+`
[09:30:15.758]             `<<-` <- base::`<<-`
[09:30:15.758]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:15.758]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:15.758]                   3L)]
[09:30:15.758]             }
[09:30:15.758]             function(cond) {
[09:30:15.758]                 is_error <- inherits(cond, "error")
[09:30:15.758]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:15.758]                   NULL)
[09:30:15.758]                 if (is_error) {
[09:30:15.758]                   sessionInformation <- function() {
[09:30:15.758]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:15.758]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:15.758]                       search = base::search(), system = base::Sys.info())
[09:30:15.758]                   }
[09:30:15.758]                   ...future.conditions[[length(...future.conditions) + 
[09:30:15.758]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:15.758]                     cond$call), session = sessionInformation(), 
[09:30:15.758]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:15.758]                   signalCondition(cond)
[09:30:15.758]                 }
[09:30:15.758]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:15.758]                 "immediateCondition"))) {
[09:30:15.758]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:15.758]                   ...future.conditions[[length(...future.conditions) + 
[09:30:15.758]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:15.758]                   if (TRUE && !signal) {
[09:30:15.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:15.758]                     {
[09:30:15.758]                       inherits <- base::inherits
[09:30:15.758]                       invokeRestart <- base::invokeRestart
[09:30:15.758]                       is.null <- base::is.null
[09:30:15.758]                       muffled <- FALSE
[09:30:15.758]                       if (inherits(cond, "message")) {
[09:30:15.758]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:15.758]                         if (muffled) 
[09:30:15.758]                           invokeRestart("muffleMessage")
[09:30:15.758]                       }
[09:30:15.758]                       else if (inherits(cond, "warning")) {
[09:30:15.758]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:15.758]                         if (muffled) 
[09:30:15.758]                           invokeRestart("muffleWarning")
[09:30:15.758]                       }
[09:30:15.758]                       else if (inherits(cond, "condition")) {
[09:30:15.758]                         if (!is.null(pattern)) {
[09:30:15.758]                           computeRestarts <- base::computeRestarts
[09:30:15.758]                           grepl <- base::grepl
[09:30:15.758]                           restarts <- computeRestarts(cond)
[09:30:15.758]                           for (restart in restarts) {
[09:30:15.758]                             name <- restart$name
[09:30:15.758]                             if (is.null(name)) 
[09:30:15.758]                               next
[09:30:15.758]                             if (!grepl(pattern, name)) 
[09:30:15.758]                               next
[09:30:15.758]                             invokeRestart(restart)
[09:30:15.758]                             muffled <- TRUE
[09:30:15.758]                             break
[09:30:15.758]                           }
[09:30:15.758]                         }
[09:30:15.758]                       }
[09:30:15.758]                       invisible(muffled)
[09:30:15.758]                     }
[09:30:15.758]                     muffleCondition(cond, pattern = "^muffle")
[09:30:15.758]                   }
[09:30:15.758]                 }
[09:30:15.758]                 else {
[09:30:15.758]                   if (TRUE) {
[09:30:15.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:15.758]                     {
[09:30:15.758]                       inherits <- base::inherits
[09:30:15.758]                       invokeRestart <- base::invokeRestart
[09:30:15.758]                       is.null <- base::is.null
[09:30:15.758]                       muffled <- FALSE
[09:30:15.758]                       if (inherits(cond, "message")) {
[09:30:15.758]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:15.758]                         if (muffled) 
[09:30:15.758]                           invokeRestart("muffleMessage")
[09:30:15.758]                       }
[09:30:15.758]                       else if (inherits(cond, "warning")) {
[09:30:15.758]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:15.758]                         if (muffled) 
[09:30:15.758]                           invokeRestart("muffleWarning")
[09:30:15.758]                       }
[09:30:15.758]                       else if (inherits(cond, "condition")) {
[09:30:15.758]                         if (!is.null(pattern)) {
[09:30:15.758]                           computeRestarts <- base::computeRestarts
[09:30:15.758]                           grepl <- base::grepl
[09:30:15.758]                           restarts <- computeRestarts(cond)
[09:30:15.758]                           for (restart in restarts) {
[09:30:15.758]                             name <- restart$name
[09:30:15.758]                             if (is.null(name)) 
[09:30:15.758]                               next
[09:30:15.758]                             if (!grepl(pattern, name)) 
[09:30:15.758]                               next
[09:30:15.758]                             invokeRestart(restart)
[09:30:15.758]                             muffled <- TRUE
[09:30:15.758]                             break
[09:30:15.758]                           }
[09:30:15.758]                         }
[09:30:15.758]                       }
[09:30:15.758]                       invisible(muffled)
[09:30:15.758]                     }
[09:30:15.758]                     muffleCondition(cond, pattern = "^muffle")
[09:30:15.758]                   }
[09:30:15.758]                 }
[09:30:15.758]             }
[09:30:15.758]         }))
[09:30:15.758]     }, error = function(ex) {
[09:30:15.758]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:15.758]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:15.758]                 ...future.rng), started = ...future.startTime, 
[09:30:15.758]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:15.758]             version = "1.8"), class = "FutureResult")
[09:30:15.758]     }, finally = {
[09:30:15.758]         if (!identical(...future.workdir, getwd())) 
[09:30:15.758]             setwd(...future.workdir)
[09:30:15.758]         {
[09:30:15.758]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:15.758]                 ...future.oldOptions$nwarnings <- NULL
[09:30:15.758]             }
[09:30:15.758]             base::options(...future.oldOptions)
[09:30:15.758]             if (.Platform$OS.type == "windows") {
[09:30:15.758]                 old_names <- names(...future.oldEnvVars)
[09:30:15.758]                 envs <- base::Sys.getenv()
[09:30:15.758]                 names <- names(envs)
[09:30:15.758]                 common <- intersect(names, old_names)
[09:30:15.758]                 added <- setdiff(names, old_names)
[09:30:15.758]                 removed <- setdiff(old_names, names)
[09:30:15.758]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:15.758]                   envs[common]]
[09:30:15.758]                 NAMES <- toupper(changed)
[09:30:15.758]                 args <- list()
[09:30:15.758]                 for (kk in seq_along(NAMES)) {
[09:30:15.758]                   name <- changed[[kk]]
[09:30:15.758]                   NAME <- NAMES[[kk]]
[09:30:15.758]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:15.758]                     next
[09:30:15.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:15.758]                 }
[09:30:15.758]                 NAMES <- toupper(added)
[09:30:15.758]                 for (kk in seq_along(NAMES)) {
[09:30:15.758]                   name <- added[[kk]]
[09:30:15.758]                   NAME <- NAMES[[kk]]
[09:30:15.758]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:15.758]                     next
[09:30:15.758]                   args[[name]] <- ""
[09:30:15.758]                 }
[09:30:15.758]                 NAMES <- toupper(removed)
[09:30:15.758]                 for (kk in seq_along(NAMES)) {
[09:30:15.758]                   name <- removed[[kk]]
[09:30:15.758]                   NAME <- NAMES[[kk]]
[09:30:15.758]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:15.758]                     next
[09:30:15.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:15.758]                 }
[09:30:15.758]                 if (length(args) > 0) 
[09:30:15.758]                   base::do.call(base::Sys.setenv, args = args)
[09:30:15.758]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:15.758]             }
[09:30:15.758]             else {
[09:30:15.758]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:15.758]             }
[09:30:15.758]             {
[09:30:15.758]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:15.758]                   0L) {
[09:30:15.758]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:15.758]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:15.758]                   base::options(opts)
[09:30:15.758]                 }
[09:30:15.758]                 {
[09:30:15.758]                   {
[09:30:15.758]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:15.758]                     NULL
[09:30:15.758]                   }
[09:30:15.758]                   options(future.plan = NULL)
[09:30:15.758]                   if (is.na(NA_character_)) 
[09:30:15.758]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:15.758]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:15.758]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:15.758]                     .init = FALSE)
[09:30:15.758]                 }
[09:30:15.758]             }
[09:30:15.758]         }
[09:30:15.758]     })
[09:30:15.758]     if (TRUE) {
[09:30:15.758]         base::sink(type = "output", split = FALSE)
[09:30:15.758]         if (TRUE) {
[09:30:15.758]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:15.758]         }
[09:30:15.758]         else {
[09:30:15.758]             ...future.result["stdout"] <- base::list(NULL)
[09:30:15.758]         }
[09:30:15.758]         base::close(...future.stdout)
[09:30:15.758]         ...future.stdout <- NULL
[09:30:15.758]     }
[09:30:15.758]     ...future.result$conditions <- ...future.conditions
[09:30:15.758]     ...future.result$finished <- base::Sys.time()
[09:30:15.758]     ...future.result
[09:30:15.758] }
[09:30:15.761] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[09:30:15.761] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[09:30:15.761] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[09:30:15.761] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[09:30:15.761] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[09:30:15.762] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[09:30:15.762] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[09:30:15.762] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:30:15.762] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:30:15.762] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:30:15.763] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:30:15.763] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[09:30:15.763] MultisessionFuture started
[09:30:15.763] - Launch lazy future ... done
[09:30:15.763] run() for ‘MultisessionFuture’ ... done
[09:30:15.764] Created future:
[09:30:15.764] MultisessionFuture:
[09:30:15.764] Label: ‘future_mapply-2’
[09:30:15.764] Expression:
[09:30:15.764] {
[09:30:15.764]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:15.764]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:15.764]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:15.764]         on.exit(options(oopts), add = TRUE)
[09:30:15.764]     }
[09:30:15.764]     {
[09:30:15.764]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:15.764]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:30:15.764]         do.call(mapply, args = args)
[09:30:15.764]     }
[09:30:15.764] }
[09:30:15.764] Lazy evaluation: FALSE
[09:30:15.764] Asynchronous evaluation: TRUE
[09:30:15.764] Local evaluation: TRUE
[09:30:15.764] Environment: R_GlobalEnv
[09:30:15.764] Capture standard output: TRUE
[09:30:15.764] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:15.764] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:15.764] Packages: <none>
[09:30:15.764] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:15.764] Resolved: FALSE
[09:30:15.764] Value: <not collected>
[09:30:15.764] Conditions captured: <none>
[09:30:15.764] Early signaling: FALSE
[09:30:15.764] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:15.764] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:15.775] Chunk #2 of 2 ... DONE
[09:30:15.775] Launching 2 futures (chunks) ... DONE
[09:30:15.775] Resolving 2 futures (chunks) ...
[09:30:15.775] resolve() on list ...
[09:30:15.775]  recursive: 0
[09:30:15.776]  length: 2
[09:30:15.776] 
[09:30:15.818] receiveMessageFromWorker() for ClusterFuture ...
[09:30:15.818] - Validating connection of MultisessionFuture
[09:30:15.818] - received message: FutureResult
[09:30:15.818] - Received FutureResult
[09:30:15.818] - Erased future from FutureRegistry
[09:30:15.818] result() for ClusterFuture ...
[09:30:15.818] - result already collected: FutureResult
[09:30:15.818] result() for ClusterFuture ... done
[09:30:15.818] receiveMessageFromWorker() for ClusterFuture ... done
[09:30:15.818] Future #2
[09:30:15.819] result() for ClusterFuture ...
[09:30:15.819] - result already collected: FutureResult
[09:30:15.819] result() for ClusterFuture ... done
[09:30:15.819] result() for ClusterFuture ...
[09:30:15.819] - result already collected: FutureResult
[09:30:15.819] result() for ClusterFuture ... done
[09:30:15.819] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:30:15.819] - nx: 2
[09:30:15.819] - relay: TRUE
[09:30:15.819] - stdout: TRUE
[09:30:15.819] - signal: TRUE
[09:30:15.820] - resignal: FALSE
[09:30:15.820] - force: TRUE
[09:30:15.820] - relayed: [n=2] FALSE, FALSE
[09:30:15.820] - queued futures: [n=2] FALSE, FALSE
[09:30:15.820]  - until=1
[09:30:15.820]  - relaying element #1
[09:30:15.820] - relayed: [n=2] FALSE, FALSE
[09:30:15.820] - queued futures: [n=2] FALSE, TRUE
[09:30:15.820] signalConditionsASAP(NULL, pos=2) ... done
[09:30:15.820]  length: 1 (resolved future 2)
[09:30:16.266] receiveMessageFromWorker() for ClusterFuture ...
[09:30:16.266] - Validating connection of MultisessionFuture
[09:30:16.266] - received message: FutureResult
[09:30:16.267] - Received FutureResult
[09:30:16.267] - Erased future from FutureRegistry
[09:30:16.267] result() for ClusterFuture ...
[09:30:16.267] - result already collected: FutureResult
[09:30:16.267] result() for ClusterFuture ... done
[09:30:16.267] receiveMessageFromWorker() for ClusterFuture ... done
[09:30:16.267] Future #1
[09:30:16.267] result() for ClusterFuture ...
[09:30:16.267] - result already collected: FutureResult
[09:30:16.268] result() for ClusterFuture ... done
[09:30:16.268] result() for ClusterFuture ...
[09:30:16.268] - result already collected: FutureResult
[09:30:16.268] result() for ClusterFuture ... done
[09:30:16.268] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:30:16.268] - nx: 2
[09:30:16.268] - relay: TRUE
[09:30:16.268] - stdout: TRUE
[09:30:16.268] - signal: TRUE
[09:30:16.268] - resignal: FALSE
[09:30:16.268] - force: TRUE
[09:30:16.269] - relayed: [n=2] FALSE, FALSE
[09:30:16.269] - queued futures: [n=2] FALSE, TRUE
[09:30:16.269]  - until=1
[09:30:16.269]  - relaying element #1
[09:30:16.269] result() for ClusterFuture ...
[09:30:16.269] - result already collected: FutureResult
[09:30:16.269] result() for ClusterFuture ... done
[09:30:16.269] result() for ClusterFuture ...
[09:30:16.269] - result already collected: FutureResult
[09:30:16.269] result() for ClusterFuture ... done
[09:30:16.269] result() for ClusterFuture ...
[09:30:16.270] - result already collected: FutureResult
[09:30:16.270] result() for ClusterFuture ... done
[09:30:16.270] result() for ClusterFuture ...
[09:30:16.270] - result already collected: FutureResult
[09:30:16.270] result() for ClusterFuture ... done
[09:30:16.270] - relayed: [n=2] TRUE, FALSE
[09:30:16.270] - queued futures: [n=2] TRUE, TRUE
[09:30:16.270] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:30:16.270]  length: 0 (resolved future 1)
[09:30:16.270] Relaying remaining futures
[09:30:16.270] signalConditionsASAP(NULL, pos=0) ...
[09:30:16.270] - nx: 2
[09:30:16.271] - relay: TRUE
[09:30:16.271] - stdout: TRUE
[09:30:16.271] - signal: TRUE
[09:30:16.271] - resignal: FALSE
[09:30:16.271] - force: TRUE
[09:30:16.271] - relayed: [n=2] TRUE, FALSE
[09:30:16.271] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:30:16.271]  - relaying element #2
[09:30:16.271] result() for ClusterFuture ...
[09:30:16.271] - result already collected: FutureResult
[09:30:16.271] result() for ClusterFuture ... done
[09:30:16.272] result() for ClusterFuture ...
[09:30:16.272] - result already collected: FutureResult
[09:30:16.272] result() for ClusterFuture ... done
[09:30:16.272] result() for ClusterFuture ...
[09:30:16.272] - result already collected: FutureResult
[09:30:16.272] result() for ClusterFuture ... done
[09:30:16.272] result() for ClusterFuture ...
[09:30:16.272] - result already collected: FutureResult
[09:30:16.272] result() for ClusterFuture ... done
[09:30:16.272] - relayed: [n=2] TRUE, TRUE
[09:30:16.272] - queued futures: [n=2] TRUE, TRUE
[09:30:16.273] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[09:30:16.273] resolve() on list ... DONE
[09:30:16.273] result() for ClusterFuture ...
[09:30:16.273] - result already collected: FutureResult
[09:30:16.273] result() for ClusterFuture ... done
[09:30:16.273] result() for ClusterFuture ...
[09:30:16.273] - result already collected: FutureResult
[09:30:16.273] result() for ClusterFuture ... done
[09:30:16.273] result() for ClusterFuture ...
[09:30:16.273] - result already collected: FutureResult
[09:30:16.273] result() for ClusterFuture ... done
[09:30:16.274] result() for ClusterFuture ...
[09:30:16.274] - result already collected: FutureResult
[09:30:16.274] result() for ClusterFuture ... done
[09:30:16.274]  - Number of value chunks collected: 2
[09:30:16.274] Resolving 2 futures (chunks) ... DONE
[09:30:16.274] Reducing values from 2 chunks ...
[09:30:16.274]  - Number of values collected after concatenation: 2
[09:30:16.274]  - Number of values expected: 2
[09:30:16.274] Reducing values from 2 chunks ... DONE
[09:30:16.274] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[09:30:16.275] future_mapply() ...
[09:30:16.279] Number of chunks: 2
[09:30:16.279] getGlobalsAndPackagesXApply() ...
[09:30:16.279]  - future.globals: TRUE
[09:30:16.279] getGlobalsAndPackages() ...
[09:30:16.279] Searching for globals...
[09:30:16.281] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[09:30:16.281] Searching for globals ... DONE
[09:30:16.281] Resolving globals: FALSE
[09:30:16.281] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[09:30:16.282] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[09:30:16.282] - globals: [1] ‘FUN’
[09:30:16.282] 
[09:30:16.282] getGlobalsAndPackages() ... DONE
[09:30:16.282]  - globals found/used: [n=1] ‘FUN’
[09:30:16.282]  - needed namespaces: [n=0] 
[09:30:16.282] Finding globals ... DONE
[09:30:16.282] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:30:16.282] List of 2
[09:30:16.282]  $ ...future.FUN:function (x, y)  
[09:30:16.282]  $ MoreArgs     : NULL
[09:30:16.282]  - attr(*, "where")=List of 2
[09:30:16.282]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:30:16.282]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:30:16.282]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:30:16.282]  - attr(*, "resolved")= logi FALSE
[09:30:16.282]  - attr(*, "total_size")= num NA
[09:30:16.285] Packages to be attached in all futures: [n=0] 
[09:30:16.285] getGlobalsAndPackagesXApply() ... DONE
[09:30:16.285] Number of futures (= number of chunks): 2
[09:30:16.285] Launching 2 futures (chunks) ...
[09:30:16.285] Chunk #1 of 2 ...
[09:30:16.285]  - Finding globals in '...' for chunk #1 ...
[09:30:16.286] getGlobalsAndPackages() ...
[09:30:16.286] Searching for globals...
[09:30:16.286] 
[09:30:16.286] Searching for globals ... DONE
[09:30:16.286] - globals: [0] <none>
[09:30:16.286] getGlobalsAndPackages() ... DONE
[09:30:16.286]    + additional globals found: [n=0] 
[09:30:16.286]    + additional namespaces needed: [n=0] 
[09:30:16.286]  - Finding globals in '...' for chunk #1 ... DONE
[09:30:16.287]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:16.287]  - seeds: <none>
[09:30:16.287]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:16.287] getGlobalsAndPackages() ...
[09:30:16.287] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:16.287] Resolving globals: FALSE
[09:30:16.287] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[09:30:16.288] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:30:16.288] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:16.288] 
[09:30:16.288] getGlobalsAndPackages() ... DONE
[09:30:16.288] run() for ‘Future’ ...
[09:30:16.289] - state: ‘created’
[09:30:16.289] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:30:16.302] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:16.302] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:30:16.302]   - Field: ‘node’
[09:30:16.302]   - Field: ‘label’
[09:30:16.303]   - Field: ‘local’
[09:30:16.303]   - Field: ‘owner’
[09:30:16.303]   - Field: ‘envir’
[09:30:16.303]   - Field: ‘workers’
[09:30:16.303]   - Field: ‘packages’
[09:30:16.303]   - Field: ‘gc’
[09:30:16.303]   - Field: ‘conditions’
[09:30:16.303]   - Field: ‘persistent’
[09:30:16.303]   - Field: ‘expr’
[09:30:16.303]   - Field: ‘uuid’
[09:30:16.303]   - Field: ‘seed’
[09:30:16.303]   - Field: ‘version’
[09:30:16.304]   - Field: ‘result’
[09:30:16.304]   - Field: ‘asynchronous’
[09:30:16.304]   - Field: ‘calls’
[09:30:16.304]   - Field: ‘globals’
[09:30:16.304]   - Field: ‘stdout’
[09:30:16.304]   - Field: ‘earlySignal’
[09:30:16.304]   - Field: ‘lazy’
[09:30:16.304]   - Field: ‘state’
[09:30:16.304] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:30:16.304] - Launch lazy future ...
[09:30:16.305] Packages needed by the future expression (n = 0): <none>
[09:30:16.305] Packages needed by future strategies (n = 0): <none>
[09:30:16.305] {
[09:30:16.305]     {
[09:30:16.305]         {
[09:30:16.305]             ...future.startTime <- base::Sys.time()
[09:30:16.305]             {
[09:30:16.305]                 {
[09:30:16.305]                   {
[09:30:16.305]                     {
[09:30:16.305]                       base::local({
[09:30:16.305]                         has_future <- base::requireNamespace("future", 
[09:30:16.305]                           quietly = TRUE)
[09:30:16.305]                         if (has_future) {
[09:30:16.305]                           ns <- base::getNamespace("future")
[09:30:16.305]                           version <- ns[[".package"]][["version"]]
[09:30:16.305]                           if (is.null(version)) 
[09:30:16.305]                             version <- utils::packageVersion("future")
[09:30:16.305]                         }
[09:30:16.305]                         else {
[09:30:16.305]                           version <- NULL
[09:30:16.305]                         }
[09:30:16.305]                         if (!has_future || version < "1.8.0") {
[09:30:16.305]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:16.305]                             "", base::R.version$version.string), 
[09:30:16.305]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:16.305]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:16.305]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:16.305]                               "release", "version")], collapse = " "), 
[09:30:16.305]                             hostname = base::Sys.info()[["nodename"]])
[09:30:16.305]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:16.305]                             info)
[09:30:16.305]                           info <- base::paste(info, collapse = "; ")
[09:30:16.305]                           if (!has_future) {
[09:30:16.305]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:16.305]                               info)
[09:30:16.305]                           }
[09:30:16.305]                           else {
[09:30:16.305]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:16.305]                               info, version)
[09:30:16.305]                           }
[09:30:16.305]                           base::stop(msg)
[09:30:16.305]                         }
[09:30:16.305]                       })
[09:30:16.305]                     }
[09:30:16.305]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:16.305]                     base::options(mc.cores = 1L)
[09:30:16.305]                   }
[09:30:16.305]                   ...future.strategy.old <- future::plan("list")
[09:30:16.305]                   options(future.plan = NULL)
[09:30:16.305]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:16.305]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:16.305]                 }
[09:30:16.305]                 ...future.workdir <- getwd()
[09:30:16.305]             }
[09:30:16.305]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:16.305]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:16.305]         }
[09:30:16.305]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:16.305]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:16.305]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:16.305]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:16.305]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:16.305]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:16.305]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:16.305]             base::names(...future.oldOptions))
[09:30:16.305]     }
[09:30:16.305]     if (TRUE) {
[09:30:16.305]     }
[09:30:16.305]     else {
[09:30:16.305]         if (NA) {
[09:30:16.305]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:16.305]                 open = "w")
[09:30:16.305]         }
[09:30:16.305]         else {
[09:30:16.305]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:16.305]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:16.305]         }
[09:30:16.305]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:16.305]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:16.305]             base::sink(type = "output", split = FALSE)
[09:30:16.305]             base::close(...future.stdout)
[09:30:16.305]         }, add = TRUE)
[09:30:16.305]     }
[09:30:16.305]     ...future.frame <- base::sys.nframe()
[09:30:16.305]     ...future.conditions <- base::list()
[09:30:16.305]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:16.305]     if (FALSE) {
[09:30:16.305]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:16.305]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:16.305]     }
[09:30:16.305]     ...future.result <- base::tryCatch({
[09:30:16.305]         base::withCallingHandlers({
[09:30:16.305]             ...future.value <- base::withVisible(base::local({
[09:30:16.305]                 ...future.makeSendCondition <- base::local({
[09:30:16.305]                   sendCondition <- NULL
[09:30:16.305]                   function(frame = 1L) {
[09:30:16.305]                     if (is.function(sendCondition)) 
[09:30:16.305]                       return(sendCondition)
[09:30:16.305]                     ns <- getNamespace("parallel")
[09:30:16.305]                     if (exists("sendData", mode = "function", 
[09:30:16.305]                       envir = ns)) {
[09:30:16.305]                       parallel_sendData <- get("sendData", mode = "function", 
[09:30:16.305]                         envir = ns)
[09:30:16.305]                       envir <- sys.frame(frame)
[09:30:16.305]                       master <- NULL
[09:30:16.305]                       while (!identical(envir, .GlobalEnv) && 
[09:30:16.305]                         !identical(envir, emptyenv())) {
[09:30:16.305]                         if (exists("master", mode = "list", envir = envir, 
[09:30:16.305]                           inherits = FALSE)) {
[09:30:16.305]                           master <- get("master", mode = "list", 
[09:30:16.305]                             envir = envir, inherits = FALSE)
[09:30:16.305]                           if (inherits(master, c("SOCKnode", 
[09:30:16.305]                             "SOCK0node"))) {
[09:30:16.305]                             sendCondition <<- function(cond) {
[09:30:16.305]                               data <- list(type = "VALUE", value = cond, 
[09:30:16.305]                                 success = TRUE)
[09:30:16.305]                               parallel_sendData(master, data)
[09:30:16.305]                             }
[09:30:16.305]                             return(sendCondition)
[09:30:16.305]                           }
[09:30:16.305]                         }
[09:30:16.305]                         frame <- frame + 1L
[09:30:16.305]                         envir <- sys.frame(frame)
[09:30:16.305]                       }
[09:30:16.305]                     }
[09:30:16.305]                     sendCondition <<- function(cond) NULL
[09:30:16.305]                   }
[09:30:16.305]                 })
[09:30:16.305]                 withCallingHandlers({
[09:30:16.305]                   {
[09:30:16.305]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:16.305]                     if (!identical(...future.globals.maxSize.org, 
[09:30:16.305]                       ...future.globals.maxSize)) {
[09:30:16.305]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:16.305]                       on.exit(options(oopts), add = TRUE)
[09:30:16.305]                     }
[09:30:16.305]                     {
[09:30:16.305]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:16.305]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:30:16.305]                         USE.NAMES = FALSE)
[09:30:16.305]                       do.call(mapply, args = args)
[09:30:16.305]                     }
[09:30:16.305]                   }
[09:30:16.305]                 }, immediateCondition = function(cond) {
[09:30:16.305]                   sendCondition <- ...future.makeSendCondition()
[09:30:16.305]                   sendCondition(cond)
[09:30:16.305]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:16.305]                   {
[09:30:16.305]                     inherits <- base::inherits
[09:30:16.305]                     invokeRestart <- base::invokeRestart
[09:30:16.305]                     is.null <- base::is.null
[09:30:16.305]                     muffled <- FALSE
[09:30:16.305]                     if (inherits(cond, "message")) {
[09:30:16.305]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:16.305]                       if (muffled) 
[09:30:16.305]                         invokeRestart("muffleMessage")
[09:30:16.305]                     }
[09:30:16.305]                     else if (inherits(cond, "warning")) {
[09:30:16.305]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:16.305]                       if (muffled) 
[09:30:16.305]                         invokeRestart("muffleWarning")
[09:30:16.305]                     }
[09:30:16.305]                     else if (inherits(cond, "condition")) {
[09:30:16.305]                       if (!is.null(pattern)) {
[09:30:16.305]                         computeRestarts <- base::computeRestarts
[09:30:16.305]                         grepl <- base::grepl
[09:30:16.305]                         restarts <- computeRestarts(cond)
[09:30:16.305]                         for (restart in restarts) {
[09:30:16.305]                           name <- restart$name
[09:30:16.305]                           if (is.null(name)) 
[09:30:16.305]                             next
[09:30:16.305]                           if (!grepl(pattern, name)) 
[09:30:16.305]                             next
[09:30:16.305]                           invokeRestart(restart)
[09:30:16.305]                           muffled <- TRUE
[09:30:16.305]                           break
[09:30:16.305]                         }
[09:30:16.305]                       }
[09:30:16.305]                     }
[09:30:16.305]                     invisible(muffled)
[09:30:16.305]                   }
[09:30:16.305]                   muffleCondition(cond)
[09:30:16.305]                 })
[09:30:16.305]             }))
[09:30:16.305]             future::FutureResult(value = ...future.value$value, 
[09:30:16.305]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:16.305]                   ...future.rng), globalenv = if (FALSE) 
[09:30:16.305]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:16.305]                     ...future.globalenv.names))
[09:30:16.305]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:16.305]         }, condition = base::local({
[09:30:16.305]             c <- base::c
[09:30:16.305]             inherits <- base::inherits
[09:30:16.305]             invokeRestart <- base::invokeRestart
[09:30:16.305]             length <- base::length
[09:30:16.305]             list <- base::list
[09:30:16.305]             seq.int <- base::seq.int
[09:30:16.305]             signalCondition <- base::signalCondition
[09:30:16.305]             sys.calls <- base::sys.calls
[09:30:16.305]             `[[` <- base::`[[`
[09:30:16.305]             `+` <- base::`+`
[09:30:16.305]             `<<-` <- base::`<<-`
[09:30:16.305]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:16.305]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:16.305]                   3L)]
[09:30:16.305]             }
[09:30:16.305]             function(cond) {
[09:30:16.305]                 is_error <- inherits(cond, "error")
[09:30:16.305]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:16.305]                   NULL)
[09:30:16.305]                 if (is_error) {
[09:30:16.305]                   sessionInformation <- function() {
[09:30:16.305]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:16.305]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:16.305]                       search = base::search(), system = base::Sys.info())
[09:30:16.305]                   }
[09:30:16.305]                   ...future.conditions[[length(...future.conditions) + 
[09:30:16.305]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:16.305]                     cond$call), session = sessionInformation(), 
[09:30:16.305]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:16.305]                   signalCondition(cond)
[09:30:16.305]                 }
[09:30:16.305]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:16.305]                 "immediateCondition"))) {
[09:30:16.305]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:16.305]                   ...future.conditions[[length(...future.conditions) + 
[09:30:16.305]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:16.305]                   if (TRUE && !signal) {
[09:30:16.305]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:16.305]                     {
[09:30:16.305]                       inherits <- base::inherits
[09:30:16.305]                       invokeRestart <- base::invokeRestart
[09:30:16.305]                       is.null <- base::is.null
[09:30:16.305]                       muffled <- FALSE
[09:30:16.305]                       if (inherits(cond, "message")) {
[09:30:16.305]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:16.305]                         if (muffled) 
[09:30:16.305]                           invokeRestart("muffleMessage")
[09:30:16.305]                       }
[09:30:16.305]                       else if (inherits(cond, "warning")) {
[09:30:16.305]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:16.305]                         if (muffled) 
[09:30:16.305]                           invokeRestart("muffleWarning")
[09:30:16.305]                       }
[09:30:16.305]                       else if (inherits(cond, "condition")) {
[09:30:16.305]                         if (!is.null(pattern)) {
[09:30:16.305]                           computeRestarts <- base::computeRestarts
[09:30:16.305]                           grepl <- base::grepl
[09:30:16.305]                           restarts <- computeRestarts(cond)
[09:30:16.305]                           for (restart in restarts) {
[09:30:16.305]                             name <- restart$name
[09:30:16.305]                             if (is.null(name)) 
[09:30:16.305]                               next
[09:30:16.305]                             if (!grepl(pattern, name)) 
[09:30:16.305]                               next
[09:30:16.305]                             invokeRestart(restart)
[09:30:16.305]                             muffled <- TRUE
[09:30:16.305]                             break
[09:30:16.305]                           }
[09:30:16.305]                         }
[09:30:16.305]                       }
[09:30:16.305]                       invisible(muffled)
[09:30:16.305]                     }
[09:30:16.305]                     muffleCondition(cond, pattern = "^muffle")
[09:30:16.305]                   }
[09:30:16.305]                 }
[09:30:16.305]                 else {
[09:30:16.305]                   if (TRUE) {
[09:30:16.305]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:16.305]                     {
[09:30:16.305]                       inherits <- base::inherits
[09:30:16.305]                       invokeRestart <- base::invokeRestart
[09:30:16.305]                       is.null <- base::is.null
[09:30:16.305]                       muffled <- FALSE
[09:30:16.305]                       if (inherits(cond, "message")) {
[09:30:16.305]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:16.305]                         if (muffled) 
[09:30:16.305]                           invokeRestart("muffleMessage")
[09:30:16.305]                       }
[09:30:16.305]                       else if (inherits(cond, "warning")) {
[09:30:16.305]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:16.305]                         if (muffled) 
[09:30:16.305]                           invokeRestart("muffleWarning")
[09:30:16.305]                       }
[09:30:16.305]                       else if (inherits(cond, "condition")) {
[09:30:16.305]                         if (!is.null(pattern)) {
[09:30:16.305]                           computeRestarts <- base::computeRestarts
[09:30:16.305]                           grepl <- base::grepl
[09:30:16.305]                           restarts <- computeRestarts(cond)
[09:30:16.305]                           for (restart in restarts) {
[09:30:16.305]                             name <- restart$name
[09:30:16.305]                             if (is.null(name)) 
[09:30:16.305]                               next
[09:30:16.305]                             if (!grepl(pattern, name)) 
[09:30:16.305]                               next
[09:30:16.305]                             invokeRestart(restart)
[09:30:16.305]                             muffled <- TRUE
[09:30:16.305]                             break
[09:30:16.305]                           }
[09:30:16.305]                         }
[09:30:16.305]                       }
[09:30:16.305]                       invisible(muffled)
[09:30:16.305]                     }
[09:30:16.305]                     muffleCondition(cond, pattern = "^muffle")
[09:30:16.305]                   }
[09:30:16.305]                 }
[09:30:16.305]             }
[09:30:16.305]         }))
[09:30:16.305]     }, error = function(ex) {
[09:30:16.305]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:16.305]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:16.305]                 ...future.rng), started = ...future.startTime, 
[09:30:16.305]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:16.305]             version = "1.8"), class = "FutureResult")
[09:30:16.305]     }, finally = {
[09:30:16.305]         if (!identical(...future.workdir, getwd())) 
[09:30:16.305]             setwd(...future.workdir)
[09:30:16.305]         {
[09:30:16.305]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:16.305]                 ...future.oldOptions$nwarnings <- NULL
[09:30:16.305]             }
[09:30:16.305]             base::options(...future.oldOptions)
[09:30:16.305]             if (.Platform$OS.type == "windows") {
[09:30:16.305]                 old_names <- names(...future.oldEnvVars)
[09:30:16.305]                 envs <- base::Sys.getenv()
[09:30:16.305]                 names <- names(envs)
[09:30:16.305]                 common <- intersect(names, old_names)
[09:30:16.305]                 added <- setdiff(names, old_names)
[09:30:16.305]                 removed <- setdiff(old_names, names)
[09:30:16.305]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:16.305]                   envs[common]]
[09:30:16.305]                 NAMES <- toupper(changed)
[09:30:16.305]                 args <- list()
[09:30:16.305]                 for (kk in seq_along(NAMES)) {
[09:30:16.305]                   name <- changed[[kk]]
[09:30:16.305]                   NAME <- NAMES[[kk]]
[09:30:16.305]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:16.305]                     next
[09:30:16.305]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:16.305]                 }
[09:30:16.305]                 NAMES <- toupper(added)
[09:30:16.305]                 for (kk in seq_along(NAMES)) {
[09:30:16.305]                   name <- added[[kk]]
[09:30:16.305]                   NAME <- NAMES[[kk]]
[09:30:16.305]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:16.305]                     next
[09:30:16.305]                   args[[name]] <- ""
[09:30:16.305]                 }
[09:30:16.305]                 NAMES <- toupper(removed)
[09:30:16.305]                 for (kk in seq_along(NAMES)) {
[09:30:16.305]                   name <- removed[[kk]]
[09:30:16.305]                   NAME <- NAMES[[kk]]
[09:30:16.305]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:16.305]                     next
[09:30:16.305]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:16.305]                 }
[09:30:16.305]                 if (length(args) > 0) 
[09:30:16.305]                   base::do.call(base::Sys.setenv, args = args)
[09:30:16.305]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:16.305]             }
[09:30:16.305]             else {
[09:30:16.305]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:16.305]             }
[09:30:16.305]             {
[09:30:16.305]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:16.305]                   0L) {
[09:30:16.305]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:16.305]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:16.305]                   base::options(opts)
[09:30:16.305]                 }
[09:30:16.305]                 {
[09:30:16.305]                   {
[09:30:16.305]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:16.305]                     NULL
[09:30:16.305]                   }
[09:30:16.305]                   options(future.plan = NULL)
[09:30:16.305]                   if (is.na(NA_character_)) 
[09:30:16.305]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:16.305]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:16.305]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:16.305]                     .init = FALSE)
[09:30:16.305]                 }
[09:30:16.305]             }
[09:30:16.305]         }
[09:30:16.305]     })
[09:30:16.305]     if (FALSE) {
[09:30:16.305]         base::sink(type = "output", split = FALSE)
[09:30:16.305]         if (NA) {
[09:30:16.305]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:16.305]         }
[09:30:16.305]         else {
[09:30:16.305]             ...future.result["stdout"] <- base::list(NULL)
[09:30:16.305]         }
[09:30:16.305]         base::close(...future.stdout)
[09:30:16.305]         ...future.stdout <- NULL
[09:30:16.305]     }
[09:30:16.305]     ...future.result$conditions <- ...future.conditions
[09:30:16.305]     ...future.result$finished <- base::Sys.time()
[09:30:16.305]     ...future.result
[09:30:16.305] }
[09:30:16.308] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[09:30:16.308] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[09:30:16.308] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[09:30:16.308] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:30:16.309] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:30:16.309] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[09:30:16.309] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[09:30:16.309] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:30:16.310] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:30:16.310] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:30:16.310] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:30:16.310] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[09:30:16.311] MultisessionFuture started
[09:30:16.311] - Launch lazy future ... done
[09:30:16.311] run() for ‘MultisessionFuture’ ... done
[09:30:16.311] Created future:
[09:30:16.311] MultisessionFuture:
[09:30:16.311] Label: ‘future_mapply-1’
[09:30:16.311] Expression:
[09:30:16.311] {
[09:30:16.311]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:16.311]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:16.311]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:16.311]         on.exit(options(oopts), add = TRUE)
[09:30:16.311]     }
[09:30:16.311]     {
[09:30:16.311]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:16.311]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:30:16.311]         do.call(mapply, args = args)
[09:30:16.311]     }
[09:30:16.311] }
[09:30:16.311] Lazy evaluation: FALSE
[09:30:16.311] Asynchronous evaluation: TRUE
[09:30:16.311] Local evaluation: TRUE
[09:30:16.311] Environment: R_GlobalEnv
[09:30:16.311] Capture standard output: NA
[09:30:16.311] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:16.311] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:16.311] Packages: <none>
[09:30:16.311] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:16.311] Resolved: FALSE
[09:30:16.311] Value: <not collected>
[09:30:16.311] Conditions captured: <none>
[09:30:16.311] Early signaling: FALSE
[09:30:16.311] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:16.311] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:16.322] Chunk #1 of 2 ... DONE
[09:30:16.322] Chunk #2 of 2 ...
[09:30:16.323]  - Finding globals in '...' for chunk #2 ...
[09:30:16.323] getGlobalsAndPackages() ...
[09:30:16.323] Searching for globals...
[09:30:16.323] 
[09:30:16.323] Searching for globals ... DONE
[09:30:16.323] - globals: [0] <none>
[09:30:16.323] getGlobalsAndPackages() ... DONE
[09:30:16.323]    + additional globals found: [n=0] 
[09:30:16.324]    + additional namespaces needed: [n=0] 
[09:30:16.324]  - Finding globals in '...' for chunk #2 ... DONE
[09:30:16.324]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:30:16.324]  - seeds: <none>
[09:30:16.324]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:16.324] getGlobalsAndPackages() ...
[09:30:16.324] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:16.324] Resolving globals: FALSE
[09:30:16.325] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[09:30:16.325] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:30:16.325] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:30:16.325] 
[09:30:16.325] getGlobalsAndPackages() ... DONE
[09:30:16.326] run() for ‘Future’ ...
[09:30:16.326] - state: ‘created’
[09:30:16.326] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:30:16.339] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:16.339] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:30:16.339]   - Field: ‘node’
[09:30:16.339]   - Field: ‘label’
[09:30:16.339]   - Field: ‘local’
[09:30:16.340]   - Field: ‘owner’
[09:30:16.340]   - Field: ‘envir’
[09:30:16.340]   - Field: ‘workers’
[09:30:16.340]   - Field: ‘packages’
[09:30:16.340]   - Field: ‘gc’
[09:30:16.340]   - Field: ‘conditions’
[09:30:16.340]   - Field: ‘persistent’
[09:30:16.340]   - Field: ‘expr’
[09:30:16.340]   - Field: ‘uuid’
[09:30:16.340]   - Field: ‘seed’
[09:30:16.341]   - Field: ‘version’
[09:30:16.341]   - Field: ‘result’
[09:30:16.341]   - Field: ‘asynchronous’
[09:30:16.341]   - Field: ‘calls’
[09:30:16.341]   - Field: ‘globals’
[09:30:16.341]   - Field: ‘stdout’
[09:30:16.341]   - Field: ‘earlySignal’
[09:30:16.341]   - Field: ‘lazy’
[09:30:16.341]   - Field: ‘state’
[09:30:16.341] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:30:16.341] - Launch lazy future ...
[09:30:16.342] Packages needed by the future expression (n = 0): <none>
[09:30:16.342] Packages needed by future strategies (n = 0): <none>
[09:30:16.342] {
[09:30:16.342]     {
[09:30:16.342]         {
[09:30:16.342]             ...future.startTime <- base::Sys.time()
[09:30:16.342]             {
[09:30:16.342]                 {
[09:30:16.342]                   {
[09:30:16.342]                     {
[09:30:16.342]                       base::local({
[09:30:16.342]                         has_future <- base::requireNamespace("future", 
[09:30:16.342]                           quietly = TRUE)
[09:30:16.342]                         if (has_future) {
[09:30:16.342]                           ns <- base::getNamespace("future")
[09:30:16.342]                           version <- ns[[".package"]][["version"]]
[09:30:16.342]                           if (is.null(version)) 
[09:30:16.342]                             version <- utils::packageVersion("future")
[09:30:16.342]                         }
[09:30:16.342]                         else {
[09:30:16.342]                           version <- NULL
[09:30:16.342]                         }
[09:30:16.342]                         if (!has_future || version < "1.8.0") {
[09:30:16.342]                           info <- base::c(r_version = base::gsub("R version ", 
[09:30:16.342]                             "", base::R.version$version.string), 
[09:30:16.342]                             platform = base::sprintf("%s (%s-bit)", 
[09:30:16.342]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:30:16.342]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:30:16.342]                               "release", "version")], collapse = " "), 
[09:30:16.342]                             hostname = base::Sys.info()[["nodename"]])
[09:30:16.342]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:30:16.342]                             info)
[09:30:16.342]                           info <- base::paste(info, collapse = "; ")
[09:30:16.342]                           if (!has_future) {
[09:30:16.342]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:30:16.342]                               info)
[09:30:16.342]                           }
[09:30:16.342]                           else {
[09:30:16.342]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:30:16.342]                               info, version)
[09:30:16.342]                           }
[09:30:16.342]                           base::stop(msg)
[09:30:16.342]                         }
[09:30:16.342]                       })
[09:30:16.342]                     }
[09:30:16.342]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:30:16.342]                     base::options(mc.cores = 1L)
[09:30:16.342]                   }
[09:30:16.342]                   ...future.strategy.old <- future::plan("list")
[09:30:16.342]                   options(future.plan = NULL)
[09:30:16.342]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:30:16.342]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:30:16.342]                 }
[09:30:16.342]                 ...future.workdir <- getwd()
[09:30:16.342]             }
[09:30:16.342]             ...future.oldOptions <- base::as.list(base::.Options)
[09:30:16.342]             ...future.oldEnvVars <- base::Sys.getenv()
[09:30:16.342]         }
[09:30:16.342]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:30:16.342]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:30:16.342]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:30:16.342]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:30:16.342]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:30:16.342]             future.stdout.windows.reencode = NULL, width = 80L)
[09:30:16.342]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:30:16.342]             base::names(...future.oldOptions))
[09:30:16.342]     }
[09:30:16.342]     if (TRUE) {
[09:30:16.342]     }
[09:30:16.342]     else {
[09:30:16.342]         if (NA) {
[09:30:16.342]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:30:16.342]                 open = "w")
[09:30:16.342]         }
[09:30:16.342]         else {
[09:30:16.342]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:30:16.342]                 windows = "NUL", "/dev/null"), open = "w")
[09:30:16.342]         }
[09:30:16.342]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:30:16.342]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:30:16.342]             base::sink(type = "output", split = FALSE)
[09:30:16.342]             base::close(...future.stdout)
[09:30:16.342]         }, add = TRUE)
[09:30:16.342]     }
[09:30:16.342]     ...future.frame <- base::sys.nframe()
[09:30:16.342]     ...future.conditions <- base::list()
[09:30:16.342]     ...future.rng <- base::globalenv()$.Random.seed
[09:30:16.342]     if (FALSE) {
[09:30:16.342]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:30:16.342]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:30:16.342]     }
[09:30:16.342]     ...future.result <- base::tryCatch({
[09:30:16.342]         base::withCallingHandlers({
[09:30:16.342]             ...future.value <- base::withVisible(base::local({
[09:30:16.342]                 ...future.makeSendCondition <- base::local({
[09:30:16.342]                   sendCondition <- NULL
[09:30:16.342]                   function(frame = 1L) {
[09:30:16.342]                     if (is.function(sendCondition)) 
[09:30:16.342]                       return(sendCondition)
[09:30:16.342]                     ns <- getNamespace("parallel")
[09:30:16.342]                     if (exists("sendData", mode = "function", 
[09:30:16.342]                       envir = ns)) {
[09:30:16.342]                       parallel_sendData <- get("sendData", mode = "function", 
[09:30:16.342]                         envir = ns)
[09:30:16.342]                       envir <- sys.frame(frame)
[09:30:16.342]                       master <- NULL
[09:30:16.342]                       while (!identical(envir, .GlobalEnv) && 
[09:30:16.342]                         !identical(envir, emptyenv())) {
[09:30:16.342]                         if (exists("master", mode = "list", envir = envir, 
[09:30:16.342]                           inherits = FALSE)) {
[09:30:16.342]                           master <- get("master", mode = "list", 
[09:30:16.342]                             envir = envir, inherits = FALSE)
[09:30:16.342]                           if (inherits(master, c("SOCKnode", 
[09:30:16.342]                             "SOCK0node"))) {
[09:30:16.342]                             sendCondition <<- function(cond) {
[09:30:16.342]                               data <- list(type = "VALUE", value = cond, 
[09:30:16.342]                                 success = TRUE)
[09:30:16.342]                               parallel_sendData(master, data)
[09:30:16.342]                             }
[09:30:16.342]                             return(sendCondition)
[09:30:16.342]                           }
[09:30:16.342]                         }
[09:30:16.342]                         frame <- frame + 1L
[09:30:16.342]                         envir <- sys.frame(frame)
[09:30:16.342]                       }
[09:30:16.342]                     }
[09:30:16.342]                     sendCondition <<- function(cond) NULL
[09:30:16.342]                   }
[09:30:16.342]                 })
[09:30:16.342]                 withCallingHandlers({
[09:30:16.342]                   {
[09:30:16.342]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:16.342]                     if (!identical(...future.globals.maxSize.org, 
[09:30:16.342]                       ...future.globals.maxSize)) {
[09:30:16.342]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:16.342]                       on.exit(options(oopts), add = TRUE)
[09:30:16.342]                     }
[09:30:16.342]                     {
[09:30:16.342]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:16.342]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:30:16.342]                         USE.NAMES = FALSE)
[09:30:16.342]                       do.call(mapply, args = args)
[09:30:16.342]                     }
[09:30:16.342]                   }
[09:30:16.342]                 }, immediateCondition = function(cond) {
[09:30:16.342]                   sendCondition <- ...future.makeSendCondition()
[09:30:16.342]                   sendCondition(cond)
[09:30:16.342]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:16.342]                   {
[09:30:16.342]                     inherits <- base::inherits
[09:30:16.342]                     invokeRestart <- base::invokeRestart
[09:30:16.342]                     is.null <- base::is.null
[09:30:16.342]                     muffled <- FALSE
[09:30:16.342]                     if (inherits(cond, "message")) {
[09:30:16.342]                       muffled <- grepl(pattern, "muffleMessage")
[09:30:16.342]                       if (muffled) 
[09:30:16.342]                         invokeRestart("muffleMessage")
[09:30:16.342]                     }
[09:30:16.342]                     else if (inherits(cond, "warning")) {
[09:30:16.342]                       muffled <- grepl(pattern, "muffleWarning")
[09:30:16.342]                       if (muffled) 
[09:30:16.342]                         invokeRestart("muffleWarning")
[09:30:16.342]                     }
[09:30:16.342]                     else if (inherits(cond, "condition")) {
[09:30:16.342]                       if (!is.null(pattern)) {
[09:30:16.342]                         computeRestarts <- base::computeRestarts
[09:30:16.342]                         grepl <- base::grepl
[09:30:16.342]                         restarts <- computeRestarts(cond)
[09:30:16.342]                         for (restart in restarts) {
[09:30:16.342]                           name <- restart$name
[09:30:16.342]                           if (is.null(name)) 
[09:30:16.342]                             next
[09:30:16.342]                           if (!grepl(pattern, name)) 
[09:30:16.342]                             next
[09:30:16.342]                           invokeRestart(restart)
[09:30:16.342]                           muffled <- TRUE
[09:30:16.342]                           break
[09:30:16.342]                         }
[09:30:16.342]                       }
[09:30:16.342]                     }
[09:30:16.342]                     invisible(muffled)
[09:30:16.342]                   }
[09:30:16.342]                   muffleCondition(cond)
[09:30:16.342]                 })
[09:30:16.342]             }))
[09:30:16.342]             future::FutureResult(value = ...future.value$value, 
[09:30:16.342]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:16.342]                   ...future.rng), globalenv = if (FALSE) 
[09:30:16.342]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:30:16.342]                     ...future.globalenv.names))
[09:30:16.342]                 else NULL, started = ...future.startTime, version = "1.8")
[09:30:16.342]         }, condition = base::local({
[09:30:16.342]             c <- base::c
[09:30:16.342]             inherits <- base::inherits
[09:30:16.342]             invokeRestart <- base::invokeRestart
[09:30:16.342]             length <- base::length
[09:30:16.342]             list <- base::list
[09:30:16.342]             seq.int <- base::seq.int
[09:30:16.342]             signalCondition <- base::signalCondition
[09:30:16.342]             sys.calls <- base::sys.calls
[09:30:16.342]             `[[` <- base::`[[`
[09:30:16.342]             `+` <- base::`+`
[09:30:16.342]             `<<-` <- base::`<<-`
[09:30:16.342]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:30:16.342]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:30:16.342]                   3L)]
[09:30:16.342]             }
[09:30:16.342]             function(cond) {
[09:30:16.342]                 is_error <- inherits(cond, "error")
[09:30:16.342]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:30:16.342]                   NULL)
[09:30:16.342]                 if (is_error) {
[09:30:16.342]                   sessionInformation <- function() {
[09:30:16.342]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:30:16.342]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:30:16.342]                       search = base::search(), system = base::Sys.info())
[09:30:16.342]                   }
[09:30:16.342]                   ...future.conditions[[length(...future.conditions) + 
[09:30:16.342]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:30:16.342]                     cond$call), session = sessionInformation(), 
[09:30:16.342]                     timestamp = base::Sys.time(), signaled = 0L)
[09:30:16.342]                   signalCondition(cond)
[09:30:16.342]                 }
[09:30:16.342]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:30:16.342]                 "immediateCondition"))) {
[09:30:16.342]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:30:16.342]                   ...future.conditions[[length(...future.conditions) + 
[09:30:16.342]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:30:16.342]                   if (TRUE && !signal) {
[09:30:16.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:16.342]                     {
[09:30:16.342]                       inherits <- base::inherits
[09:30:16.342]                       invokeRestart <- base::invokeRestart
[09:30:16.342]                       is.null <- base::is.null
[09:30:16.342]                       muffled <- FALSE
[09:30:16.342]                       if (inherits(cond, "message")) {
[09:30:16.342]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:16.342]                         if (muffled) 
[09:30:16.342]                           invokeRestart("muffleMessage")
[09:30:16.342]                       }
[09:30:16.342]                       else if (inherits(cond, "warning")) {
[09:30:16.342]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:16.342]                         if (muffled) 
[09:30:16.342]                           invokeRestart("muffleWarning")
[09:30:16.342]                       }
[09:30:16.342]                       else if (inherits(cond, "condition")) {
[09:30:16.342]                         if (!is.null(pattern)) {
[09:30:16.342]                           computeRestarts <- base::computeRestarts
[09:30:16.342]                           grepl <- base::grepl
[09:30:16.342]                           restarts <- computeRestarts(cond)
[09:30:16.342]                           for (restart in restarts) {
[09:30:16.342]                             name <- restart$name
[09:30:16.342]                             if (is.null(name)) 
[09:30:16.342]                               next
[09:30:16.342]                             if (!grepl(pattern, name)) 
[09:30:16.342]                               next
[09:30:16.342]                             invokeRestart(restart)
[09:30:16.342]                             muffled <- TRUE
[09:30:16.342]                             break
[09:30:16.342]                           }
[09:30:16.342]                         }
[09:30:16.342]                       }
[09:30:16.342]                       invisible(muffled)
[09:30:16.342]                     }
[09:30:16.342]                     muffleCondition(cond, pattern = "^muffle")
[09:30:16.342]                   }
[09:30:16.342]                 }
[09:30:16.342]                 else {
[09:30:16.342]                   if (TRUE) {
[09:30:16.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:30:16.342]                     {
[09:30:16.342]                       inherits <- base::inherits
[09:30:16.342]                       invokeRestart <- base::invokeRestart
[09:30:16.342]                       is.null <- base::is.null
[09:30:16.342]                       muffled <- FALSE
[09:30:16.342]                       if (inherits(cond, "message")) {
[09:30:16.342]                         muffled <- grepl(pattern, "muffleMessage")
[09:30:16.342]                         if (muffled) 
[09:30:16.342]                           invokeRestart("muffleMessage")
[09:30:16.342]                       }
[09:30:16.342]                       else if (inherits(cond, "warning")) {
[09:30:16.342]                         muffled <- grepl(pattern, "muffleWarning")
[09:30:16.342]                         if (muffled) 
[09:30:16.342]                           invokeRestart("muffleWarning")
[09:30:16.342]                       }
[09:30:16.342]                       else if (inherits(cond, "condition")) {
[09:30:16.342]                         if (!is.null(pattern)) {
[09:30:16.342]                           computeRestarts <- base::computeRestarts
[09:30:16.342]                           grepl <- base::grepl
[09:30:16.342]                           restarts <- computeRestarts(cond)
[09:30:16.342]                           for (restart in restarts) {
[09:30:16.342]                             name <- restart$name
[09:30:16.342]                             if (is.null(name)) 
[09:30:16.342]                               next
[09:30:16.342]                             if (!grepl(pattern, name)) 
[09:30:16.342]                               next
[09:30:16.342]                             invokeRestart(restart)
[09:30:16.342]                             muffled <- TRUE
[09:30:16.342]                             break
[09:30:16.342]                           }
[09:30:16.342]                         }
[09:30:16.342]                       }
[09:30:16.342]                       invisible(muffled)
[09:30:16.342]                     }
[09:30:16.342]                     muffleCondition(cond, pattern = "^muffle")
[09:30:16.342]                   }
[09:30:16.342]                 }
[09:30:16.342]             }
[09:30:16.342]         }))
[09:30:16.342]     }, error = function(ex) {
[09:30:16.342]         base::structure(base::list(value = NULL, visible = NULL, 
[09:30:16.342]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:30:16.342]                 ...future.rng), started = ...future.startTime, 
[09:30:16.342]             finished = Sys.time(), session_uuid = NA_character_, 
[09:30:16.342]             version = "1.8"), class = "FutureResult")
[09:30:16.342]     }, finally = {
[09:30:16.342]         if (!identical(...future.workdir, getwd())) 
[09:30:16.342]             setwd(...future.workdir)
[09:30:16.342]         {
[09:30:16.342]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:30:16.342]                 ...future.oldOptions$nwarnings <- NULL
[09:30:16.342]             }
[09:30:16.342]             base::options(...future.oldOptions)
[09:30:16.342]             if (.Platform$OS.type == "windows") {
[09:30:16.342]                 old_names <- names(...future.oldEnvVars)
[09:30:16.342]                 envs <- base::Sys.getenv()
[09:30:16.342]                 names <- names(envs)
[09:30:16.342]                 common <- intersect(names, old_names)
[09:30:16.342]                 added <- setdiff(names, old_names)
[09:30:16.342]                 removed <- setdiff(old_names, names)
[09:30:16.342]                 changed <- common[...future.oldEnvVars[common] != 
[09:30:16.342]                   envs[common]]
[09:30:16.342]                 NAMES <- toupper(changed)
[09:30:16.342]                 args <- list()
[09:30:16.342]                 for (kk in seq_along(NAMES)) {
[09:30:16.342]                   name <- changed[[kk]]
[09:30:16.342]                   NAME <- NAMES[[kk]]
[09:30:16.342]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:16.342]                     next
[09:30:16.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:16.342]                 }
[09:30:16.342]                 NAMES <- toupper(added)
[09:30:16.342]                 for (kk in seq_along(NAMES)) {
[09:30:16.342]                   name <- added[[kk]]
[09:30:16.342]                   NAME <- NAMES[[kk]]
[09:30:16.342]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:16.342]                     next
[09:30:16.342]                   args[[name]] <- ""
[09:30:16.342]                 }
[09:30:16.342]                 NAMES <- toupper(removed)
[09:30:16.342]                 for (kk in seq_along(NAMES)) {
[09:30:16.342]                   name <- removed[[kk]]
[09:30:16.342]                   NAME <- NAMES[[kk]]
[09:30:16.342]                   if (name != NAME && is.element(NAME, old_names)) 
[09:30:16.342]                     next
[09:30:16.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:30:16.342]                 }
[09:30:16.342]                 if (length(args) > 0) 
[09:30:16.342]                   base::do.call(base::Sys.setenv, args = args)
[09:30:16.342]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:30:16.342]             }
[09:30:16.342]             else {
[09:30:16.342]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:30:16.342]             }
[09:30:16.342]             {
[09:30:16.342]                 if (base::length(...future.futureOptionsAdded) > 
[09:30:16.342]                   0L) {
[09:30:16.342]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:30:16.342]                   base::names(opts) <- ...future.futureOptionsAdded
[09:30:16.342]                   base::options(opts)
[09:30:16.342]                 }
[09:30:16.342]                 {
[09:30:16.342]                   {
[09:30:16.342]                     base::options(mc.cores = ...future.mc.cores.old)
[09:30:16.342]                     NULL
[09:30:16.342]                   }
[09:30:16.342]                   options(future.plan = NULL)
[09:30:16.342]                   if (is.na(NA_character_)) 
[09:30:16.342]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:30:16.342]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:30:16.342]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:30:16.342]                     .init = FALSE)
[09:30:16.342]                 }
[09:30:16.342]             }
[09:30:16.342]         }
[09:30:16.342]     })
[09:30:16.342]     if (FALSE) {
[09:30:16.342]         base::sink(type = "output", split = FALSE)
[09:30:16.342]         if (NA) {
[09:30:16.342]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:30:16.342]         }
[09:30:16.342]         else {
[09:30:16.342]             ...future.result["stdout"] <- base::list(NULL)
[09:30:16.342]         }
[09:30:16.342]         base::close(...future.stdout)
[09:30:16.342]         ...future.stdout <- NULL
[09:30:16.342]     }
[09:30:16.342]     ...future.result$conditions <- ...future.conditions
[09:30:16.342]     ...future.result$finished <- base::Sys.time()
[09:30:16.342]     ...future.result
[09:30:16.342] }
[09:30:16.345] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[09:30:16.345] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[09:30:16.345] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[09:30:16.345] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[09:30:16.346] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[09:30:16.346] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[09:30:16.346] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[09:30:16.346] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:30:16.346] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:30:16.347] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:30:16.347] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:30:16.347] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[09:30:16.347] MultisessionFuture started
[09:30:16.347] - Launch lazy future ... done
[09:30:16.348] run() for ‘MultisessionFuture’ ... done
[09:30:16.348] Created future:
[09:30:16.348] MultisessionFuture:
[09:30:16.348] Label: ‘future_mapply-2’
[09:30:16.348] Expression:
[09:30:16.348] {
[09:30:16.348]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:30:16.348]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:30:16.348]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:30:16.348]         on.exit(options(oopts), add = TRUE)
[09:30:16.348]     }
[09:30:16.348]     {
[09:30:16.348]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:30:16.348]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:30:16.348]         do.call(mapply, args = args)
[09:30:16.348]     }
[09:30:16.348] }
[09:30:16.348] Lazy evaluation: FALSE
[09:30:16.348] Asynchronous evaluation: TRUE
[09:30:16.348] Local evaluation: TRUE
[09:30:16.348] Environment: R_GlobalEnv
[09:30:16.348] Capture standard output: NA
[09:30:16.348] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:30:16.348] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:30:16.348] Packages: <none>
[09:30:16.348] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:30:16.348] Resolved: FALSE
[09:30:16.348] Value: <not collected>
[09:30:16.348] Conditions captured: <none>
[09:30:16.348] Early signaling: FALSE
[09:30:16.348] Owner process: c124fc85-c18b-21a4-4373-00229a54e311
[09:30:16.348] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:30:16.359] Chunk #2 of 2 ... DONE
[09:30:16.359] Launching 2 futures (chunks) ... DONE
[09:30:16.359] Resolving 2 futures (chunks) ...
[09:30:16.359] resolve() on list ...
[09:30:16.360]  recursive: 0
[09:30:16.360]  length: 2
[09:30:16.360] 
[09:30:16.402] receiveMessageFromWorker() for ClusterFuture ...
[09:30:16.402] - Validating connection of MultisessionFuture
[09:30:16.402] - received message: FutureResult
[09:30:16.402] - Received FutureResult
[09:30:16.402] - Erased future from FutureRegistry
[09:30:16.402] result() for ClusterFuture ...
[09:30:16.403] - result already collected: FutureResult
[09:30:16.403] result() for ClusterFuture ... done
[09:30:16.403] receiveMessageFromWorker() for ClusterFuture ... done
[09:30:16.403] Future #2
[09:30:16.403] result() for ClusterFuture ...
[09:30:16.403] - result already collected: FutureResult
[09:30:16.403] result() for ClusterFuture ... done
[09:30:16.403] result() for ClusterFuture ...
[09:30:16.403] - result already collected: FutureResult
[09:30:16.403] result() for ClusterFuture ... done
[09:30:16.403] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:30:16.404] - nx: 2
[09:30:16.404] - relay: TRUE
[09:30:16.404] - stdout: TRUE
[09:30:16.404] - signal: TRUE
[09:30:16.404] - resignal: FALSE
[09:30:16.404] - force: TRUE
[09:30:16.404] - relayed: [n=2] FALSE, FALSE
[09:30:16.404] - queued futures: [n=2] FALSE, FALSE
[09:30:16.404]  - until=1
[09:30:16.404]  - relaying element #1
[09:30:16.404] - relayed: [n=2] FALSE, FALSE
[09:30:16.404] - queued futures: [n=2] FALSE, TRUE
[09:30:16.405] signalConditionsASAP(NULL, pos=2) ... done
[09:30:16.405]  length: 1 (resolved future 2)
[09:30:16.854] receiveMessageFromWorker() for ClusterFuture ...
[09:30:16.854] - Validating connection of MultisessionFuture
[09:30:16.855] - received message: FutureResult
[09:30:16.855] - Received FutureResult
[09:30:16.855] - Erased future from FutureRegistry
[09:30:16.855] result() for ClusterFuture ...
[09:30:16.855] - result already collected: FutureResult
[09:30:16.855] result() for ClusterFuture ... done
[09:30:16.855] receiveMessageFromWorker() for ClusterFuture ... done
[09:30:16.855] Future #1
[09:30:16.855] result() for ClusterFuture ...
[09:30:16.855] - result already collected: FutureResult
[09:30:16.856] result() for ClusterFuture ... done
[09:30:16.856] result() for ClusterFuture ...
[09:30:16.856] - result already collected: FutureResult
[09:30:16.856] result() for ClusterFuture ... done
[09:30:16.856] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:30:16.856] - nx: 2
[09:30:16.856] - relay: TRUE
[09:30:16.858] - stdout: TRUE
[09:30:16.858] - signal: TRUE
[09:30:16.858] - resignal: FALSE
[09:30:16.858] - force: TRUE
[09:30:16.859] - relayed: [n=2] FALSE, FALSE
[09:30:16.859] - queued futures: [n=2] FALSE, TRUE
[09:30:16.859]  - until=1
[09:30:16.859]  - relaying element #1
[09:30:16.859] result() for ClusterFuture ...
[09:30:16.859] - result already collected: FutureResult
[09:30:16.859] result() for ClusterFuture ... done
[09:30:16.859] result() for ClusterFuture ...
[09:30:16.859] - result already collected: FutureResult
[09:30:16.859] result() for ClusterFuture ... done
[09:30:16.859] result() for ClusterFuture ...
[09:30:16.860] - result already collected: FutureResult
[09:30:16.860] result() for ClusterFuture ... done
[09:30:16.860] result() for ClusterFuture ...
[09:30:16.860] - result already collected: FutureResult
[09:30:16.860] result() for ClusterFuture ... done
[09:30:16.860] - relayed: [n=2] TRUE, FALSE
[09:30:16.860] - queued futures: [n=2] TRUE, TRUE
[09:30:16.860] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:30:16.860]  length: 0 (resolved future 1)
[09:30:16.860] Relaying remaining futures
[09:30:16.860] signalConditionsASAP(NULL, pos=0) ...
[09:30:16.860] - nx: 2
[09:30:16.861] - relay: TRUE
[09:30:16.861] - stdout: TRUE
[09:30:16.861] - signal: TRUE
[09:30:16.861] - resignal: FALSE
[09:30:16.861] - force: TRUE
[09:30:16.861] - relayed: [n=2] TRUE, FALSE
[09:30:16.861] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:30:16.861]  - relaying element #2
[09:30:16.861] result() for ClusterFuture ...
[09:30:16.861] - result already collected: FutureResult
[09:30:16.861] result() for ClusterFuture ... done
[09:30:16.861] result() for ClusterFuture ...
[09:30:16.862] - result already collected: FutureResult
[09:30:16.862] result() for ClusterFuture ... done
[09:30:16.862] result() for ClusterFuture ...
[09:30:16.862] - result already collected: FutureResult
[09:30:16.862] result() for ClusterFuture ... done
[09:30:16.862] result() for ClusterFuture ...
[09:30:16.862] - result already collected: FutureResult
[09:30:16.862] result() for ClusterFuture ... done
[09:30:16.862] - relayed: [n=2] TRUE, TRUE
[09:30:16.862] - queued futures: [n=2] TRUE, TRUE
[09:30:16.862] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[09:30:16.862] resolve() on list ... DONE
[09:30:16.863] result() for ClusterFuture ...
[09:30:16.863] - result already collected: FutureResult
[09:30:16.863] result() for ClusterFuture ... done
[09:30:16.863] result() for ClusterFuture ...
[09:30:16.863] - result already collected: FutureResult
[09:30:16.863] result() for ClusterFuture ... done
[09:30:16.863] result() for ClusterFuture ...
[09:30:16.863] - result already collected: FutureResult
[09:30:16.863] result() for ClusterFuture ... done
[09:30:16.863] result() for ClusterFuture ...
[09:30:16.863] - result already collected: FutureResult
[09:30:16.864] result() for ClusterFuture ... done
[09:30:16.864]  - Number of value chunks collected: 2
[09:30:16.864] Resolving 2 futures (chunks) ... DONE
[09:30:16.864] Reducing values from 2 chunks ...
[09:30:16.864]  - Number of values collected after concatenation: 2
[09:30:16.864]  - Number of values expected: 2
[09:30:16.864] Reducing values from 2 chunks ... DONE
[09:30:16.864] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 2 cores ... DONE
> 
> message("*** future_*apply() and 'future.stdout' ... DONE")
*** future_*apply() and 'future.stdout' ... DONE
> 
> source("incl/end.R")
[09:30:16.865] plan(): Setting new future strategy stack:
[09:30:16.865] List of future strategies:
[09:30:16.865] 1. FutureStrategy:
[09:30:16.865]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:30:16.865]    - tweaked: FALSE
[09:30:16.865]    - call: future::plan(oplan)
[09:30:16.866] plan(): nbrOfWorkers() = 1
> 
