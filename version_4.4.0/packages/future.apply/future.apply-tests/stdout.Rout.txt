
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:38:20.934] plan(): Setting new future strategy stack:
[17:38:20.934] List of future strategies:
[17:38:20.934] 1. sequential:
[17:38:20.934]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:20.934]    - tweaked: FALSE
[17:38:20.934]    - call: future::plan("sequential")
[17:38:20.949] plan(): nbrOfWorkers() = 1
> 
> message("*** future_*apply() and 'future.stdout' ...")
*** future_*apply() and 'future.stdout' ...
> 
> options(future.debug = TRUE)
> 
> truth <- list()
> 
> out <- utils::capture.output({
+   y <- lapply(1:0, FUN = function(x) {
+     print(x)
+   })
+ })
> truth[["lapply"]] <- list(value = y, stdout = out)
> 
> out <- utils::capture.output({
+   y <- mapply(1:0, 0:1, FUN = function(x, y) {
+     print(list(x = x, y = y))
+   })
+ })
> truth[["mapply"]] <- list(value = y, stdout = out)
> 
> for (cores in 1:availCores) {
+   message(sprintf("  - Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+   
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("* plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     for (fun in names(truth)) {
+       for (stdout in c(FALSE, TRUE, NA)) {
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ...", fun, stdout))
+   
+         out <- utils::capture.output({
+           if (fun == "lapply") {
+             y <- future_lapply(1:0, FUN = function(x) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+ 	      print(x)
+             }, future.stdout = stdout)
+ 	  } else if (fun == "mapply") {
+             y <- future_mapply(1:0, 0:1, FUN = function(x, y) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+               print(list(x = x, y = y))
+             }, future.stdout = stdout)
+ 	  }
+         })
+         stopifnot(identical(y, truth[[fun]]$value))
+   
+         if (isTRUE(stdout)) {
+           stopifnot(identical(out, truth[[fun]]$stdout))
+         } else if (is.na(stdout)) {
+         } else {
+           stopifnot(nchar(out) == 0)
+         }
+       
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ... DONE", fun, stdout))
+       } ## for (stdout ...)
+     } ## for (fun ...)
+     
+     message(sprintf("* plan('%s') ... DONE", strategy))
+   }
+   
+   message(sprintf("  - Testing with %d cores ... DONE", cores))
+ }
  - Testing with 1 cores ...
* plan('sequential') ...
[17:38:20.984] plan(): Setting new future strategy stack:
[17:38:20.984] List of future strategies:
[17:38:20.984] 1. sequential:
[17:38:20.984]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:20.984]    - tweaked: FALSE
[17:38:20.984]    - call: plan(strategy)
[17:38:20.996] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[17:38:20.996] future_lapply() ...
[17:38:21.001] Number of chunks: 1
[17:38:21.001] getGlobalsAndPackagesXApply() ...
[17:38:21.001]  - future.globals: TRUE
[17:38:21.002] getGlobalsAndPackages() ...
[17:38:21.002] Searching for globals...
[17:38:21.004] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:38:21.004] Searching for globals ... DONE
[17:38:21.004] Resolving globals: FALSE
[17:38:21.005] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:38:21.006] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:38:21.006] - globals: [1] ‘FUN’
[17:38:21.006] 
[17:38:21.006] getGlobalsAndPackages() ... DONE
[17:38:21.006]  - globals found/used: [n=1] ‘FUN’
[17:38:21.006]  - needed namespaces: [n=0] 
[17:38:21.006] Finding globals ... DONE
[17:38:21.007]  - use_args: TRUE
[17:38:21.007]  - Getting '...' globals ...
[17:38:21.007] resolve() on list ...
[17:38:21.008]  recursive: 0
[17:38:21.008]  length: 1
[17:38:21.008]  elements: ‘...’
[17:38:21.008]  length: 0 (resolved future 1)
[17:38:21.008] resolve() on list ... DONE
[17:38:21.008]    - '...' content: [n=0] 
[17:38:21.008] List of 1
[17:38:21.008]  $ ...: list()
[17:38:21.008]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:21.008]  - attr(*, "where")=List of 1
[17:38:21.008]   ..$ ...:<environment: 0x5628ab87a2d8> 
[17:38:21.008]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:21.008]  - attr(*, "resolved")= logi TRUE
[17:38:21.008]  - attr(*, "total_size")= num NA
[17:38:21.013]  - Getting '...' globals ... DONE
[17:38:21.013] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:38:21.013] List of 2
[17:38:21.013]  $ ...future.FUN:function (x)  
[17:38:21.013]  $ ...          : list()
[17:38:21.013]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:21.013]  - attr(*, "where")=List of 2
[17:38:21.013]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:21.013]   ..$ ...          :<environment: 0x5628ab87a2d8> 
[17:38:21.013]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:21.013]  - attr(*, "resolved")= logi FALSE
[17:38:21.013]  - attr(*, "total_size")= num 4720
[17:38:21.016] Packages to be attached in all futures: [n=0] 
[17:38:21.018] getGlobalsAndPackagesXApply() ... DONE
[17:38:21.018] Number of futures (= number of chunks): 1
[17:38:21.018] Launching 1 futures (chunks) ...
[17:38:21.019] Chunk #1 of 1 ...
[17:38:21.019]  - Finding globals in 'X' for chunk #1 ...
[17:38:21.019] getGlobalsAndPackages() ...
[17:38:21.019] Searching for globals...
[17:38:21.019] 
[17:38:21.019] Searching for globals ... DONE
[17:38:21.020] - globals: [0] <none>
[17:38:21.020] getGlobalsAndPackages() ... DONE
[17:38:21.020]    + additional globals found: [n=0] 
[17:38:21.020]    + additional namespaces needed: [n=0] 
[17:38:21.020]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:21.020]  - seeds: <none>
[17:38:21.020]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:21.020] getGlobalsAndPackages() ...
[17:38:21.020] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:21.021] Resolving globals: FALSE
[17:38:21.021] Tweak future expression to call with '...' arguments ...
[17:38:21.021] {
[17:38:21.021]     do.call(function(...) {
[17:38:21.021]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:21.021]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:21.021]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:21.021]             on.exit(options(oopts), add = TRUE)
[17:38:21.021]         }
[17:38:21.021]         {
[17:38:21.021]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:21.021]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:21.021]                 ...future.FUN(...future.X_jj, ...)
[17:38:21.021]             })
[17:38:21.021]         }
[17:38:21.021]     }, args = future.call.arguments)
[17:38:21.021] }
[17:38:21.021] Tweak future expression to call with '...' arguments ... DONE
[17:38:21.021] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:21.022] 
[17:38:21.022] getGlobalsAndPackages() ... DONE
[17:38:21.022] run() for ‘Future’ ...
[17:38:21.022] - state: ‘created’
[17:38:21.023] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:38:21.023] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:21.023] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:21.023]   - Field: ‘label’
[17:38:21.023]   - Field: ‘local’
[17:38:21.023]   - Field: ‘owner’
[17:38:21.024]   - Field: ‘envir’
[17:38:21.024]   - Field: ‘packages’
[17:38:21.024]   - Field: ‘gc’
[17:38:21.024]   - Field: ‘conditions’
[17:38:21.024]   - Field: ‘expr’
[17:38:21.024]   - Field: ‘uuid’
[17:38:21.024]   - Field: ‘seed’
[17:38:21.024]   - Field: ‘version’
[17:38:21.024]   - Field: ‘result’
[17:38:21.024]   - Field: ‘asynchronous’
[17:38:21.024]   - Field: ‘calls’
[17:38:21.025]   - Field: ‘globals’
[17:38:21.025]   - Field: ‘stdout’
[17:38:21.025]   - Field: ‘earlySignal’
[17:38:21.025]   - Field: ‘lazy’
[17:38:21.025]   - Field: ‘state’
[17:38:21.025] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:21.025] - Launch lazy future ...
[17:38:21.026] Packages needed by the future expression (n = 0): <none>
[17:38:21.026] Packages needed by future strategies (n = 0): <none>
[17:38:21.027] {
[17:38:21.027]     {
[17:38:21.027]         {
[17:38:21.027]             ...future.startTime <- base::Sys.time()
[17:38:21.027]             {
[17:38:21.027]                 {
[17:38:21.027]                   {
[17:38:21.027]                     base::local({
[17:38:21.027]                       has_future <- base::requireNamespace("future", 
[17:38:21.027]                         quietly = TRUE)
[17:38:21.027]                       if (has_future) {
[17:38:21.027]                         ns <- base::getNamespace("future")
[17:38:21.027]                         version <- ns[[".package"]][["version"]]
[17:38:21.027]                         if (is.null(version)) 
[17:38:21.027]                           version <- utils::packageVersion("future")
[17:38:21.027]                       }
[17:38:21.027]                       else {
[17:38:21.027]                         version <- NULL
[17:38:21.027]                       }
[17:38:21.027]                       if (!has_future || version < "1.8.0") {
[17:38:21.027]                         info <- base::c(r_version = base::gsub("R version ", 
[17:38:21.027]                           "", base::R.version$version.string), 
[17:38:21.027]                           platform = base::sprintf("%s (%s-bit)", 
[17:38:21.027]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:21.027]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:21.027]                             "release", "version")], collapse = " "), 
[17:38:21.027]                           hostname = base::Sys.info()[["nodename"]])
[17:38:21.027]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:38:21.027]                           info)
[17:38:21.027]                         info <- base::paste(info, collapse = "; ")
[17:38:21.027]                         if (!has_future) {
[17:38:21.027]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:21.027]                             info)
[17:38:21.027]                         }
[17:38:21.027]                         else {
[17:38:21.027]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:21.027]                             info, version)
[17:38:21.027]                         }
[17:38:21.027]                         base::stop(msg)
[17:38:21.027]                       }
[17:38:21.027]                     })
[17:38:21.027]                   }
[17:38:21.027]                   ...future.strategy.old <- future::plan("list")
[17:38:21.027]                   options(future.plan = NULL)
[17:38:21.027]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:21.027]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:21.027]                 }
[17:38:21.027]                 ...future.workdir <- getwd()
[17:38:21.027]             }
[17:38:21.027]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:21.027]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:21.027]         }
[17:38:21.027]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:21.027]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:21.027]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:21.027]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:21.027]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:21.027]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:21.027]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:21.027]             base::names(...future.oldOptions))
[17:38:21.027]     }
[17:38:21.027]     if (FALSE) {
[17:38:21.027]     }
[17:38:21.027]     else {
[17:38:21.027]         if (FALSE) {
[17:38:21.027]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:21.027]                 open = "w")
[17:38:21.027]         }
[17:38:21.027]         else {
[17:38:21.027]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:21.027]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:21.027]         }
[17:38:21.027]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:21.027]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:21.027]             base::sink(type = "output", split = FALSE)
[17:38:21.027]             base::close(...future.stdout)
[17:38:21.027]         }, add = TRUE)
[17:38:21.027]     }
[17:38:21.027]     ...future.frame <- base::sys.nframe()
[17:38:21.027]     ...future.conditions <- base::list()
[17:38:21.027]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:21.027]     if (FALSE) {
[17:38:21.027]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:21.027]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:21.027]     }
[17:38:21.027]     ...future.result <- base::tryCatch({
[17:38:21.027]         base::withCallingHandlers({
[17:38:21.027]             ...future.value <- base::withVisible(base::local({
[17:38:21.027]                 do.call(function(...) {
[17:38:21.027]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:21.027]                   if (!identical(...future.globals.maxSize.org, 
[17:38:21.027]                     ...future.globals.maxSize)) {
[17:38:21.027]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:21.027]                     on.exit(options(oopts), add = TRUE)
[17:38:21.027]                   }
[17:38:21.027]                   {
[17:38:21.027]                     lapply(seq_along(...future.elements_ii), 
[17:38:21.027]                       FUN = function(jj) {
[17:38:21.027]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:21.027]                         ...future.FUN(...future.X_jj, ...)
[17:38:21.027]                       })
[17:38:21.027]                   }
[17:38:21.027]                 }, args = future.call.arguments)
[17:38:21.027]             }))
[17:38:21.027]             future::FutureResult(value = ...future.value$value, 
[17:38:21.027]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:21.027]                   ...future.rng), globalenv = if (FALSE) 
[17:38:21.027]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:21.027]                     ...future.globalenv.names))
[17:38:21.027]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:21.027]         }, condition = base::local({
[17:38:21.027]             c <- base::c
[17:38:21.027]             inherits <- base::inherits
[17:38:21.027]             invokeRestart <- base::invokeRestart
[17:38:21.027]             length <- base::length
[17:38:21.027]             list <- base::list
[17:38:21.027]             seq.int <- base::seq.int
[17:38:21.027]             signalCondition <- base::signalCondition
[17:38:21.027]             sys.calls <- base::sys.calls
[17:38:21.027]             `[[` <- base::`[[`
[17:38:21.027]             `+` <- base::`+`
[17:38:21.027]             `<<-` <- base::`<<-`
[17:38:21.027]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:21.027]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:21.027]                   3L)]
[17:38:21.027]             }
[17:38:21.027]             function(cond) {
[17:38:21.027]                 is_error <- inherits(cond, "error")
[17:38:21.027]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:21.027]                   NULL)
[17:38:21.027]                 if (is_error) {
[17:38:21.027]                   sessionInformation <- function() {
[17:38:21.027]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:21.027]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:21.027]                       search = base::search(), system = base::Sys.info())
[17:38:21.027]                   }
[17:38:21.027]                   ...future.conditions[[length(...future.conditions) + 
[17:38:21.027]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:21.027]                     cond$call), session = sessionInformation(), 
[17:38:21.027]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:21.027]                   signalCondition(cond)
[17:38:21.027]                 }
[17:38:21.027]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:21.027]                 "immediateCondition"))) {
[17:38:21.027]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:21.027]                   ...future.conditions[[length(...future.conditions) + 
[17:38:21.027]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:21.027]                   if (TRUE && !signal) {
[17:38:21.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:21.027]                     {
[17:38:21.027]                       inherits <- base::inherits
[17:38:21.027]                       invokeRestart <- base::invokeRestart
[17:38:21.027]                       is.null <- base::is.null
[17:38:21.027]                       muffled <- FALSE
[17:38:21.027]                       if (inherits(cond, "message")) {
[17:38:21.027]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:21.027]                         if (muffled) 
[17:38:21.027]                           invokeRestart("muffleMessage")
[17:38:21.027]                       }
[17:38:21.027]                       else if (inherits(cond, "warning")) {
[17:38:21.027]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:21.027]                         if (muffled) 
[17:38:21.027]                           invokeRestart("muffleWarning")
[17:38:21.027]                       }
[17:38:21.027]                       else if (inherits(cond, "condition")) {
[17:38:21.027]                         if (!is.null(pattern)) {
[17:38:21.027]                           computeRestarts <- base::computeRestarts
[17:38:21.027]                           grepl <- base::grepl
[17:38:21.027]                           restarts <- computeRestarts(cond)
[17:38:21.027]                           for (restart in restarts) {
[17:38:21.027]                             name <- restart$name
[17:38:21.027]                             if (is.null(name)) 
[17:38:21.027]                               next
[17:38:21.027]                             if (!grepl(pattern, name)) 
[17:38:21.027]                               next
[17:38:21.027]                             invokeRestart(restart)
[17:38:21.027]                             muffled <- TRUE
[17:38:21.027]                             break
[17:38:21.027]                           }
[17:38:21.027]                         }
[17:38:21.027]                       }
[17:38:21.027]                       invisible(muffled)
[17:38:21.027]                     }
[17:38:21.027]                     muffleCondition(cond, pattern = "^muffle")
[17:38:21.027]                   }
[17:38:21.027]                 }
[17:38:21.027]                 else {
[17:38:21.027]                   if (TRUE) {
[17:38:21.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:21.027]                     {
[17:38:21.027]                       inherits <- base::inherits
[17:38:21.027]                       invokeRestart <- base::invokeRestart
[17:38:21.027]                       is.null <- base::is.null
[17:38:21.027]                       muffled <- FALSE
[17:38:21.027]                       if (inherits(cond, "message")) {
[17:38:21.027]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:21.027]                         if (muffled) 
[17:38:21.027]                           invokeRestart("muffleMessage")
[17:38:21.027]                       }
[17:38:21.027]                       else if (inherits(cond, "warning")) {
[17:38:21.027]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:21.027]                         if (muffled) 
[17:38:21.027]                           invokeRestart("muffleWarning")
[17:38:21.027]                       }
[17:38:21.027]                       else if (inherits(cond, "condition")) {
[17:38:21.027]                         if (!is.null(pattern)) {
[17:38:21.027]                           computeRestarts <- base::computeRestarts
[17:38:21.027]                           grepl <- base::grepl
[17:38:21.027]                           restarts <- computeRestarts(cond)
[17:38:21.027]                           for (restart in restarts) {
[17:38:21.027]                             name <- restart$name
[17:38:21.027]                             if (is.null(name)) 
[17:38:21.027]                               next
[17:38:21.027]                             if (!grepl(pattern, name)) 
[17:38:21.027]                               next
[17:38:21.027]                             invokeRestart(restart)
[17:38:21.027]                             muffled <- TRUE
[17:38:21.027]                             break
[17:38:21.027]                           }
[17:38:21.027]                         }
[17:38:21.027]                       }
[17:38:21.027]                       invisible(muffled)
[17:38:21.027]                     }
[17:38:21.027]                     muffleCondition(cond, pattern = "^muffle")
[17:38:21.027]                   }
[17:38:21.027]                 }
[17:38:21.027]             }
[17:38:21.027]         }))
[17:38:21.027]     }, error = function(ex) {
[17:38:21.027]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:21.027]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:21.027]                 ...future.rng), started = ...future.startTime, 
[17:38:21.027]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:21.027]             version = "1.8"), class = "FutureResult")
[17:38:21.027]     }, finally = {
[17:38:21.027]         if (!identical(...future.workdir, getwd())) 
[17:38:21.027]             setwd(...future.workdir)
[17:38:21.027]         {
[17:38:21.027]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:21.027]                 ...future.oldOptions$nwarnings <- NULL
[17:38:21.027]             }
[17:38:21.027]             base::options(...future.oldOptions)
[17:38:21.027]             if (.Platform$OS.type == "windows") {
[17:38:21.027]                 old_names <- names(...future.oldEnvVars)
[17:38:21.027]                 envs <- base::Sys.getenv()
[17:38:21.027]                 names <- names(envs)
[17:38:21.027]                 common <- intersect(names, old_names)
[17:38:21.027]                 added <- setdiff(names, old_names)
[17:38:21.027]                 removed <- setdiff(old_names, names)
[17:38:21.027]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:21.027]                   envs[common]]
[17:38:21.027]                 NAMES <- toupper(changed)
[17:38:21.027]                 args <- list()
[17:38:21.027]                 for (kk in seq_along(NAMES)) {
[17:38:21.027]                   name <- changed[[kk]]
[17:38:21.027]                   NAME <- NAMES[[kk]]
[17:38:21.027]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:21.027]                     next
[17:38:21.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:21.027]                 }
[17:38:21.027]                 NAMES <- toupper(added)
[17:38:21.027]                 for (kk in seq_along(NAMES)) {
[17:38:21.027]                   name <- added[[kk]]
[17:38:21.027]                   NAME <- NAMES[[kk]]
[17:38:21.027]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:21.027]                     next
[17:38:21.027]                   args[[name]] <- ""
[17:38:21.027]                 }
[17:38:21.027]                 NAMES <- toupper(removed)
[17:38:21.027]                 for (kk in seq_along(NAMES)) {
[17:38:21.027]                   name <- removed[[kk]]
[17:38:21.027]                   NAME <- NAMES[[kk]]
[17:38:21.027]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:21.027]                     next
[17:38:21.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:21.027]                 }
[17:38:21.027]                 if (length(args) > 0) 
[17:38:21.027]                   base::do.call(base::Sys.setenv, args = args)
[17:38:21.027]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:21.027]             }
[17:38:21.027]             else {
[17:38:21.027]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:21.027]             }
[17:38:21.027]             {
[17:38:21.027]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:21.027]                   0L) {
[17:38:21.027]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:21.027]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:21.027]                   base::options(opts)
[17:38:21.027]                 }
[17:38:21.027]                 {
[17:38:21.027]                   {
[17:38:21.027]                     NULL
[17:38:21.027]                     RNGkind("Mersenne-Twister")
[17:38:21.027]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:21.027]                       inherits = FALSE)
[17:38:21.027]                   }
[17:38:21.027]                   options(future.plan = NULL)
[17:38:21.027]                   if (is.na(NA_character_)) 
[17:38:21.027]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:21.027]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:21.027]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:21.027]                     .init = FALSE)
[17:38:21.027]                 }
[17:38:21.027]             }
[17:38:21.027]         }
[17:38:21.027]     })
[17:38:21.027]     if (TRUE) {
[17:38:21.027]         base::sink(type = "output", split = FALSE)
[17:38:21.027]         if (FALSE) {
[17:38:21.027]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:21.027]         }
[17:38:21.027]         else {
[17:38:21.027]             ...future.result["stdout"] <- base::list(NULL)
[17:38:21.027]         }
[17:38:21.027]         base::close(...future.stdout)
[17:38:21.027]         ...future.stdout <- NULL
[17:38:21.027]     }
[17:38:21.027]     ...future.result$conditions <- ...future.conditions
[17:38:21.027]     ...future.result$finished <- base::Sys.time()
[17:38:21.027]     ...future.result
[17:38:21.027] }
[17:38:21.028] assign_globals() ...
[17:38:21.029] List of 5
[17:38:21.029]  $ ...future.FUN            :function (x)  
[17:38:21.029]  $ future.call.arguments    : list()
[17:38:21.029]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:21.029]  $ ...future.elements_ii    :List of 2
[17:38:21.029]   ..$ : int 1
[17:38:21.029]   ..$ : int 0
[17:38:21.029]  $ ...future.seeds_ii       : NULL
[17:38:21.029]  $ ...future.globals.maxSize: NULL
[17:38:21.029]  - attr(*, "where")=List of 5
[17:38:21.029]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:21.029]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:21.029]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:21.029]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:21.029]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:21.029]  - attr(*, "resolved")= logi FALSE
[17:38:21.029]  - attr(*, "total_size")= num 4720
[17:38:21.029]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:21.029]  - attr(*, "already-done")= logi TRUE
[17:38:21.033] - reassign environment for ‘...future.FUN’
[17:38:21.033] - copied ‘...future.FUN’ to environment
[17:38:21.034] - copied ‘future.call.arguments’ to environment
[17:38:21.034] - copied ‘...future.elements_ii’ to environment
[17:38:21.034] - copied ‘...future.seeds_ii’ to environment
[17:38:21.034] - copied ‘...future.globals.maxSize’ to environment
[17:38:21.034] assign_globals() ... done
[17:38:21.034] plan(): Setting new future strategy stack:
[17:38:21.034] List of future strategies:
[17:38:21.034] 1. sequential:
[17:38:21.034]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:21.034]    - tweaked: FALSE
[17:38:21.034]    - call: NULL
[17:38:21.035] plan(): nbrOfWorkers() = 1
[17:38:21.537] plan(): Setting new future strategy stack:
[17:38:21.537] List of future strategies:
[17:38:21.537] 1. sequential:
[17:38:21.537]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:21.537]    - tweaked: FALSE
[17:38:21.537]    - call: plan(strategy)
[17:38:21.538] plan(): nbrOfWorkers() = 1
[17:38:21.538] SequentialFuture started (and completed)
[17:38:21.538] - Launch lazy future ... done
[17:38:21.538] run() for ‘SequentialFuture’ ... done
[17:38:21.539] Created future:
[17:38:21.539] SequentialFuture:
[17:38:21.539] Label: ‘future_lapply-1’
[17:38:21.539] Expression:
[17:38:21.539] {
[17:38:21.539]     do.call(function(...) {
[17:38:21.539]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:21.539]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:21.539]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:21.539]             on.exit(options(oopts), add = TRUE)
[17:38:21.539]         }
[17:38:21.539]         {
[17:38:21.539]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:21.539]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:21.539]                 ...future.FUN(...future.X_jj, ...)
[17:38:21.539]             })
[17:38:21.539]         }
[17:38:21.539]     }, args = future.call.arguments)
[17:38:21.539] }
[17:38:21.539] Lazy evaluation: FALSE
[17:38:21.539] Asynchronous evaluation: FALSE
[17:38:21.539] Local evaluation: TRUE
[17:38:21.539] Environment: R_GlobalEnv
[17:38:21.539] Capture standard output: FALSE
[17:38:21.539] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:21.539] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:21.539] Packages: <none>
[17:38:21.539] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:21.539] Resolved: TRUE
[17:38:21.539] Value: 112 bytes of class ‘list’
[17:38:21.539] Early signaling: FALSE
[17:38:21.539] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:21.539] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:21.540] Chunk #1 of 1 ... DONE
[17:38:21.540] Launching 1 futures (chunks) ... DONE
[17:38:21.540] Resolving 1 futures (chunks) ...
[17:38:21.541] resolve() on list ...
[17:38:21.541]  recursive: 0
[17:38:21.541]  length: 1
[17:38:21.541] 
[17:38:21.541] resolved() for ‘SequentialFuture’ ...
[17:38:21.541] - state: ‘finished’
[17:38:21.541] - run: TRUE
[17:38:21.541] - result: ‘FutureResult’
[17:38:21.541] resolved() for ‘SequentialFuture’ ... done
[17:38:21.542] Future #1
[17:38:21.542] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:21.542] - nx: 1
[17:38:21.542] - relay: TRUE
[17:38:21.542] - stdout: TRUE
[17:38:21.542] - signal: TRUE
[17:38:21.542] - resignal: FALSE
[17:38:21.542] - force: TRUE
[17:38:21.543] - relayed: [n=1] FALSE
[17:38:21.543] - queued futures: [n=1] FALSE
[17:38:21.543]  - until=1
[17:38:21.543]  - relaying element #1
[17:38:21.543] - relayed: [n=1] TRUE
[17:38:21.543] - queued futures: [n=1] TRUE
[17:38:21.543] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:21.543]  length: 0 (resolved future 1)
[17:38:21.544] Relaying remaining futures
[17:38:21.544] signalConditionsASAP(NULL, pos=0) ...
[17:38:21.544] - nx: 1
[17:38:21.544] - relay: TRUE
[17:38:21.544] - stdout: TRUE
[17:38:21.544] - signal: TRUE
[17:38:21.544] - resignal: FALSE
[17:38:21.544] - force: TRUE
[17:38:21.544] - relayed: [n=1] TRUE
[17:38:21.544] - queued futures: [n=1] TRUE
 - flush all
[17:38:21.544] - relayed: [n=1] TRUE
[17:38:21.544] - queued futures: [n=1] TRUE
[17:38:21.545] signalConditionsASAP(NULL, pos=0) ... done
[17:38:21.545] resolve() on list ... DONE
[17:38:21.545]  - Number of value chunks collected: 1
[17:38:21.545] Resolving 1 futures (chunks) ... DONE
[17:38:21.545] Reducing values from 1 chunks ...
[17:38:21.545]  - Number of values collected after concatenation: 2
[17:38:21.545]  - Number of values expected: 2
[17:38:21.545] Reducing values from 1 chunks ... DONE
[17:38:21.545] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[17:38:21.546] future_lapply() ...
[17:38:21.546] Number of chunks: 1
[17:38:21.547] getGlobalsAndPackagesXApply() ...
[17:38:21.547]  - future.globals: TRUE
[17:38:21.547] getGlobalsAndPackages() ...
[17:38:21.547] Searching for globals...
[17:38:21.548] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:38:21.548] Searching for globals ... DONE
[17:38:21.548] Resolving globals: FALSE
[17:38:21.549] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:38:21.549] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:38:21.549] - globals: [1] ‘FUN’
[17:38:21.549] 
[17:38:21.549] getGlobalsAndPackages() ... DONE
[17:38:21.552]  - globals found/used: [n=1] ‘FUN’
[17:38:21.552]  - needed namespaces: [n=0] 
[17:38:21.552] Finding globals ... DONE
[17:38:21.552]  - use_args: TRUE
[17:38:21.552]  - Getting '...' globals ...
[17:38:21.552] resolve() on list ...
[17:38:21.552]  recursive: 0
[17:38:21.552]  length: 1
[17:38:21.553]  elements: ‘...’
[17:38:21.553]  length: 0 (resolved future 1)
[17:38:21.553] resolve() on list ... DONE
[17:38:21.553]    - '...' content: [n=0] 
[17:38:21.553] List of 1
[17:38:21.553]  $ ...: list()
[17:38:21.553]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:21.553]  - attr(*, "where")=List of 1
[17:38:21.553]   ..$ ...:<environment: 0x5628abf40250> 
[17:38:21.553]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:21.553]  - attr(*, "resolved")= logi TRUE
[17:38:21.553]  - attr(*, "total_size")= num NA
[17:38:21.556]  - Getting '...' globals ... DONE
[17:38:21.556] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:38:21.556] List of 2
[17:38:21.556]  $ ...future.FUN:function (x)  
[17:38:21.556]  $ ...          : list()
[17:38:21.556]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:21.556]  - attr(*, "where")=List of 2
[17:38:21.556]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:21.556]   ..$ ...          :<environment: 0x5628abf40250> 
[17:38:21.556]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:21.556]  - attr(*, "resolved")= logi FALSE
[17:38:21.556]  - attr(*, "total_size")= num 4720
[17:38:21.558] Packages to be attached in all futures: [n=0] 
[17:38:21.558] getGlobalsAndPackagesXApply() ... DONE
[17:38:21.559] Number of futures (= number of chunks): 1
[17:38:21.559] Launching 1 futures (chunks) ...
[17:38:21.559] Chunk #1 of 1 ...
[17:38:21.559]  - Finding globals in 'X' for chunk #1 ...
[17:38:21.559] getGlobalsAndPackages() ...
[17:38:21.559] Searching for globals...
[17:38:21.559] 
[17:38:21.560] Searching for globals ... DONE
[17:38:21.560] - globals: [0] <none>
[17:38:21.560] getGlobalsAndPackages() ... DONE
[17:38:21.560]    + additional globals found: [n=0] 
[17:38:21.560]    + additional namespaces needed: [n=0] 
[17:38:21.560]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:21.560]  - seeds: <none>
[17:38:21.560]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:21.560] getGlobalsAndPackages() ...
[17:38:21.560] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:21.560] Resolving globals: FALSE
[17:38:21.561] Tweak future expression to call with '...' arguments ...
[17:38:21.561] {
[17:38:21.561]     do.call(function(...) {
[17:38:21.561]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:21.561]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:21.561]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:21.561]             on.exit(options(oopts), add = TRUE)
[17:38:21.561]         }
[17:38:21.561]         {
[17:38:21.561]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:21.561]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:21.561]                 ...future.FUN(...future.X_jj, ...)
[17:38:21.561]             })
[17:38:21.561]         }
[17:38:21.561]     }, args = future.call.arguments)
[17:38:21.561] }
[17:38:21.561] Tweak future expression to call with '...' arguments ... DONE
[17:38:21.561] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:21.561] 
[17:38:21.561] getGlobalsAndPackages() ... DONE
[17:38:21.562] run() for ‘Future’ ...
[17:38:21.562] - state: ‘created’
[17:38:21.562] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:38:21.562] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:21.562] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:21.562]   - Field: ‘label’
[17:38:21.563]   - Field: ‘local’
[17:38:21.563]   - Field: ‘owner’
[17:38:21.563]   - Field: ‘envir’
[17:38:21.563]   - Field: ‘packages’
[17:38:21.563]   - Field: ‘gc’
[17:38:21.563]   - Field: ‘conditions’
[17:38:21.563]   - Field: ‘expr’
[17:38:21.563]   - Field: ‘uuid’
[17:38:21.563]   - Field: ‘seed’
[17:38:21.563]   - Field: ‘version’
[17:38:21.563]   - Field: ‘result’
[17:38:21.564]   - Field: ‘asynchronous’
[17:38:21.564]   - Field: ‘calls’
[17:38:21.564]   - Field: ‘globals’
[17:38:21.564]   - Field: ‘stdout’
[17:38:21.564]   - Field: ‘earlySignal’
[17:38:21.564]   - Field: ‘lazy’
[17:38:21.564]   - Field: ‘state’
[17:38:21.564] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:21.564] - Launch lazy future ...
[17:38:21.564] Packages needed by the future expression (n = 0): <none>
[17:38:21.565] Packages needed by future strategies (n = 0): <none>
[17:38:21.565] {
[17:38:21.565]     {
[17:38:21.565]         {
[17:38:21.565]             ...future.startTime <- base::Sys.time()
[17:38:21.565]             {
[17:38:21.565]                 {
[17:38:21.565]                   {
[17:38:21.565]                     base::local({
[17:38:21.565]                       has_future <- base::requireNamespace("future", 
[17:38:21.565]                         quietly = TRUE)
[17:38:21.565]                       if (has_future) {
[17:38:21.565]                         ns <- base::getNamespace("future")
[17:38:21.565]                         version <- ns[[".package"]][["version"]]
[17:38:21.565]                         if (is.null(version)) 
[17:38:21.565]                           version <- utils::packageVersion("future")
[17:38:21.565]                       }
[17:38:21.565]                       else {
[17:38:21.565]                         version <- NULL
[17:38:21.565]                       }
[17:38:21.565]                       if (!has_future || version < "1.8.0") {
[17:38:21.565]                         info <- base::c(r_version = base::gsub("R version ", 
[17:38:21.565]                           "", base::R.version$version.string), 
[17:38:21.565]                           platform = base::sprintf("%s (%s-bit)", 
[17:38:21.565]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:21.565]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:21.565]                             "release", "version")], collapse = " "), 
[17:38:21.565]                           hostname = base::Sys.info()[["nodename"]])
[17:38:21.565]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:38:21.565]                           info)
[17:38:21.565]                         info <- base::paste(info, collapse = "; ")
[17:38:21.565]                         if (!has_future) {
[17:38:21.565]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:21.565]                             info)
[17:38:21.565]                         }
[17:38:21.565]                         else {
[17:38:21.565]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:21.565]                             info, version)
[17:38:21.565]                         }
[17:38:21.565]                         base::stop(msg)
[17:38:21.565]                       }
[17:38:21.565]                     })
[17:38:21.565]                   }
[17:38:21.565]                   ...future.strategy.old <- future::plan("list")
[17:38:21.565]                   options(future.plan = NULL)
[17:38:21.565]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:21.565]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:21.565]                 }
[17:38:21.565]                 ...future.workdir <- getwd()
[17:38:21.565]             }
[17:38:21.565]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:21.565]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:21.565]         }
[17:38:21.565]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:21.565]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:21.565]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:21.565]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:21.565]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:21.565]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:21.565]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:21.565]             base::names(...future.oldOptions))
[17:38:21.565]     }
[17:38:21.565]     if (FALSE) {
[17:38:21.565]     }
[17:38:21.565]     else {
[17:38:21.565]         if (TRUE) {
[17:38:21.565]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:21.565]                 open = "w")
[17:38:21.565]         }
[17:38:21.565]         else {
[17:38:21.565]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:21.565]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:21.565]         }
[17:38:21.565]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:21.565]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:21.565]             base::sink(type = "output", split = FALSE)
[17:38:21.565]             base::close(...future.stdout)
[17:38:21.565]         }, add = TRUE)
[17:38:21.565]     }
[17:38:21.565]     ...future.frame <- base::sys.nframe()
[17:38:21.565]     ...future.conditions <- base::list()
[17:38:21.565]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:21.565]     if (FALSE) {
[17:38:21.565]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:21.565]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:21.565]     }
[17:38:21.565]     ...future.result <- base::tryCatch({
[17:38:21.565]         base::withCallingHandlers({
[17:38:21.565]             ...future.value <- base::withVisible(base::local({
[17:38:21.565]                 do.call(function(...) {
[17:38:21.565]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:21.565]                   if (!identical(...future.globals.maxSize.org, 
[17:38:21.565]                     ...future.globals.maxSize)) {
[17:38:21.565]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:21.565]                     on.exit(options(oopts), add = TRUE)
[17:38:21.565]                   }
[17:38:21.565]                   {
[17:38:21.565]                     lapply(seq_along(...future.elements_ii), 
[17:38:21.565]                       FUN = function(jj) {
[17:38:21.565]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:21.565]                         ...future.FUN(...future.X_jj, ...)
[17:38:21.565]                       })
[17:38:21.565]                   }
[17:38:21.565]                 }, args = future.call.arguments)
[17:38:21.565]             }))
[17:38:21.565]             future::FutureResult(value = ...future.value$value, 
[17:38:21.565]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:21.565]                   ...future.rng), globalenv = if (FALSE) 
[17:38:21.565]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:21.565]                     ...future.globalenv.names))
[17:38:21.565]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:21.565]         }, condition = base::local({
[17:38:21.565]             c <- base::c
[17:38:21.565]             inherits <- base::inherits
[17:38:21.565]             invokeRestart <- base::invokeRestart
[17:38:21.565]             length <- base::length
[17:38:21.565]             list <- base::list
[17:38:21.565]             seq.int <- base::seq.int
[17:38:21.565]             signalCondition <- base::signalCondition
[17:38:21.565]             sys.calls <- base::sys.calls
[17:38:21.565]             `[[` <- base::`[[`
[17:38:21.565]             `+` <- base::`+`
[17:38:21.565]             `<<-` <- base::`<<-`
[17:38:21.565]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:21.565]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:21.565]                   3L)]
[17:38:21.565]             }
[17:38:21.565]             function(cond) {
[17:38:21.565]                 is_error <- inherits(cond, "error")
[17:38:21.565]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:21.565]                   NULL)
[17:38:21.565]                 if (is_error) {
[17:38:21.565]                   sessionInformation <- function() {
[17:38:21.565]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:21.565]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:21.565]                       search = base::search(), system = base::Sys.info())
[17:38:21.565]                   }
[17:38:21.565]                   ...future.conditions[[length(...future.conditions) + 
[17:38:21.565]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:21.565]                     cond$call), session = sessionInformation(), 
[17:38:21.565]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:21.565]                   signalCondition(cond)
[17:38:21.565]                 }
[17:38:21.565]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:21.565]                 "immediateCondition"))) {
[17:38:21.565]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:21.565]                   ...future.conditions[[length(...future.conditions) + 
[17:38:21.565]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:21.565]                   if (TRUE && !signal) {
[17:38:21.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:21.565]                     {
[17:38:21.565]                       inherits <- base::inherits
[17:38:21.565]                       invokeRestart <- base::invokeRestart
[17:38:21.565]                       is.null <- base::is.null
[17:38:21.565]                       muffled <- FALSE
[17:38:21.565]                       if (inherits(cond, "message")) {
[17:38:21.565]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:21.565]                         if (muffled) 
[17:38:21.565]                           invokeRestart("muffleMessage")
[17:38:21.565]                       }
[17:38:21.565]                       else if (inherits(cond, "warning")) {
[17:38:21.565]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:21.565]                         if (muffled) 
[17:38:21.565]                           invokeRestart("muffleWarning")
[17:38:21.565]                       }
[17:38:21.565]                       else if (inherits(cond, "condition")) {
[17:38:21.565]                         if (!is.null(pattern)) {
[17:38:21.565]                           computeRestarts <- base::computeRestarts
[17:38:21.565]                           grepl <- base::grepl
[17:38:21.565]                           restarts <- computeRestarts(cond)
[17:38:21.565]                           for (restart in restarts) {
[17:38:21.565]                             name <- restart$name
[17:38:21.565]                             if (is.null(name)) 
[17:38:21.565]                               next
[17:38:21.565]                             if (!grepl(pattern, name)) 
[17:38:21.565]                               next
[17:38:21.565]                             invokeRestart(restart)
[17:38:21.565]                             muffled <- TRUE
[17:38:21.565]                             break
[17:38:21.565]                           }
[17:38:21.565]                         }
[17:38:21.565]                       }
[17:38:21.565]                       invisible(muffled)
[17:38:21.565]                     }
[17:38:21.565]                     muffleCondition(cond, pattern = "^muffle")
[17:38:21.565]                   }
[17:38:21.565]                 }
[17:38:21.565]                 else {
[17:38:21.565]                   if (TRUE) {
[17:38:21.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:21.565]                     {
[17:38:21.565]                       inherits <- base::inherits
[17:38:21.565]                       invokeRestart <- base::invokeRestart
[17:38:21.565]                       is.null <- base::is.null
[17:38:21.565]                       muffled <- FALSE
[17:38:21.565]                       if (inherits(cond, "message")) {
[17:38:21.565]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:21.565]                         if (muffled) 
[17:38:21.565]                           invokeRestart("muffleMessage")
[17:38:21.565]                       }
[17:38:21.565]                       else if (inherits(cond, "warning")) {
[17:38:21.565]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:21.565]                         if (muffled) 
[17:38:21.565]                           invokeRestart("muffleWarning")
[17:38:21.565]                       }
[17:38:21.565]                       else if (inherits(cond, "condition")) {
[17:38:21.565]                         if (!is.null(pattern)) {
[17:38:21.565]                           computeRestarts <- base::computeRestarts
[17:38:21.565]                           grepl <- base::grepl
[17:38:21.565]                           restarts <- computeRestarts(cond)
[17:38:21.565]                           for (restart in restarts) {
[17:38:21.565]                             name <- restart$name
[17:38:21.565]                             if (is.null(name)) 
[17:38:21.565]                               next
[17:38:21.565]                             if (!grepl(pattern, name)) 
[17:38:21.565]                               next
[17:38:21.565]                             invokeRestart(restart)
[17:38:21.565]                             muffled <- TRUE
[17:38:21.565]                             break
[17:38:21.565]                           }
[17:38:21.565]                         }
[17:38:21.565]                       }
[17:38:21.565]                       invisible(muffled)
[17:38:21.565]                     }
[17:38:21.565]                     muffleCondition(cond, pattern = "^muffle")
[17:38:21.565]                   }
[17:38:21.565]                 }
[17:38:21.565]             }
[17:38:21.565]         }))
[17:38:21.565]     }, error = function(ex) {
[17:38:21.565]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:21.565]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:21.565]                 ...future.rng), started = ...future.startTime, 
[17:38:21.565]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:21.565]             version = "1.8"), class = "FutureResult")
[17:38:21.565]     }, finally = {
[17:38:21.565]         if (!identical(...future.workdir, getwd())) 
[17:38:21.565]             setwd(...future.workdir)
[17:38:21.565]         {
[17:38:21.565]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:21.565]                 ...future.oldOptions$nwarnings <- NULL
[17:38:21.565]             }
[17:38:21.565]             base::options(...future.oldOptions)
[17:38:21.565]             if (.Platform$OS.type == "windows") {
[17:38:21.565]                 old_names <- names(...future.oldEnvVars)
[17:38:21.565]                 envs <- base::Sys.getenv()
[17:38:21.565]                 names <- names(envs)
[17:38:21.565]                 common <- intersect(names, old_names)
[17:38:21.565]                 added <- setdiff(names, old_names)
[17:38:21.565]                 removed <- setdiff(old_names, names)
[17:38:21.565]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:21.565]                   envs[common]]
[17:38:21.565]                 NAMES <- toupper(changed)
[17:38:21.565]                 args <- list()
[17:38:21.565]                 for (kk in seq_along(NAMES)) {
[17:38:21.565]                   name <- changed[[kk]]
[17:38:21.565]                   NAME <- NAMES[[kk]]
[17:38:21.565]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:21.565]                     next
[17:38:21.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:21.565]                 }
[17:38:21.565]                 NAMES <- toupper(added)
[17:38:21.565]                 for (kk in seq_along(NAMES)) {
[17:38:21.565]                   name <- added[[kk]]
[17:38:21.565]                   NAME <- NAMES[[kk]]
[17:38:21.565]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:21.565]                     next
[17:38:21.565]                   args[[name]] <- ""
[17:38:21.565]                 }
[17:38:21.565]                 NAMES <- toupper(removed)
[17:38:21.565]                 for (kk in seq_along(NAMES)) {
[17:38:21.565]                   name <- removed[[kk]]
[17:38:21.565]                   NAME <- NAMES[[kk]]
[17:38:21.565]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:21.565]                     next
[17:38:21.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:21.565]                 }
[17:38:21.565]                 if (length(args) > 0) 
[17:38:21.565]                   base::do.call(base::Sys.setenv, args = args)
[17:38:21.565]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:21.565]             }
[17:38:21.565]             else {
[17:38:21.565]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:21.565]             }
[17:38:21.565]             {
[17:38:21.565]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:21.565]                   0L) {
[17:38:21.565]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:21.565]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:21.565]                   base::options(opts)
[17:38:21.565]                 }
[17:38:21.565]                 {
[17:38:21.565]                   {
[17:38:21.565]                     NULL
[17:38:21.565]                     RNGkind("Mersenne-Twister")
[17:38:21.565]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:21.565]                       inherits = FALSE)
[17:38:21.565]                   }
[17:38:21.565]                   options(future.plan = NULL)
[17:38:21.565]                   if (is.na(NA_character_)) 
[17:38:21.565]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:21.565]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:21.565]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:21.565]                     .init = FALSE)
[17:38:21.565]                 }
[17:38:21.565]             }
[17:38:21.565]         }
[17:38:21.565]     })
[17:38:21.565]     if (TRUE) {
[17:38:21.565]         base::sink(type = "output", split = FALSE)
[17:38:21.565]         if (TRUE) {
[17:38:21.565]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:21.565]         }
[17:38:21.565]         else {
[17:38:21.565]             ...future.result["stdout"] <- base::list(NULL)
[17:38:21.565]         }
[17:38:21.565]         base::close(...future.stdout)
[17:38:21.565]         ...future.stdout <- NULL
[17:38:21.565]     }
[17:38:21.565]     ...future.result$conditions <- ...future.conditions
[17:38:21.565]     ...future.result$finished <- base::Sys.time()
[17:38:21.565]     ...future.result
[17:38:21.565] }
[17:38:21.567] assign_globals() ...
[17:38:21.567] List of 5
[17:38:21.567]  $ ...future.FUN            :function (x)  
[17:38:21.567]  $ future.call.arguments    : list()
[17:38:21.567]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:21.567]  $ ...future.elements_ii    :List of 2
[17:38:21.567]   ..$ : int 1
[17:38:21.567]   ..$ : int 0
[17:38:21.567]  $ ...future.seeds_ii       : NULL
[17:38:21.567]  $ ...future.globals.maxSize: NULL
[17:38:21.567]  - attr(*, "where")=List of 5
[17:38:21.567]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:21.567]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:21.567]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:21.567]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:21.567]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:21.567]  - attr(*, "resolved")= logi FALSE
[17:38:21.567]  - attr(*, "total_size")= num 4720
[17:38:21.567]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:21.567]  - attr(*, "already-done")= logi TRUE
[17:38:21.571] - reassign environment for ‘...future.FUN’
[17:38:21.572] - copied ‘...future.FUN’ to environment
[17:38:21.572] - copied ‘future.call.arguments’ to environment
[17:38:21.572] - copied ‘...future.elements_ii’ to environment
[17:38:21.572] - copied ‘...future.seeds_ii’ to environment
[17:38:21.572] - copied ‘...future.globals.maxSize’ to environment
[17:38:21.572] assign_globals() ... done
[17:38:21.572] plan(): Setting new future strategy stack:
[17:38:21.572] List of future strategies:
[17:38:21.572] 1. sequential:
[17:38:21.572]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:21.572]    - tweaked: FALSE
[17:38:21.572]    - call: NULL
[17:38:21.573] plan(): nbrOfWorkers() = 1
[17:38:22.075] plan(): Setting new future strategy stack:
[17:38:22.075] List of future strategies:
[17:38:22.075] 1. sequential:
[17:38:22.075]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:22.075]    - tweaked: FALSE
[17:38:22.075]    - call: plan(strategy)
[17:38:22.075] plan(): nbrOfWorkers() = 1
[17:38:22.076] SequentialFuture started (and completed)
[17:38:22.076] - Launch lazy future ... done
[17:38:22.076] run() for ‘SequentialFuture’ ... done
[17:38:22.076] Created future:
[17:38:22.076] SequentialFuture:
[17:38:22.076] Label: ‘future_lapply-1’
[17:38:22.076] Expression:
[17:38:22.076] {
[17:38:22.076]     do.call(function(...) {
[17:38:22.076]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:22.076]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:22.076]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:22.076]             on.exit(options(oopts), add = TRUE)
[17:38:22.076]         }
[17:38:22.076]         {
[17:38:22.076]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:22.076]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:22.076]                 ...future.FUN(...future.X_jj, ...)
[17:38:22.076]             })
[17:38:22.076]         }
[17:38:22.076]     }, args = future.call.arguments)
[17:38:22.076] }
[17:38:22.076] Lazy evaluation: FALSE
[17:38:22.076] Asynchronous evaluation: FALSE
[17:38:22.076] Local evaluation: TRUE
[17:38:22.076] Environment: R_GlobalEnv
[17:38:22.076] Capture standard output: TRUE
[17:38:22.076] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:22.076] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:22.076] Packages: <none>
[17:38:22.076] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:22.076] Resolved: TRUE
[17:38:22.076] Value: 112 bytes of class ‘list’
[17:38:22.076] Early signaling: FALSE
[17:38:22.076] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:22.076] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:22.077] Chunk #1 of 1 ... DONE
[17:38:22.077] Launching 1 futures (chunks) ... DONE
[17:38:22.077] Resolving 1 futures (chunks) ...
[17:38:22.078] resolve() on list ...
[17:38:22.078]  recursive: 0
[17:38:22.078]  length: 1
[17:38:22.078] 
[17:38:22.078] resolved() for ‘SequentialFuture’ ...
[17:38:22.078] - state: ‘finished’
[17:38:22.078] - run: TRUE
[17:38:22.078] - result: ‘FutureResult’
[17:38:22.078] resolved() for ‘SequentialFuture’ ... done
[17:38:22.078] Future #1
[17:38:22.079] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:22.079] - nx: 1
[17:38:22.079] - relay: TRUE
[17:38:22.079] - stdout: TRUE
[17:38:22.079] - signal: TRUE
[17:38:22.079] - resignal: FALSE
[17:38:22.081] - force: TRUE
[17:38:22.081] - relayed: [n=1] FALSE
[17:38:22.081] - queued futures: [n=1] FALSE
[17:38:22.081]  - until=1
[17:38:22.081]  - relaying element #1
[17:38:22.081] - relayed: [n=1] TRUE
[17:38:22.081] - queued futures: [n=1] TRUE
[17:38:22.082] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:22.082]  length: 0 (resolved future 1)
[17:38:22.082] Relaying remaining futures
[17:38:22.082] signalConditionsASAP(NULL, pos=0) ...
[17:38:22.082] - nx: 1
[17:38:22.082] - relay: TRUE
[17:38:22.082] - stdout: TRUE
[17:38:22.082] - signal: TRUE
[17:38:22.082] - resignal: FALSE
[17:38:22.082] - force: TRUE
[17:38:22.082] - relayed: [n=1] TRUE
[17:38:22.082] - queued futures: [n=1] TRUE
 - flush all
[17:38:22.083] - relayed: [n=1] TRUE
[17:38:22.083] - queued futures: [n=1] TRUE
[17:38:22.083] signalConditionsASAP(NULL, pos=0) ... done
[17:38:22.083] resolve() on list ... DONE
[17:38:22.083]  - Number of value chunks collected: 1
[17:38:22.083] Resolving 1 futures (chunks) ... DONE
[17:38:22.083] Reducing values from 1 chunks ...
[17:38:22.083]  - Number of values collected after concatenation: 2
[17:38:22.083]  - Number of values expected: 2
[17:38:22.084] Reducing values from 1 chunks ... DONE
[17:38:22.084] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[17:38:22.084] future_lapply() ...
[17:38:22.085] Number of chunks: 1
[17:38:22.085] getGlobalsAndPackagesXApply() ...
[17:38:22.085]  - future.globals: TRUE
[17:38:22.085] getGlobalsAndPackages() ...
[17:38:22.085] Searching for globals...
[17:38:22.086] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:38:22.086] Searching for globals ... DONE
[17:38:22.087] Resolving globals: FALSE
[17:38:22.087] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:38:22.087] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:38:22.087] - globals: [1] ‘FUN’
[17:38:22.088] 
[17:38:22.088] getGlobalsAndPackages() ... DONE
[17:38:22.088]  - globals found/used: [n=1] ‘FUN’
[17:38:22.088]  - needed namespaces: [n=0] 
[17:38:22.088] Finding globals ... DONE
[17:38:22.088]  - use_args: TRUE
[17:38:22.088]  - Getting '...' globals ...
[17:38:22.088] resolve() on list ...
[17:38:22.088]  recursive: 0
[17:38:22.089]  length: 1
[17:38:22.089]  elements: ‘...’
[17:38:22.089]  length: 0 (resolved future 1)
[17:38:22.089] resolve() on list ... DONE
[17:38:22.089]    - '...' content: [n=0] 
[17:38:22.089] List of 1
[17:38:22.089]  $ ...: list()
[17:38:22.089]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:22.089]  - attr(*, "where")=List of 1
[17:38:22.089]   ..$ ...:<environment: 0x5628aa1955e0> 
[17:38:22.089]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:22.089]  - attr(*, "resolved")= logi TRUE
[17:38:22.089]  - attr(*, "total_size")= num NA
[17:38:22.092]  - Getting '...' globals ... DONE
[17:38:22.092] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:38:22.092] List of 2
[17:38:22.092]  $ ...future.FUN:function (x)  
[17:38:22.092]  $ ...          : list()
[17:38:22.092]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:22.092]  - attr(*, "where")=List of 2
[17:38:22.092]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:22.092]   ..$ ...          :<environment: 0x5628aa1955e0> 
[17:38:22.092]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:22.092]  - attr(*, "resolved")= logi FALSE
[17:38:22.092]  - attr(*, "total_size")= num 4720
[17:38:22.094] Packages to be attached in all futures: [n=0] 
[17:38:22.095] getGlobalsAndPackagesXApply() ... DONE
[17:38:22.095] Number of futures (= number of chunks): 1
[17:38:22.095] Launching 1 futures (chunks) ...
[17:38:22.095] Chunk #1 of 1 ...
[17:38:22.095]  - Finding globals in 'X' for chunk #1 ...
[17:38:22.095] getGlobalsAndPackages() ...
[17:38:22.095] Searching for globals...
[17:38:22.095] 
[17:38:22.096] Searching for globals ... DONE
[17:38:22.096] - globals: [0] <none>
[17:38:22.096] getGlobalsAndPackages() ... DONE
[17:38:22.096]    + additional globals found: [n=0] 
[17:38:22.096]    + additional namespaces needed: [n=0] 
[17:38:22.096]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:22.096]  - seeds: <none>
[17:38:22.096]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:22.096] getGlobalsAndPackages() ...
[17:38:22.096] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:22.097] Resolving globals: FALSE
[17:38:22.097] Tweak future expression to call with '...' arguments ...
[17:38:22.097] {
[17:38:22.097]     do.call(function(...) {
[17:38:22.097]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:22.097]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:22.097]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:22.097]             on.exit(options(oopts), add = TRUE)
[17:38:22.097]         }
[17:38:22.097]         {
[17:38:22.097]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:22.097]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:22.097]                 ...future.FUN(...future.X_jj, ...)
[17:38:22.097]             })
[17:38:22.097]         }
[17:38:22.097]     }, args = future.call.arguments)
[17:38:22.097] }
[17:38:22.097] Tweak future expression to call with '...' arguments ... DONE
[17:38:22.097] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:22.097] 
[17:38:22.098] getGlobalsAndPackages() ... DONE
[17:38:22.098] run() for ‘Future’ ...
[17:38:22.098] - state: ‘created’
[17:38:22.098] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:38:22.098] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:22.098] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:22.099]   - Field: ‘label’
[17:38:22.099]   - Field: ‘local’
[17:38:22.099]   - Field: ‘owner’
[17:38:22.099]   - Field: ‘envir’
[17:38:22.099]   - Field: ‘packages’
[17:38:22.099]   - Field: ‘gc’
[17:38:22.099]   - Field: ‘conditions’
[17:38:22.099]   - Field: ‘expr’
[17:38:22.099]   - Field: ‘uuid’
[17:38:22.099]   - Field: ‘seed’
[17:38:22.099]   - Field: ‘version’
[17:38:22.100]   - Field: ‘result’
[17:38:22.100]   - Field: ‘asynchronous’
[17:38:22.100]   - Field: ‘calls’
[17:38:22.100]   - Field: ‘globals’
[17:38:22.100]   - Field: ‘stdout’
[17:38:22.100]   - Field: ‘earlySignal’
[17:38:22.100]   - Field: ‘lazy’
[17:38:22.100]   - Field: ‘state’
[17:38:22.100] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:22.100] - Launch lazy future ...
[17:38:22.101] Packages needed by the future expression (n = 0): <none>
[17:38:22.101] Packages needed by future strategies (n = 0): <none>
[17:38:22.101] {
[17:38:22.101]     {
[17:38:22.101]         {
[17:38:22.101]             ...future.startTime <- base::Sys.time()
[17:38:22.101]             {
[17:38:22.101]                 {
[17:38:22.101]                   {
[17:38:22.101]                     base::local({
[17:38:22.101]                       has_future <- base::requireNamespace("future", 
[17:38:22.101]                         quietly = TRUE)
[17:38:22.101]                       if (has_future) {
[17:38:22.101]                         ns <- base::getNamespace("future")
[17:38:22.101]                         version <- ns[[".package"]][["version"]]
[17:38:22.101]                         if (is.null(version)) 
[17:38:22.101]                           version <- utils::packageVersion("future")
[17:38:22.101]                       }
[17:38:22.101]                       else {
[17:38:22.101]                         version <- NULL
[17:38:22.101]                       }
[17:38:22.101]                       if (!has_future || version < "1.8.0") {
[17:38:22.101]                         info <- base::c(r_version = base::gsub("R version ", 
[17:38:22.101]                           "", base::R.version$version.string), 
[17:38:22.101]                           platform = base::sprintf("%s (%s-bit)", 
[17:38:22.101]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:22.101]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:22.101]                             "release", "version")], collapse = " "), 
[17:38:22.101]                           hostname = base::Sys.info()[["nodename"]])
[17:38:22.101]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:38:22.101]                           info)
[17:38:22.101]                         info <- base::paste(info, collapse = "; ")
[17:38:22.101]                         if (!has_future) {
[17:38:22.101]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:22.101]                             info)
[17:38:22.101]                         }
[17:38:22.101]                         else {
[17:38:22.101]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:22.101]                             info, version)
[17:38:22.101]                         }
[17:38:22.101]                         base::stop(msg)
[17:38:22.101]                       }
[17:38:22.101]                     })
[17:38:22.101]                   }
[17:38:22.101]                   ...future.strategy.old <- future::plan("list")
[17:38:22.101]                   options(future.plan = NULL)
[17:38:22.101]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:22.101]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:22.101]                 }
[17:38:22.101]                 ...future.workdir <- getwd()
[17:38:22.101]             }
[17:38:22.101]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:22.101]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:22.101]         }
[17:38:22.101]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:22.101]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:22.101]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:22.101]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:22.101]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:22.101]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:22.101]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:22.101]             base::names(...future.oldOptions))
[17:38:22.101]     }
[17:38:22.101]     if (TRUE) {
[17:38:22.101]     }
[17:38:22.101]     else {
[17:38:22.101]         if (NA) {
[17:38:22.101]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:22.101]                 open = "w")
[17:38:22.101]         }
[17:38:22.101]         else {
[17:38:22.101]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:22.101]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:22.101]         }
[17:38:22.101]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:22.101]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:22.101]             base::sink(type = "output", split = FALSE)
[17:38:22.101]             base::close(...future.stdout)
[17:38:22.101]         }, add = TRUE)
[17:38:22.101]     }
[17:38:22.101]     ...future.frame <- base::sys.nframe()
[17:38:22.101]     ...future.conditions <- base::list()
[17:38:22.101]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:22.101]     if (FALSE) {
[17:38:22.101]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:22.101]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:22.101]     }
[17:38:22.101]     ...future.result <- base::tryCatch({
[17:38:22.101]         base::withCallingHandlers({
[17:38:22.101]             ...future.value <- base::withVisible(base::local({
[17:38:22.101]                 do.call(function(...) {
[17:38:22.101]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:22.101]                   if (!identical(...future.globals.maxSize.org, 
[17:38:22.101]                     ...future.globals.maxSize)) {
[17:38:22.101]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:22.101]                     on.exit(options(oopts), add = TRUE)
[17:38:22.101]                   }
[17:38:22.101]                   {
[17:38:22.101]                     lapply(seq_along(...future.elements_ii), 
[17:38:22.101]                       FUN = function(jj) {
[17:38:22.101]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:22.101]                         ...future.FUN(...future.X_jj, ...)
[17:38:22.101]                       })
[17:38:22.101]                   }
[17:38:22.101]                 }, args = future.call.arguments)
[17:38:22.101]             }))
[17:38:22.101]             future::FutureResult(value = ...future.value$value, 
[17:38:22.101]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:22.101]                   ...future.rng), globalenv = if (FALSE) 
[17:38:22.101]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:22.101]                     ...future.globalenv.names))
[17:38:22.101]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:22.101]         }, condition = base::local({
[17:38:22.101]             c <- base::c
[17:38:22.101]             inherits <- base::inherits
[17:38:22.101]             invokeRestart <- base::invokeRestart
[17:38:22.101]             length <- base::length
[17:38:22.101]             list <- base::list
[17:38:22.101]             seq.int <- base::seq.int
[17:38:22.101]             signalCondition <- base::signalCondition
[17:38:22.101]             sys.calls <- base::sys.calls
[17:38:22.101]             `[[` <- base::`[[`
[17:38:22.101]             `+` <- base::`+`
[17:38:22.101]             `<<-` <- base::`<<-`
[17:38:22.101]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:22.101]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:22.101]                   3L)]
[17:38:22.101]             }
[17:38:22.101]             function(cond) {
[17:38:22.101]                 is_error <- inherits(cond, "error")
[17:38:22.101]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:22.101]                   NULL)
[17:38:22.101]                 if (is_error) {
[17:38:22.101]                   sessionInformation <- function() {
[17:38:22.101]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:22.101]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:22.101]                       search = base::search(), system = base::Sys.info())
[17:38:22.101]                   }
[17:38:22.101]                   ...future.conditions[[length(...future.conditions) + 
[17:38:22.101]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:22.101]                     cond$call), session = sessionInformation(), 
[17:38:22.101]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:22.101]                   signalCondition(cond)
[17:38:22.101]                 }
[17:38:22.101]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:22.101]                 "immediateCondition"))) {
[17:38:22.101]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:22.101]                   ...future.conditions[[length(...future.conditions) + 
[17:38:22.101]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:22.101]                   if (TRUE && !signal) {
[17:38:22.101]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:22.101]                     {
[17:38:22.101]                       inherits <- base::inherits
[17:38:22.101]                       invokeRestart <- base::invokeRestart
[17:38:22.101]                       is.null <- base::is.null
[17:38:22.101]                       muffled <- FALSE
[17:38:22.101]                       if (inherits(cond, "message")) {
[17:38:22.101]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:22.101]                         if (muffled) 
[17:38:22.101]                           invokeRestart("muffleMessage")
[17:38:22.101]                       }
[17:38:22.101]                       else if (inherits(cond, "warning")) {
[17:38:22.101]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:22.101]                         if (muffled) 
[17:38:22.101]                           invokeRestart("muffleWarning")
[17:38:22.101]                       }
[17:38:22.101]                       else if (inherits(cond, "condition")) {
[17:38:22.101]                         if (!is.null(pattern)) {
[17:38:22.101]                           computeRestarts <- base::computeRestarts
[17:38:22.101]                           grepl <- base::grepl
[17:38:22.101]                           restarts <- computeRestarts(cond)
[17:38:22.101]                           for (restart in restarts) {
[17:38:22.101]                             name <- restart$name
[17:38:22.101]                             if (is.null(name)) 
[17:38:22.101]                               next
[17:38:22.101]                             if (!grepl(pattern, name)) 
[17:38:22.101]                               next
[17:38:22.101]                             invokeRestart(restart)
[17:38:22.101]                             muffled <- TRUE
[17:38:22.101]                             break
[17:38:22.101]                           }
[17:38:22.101]                         }
[17:38:22.101]                       }
[17:38:22.101]                       invisible(muffled)
[17:38:22.101]                     }
[17:38:22.101]                     muffleCondition(cond, pattern = "^muffle")
[17:38:22.101]                   }
[17:38:22.101]                 }
[17:38:22.101]                 else {
[17:38:22.101]                   if (TRUE) {
[17:38:22.101]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:22.101]                     {
[17:38:22.101]                       inherits <- base::inherits
[17:38:22.101]                       invokeRestart <- base::invokeRestart
[17:38:22.101]                       is.null <- base::is.null
[17:38:22.101]                       muffled <- FALSE
[17:38:22.101]                       if (inherits(cond, "message")) {
[17:38:22.101]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:22.101]                         if (muffled) 
[17:38:22.101]                           invokeRestart("muffleMessage")
[17:38:22.101]                       }
[17:38:22.101]                       else if (inherits(cond, "warning")) {
[17:38:22.101]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:22.101]                         if (muffled) 
[17:38:22.101]                           invokeRestart("muffleWarning")
[17:38:22.101]                       }
[17:38:22.101]                       else if (inherits(cond, "condition")) {
[17:38:22.101]                         if (!is.null(pattern)) {
[17:38:22.101]                           computeRestarts <- base::computeRestarts
[17:38:22.101]                           grepl <- base::grepl
[17:38:22.101]                           restarts <- computeRestarts(cond)
[17:38:22.101]                           for (restart in restarts) {
[17:38:22.101]                             name <- restart$name
[17:38:22.101]                             if (is.null(name)) 
[17:38:22.101]                               next
[17:38:22.101]                             if (!grepl(pattern, name)) 
[17:38:22.101]                               next
[17:38:22.101]                             invokeRestart(restart)
[17:38:22.101]                             muffled <- TRUE
[17:38:22.101]                             break
[17:38:22.101]                           }
[17:38:22.101]                         }
[17:38:22.101]                       }
[17:38:22.101]                       invisible(muffled)
[17:38:22.101]                     }
[17:38:22.101]                     muffleCondition(cond, pattern = "^muffle")
[17:38:22.101]                   }
[17:38:22.101]                 }
[17:38:22.101]             }
[17:38:22.101]         }))
[17:38:22.101]     }, error = function(ex) {
[17:38:22.101]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:22.101]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:22.101]                 ...future.rng), started = ...future.startTime, 
[17:38:22.101]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:22.101]             version = "1.8"), class = "FutureResult")
[17:38:22.101]     }, finally = {
[17:38:22.101]         if (!identical(...future.workdir, getwd())) 
[17:38:22.101]             setwd(...future.workdir)
[17:38:22.101]         {
[17:38:22.101]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:22.101]                 ...future.oldOptions$nwarnings <- NULL
[17:38:22.101]             }
[17:38:22.101]             base::options(...future.oldOptions)
[17:38:22.101]             if (.Platform$OS.type == "windows") {
[17:38:22.101]                 old_names <- names(...future.oldEnvVars)
[17:38:22.101]                 envs <- base::Sys.getenv()
[17:38:22.101]                 names <- names(envs)
[17:38:22.101]                 common <- intersect(names, old_names)
[17:38:22.101]                 added <- setdiff(names, old_names)
[17:38:22.101]                 removed <- setdiff(old_names, names)
[17:38:22.101]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:22.101]                   envs[common]]
[17:38:22.101]                 NAMES <- toupper(changed)
[17:38:22.101]                 args <- list()
[17:38:22.101]                 for (kk in seq_along(NAMES)) {
[17:38:22.101]                   name <- changed[[kk]]
[17:38:22.101]                   NAME <- NAMES[[kk]]
[17:38:22.101]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:22.101]                     next
[17:38:22.101]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:22.101]                 }
[17:38:22.101]                 NAMES <- toupper(added)
[17:38:22.101]                 for (kk in seq_along(NAMES)) {
[17:38:22.101]                   name <- added[[kk]]
[17:38:22.101]                   NAME <- NAMES[[kk]]
[17:38:22.101]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:22.101]                     next
[17:38:22.101]                   args[[name]] <- ""
[17:38:22.101]                 }
[17:38:22.101]                 NAMES <- toupper(removed)
[17:38:22.101]                 for (kk in seq_along(NAMES)) {
[17:38:22.101]                   name <- removed[[kk]]
[17:38:22.101]                   NAME <- NAMES[[kk]]
[17:38:22.101]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:22.101]                     next
[17:38:22.101]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:22.101]                 }
[17:38:22.101]                 if (length(args) > 0) 
[17:38:22.101]                   base::do.call(base::Sys.setenv, args = args)
[17:38:22.101]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:22.101]             }
[17:38:22.101]             else {
[17:38:22.101]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:22.101]             }
[17:38:22.101]             {
[17:38:22.101]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:22.101]                   0L) {
[17:38:22.101]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:22.101]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:22.101]                   base::options(opts)
[17:38:22.101]                 }
[17:38:22.101]                 {
[17:38:22.101]                   {
[17:38:22.101]                     NULL
[17:38:22.101]                     RNGkind("Mersenne-Twister")
[17:38:22.101]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:22.101]                       inherits = FALSE)
[17:38:22.101]                   }
[17:38:22.101]                   options(future.plan = NULL)
[17:38:22.101]                   if (is.na(NA_character_)) 
[17:38:22.101]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:22.101]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:22.101]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:22.101]                     .init = FALSE)
[17:38:22.101]                 }
[17:38:22.101]             }
[17:38:22.101]         }
[17:38:22.101]     })
[17:38:22.101]     if (FALSE) {
[17:38:22.101]         base::sink(type = "output", split = FALSE)
[17:38:22.101]         if (NA) {
[17:38:22.101]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:22.101]         }
[17:38:22.101]         else {
[17:38:22.101]             ...future.result["stdout"] <- base::list(NULL)
[17:38:22.101]         }
[17:38:22.101]         base::close(...future.stdout)
[17:38:22.101]         ...future.stdout <- NULL
[17:38:22.101]     }
[17:38:22.101]     ...future.result$conditions <- ...future.conditions
[17:38:22.101]     ...future.result$finished <- base::Sys.time()
[17:38:22.101]     ...future.result
[17:38:22.101] }
[17:38:22.103] assign_globals() ...
[17:38:22.103] List of 5
[17:38:22.103]  $ ...future.FUN            :function (x)  
[17:38:22.103]  $ future.call.arguments    : list()
[17:38:22.103]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:22.103]  $ ...future.elements_ii    :List of 2
[17:38:22.103]   ..$ : int 1
[17:38:22.103]   ..$ : int 0
[17:38:22.103]  $ ...future.seeds_ii       : NULL
[17:38:22.103]  $ ...future.globals.maxSize: NULL
[17:38:22.103]  - attr(*, "where")=List of 5
[17:38:22.103]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:22.103]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:22.103]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:22.103]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:22.103]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:22.103]  - attr(*, "resolved")= logi FALSE
[17:38:22.103]  - attr(*, "total_size")= num 4720
[17:38:22.103]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:22.103]  - attr(*, "already-done")= logi TRUE
[17:38:22.109] - reassign environment for ‘...future.FUN’
[17:38:22.109] - copied ‘...future.FUN’ to environment
[17:38:22.109] - copied ‘future.call.arguments’ to environment
[17:38:22.109] - copied ‘...future.elements_ii’ to environment
[17:38:22.109] - copied ‘...future.seeds_ii’ to environment
[17:38:22.109] - copied ‘...future.globals.maxSize’ to environment
[17:38:22.110] assign_globals() ... done
[17:38:22.110] plan(): Setting new future strategy stack:
[17:38:22.110] List of future strategies:
[17:38:22.110] 1. sequential:
[17:38:22.110]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:22.110]    - tweaked: FALSE
[17:38:22.110]    - call: NULL
[17:38:22.110] plan(): nbrOfWorkers() = 1
[17:38:22.612] plan(): Setting new future strategy stack:
[17:38:22.612] List of future strategies:
[17:38:22.612] 1. sequential:
[17:38:22.612]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:22.612]    - tweaked: FALSE
[17:38:22.612]    - call: plan(strategy)
[17:38:22.613] plan(): nbrOfWorkers() = 1
[17:38:22.613] SequentialFuture started (and completed)
[17:38:22.613] - Launch lazy future ... done
[17:38:22.613] run() for ‘SequentialFuture’ ... done
[17:38:22.613] Created future:
[17:38:22.613] SequentialFuture:
[17:38:22.613] Label: ‘future_lapply-1’
[17:38:22.613] Expression:
[17:38:22.613] {
[17:38:22.613]     do.call(function(...) {
[17:38:22.613]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:22.613]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:22.613]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:22.613]             on.exit(options(oopts), add = TRUE)
[17:38:22.613]         }
[17:38:22.613]         {
[17:38:22.613]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:22.613]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:22.613]                 ...future.FUN(...future.X_jj, ...)
[17:38:22.613]             })
[17:38:22.613]         }
[17:38:22.613]     }, args = future.call.arguments)
[17:38:22.613] }
[17:38:22.613] Lazy evaluation: FALSE
[17:38:22.613] Asynchronous evaluation: FALSE
[17:38:22.613] Local evaluation: TRUE
[17:38:22.613] Environment: R_GlobalEnv
[17:38:22.613] Capture standard output: NA
[17:38:22.613] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:22.613] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:22.613] Packages: <none>
[17:38:22.613] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:22.613] Resolved: TRUE
[17:38:22.613] Value: 112 bytes of class ‘list’
[17:38:22.613] Early signaling: FALSE
[17:38:22.613] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:22.613] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:22.614] Chunk #1 of 1 ... DONE
[17:38:22.614] Launching 1 futures (chunks) ... DONE
[17:38:22.615] Resolving 1 futures (chunks) ...
[17:38:22.615] resolve() on list ...
[17:38:22.615]  recursive: 0
[17:38:22.615]  length: 1
[17:38:22.615] 
[17:38:22.615] resolved() for ‘SequentialFuture’ ...
[17:38:22.615] - state: ‘finished’
[17:38:22.615] - run: TRUE
[17:38:22.615] - result: ‘FutureResult’
[17:38:22.615] resolved() for ‘SequentialFuture’ ... done
[17:38:22.616] Future #1
[17:38:22.616] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:22.616] - nx: 1
[17:38:22.616] - relay: TRUE
[17:38:22.616] - stdout: TRUE
[17:38:22.616] - signal: TRUE
[17:38:22.616] - resignal: FALSE
[17:38:22.616] - force: TRUE
[17:38:22.616] - relayed: [n=1] FALSE
[17:38:22.616] - queued futures: [n=1] FALSE
[17:38:22.616]  - until=1
[17:38:22.617]  - relaying element #1
[17:38:22.617] - relayed: [n=1] TRUE
[17:38:22.617] - queued futures: [n=1] TRUE
[17:38:22.617] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:22.617]  length: 0 (resolved future 1)
[17:38:22.617] Relaying remaining futures
[17:38:22.617] signalConditionsASAP(NULL, pos=0) ...
[17:38:22.617] - nx: 1
[17:38:22.617] - relay: TRUE
[17:38:22.617] - stdout: TRUE
[17:38:22.618] - signal: TRUE
[17:38:22.618] - resignal: FALSE
[17:38:22.618] - force: TRUE
[17:38:22.618] - relayed: [n=1] TRUE
[17:38:22.618] - queued futures: [n=1] TRUE
 - flush all
[17:38:22.618] - relayed: [n=1] TRUE
[17:38:22.618] - queued futures: [n=1] TRUE
[17:38:22.618] signalConditionsASAP(NULL, pos=0) ... done
[17:38:22.618] resolve() on list ... DONE
[17:38:22.618]  - Number of value chunks collected: 1
[17:38:22.618] Resolving 1 futures (chunks) ... DONE
[17:38:22.619] Reducing values from 1 chunks ...
[17:38:22.619]  - Number of values collected after concatenation: 2
[17:38:22.619]  - Number of values expected: 2
[17:38:22.619] Reducing values from 1 chunks ... DONE
[17:38:22.619] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[17:38:22.619] future_mapply() ...
[17:38:22.619] Number of chunks: 1
[17:38:22.620] getGlobalsAndPackagesXApply() ...
[17:38:22.620]  - future.globals: TRUE
[17:38:22.620] getGlobalsAndPackages() ...
[17:38:22.620] Searching for globals...
[17:38:22.621] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:38:22.621] Searching for globals ... DONE
[17:38:22.622] Resolving globals: FALSE
[17:38:22.622] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:38:22.622] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:38:22.622] - globals: [1] ‘FUN’
[17:38:22.623] 
[17:38:22.623] getGlobalsAndPackages() ... DONE
[17:38:22.623]  - globals found/used: [n=1] ‘FUN’
[17:38:22.623]  - needed namespaces: [n=0] 
[17:38:22.623] Finding globals ... DONE
[17:38:22.623] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:38:22.623] List of 2
[17:38:22.623]  $ ...future.FUN:function (x, y)  
[17:38:22.623]  $ MoreArgs     : NULL
[17:38:22.623]  - attr(*, "where")=List of 2
[17:38:22.623]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:22.623]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:38:22.623]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:22.623]  - attr(*, "resolved")= logi FALSE
[17:38:22.623]  - attr(*, "total_size")= num NA
[17:38:22.626] Packages to be attached in all futures: [n=0] 
[17:38:22.626] getGlobalsAndPackagesXApply() ... DONE
[17:38:22.626] Number of futures (= number of chunks): 1
[17:38:22.626] Launching 1 futures (chunks) ...
[17:38:22.626] Chunk #1 of 1 ...
[17:38:22.626]  - Finding globals in '...' for chunk #1 ...
[17:38:22.626] getGlobalsAndPackages() ...
[17:38:22.626] Searching for globals...
[17:38:22.627] 
[17:38:22.627] Searching for globals ... DONE
[17:38:22.627] - globals: [0] <none>
[17:38:22.627] getGlobalsAndPackages() ... DONE
[17:38:22.627]    + additional globals found: [n=0] 
[17:38:22.627]    + additional namespaces needed: [n=0] 
[17:38:22.627]  - Finding globals in '...' for chunk #1 ... DONE
[17:38:22.627]  - seeds: <none>
[17:38:22.627]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:22.628] getGlobalsAndPackages() ...
[17:38:22.628] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:22.628] Resolving globals: FALSE
[17:38:22.628] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:38:22.629] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:38:22.629] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:22.629] 
[17:38:22.629] getGlobalsAndPackages() ... DONE
[17:38:22.629] run() for ‘Future’ ...
[17:38:22.629] - state: ‘created’
[17:38:22.630] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:38:22.630] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:22.630] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:22.630]   - Field: ‘label’
[17:38:22.630]   - Field: ‘local’
[17:38:22.630]   - Field: ‘owner’
[17:38:22.630]   - Field: ‘envir’
[17:38:22.630]   - Field: ‘packages’
[17:38:22.630]   - Field: ‘gc’
[17:38:22.631]   - Field: ‘conditions’
[17:38:22.631]   - Field: ‘expr’
[17:38:22.631]   - Field: ‘uuid’
[17:38:22.631]   - Field: ‘seed’
[17:38:22.631]   - Field: ‘version’
[17:38:22.631]   - Field: ‘result’
[17:38:22.631]   - Field: ‘asynchronous’
[17:38:22.631]   - Field: ‘calls’
[17:38:22.631]   - Field: ‘globals’
[17:38:22.631]   - Field: ‘stdout’
[17:38:22.631]   - Field: ‘earlySignal’
[17:38:22.632]   - Field: ‘lazy’
[17:38:22.632]   - Field: ‘state’
[17:38:22.632] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:22.632] - Launch lazy future ...
[17:38:22.632] Packages needed by the future expression (n = 0): <none>
[17:38:22.632] Packages needed by future strategies (n = 0): <none>
[17:38:22.633] {
[17:38:22.633]     {
[17:38:22.633]         {
[17:38:22.633]             ...future.startTime <- base::Sys.time()
[17:38:22.633]             {
[17:38:22.633]                 {
[17:38:22.633]                   {
[17:38:22.633]                     base::local({
[17:38:22.633]                       has_future <- base::requireNamespace("future", 
[17:38:22.633]                         quietly = TRUE)
[17:38:22.633]                       if (has_future) {
[17:38:22.633]                         ns <- base::getNamespace("future")
[17:38:22.633]                         version <- ns[[".package"]][["version"]]
[17:38:22.633]                         if (is.null(version)) 
[17:38:22.633]                           version <- utils::packageVersion("future")
[17:38:22.633]                       }
[17:38:22.633]                       else {
[17:38:22.633]                         version <- NULL
[17:38:22.633]                       }
[17:38:22.633]                       if (!has_future || version < "1.8.0") {
[17:38:22.633]                         info <- base::c(r_version = base::gsub("R version ", 
[17:38:22.633]                           "", base::R.version$version.string), 
[17:38:22.633]                           platform = base::sprintf("%s (%s-bit)", 
[17:38:22.633]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:22.633]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:22.633]                             "release", "version")], collapse = " "), 
[17:38:22.633]                           hostname = base::Sys.info()[["nodename"]])
[17:38:22.633]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:38:22.633]                           info)
[17:38:22.633]                         info <- base::paste(info, collapse = "; ")
[17:38:22.633]                         if (!has_future) {
[17:38:22.633]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:22.633]                             info)
[17:38:22.633]                         }
[17:38:22.633]                         else {
[17:38:22.633]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:22.633]                             info, version)
[17:38:22.633]                         }
[17:38:22.633]                         base::stop(msg)
[17:38:22.633]                       }
[17:38:22.633]                     })
[17:38:22.633]                   }
[17:38:22.633]                   ...future.strategy.old <- future::plan("list")
[17:38:22.633]                   options(future.plan = NULL)
[17:38:22.633]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:22.633]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:22.633]                 }
[17:38:22.633]                 ...future.workdir <- getwd()
[17:38:22.633]             }
[17:38:22.633]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:22.633]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:22.633]         }
[17:38:22.633]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:22.633]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:22.633]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:22.633]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:22.633]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:22.633]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:22.633]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:22.633]             base::names(...future.oldOptions))
[17:38:22.633]     }
[17:38:22.633]     if (FALSE) {
[17:38:22.633]     }
[17:38:22.633]     else {
[17:38:22.633]         if (FALSE) {
[17:38:22.633]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:22.633]                 open = "w")
[17:38:22.633]         }
[17:38:22.633]         else {
[17:38:22.633]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:22.633]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:22.633]         }
[17:38:22.633]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:22.633]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:22.633]             base::sink(type = "output", split = FALSE)
[17:38:22.633]             base::close(...future.stdout)
[17:38:22.633]         }, add = TRUE)
[17:38:22.633]     }
[17:38:22.633]     ...future.frame <- base::sys.nframe()
[17:38:22.633]     ...future.conditions <- base::list()
[17:38:22.633]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:22.633]     if (FALSE) {
[17:38:22.633]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:22.633]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:22.633]     }
[17:38:22.633]     ...future.result <- base::tryCatch({
[17:38:22.633]         base::withCallingHandlers({
[17:38:22.633]             ...future.value <- base::withVisible(base::local({
[17:38:22.633]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:22.633]                 if (!identical(...future.globals.maxSize.org, 
[17:38:22.633]                   ...future.globals.maxSize)) {
[17:38:22.633]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:22.633]                   on.exit(options(oopts), add = TRUE)
[17:38:22.633]                 }
[17:38:22.633]                 {
[17:38:22.633]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:22.633]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:38:22.633]                     USE.NAMES = FALSE)
[17:38:22.633]                   do.call(mapply, args = args)
[17:38:22.633]                 }
[17:38:22.633]             }))
[17:38:22.633]             future::FutureResult(value = ...future.value$value, 
[17:38:22.633]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:22.633]                   ...future.rng), globalenv = if (FALSE) 
[17:38:22.633]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:22.633]                     ...future.globalenv.names))
[17:38:22.633]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:22.633]         }, condition = base::local({
[17:38:22.633]             c <- base::c
[17:38:22.633]             inherits <- base::inherits
[17:38:22.633]             invokeRestart <- base::invokeRestart
[17:38:22.633]             length <- base::length
[17:38:22.633]             list <- base::list
[17:38:22.633]             seq.int <- base::seq.int
[17:38:22.633]             signalCondition <- base::signalCondition
[17:38:22.633]             sys.calls <- base::sys.calls
[17:38:22.633]             `[[` <- base::`[[`
[17:38:22.633]             `+` <- base::`+`
[17:38:22.633]             `<<-` <- base::`<<-`
[17:38:22.633]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:22.633]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:22.633]                   3L)]
[17:38:22.633]             }
[17:38:22.633]             function(cond) {
[17:38:22.633]                 is_error <- inherits(cond, "error")
[17:38:22.633]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:22.633]                   NULL)
[17:38:22.633]                 if (is_error) {
[17:38:22.633]                   sessionInformation <- function() {
[17:38:22.633]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:22.633]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:22.633]                       search = base::search(), system = base::Sys.info())
[17:38:22.633]                   }
[17:38:22.633]                   ...future.conditions[[length(...future.conditions) + 
[17:38:22.633]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:22.633]                     cond$call), session = sessionInformation(), 
[17:38:22.633]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:22.633]                   signalCondition(cond)
[17:38:22.633]                 }
[17:38:22.633]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:22.633]                 "immediateCondition"))) {
[17:38:22.633]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:22.633]                   ...future.conditions[[length(...future.conditions) + 
[17:38:22.633]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:22.633]                   if (TRUE && !signal) {
[17:38:22.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:22.633]                     {
[17:38:22.633]                       inherits <- base::inherits
[17:38:22.633]                       invokeRestart <- base::invokeRestart
[17:38:22.633]                       is.null <- base::is.null
[17:38:22.633]                       muffled <- FALSE
[17:38:22.633]                       if (inherits(cond, "message")) {
[17:38:22.633]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:22.633]                         if (muffled) 
[17:38:22.633]                           invokeRestart("muffleMessage")
[17:38:22.633]                       }
[17:38:22.633]                       else if (inherits(cond, "warning")) {
[17:38:22.633]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:22.633]                         if (muffled) 
[17:38:22.633]                           invokeRestart("muffleWarning")
[17:38:22.633]                       }
[17:38:22.633]                       else if (inherits(cond, "condition")) {
[17:38:22.633]                         if (!is.null(pattern)) {
[17:38:22.633]                           computeRestarts <- base::computeRestarts
[17:38:22.633]                           grepl <- base::grepl
[17:38:22.633]                           restarts <- computeRestarts(cond)
[17:38:22.633]                           for (restart in restarts) {
[17:38:22.633]                             name <- restart$name
[17:38:22.633]                             if (is.null(name)) 
[17:38:22.633]                               next
[17:38:22.633]                             if (!grepl(pattern, name)) 
[17:38:22.633]                               next
[17:38:22.633]                             invokeRestart(restart)
[17:38:22.633]                             muffled <- TRUE
[17:38:22.633]                             break
[17:38:22.633]                           }
[17:38:22.633]                         }
[17:38:22.633]                       }
[17:38:22.633]                       invisible(muffled)
[17:38:22.633]                     }
[17:38:22.633]                     muffleCondition(cond, pattern = "^muffle")
[17:38:22.633]                   }
[17:38:22.633]                 }
[17:38:22.633]                 else {
[17:38:22.633]                   if (TRUE) {
[17:38:22.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:22.633]                     {
[17:38:22.633]                       inherits <- base::inherits
[17:38:22.633]                       invokeRestart <- base::invokeRestart
[17:38:22.633]                       is.null <- base::is.null
[17:38:22.633]                       muffled <- FALSE
[17:38:22.633]                       if (inherits(cond, "message")) {
[17:38:22.633]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:22.633]                         if (muffled) 
[17:38:22.633]                           invokeRestart("muffleMessage")
[17:38:22.633]                       }
[17:38:22.633]                       else if (inherits(cond, "warning")) {
[17:38:22.633]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:22.633]                         if (muffled) 
[17:38:22.633]                           invokeRestart("muffleWarning")
[17:38:22.633]                       }
[17:38:22.633]                       else if (inherits(cond, "condition")) {
[17:38:22.633]                         if (!is.null(pattern)) {
[17:38:22.633]                           computeRestarts <- base::computeRestarts
[17:38:22.633]                           grepl <- base::grepl
[17:38:22.633]                           restarts <- computeRestarts(cond)
[17:38:22.633]                           for (restart in restarts) {
[17:38:22.633]                             name <- restart$name
[17:38:22.633]                             if (is.null(name)) 
[17:38:22.633]                               next
[17:38:22.633]                             if (!grepl(pattern, name)) 
[17:38:22.633]                               next
[17:38:22.633]                             invokeRestart(restart)
[17:38:22.633]                             muffled <- TRUE
[17:38:22.633]                             break
[17:38:22.633]                           }
[17:38:22.633]                         }
[17:38:22.633]                       }
[17:38:22.633]                       invisible(muffled)
[17:38:22.633]                     }
[17:38:22.633]                     muffleCondition(cond, pattern = "^muffle")
[17:38:22.633]                   }
[17:38:22.633]                 }
[17:38:22.633]             }
[17:38:22.633]         }))
[17:38:22.633]     }, error = function(ex) {
[17:38:22.633]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:22.633]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:22.633]                 ...future.rng), started = ...future.startTime, 
[17:38:22.633]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:22.633]             version = "1.8"), class = "FutureResult")
[17:38:22.633]     }, finally = {
[17:38:22.633]         if (!identical(...future.workdir, getwd())) 
[17:38:22.633]             setwd(...future.workdir)
[17:38:22.633]         {
[17:38:22.633]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:22.633]                 ...future.oldOptions$nwarnings <- NULL
[17:38:22.633]             }
[17:38:22.633]             base::options(...future.oldOptions)
[17:38:22.633]             if (.Platform$OS.type == "windows") {
[17:38:22.633]                 old_names <- names(...future.oldEnvVars)
[17:38:22.633]                 envs <- base::Sys.getenv()
[17:38:22.633]                 names <- names(envs)
[17:38:22.633]                 common <- intersect(names, old_names)
[17:38:22.633]                 added <- setdiff(names, old_names)
[17:38:22.633]                 removed <- setdiff(old_names, names)
[17:38:22.633]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:22.633]                   envs[common]]
[17:38:22.633]                 NAMES <- toupper(changed)
[17:38:22.633]                 args <- list()
[17:38:22.633]                 for (kk in seq_along(NAMES)) {
[17:38:22.633]                   name <- changed[[kk]]
[17:38:22.633]                   NAME <- NAMES[[kk]]
[17:38:22.633]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:22.633]                     next
[17:38:22.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:22.633]                 }
[17:38:22.633]                 NAMES <- toupper(added)
[17:38:22.633]                 for (kk in seq_along(NAMES)) {
[17:38:22.633]                   name <- added[[kk]]
[17:38:22.633]                   NAME <- NAMES[[kk]]
[17:38:22.633]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:22.633]                     next
[17:38:22.633]                   args[[name]] <- ""
[17:38:22.633]                 }
[17:38:22.633]                 NAMES <- toupper(removed)
[17:38:22.633]                 for (kk in seq_along(NAMES)) {
[17:38:22.633]                   name <- removed[[kk]]
[17:38:22.633]                   NAME <- NAMES[[kk]]
[17:38:22.633]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:22.633]                     next
[17:38:22.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:22.633]                 }
[17:38:22.633]                 if (length(args) > 0) 
[17:38:22.633]                   base::do.call(base::Sys.setenv, args = args)
[17:38:22.633]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:22.633]             }
[17:38:22.633]             else {
[17:38:22.633]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:22.633]             }
[17:38:22.633]             {
[17:38:22.633]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:22.633]                   0L) {
[17:38:22.633]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:22.633]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:22.633]                   base::options(opts)
[17:38:22.633]                 }
[17:38:22.633]                 {
[17:38:22.633]                   {
[17:38:22.633]                     NULL
[17:38:22.633]                     RNGkind("Mersenne-Twister")
[17:38:22.633]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:22.633]                       inherits = FALSE)
[17:38:22.633]                   }
[17:38:22.633]                   options(future.plan = NULL)
[17:38:22.633]                   if (is.na(NA_character_)) 
[17:38:22.633]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:22.633]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:22.633]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:22.633]                     .init = FALSE)
[17:38:22.633]                 }
[17:38:22.633]             }
[17:38:22.633]         }
[17:38:22.633]     })
[17:38:22.633]     if (TRUE) {
[17:38:22.633]         base::sink(type = "output", split = FALSE)
[17:38:22.633]         if (FALSE) {
[17:38:22.633]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:22.633]         }
[17:38:22.633]         else {
[17:38:22.633]             ...future.result["stdout"] <- base::list(NULL)
[17:38:22.633]         }
[17:38:22.633]         base::close(...future.stdout)
[17:38:22.633]         ...future.stdout <- NULL
[17:38:22.633]     }
[17:38:22.633]     ...future.result$conditions <- ...future.conditions
[17:38:22.633]     ...future.result$finished <- base::Sys.time()
[17:38:22.633]     ...future.result
[17:38:22.633] }
[17:38:22.634] assign_globals() ...
[17:38:22.634] List of 5
[17:38:22.634]  $ ...future.FUN            :function (x, y)  
[17:38:22.634]  $ MoreArgs                 : NULL
[17:38:22.634]  $ ...future.elements_ii    :List of 2
[17:38:22.634]   ..$ :List of 2
[17:38:22.634]   .. ..$ : int 1
[17:38:22.634]   .. ..$ : int 0
[17:38:22.634]   ..$ :List of 2
[17:38:22.634]   .. ..$ : int 0
[17:38:22.634]   .. ..$ : int 1
[17:38:22.634]  $ ...future.seeds_ii       : NULL
[17:38:22.634]  $ ...future.globals.maxSize: NULL
[17:38:22.634]  - attr(*, "where")=List of 5
[17:38:22.634]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:22.634]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:38:22.634]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:22.634]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:22.634]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:22.634]  - attr(*, "resolved")= logi FALSE
[17:38:22.634]  - attr(*, "total_size")= num 6480
[17:38:22.634]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:22.634]  - attr(*, "already-done")= logi TRUE
[17:38:22.641] - reassign environment for ‘...future.FUN’
[17:38:22.642] - copied ‘...future.FUN’ to environment
[17:38:22.642] - copied ‘MoreArgs’ to environment
[17:38:22.642] - copied ‘...future.elements_ii’ to environment
[17:38:22.642] - copied ‘...future.seeds_ii’ to environment
[17:38:22.642] - copied ‘...future.globals.maxSize’ to environment
[17:38:22.642] assign_globals() ... done
[17:38:22.642] plan(): Setting new future strategy stack:
[17:38:22.642] List of future strategies:
[17:38:22.642] 1. sequential:
[17:38:22.642]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:22.642]    - tweaked: FALSE
[17:38:22.642]    - call: NULL
[17:38:22.643] plan(): nbrOfWorkers() = 1
[17:38:23.145] plan(): Setting new future strategy stack:
[17:38:23.145] List of future strategies:
[17:38:23.145] 1. sequential:
[17:38:23.145]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:23.145]    - tweaked: FALSE
[17:38:23.145]    - call: plan(strategy)
[17:38:23.145] plan(): nbrOfWorkers() = 1
[17:38:23.145] SequentialFuture started (and completed)
[17:38:23.146] - Launch lazy future ... done
[17:38:23.146] run() for ‘SequentialFuture’ ... done
[17:38:23.146] Created future:
[17:38:23.146] SequentialFuture:
[17:38:23.146] Label: ‘future_mapply-1’
[17:38:23.146] Expression:
[17:38:23.146] {
[17:38:23.146]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:23.146]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:23.146]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:23.146]         on.exit(options(oopts), add = TRUE)
[17:38:23.146]     }
[17:38:23.146]     {
[17:38:23.146]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:23.146]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:38:23.146]         do.call(mapply, args = args)
[17:38:23.146]     }
[17:38:23.146] }
[17:38:23.146] Lazy evaluation: FALSE
[17:38:23.146] Asynchronous evaluation: FALSE
[17:38:23.146] Local evaluation: TRUE
[17:38:23.146] Environment: R_GlobalEnv
[17:38:23.146] Capture standard output: FALSE
[17:38:23.146] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:23.146] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:23.146] Packages: <none>
[17:38:23.146] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:23.146] Resolved: TRUE
[17:38:23.146] Value: 224 bytes of class ‘list’
[17:38:23.146] Early signaling: FALSE
[17:38:23.146] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:23.146] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:23.147] Chunk #1 of 1 ... DONE
[17:38:23.147] Launching 1 futures (chunks) ... DONE
[17:38:23.147] Resolving 1 futures (chunks) ...
[17:38:23.147] resolve() on list ...
[17:38:23.147]  recursive: 0
[17:38:23.147]  length: 1
[17:38:23.148] 
[17:38:23.148] resolved() for ‘SequentialFuture’ ...
[17:38:23.148] - state: ‘finished’
[17:38:23.148] - run: TRUE
[17:38:23.148] - result: ‘FutureResult’
[17:38:23.148] resolved() for ‘SequentialFuture’ ... done
[17:38:23.148] Future #1
[17:38:23.148] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:23.148] - nx: 1
[17:38:23.149] - relay: TRUE
[17:38:23.149] - stdout: TRUE
[17:38:23.149] - signal: TRUE
[17:38:23.149] - resignal: FALSE
[17:38:23.149] - force: TRUE
[17:38:23.149] - relayed: [n=1] FALSE
[17:38:23.149] - queued futures: [n=1] FALSE
[17:38:23.149]  - until=1
[17:38:23.149]  - relaying element #1
[17:38:23.149] - relayed: [n=1] TRUE
[17:38:23.149] - queued futures: [n=1] TRUE
[17:38:23.150] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:23.150]  length: 0 (resolved future 1)
[17:38:23.150] Relaying remaining futures
[17:38:23.150] signalConditionsASAP(NULL, pos=0) ...
[17:38:23.150] - nx: 1
[17:38:23.150] - relay: TRUE
[17:38:23.150] - stdout: TRUE
[17:38:23.150] - signal: TRUE
[17:38:23.150] - resignal: FALSE
[17:38:23.150] - force: TRUE
[17:38:23.150] - relayed: [n=1] TRUE
[17:38:23.150] - queued futures: [n=1] TRUE
 - flush all
[17:38:23.151] - relayed: [n=1] TRUE
[17:38:23.151] - queued futures: [n=1] TRUE
[17:38:23.151] signalConditionsASAP(NULL, pos=0) ... done
[17:38:23.151] resolve() on list ... DONE
[17:38:23.151]  - Number of value chunks collected: 1
[17:38:23.151] Resolving 1 futures (chunks) ... DONE
[17:38:23.151] Reducing values from 1 chunks ...
[17:38:23.151]  - Number of values collected after concatenation: 2
[17:38:23.151]  - Number of values expected: 2
[17:38:23.151] Reducing values from 1 chunks ... DONE
[17:38:23.152] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[17:38:23.152] future_mapply() ...
[17:38:23.152] Number of chunks: 1
[17:38:23.152] getGlobalsAndPackagesXApply() ...
[17:38:23.152]  - future.globals: TRUE
[17:38:23.152] getGlobalsAndPackages() ...
[17:38:23.152] Searching for globals...
[17:38:23.154] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:38:23.154] Searching for globals ... DONE
[17:38:23.154] Resolving globals: FALSE
[17:38:23.155] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:38:23.155] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:38:23.155] - globals: [1] ‘FUN’
[17:38:23.155] 
[17:38:23.155] getGlobalsAndPackages() ... DONE
[17:38:23.155]  - globals found/used: [n=1] ‘FUN’
[17:38:23.156]  - needed namespaces: [n=0] 
[17:38:23.156] Finding globals ... DONE
[17:38:23.156] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:38:23.156] List of 2
[17:38:23.156]  $ ...future.FUN:function (x, y)  
[17:38:23.156]  $ MoreArgs     : NULL
[17:38:23.156]  - attr(*, "where")=List of 2
[17:38:23.156]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:23.156]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:38:23.156]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:23.156]  - attr(*, "resolved")= logi FALSE
[17:38:23.156]  - attr(*, "total_size")= num NA
[17:38:23.158] Packages to be attached in all futures: [n=0] 
[17:38:23.159] getGlobalsAndPackagesXApply() ... DONE
[17:38:23.159] Number of futures (= number of chunks): 1
[17:38:23.159] Launching 1 futures (chunks) ...
[17:38:23.159] Chunk #1 of 1 ...
[17:38:23.159]  - Finding globals in '...' for chunk #1 ...
[17:38:23.159] getGlobalsAndPackages() ...
[17:38:23.159] Searching for globals...
[17:38:23.160] 
[17:38:23.160] Searching for globals ... DONE
[17:38:23.160] - globals: [0] <none>
[17:38:23.160] getGlobalsAndPackages() ... DONE
[17:38:23.160]    + additional globals found: [n=0] 
[17:38:23.160]    + additional namespaces needed: [n=0] 
[17:38:23.160]  - Finding globals in '...' for chunk #1 ... DONE
[17:38:23.160]  - seeds: <none>
[17:38:23.160]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:23.160] getGlobalsAndPackages() ...
[17:38:23.160] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:23.161] Resolving globals: FALSE
[17:38:23.161] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:38:23.161] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:38:23.162] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:23.162] 
[17:38:23.162] getGlobalsAndPackages() ... DONE
[17:38:23.164] run() for ‘Future’ ...
[17:38:23.164] - state: ‘created’
[17:38:23.164] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:38:23.164] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:23.164] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:23.164]   - Field: ‘label’
[17:38:23.165]   - Field: ‘local’
[17:38:23.165]   - Field: ‘owner’
[17:38:23.165]   - Field: ‘envir’
[17:38:23.165]   - Field: ‘packages’
[17:38:23.165]   - Field: ‘gc’
[17:38:23.165]   - Field: ‘conditions’
[17:38:23.165]   - Field: ‘expr’
[17:38:23.165]   - Field: ‘uuid’
[17:38:23.165]   - Field: ‘seed’
[17:38:23.165]   - Field: ‘version’
[17:38:23.165]   - Field: ‘result’
[17:38:23.166]   - Field: ‘asynchronous’
[17:38:23.166]   - Field: ‘calls’
[17:38:23.166]   - Field: ‘globals’
[17:38:23.166]   - Field: ‘stdout’
[17:38:23.166]   - Field: ‘earlySignal’
[17:38:23.166]   - Field: ‘lazy’
[17:38:23.166]   - Field: ‘state’
[17:38:23.166] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:23.166] - Launch lazy future ...
[17:38:23.166] Packages needed by the future expression (n = 0): <none>
[17:38:23.167] Packages needed by future strategies (n = 0): <none>
[17:38:23.167] {
[17:38:23.167]     {
[17:38:23.167]         {
[17:38:23.167]             ...future.startTime <- base::Sys.time()
[17:38:23.167]             {
[17:38:23.167]                 {
[17:38:23.167]                   {
[17:38:23.167]                     base::local({
[17:38:23.167]                       has_future <- base::requireNamespace("future", 
[17:38:23.167]                         quietly = TRUE)
[17:38:23.167]                       if (has_future) {
[17:38:23.167]                         ns <- base::getNamespace("future")
[17:38:23.167]                         version <- ns[[".package"]][["version"]]
[17:38:23.167]                         if (is.null(version)) 
[17:38:23.167]                           version <- utils::packageVersion("future")
[17:38:23.167]                       }
[17:38:23.167]                       else {
[17:38:23.167]                         version <- NULL
[17:38:23.167]                       }
[17:38:23.167]                       if (!has_future || version < "1.8.0") {
[17:38:23.167]                         info <- base::c(r_version = base::gsub("R version ", 
[17:38:23.167]                           "", base::R.version$version.string), 
[17:38:23.167]                           platform = base::sprintf("%s (%s-bit)", 
[17:38:23.167]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:23.167]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:23.167]                             "release", "version")], collapse = " "), 
[17:38:23.167]                           hostname = base::Sys.info()[["nodename"]])
[17:38:23.167]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:38:23.167]                           info)
[17:38:23.167]                         info <- base::paste(info, collapse = "; ")
[17:38:23.167]                         if (!has_future) {
[17:38:23.167]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:23.167]                             info)
[17:38:23.167]                         }
[17:38:23.167]                         else {
[17:38:23.167]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:23.167]                             info, version)
[17:38:23.167]                         }
[17:38:23.167]                         base::stop(msg)
[17:38:23.167]                       }
[17:38:23.167]                     })
[17:38:23.167]                   }
[17:38:23.167]                   ...future.strategy.old <- future::plan("list")
[17:38:23.167]                   options(future.plan = NULL)
[17:38:23.167]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:23.167]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:23.167]                 }
[17:38:23.167]                 ...future.workdir <- getwd()
[17:38:23.167]             }
[17:38:23.167]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:23.167]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:23.167]         }
[17:38:23.167]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:23.167]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:23.167]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:23.167]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:23.167]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:23.167]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:23.167]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:23.167]             base::names(...future.oldOptions))
[17:38:23.167]     }
[17:38:23.167]     if (FALSE) {
[17:38:23.167]     }
[17:38:23.167]     else {
[17:38:23.167]         if (TRUE) {
[17:38:23.167]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:23.167]                 open = "w")
[17:38:23.167]         }
[17:38:23.167]         else {
[17:38:23.167]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:23.167]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:23.167]         }
[17:38:23.167]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:23.167]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:23.167]             base::sink(type = "output", split = FALSE)
[17:38:23.167]             base::close(...future.stdout)
[17:38:23.167]         }, add = TRUE)
[17:38:23.167]     }
[17:38:23.167]     ...future.frame <- base::sys.nframe()
[17:38:23.167]     ...future.conditions <- base::list()
[17:38:23.167]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:23.167]     if (FALSE) {
[17:38:23.167]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:23.167]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:23.167]     }
[17:38:23.167]     ...future.result <- base::tryCatch({
[17:38:23.167]         base::withCallingHandlers({
[17:38:23.167]             ...future.value <- base::withVisible(base::local({
[17:38:23.167]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:23.167]                 if (!identical(...future.globals.maxSize.org, 
[17:38:23.167]                   ...future.globals.maxSize)) {
[17:38:23.167]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:23.167]                   on.exit(options(oopts), add = TRUE)
[17:38:23.167]                 }
[17:38:23.167]                 {
[17:38:23.167]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:23.167]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:38:23.167]                     USE.NAMES = FALSE)
[17:38:23.167]                   do.call(mapply, args = args)
[17:38:23.167]                 }
[17:38:23.167]             }))
[17:38:23.167]             future::FutureResult(value = ...future.value$value, 
[17:38:23.167]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:23.167]                   ...future.rng), globalenv = if (FALSE) 
[17:38:23.167]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:23.167]                     ...future.globalenv.names))
[17:38:23.167]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:23.167]         }, condition = base::local({
[17:38:23.167]             c <- base::c
[17:38:23.167]             inherits <- base::inherits
[17:38:23.167]             invokeRestart <- base::invokeRestart
[17:38:23.167]             length <- base::length
[17:38:23.167]             list <- base::list
[17:38:23.167]             seq.int <- base::seq.int
[17:38:23.167]             signalCondition <- base::signalCondition
[17:38:23.167]             sys.calls <- base::sys.calls
[17:38:23.167]             `[[` <- base::`[[`
[17:38:23.167]             `+` <- base::`+`
[17:38:23.167]             `<<-` <- base::`<<-`
[17:38:23.167]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:23.167]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:23.167]                   3L)]
[17:38:23.167]             }
[17:38:23.167]             function(cond) {
[17:38:23.167]                 is_error <- inherits(cond, "error")
[17:38:23.167]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:23.167]                   NULL)
[17:38:23.167]                 if (is_error) {
[17:38:23.167]                   sessionInformation <- function() {
[17:38:23.167]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:23.167]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:23.167]                       search = base::search(), system = base::Sys.info())
[17:38:23.167]                   }
[17:38:23.167]                   ...future.conditions[[length(...future.conditions) + 
[17:38:23.167]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:23.167]                     cond$call), session = sessionInformation(), 
[17:38:23.167]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:23.167]                   signalCondition(cond)
[17:38:23.167]                 }
[17:38:23.167]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:23.167]                 "immediateCondition"))) {
[17:38:23.167]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:23.167]                   ...future.conditions[[length(...future.conditions) + 
[17:38:23.167]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:23.167]                   if (TRUE && !signal) {
[17:38:23.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:23.167]                     {
[17:38:23.167]                       inherits <- base::inherits
[17:38:23.167]                       invokeRestart <- base::invokeRestart
[17:38:23.167]                       is.null <- base::is.null
[17:38:23.167]                       muffled <- FALSE
[17:38:23.167]                       if (inherits(cond, "message")) {
[17:38:23.167]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:23.167]                         if (muffled) 
[17:38:23.167]                           invokeRestart("muffleMessage")
[17:38:23.167]                       }
[17:38:23.167]                       else if (inherits(cond, "warning")) {
[17:38:23.167]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:23.167]                         if (muffled) 
[17:38:23.167]                           invokeRestart("muffleWarning")
[17:38:23.167]                       }
[17:38:23.167]                       else if (inherits(cond, "condition")) {
[17:38:23.167]                         if (!is.null(pattern)) {
[17:38:23.167]                           computeRestarts <- base::computeRestarts
[17:38:23.167]                           grepl <- base::grepl
[17:38:23.167]                           restarts <- computeRestarts(cond)
[17:38:23.167]                           for (restart in restarts) {
[17:38:23.167]                             name <- restart$name
[17:38:23.167]                             if (is.null(name)) 
[17:38:23.167]                               next
[17:38:23.167]                             if (!grepl(pattern, name)) 
[17:38:23.167]                               next
[17:38:23.167]                             invokeRestart(restart)
[17:38:23.167]                             muffled <- TRUE
[17:38:23.167]                             break
[17:38:23.167]                           }
[17:38:23.167]                         }
[17:38:23.167]                       }
[17:38:23.167]                       invisible(muffled)
[17:38:23.167]                     }
[17:38:23.167]                     muffleCondition(cond, pattern = "^muffle")
[17:38:23.167]                   }
[17:38:23.167]                 }
[17:38:23.167]                 else {
[17:38:23.167]                   if (TRUE) {
[17:38:23.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:23.167]                     {
[17:38:23.167]                       inherits <- base::inherits
[17:38:23.167]                       invokeRestart <- base::invokeRestart
[17:38:23.167]                       is.null <- base::is.null
[17:38:23.167]                       muffled <- FALSE
[17:38:23.167]                       if (inherits(cond, "message")) {
[17:38:23.167]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:23.167]                         if (muffled) 
[17:38:23.167]                           invokeRestart("muffleMessage")
[17:38:23.167]                       }
[17:38:23.167]                       else if (inherits(cond, "warning")) {
[17:38:23.167]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:23.167]                         if (muffled) 
[17:38:23.167]                           invokeRestart("muffleWarning")
[17:38:23.167]                       }
[17:38:23.167]                       else if (inherits(cond, "condition")) {
[17:38:23.167]                         if (!is.null(pattern)) {
[17:38:23.167]                           computeRestarts <- base::computeRestarts
[17:38:23.167]                           grepl <- base::grepl
[17:38:23.167]                           restarts <- computeRestarts(cond)
[17:38:23.167]                           for (restart in restarts) {
[17:38:23.167]                             name <- restart$name
[17:38:23.167]                             if (is.null(name)) 
[17:38:23.167]                               next
[17:38:23.167]                             if (!grepl(pattern, name)) 
[17:38:23.167]                               next
[17:38:23.167]                             invokeRestart(restart)
[17:38:23.167]                             muffled <- TRUE
[17:38:23.167]                             break
[17:38:23.167]                           }
[17:38:23.167]                         }
[17:38:23.167]                       }
[17:38:23.167]                       invisible(muffled)
[17:38:23.167]                     }
[17:38:23.167]                     muffleCondition(cond, pattern = "^muffle")
[17:38:23.167]                   }
[17:38:23.167]                 }
[17:38:23.167]             }
[17:38:23.167]         }))
[17:38:23.167]     }, error = function(ex) {
[17:38:23.167]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:23.167]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:23.167]                 ...future.rng), started = ...future.startTime, 
[17:38:23.167]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:23.167]             version = "1.8"), class = "FutureResult")
[17:38:23.167]     }, finally = {
[17:38:23.167]         if (!identical(...future.workdir, getwd())) 
[17:38:23.167]             setwd(...future.workdir)
[17:38:23.167]         {
[17:38:23.167]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:23.167]                 ...future.oldOptions$nwarnings <- NULL
[17:38:23.167]             }
[17:38:23.167]             base::options(...future.oldOptions)
[17:38:23.167]             if (.Platform$OS.type == "windows") {
[17:38:23.167]                 old_names <- names(...future.oldEnvVars)
[17:38:23.167]                 envs <- base::Sys.getenv()
[17:38:23.167]                 names <- names(envs)
[17:38:23.167]                 common <- intersect(names, old_names)
[17:38:23.167]                 added <- setdiff(names, old_names)
[17:38:23.167]                 removed <- setdiff(old_names, names)
[17:38:23.167]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:23.167]                   envs[common]]
[17:38:23.167]                 NAMES <- toupper(changed)
[17:38:23.167]                 args <- list()
[17:38:23.167]                 for (kk in seq_along(NAMES)) {
[17:38:23.167]                   name <- changed[[kk]]
[17:38:23.167]                   NAME <- NAMES[[kk]]
[17:38:23.167]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:23.167]                     next
[17:38:23.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:23.167]                 }
[17:38:23.167]                 NAMES <- toupper(added)
[17:38:23.167]                 for (kk in seq_along(NAMES)) {
[17:38:23.167]                   name <- added[[kk]]
[17:38:23.167]                   NAME <- NAMES[[kk]]
[17:38:23.167]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:23.167]                     next
[17:38:23.167]                   args[[name]] <- ""
[17:38:23.167]                 }
[17:38:23.167]                 NAMES <- toupper(removed)
[17:38:23.167]                 for (kk in seq_along(NAMES)) {
[17:38:23.167]                   name <- removed[[kk]]
[17:38:23.167]                   NAME <- NAMES[[kk]]
[17:38:23.167]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:23.167]                     next
[17:38:23.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:23.167]                 }
[17:38:23.167]                 if (length(args) > 0) 
[17:38:23.167]                   base::do.call(base::Sys.setenv, args = args)
[17:38:23.167]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:23.167]             }
[17:38:23.167]             else {
[17:38:23.167]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:23.167]             }
[17:38:23.167]             {
[17:38:23.167]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:23.167]                   0L) {
[17:38:23.167]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:23.167]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:23.167]                   base::options(opts)
[17:38:23.167]                 }
[17:38:23.167]                 {
[17:38:23.167]                   {
[17:38:23.167]                     NULL
[17:38:23.167]                     RNGkind("Mersenne-Twister")
[17:38:23.167]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:23.167]                       inherits = FALSE)
[17:38:23.167]                   }
[17:38:23.167]                   options(future.plan = NULL)
[17:38:23.167]                   if (is.na(NA_character_)) 
[17:38:23.167]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:23.167]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:23.167]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:23.167]                     .init = FALSE)
[17:38:23.167]                 }
[17:38:23.167]             }
[17:38:23.167]         }
[17:38:23.167]     })
[17:38:23.167]     if (TRUE) {
[17:38:23.167]         base::sink(type = "output", split = FALSE)
[17:38:23.167]         if (TRUE) {
[17:38:23.167]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:23.167]         }
[17:38:23.167]         else {
[17:38:23.167]             ...future.result["stdout"] <- base::list(NULL)
[17:38:23.167]         }
[17:38:23.167]         base::close(...future.stdout)
[17:38:23.167]         ...future.stdout <- NULL
[17:38:23.167]     }
[17:38:23.167]     ...future.result$conditions <- ...future.conditions
[17:38:23.167]     ...future.result$finished <- base::Sys.time()
[17:38:23.167]     ...future.result
[17:38:23.167] }
[17:38:23.169] assign_globals() ...
[17:38:23.169] List of 5
[17:38:23.169]  $ ...future.FUN            :function (x, y)  
[17:38:23.169]  $ MoreArgs                 : NULL
[17:38:23.169]  $ ...future.elements_ii    :List of 2
[17:38:23.169]   ..$ :List of 2
[17:38:23.169]   .. ..$ : int 1
[17:38:23.169]   .. ..$ : int 0
[17:38:23.169]   ..$ :List of 2
[17:38:23.169]   .. ..$ : int 0
[17:38:23.169]   .. ..$ : int 1
[17:38:23.169]  $ ...future.seeds_ii       : NULL
[17:38:23.169]  $ ...future.globals.maxSize: NULL
[17:38:23.169]  - attr(*, "where")=List of 5
[17:38:23.169]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:23.169]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:38:23.169]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:23.169]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:23.169]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:23.169]  - attr(*, "resolved")= logi FALSE
[17:38:23.169]  - attr(*, "total_size")= num 6480
[17:38:23.169]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:23.169]  - attr(*, "already-done")= logi TRUE
[17:38:23.174] - reassign environment for ‘...future.FUN’
[17:38:23.174] - copied ‘...future.FUN’ to environment
[17:38:23.174] - copied ‘MoreArgs’ to environment
[17:38:23.174] - copied ‘...future.elements_ii’ to environment
[17:38:23.174] - copied ‘...future.seeds_ii’ to environment
[17:38:23.174] - copied ‘...future.globals.maxSize’ to environment
[17:38:23.175] assign_globals() ... done
[17:38:23.175] plan(): Setting new future strategy stack:
[17:38:23.175] List of future strategies:
[17:38:23.175] 1. sequential:
[17:38:23.175]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:23.175]    - tweaked: FALSE
[17:38:23.175]    - call: NULL
[17:38:23.175] plan(): nbrOfWorkers() = 1
[17:38:23.677] plan(): Setting new future strategy stack:
[17:38:23.677] List of future strategies:
[17:38:23.677] 1. sequential:
[17:38:23.677]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:23.677]    - tweaked: FALSE
[17:38:23.677]    - call: plan(strategy)
[17:38:23.678] plan(): nbrOfWorkers() = 1
[17:38:23.678] SequentialFuture started (and completed)
[17:38:23.678] - Launch lazy future ... done
[17:38:23.678] run() for ‘SequentialFuture’ ... done
[17:38:23.678] Created future:
[17:38:23.678] SequentialFuture:
[17:38:23.678] Label: ‘future_mapply-1’
[17:38:23.678] Expression:
[17:38:23.678] {
[17:38:23.678]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:23.678]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:23.678]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:23.678]         on.exit(options(oopts), add = TRUE)
[17:38:23.678]     }
[17:38:23.678]     {
[17:38:23.678]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:23.678]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:38:23.678]         do.call(mapply, args = args)
[17:38:23.678]     }
[17:38:23.678] }
[17:38:23.678] Lazy evaluation: FALSE
[17:38:23.678] Asynchronous evaluation: FALSE
[17:38:23.678] Local evaluation: TRUE
[17:38:23.678] Environment: R_GlobalEnv
[17:38:23.678] Capture standard output: TRUE
[17:38:23.678] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:23.678] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:23.678] Packages: <none>
[17:38:23.678] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:23.678] Resolved: TRUE
[17:38:23.678] Value: 224 bytes of class ‘list’
[17:38:23.678] Early signaling: FALSE
[17:38:23.678] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:23.678] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:23.679] Chunk #1 of 1 ... DONE
[17:38:23.679] Launching 1 futures (chunks) ... DONE
[17:38:23.680] Resolving 1 futures (chunks) ...
[17:38:23.680] resolve() on list ...
[17:38:23.680]  recursive: 0
[17:38:23.680]  length: 1
[17:38:23.680] 
[17:38:23.680] resolved() for ‘SequentialFuture’ ...
[17:38:23.680] - state: ‘finished’
[17:38:23.680] - run: TRUE
[17:38:23.680] - result: ‘FutureResult’
[17:38:23.681] resolved() for ‘SequentialFuture’ ... done
[17:38:23.681] Future #1
[17:38:23.681] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:23.681] - nx: 1
[17:38:23.681] - relay: TRUE
[17:38:23.681] - stdout: TRUE
[17:38:23.681] - signal: TRUE
[17:38:23.681] - resignal: FALSE
[17:38:23.681] - force: TRUE
[17:38:23.681] - relayed: [n=1] FALSE
[17:38:23.681] - queued futures: [n=1] FALSE
[17:38:23.682]  - until=1
[17:38:23.682]  - relaying element #1
[17:38:23.682] - relayed: [n=1] TRUE
[17:38:23.682] - queued futures: [n=1] TRUE
[17:38:23.682] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:23.682]  length: 0 (resolved future 1)
[17:38:23.682] Relaying remaining futures
[17:38:23.682] signalConditionsASAP(NULL, pos=0) ...
[17:38:23.682] - nx: 1
[17:38:23.682] - relay: TRUE
[17:38:23.683] - stdout: TRUE
[17:38:23.683] - signal: TRUE
[17:38:23.683] - resignal: FALSE
[17:38:23.683] - force: TRUE
[17:38:23.683] - relayed: [n=1] TRUE
[17:38:23.683] - queued futures: [n=1] TRUE
 - flush all
[17:38:23.683] - relayed: [n=1] TRUE
[17:38:23.683] - queued futures: [n=1] TRUE
[17:38:23.683] signalConditionsASAP(NULL, pos=0) ... done
[17:38:23.683] resolve() on list ... DONE
[17:38:23.684]  - Number of value chunks collected: 1
[17:38:23.684] Resolving 1 futures (chunks) ... DONE
[17:38:23.684] Reducing values from 1 chunks ...
[17:38:23.684]  - Number of values collected after concatenation: 2
[17:38:23.684]  - Number of values expected: 2
[17:38:23.684] Reducing values from 1 chunks ... DONE
[17:38:23.684] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[17:38:23.684] future_mapply() ...
[17:38:23.685] Number of chunks: 1
[17:38:23.685] getGlobalsAndPackagesXApply() ...
[17:38:23.685]  - future.globals: TRUE
[17:38:23.685] getGlobalsAndPackages() ...
[17:38:23.685] Searching for globals...
[17:38:23.686] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:38:23.687] Searching for globals ... DONE
[17:38:23.687] Resolving globals: FALSE
[17:38:23.687] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:38:23.687] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:38:23.688] - globals: [1] ‘FUN’
[17:38:23.688] 
[17:38:23.688] getGlobalsAndPackages() ... DONE
[17:38:23.688]  - globals found/used: [n=1] ‘FUN’
[17:38:23.688]  - needed namespaces: [n=0] 
[17:38:23.688] Finding globals ... DONE
[17:38:23.688] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:38:23.689] List of 2
[17:38:23.689]  $ ...future.FUN:function (x, y)  
[17:38:23.689]  $ MoreArgs     : NULL
[17:38:23.689]  - attr(*, "where")=List of 2
[17:38:23.689]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:23.689]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:38:23.689]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:23.689]  - attr(*, "resolved")= logi FALSE
[17:38:23.689]  - attr(*, "total_size")= num NA
[17:38:23.695] Packages to be attached in all futures: [n=0] 
[17:38:23.695] getGlobalsAndPackagesXApply() ... DONE
[17:38:23.695] Number of futures (= number of chunks): 1
[17:38:23.695] Launching 1 futures (chunks) ...
[17:38:23.695] Chunk #1 of 1 ...
[17:38:23.695]  - Finding globals in '...' for chunk #1 ...
[17:38:23.696] getGlobalsAndPackages() ...
[17:38:23.696] Searching for globals...
[17:38:23.696] 
[17:38:23.697] Searching for globals ... DONE
[17:38:23.697] - globals: [0] <none>
[17:38:23.697] getGlobalsAndPackages() ... DONE
[17:38:23.697]    + additional globals found: [n=0] 
[17:38:23.697]    + additional namespaces needed: [n=0] 
[17:38:23.697]  - Finding globals in '...' for chunk #1 ... DONE
[17:38:23.697]  - seeds: <none>
[17:38:23.697]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:23.697] getGlobalsAndPackages() ...
[17:38:23.698] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:23.698] Resolving globals: FALSE
[17:38:23.698] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:38:23.699] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:38:23.699] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:23.699] 
[17:38:23.699] getGlobalsAndPackages() ... DONE
[17:38:23.699] run() for ‘Future’ ...
[17:38:23.699] - state: ‘created’
[17:38:23.699] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:38:23.700] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:23.700] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:23.700]   - Field: ‘label’
[17:38:23.700]   - Field: ‘local’
[17:38:23.700]   - Field: ‘owner’
[17:38:23.700]   - Field: ‘envir’
[17:38:23.700]   - Field: ‘packages’
[17:38:23.700]   - Field: ‘gc’
[17:38:23.701]   - Field: ‘conditions’
[17:38:23.701]   - Field: ‘expr’
[17:38:23.701]   - Field: ‘uuid’
[17:38:23.701]   - Field: ‘seed’
[17:38:23.701]   - Field: ‘version’
[17:38:23.701]   - Field: ‘result’
[17:38:23.701]   - Field: ‘asynchronous’
[17:38:23.701]   - Field: ‘calls’
[17:38:23.701]   - Field: ‘globals’
[17:38:23.701]   - Field: ‘stdout’
[17:38:23.701]   - Field: ‘earlySignal’
[17:38:23.702]   - Field: ‘lazy’
[17:38:23.702]   - Field: ‘state’
[17:38:23.702] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:23.702] - Launch lazy future ...
[17:38:23.702] Packages needed by the future expression (n = 0): <none>
[17:38:23.702] Packages needed by future strategies (n = 0): <none>
[17:38:23.703] {
[17:38:23.703]     {
[17:38:23.703]         {
[17:38:23.703]             ...future.startTime <- base::Sys.time()
[17:38:23.703]             {
[17:38:23.703]                 {
[17:38:23.703]                   {
[17:38:23.703]                     base::local({
[17:38:23.703]                       has_future <- base::requireNamespace("future", 
[17:38:23.703]                         quietly = TRUE)
[17:38:23.703]                       if (has_future) {
[17:38:23.703]                         ns <- base::getNamespace("future")
[17:38:23.703]                         version <- ns[[".package"]][["version"]]
[17:38:23.703]                         if (is.null(version)) 
[17:38:23.703]                           version <- utils::packageVersion("future")
[17:38:23.703]                       }
[17:38:23.703]                       else {
[17:38:23.703]                         version <- NULL
[17:38:23.703]                       }
[17:38:23.703]                       if (!has_future || version < "1.8.0") {
[17:38:23.703]                         info <- base::c(r_version = base::gsub("R version ", 
[17:38:23.703]                           "", base::R.version$version.string), 
[17:38:23.703]                           platform = base::sprintf("%s (%s-bit)", 
[17:38:23.703]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:23.703]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:23.703]                             "release", "version")], collapse = " "), 
[17:38:23.703]                           hostname = base::Sys.info()[["nodename"]])
[17:38:23.703]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:38:23.703]                           info)
[17:38:23.703]                         info <- base::paste(info, collapse = "; ")
[17:38:23.703]                         if (!has_future) {
[17:38:23.703]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:23.703]                             info)
[17:38:23.703]                         }
[17:38:23.703]                         else {
[17:38:23.703]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:23.703]                             info, version)
[17:38:23.703]                         }
[17:38:23.703]                         base::stop(msg)
[17:38:23.703]                       }
[17:38:23.703]                     })
[17:38:23.703]                   }
[17:38:23.703]                   ...future.strategy.old <- future::plan("list")
[17:38:23.703]                   options(future.plan = NULL)
[17:38:23.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:23.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:23.703]                 }
[17:38:23.703]                 ...future.workdir <- getwd()
[17:38:23.703]             }
[17:38:23.703]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:23.703]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:23.703]         }
[17:38:23.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:23.703]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:23.703]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:23.703]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:23.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:23.703]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:23.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:23.703]             base::names(...future.oldOptions))
[17:38:23.703]     }
[17:38:23.703]     if (TRUE) {
[17:38:23.703]     }
[17:38:23.703]     else {
[17:38:23.703]         if (NA) {
[17:38:23.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:23.703]                 open = "w")
[17:38:23.703]         }
[17:38:23.703]         else {
[17:38:23.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:23.703]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:23.703]         }
[17:38:23.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:23.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:23.703]             base::sink(type = "output", split = FALSE)
[17:38:23.703]             base::close(...future.stdout)
[17:38:23.703]         }, add = TRUE)
[17:38:23.703]     }
[17:38:23.703]     ...future.frame <- base::sys.nframe()
[17:38:23.703]     ...future.conditions <- base::list()
[17:38:23.703]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:23.703]     if (FALSE) {
[17:38:23.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:23.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:23.703]     }
[17:38:23.703]     ...future.result <- base::tryCatch({
[17:38:23.703]         base::withCallingHandlers({
[17:38:23.703]             ...future.value <- base::withVisible(base::local({
[17:38:23.703]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:23.703]                 if (!identical(...future.globals.maxSize.org, 
[17:38:23.703]                   ...future.globals.maxSize)) {
[17:38:23.703]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:23.703]                   on.exit(options(oopts), add = TRUE)
[17:38:23.703]                 }
[17:38:23.703]                 {
[17:38:23.703]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:23.703]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:38:23.703]                     USE.NAMES = FALSE)
[17:38:23.703]                   do.call(mapply, args = args)
[17:38:23.703]                 }
[17:38:23.703]             }))
[17:38:23.703]             future::FutureResult(value = ...future.value$value, 
[17:38:23.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:23.703]                   ...future.rng), globalenv = if (FALSE) 
[17:38:23.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:23.703]                     ...future.globalenv.names))
[17:38:23.703]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:23.703]         }, condition = base::local({
[17:38:23.703]             c <- base::c
[17:38:23.703]             inherits <- base::inherits
[17:38:23.703]             invokeRestart <- base::invokeRestart
[17:38:23.703]             length <- base::length
[17:38:23.703]             list <- base::list
[17:38:23.703]             seq.int <- base::seq.int
[17:38:23.703]             signalCondition <- base::signalCondition
[17:38:23.703]             sys.calls <- base::sys.calls
[17:38:23.703]             `[[` <- base::`[[`
[17:38:23.703]             `+` <- base::`+`
[17:38:23.703]             `<<-` <- base::`<<-`
[17:38:23.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:23.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:23.703]                   3L)]
[17:38:23.703]             }
[17:38:23.703]             function(cond) {
[17:38:23.703]                 is_error <- inherits(cond, "error")
[17:38:23.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:23.703]                   NULL)
[17:38:23.703]                 if (is_error) {
[17:38:23.703]                   sessionInformation <- function() {
[17:38:23.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:23.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:23.703]                       search = base::search(), system = base::Sys.info())
[17:38:23.703]                   }
[17:38:23.703]                   ...future.conditions[[length(...future.conditions) + 
[17:38:23.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:23.703]                     cond$call), session = sessionInformation(), 
[17:38:23.703]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:23.703]                   signalCondition(cond)
[17:38:23.703]                 }
[17:38:23.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:23.703]                 "immediateCondition"))) {
[17:38:23.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:23.703]                   ...future.conditions[[length(...future.conditions) + 
[17:38:23.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:23.703]                   if (TRUE && !signal) {
[17:38:23.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:23.703]                     {
[17:38:23.703]                       inherits <- base::inherits
[17:38:23.703]                       invokeRestart <- base::invokeRestart
[17:38:23.703]                       is.null <- base::is.null
[17:38:23.703]                       muffled <- FALSE
[17:38:23.703]                       if (inherits(cond, "message")) {
[17:38:23.703]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:23.703]                         if (muffled) 
[17:38:23.703]                           invokeRestart("muffleMessage")
[17:38:23.703]                       }
[17:38:23.703]                       else if (inherits(cond, "warning")) {
[17:38:23.703]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:23.703]                         if (muffled) 
[17:38:23.703]                           invokeRestart("muffleWarning")
[17:38:23.703]                       }
[17:38:23.703]                       else if (inherits(cond, "condition")) {
[17:38:23.703]                         if (!is.null(pattern)) {
[17:38:23.703]                           computeRestarts <- base::computeRestarts
[17:38:23.703]                           grepl <- base::grepl
[17:38:23.703]                           restarts <- computeRestarts(cond)
[17:38:23.703]                           for (restart in restarts) {
[17:38:23.703]                             name <- restart$name
[17:38:23.703]                             if (is.null(name)) 
[17:38:23.703]                               next
[17:38:23.703]                             if (!grepl(pattern, name)) 
[17:38:23.703]                               next
[17:38:23.703]                             invokeRestart(restart)
[17:38:23.703]                             muffled <- TRUE
[17:38:23.703]                             break
[17:38:23.703]                           }
[17:38:23.703]                         }
[17:38:23.703]                       }
[17:38:23.703]                       invisible(muffled)
[17:38:23.703]                     }
[17:38:23.703]                     muffleCondition(cond, pattern = "^muffle")
[17:38:23.703]                   }
[17:38:23.703]                 }
[17:38:23.703]                 else {
[17:38:23.703]                   if (TRUE) {
[17:38:23.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:23.703]                     {
[17:38:23.703]                       inherits <- base::inherits
[17:38:23.703]                       invokeRestart <- base::invokeRestart
[17:38:23.703]                       is.null <- base::is.null
[17:38:23.703]                       muffled <- FALSE
[17:38:23.703]                       if (inherits(cond, "message")) {
[17:38:23.703]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:23.703]                         if (muffled) 
[17:38:23.703]                           invokeRestart("muffleMessage")
[17:38:23.703]                       }
[17:38:23.703]                       else if (inherits(cond, "warning")) {
[17:38:23.703]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:23.703]                         if (muffled) 
[17:38:23.703]                           invokeRestart("muffleWarning")
[17:38:23.703]                       }
[17:38:23.703]                       else if (inherits(cond, "condition")) {
[17:38:23.703]                         if (!is.null(pattern)) {
[17:38:23.703]                           computeRestarts <- base::computeRestarts
[17:38:23.703]                           grepl <- base::grepl
[17:38:23.703]                           restarts <- computeRestarts(cond)
[17:38:23.703]                           for (restart in restarts) {
[17:38:23.703]                             name <- restart$name
[17:38:23.703]                             if (is.null(name)) 
[17:38:23.703]                               next
[17:38:23.703]                             if (!grepl(pattern, name)) 
[17:38:23.703]                               next
[17:38:23.703]                             invokeRestart(restart)
[17:38:23.703]                             muffled <- TRUE
[17:38:23.703]                             break
[17:38:23.703]                           }
[17:38:23.703]                         }
[17:38:23.703]                       }
[17:38:23.703]                       invisible(muffled)
[17:38:23.703]                     }
[17:38:23.703]                     muffleCondition(cond, pattern = "^muffle")
[17:38:23.703]                   }
[17:38:23.703]                 }
[17:38:23.703]             }
[17:38:23.703]         }))
[17:38:23.703]     }, error = function(ex) {
[17:38:23.703]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:23.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:23.703]                 ...future.rng), started = ...future.startTime, 
[17:38:23.703]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:23.703]             version = "1.8"), class = "FutureResult")
[17:38:23.703]     }, finally = {
[17:38:23.703]         if (!identical(...future.workdir, getwd())) 
[17:38:23.703]             setwd(...future.workdir)
[17:38:23.703]         {
[17:38:23.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:23.703]                 ...future.oldOptions$nwarnings <- NULL
[17:38:23.703]             }
[17:38:23.703]             base::options(...future.oldOptions)
[17:38:23.703]             if (.Platform$OS.type == "windows") {
[17:38:23.703]                 old_names <- names(...future.oldEnvVars)
[17:38:23.703]                 envs <- base::Sys.getenv()
[17:38:23.703]                 names <- names(envs)
[17:38:23.703]                 common <- intersect(names, old_names)
[17:38:23.703]                 added <- setdiff(names, old_names)
[17:38:23.703]                 removed <- setdiff(old_names, names)
[17:38:23.703]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:23.703]                   envs[common]]
[17:38:23.703]                 NAMES <- toupper(changed)
[17:38:23.703]                 args <- list()
[17:38:23.703]                 for (kk in seq_along(NAMES)) {
[17:38:23.703]                   name <- changed[[kk]]
[17:38:23.703]                   NAME <- NAMES[[kk]]
[17:38:23.703]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:23.703]                     next
[17:38:23.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:23.703]                 }
[17:38:23.703]                 NAMES <- toupper(added)
[17:38:23.703]                 for (kk in seq_along(NAMES)) {
[17:38:23.703]                   name <- added[[kk]]
[17:38:23.703]                   NAME <- NAMES[[kk]]
[17:38:23.703]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:23.703]                     next
[17:38:23.703]                   args[[name]] <- ""
[17:38:23.703]                 }
[17:38:23.703]                 NAMES <- toupper(removed)
[17:38:23.703]                 for (kk in seq_along(NAMES)) {
[17:38:23.703]                   name <- removed[[kk]]
[17:38:23.703]                   NAME <- NAMES[[kk]]
[17:38:23.703]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:23.703]                     next
[17:38:23.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:23.703]                 }
[17:38:23.703]                 if (length(args) > 0) 
[17:38:23.703]                   base::do.call(base::Sys.setenv, args = args)
[17:38:23.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:23.703]             }
[17:38:23.703]             else {
[17:38:23.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:23.703]             }
[17:38:23.703]             {
[17:38:23.703]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:23.703]                   0L) {
[17:38:23.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:23.703]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:23.703]                   base::options(opts)
[17:38:23.703]                 }
[17:38:23.703]                 {
[17:38:23.703]                   {
[17:38:23.703]                     NULL
[17:38:23.703]                     RNGkind("Mersenne-Twister")
[17:38:23.703]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:23.703]                       inherits = FALSE)
[17:38:23.703]                   }
[17:38:23.703]                   options(future.plan = NULL)
[17:38:23.703]                   if (is.na(NA_character_)) 
[17:38:23.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:23.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:23.703]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:23.703]                     .init = FALSE)
[17:38:23.703]                 }
[17:38:23.703]             }
[17:38:23.703]         }
[17:38:23.703]     })
[17:38:23.703]     if (FALSE) {
[17:38:23.703]         base::sink(type = "output", split = FALSE)
[17:38:23.703]         if (NA) {
[17:38:23.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:23.703]         }
[17:38:23.703]         else {
[17:38:23.703]             ...future.result["stdout"] <- base::list(NULL)
[17:38:23.703]         }
[17:38:23.703]         base::close(...future.stdout)
[17:38:23.703]         ...future.stdout <- NULL
[17:38:23.703]     }
[17:38:23.703]     ...future.result$conditions <- ...future.conditions
[17:38:23.703]     ...future.result$finished <- base::Sys.time()
[17:38:23.703]     ...future.result
[17:38:23.703] }
[17:38:23.704] assign_globals() ...
[17:38:23.704] List of 5
[17:38:23.704]  $ ...future.FUN            :function (x, y)  
[17:38:23.704]  $ MoreArgs                 : NULL
[17:38:23.704]  $ ...future.elements_ii    :List of 2
[17:38:23.704]   ..$ :List of 2
[17:38:23.704]   .. ..$ : int 1
[17:38:23.704]   .. ..$ : int 0
[17:38:23.704]   ..$ :List of 2
[17:38:23.704]   .. ..$ : int 0
[17:38:23.704]   .. ..$ : int 1
[17:38:23.704]  $ ...future.seeds_ii       : NULL
[17:38:23.704]  $ ...future.globals.maxSize: NULL
[17:38:23.704]  - attr(*, "where")=List of 5
[17:38:23.704]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:23.704]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:38:23.704]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:23.704]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:23.704]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:23.704]  - attr(*, "resolved")= logi FALSE
[17:38:23.704]  - attr(*, "total_size")= num 6480
[17:38:23.704]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:23.704]  - attr(*, "already-done")= logi TRUE
[17:38:23.710] - reassign environment for ‘...future.FUN’
[17:38:23.710] - copied ‘...future.FUN’ to environment
[17:38:23.710] - copied ‘MoreArgs’ to environment
[17:38:23.710] - copied ‘...future.elements_ii’ to environment
[17:38:23.710] - copied ‘...future.seeds_ii’ to environment
[17:38:23.710] - copied ‘...future.globals.maxSize’ to environment
[17:38:23.710] assign_globals() ... done
[17:38:23.711] plan(): Setting new future strategy stack:
[17:38:23.711] List of future strategies:
[17:38:23.711] 1. sequential:
[17:38:23.711]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:23.711]    - tweaked: FALSE
[17:38:23.711]    - call: NULL
[17:38:23.711] plan(): nbrOfWorkers() = 1
[17:38:24.213] plan(): Setting new future strategy stack:
[17:38:24.213] List of future strategies:
[17:38:24.213] 1. sequential:
[17:38:24.213]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:24.213]    - tweaked: FALSE
[17:38:24.213]    - call: plan(strategy)
[17:38:24.214] plan(): nbrOfWorkers() = 1
[17:38:24.214] SequentialFuture started (and completed)
[17:38:24.214] - Launch lazy future ... done
[17:38:24.214] run() for ‘SequentialFuture’ ... done
[17:38:24.214] Created future:
[17:38:24.214] SequentialFuture:
[17:38:24.214] Label: ‘future_mapply-1’
[17:38:24.214] Expression:
[17:38:24.214] {
[17:38:24.214]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:24.214]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:24.214]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:24.214]         on.exit(options(oopts), add = TRUE)
[17:38:24.214]     }
[17:38:24.214]     {
[17:38:24.214]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:24.214]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:38:24.214]         do.call(mapply, args = args)
[17:38:24.214]     }
[17:38:24.214] }
[17:38:24.214] Lazy evaluation: FALSE
[17:38:24.214] Asynchronous evaluation: FALSE
[17:38:24.214] Local evaluation: TRUE
[17:38:24.214] Environment: R_GlobalEnv
[17:38:24.214] Capture standard output: NA
[17:38:24.214] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:24.214] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:24.214] Packages: <none>
[17:38:24.214] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:24.214] Resolved: TRUE
[17:38:24.214] Value: 224 bytes of class ‘list’
[17:38:24.214] Early signaling: FALSE
[17:38:24.214] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:24.214] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:24.215] Chunk #1 of 1 ... DONE
[17:38:24.215] Launching 1 futures (chunks) ... DONE
[17:38:24.215] Resolving 1 futures (chunks) ...
[17:38:24.216] resolve() on list ...
[17:38:24.216]  recursive: 0
[17:38:24.216]  length: 1
[17:38:24.216] 
[17:38:24.216] resolved() for ‘SequentialFuture’ ...
[17:38:24.216] - state: ‘finished’
[17:38:24.216] - run: TRUE
[17:38:24.216] - result: ‘FutureResult’
[17:38:24.216] resolved() for ‘SequentialFuture’ ... done
[17:38:24.216] Future #1
[17:38:24.217] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:24.217] - nx: 1
[17:38:24.217] - relay: TRUE
[17:38:24.217] - stdout: TRUE
[17:38:24.217] - signal: TRUE
[17:38:24.217] - resignal: FALSE
[17:38:24.217] - force: TRUE
[17:38:24.217] - relayed: [n=1] FALSE
[17:38:24.217] - queued futures: [n=1] FALSE
[17:38:24.217]  - until=1
[17:38:24.217]  - relaying element #1
[17:38:24.218] - relayed: [n=1] TRUE
[17:38:24.218] - queued futures: [n=1] TRUE
[17:38:24.218] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:24.218]  length: 0 (resolved future 1)
[17:38:24.218] Relaying remaining futures
[17:38:24.218] signalConditionsASAP(NULL, pos=0) ...
[17:38:24.218] - nx: 1
[17:38:24.218] - relay: TRUE
[17:38:24.218] - stdout: TRUE
[17:38:24.218] - signal: TRUE
[17:38:24.219] - resignal: FALSE
[17:38:24.219] - force: TRUE
[17:38:24.219] - relayed: [n=1] TRUE
[17:38:24.219] - queued futures: [n=1] TRUE
 - flush all
[17:38:24.219] - relayed: [n=1] TRUE
[17:38:24.219] - queued futures: [n=1] TRUE
[17:38:24.219] signalConditionsASAP(NULL, pos=0) ... done
[17:38:24.219] resolve() on list ... DONE
[17:38:24.219]  - Number of value chunks collected: 1
[17:38:24.219] Resolving 1 futures (chunks) ... DONE
[17:38:24.219] Reducing values from 1 chunks ...
[17:38:24.220]  - Number of values collected after concatenation: 2
[17:38:24.220]  - Number of values expected: 2
[17:38:24.220] Reducing values from 1 chunks ... DONE
[17:38:24.220] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('sequential') ... DONE
* plan('multicore') ...
[17:38:24.220] plan(): Setting new future strategy stack:
[17:38:24.220] List of future strategies:
[17:38:24.220] 1. multicore:
[17:38:24.220]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:24.220]    - tweaked: FALSE
[17:38:24.220]    - call: plan(strategy)
[17:38:24.226] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[17:38:24.226] future_lapply() ...
[17:38:24.230] Number of chunks: 1
[17:38:24.230] getGlobalsAndPackagesXApply() ...
[17:38:24.230]  - future.globals: TRUE
[17:38:24.230] getGlobalsAndPackages() ...
[17:38:24.230] Searching for globals...
[17:38:24.232] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:38:24.232] Searching for globals ... DONE
[17:38:24.232] Resolving globals: FALSE
[17:38:24.232] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:38:24.233] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:38:24.233] - globals: [1] ‘FUN’
[17:38:24.233] 
[17:38:24.233] getGlobalsAndPackages() ... DONE
[17:38:24.233]  - globals found/used: [n=1] ‘FUN’
[17:38:24.233]  - needed namespaces: [n=0] 
[17:38:24.233] Finding globals ... DONE
[17:38:24.234]  - use_args: TRUE
[17:38:24.234]  - Getting '...' globals ...
[17:38:24.234] resolve() on list ...
[17:38:24.234]  recursive: 0
[17:38:24.234]  length: 1
[17:38:24.234]  elements: ‘...’
[17:38:24.234]  length: 0 (resolved future 1)
[17:38:24.234] resolve() on list ... DONE
[17:38:24.234]    - '...' content: [n=0] 
[17:38:24.235] List of 1
[17:38:24.235]  $ ...: list()
[17:38:24.235]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:24.235]  - attr(*, "where")=List of 1
[17:38:24.235]   ..$ ...:<environment: 0x5628aaef38e8> 
[17:38:24.235]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:24.235]  - attr(*, "resolved")= logi TRUE
[17:38:24.235]  - attr(*, "total_size")= num NA
[17:38:24.237]  - Getting '...' globals ... DONE
[17:38:24.237] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:38:24.237] List of 2
[17:38:24.237]  $ ...future.FUN:function (x)  
[17:38:24.237]  $ ...          : list()
[17:38:24.237]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:24.237]  - attr(*, "where")=List of 2
[17:38:24.237]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:24.237]   ..$ ...          :<environment: 0x5628aaef38e8> 
[17:38:24.237]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:24.237]  - attr(*, "resolved")= logi FALSE
[17:38:24.237]  - attr(*, "total_size")= num 4720
[17:38:24.240] Packages to be attached in all futures: [n=0] 
[17:38:24.240] getGlobalsAndPackagesXApply() ... DONE
[17:38:24.240] Number of futures (= number of chunks): 1
[17:38:24.240] Launching 1 futures (chunks) ...
[17:38:24.240] Chunk #1 of 1 ...
[17:38:24.241]  - Finding globals in 'X' for chunk #1 ...
[17:38:24.241] getGlobalsAndPackages() ...
[17:38:24.241] Searching for globals...
[17:38:24.241] 
[17:38:24.241] Searching for globals ... DONE
[17:38:24.241] - globals: [0] <none>
[17:38:24.241] getGlobalsAndPackages() ... DONE
[17:38:24.241]    + additional globals found: [n=0] 
[17:38:24.241]    + additional namespaces needed: [n=0] 
[17:38:24.242]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:24.242]  - seeds: <none>
[17:38:24.242]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:24.242] getGlobalsAndPackages() ...
[17:38:24.242] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:24.242] Resolving globals: FALSE
[17:38:24.242] Tweak future expression to call with '...' arguments ...
[17:38:24.242] {
[17:38:24.242]     do.call(function(...) {
[17:38:24.242]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:24.242]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:24.242]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:24.242]             on.exit(options(oopts), add = TRUE)
[17:38:24.242]         }
[17:38:24.242]         {
[17:38:24.242]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:24.242]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:24.242]                 ...future.FUN(...future.X_jj, ...)
[17:38:24.242]             })
[17:38:24.242]         }
[17:38:24.242]     }, args = future.call.arguments)
[17:38:24.242] }
[17:38:24.243] Tweak future expression to call with '...' arguments ... DONE
[17:38:24.243] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:24.243] 
[17:38:24.243] getGlobalsAndPackages() ... DONE
[17:38:24.243] run() for ‘Future’ ...
[17:38:24.243] - state: ‘created’
[17:38:24.244] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:24.247] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:24.247] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:24.247]   - Field: ‘label’
[17:38:24.247]   - Field: ‘local’
[17:38:24.248]   - Field: ‘owner’
[17:38:24.248]   - Field: ‘envir’
[17:38:24.248]   - Field: ‘packages’
[17:38:24.248]   - Field: ‘gc’
[17:38:24.248]   - Field: ‘conditions’
[17:38:24.248]   - Field: ‘expr’
[17:38:24.248]   - Field: ‘uuid’
[17:38:24.248]   - Field: ‘seed’
[17:38:24.248]   - Field: ‘version’
[17:38:24.249]   - Field: ‘result’
[17:38:24.249]   - Field: ‘asynchronous’
[17:38:24.249]   - Field: ‘calls’
[17:38:24.249]   - Field: ‘globals’
[17:38:24.249]   - Field: ‘stdout’
[17:38:24.249]   - Field: ‘earlySignal’
[17:38:24.249]   - Field: ‘lazy’
[17:38:24.249]   - Field: ‘state’
[17:38:24.249] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:24.249] - Launch lazy future ...
[17:38:24.250] Packages needed by the future expression (n = 0): <none>
[17:38:24.250] Packages needed by future strategies (n = 0): <none>
[17:38:24.250] {
[17:38:24.250]     {
[17:38:24.250]         {
[17:38:24.250]             ...future.startTime <- base::Sys.time()
[17:38:24.250]             {
[17:38:24.250]                 {
[17:38:24.250]                   {
[17:38:24.250]                     base::local({
[17:38:24.250]                       has_future <- base::requireNamespace("future", 
[17:38:24.250]                         quietly = TRUE)
[17:38:24.250]                       if (has_future) {
[17:38:24.250]                         ns <- base::getNamespace("future")
[17:38:24.250]                         version <- ns[[".package"]][["version"]]
[17:38:24.250]                         if (is.null(version)) 
[17:38:24.250]                           version <- utils::packageVersion("future")
[17:38:24.250]                       }
[17:38:24.250]                       else {
[17:38:24.250]                         version <- NULL
[17:38:24.250]                       }
[17:38:24.250]                       if (!has_future || version < "1.8.0") {
[17:38:24.250]                         info <- base::c(r_version = base::gsub("R version ", 
[17:38:24.250]                           "", base::R.version$version.string), 
[17:38:24.250]                           platform = base::sprintf("%s (%s-bit)", 
[17:38:24.250]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:24.250]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:24.250]                             "release", "version")], collapse = " "), 
[17:38:24.250]                           hostname = base::Sys.info()[["nodename"]])
[17:38:24.250]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:38:24.250]                           info)
[17:38:24.250]                         info <- base::paste(info, collapse = "; ")
[17:38:24.250]                         if (!has_future) {
[17:38:24.250]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:24.250]                             info)
[17:38:24.250]                         }
[17:38:24.250]                         else {
[17:38:24.250]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:24.250]                             info, version)
[17:38:24.250]                         }
[17:38:24.250]                         base::stop(msg)
[17:38:24.250]                       }
[17:38:24.250]                     })
[17:38:24.250]                   }
[17:38:24.250]                   ...future.strategy.old <- future::plan("list")
[17:38:24.250]                   options(future.plan = NULL)
[17:38:24.250]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:24.250]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:24.250]                 }
[17:38:24.250]                 ...future.workdir <- getwd()
[17:38:24.250]             }
[17:38:24.250]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:24.250]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:24.250]         }
[17:38:24.250]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:24.250]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:24.250]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:24.250]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:24.250]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:24.250]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:24.250]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:24.250]             base::names(...future.oldOptions))
[17:38:24.250]     }
[17:38:24.250]     if (FALSE) {
[17:38:24.250]     }
[17:38:24.250]     else {
[17:38:24.250]         if (FALSE) {
[17:38:24.250]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:24.250]                 open = "w")
[17:38:24.250]         }
[17:38:24.250]         else {
[17:38:24.250]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:24.250]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:24.250]         }
[17:38:24.250]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:24.250]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:24.250]             base::sink(type = "output", split = FALSE)
[17:38:24.250]             base::close(...future.stdout)
[17:38:24.250]         }, add = TRUE)
[17:38:24.250]     }
[17:38:24.250]     ...future.frame <- base::sys.nframe()
[17:38:24.250]     ...future.conditions <- base::list()
[17:38:24.250]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:24.250]     if (FALSE) {
[17:38:24.250]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:24.250]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:24.250]     }
[17:38:24.250]     ...future.result <- base::tryCatch({
[17:38:24.250]         base::withCallingHandlers({
[17:38:24.250]             ...future.value <- base::withVisible(base::local({
[17:38:24.250]                 do.call(function(...) {
[17:38:24.250]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:24.250]                   if (!identical(...future.globals.maxSize.org, 
[17:38:24.250]                     ...future.globals.maxSize)) {
[17:38:24.250]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:24.250]                     on.exit(options(oopts), add = TRUE)
[17:38:24.250]                   }
[17:38:24.250]                   {
[17:38:24.250]                     lapply(seq_along(...future.elements_ii), 
[17:38:24.250]                       FUN = function(jj) {
[17:38:24.250]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:24.250]                         ...future.FUN(...future.X_jj, ...)
[17:38:24.250]                       })
[17:38:24.250]                   }
[17:38:24.250]                 }, args = future.call.arguments)
[17:38:24.250]             }))
[17:38:24.250]             future::FutureResult(value = ...future.value$value, 
[17:38:24.250]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:24.250]                   ...future.rng), globalenv = if (FALSE) 
[17:38:24.250]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:24.250]                     ...future.globalenv.names))
[17:38:24.250]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:24.250]         }, condition = base::local({
[17:38:24.250]             c <- base::c
[17:38:24.250]             inherits <- base::inherits
[17:38:24.250]             invokeRestart <- base::invokeRestart
[17:38:24.250]             length <- base::length
[17:38:24.250]             list <- base::list
[17:38:24.250]             seq.int <- base::seq.int
[17:38:24.250]             signalCondition <- base::signalCondition
[17:38:24.250]             sys.calls <- base::sys.calls
[17:38:24.250]             `[[` <- base::`[[`
[17:38:24.250]             `+` <- base::`+`
[17:38:24.250]             `<<-` <- base::`<<-`
[17:38:24.250]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:24.250]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:24.250]                   3L)]
[17:38:24.250]             }
[17:38:24.250]             function(cond) {
[17:38:24.250]                 is_error <- inherits(cond, "error")
[17:38:24.250]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:24.250]                   NULL)
[17:38:24.250]                 if (is_error) {
[17:38:24.250]                   sessionInformation <- function() {
[17:38:24.250]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:24.250]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:24.250]                       search = base::search(), system = base::Sys.info())
[17:38:24.250]                   }
[17:38:24.250]                   ...future.conditions[[length(...future.conditions) + 
[17:38:24.250]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:24.250]                     cond$call), session = sessionInformation(), 
[17:38:24.250]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:24.250]                   signalCondition(cond)
[17:38:24.250]                 }
[17:38:24.250]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:24.250]                 "immediateCondition"))) {
[17:38:24.250]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:24.250]                   ...future.conditions[[length(...future.conditions) + 
[17:38:24.250]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:24.250]                   if (TRUE && !signal) {
[17:38:24.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:24.250]                     {
[17:38:24.250]                       inherits <- base::inherits
[17:38:24.250]                       invokeRestart <- base::invokeRestart
[17:38:24.250]                       is.null <- base::is.null
[17:38:24.250]                       muffled <- FALSE
[17:38:24.250]                       if (inherits(cond, "message")) {
[17:38:24.250]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:24.250]                         if (muffled) 
[17:38:24.250]                           invokeRestart("muffleMessage")
[17:38:24.250]                       }
[17:38:24.250]                       else if (inherits(cond, "warning")) {
[17:38:24.250]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:24.250]                         if (muffled) 
[17:38:24.250]                           invokeRestart("muffleWarning")
[17:38:24.250]                       }
[17:38:24.250]                       else if (inherits(cond, "condition")) {
[17:38:24.250]                         if (!is.null(pattern)) {
[17:38:24.250]                           computeRestarts <- base::computeRestarts
[17:38:24.250]                           grepl <- base::grepl
[17:38:24.250]                           restarts <- computeRestarts(cond)
[17:38:24.250]                           for (restart in restarts) {
[17:38:24.250]                             name <- restart$name
[17:38:24.250]                             if (is.null(name)) 
[17:38:24.250]                               next
[17:38:24.250]                             if (!grepl(pattern, name)) 
[17:38:24.250]                               next
[17:38:24.250]                             invokeRestart(restart)
[17:38:24.250]                             muffled <- TRUE
[17:38:24.250]                             break
[17:38:24.250]                           }
[17:38:24.250]                         }
[17:38:24.250]                       }
[17:38:24.250]                       invisible(muffled)
[17:38:24.250]                     }
[17:38:24.250]                     muffleCondition(cond, pattern = "^muffle")
[17:38:24.250]                   }
[17:38:24.250]                 }
[17:38:24.250]                 else {
[17:38:24.250]                   if (TRUE) {
[17:38:24.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:24.250]                     {
[17:38:24.250]                       inherits <- base::inherits
[17:38:24.250]                       invokeRestart <- base::invokeRestart
[17:38:24.250]                       is.null <- base::is.null
[17:38:24.250]                       muffled <- FALSE
[17:38:24.250]                       if (inherits(cond, "message")) {
[17:38:24.250]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:24.250]                         if (muffled) 
[17:38:24.250]                           invokeRestart("muffleMessage")
[17:38:24.250]                       }
[17:38:24.250]                       else if (inherits(cond, "warning")) {
[17:38:24.250]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:24.250]                         if (muffled) 
[17:38:24.250]                           invokeRestart("muffleWarning")
[17:38:24.250]                       }
[17:38:24.250]                       else if (inherits(cond, "condition")) {
[17:38:24.250]                         if (!is.null(pattern)) {
[17:38:24.250]                           computeRestarts <- base::computeRestarts
[17:38:24.250]                           grepl <- base::grepl
[17:38:24.250]                           restarts <- computeRestarts(cond)
[17:38:24.250]                           for (restart in restarts) {
[17:38:24.250]                             name <- restart$name
[17:38:24.250]                             if (is.null(name)) 
[17:38:24.250]                               next
[17:38:24.250]                             if (!grepl(pattern, name)) 
[17:38:24.250]                               next
[17:38:24.250]                             invokeRestart(restart)
[17:38:24.250]                             muffled <- TRUE
[17:38:24.250]                             break
[17:38:24.250]                           }
[17:38:24.250]                         }
[17:38:24.250]                       }
[17:38:24.250]                       invisible(muffled)
[17:38:24.250]                     }
[17:38:24.250]                     muffleCondition(cond, pattern = "^muffle")
[17:38:24.250]                   }
[17:38:24.250]                 }
[17:38:24.250]             }
[17:38:24.250]         }))
[17:38:24.250]     }, error = function(ex) {
[17:38:24.250]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:24.250]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:24.250]                 ...future.rng), started = ...future.startTime, 
[17:38:24.250]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:24.250]             version = "1.8"), class = "FutureResult")
[17:38:24.250]     }, finally = {
[17:38:24.250]         if (!identical(...future.workdir, getwd())) 
[17:38:24.250]             setwd(...future.workdir)
[17:38:24.250]         {
[17:38:24.250]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:24.250]                 ...future.oldOptions$nwarnings <- NULL
[17:38:24.250]             }
[17:38:24.250]             base::options(...future.oldOptions)
[17:38:24.250]             if (.Platform$OS.type == "windows") {
[17:38:24.250]                 old_names <- names(...future.oldEnvVars)
[17:38:24.250]                 envs <- base::Sys.getenv()
[17:38:24.250]                 names <- names(envs)
[17:38:24.250]                 common <- intersect(names, old_names)
[17:38:24.250]                 added <- setdiff(names, old_names)
[17:38:24.250]                 removed <- setdiff(old_names, names)
[17:38:24.250]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:24.250]                   envs[common]]
[17:38:24.250]                 NAMES <- toupper(changed)
[17:38:24.250]                 args <- list()
[17:38:24.250]                 for (kk in seq_along(NAMES)) {
[17:38:24.250]                   name <- changed[[kk]]
[17:38:24.250]                   NAME <- NAMES[[kk]]
[17:38:24.250]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:24.250]                     next
[17:38:24.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:24.250]                 }
[17:38:24.250]                 NAMES <- toupper(added)
[17:38:24.250]                 for (kk in seq_along(NAMES)) {
[17:38:24.250]                   name <- added[[kk]]
[17:38:24.250]                   NAME <- NAMES[[kk]]
[17:38:24.250]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:24.250]                     next
[17:38:24.250]                   args[[name]] <- ""
[17:38:24.250]                 }
[17:38:24.250]                 NAMES <- toupper(removed)
[17:38:24.250]                 for (kk in seq_along(NAMES)) {
[17:38:24.250]                   name <- removed[[kk]]
[17:38:24.250]                   NAME <- NAMES[[kk]]
[17:38:24.250]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:24.250]                     next
[17:38:24.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:24.250]                 }
[17:38:24.250]                 if (length(args) > 0) 
[17:38:24.250]                   base::do.call(base::Sys.setenv, args = args)
[17:38:24.250]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:24.250]             }
[17:38:24.250]             else {
[17:38:24.250]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:24.250]             }
[17:38:24.250]             {
[17:38:24.250]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:24.250]                   0L) {
[17:38:24.250]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:24.250]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:24.250]                   base::options(opts)
[17:38:24.250]                 }
[17:38:24.250]                 {
[17:38:24.250]                   {
[17:38:24.250]                     NULL
[17:38:24.250]                     RNGkind("Mersenne-Twister")
[17:38:24.250]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:24.250]                       inherits = FALSE)
[17:38:24.250]                   }
[17:38:24.250]                   options(future.plan = NULL)
[17:38:24.250]                   if (is.na(NA_character_)) 
[17:38:24.250]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:24.250]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:24.250]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:24.250]                     .init = FALSE)
[17:38:24.250]                 }
[17:38:24.250]             }
[17:38:24.250]         }
[17:38:24.250]     })
[17:38:24.250]     if (TRUE) {
[17:38:24.250]         base::sink(type = "output", split = FALSE)
[17:38:24.250]         if (FALSE) {
[17:38:24.250]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:24.250]         }
[17:38:24.250]         else {
[17:38:24.250]             ...future.result["stdout"] <- base::list(NULL)
[17:38:24.250]         }
[17:38:24.250]         base::close(...future.stdout)
[17:38:24.250]         ...future.stdout <- NULL
[17:38:24.250]     }
[17:38:24.250]     ...future.result$conditions <- ...future.conditions
[17:38:24.250]     ...future.result$finished <- base::Sys.time()
[17:38:24.250]     ...future.result
[17:38:24.250] }
[17:38:24.252] assign_globals() ...
[17:38:24.252] List of 5
[17:38:24.252]  $ ...future.FUN            :function (x)  
[17:38:24.252]  $ future.call.arguments    : list()
[17:38:24.252]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:24.252]  $ ...future.elements_ii    :List of 2
[17:38:24.252]   ..$ : int 1
[17:38:24.252]   ..$ : int 0
[17:38:24.252]  $ ...future.seeds_ii       : NULL
[17:38:24.252]  $ ...future.globals.maxSize: NULL
[17:38:24.252]  - attr(*, "where")=List of 5
[17:38:24.252]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:24.252]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:24.252]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:24.252]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:24.252]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:24.252]  - attr(*, "resolved")= logi FALSE
[17:38:24.252]  - attr(*, "total_size")= num 4720
[17:38:24.252]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:24.252]  - attr(*, "already-done")= logi TRUE
[17:38:24.258] - reassign environment for ‘...future.FUN’
[17:38:24.259] - copied ‘...future.FUN’ to environment
[17:38:24.259] - copied ‘future.call.arguments’ to environment
[17:38:24.259] - copied ‘...future.elements_ii’ to environment
[17:38:24.259] - copied ‘...future.seeds_ii’ to environment
[17:38:24.259] - copied ‘...future.globals.maxSize’ to environment
[17:38:24.259] assign_globals() ... done
[17:38:24.259] plan(): Setting new future strategy stack:
[17:38:24.259] List of future strategies:
[17:38:24.259] 1. sequential:
[17:38:24.259]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:24.259]    - tweaked: FALSE
[17:38:24.259]    - call: NULL
[17:38:24.260] plan(): nbrOfWorkers() = 1
[17:38:24.762] plan(): Setting new future strategy stack:
[17:38:24.762] List of future strategies:
[17:38:24.762] 1. multicore:
[17:38:24.762]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:24.762]    - tweaked: FALSE
[17:38:24.762]    - call: plan(strategy)
[17:38:24.766] plan(): nbrOfWorkers() = 1
[17:38:24.766] SequentialFuture started (and completed)
[17:38:24.766] - Launch lazy future ... done
[17:38:24.766] run() for ‘SequentialFuture’ ... done
[17:38:24.766] Created future:
[17:38:24.766] SequentialFuture:
[17:38:24.766] Label: ‘future_lapply-1’
[17:38:24.766] Expression:
[17:38:24.766] {
[17:38:24.766]     do.call(function(...) {
[17:38:24.766]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:24.766]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:24.766]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:24.766]             on.exit(options(oopts), add = TRUE)
[17:38:24.766]         }
[17:38:24.766]         {
[17:38:24.766]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:24.766]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:24.766]                 ...future.FUN(...future.X_jj, ...)
[17:38:24.766]             })
[17:38:24.766]         }
[17:38:24.766]     }, args = future.call.arguments)
[17:38:24.766] }
[17:38:24.766] Lazy evaluation: FALSE
[17:38:24.766] Asynchronous evaluation: FALSE
[17:38:24.766] Local evaluation: TRUE
[17:38:24.766] Environment: R_GlobalEnv
[17:38:24.766] Capture standard output: FALSE
[17:38:24.766] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:24.766] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:24.766] Packages: <none>
[17:38:24.766] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:24.766] Resolved: TRUE
[17:38:24.766] Value: 112 bytes of class ‘list’
[17:38:24.766] Early signaling: FALSE
[17:38:24.766] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:24.766] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:24.768] Chunk #1 of 1 ... DONE
[17:38:24.768] Launching 1 futures (chunks) ... DONE
[17:38:24.768] Resolving 1 futures (chunks) ...
[17:38:24.768] resolve() on list ...
[17:38:24.768]  recursive: 0
[17:38:24.768]  length: 1
[17:38:24.768] 
[17:38:24.768] resolved() for ‘SequentialFuture’ ...
[17:38:24.768] - state: ‘finished’
[17:38:24.768] - run: TRUE
[17:38:24.769] - result: ‘FutureResult’
[17:38:24.769] resolved() for ‘SequentialFuture’ ... done
[17:38:24.769] Future #1
[17:38:24.769] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:24.769] - nx: 1
[17:38:24.769] - relay: TRUE
[17:38:24.769] - stdout: TRUE
[17:38:24.769] - signal: TRUE
[17:38:24.769] - resignal: FALSE
[17:38:24.769] - force: TRUE
[17:38:24.769] - relayed: [n=1] FALSE
[17:38:24.770] - queued futures: [n=1] FALSE
[17:38:24.770]  - until=1
[17:38:24.770]  - relaying element #1
[17:38:24.770] - relayed: [n=1] TRUE
[17:38:24.770] - queued futures: [n=1] TRUE
[17:38:24.770] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:24.770]  length: 0 (resolved future 1)
[17:38:24.770] Relaying remaining futures
[17:38:24.770] signalConditionsASAP(NULL, pos=0) ...
[17:38:24.770] - nx: 1
[17:38:24.771] - relay: TRUE
[17:38:24.771] - stdout: TRUE
[17:38:24.771] - signal: TRUE
[17:38:24.771] - resignal: FALSE
[17:38:24.771] - force: TRUE
[17:38:24.771] - relayed: [n=1] TRUE
[17:38:24.771] - queued futures: [n=1] TRUE
 - flush all
[17:38:24.771] - relayed: [n=1] TRUE
[17:38:24.771] - queued futures: [n=1] TRUE
[17:38:24.771] signalConditionsASAP(NULL, pos=0) ... done
[17:38:24.771] resolve() on list ... DONE
[17:38:24.772]  - Number of value chunks collected: 1
[17:38:24.772] Resolving 1 futures (chunks) ... DONE
[17:38:24.772] Reducing values from 1 chunks ...
[17:38:24.772]  - Number of values collected after concatenation: 2
[17:38:24.772]  - Number of values expected: 2
[17:38:24.772] Reducing values from 1 chunks ... DONE
[17:38:24.772] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[17:38:24.772] future_lapply() ...
[17:38:24.776] Number of chunks: 1
[17:38:24.776] getGlobalsAndPackagesXApply() ...
[17:38:24.776]  - future.globals: TRUE
[17:38:24.777] getGlobalsAndPackages() ...
[17:38:24.777] Searching for globals...
[17:38:24.778] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:38:24.778] Searching for globals ... DONE
[17:38:24.778] Resolving globals: FALSE
[17:38:24.779] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:38:24.779] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:38:24.779] - globals: [1] ‘FUN’
[17:38:24.779] 
[17:38:24.779] getGlobalsAndPackages() ... DONE
[17:38:24.779]  - globals found/used: [n=1] ‘FUN’
[17:38:24.780]  - needed namespaces: [n=0] 
[17:38:24.780] Finding globals ... DONE
[17:38:24.780]  - use_args: TRUE
[17:38:24.780]  - Getting '...' globals ...
[17:38:24.780] resolve() on list ...
[17:38:24.780]  recursive: 0
[17:38:24.780]  length: 1
[17:38:24.780]  elements: ‘...’
[17:38:24.781]  length: 0 (resolved future 1)
[17:38:24.781] resolve() on list ... DONE
[17:38:24.781]    - '...' content: [n=0] 
[17:38:24.781] List of 1
[17:38:24.781]  $ ...: list()
[17:38:24.781]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:24.781]  - attr(*, "where")=List of 1
[17:38:24.781]   ..$ ...:<environment: 0x5628ab330fc8> 
[17:38:24.781]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:24.781]  - attr(*, "resolved")= logi TRUE
[17:38:24.781]  - attr(*, "total_size")= num NA
[17:38:24.783]  - Getting '...' globals ... DONE
[17:38:24.783] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:38:24.784] List of 2
[17:38:24.784]  $ ...future.FUN:function (x)  
[17:38:24.784]  $ ...          : list()
[17:38:24.784]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:24.784]  - attr(*, "where")=List of 2
[17:38:24.784]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:24.784]   ..$ ...          :<environment: 0x5628ab330fc8> 
[17:38:24.784]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:24.784]  - attr(*, "resolved")= logi FALSE
[17:38:24.784]  - attr(*, "total_size")= num 4720
[17:38:24.788] Packages to be attached in all futures: [n=0] 
[17:38:24.788] getGlobalsAndPackagesXApply() ... DONE
[17:38:24.788] Number of futures (= number of chunks): 1
[17:38:24.788] Launching 1 futures (chunks) ...
[17:38:24.788] Chunk #1 of 1 ...
[17:38:24.788]  - Finding globals in 'X' for chunk #1 ...
[17:38:24.789] getGlobalsAndPackages() ...
[17:38:24.789] Searching for globals...
[17:38:24.789] 
[17:38:24.789] Searching for globals ... DONE
[17:38:24.789] - globals: [0] <none>
[17:38:24.789] getGlobalsAndPackages() ... DONE
[17:38:24.789]    + additional globals found: [n=0] 
[17:38:24.789]    + additional namespaces needed: [n=0] 
[17:38:24.789]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:24.790]  - seeds: <none>
[17:38:24.790]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:24.790] getGlobalsAndPackages() ...
[17:38:24.790] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:24.790] Resolving globals: FALSE
[17:38:24.790] Tweak future expression to call with '...' arguments ...
[17:38:24.790] {
[17:38:24.790]     do.call(function(...) {
[17:38:24.790]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:24.790]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:24.790]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:24.790]             on.exit(options(oopts), add = TRUE)
[17:38:24.790]         }
[17:38:24.790]         {
[17:38:24.790]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:24.790]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:24.790]                 ...future.FUN(...future.X_jj, ...)
[17:38:24.790]             })
[17:38:24.790]         }
[17:38:24.790]     }, args = future.call.arguments)
[17:38:24.790] }
[17:38:24.790] Tweak future expression to call with '...' arguments ... DONE
[17:38:24.791] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:24.791] 
[17:38:24.791] getGlobalsAndPackages() ... DONE
[17:38:24.791] run() for ‘Future’ ...
[17:38:24.791] - state: ‘created’
[17:38:24.791] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:24.795] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:24.795] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:24.795]   - Field: ‘label’
[17:38:24.795]   - Field: ‘local’
[17:38:24.795]   - Field: ‘owner’
[17:38:24.796]   - Field: ‘envir’
[17:38:24.796]   - Field: ‘packages’
[17:38:24.796]   - Field: ‘gc’
[17:38:24.796]   - Field: ‘conditions’
[17:38:24.796]   - Field: ‘expr’
[17:38:24.796]   - Field: ‘uuid’
[17:38:24.796]   - Field: ‘seed’
[17:38:24.796]   - Field: ‘version’
[17:38:24.796]   - Field: ‘result’
[17:38:24.796]   - Field: ‘asynchronous’
[17:38:24.797]   - Field: ‘calls’
[17:38:24.797]   - Field: ‘globals’
[17:38:24.797]   - Field: ‘stdout’
[17:38:24.797]   - Field: ‘earlySignal’
[17:38:24.797]   - Field: ‘lazy’
[17:38:24.797]   - Field: ‘state’
[17:38:24.797] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:24.797] - Launch lazy future ...
[17:38:24.797] Packages needed by the future expression (n = 0): <none>
[17:38:24.797] Packages needed by future strategies (n = 0): <none>
[17:38:24.798] {
[17:38:24.798]     {
[17:38:24.798]         {
[17:38:24.798]             ...future.startTime <- base::Sys.time()
[17:38:24.798]             {
[17:38:24.798]                 {
[17:38:24.798]                   {
[17:38:24.798]                     base::local({
[17:38:24.798]                       has_future <- base::requireNamespace("future", 
[17:38:24.798]                         quietly = TRUE)
[17:38:24.798]                       if (has_future) {
[17:38:24.798]                         ns <- base::getNamespace("future")
[17:38:24.798]                         version <- ns[[".package"]][["version"]]
[17:38:24.798]                         if (is.null(version)) 
[17:38:24.798]                           version <- utils::packageVersion("future")
[17:38:24.798]                       }
[17:38:24.798]                       else {
[17:38:24.798]                         version <- NULL
[17:38:24.798]                       }
[17:38:24.798]                       if (!has_future || version < "1.8.0") {
[17:38:24.798]                         info <- base::c(r_version = base::gsub("R version ", 
[17:38:24.798]                           "", base::R.version$version.string), 
[17:38:24.798]                           platform = base::sprintf("%s (%s-bit)", 
[17:38:24.798]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:24.798]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:24.798]                             "release", "version")], collapse = " "), 
[17:38:24.798]                           hostname = base::Sys.info()[["nodename"]])
[17:38:24.798]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:38:24.798]                           info)
[17:38:24.798]                         info <- base::paste(info, collapse = "; ")
[17:38:24.798]                         if (!has_future) {
[17:38:24.798]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:24.798]                             info)
[17:38:24.798]                         }
[17:38:24.798]                         else {
[17:38:24.798]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:24.798]                             info, version)
[17:38:24.798]                         }
[17:38:24.798]                         base::stop(msg)
[17:38:24.798]                       }
[17:38:24.798]                     })
[17:38:24.798]                   }
[17:38:24.798]                   ...future.strategy.old <- future::plan("list")
[17:38:24.798]                   options(future.plan = NULL)
[17:38:24.798]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:24.798]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:24.798]                 }
[17:38:24.798]                 ...future.workdir <- getwd()
[17:38:24.798]             }
[17:38:24.798]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:24.798]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:24.798]         }
[17:38:24.798]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:24.798]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:24.798]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:24.798]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:24.798]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:24.798]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:24.798]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:24.798]             base::names(...future.oldOptions))
[17:38:24.798]     }
[17:38:24.798]     if (FALSE) {
[17:38:24.798]     }
[17:38:24.798]     else {
[17:38:24.798]         if (TRUE) {
[17:38:24.798]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:24.798]                 open = "w")
[17:38:24.798]         }
[17:38:24.798]         else {
[17:38:24.798]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:24.798]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:24.798]         }
[17:38:24.798]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:24.798]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:24.798]             base::sink(type = "output", split = FALSE)
[17:38:24.798]             base::close(...future.stdout)
[17:38:24.798]         }, add = TRUE)
[17:38:24.798]     }
[17:38:24.798]     ...future.frame <- base::sys.nframe()
[17:38:24.798]     ...future.conditions <- base::list()
[17:38:24.798]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:24.798]     if (FALSE) {
[17:38:24.798]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:24.798]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:24.798]     }
[17:38:24.798]     ...future.result <- base::tryCatch({
[17:38:24.798]         base::withCallingHandlers({
[17:38:24.798]             ...future.value <- base::withVisible(base::local({
[17:38:24.798]                 do.call(function(...) {
[17:38:24.798]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:24.798]                   if (!identical(...future.globals.maxSize.org, 
[17:38:24.798]                     ...future.globals.maxSize)) {
[17:38:24.798]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:24.798]                     on.exit(options(oopts), add = TRUE)
[17:38:24.798]                   }
[17:38:24.798]                   {
[17:38:24.798]                     lapply(seq_along(...future.elements_ii), 
[17:38:24.798]                       FUN = function(jj) {
[17:38:24.798]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:24.798]                         ...future.FUN(...future.X_jj, ...)
[17:38:24.798]                       })
[17:38:24.798]                   }
[17:38:24.798]                 }, args = future.call.arguments)
[17:38:24.798]             }))
[17:38:24.798]             future::FutureResult(value = ...future.value$value, 
[17:38:24.798]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:24.798]                   ...future.rng), globalenv = if (FALSE) 
[17:38:24.798]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:24.798]                     ...future.globalenv.names))
[17:38:24.798]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:24.798]         }, condition = base::local({
[17:38:24.798]             c <- base::c
[17:38:24.798]             inherits <- base::inherits
[17:38:24.798]             invokeRestart <- base::invokeRestart
[17:38:24.798]             length <- base::length
[17:38:24.798]             list <- base::list
[17:38:24.798]             seq.int <- base::seq.int
[17:38:24.798]             signalCondition <- base::signalCondition
[17:38:24.798]             sys.calls <- base::sys.calls
[17:38:24.798]             `[[` <- base::`[[`
[17:38:24.798]             `+` <- base::`+`
[17:38:24.798]             `<<-` <- base::`<<-`
[17:38:24.798]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:24.798]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:24.798]                   3L)]
[17:38:24.798]             }
[17:38:24.798]             function(cond) {
[17:38:24.798]                 is_error <- inherits(cond, "error")
[17:38:24.798]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:24.798]                   NULL)
[17:38:24.798]                 if (is_error) {
[17:38:24.798]                   sessionInformation <- function() {
[17:38:24.798]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:24.798]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:24.798]                       search = base::search(), system = base::Sys.info())
[17:38:24.798]                   }
[17:38:24.798]                   ...future.conditions[[length(...future.conditions) + 
[17:38:24.798]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:24.798]                     cond$call), session = sessionInformation(), 
[17:38:24.798]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:24.798]                   signalCondition(cond)
[17:38:24.798]                 }
[17:38:24.798]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:24.798]                 "immediateCondition"))) {
[17:38:24.798]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:24.798]                   ...future.conditions[[length(...future.conditions) + 
[17:38:24.798]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:24.798]                   if (TRUE && !signal) {
[17:38:24.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:24.798]                     {
[17:38:24.798]                       inherits <- base::inherits
[17:38:24.798]                       invokeRestart <- base::invokeRestart
[17:38:24.798]                       is.null <- base::is.null
[17:38:24.798]                       muffled <- FALSE
[17:38:24.798]                       if (inherits(cond, "message")) {
[17:38:24.798]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:24.798]                         if (muffled) 
[17:38:24.798]                           invokeRestart("muffleMessage")
[17:38:24.798]                       }
[17:38:24.798]                       else if (inherits(cond, "warning")) {
[17:38:24.798]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:24.798]                         if (muffled) 
[17:38:24.798]                           invokeRestart("muffleWarning")
[17:38:24.798]                       }
[17:38:24.798]                       else if (inherits(cond, "condition")) {
[17:38:24.798]                         if (!is.null(pattern)) {
[17:38:24.798]                           computeRestarts <- base::computeRestarts
[17:38:24.798]                           grepl <- base::grepl
[17:38:24.798]                           restarts <- computeRestarts(cond)
[17:38:24.798]                           for (restart in restarts) {
[17:38:24.798]                             name <- restart$name
[17:38:24.798]                             if (is.null(name)) 
[17:38:24.798]                               next
[17:38:24.798]                             if (!grepl(pattern, name)) 
[17:38:24.798]                               next
[17:38:24.798]                             invokeRestart(restart)
[17:38:24.798]                             muffled <- TRUE
[17:38:24.798]                             break
[17:38:24.798]                           }
[17:38:24.798]                         }
[17:38:24.798]                       }
[17:38:24.798]                       invisible(muffled)
[17:38:24.798]                     }
[17:38:24.798]                     muffleCondition(cond, pattern = "^muffle")
[17:38:24.798]                   }
[17:38:24.798]                 }
[17:38:24.798]                 else {
[17:38:24.798]                   if (TRUE) {
[17:38:24.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:24.798]                     {
[17:38:24.798]                       inherits <- base::inherits
[17:38:24.798]                       invokeRestart <- base::invokeRestart
[17:38:24.798]                       is.null <- base::is.null
[17:38:24.798]                       muffled <- FALSE
[17:38:24.798]                       if (inherits(cond, "message")) {
[17:38:24.798]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:24.798]                         if (muffled) 
[17:38:24.798]                           invokeRestart("muffleMessage")
[17:38:24.798]                       }
[17:38:24.798]                       else if (inherits(cond, "warning")) {
[17:38:24.798]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:24.798]                         if (muffled) 
[17:38:24.798]                           invokeRestart("muffleWarning")
[17:38:24.798]                       }
[17:38:24.798]                       else if (inherits(cond, "condition")) {
[17:38:24.798]                         if (!is.null(pattern)) {
[17:38:24.798]                           computeRestarts <- base::computeRestarts
[17:38:24.798]                           grepl <- base::grepl
[17:38:24.798]                           restarts <- computeRestarts(cond)
[17:38:24.798]                           for (restart in restarts) {
[17:38:24.798]                             name <- restart$name
[17:38:24.798]                             if (is.null(name)) 
[17:38:24.798]                               next
[17:38:24.798]                             if (!grepl(pattern, name)) 
[17:38:24.798]                               next
[17:38:24.798]                             invokeRestart(restart)
[17:38:24.798]                             muffled <- TRUE
[17:38:24.798]                             break
[17:38:24.798]                           }
[17:38:24.798]                         }
[17:38:24.798]                       }
[17:38:24.798]                       invisible(muffled)
[17:38:24.798]                     }
[17:38:24.798]                     muffleCondition(cond, pattern = "^muffle")
[17:38:24.798]                   }
[17:38:24.798]                 }
[17:38:24.798]             }
[17:38:24.798]         }))
[17:38:24.798]     }, error = function(ex) {
[17:38:24.798]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:24.798]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:24.798]                 ...future.rng), started = ...future.startTime, 
[17:38:24.798]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:24.798]             version = "1.8"), class = "FutureResult")
[17:38:24.798]     }, finally = {
[17:38:24.798]         if (!identical(...future.workdir, getwd())) 
[17:38:24.798]             setwd(...future.workdir)
[17:38:24.798]         {
[17:38:24.798]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:24.798]                 ...future.oldOptions$nwarnings <- NULL
[17:38:24.798]             }
[17:38:24.798]             base::options(...future.oldOptions)
[17:38:24.798]             if (.Platform$OS.type == "windows") {
[17:38:24.798]                 old_names <- names(...future.oldEnvVars)
[17:38:24.798]                 envs <- base::Sys.getenv()
[17:38:24.798]                 names <- names(envs)
[17:38:24.798]                 common <- intersect(names, old_names)
[17:38:24.798]                 added <- setdiff(names, old_names)
[17:38:24.798]                 removed <- setdiff(old_names, names)
[17:38:24.798]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:24.798]                   envs[common]]
[17:38:24.798]                 NAMES <- toupper(changed)
[17:38:24.798]                 args <- list()
[17:38:24.798]                 for (kk in seq_along(NAMES)) {
[17:38:24.798]                   name <- changed[[kk]]
[17:38:24.798]                   NAME <- NAMES[[kk]]
[17:38:24.798]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:24.798]                     next
[17:38:24.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:24.798]                 }
[17:38:24.798]                 NAMES <- toupper(added)
[17:38:24.798]                 for (kk in seq_along(NAMES)) {
[17:38:24.798]                   name <- added[[kk]]
[17:38:24.798]                   NAME <- NAMES[[kk]]
[17:38:24.798]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:24.798]                     next
[17:38:24.798]                   args[[name]] <- ""
[17:38:24.798]                 }
[17:38:24.798]                 NAMES <- toupper(removed)
[17:38:24.798]                 for (kk in seq_along(NAMES)) {
[17:38:24.798]                   name <- removed[[kk]]
[17:38:24.798]                   NAME <- NAMES[[kk]]
[17:38:24.798]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:24.798]                     next
[17:38:24.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:24.798]                 }
[17:38:24.798]                 if (length(args) > 0) 
[17:38:24.798]                   base::do.call(base::Sys.setenv, args = args)
[17:38:24.798]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:24.798]             }
[17:38:24.798]             else {
[17:38:24.798]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:24.798]             }
[17:38:24.798]             {
[17:38:24.798]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:24.798]                   0L) {
[17:38:24.798]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:24.798]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:24.798]                   base::options(opts)
[17:38:24.798]                 }
[17:38:24.798]                 {
[17:38:24.798]                   {
[17:38:24.798]                     NULL
[17:38:24.798]                     RNGkind("Mersenne-Twister")
[17:38:24.798]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:24.798]                       inherits = FALSE)
[17:38:24.798]                   }
[17:38:24.798]                   options(future.plan = NULL)
[17:38:24.798]                   if (is.na(NA_character_)) 
[17:38:24.798]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:24.798]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:24.798]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:24.798]                     .init = FALSE)
[17:38:24.798]                 }
[17:38:24.798]             }
[17:38:24.798]         }
[17:38:24.798]     })
[17:38:24.798]     if (TRUE) {
[17:38:24.798]         base::sink(type = "output", split = FALSE)
[17:38:24.798]         if (TRUE) {
[17:38:24.798]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:24.798]         }
[17:38:24.798]         else {
[17:38:24.798]             ...future.result["stdout"] <- base::list(NULL)
[17:38:24.798]         }
[17:38:24.798]         base::close(...future.stdout)
[17:38:24.798]         ...future.stdout <- NULL
[17:38:24.798]     }
[17:38:24.798]     ...future.result$conditions <- ...future.conditions
[17:38:24.798]     ...future.result$finished <- base::Sys.time()
[17:38:24.798]     ...future.result
[17:38:24.798] }
[17:38:24.800] assign_globals() ...
[17:38:24.800] List of 5
[17:38:24.800]  $ ...future.FUN            :function (x)  
[17:38:24.800]  $ future.call.arguments    : list()
[17:38:24.800]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:24.800]  $ ...future.elements_ii    :List of 2
[17:38:24.800]   ..$ : int 1
[17:38:24.800]   ..$ : int 0
[17:38:24.800]  $ ...future.seeds_ii       : NULL
[17:38:24.800]  $ ...future.globals.maxSize: NULL
[17:38:24.800]  - attr(*, "where")=List of 5
[17:38:24.800]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:24.800]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:24.800]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:24.800]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:24.800]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:24.800]  - attr(*, "resolved")= logi FALSE
[17:38:24.800]  - attr(*, "total_size")= num 4720
[17:38:24.800]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:24.800]  - attr(*, "already-done")= logi TRUE
[17:38:24.804] - reassign environment for ‘...future.FUN’
[17:38:24.804] - copied ‘...future.FUN’ to environment
[17:38:24.805] - copied ‘future.call.arguments’ to environment
[17:38:24.805] - copied ‘...future.elements_ii’ to environment
[17:38:24.805] - copied ‘...future.seeds_ii’ to environment
[17:38:24.805] - copied ‘...future.globals.maxSize’ to environment
[17:38:24.805] assign_globals() ... done
[17:38:24.805] plan(): Setting new future strategy stack:
[17:38:24.805] List of future strategies:
[17:38:24.805] 1. sequential:
[17:38:24.805]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:24.805]    - tweaked: FALSE
[17:38:24.805]    - call: NULL
[17:38:24.806] plan(): nbrOfWorkers() = 1
[17:38:25.307] plan(): Setting new future strategy stack:
[17:38:25.308] List of future strategies:
[17:38:25.308] 1. multicore:
[17:38:25.308]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:25.308]    - tweaked: FALSE
[17:38:25.308]    - call: plan(strategy)
[17:38:25.312] plan(): nbrOfWorkers() = 1
[17:38:25.312] SequentialFuture started (and completed)
[17:38:25.312] - Launch lazy future ... done
[17:38:25.312] run() for ‘SequentialFuture’ ... done
[17:38:25.312] Created future:
[17:38:25.312] SequentialFuture:
[17:38:25.312] Label: ‘future_lapply-1’
[17:38:25.312] Expression:
[17:38:25.312] {
[17:38:25.312]     do.call(function(...) {
[17:38:25.312]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:25.312]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:25.312]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:25.312]             on.exit(options(oopts), add = TRUE)
[17:38:25.312]         }
[17:38:25.312]         {
[17:38:25.312]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:25.312]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:25.312]                 ...future.FUN(...future.X_jj, ...)
[17:38:25.312]             })
[17:38:25.312]         }
[17:38:25.312]     }, args = future.call.arguments)
[17:38:25.312] }
[17:38:25.312] Lazy evaluation: FALSE
[17:38:25.312] Asynchronous evaluation: FALSE
[17:38:25.312] Local evaluation: TRUE
[17:38:25.312] Environment: R_GlobalEnv
[17:38:25.312] Capture standard output: TRUE
[17:38:25.312] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:25.312] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:25.312] Packages: <none>
[17:38:25.312] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:25.312] Resolved: TRUE
[17:38:25.312] Value: 112 bytes of class ‘list’
[17:38:25.312] Early signaling: FALSE
[17:38:25.312] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:25.312] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:25.313] Chunk #1 of 1 ... DONE
[17:38:25.313] Launching 1 futures (chunks) ... DONE
[17:38:25.314] Resolving 1 futures (chunks) ...
[17:38:25.314] resolve() on list ...
[17:38:25.314]  recursive: 0
[17:38:25.314]  length: 1
[17:38:25.314] 
[17:38:25.314] resolved() for ‘SequentialFuture’ ...
[17:38:25.314] - state: ‘finished’
[17:38:25.314] - run: TRUE
[17:38:25.314] - result: ‘FutureResult’
[17:38:25.314] resolved() for ‘SequentialFuture’ ... done
[17:38:25.314] Future #1
[17:38:25.315] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:25.315] - nx: 1
[17:38:25.315] - relay: TRUE
[17:38:25.315] - stdout: TRUE
[17:38:25.315] - signal: TRUE
[17:38:25.315] - resignal: FALSE
[17:38:25.315] - force: TRUE
[17:38:25.315] - relayed: [n=1] FALSE
[17:38:25.315] - queued futures: [n=1] FALSE
[17:38:25.315]  - until=1
[17:38:25.315]  - relaying element #1
[17:38:25.316] - relayed: [n=1] TRUE
[17:38:25.316] - queued futures: [n=1] TRUE
[17:38:25.316] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:25.316]  length: 0 (resolved future 1)
[17:38:25.316] Relaying remaining futures
[17:38:25.316] signalConditionsASAP(NULL, pos=0) ...
[17:38:25.316] - nx: 1
[17:38:25.316] - relay: TRUE
[17:38:25.316] - stdout: TRUE
[17:38:25.317] - signal: TRUE
[17:38:25.317] - resignal: FALSE
[17:38:25.317] - force: TRUE
[17:38:25.317] - relayed: [n=1] TRUE
[17:38:25.317] - queued futures: [n=1] TRUE
 - flush all
[17:38:25.317] - relayed: [n=1] TRUE
[17:38:25.317] - queued futures: [n=1] TRUE
[17:38:25.317] signalConditionsASAP(NULL, pos=0) ... done
[17:38:25.317] resolve() on list ... DONE
[17:38:25.317]  - Number of value chunks collected: 1
[17:38:25.317] Resolving 1 futures (chunks) ... DONE
[17:38:25.318] Reducing values from 1 chunks ...
[17:38:25.318]  - Number of values collected after concatenation: 2
[17:38:25.318]  - Number of values expected: 2
[17:38:25.318] Reducing values from 1 chunks ... DONE
[17:38:25.318] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[17:38:25.318] future_lapply() ...
[17:38:25.324] Number of chunks: 1
[17:38:25.324] getGlobalsAndPackagesXApply() ...
[17:38:25.324]  - future.globals: TRUE
[17:38:25.324] getGlobalsAndPackages() ...
[17:38:25.324] Searching for globals...
[17:38:25.325] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:38:25.326] Searching for globals ... DONE
[17:38:25.326] Resolving globals: FALSE
[17:38:25.326] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:38:25.326] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:38:25.327] - globals: [1] ‘FUN’
[17:38:25.327] 
[17:38:25.327] getGlobalsAndPackages() ... DONE
[17:38:25.327]  - globals found/used: [n=1] ‘FUN’
[17:38:25.327]  - needed namespaces: [n=0] 
[17:38:25.327] Finding globals ... DONE
[17:38:25.327]  - use_args: TRUE
[17:38:25.327]  - Getting '...' globals ...
[17:38:25.327] resolve() on list ...
[17:38:25.328]  recursive: 0
[17:38:25.328]  length: 1
[17:38:25.328]  elements: ‘...’
[17:38:25.328]  length: 0 (resolved future 1)
[17:38:25.328] resolve() on list ... DONE
[17:38:25.328]    - '...' content: [n=0] 
[17:38:25.328] List of 1
[17:38:25.328]  $ ...: list()
[17:38:25.328]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:25.328]  - attr(*, "where")=List of 1
[17:38:25.328]   ..$ ...:<environment: 0x5628ac3124c8> 
[17:38:25.328]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:25.328]  - attr(*, "resolved")= logi TRUE
[17:38:25.328]  - attr(*, "total_size")= num NA
[17:38:25.331]  - Getting '...' globals ... DONE
[17:38:25.331] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:38:25.331] List of 2
[17:38:25.331]  $ ...future.FUN:function (x)  
[17:38:25.331]  $ ...          : list()
[17:38:25.331]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:25.331]  - attr(*, "where")=List of 2
[17:38:25.331]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:25.331]   ..$ ...          :<environment: 0x5628ac3124c8> 
[17:38:25.331]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:25.331]  - attr(*, "resolved")= logi FALSE
[17:38:25.331]  - attr(*, "total_size")= num 4720
[17:38:25.333] Packages to be attached in all futures: [n=0] 
[17:38:25.334] getGlobalsAndPackagesXApply() ... DONE
[17:38:25.334] Number of futures (= number of chunks): 1
[17:38:25.334] Launching 1 futures (chunks) ...
[17:38:25.334] Chunk #1 of 1 ...
[17:38:25.334]  - Finding globals in 'X' for chunk #1 ...
[17:38:25.334] getGlobalsAndPackages() ...
[17:38:25.334] Searching for globals...
[17:38:25.335] 
[17:38:25.335] Searching for globals ... DONE
[17:38:25.335] - globals: [0] <none>
[17:38:25.335] getGlobalsAndPackages() ... DONE
[17:38:25.335]    + additional globals found: [n=0] 
[17:38:25.335]    + additional namespaces needed: [n=0] 
[17:38:25.335]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:25.335]  - seeds: <none>
[17:38:25.335]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:25.335] getGlobalsAndPackages() ...
[17:38:25.335] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:25.336] Resolving globals: FALSE
[17:38:25.336] Tweak future expression to call with '...' arguments ...
[17:38:25.336] {
[17:38:25.336]     do.call(function(...) {
[17:38:25.336]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:25.336]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:25.336]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:25.336]             on.exit(options(oopts), add = TRUE)
[17:38:25.336]         }
[17:38:25.336]         {
[17:38:25.336]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:25.336]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:25.336]                 ...future.FUN(...future.X_jj, ...)
[17:38:25.336]             })
[17:38:25.336]         }
[17:38:25.336]     }, args = future.call.arguments)
[17:38:25.336] }
[17:38:25.336] Tweak future expression to call with '...' arguments ... DONE
[17:38:25.336] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:25.336] 
[17:38:25.337] getGlobalsAndPackages() ... DONE
[17:38:25.337] run() for ‘Future’ ...
[17:38:25.337] - state: ‘created’
[17:38:25.337] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:25.341] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:25.341] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:25.341]   - Field: ‘label’
[17:38:25.341]   - Field: ‘local’
[17:38:25.341]   - Field: ‘owner’
[17:38:25.341]   - Field: ‘envir’
[17:38:25.341]   - Field: ‘packages’
[17:38:25.341]   - Field: ‘gc’
[17:38:25.341]   - Field: ‘conditions’
[17:38:25.342]   - Field: ‘expr’
[17:38:25.342]   - Field: ‘uuid’
[17:38:25.342]   - Field: ‘seed’
[17:38:25.342]   - Field: ‘version’
[17:38:25.342]   - Field: ‘result’
[17:38:25.342]   - Field: ‘asynchronous’
[17:38:25.342]   - Field: ‘calls’
[17:38:25.342]   - Field: ‘globals’
[17:38:25.342]   - Field: ‘stdout’
[17:38:25.342]   - Field: ‘earlySignal’
[17:38:25.342]   - Field: ‘lazy’
[17:38:25.342]   - Field: ‘state’
[17:38:25.343] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:25.343] - Launch lazy future ...
[17:38:25.343] Packages needed by the future expression (n = 0): <none>
[17:38:25.343] Packages needed by future strategies (n = 0): <none>
[17:38:25.343] {
[17:38:25.343]     {
[17:38:25.343]         {
[17:38:25.343]             ...future.startTime <- base::Sys.time()
[17:38:25.343]             {
[17:38:25.343]                 {
[17:38:25.343]                   {
[17:38:25.343]                     base::local({
[17:38:25.343]                       has_future <- base::requireNamespace("future", 
[17:38:25.343]                         quietly = TRUE)
[17:38:25.343]                       if (has_future) {
[17:38:25.343]                         ns <- base::getNamespace("future")
[17:38:25.343]                         version <- ns[[".package"]][["version"]]
[17:38:25.343]                         if (is.null(version)) 
[17:38:25.343]                           version <- utils::packageVersion("future")
[17:38:25.343]                       }
[17:38:25.343]                       else {
[17:38:25.343]                         version <- NULL
[17:38:25.343]                       }
[17:38:25.343]                       if (!has_future || version < "1.8.0") {
[17:38:25.343]                         info <- base::c(r_version = base::gsub("R version ", 
[17:38:25.343]                           "", base::R.version$version.string), 
[17:38:25.343]                           platform = base::sprintf("%s (%s-bit)", 
[17:38:25.343]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:25.343]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:25.343]                             "release", "version")], collapse = " "), 
[17:38:25.343]                           hostname = base::Sys.info()[["nodename"]])
[17:38:25.343]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:38:25.343]                           info)
[17:38:25.343]                         info <- base::paste(info, collapse = "; ")
[17:38:25.343]                         if (!has_future) {
[17:38:25.343]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:25.343]                             info)
[17:38:25.343]                         }
[17:38:25.343]                         else {
[17:38:25.343]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:25.343]                             info, version)
[17:38:25.343]                         }
[17:38:25.343]                         base::stop(msg)
[17:38:25.343]                       }
[17:38:25.343]                     })
[17:38:25.343]                   }
[17:38:25.343]                   ...future.strategy.old <- future::plan("list")
[17:38:25.343]                   options(future.plan = NULL)
[17:38:25.343]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:25.343]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:25.343]                 }
[17:38:25.343]                 ...future.workdir <- getwd()
[17:38:25.343]             }
[17:38:25.343]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:25.343]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:25.343]         }
[17:38:25.343]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:25.343]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:25.343]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:25.343]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:25.343]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:25.343]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:25.343]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:25.343]             base::names(...future.oldOptions))
[17:38:25.343]     }
[17:38:25.343]     if (TRUE) {
[17:38:25.343]     }
[17:38:25.343]     else {
[17:38:25.343]         if (NA) {
[17:38:25.343]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:25.343]                 open = "w")
[17:38:25.343]         }
[17:38:25.343]         else {
[17:38:25.343]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:25.343]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:25.343]         }
[17:38:25.343]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:25.343]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:25.343]             base::sink(type = "output", split = FALSE)
[17:38:25.343]             base::close(...future.stdout)
[17:38:25.343]         }, add = TRUE)
[17:38:25.343]     }
[17:38:25.343]     ...future.frame <- base::sys.nframe()
[17:38:25.343]     ...future.conditions <- base::list()
[17:38:25.343]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:25.343]     if (FALSE) {
[17:38:25.343]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:25.343]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:25.343]     }
[17:38:25.343]     ...future.result <- base::tryCatch({
[17:38:25.343]         base::withCallingHandlers({
[17:38:25.343]             ...future.value <- base::withVisible(base::local({
[17:38:25.343]                 do.call(function(...) {
[17:38:25.343]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:25.343]                   if (!identical(...future.globals.maxSize.org, 
[17:38:25.343]                     ...future.globals.maxSize)) {
[17:38:25.343]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:25.343]                     on.exit(options(oopts), add = TRUE)
[17:38:25.343]                   }
[17:38:25.343]                   {
[17:38:25.343]                     lapply(seq_along(...future.elements_ii), 
[17:38:25.343]                       FUN = function(jj) {
[17:38:25.343]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:25.343]                         ...future.FUN(...future.X_jj, ...)
[17:38:25.343]                       })
[17:38:25.343]                   }
[17:38:25.343]                 }, args = future.call.arguments)
[17:38:25.343]             }))
[17:38:25.343]             future::FutureResult(value = ...future.value$value, 
[17:38:25.343]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:25.343]                   ...future.rng), globalenv = if (FALSE) 
[17:38:25.343]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:25.343]                     ...future.globalenv.names))
[17:38:25.343]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:25.343]         }, condition = base::local({
[17:38:25.343]             c <- base::c
[17:38:25.343]             inherits <- base::inherits
[17:38:25.343]             invokeRestart <- base::invokeRestart
[17:38:25.343]             length <- base::length
[17:38:25.343]             list <- base::list
[17:38:25.343]             seq.int <- base::seq.int
[17:38:25.343]             signalCondition <- base::signalCondition
[17:38:25.343]             sys.calls <- base::sys.calls
[17:38:25.343]             `[[` <- base::`[[`
[17:38:25.343]             `+` <- base::`+`
[17:38:25.343]             `<<-` <- base::`<<-`
[17:38:25.343]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:25.343]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:25.343]                   3L)]
[17:38:25.343]             }
[17:38:25.343]             function(cond) {
[17:38:25.343]                 is_error <- inherits(cond, "error")
[17:38:25.343]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:25.343]                   NULL)
[17:38:25.343]                 if (is_error) {
[17:38:25.343]                   sessionInformation <- function() {
[17:38:25.343]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:25.343]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:25.343]                       search = base::search(), system = base::Sys.info())
[17:38:25.343]                   }
[17:38:25.343]                   ...future.conditions[[length(...future.conditions) + 
[17:38:25.343]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:25.343]                     cond$call), session = sessionInformation(), 
[17:38:25.343]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:25.343]                   signalCondition(cond)
[17:38:25.343]                 }
[17:38:25.343]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:25.343]                 "immediateCondition"))) {
[17:38:25.343]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:25.343]                   ...future.conditions[[length(...future.conditions) + 
[17:38:25.343]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:25.343]                   if (TRUE && !signal) {
[17:38:25.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:25.343]                     {
[17:38:25.343]                       inherits <- base::inherits
[17:38:25.343]                       invokeRestart <- base::invokeRestart
[17:38:25.343]                       is.null <- base::is.null
[17:38:25.343]                       muffled <- FALSE
[17:38:25.343]                       if (inherits(cond, "message")) {
[17:38:25.343]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:25.343]                         if (muffled) 
[17:38:25.343]                           invokeRestart("muffleMessage")
[17:38:25.343]                       }
[17:38:25.343]                       else if (inherits(cond, "warning")) {
[17:38:25.343]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:25.343]                         if (muffled) 
[17:38:25.343]                           invokeRestart("muffleWarning")
[17:38:25.343]                       }
[17:38:25.343]                       else if (inherits(cond, "condition")) {
[17:38:25.343]                         if (!is.null(pattern)) {
[17:38:25.343]                           computeRestarts <- base::computeRestarts
[17:38:25.343]                           grepl <- base::grepl
[17:38:25.343]                           restarts <- computeRestarts(cond)
[17:38:25.343]                           for (restart in restarts) {
[17:38:25.343]                             name <- restart$name
[17:38:25.343]                             if (is.null(name)) 
[17:38:25.343]                               next
[17:38:25.343]                             if (!grepl(pattern, name)) 
[17:38:25.343]                               next
[17:38:25.343]                             invokeRestart(restart)
[17:38:25.343]                             muffled <- TRUE
[17:38:25.343]                             break
[17:38:25.343]                           }
[17:38:25.343]                         }
[17:38:25.343]                       }
[17:38:25.343]                       invisible(muffled)
[17:38:25.343]                     }
[17:38:25.343]                     muffleCondition(cond, pattern = "^muffle")
[17:38:25.343]                   }
[17:38:25.343]                 }
[17:38:25.343]                 else {
[17:38:25.343]                   if (TRUE) {
[17:38:25.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:25.343]                     {
[17:38:25.343]                       inherits <- base::inherits
[17:38:25.343]                       invokeRestart <- base::invokeRestart
[17:38:25.343]                       is.null <- base::is.null
[17:38:25.343]                       muffled <- FALSE
[17:38:25.343]                       if (inherits(cond, "message")) {
[17:38:25.343]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:25.343]                         if (muffled) 
[17:38:25.343]                           invokeRestart("muffleMessage")
[17:38:25.343]                       }
[17:38:25.343]                       else if (inherits(cond, "warning")) {
[17:38:25.343]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:25.343]                         if (muffled) 
[17:38:25.343]                           invokeRestart("muffleWarning")
[17:38:25.343]                       }
[17:38:25.343]                       else if (inherits(cond, "condition")) {
[17:38:25.343]                         if (!is.null(pattern)) {
[17:38:25.343]                           computeRestarts <- base::computeRestarts
[17:38:25.343]                           grepl <- base::grepl
[17:38:25.343]                           restarts <- computeRestarts(cond)
[17:38:25.343]                           for (restart in restarts) {
[17:38:25.343]                             name <- restart$name
[17:38:25.343]                             if (is.null(name)) 
[17:38:25.343]                               next
[17:38:25.343]                             if (!grepl(pattern, name)) 
[17:38:25.343]                               next
[17:38:25.343]                             invokeRestart(restart)
[17:38:25.343]                             muffled <- TRUE
[17:38:25.343]                             break
[17:38:25.343]                           }
[17:38:25.343]                         }
[17:38:25.343]                       }
[17:38:25.343]                       invisible(muffled)
[17:38:25.343]                     }
[17:38:25.343]                     muffleCondition(cond, pattern = "^muffle")
[17:38:25.343]                   }
[17:38:25.343]                 }
[17:38:25.343]             }
[17:38:25.343]         }))
[17:38:25.343]     }, error = function(ex) {
[17:38:25.343]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:25.343]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:25.343]                 ...future.rng), started = ...future.startTime, 
[17:38:25.343]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:25.343]             version = "1.8"), class = "FutureResult")
[17:38:25.343]     }, finally = {
[17:38:25.343]         if (!identical(...future.workdir, getwd())) 
[17:38:25.343]             setwd(...future.workdir)
[17:38:25.343]         {
[17:38:25.343]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:25.343]                 ...future.oldOptions$nwarnings <- NULL
[17:38:25.343]             }
[17:38:25.343]             base::options(...future.oldOptions)
[17:38:25.343]             if (.Platform$OS.type == "windows") {
[17:38:25.343]                 old_names <- names(...future.oldEnvVars)
[17:38:25.343]                 envs <- base::Sys.getenv()
[17:38:25.343]                 names <- names(envs)
[17:38:25.343]                 common <- intersect(names, old_names)
[17:38:25.343]                 added <- setdiff(names, old_names)
[17:38:25.343]                 removed <- setdiff(old_names, names)
[17:38:25.343]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:25.343]                   envs[common]]
[17:38:25.343]                 NAMES <- toupper(changed)
[17:38:25.343]                 args <- list()
[17:38:25.343]                 for (kk in seq_along(NAMES)) {
[17:38:25.343]                   name <- changed[[kk]]
[17:38:25.343]                   NAME <- NAMES[[kk]]
[17:38:25.343]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:25.343]                     next
[17:38:25.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:25.343]                 }
[17:38:25.343]                 NAMES <- toupper(added)
[17:38:25.343]                 for (kk in seq_along(NAMES)) {
[17:38:25.343]                   name <- added[[kk]]
[17:38:25.343]                   NAME <- NAMES[[kk]]
[17:38:25.343]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:25.343]                     next
[17:38:25.343]                   args[[name]] <- ""
[17:38:25.343]                 }
[17:38:25.343]                 NAMES <- toupper(removed)
[17:38:25.343]                 for (kk in seq_along(NAMES)) {
[17:38:25.343]                   name <- removed[[kk]]
[17:38:25.343]                   NAME <- NAMES[[kk]]
[17:38:25.343]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:25.343]                     next
[17:38:25.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:25.343]                 }
[17:38:25.343]                 if (length(args) > 0) 
[17:38:25.343]                   base::do.call(base::Sys.setenv, args = args)
[17:38:25.343]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:25.343]             }
[17:38:25.343]             else {
[17:38:25.343]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:25.343]             }
[17:38:25.343]             {
[17:38:25.343]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:25.343]                   0L) {
[17:38:25.343]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:25.343]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:25.343]                   base::options(opts)
[17:38:25.343]                 }
[17:38:25.343]                 {
[17:38:25.343]                   {
[17:38:25.343]                     NULL
[17:38:25.343]                     RNGkind("Mersenne-Twister")
[17:38:25.343]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:25.343]                       inherits = FALSE)
[17:38:25.343]                   }
[17:38:25.343]                   options(future.plan = NULL)
[17:38:25.343]                   if (is.na(NA_character_)) 
[17:38:25.343]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:25.343]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:25.343]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:25.343]                     .init = FALSE)
[17:38:25.343]                 }
[17:38:25.343]             }
[17:38:25.343]         }
[17:38:25.343]     })
[17:38:25.343]     if (FALSE) {
[17:38:25.343]         base::sink(type = "output", split = FALSE)
[17:38:25.343]         if (NA) {
[17:38:25.343]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:25.343]         }
[17:38:25.343]         else {
[17:38:25.343]             ...future.result["stdout"] <- base::list(NULL)
[17:38:25.343]         }
[17:38:25.343]         base::close(...future.stdout)
[17:38:25.343]         ...future.stdout <- NULL
[17:38:25.343]     }
[17:38:25.343]     ...future.result$conditions <- ...future.conditions
[17:38:25.343]     ...future.result$finished <- base::Sys.time()
[17:38:25.343]     ...future.result
[17:38:25.343] }
[17:38:25.345] assign_globals() ...
[17:38:25.345] List of 5
[17:38:25.345]  $ ...future.FUN            :function (x)  
[17:38:25.345]  $ future.call.arguments    : list()
[17:38:25.345]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:25.345]  $ ...future.elements_ii    :List of 2
[17:38:25.345]   ..$ : int 1
[17:38:25.345]   ..$ : int 0
[17:38:25.345]  $ ...future.seeds_ii       : NULL
[17:38:25.345]  $ ...future.globals.maxSize: NULL
[17:38:25.345]  - attr(*, "where")=List of 5
[17:38:25.345]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:25.345]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:25.345]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:25.345]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:25.345]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:25.345]  - attr(*, "resolved")= logi FALSE
[17:38:25.345]  - attr(*, "total_size")= num 4720
[17:38:25.345]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:25.345]  - attr(*, "already-done")= logi TRUE
[17:38:25.351] - reassign environment for ‘...future.FUN’
[17:38:25.352] - copied ‘...future.FUN’ to environment
[17:38:25.352] - copied ‘future.call.arguments’ to environment
[17:38:25.352] - copied ‘...future.elements_ii’ to environment
[17:38:25.352] - copied ‘...future.seeds_ii’ to environment
[17:38:25.352] - copied ‘...future.globals.maxSize’ to environment
[17:38:25.352] assign_globals() ... done
[17:38:25.352] plan(): Setting new future strategy stack:
[17:38:25.352] List of future strategies:
[17:38:25.352] 1. sequential:
[17:38:25.352]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:25.352]    - tweaked: FALSE
[17:38:25.352]    - call: NULL
[17:38:25.353] plan(): nbrOfWorkers() = 1
[17:38:25.855] plan(): Setting new future strategy stack:
[17:38:25.855] List of future strategies:
[17:38:25.855] 1. multicore:
[17:38:25.855]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:25.855]    - tweaked: FALSE
[17:38:25.855]    - call: plan(strategy)
[17:38:25.859] plan(): nbrOfWorkers() = 1
[17:38:25.859] SequentialFuture started (and completed)
[17:38:25.859] - Launch lazy future ... done
[17:38:25.859] run() for ‘SequentialFuture’ ... done
[17:38:25.859] Created future:
[17:38:25.859] SequentialFuture:
[17:38:25.859] Label: ‘future_lapply-1’
[17:38:25.859] Expression:
[17:38:25.859] {
[17:38:25.859]     do.call(function(...) {
[17:38:25.859]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:25.859]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:25.859]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:25.859]             on.exit(options(oopts), add = TRUE)
[17:38:25.859]         }
[17:38:25.859]         {
[17:38:25.859]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:25.859]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:25.859]                 ...future.FUN(...future.X_jj, ...)
[17:38:25.859]             })
[17:38:25.859]         }
[17:38:25.859]     }, args = future.call.arguments)
[17:38:25.859] }
[17:38:25.859] Lazy evaluation: FALSE
[17:38:25.859] Asynchronous evaluation: FALSE
[17:38:25.859] Local evaluation: TRUE
[17:38:25.859] Environment: R_GlobalEnv
[17:38:25.859] Capture standard output: NA
[17:38:25.859] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:25.859] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:25.859] Packages: <none>
[17:38:25.859] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:25.859] Resolved: TRUE
[17:38:25.859] Value: 112 bytes of class ‘list’
[17:38:25.859] Early signaling: FALSE
[17:38:25.859] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:25.859] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:25.860] Chunk #1 of 1 ... DONE
[17:38:25.861] Launching 1 futures (chunks) ... DONE
[17:38:25.861] Resolving 1 futures (chunks) ...
[17:38:25.861] resolve() on list ...
[17:38:25.861]  recursive: 0
[17:38:25.861]  length: 1
[17:38:25.861] 
[17:38:25.861] resolved() for ‘SequentialFuture’ ...
[17:38:25.861] - state: ‘finished’
[17:38:25.861] - run: TRUE
[17:38:25.861] - result: ‘FutureResult’
[17:38:25.862] resolved() for ‘SequentialFuture’ ... done
[17:38:25.862] Future #1
[17:38:25.862] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:25.862] - nx: 1
[17:38:25.862] - relay: TRUE
[17:38:25.862] - stdout: TRUE
[17:38:25.862] - signal: TRUE
[17:38:25.862] - resignal: FALSE
[17:38:25.862] - force: TRUE
[17:38:25.862] - relayed: [n=1] FALSE
[17:38:25.862] - queued futures: [n=1] FALSE
[17:38:25.863]  - until=1
[17:38:25.863]  - relaying element #1
[17:38:25.863] - relayed: [n=1] TRUE
[17:38:25.863] - queued futures: [n=1] TRUE
[17:38:25.863] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:25.863]  length: 0 (resolved future 1)
[17:38:25.863] Relaying remaining futures
[17:38:25.863] signalConditionsASAP(NULL, pos=0) ...
[17:38:25.863] - nx: 1
[17:38:25.863] - relay: TRUE
[17:38:25.863] - stdout: TRUE
[17:38:25.864] - signal: TRUE
[17:38:25.864] - resignal: FALSE
[17:38:25.864] - force: TRUE
[17:38:25.864] - relayed: [n=1] TRUE
[17:38:25.864] - queued futures: [n=1] TRUE
 - flush all
[17:38:25.864] - relayed: [n=1] TRUE
[17:38:25.864] - queued futures: [n=1] TRUE
[17:38:25.864] signalConditionsASAP(NULL, pos=0) ... done
[17:38:25.864] resolve() on list ... DONE
[17:38:25.864]  - Number of value chunks collected: 1
[17:38:25.865] Resolving 1 futures (chunks) ... DONE
[17:38:25.865] Reducing values from 1 chunks ...
[17:38:25.865]  - Number of values collected after concatenation: 2
[17:38:25.865]  - Number of values expected: 2
[17:38:25.865] Reducing values from 1 chunks ... DONE
[17:38:25.865] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[17:38:25.865] future_mapply() ...
[17:38:25.869] Number of chunks: 1
[17:38:25.869] getGlobalsAndPackagesXApply() ...
[17:38:25.869]  - future.globals: TRUE
[17:38:25.869] getGlobalsAndPackages() ...
[17:38:25.869] Searching for globals...
[17:38:25.871] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:38:25.871] Searching for globals ... DONE
[17:38:25.871] Resolving globals: FALSE
[17:38:25.871] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:38:25.872] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:38:25.872] - globals: [1] ‘FUN’
[17:38:25.872] 
[17:38:25.872] getGlobalsAndPackages() ... DONE
[17:38:25.872]  - globals found/used: [n=1] ‘FUN’
[17:38:25.872]  - needed namespaces: [n=0] 
[17:38:25.872] Finding globals ... DONE
[17:38:25.872] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:38:25.872] List of 2
[17:38:25.872]  $ ...future.FUN:function (x, y)  
[17:38:25.872]  $ MoreArgs     : NULL
[17:38:25.872]  - attr(*, "where")=List of 2
[17:38:25.872]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:25.872]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:38:25.872]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:25.872]  - attr(*, "resolved")= logi FALSE
[17:38:25.872]  - attr(*, "total_size")= num NA
[17:38:25.875] Packages to be attached in all futures: [n=0] 
[17:38:25.875] getGlobalsAndPackagesXApply() ... DONE
[17:38:25.875] Number of futures (= number of chunks): 1
[17:38:25.875] Launching 1 futures (chunks) ...
[17:38:25.875] Chunk #1 of 1 ...
[17:38:25.876]  - Finding globals in '...' for chunk #1 ...
[17:38:25.876] getGlobalsAndPackages() ...
[17:38:25.876] Searching for globals...
[17:38:25.876] 
[17:38:25.876] Searching for globals ... DONE
[17:38:25.876] - globals: [0] <none>
[17:38:25.876] getGlobalsAndPackages() ... DONE
[17:38:25.876]    + additional globals found: [n=0] 
[17:38:25.876]    + additional namespaces needed: [n=0] 
[17:38:25.877]  - Finding globals in '...' for chunk #1 ... DONE
[17:38:25.877]  - seeds: <none>
[17:38:25.877]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:25.877] getGlobalsAndPackages() ...
[17:38:25.877] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:25.877] Resolving globals: FALSE
[17:38:25.878] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:38:25.878] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:38:25.878] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:25.878] 
[17:38:25.878] getGlobalsAndPackages() ... DONE
[17:38:25.879] run() for ‘Future’ ...
[17:38:25.879] - state: ‘created’
[17:38:25.879] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:25.884] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:25.884] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:25.884]   - Field: ‘label’
[17:38:25.884]   - Field: ‘local’
[17:38:25.884]   - Field: ‘owner’
[17:38:25.884]   - Field: ‘envir’
[17:38:25.885]   - Field: ‘packages’
[17:38:25.885]   - Field: ‘gc’
[17:38:25.885]   - Field: ‘conditions’
[17:38:25.885]   - Field: ‘expr’
[17:38:25.885]   - Field: ‘uuid’
[17:38:25.885]   - Field: ‘seed’
[17:38:25.885]   - Field: ‘version’
[17:38:25.885]   - Field: ‘result’
[17:38:25.885]   - Field: ‘asynchronous’
[17:38:25.885]   - Field: ‘calls’
[17:38:25.885]   - Field: ‘globals’
[17:38:25.886]   - Field: ‘stdout’
[17:38:25.886]   - Field: ‘earlySignal’
[17:38:25.886]   - Field: ‘lazy’
[17:38:25.886]   - Field: ‘state’
[17:38:25.886] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:25.886] - Launch lazy future ...
[17:38:25.886] Packages needed by the future expression (n = 0): <none>
[17:38:25.886] Packages needed by future strategies (n = 0): <none>
[17:38:25.887] {
[17:38:25.887]     {
[17:38:25.887]         {
[17:38:25.887]             ...future.startTime <- base::Sys.time()
[17:38:25.887]             {
[17:38:25.887]                 {
[17:38:25.887]                   {
[17:38:25.887]                     base::local({
[17:38:25.887]                       has_future <- base::requireNamespace("future", 
[17:38:25.887]                         quietly = TRUE)
[17:38:25.887]                       if (has_future) {
[17:38:25.887]                         ns <- base::getNamespace("future")
[17:38:25.887]                         version <- ns[[".package"]][["version"]]
[17:38:25.887]                         if (is.null(version)) 
[17:38:25.887]                           version <- utils::packageVersion("future")
[17:38:25.887]                       }
[17:38:25.887]                       else {
[17:38:25.887]                         version <- NULL
[17:38:25.887]                       }
[17:38:25.887]                       if (!has_future || version < "1.8.0") {
[17:38:25.887]                         info <- base::c(r_version = base::gsub("R version ", 
[17:38:25.887]                           "", base::R.version$version.string), 
[17:38:25.887]                           platform = base::sprintf("%s (%s-bit)", 
[17:38:25.887]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:25.887]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:25.887]                             "release", "version")], collapse = " "), 
[17:38:25.887]                           hostname = base::Sys.info()[["nodename"]])
[17:38:25.887]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:38:25.887]                           info)
[17:38:25.887]                         info <- base::paste(info, collapse = "; ")
[17:38:25.887]                         if (!has_future) {
[17:38:25.887]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:25.887]                             info)
[17:38:25.887]                         }
[17:38:25.887]                         else {
[17:38:25.887]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:25.887]                             info, version)
[17:38:25.887]                         }
[17:38:25.887]                         base::stop(msg)
[17:38:25.887]                       }
[17:38:25.887]                     })
[17:38:25.887]                   }
[17:38:25.887]                   ...future.strategy.old <- future::plan("list")
[17:38:25.887]                   options(future.plan = NULL)
[17:38:25.887]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:25.887]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:25.887]                 }
[17:38:25.887]                 ...future.workdir <- getwd()
[17:38:25.887]             }
[17:38:25.887]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:25.887]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:25.887]         }
[17:38:25.887]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:25.887]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:25.887]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:25.887]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:25.887]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:25.887]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:25.887]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:25.887]             base::names(...future.oldOptions))
[17:38:25.887]     }
[17:38:25.887]     if (FALSE) {
[17:38:25.887]     }
[17:38:25.887]     else {
[17:38:25.887]         if (FALSE) {
[17:38:25.887]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:25.887]                 open = "w")
[17:38:25.887]         }
[17:38:25.887]         else {
[17:38:25.887]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:25.887]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:25.887]         }
[17:38:25.887]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:25.887]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:25.887]             base::sink(type = "output", split = FALSE)
[17:38:25.887]             base::close(...future.stdout)
[17:38:25.887]         }, add = TRUE)
[17:38:25.887]     }
[17:38:25.887]     ...future.frame <- base::sys.nframe()
[17:38:25.887]     ...future.conditions <- base::list()
[17:38:25.887]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:25.887]     if (FALSE) {
[17:38:25.887]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:25.887]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:25.887]     }
[17:38:25.887]     ...future.result <- base::tryCatch({
[17:38:25.887]         base::withCallingHandlers({
[17:38:25.887]             ...future.value <- base::withVisible(base::local({
[17:38:25.887]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:25.887]                 if (!identical(...future.globals.maxSize.org, 
[17:38:25.887]                   ...future.globals.maxSize)) {
[17:38:25.887]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:25.887]                   on.exit(options(oopts), add = TRUE)
[17:38:25.887]                 }
[17:38:25.887]                 {
[17:38:25.887]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:25.887]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:38:25.887]                     USE.NAMES = FALSE)
[17:38:25.887]                   do.call(mapply, args = args)
[17:38:25.887]                 }
[17:38:25.887]             }))
[17:38:25.887]             future::FutureResult(value = ...future.value$value, 
[17:38:25.887]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:25.887]                   ...future.rng), globalenv = if (FALSE) 
[17:38:25.887]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:25.887]                     ...future.globalenv.names))
[17:38:25.887]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:25.887]         }, condition = base::local({
[17:38:25.887]             c <- base::c
[17:38:25.887]             inherits <- base::inherits
[17:38:25.887]             invokeRestart <- base::invokeRestart
[17:38:25.887]             length <- base::length
[17:38:25.887]             list <- base::list
[17:38:25.887]             seq.int <- base::seq.int
[17:38:25.887]             signalCondition <- base::signalCondition
[17:38:25.887]             sys.calls <- base::sys.calls
[17:38:25.887]             `[[` <- base::`[[`
[17:38:25.887]             `+` <- base::`+`
[17:38:25.887]             `<<-` <- base::`<<-`
[17:38:25.887]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:25.887]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:25.887]                   3L)]
[17:38:25.887]             }
[17:38:25.887]             function(cond) {
[17:38:25.887]                 is_error <- inherits(cond, "error")
[17:38:25.887]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:25.887]                   NULL)
[17:38:25.887]                 if (is_error) {
[17:38:25.887]                   sessionInformation <- function() {
[17:38:25.887]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:25.887]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:25.887]                       search = base::search(), system = base::Sys.info())
[17:38:25.887]                   }
[17:38:25.887]                   ...future.conditions[[length(...future.conditions) + 
[17:38:25.887]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:25.887]                     cond$call), session = sessionInformation(), 
[17:38:25.887]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:25.887]                   signalCondition(cond)
[17:38:25.887]                 }
[17:38:25.887]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:25.887]                 "immediateCondition"))) {
[17:38:25.887]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:25.887]                   ...future.conditions[[length(...future.conditions) + 
[17:38:25.887]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:25.887]                   if (TRUE && !signal) {
[17:38:25.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:25.887]                     {
[17:38:25.887]                       inherits <- base::inherits
[17:38:25.887]                       invokeRestart <- base::invokeRestart
[17:38:25.887]                       is.null <- base::is.null
[17:38:25.887]                       muffled <- FALSE
[17:38:25.887]                       if (inherits(cond, "message")) {
[17:38:25.887]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:25.887]                         if (muffled) 
[17:38:25.887]                           invokeRestart("muffleMessage")
[17:38:25.887]                       }
[17:38:25.887]                       else if (inherits(cond, "warning")) {
[17:38:25.887]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:25.887]                         if (muffled) 
[17:38:25.887]                           invokeRestart("muffleWarning")
[17:38:25.887]                       }
[17:38:25.887]                       else if (inherits(cond, "condition")) {
[17:38:25.887]                         if (!is.null(pattern)) {
[17:38:25.887]                           computeRestarts <- base::computeRestarts
[17:38:25.887]                           grepl <- base::grepl
[17:38:25.887]                           restarts <- computeRestarts(cond)
[17:38:25.887]                           for (restart in restarts) {
[17:38:25.887]                             name <- restart$name
[17:38:25.887]                             if (is.null(name)) 
[17:38:25.887]                               next
[17:38:25.887]                             if (!grepl(pattern, name)) 
[17:38:25.887]                               next
[17:38:25.887]                             invokeRestart(restart)
[17:38:25.887]                             muffled <- TRUE
[17:38:25.887]                             break
[17:38:25.887]                           }
[17:38:25.887]                         }
[17:38:25.887]                       }
[17:38:25.887]                       invisible(muffled)
[17:38:25.887]                     }
[17:38:25.887]                     muffleCondition(cond, pattern = "^muffle")
[17:38:25.887]                   }
[17:38:25.887]                 }
[17:38:25.887]                 else {
[17:38:25.887]                   if (TRUE) {
[17:38:25.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:25.887]                     {
[17:38:25.887]                       inherits <- base::inherits
[17:38:25.887]                       invokeRestart <- base::invokeRestart
[17:38:25.887]                       is.null <- base::is.null
[17:38:25.887]                       muffled <- FALSE
[17:38:25.887]                       if (inherits(cond, "message")) {
[17:38:25.887]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:25.887]                         if (muffled) 
[17:38:25.887]                           invokeRestart("muffleMessage")
[17:38:25.887]                       }
[17:38:25.887]                       else if (inherits(cond, "warning")) {
[17:38:25.887]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:25.887]                         if (muffled) 
[17:38:25.887]                           invokeRestart("muffleWarning")
[17:38:25.887]                       }
[17:38:25.887]                       else if (inherits(cond, "condition")) {
[17:38:25.887]                         if (!is.null(pattern)) {
[17:38:25.887]                           computeRestarts <- base::computeRestarts
[17:38:25.887]                           grepl <- base::grepl
[17:38:25.887]                           restarts <- computeRestarts(cond)
[17:38:25.887]                           for (restart in restarts) {
[17:38:25.887]                             name <- restart$name
[17:38:25.887]                             if (is.null(name)) 
[17:38:25.887]                               next
[17:38:25.887]                             if (!grepl(pattern, name)) 
[17:38:25.887]                               next
[17:38:25.887]                             invokeRestart(restart)
[17:38:25.887]                             muffled <- TRUE
[17:38:25.887]                             break
[17:38:25.887]                           }
[17:38:25.887]                         }
[17:38:25.887]                       }
[17:38:25.887]                       invisible(muffled)
[17:38:25.887]                     }
[17:38:25.887]                     muffleCondition(cond, pattern = "^muffle")
[17:38:25.887]                   }
[17:38:25.887]                 }
[17:38:25.887]             }
[17:38:25.887]         }))
[17:38:25.887]     }, error = function(ex) {
[17:38:25.887]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:25.887]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:25.887]                 ...future.rng), started = ...future.startTime, 
[17:38:25.887]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:25.887]             version = "1.8"), class = "FutureResult")
[17:38:25.887]     }, finally = {
[17:38:25.887]         if (!identical(...future.workdir, getwd())) 
[17:38:25.887]             setwd(...future.workdir)
[17:38:25.887]         {
[17:38:25.887]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:25.887]                 ...future.oldOptions$nwarnings <- NULL
[17:38:25.887]             }
[17:38:25.887]             base::options(...future.oldOptions)
[17:38:25.887]             if (.Platform$OS.type == "windows") {
[17:38:25.887]                 old_names <- names(...future.oldEnvVars)
[17:38:25.887]                 envs <- base::Sys.getenv()
[17:38:25.887]                 names <- names(envs)
[17:38:25.887]                 common <- intersect(names, old_names)
[17:38:25.887]                 added <- setdiff(names, old_names)
[17:38:25.887]                 removed <- setdiff(old_names, names)
[17:38:25.887]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:25.887]                   envs[common]]
[17:38:25.887]                 NAMES <- toupper(changed)
[17:38:25.887]                 args <- list()
[17:38:25.887]                 for (kk in seq_along(NAMES)) {
[17:38:25.887]                   name <- changed[[kk]]
[17:38:25.887]                   NAME <- NAMES[[kk]]
[17:38:25.887]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:25.887]                     next
[17:38:25.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:25.887]                 }
[17:38:25.887]                 NAMES <- toupper(added)
[17:38:25.887]                 for (kk in seq_along(NAMES)) {
[17:38:25.887]                   name <- added[[kk]]
[17:38:25.887]                   NAME <- NAMES[[kk]]
[17:38:25.887]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:25.887]                     next
[17:38:25.887]                   args[[name]] <- ""
[17:38:25.887]                 }
[17:38:25.887]                 NAMES <- toupper(removed)
[17:38:25.887]                 for (kk in seq_along(NAMES)) {
[17:38:25.887]                   name <- removed[[kk]]
[17:38:25.887]                   NAME <- NAMES[[kk]]
[17:38:25.887]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:25.887]                     next
[17:38:25.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:25.887]                 }
[17:38:25.887]                 if (length(args) > 0) 
[17:38:25.887]                   base::do.call(base::Sys.setenv, args = args)
[17:38:25.887]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:25.887]             }
[17:38:25.887]             else {
[17:38:25.887]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:25.887]             }
[17:38:25.887]             {
[17:38:25.887]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:25.887]                   0L) {
[17:38:25.887]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:25.887]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:25.887]                   base::options(opts)
[17:38:25.887]                 }
[17:38:25.887]                 {
[17:38:25.887]                   {
[17:38:25.887]                     NULL
[17:38:25.887]                     RNGkind("Mersenne-Twister")
[17:38:25.887]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:25.887]                       inherits = FALSE)
[17:38:25.887]                   }
[17:38:25.887]                   options(future.plan = NULL)
[17:38:25.887]                   if (is.na(NA_character_)) 
[17:38:25.887]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:25.887]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:25.887]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:25.887]                     .init = FALSE)
[17:38:25.887]                 }
[17:38:25.887]             }
[17:38:25.887]         }
[17:38:25.887]     })
[17:38:25.887]     if (TRUE) {
[17:38:25.887]         base::sink(type = "output", split = FALSE)
[17:38:25.887]         if (FALSE) {
[17:38:25.887]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:25.887]         }
[17:38:25.887]         else {
[17:38:25.887]             ...future.result["stdout"] <- base::list(NULL)
[17:38:25.887]         }
[17:38:25.887]         base::close(...future.stdout)
[17:38:25.887]         ...future.stdout <- NULL
[17:38:25.887]     }
[17:38:25.887]     ...future.result$conditions <- ...future.conditions
[17:38:25.887]     ...future.result$finished <- base::Sys.time()
[17:38:25.887]     ...future.result
[17:38:25.887] }
[17:38:25.888] assign_globals() ...
[17:38:25.888] List of 5
[17:38:25.888]  $ ...future.FUN            :function (x, y)  
[17:38:25.888]  $ MoreArgs                 : NULL
[17:38:25.888]  $ ...future.elements_ii    :List of 2
[17:38:25.888]   ..$ :List of 2
[17:38:25.888]   .. ..$ : int 1
[17:38:25.888]   .. ..$ : int 0
[17:38:25.888]   ..$ :List of 2
[17:38:25.888]   .. ..$ : int 0
[17:38:25.888]   .. ..$ : int 1
[17:38:25.888]  $ ...future.seeds_ii       : NULL
[17:38:25.888]  $ ...future.globals.maxSize: NULL
[17:38:25.888]  - attr(*, "where")=List of 5
[17:38:25.888]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:25.888]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:38:25.888]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:25.888]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:25.888]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:25.888]  - attr(*, "resolved")= logi FALSE
[17:38:25.888]  - attr(*, "total_size")= num 6480
[17:38:25.888]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:25.888]  - attr(*, "already-done")= logi TRUE
[17:38:25.894] - reassign environment for ‘...future.FUN’
[17:38:25.894] - copied ‘...future.FUN’ to environment
[17:38:25.894] - copied ‘MoreArgs’ to environment
[17:38:25.894] - copied ‘...future.elements_ii’ to environment
[17:38:25.894] - copied ‘...future.seeds_ii’ to environment
[17:38:25.894] - copied ‘...future.globals.maxSize’ to environment
[17:38:25.895] assign_globals() ... done
[17:38:25.895] plan(): Setting new future strategy stack:
[17:38:25.895] List of future strategies:
[17:38:25.895] 1. sequential:
[17:38:25.895]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:25.895]    - tweaked: FALSE
[17:38:25.895]    - call: NULL
[17:38:25.895] plan(): nbrOfWorkers() = 1
[17:38:26.397] plan(): Setting new future strategy stack:
[17:38:26.397] List of future strategies:
[17:38:26.397] 1. multicore:
[17:38:26.397]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:26.397]    - tweaked: FALSE
[17:38:26.397]    - call: plan(strategy)
[17:38:26.401] plan(): nbrOfWorkers() = 1
[17:38:26.401] SequentialFuture started (and completed)
[17:38:26.401] - Launch lazy future ... done
[17:38:26.402] run() for ‘SequentialFuture’ ... done
[17:38:26.402] Created future:
[17:38:26.402] SequentialFuture:
[17:38:26.402] Label: ‘future_mapply-1’
[17:38:26.402] Expression:
[17:38:26.402] {
[17:38:26.402]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:26.402]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:26.402]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:26.402]         on.exit(options(oopts), add = TRUE)
[17:38:26.402]     }
[17:38:26.402]     {
[17:38:26.402]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:26.402]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:38:26.402]         do.call(mapply, args = args)
[17:38:26.402]     }
[17:38:26.402] }
[17:38:26.402] Lazy evaluation: FALSE
[17:38:26.402] Asynchronous evaluation: FALSE
[17:38:26.402] Local evaluation: TRUE
[17:38:26.402] Environment: R_GlobalEnv
[17:38:26.402] Capture standard output: FALSE
[17:38:26.402] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:26.402] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:26.402] Packages: <none>
[17:38:26.402] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:26.402] Resolved: TRUE
[17:38:26.402] Value: 224 bytes of class ‘list’
[17:38:26.402] Early signaling: FALSE
[17:38:26.402] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:26.402] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:26.403] Chunk #1 of 1 ... DONE
[17:38:26.403] Launching 1 futures (chunks) ... DONE
[17:38:26.403] Resolving 1 futures (chunks) ...
[17:38:26.403] resolve() on list ...
[17:38:26.403]  recursive: 0
[17:38:26.403]  length: 1
[17:38:26.403] 
[17:38:26.404] resolved() for ‘SequentialFuture’ ...
[17:38:26.404] - state: ‘finished’
[17:38:26.404] - run: TRUE
[17:38:26.404] - result: ‘FutureResult’
[17:38:26.404] resolved() for ‘SequentialFuture’ ... done
[17:38:26.404] Future #1
[17:38:26.404] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:26.404] - nx: 1
[17:38:26.404] - relay: TRUE
[17:38:26.404] - stdout: TRUE
[17:38:26.405] - signal: TRUE
[17:38:26.405] - resignal: FALSE
[17:38:26.405] - force: TRUE
[17:38:26.405] - relayed: [n=1] FALSE
[17:38:26.405] - queued futures: [n=1] FALSE
[17:38:26.405]  - until=1
[17:38:26.405]  - relaying element #1
[17:38:26.405] - relayed: [n=1] TRUE
[17:38:26.405] - queued futures: [n=1] TRUE
[17:38:26.405] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:26.405]  length: 0 (resolved future 1)
[17:38:26.406] Relaying remaining futures
[17:38:26.406] signalConditionsASAP(NULL, pos=0) ...
[17:38:26.406] - nx: 1
[17:38:26.406] - relay: TRUE
[17:38:26.406] - stdout: TRUE
[17:38:26.406] - signal: TRUE
[17:38:26.406] - resignal: FALSE
[17:38:26.406] - force: TRUE
[17:38:26.406] - relayed: [n=1] TRUE
[17:38:26.406] - queued futures: [n=1] TRUE
 - flush all
[17:38:26.406] - relayed: [n=1] TRUE
[17:38:26.407] - queued futures: [n=1] TRUE
[17:38:26.407] signalConditionsASAP(NULL, pos=0) ... done
[17:38:26.407] resolve() on list ... DONE
[17:38:26.407]  - Number of value chunks collected: 1
[17:38:26.407] Resolving 1 futures (chunks) ... DONE
[17:38:26.407] Reducing values from 1 chunks ...
[17:38:26.407]  - Number of values collected after concatenation: 2
[17:38:26.407]  - Number of values expected: 2
[17:38:26.407] Reducing values from 1 chunks ... DONE
[17:38:26.407] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[17:38:26.408] future_mapply() ...
[17:38:26.411] Number of chunks: 1
[17:38:26.411] getGlobalsAndPackagesXApply() ...
[17:38:26.411]  - future.globals: TRUE
[17:38:26.411] getGlobalsAndPackages() ...
[17:38:26.412] Searching for globals...
[17:38:26.413] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:38:26.413] Searching for globals ... DONE
[17:38:26.413] Resolving globals: FALSE
[17:38:26.414] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:38:26.416] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:38:26.416] - globals: [1] ‘FUN’
[17:38:26.416] 
[17:38:26.416] getGlobalsAndPackages() ... DONE
[17:38:26.416]  - globals found/used: [n=1] ‘FUN’
[17:38:26.416]  - needed namespaces: [n=0] 
[17:38:26.416] Finding globals ... DONE
[17:38:26.417] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:38:26.417] List of 2
[17:38:26.417]  $ ...future.FUN:function (x, y)  
[17:38:26.417]  $ MoreArgs     : NULL
[17:38:26.417]  - attr(*, "where")=List of 2
[17:38:26.417]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:26.417]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:38:26.417]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:26.417]  - attr(*, "resolved")= logi FALSE
[17:38:26.417]  - attr(*, "total_size")= num NA
[17:38:26.419] Packages to be attached in all futures: [n=0] 
[17:38:26.419] getGlobalsAndPackagesXApply() ... DONE
[17:38:26.419] Number of futures (= number of chunks): 1
[17:38:26.420] Launching 1 futures (chunks) ...
[17:38:26.420] Chunk #1 of 1 ...
[17:38:26.420]  - Finding globals in '...' for chunk #1 ...
[17:38:26.420] getGlobalsAndPackages() ...
[17:38:26.420] Searching for globals...
[17:38:26.420] 
[17:38:26.421] Searching for globals ... DONE
[17:38:26.421] - globals: [0] <none>
[17:38:26.421] getGlobalsAndPackages() ... DONE
[17:38:26.421]    + additional globals found: [n=0] 
[17:38:26.421]    + additional namespaces needed: [n=0] 
[17:38:26.421]  - Finding globals in '...' for chunk #1 ... DONE
[17:38:26.421]  - seeds: <none>
[17:38:26.421]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:26.421] getGlobalsAndPackages() ...
[17:38:26.421] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:26.421] Resolving globals: FALSE
[17:38:26.422] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:38:26.422] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:38:26.422] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:26.423] 
[17:38:26.423] getGlobalsAndPackages() ... DONE
[17:38:26.423] run() for ‘Future’ ...
[17:38:26.423] - state: ‘created’
[17:38:26.423] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:26.427] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:26.427] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:26.427]   - Field: ‘label’
[17:38:26.427]   - Field: ‘local’
[17:38:26.427]   - Field: ‘owner’
[17:38:26.427]   - Field: ‘envir’
[17:38:26.427]   - Field: ‘packages’
[17:38:26.427]   - Field: ‘gc’
[17:38:26.427]   - Field: ‘conditions’
[17:38:26.428]   - Field: ‘expr’
[17:38:26.428]   - Field: ‘uuid’
[17:38:26.428]   - Field: ‘seed’
[17:38:26.428]   - Field: ‘version’
[17:38:26.428]   - Field: ‘result’
[17:38:26.428]   - Field: ‘asynchronous’
[17:38:26.428]   - Field: ‘calls’
[17:38:26.428]   - Field: ‘globals’
[17:38:26.428]   - Field: ‘stdout’
[17:38:26.428]   - Field: ‘earlySignal’
[17:38:26.428]   - Field: ‘lazy’
[17:38:26.429]   - Field: ‘state’
[17:38:26.429] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:26.429] - Launch lazy future ...
[17:38:26.429] Packages needed by the future expression (n = 0): <none>
[17:38:26.429] Packages needed by future strategies (n = 0): <none>
[17:38:26.429] {
[17:38:26.429]     {
[17:38:26.429]         {
[17:38:26.429]             ...future.startTime <- base::Sys.time()
[17:38:26.429]             {
[17:38:26.429]                 {
[17:38:26.429]                   {
[17:38:26.429]                     base::local({
[17:38:26.429]                       has_future <- base::requireNamespace("future", 
[17:38:26.429]                         quietly = TRUE)
[17:38:26.429]                       if (has_future) {
[17:38:26.429]                         ns <- base::getNamespace("future")
[17:38:26.429]                         version <- ns[[".package"]][["version"]]
[17:38:26.429]                         if (is.null(version)) 
[17:38:26.429]                           version <- utils::packageVersion("future")
[17:38:26.429]                       }
[17:38:26.429]                       else {
[17:38:26.429]                         version <- NULL
[17:38:26.429]                       }
[17:38:26.429]                       if (!has_future || version < "1.8.0") {
[17:38:26.429]                         info <- base::c(r_version = base::gsub("R version ", 
[17:38:26.429]                           "", base::R.version$version.string), 
[17:38:26.429]                           platform = base::sprintf("%s (%s-bit)", 
[17:38:26.429]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:26.429]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:26.429]                             "release", "version")], collapse = " "), 
[17:38:26.429]                           hostname = base::Sys.info()[["nodename"]])
[17:38:26.429]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:38:26.429]                           info)
[17:38:26.429]                         info <- base::paste(info, collapse = "; ")
[17:38:26.429]                         if (!has_future) {
[17:38:26.429]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:26.429]                             info)
[17:38:26.429]                         }
[17:38:26.429]                         else {
[17:38:26.429]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:26.429]                             info, version)
[17:38:26.429]                         }
[17:38:26.429]                         base::stop(msg)
[17:38:26.429]                       }
[17:38:26.429]                     })
[17:38:26.429]                   }
[17:38:26.429]                   ...future.strategy.old <- future::plan("list")
[17:38:26.429]                   options(future.plan = NULL)
[17:38:26.429]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:26.429]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:26.429]                 }
[17:38:26.429]                 ...future.workdir <- getwd()
[17:38:26.429]             }
[17:38:26.429]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:26.429]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:26.429]         }
[17:38:26.429]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:26.429]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:26.429]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:26.429]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:26.429]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:26.429]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:26.429]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:26.429]             base::names(...future.oldOptions))
[17:38:26.429]     }
[17:38:26.429]     if (FALSE) {
[17:38:26.429]     }
[17:38:26.429]     else {
[17:38:26.429]         if (TRUE) {
[17:38:26.429]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:26.429]                 open = "w")
[17:38:26.429]         }
[17:38:26.429]         else {
[17:38:26.429]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:26.429]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:26.429]         }
[17:38:26.429]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:26.429]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:26.429]             base::sink(type = "output", split = FALSE)
[17:38:26.429]             base::close(...future.stdout)
[17:38:26.429]         }, add = TRUE)
[17:38:26.429]     }
[17:38:26.429]     ...future.frame <- base::sys.nframe()
[17:38:26.429]     ...future.conditions <- base::list()
[17:38:26.429]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:26.429]     if (FALSE) {
[17:38:26.429]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:26.429]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:26.429]     }
[17:38:26.429]     ...future.result <- base::tryCatch({
[17:38:26.429]         base::withCallingHandlers({
[17:38:26.429]             ...future.value <- base::withVisible(base::local({
[17:38:26.429]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:26.429]                 if (!identical(...future.globals.maxSize.org, 
[17:38:26.429]                   ...future.globals.maxSize)) {
[17:38:26.429]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:26.429]                   on.exit(options(oopts), add = TRUE)
[17:38:26.429]                 }
[17:38:26.429]                 {
[17:38:26.429]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:26.429]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:38:26.429]                     USE.NAMES = FALSE)
[17:38:26.429]                   do.call(mapply, args = args)
[17:38:26.429]                 }
[17:38:26.429]             }))
[17:38:26.429]             future::FutureResult(value = ...future.value$value, 
[17:38:26.429]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:26.429]                   ...future.rng), globalenv = if (FALSE) 
[17:38:26.429]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:26.429]                     ...future.globalenv.names))
[17:38:26.429]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:26.429]         }, condition = base::local({
[17:38:26.429]             c <- base::c
[17:38:26.429]             inherits <- base::inherits
[17:38:26.429]             invokeRestart <- base::invokeRestart
[17:38:26.429]             length <- base::length
[17:38:26.429]             list <- base::list
[17:38:26.429]             seq.int <- base::seq.int
[17:38:26.429]             signalCondition <- base::signalCondition
[17:38:26.429]             sys.calls <- base::sys.calls
[17:38:26.429]             `[[` <- base::`[[`
[17:38:26.429]             `+` <- base::`+`
[17:38:26.429]             `<<-` <- base::`<<-`
[17:38:26.429]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:26.429]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:26.429]                   3L)]
[17:38:26.429]             }
[17:38:26.429]             function(cond) {
[17:38:26.429]                 is_error <- inherits(cond, "error")
[17:38:26.429]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:26.429]                   NULL)
[17:38:26.429]                 if (is_error) {
[17:38:26.429]                   sessionInformation <- function() {
[17:38:26.429]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:26.429]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:26.429]                       search = base::search(), system = base::Sys.info())
[17:38:26.429]                   }
[17:38:26.429]                   ...future.conditions[[length(...future.conditions) + 
[17:38:26.429]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:26.429]                     cond$call), session = sessionInformation(), 
[17:38:26.429]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:26.429]                   signalCondition(cond)
[17:38:26.429]                 }
[17:38:26.429]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:26.429]                 "immediateCondition"))) {
[17:38:26.429]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:26.429]                   ...future.conditions[[length(...future.conditions) + 
[17:38:26.429]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:26.429]                   if (TRUE && !signal) {
[17:38:26.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:26.429]                     {
[17:38:26.429]                       inherits <- base::inherits
[17:38:26.429]                       invokeRestart <- base::invokeRestart
[17:38:26.429]                       is.null <- base::is.null
[17:38:26.429]                       muffled <- FALSE
[17:38:26.429]                       if (inherits(cond, "message")) {
[17:38:26.429]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:26.429]                         if (muffled) 
[17:38:26.429]                           invokeRestart("muffleMessage")
[17:38:26.429]                       }
[17:38:26.429]                       else if (inherits(cond, "warning")) {
[17:38:26.429]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:26.429]                         if (muffled) 
[17:38:26.429]                           invokeRestart("muffleWarning")
[17:38:26.429]                       }
[17:38:26.429]                       else if (inherits(cond, "condition")) {
[17:38:26.429]                         if (!is.null(pattern)) {
[17:38:26.429]                           computeRestarts <- base::computeRestarts
[17:38:26.429]                           grepl <- base::grepl
[17:38:26.429]                           restarts <- computeRestarts(cond)
[17:38:26.429]                           for (restart in restarts) {
[17:38:26.429]                             name <- restart$name
[17:38:26.429]                             if (is.null(name)) 
[17:38:26.429]                               next
[17:38:26.429]                             if (!grepl(pattern, name)) 
[17:38:26.429]                               next
[17:38:26.429]                             invokeRestart(restart)
[17:38:26.429]                             muffled <- TRUE
[17:38:26.429]                             break
[17:38:26.429]                           }
[17:38:26.429]                         }
[17:38:26.429]                       }
[17:38:26.429]                       invisible(muffled)
[17:38:26.429]                     }
[17:38:26.429]                     muffleCondition(cond, pattern = "^muffle")
[17:38:26.429]                   }
[17:38:26.429]                 }
[17:38:26.429]                 else {
[17:38:26.429]                   if (TRUE) {
[17:38:26.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:26.429]                     {
[17:38:26.429]                       inherits <- base::inherits
[17:38:26.429]                       invokeRestart <- base::invokeRestart
[17:38:26.429]                       is.null <- base::is.null
[17:38:26.429]                       muffled <- FALSE
[17:38:26.429]                       if (inherits(cond, "message")) {
[17:38:26.429]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:26.429]                         if (muffled) 
[17:38:26.429]                           invokeRestart("muffleMessage")
[17:38:26.429]                       }
[17:38:26.429]                       else if (inherits(cond, "warning")) {
[17:38:26.429]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:26.429]                         if (muffled) 
[17:38:26.429]                           invokeRestart("muffleWarning")
[17:38:26.429]                       }
[17:38:26.429]                       else if (inherits(cond, "condition")) {
[17:38:26.429]                         if (!is.null(pattern)) {
[17:38:26.429]                           computeRestarts <- base::computeRestarts
[17:38:26.429]                           grepl <- base::grepl
[17:38:26.429]                           restarts <- computeRestarts(cond)
[17:38:26.429]                           for (restart in restarts) {
[17:38:26.429]                             name <- restart$name
[17:38:26.429]                             if (is.null(name)) 
[17:38:26.429]                               next
[17:38:26.429]                             if (!grepl(pattern, name)) 
[17:38:26.429]                               next
[17:38:26.429]                             invokeRestart(restart)
[17:38:26.429]                             muffled <- TRUE
[17:38:26.429]                             break
[17:38:26.429]                           }
[17:38:26.429]                         }
[17:38:26.429]                       }
[17:38:26.429]                       invisible(muffled)
[17:38:26.429]                     }
[17:38:26.429]                     muffleCondition(cond, pattern = "^muffle")
[17:38:26.429]                   }
[17:38:26.429]                 }
[17:38:26.429]             }
[17:38:26.429]         }))
[17:38:26.429]     }, error = function(ex) {
[17:38:26.429]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:26.429]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:26.429]                 ...future.rng), started = ...future.startTime, 
[17:38:26.429]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:26.429]             version = "1.8"), class = "FutureResult")
[17:38:26.429]     }, finally = {
[17:38:26.429]         if (!identical(...future.workdir, getwd())) 
[17:38:26.429]             setwd(...future.workdir)
[17:38:26.429]         {
[17:38:26.429]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:26.429]                 ...future.oldOptions$nwarnings <- NULL
[17:38:26.429]             }
[17:38:26.429]             base::options(...future.oldOptions)
[17:38:26.429]             if (.Platform$OS.type == "windows") {
[17:38:26.429]                 old_names <- names(...future.oldEnvVars)
[17:38:26.429]                 envs <- base::Sys.getenv()
[17:38:26.429]                 names <- names(envs)
[17:38:26.429]                 common <- intersect(names, old_names)
[17:38:26.429]                 added <- setdiff(names, old_names)
[17:38:26.429]                 removed <- setdiff(old_names, names)
[17:38:26.429]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:26.429]                   envs[common]]
[17:38:26.429]                 NAMES <- toupper(changed)
[17:38:26.429]                 args <- list()
[17:38:26.429]                 for (kk in seq_along(NAMES)) {
[17:38:26.429]                   name <- changed[[kk]]
[17:38:26.429]                   NAME <- NAMES[[kk]]
[17:38:26.429]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:26.429]                     next
[17:38:26.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:26.429]                 }
[17:38:26.429]                 NAMES <- toupper(added)
[17:38:26.429]                 for (kk in seq_along(NAMES)) {
[17:38:26.429]                   name <- added[[kk]]
[17:38:26.429]                   NAME <- NAMES[[kk]]
[17:38:26.429]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:26.429]                     next
[17:38:26.429]                   args[[name]] <- ""
[17:38:26.429]                 }
[17:38:26.429]                 NAMES <- toupper(removed)
[17:38:26.429]                 for (kk in seq_along(NAMES)) {
[17:38:26.429]                   name <- removed[[kk]]
[17:38:26.429]                   NAME <- NAMES[[kk]]
[17:38:26.429]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:26.429]                     next
[17:38:26.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:26.429]                 }
[17:38:26.429]                 if (length(args) > 0) 
[17:38:26.429]                   base::do.call(base::Sys.setenv, args = args)
[17:38:26.429]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:26.429]             }
[17:38:26.429]             else {
[17:38:26.429]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:26.429]             }
[17:38:26.429]             {
[17:38:26.429]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:26.429]                   0L) {
[17:38:26.429]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:26.429]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:26.429]                   base::options(opts)
[17:38:26.429]                 }
[17:38:26.429]                 {
[17:38:26.429]                   {
[17:38:26.429]                     NULL
[17:38:26.429]                     RNGkind("Mersenne-Twister")
[17:38:26.429]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:26.429]                       inherits = FALSE)
[17:38:26.429]                   }
[17:38:26.429]                   options(future.plan = NULL)
[17:38:26.429]                   if (is.na(NA_character_)) 
[17:38:26.429]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:26.429]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:26.429]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:26.429]                     .init = FALSE)
[17:38:26.429]                 }
[17:38:26.429]             }
[17:38:26.429]         }
[17:38:26.429]     })
[17:38:26.429]     if (TRUE) {
[17:38:26.429]         base::sink(type = "output", split = FALSE)
[17:38:26.429]         if (TRUE) {
[17:38:26.429]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:26.429]         }
[17:38:26.429]         else {
[17:38:26.429]             ...future.result["stdout"] <- base::list(NULL)
[17:38:26.429]         }
[17:38:26.429]         base::close(...future.stdout)
[17:38:26.429]         ...future.stdout <- NULL
[17:38:26.429]     }
[17:38:26.429]     ...future.result$conditions <- ...future.conditions
[17:38:26.429]     ...future.result$finished <- base::Sys.time()
[17:38:26.429]     ...future.result
[17:38:26.429] }
[17:38:26.431] assign_globals() ...
[17:38:26.431] List of 5
[17:38:26.431]  $ ...future.FUN            :function (x, y)  
[17:38:26.431]  $ MoreArgs                 : NULL
[17:38:26.431]  $ ...future.elements_ii    :List of 2
[17:38:26.431]   ..$ :List of 2
[17:38:26.431]   .. ..$ : int 1
[17:38:26.431]   .. ..$ : int 0
[17:38:26.431]   ..$ :List of 2
[17:38:26.431]   .. ..$ : int 0
[17:38:26.431]   .. ..$ : int 1
[17:38:26.431]  $ ...future.seeds_ii       : NULL
[17:38:26.431]  $ ...future.globals.maxSize: NULL
[17:38:26.431]  - attr(*, "where")=List of 5
[17:38:26.431]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:26.431]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:38:26.431]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:26.431]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:26.431]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:26.431]  - attr(*, "resolved")= logi FALSE
[17:38:26.431]  - attr(*, "total_size")= num 6480
[17:38:26.431]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:26.431]  - attr(*, "already-done")= logi TRUE
[17:38:26.437] - reassign environment for ‘...future.FUN’
[17:38:26.437] - copied ‘...future.FUN’ to environment
[17:38:26.437] - copied ‘MoreArgs’ to environment
[17:38:26.437] - copied ‘...future.elements_ii’ to environment
[17:38:26.437] - copied ‘...future.seeds_ii’ to environment
[17:38:26.437] - copied ‘...future.globals.maxSize’ to environment
[17:38:26.437] assign_globals() ... done
[17:38:26.437] plan(): Setting new future strategy stack:
[17:38:26.438] List of future strategies:
[17:38:26.438] 1. sequential:
[17:38:26.438]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:26.438]    - tweaked: FALSE
[17:38:26.438]    - call: NULL
[17:38:26.438] plan(): nbrOfWorkers() = 1
[17:38:26.940] plan(): Setting new future strategy stack:
[17:38:26.940] List of future strategies:
[17:38:26.940] 1. multicore:
[17:38:26.940]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:26.940]    - tweaked: FALSE
[17:38:26.940]    - call: plan(strategy)
[17:38:26.944] plan(): nbrOfWorkers() = 1
[17:38:26.944] SequentialFuture started (and completed)
[17:38:26.944] - Launch lazy future ... done
[17:38:26.945] run() for ‘SequentialFuture’ ... done
[17:38:26.945] Created future:
[17:38:26.945] SequentialFuture:
[17:38:26.945] Label: ‘future_mapply-1’
[17:38:26.945] Expression:
[17:38:26.945] {
[17:38:26.945]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:26.945]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:26.945]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:26.945]         on.exit(options(oopts), add = TRUE)
[17:38:26.945]     }
[17:38:26.945]     {
[17:38:26.945]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:26.945]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:38:26.945]         do.call(mapply, args = args)
[17:38:26.945]     }
[17:38:26.945] }
[17:38:26.945] Lazy evaluation: FALSE
[17:38:26.945] Asynchronous evaluation: FALSE
[17:38:26.945] Local evaluation: TRUE
[17:38:26.945] Environment: R_GlobalEnv
[17:38:26.945] Capture standard output: TRUE
[17:38:26.945] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:26.945] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:26.945] Packages: <none>
[17:38:26.945] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:26.945] Resolved: TRUE
[17:38:26.945] Value: 224 bytes of class ‘list’
[17:38:26.945] Early signaling: FALSE
[17:38:26.945] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:26.945] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:26.946] Chunk #1 of 1 ... DONE
[17:38:26.946] Launching 1 futures (chunks) ... DONE
[17:38:26.946] Resolving 1 futures (chunks) ...
[17:38:26.946] resolve() on list ...
[17:38:26.946]  recursive: 0
[17:38:26.946]  length: 1
[17:38:26.948] 
[17:38:26.948] resolved() for ‘SequentialFuture’ ...
[17:38:26.948] - state: ‘finished’
[17:38:26.949] - run: TRUE
[17:38:26.949] - result: ‘FutureResult’
[17:38:26.949] resolved() for ‘SequentialFuture’ ... done
[17:38:26.949] Future #1
[17:38:26.949] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:26.949] - nx: 1
[17:38:26.949] - relay: TRUE
[17:38:26.949] - stdout: TRUE
[17:38:26.949] - signal: TRUE
[17:38:26.949] - resignal: FALSE
[17:38:26.949] - force: TRUE
[17:38:26.950] - relayed: [n=1] FALSE
[17:38:26.950] - queued futures: [n=1] FALSE
[17:38:26.950]  - until=1
[17:38:26.950]  - relaying element #1
[17:38:26.950] - relayed: [n=1] TRUE
[17:38:26.950] - queued futures: [n=1] TRUE
[17:38:26.950] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:26.950]  length: 0 (resolved future 1)
[17:38:26.950] Relaying remaining futures
[17:38:26.951] signalConditionsASAP(NULL, pos=0) ...
[17:38:26.951] - nx: 1
[17:38:26.951] - relay: TRUE
[17:38:26.951] - stdout: TRUE
[17:38:26.951] - signal: TRUE
[17:38:26.951] - resignal: FALSE
[17:38:26.951] - force: TRUE
[17:38:26.951] - relayed: [n=1] TRUE
[17:38:26.951] - queued futures: [n=1] TRUE
 - flush all
[17:38:26.951] - relayed: [n=1] TRUE
[17:38:26.951] - queued futures: [n=1] TRUE
[17:38:26.951] signalConditionsASAP(NULL, pos=0) ... done
[17:38:26.952] resolve() on list ... DONE
[17:38:26.952]  - Number of value chunks collected: 1
[17:38:26.952] Resolving 1 futures (chunks) ... DONE
[17:38:26.952] Reducing values from 1 chunks ...
[17:38:26.952]  - Number of values collected after concatenation: 2
[17:38:26.952]  - Number of values expected: 2
[17:38:26.952] Reducing values from 1 chunks ... DONE
[17:38:26.952] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[17:38:26.953] future_mapply() ...
[17:38:26.956] Number of chunks: 1
[17:38:26.956] getGlobalsAndPackagesXApply() ...
[17:38:26.956]  - future.globals: TRUE
[17:38:26.956] getGlobalsAndPackages() ...
[17:38:26.956] Searching for globals...
[17:38:26.958] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:38:26.958] Searching for globals ... DONE
[17:38:26.958] Resolving globals: FALSE
[17:38:26.959] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:38:26.959] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:38:26.959] - globals: [1] ‘FUN’
[17:38:26.959] 
[17:38:26.959] getGlobalsAndPackages() ... DONE
[17:38:26.959]  - globals found/used: [n=1] ‘FUN’
[17:38:26.959]  - needed namespaces: [n=0] 
[17:38:26.959] Finding globals ... DONE
[17:38:26.960] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:38:26.960] List of 2
[17:38:26.960]  $ ...future.FUN:function (x, y)  
[17:38:26.960]  $ MoreArgs     : NULL
[17:38:26.960]  - attr(*, "where")=List of 2
[17:38:26.960]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:26.960]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:38:26.960]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:26.960]  - attr(*, "resolved")= logi FALSE
[17:38:26.960]  - attr(*, "total_size")= num NA
[17:38:26.962] Packages to be attached in all futures: [n=0] 
[17:38:26.962] getGlobalsAndPackagesXApply() ... DONE
[17:38:26.963] Number of futures (= number of chunks): 1
[17:38:26.963] Launching 1 futures (chunks) ...
[17:38:26.963] Chunk #1 of 1 ...
[17:38:26.963]  - Finding globals in '...' for chunk #1 ...
[17:38:26.963] getGlobalsAndPackages() ...
[17:38:26.963] Searching for globals...
[17:38:26.963] 
[17:38:26.963] Searching for globals ... DONE
[17:38:26.964] - globals: [0] <none>
[17:38:26.964] getGlobalsAndPackages() ... DONE
[17:38:26.964]    + additional globals found: [n=0] 
[17:38:26.964]    + additional namespaces needed: [n=0] 
[17:38:26.964]  - Finding globals in '...' for chunk #1 ... DONE
[17:38:26.964]  - seeds: <none>
[17:38:26.964]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:26.964] getGlobalsAndPackages() ...
[17:38:26.964] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:26.964] Resolving globals: FALSE
[17:38:26.965] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:38:26.965] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:38:26.965] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:26.966] 
[17:38:26.966] getGlobalsAndPackages() ... DONE
[17:38:26.966] run() for ‘Future’ ...
[17:38:26.966] - state: ‘created’
[17:38:26.966] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:26.970] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:26.970] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:26.970]   - Field: ‘label’
[17:38:26.970]   - Field: ‘local’
[17:38:26.970]   - Field: ‘owner’
[17:38:26.970]   - Field: ‘envir’
[17:38:26.970]   - Field: ‘packages’
[17:38:26.970]   - Field: ‘gc’
[17:38:26.970]   - Field: ‘conditions’
[17:38:26.970]   - Field: ‘expr’
[17:38:26.971]   - Field: ‘uuid’
[17:38:26.971]   - Field: ‘seed’
[17:38:26.971]   - Field: ‘version’
[17:38:26.971]   - Field: ‘result’
[17:38:26.971]   - Field: ‘asynchronous’
[17:38:26.971]   - Field: ‘calls’
[17:38:26.971]   - Field: ‘globals’
[17:38:26.971]   - Field: ‘stdout’
[17:38:26.971]   - Field: ‘earlySignal’
[17:38:26.971]   - Field: ‘lazy’
[17:38:26.971]   - Field: ‘state’
[17:38:26.972] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:26.972] - Launch lazy future ...
[17:38:26.972] Packages needed by the future expression (n = 0): <none>
[17:38:26.972] Packages needed by future strategies (n = 0): <none>
[17:38:26.972] {
[17:38:26.972]     {
[17:38:26.972]         {
[17:38:26.972]             ...future.startTime <- base::Sys.time()
[17:38:26.972]             {
[17:38:26.972]                 {
[17:38:26.972]                   {
[17:38:26.972]                     base::local({
[17:38:26.972]                       has_future <- base::requireNamespace("future", 
[17:38:26.972]                         quietly = TRUE)
[17:38:26.972]                       if (has_future) {
[17:38:26.972]                         ns <- base::getNamespace("future")
[17:38:26.972]                         version <- ns[[".package"]][["version"]]
[17:38:26.972]                         if (is.null(version)) 
[17:38:26.972]                           version <- utils::packageVersion("future")
[17:38:26.972]                       }
[17:38:26.972]                       else {
[17:38:26.972]                         version <- NULL
[17:38:26.972]                       }
[17:38:26.972]                       if (!has_future || version < "1.8.0") {
[17:38:26.972]                         info <- base::c(r_version = base::gsub("R version ", 
[17:38:26.972]                           "", base::R.version$version.string), 
[17:38:26.972]                           platform = base::sprintf("%s (%s-bit)", 
[17:38:26.972]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:26.972]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:26.972]                             "release", "version")], collapse = " "), 
[17:38:26.972]                           hostname = base::Sys.info()[["nodename"]])
[17:38:26.972]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:38:26.972]                           info)
[17:38:26.972]                         info <- base::paste(info, collapse = "; ")
[17:38:26.972]                         if (!has_future) {
[17:38:26.972]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:26.972]                             info)
[17:38:26.972]                         }
[17:38:26.972]                         else {
[17:38:26.972]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:26.972]                             info, version)
[17:38:26.972]                         }
[17:38:26.972]                         base::stop(msg)
[17:38:26.972]                       }
[17:38:26.972]                     })
[17:38:26.972]                   }
[17:38:26.972]                   ...future.strategy.old <- future::plan("list")
[17:38:26.972]                   options(future.plan = NULL)
[17:38:26.972]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:26.972]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:26.972]                 }
[17:38:26.972]                 ...future.workdir <- getwd()
[17:38:26.972]             }
[17:38:26.972]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:26.972]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:26.972]         }
[17:38:26.972]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:26.972]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:26.972]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:26.972]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:26.972]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:26.972]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:26.972]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:26.972]             base::names(...future.oldOptions))
[17:38:26.972]     }
[17:38:26.972]     if (TRUE) {
[17:38:26.972]     }
[17:38:26.972]     else {
[17:38:26.972]         if (NA) {
[17:38:26.972]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:26.972]                 open = "w")
[17:38:26.972]         }
[17:38:26.972]         else {
[17:38:26.972]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:26.972]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:26.972]         }
[17:38:26.972]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:26.972]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:26.972]             base::sink(type = "output", split = FALSE)
[17:38:26.972]             base::close(...future.stdout)
[17:38:26.972]         }, add = TRUE)
[17:38:26.972]     }
[17:38:26.972]     ...future.frame <- base::sys.nframe()
[17:38:26.972]     ...future.conditions <- base::list()
[17:38:26.972]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:26.972]     if (FALSE) {
[17:38:26.972]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:26.972]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:26.972]     }
[17:38:26.972]     ...future.result <- base::tryCatch({
[17:38:26.972]         base::withCallingHandlers({
[17:38:26.972]             ...future.value <- base::withVisible(base::local({
[17:38:26.972]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:26.972]                 if (!identical(...future.globals.maxSize.org, 
[17:38:26.972]                   ...future.globals.maxSize)) {
[17:38:26.972]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:26.972]                   on.exit(options(oopts), add = TRUE)
[17:38:26.972]                 }
[17:38:26.972]                 {
[17:38:26.972]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:26.972]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:38:26.972]                     USE.NAMES = FALSE)
[17:38:26.972]                   do.call(mapply, args = args)
[17:38:26.972]                 }
[17:38:26.972]             }))
[17:38:26.972]             future::FutureResult(value = ...future.value$value, 
[17:38:26.972]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:26.972]                   ...future.rng), globalenv = if (FALSE) 
[17:38:26.972]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:26.972]                     ...future.globalenv.names))
[17:38:26.972]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:26.972]         }, condition = base::local({
[17:38:26.972]             c <- base::c
[17:38:26.972]             inherits <- base::inherits
[17:38:26.972]             invokeRestart <- base::invokeRestart
[17:38:26.972]             length <- base::length
[17:38:26.972]             list <- base::list
[17:38:26.972]             seq.int <- base::seq.int
[17:38:26.972]             signalCondition <- base::signalCondition
[17:38:26.972]             sys.calls <- base::sys.calls
[17:38:26.972]             `[[` <- base::`[[`
[17:38:26.972]             `+` <- base::`+`
[17:38:26.972]             `<<-` <- base::`<<-`
[17:38:26.972]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:26.972]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:26.972]                   3L)]
[17:38:26.972]             }
[17:38:26.972]             function(cond) {
[17:38:26.972]                 is_error <- inherits(cond, "error")
[17:38:26.972]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:26.972]                   NULL)
[17:38:26.972]                 if (is_error) {
[17:38:26.972]                   sessionInformation <- function() {
[17:38:26.972]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:26.972]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:26.972]                       search = base::search(), system = base::Sys.info())
[17:38:26.972]                   }
[17:38:26.972]                   ...future.conditions[[length(...future.conditions) + 
[17:38:26.972]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:26.972]                     cond$call), session = sessionInformation(), 
[17:38:26.972]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:26.972]                   signalCondition(cond)
[17:38:26.972]                 }
[17:38:26.972]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:26.972]                 "immediateCondition"))) {
[17:38:26.972]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:26.972]                   ...future.conditions[[length(...future.conditions) + 
[17:38:26.972]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:26.972]                   if (TRUE && !signal) {
[17:38:26.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:26.972]                     {
[17:38:26.972]                       inherits <- base::inherits
[17:38:26.972]                       invokeRestart <- base::invokeRestart
[17:38:26.972]                       is.null <- base::is.null
[17:38:26.972]                       muffled <- FALSE
[17:38:26.972]                       if (inherits(cond, "message")) {
[17:38:26.972]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:26.972]                         if (muffled) 
[17:38:26.972]                           invokeRestart("muffleMessage")
[17:38:26.972]                       }
[17:38:26.972]                       else if (inherits(cond, "warning")) {
[17:38:26.972]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:26.972]                         if (muffled) 
[17:38:26.972]                           invokeRestart("muffleWarning")
[17:38:26.972]                       }
[17:38:26.972]                       else if (inherits(cond, "condition")) {
[17:38:26.972]                         if (!is.null(pattern)) {
[17:38:26.972]                           computeRestarts <- base::computeRestarts
[17:38:26.972]                           grepl <- base::grepl
[17:38:26.972]                           restarts <- computeRestarts(cond)
[17:38:26.972]                           for (restart in restarts) {
[17:38:26.972]                             name <- restart$name
[17:38:26.972]                             if (is.null(name)) 
[17:38:26.972]                               next
[17:38:26.972]                             if (!grepl(pattern, name)) 
[17:38:26.972]                               next
[17:38:26.972]                             invokeRestart(restart)
[17:38:26.972]                             muffled <- TRUE
[17:38:26.972]                             break
[17:38:26.972]                           }
[17:38:26.972]                         }
[17:38:26.972]                       }
[17:38:26.972]                       invisible(muffled)
[17:38:26.972]                     }
[17:38:26.972]                     muffleCondition(cond, pattern = "^muffle")
[17:38:26.972]                   }
[17:38:26.972]                 }
[17:38:26.972]                 else {
[17:38:26.972]                   if (TRUE) {
[17:38:26.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:26.972]                     {
[17:38:26.972]                       inherits <- base::inherits
[17:38:26.972]                       invokeRestart <- base::invokeRestart
[17:38:26.972]                       is.null <- base::is.null
[17:38:26.972]                       muffled <- FALSE
[17:38:26.972]                       if (inherits(cond, "message")) {
[17:38:26.972]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:26.972]                         if (muffled) 
[17:38:26.972]                           invokeRestart("muffleMessage")
[17:38:26.972]                       }
[17:38:26.972]                       else if (inherits(cond, "warning")) {
[17:38:26.972]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:26.972]                         if (muffled) 
[17:38:26.972]                           invokeRestart("muffleWarning")
[17:38:26.972]                       }
[17:38:26.972]                       else if (inherits(cond, "condition")) {
[17:38:26.972]                         if (!is.null(pattern)) {
[17:38:26.972]                           computeRestarts <- base::computeRestarts
[17:38:26.972]                           grepl <- base::grepl
[17:38:26.972]                           restarts <- computeRestarts(cond)
[17:38:26.972]                           for (restart in restarts) {
[17:38:26.972]                             name <- restart$name
[17:38:26.972]                             if (is.null(name)) 
[17:38:26.972]                               next
[17:38:26.972]                             if (!grepl(pattern, name)) 
[17:38:26.972]                               next
[17:38:26.972]                             invokeRestart(restart)
[17:38:26.972]                             muffled <- TRUE
[17:38:26.972]                             break
[17:38:26.972]                           }
[17:38:26.972]                         }
[17:38:26.972]                       }
[17:38:26.972]                       invisible(muffled)
[17:38:26.972]                     }
[17:38:26.972]                     muffleCondition(cond, pattern = "^muffle")
[17:38:26.972]                   }
[17:38:26.972]                 }
[17:38:26.972]             }
[17:38:26.972]         }))
[17:38:26.972]     }, error = function(ex) {
[17:38:26.972]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:26.972]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:26.972]                 ...future.rng), started = ...future.startTime, 
[17:38:26.972]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:26.972]             version = "1.8"), class = "FutureResult")
[17:38:26.972]     }, finally = {
[17:38:26.972]         if (!identical(...future.workdir, getwd())) 
[17:38:26.972]             setwd(...future.workdir)
[17:38:26.972]         {
[17:38:26.972]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:26.972]                 ...future.oldOptions$nwarnings <- NULL
[17:38:26.972]             }
[17:38:26.972]             base::options(...future.oldOptions)
[17:38:26.972]             if (.Platform$OS.type == "windows") {
[17:38:26.972]                 old_names <- names(...future.oldEnvVars)
[17:38:26.972]                 envs <- base::Sys.getenv()
[17:38:26.972]                 names <- names(envs)
[17:38:26.972]                 common <- intersect(names, old_names)
[17:38:26.972]                 added <- setdiff(names, old_names)
[17:38:26.972]                 removed <- setdiff(old_names, names)
[17:38:26.972]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:26.972]                   envs[common]]
[17:38:26.972]                 NAMES <- toupper(changed)
[17:38:26.972]                 args <- list()
[17:38:26.972]                 for (kk in seq_along(NAMES)) {
[17:38:26.972]                   name <- changed[[kk]]
[17:38:26.972]                   NAME <- NAMES[[kk]]
[17:38:26.972]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:26.972]                     next
[17:38:26.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:26.972]                 }
[17:38:26.972]                 NAMES <- toupper(added)
[17:38:26.972]                 for (kk in seq_along(NAMES)) {
[17:38:26.972]                   name <- added[[kk]]
[17:38:26.972]                   NAME <- NAMES[[kk]]
[17:38:26.972]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:26.972]                     next
[17:38:26.972]                   args[[name]] <- ""
[17:38:26.972]                 }
[17:38:26.972]                 NAMES <- toupper(removed)
[17:38:26.972]                 for (kk in seq_along(NAMES)) {
[17:38:26.972]                   name <- removed[[kk]]
[17:38:26.972]                   NAME <- NAMES[[kk]]
[17:38:26.972]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:26.972]                     next
[17:38:26.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:26.972]                 }
[17:38:26.972]                 if (length(args) > 0) 
[17:38:26.972]                   base::do.call(base::Sys.setenv, args = args)
[17:38:26.972]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:26.972]             }
[17:38:26.972]             else {
[17:38:26.972]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:26.972]             }
[17:38:26.972]             {
[17:38:26.972]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:26.972]                   0L) {
[17:38:26.972]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:26.972]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:26.972]                   base::options(opts)
[17:38:26.972]                 }
[17:38:26.972]                 {
[17:38:26.972]                   {
[17:38:26.972]                     NULL
[17:38:26.972]                     RNGkind("Mersenne-Twister")
[17:38:26.972]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:26.972]                       inherits = FALSE)
[17:38:26.972]                   }
[17:38:26.972]                   options(future.plan = NULL)
[17:38:26.972]                   if (is.na(NA_character_)) 
[17:38:26.972]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:26.972]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:26.972]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:26.972]                     .init = FALSE)
[17:38:26.972]                 }
[17:38:26.972]             }
[17:38:26.972]         }
[17:38:26.972]     })
[17:38:26.972]     if (FALSE) {
[17:38:26.972]         base::sink(type = "output", split = FALSE)
[17:38:26.972]         if (NA) {
[17:38:26.972]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:26.972]         }
[17:38:26.972]         else {
[17:38:26.972]             ...future.result["stdout"] <- base::list(NULL)
[17:38:26.972]         }
[17:38:26.972]         base::close(...future.stdout)
[17:38:26.972]         ...future.stdout <- NULL
[17:38:26.972]     }
[17:38:26.972]     ...future.result$conditions <- ...future.conditions
[17:38:26.972]     ...future.result$finished <- base::Sys.time()
[17:38:26.972]     ...future.result
[17:38:26.972] }
[17:38:26.974] assign_globals() ...
[17:38:26.974] List of 5
[17:38:26.974]  $ ...future.FUN            :function (x, y)  
[17:38:26.974]  $ MoreArgs                 : NULL
[17:38:26.974]  $ ...future.elements_ii    :List of 2
[17:38:26.974]   ..$ :List of 2
[17:38:26.974]   .. ..$ : int 1
[17:38:26.974]   .. ..$ : int 0
[17:38:26.974]   ..$ :List of 2
[17:38:26.974]   .. ..$ : int 0
[17:38:26.974]   .. ..$ : int 1
[17:38:26.974]  $ ...future.seeds_ii       : NULL
[17:38:26.974]  $ ...future.globals.maxSize: NULL
[17:38:26.974]  - attr(*, "where")=List of 5
[17:38:26.974]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:26.974]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:38:26.974]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:26.974]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:26.974]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:26.974]  - attr(*, "resolved")= logi FALSE
[17:38:26.974]  - attr(*, "total_size")= num 6480
[17:38:26.974]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:26.974]  - attr(*, "already-done")= logi TRUE
[17:38:26.981] - reassign environment for ‘...future.FUN’
[17:38:26.981] - copied ‘...future.FUN’ to environment
[17:38:26.982] - copied ‘MoreArgs’ to environment
[17:38:26.982] - copied ‘...future.elements_ii’ to environment
[17:38:26.982] - copied ‘...future.seeds_ii’ to environment
[17:38:26.982] - copied ‘...future.globals.maxSize’ to environment
[17:38:26.982] assign_globals() ... done
[17:38:26.982] plan(): Setting new future strategy stack:
[17:38:26.982] List of future strategies:
[17:38:26.982] 1. sequential:
[17:38:26.982]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:26.982]    - tweaked: FALSE
[17:38:26.982]    - call: NULL
[17:38:26.983] plan(): nbrOfWorkers() = 1
[17:38:27.484] plan(): Setting new future strategy stack:
[17:38:27.484] List of future strategies:
[17:38:27.484] 1. multicore:
[17:38:27.484]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:27.484]    - tweaked: FALSE
[17:38:27.484]    - call: plan(strategy)
[17:38:27.489] plan(): nbrOfWorkers() = 1
[17:38:27.489] SequentialFuture started (and completed)
[17:38:27.489] - Launch lazy future ... done
[17:38:27.489] run() for ‘SequentialFuture’ ... done
[17:38:27.489] Created future:
[17:38:27.489] SequentialFuture:
[17:38:27.489] Label: ‘future_mapply-1’
[17:38:27.489] Expression:
[17:38:27.489] {
[17:38:27.489]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:27.489]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:27.489]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:27.489]         on.exit(options(oopts), add = TRUE)
[17:38:27.489]     }
[17:38:27.489]     {
[17:38:27.489]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:27.489]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:38:27.489]         do.call(mapply, args = args)
[17:38:27.489]     }
[17:38:27.489] }
[17:38:27.489] Lazy evaluation: FALSE
[17:38:27.489] Asynchronous evaluation: FALSE
[17:38:27.489] Local evaluation: TRUE
[17:38:27.489] Environment: R_GlobalEnv
[17:38:27.489] Capture standard output: NA
[17:38:27.489] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:27.489] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:27.489] Packages: <none>
[17:38:27.489] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:27.489] Resolved: TRUE
[17:38:27.489] Value: 224 bytes of class ‘list’
[17:38:27.489] Early signaling: FALSE
[17:38:27.489] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:27.489] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:27.490] Chunk #1 of 1 ... DONE
[17:38:27.490] Launching 1 futures (chunks) ... DONE
[17:38:27.490] Resolving 1 futures (chunks) ...
[17:38:27.490] resolve() on list ...
[17:38:27.491]  recursive: 0
[17:38:27.491]  length: 1
[17:38:27.491] 
[17:38:27.491] resolved() for ‘SequentialFuture’ ...
[17:38:27.491] - state: ‘finished’
[17:38:27.491] - run: TRUE
[17:38:27.491] - result: ‘FutureResult’
[17:38:27.491] resolved() for ‘SequentialFuture’ ... done
[17:38:27.491] Future #1
[17:38:27.491] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:27.492] - nx: 1
[17:38:27.492] - relay: TRUE
[17:38:27.492] - stdout: TRUE
[17:38:27.492] - signal: TRUE
[17:38:27.492] - resignal: FALSE
[17:38:27.492] - force: TRUE
[17:38:27.492] - relayed: [n=1] FALSE
[17:38:27.492] - queued futures: [n=1] FALSE
[17:38:27.492]  - until=1
[17:38:27.492]  - relaying element #1
[17:38:27.493] - relayed: [n=1] TRUE
[17:38:27.493] - queued futures: [n=1] TRUE
[17:38:27.493] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:27.493]  length: 0 (resolved future 1)
[17:38:27.493] Relaying remaining futures
[17:38:27.493] signalConditionsASAP(NULL, pos=0) ...
[17:38:27.493] - nx: 1
[17:38:27.493] - relay: TRUE
[17:38:27.493] - stdout: TRUE
[17:38:27.493] - signal: TRUE
[17:38:27.493] - resignal: FALSE
[17:38:27.493] - force: TRUE
[17:38:27.494] - relayed: [n=1] TRUE
[17:38:27.494] - queued futures: [n=1] TRUE
 - flush all
[17:38:27.494] - relayed: [n=1] TRUE
[17:38:27.494] - queued futures: [n=1] TRUE
[17:38:27.494] signalConditionsASAP(NULL, pos=0) ... done
[17:38:27.494] resolve() on list ... DONE
[17:38:27.494]  - Number of value chunks collected: 1
[17:38:27.494] Resolving 1 futures (chunks) ... DONE
[17:38:27.494] Reducing values from 1 chunks ...
[17:38:27.494]  - Number of values collected after concatenation: 2
[17:38:27.495]  - Number of values expected: 2
[17:38:27.495] Reducing values from 1 chunks ... DONE
[17:38:27.495] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[17:38:27.495] plan(): Setting new future strategy stack:
[17:38:27.495] List of future strategies:
[17:38:27.495] 1. multisession:
[17:38:27.495]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:38:27.495]    - tweaked: FALSE
[17:38:27.495]    - call: plan(strategy)
[17:38:27.496] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:38:27.496] multisession:
[17:38:27.496] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:38:27.496] - tweaked: FALSE
[17:38:27.496] - call: plan(strategy)
[17:38:27.499] getGlobalsAndPackages() ...
[17:38:27.499] Not searching for globals
[17:38:27.500] - globals: [0] <none>
[17:38:27.500] getGlobalsAndPackages() ... DONE
[17:38:27.500] Packages needed by the future expression (n = 0): <none>
[17:38:27.500] Packages needed by future strategies (n = 0): <none>
[17:38:27.501] {
[17:38:27.501]     {
[17:38:27.501]         {
[17:38:27.501]             ...future.startTime <- base::Sys.time()
[17:38:27.501]             {
[17:38:27.501]                 {
[17:38:27.501]                   {
[17:38:27.501]                     base::local({
[17:38:27.501]                       has_future <- base::requireNamespace("future", 
[17:38:27.501]                         quietly = TRUE)
[17:38:27.501]                       if (has_future) {
[17:38:27.501]                         ns <- base::getNamespace("future")
[17:38:27.501]                         version <- ns[[".package"]][["version"]]
[17:38:27.501]                         if (is.null(version)) 
[17:38:27.501]                           version <- utils::packageVersion("future")
[17:38:27.501]                       }
[17:38:27.501]                       else {
[17:38:27.501]                         version <- NULL
[17:38:27.501]                       }
[17:38:27.501]                       if (!has_future || version < "1.8.0") {
[17:38:27.501]                         info <- base::c(r_version = base::gsub("R version ", 
[17:38:27.501]                           "", base::R.version$version.string), 
[17:38:27.501]                           platform = base::sprintf("%s (%s-bit)", 
[17:38:27.501]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:27.501]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:27.501]                             "release", "version")], collapse = " "), 
[17:38:27.501]                           hostname = base::Sys.info()[["nodename"]])
[17:38:27.501]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:38:27.501]                           info)
[17:38:27.501]                         info <- base::paste(info, collapse = "; ")
[17:38:27.501]                         if (!has_future) {
[17:38:27.501]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:27.501]                             info)
[17:38:27.501]                         }
[17:38:27.501]                         else {
[17:38:27.501]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:27.501]                             info, version)
[17:38:27.501]                         }
[17:38:27.501]                         base::stop(msg)
[17:38:27.501]                       }
[17:38:27.501]                     })
[17:38:27.501]                   }
[17:38:27.501]                   ...future.strategy.old <- future::plan("list")
[17:38:27.501]                   options(future.plan = NULL)
[17:38:27.501]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:27.501]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:27.501]                 }
[17:38:27.501]                 ...future.workdir <- getwd()
[17:38:27.501]             }
[17:38:27.501]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:27.501]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:27.501]         }
[17:38:27.501]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:27.501]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:27.501]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:27.501]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:27.501]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:27.501]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:27.501]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:27.501]             base::names(...future.oldOptions))
[17:38:27.501]     }
[17:38:27.501]     if (FALSE) {
[17:38:27.501]     }
[17:38:27.501]     else {
[17:38:27.501]         if (TRUE) {
[17:38:27.501]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:27.501]                 open = "w")
[17:38:27.501]         }
[17:38:27.501]         else {
[17:38:27.501]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:27.501]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:27.501]         }
[17:38:27.501]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:27.501]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:27.501]             base::sink(type = "output", split = FALSE)
[17:38:27.501]             base::close(...future.stdout)
[17:38:27.501]         }, add = TRUE)
[17:38:27.501]     }
[17:38:27.501]     ...future.frame <- base::sys.nframe()
[17:38:27.501]     ...future.conditions <- base::list()
[17:38:27.501]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:27.501]     if (FALSE) {
[17:38:27.501]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:27.501]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:27.501]     }
[17:38:27.501]     ...future.result <- base::tryCatch({
[17:38:27.501]         base::withCallingHandlers({
[17:38:27.501]             ...future.value <- base::withVisible(base::local(NA))
[17:38:27.501]             future::FutureResult(value = ...future.value$value, 
[17:38:27.501]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:27.501]                   ...future.rng), globalenv = if (FALSE) 
[17:38:27.501]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:27.501]                     ...future.globalenv.names))
[17:38:27.501]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:27.501]         }, condition = base::local({
[17:38:27.501]             c <- base::c
[17:38:27.501]             inherits <- base::inherits
[17:38:27.501]             invokeRestart <- base::invokeRestart
[17:38:27.501]             length <- base::length
[17:38:27.501]             list <- base::list
[17:38:27.501]             seq.int <- base::seq.int
[17:38:27.501]             signalCondition <- base::signalCondition
[17:38:27.501]             sys.calls <- base::sys.calls
[17:38:27.501]             `[[` <- base::`[[`
[17:38:27.501]             `+` <- base::`+`
[17:38:27.501]             `<<-` <- base::`<<-`
[17:38:27.501]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:27.501]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:27.501]                   3L)]
[17:38:27.501]             }
[17:38:27.501]             function(cond) {
[17:38:27.501]                 is_error <- inherits(cond, "error")
[17:38:27.501]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:27.501]                   NULL)
[17:38:27.501]                 if (is_error) {
[17:38:27.501]                   sessionInformation <- function() {
[17:38:27.501]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:27.501]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:27.501]                       search = base::search(), system = base::Sys.info())
[17:38:27.501]                   }
[17:38:27.501]                   ...future.conditions[[length(...future.conditions) + 
[17:38:27.501]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:27.501]                     cond$call), session = sessionInformation(), 
[17:38:27.501]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:27.501]                   signalCondition(cond)
[17:38:27.501]                 }
[17:38:27.501]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:27.501]                 "immediateCondition"))) {
[17:38:27.501]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:27.501]                   ...future.conditions[[length(...future.conditions) + 
[17:38:27.501]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:27.501]                   if (TRUE && !signal) {
[17:38:27.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:27.501]                     {
[17:38:27.501]                       inherits <- base::inherits
[17:38:27.501]                       invokeRestart <- base::invokeRestart
[17:38:27.501]                       is.null <- base::is.null
[17:38:27.501]                       muffled <- FALSE
[17:38:27.501]                       if (inherits(cond, "message")) {
[17:38:27.501]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:27.501]                         if (muffled) 
[17:38:27.501]                           invokeRestart("muffleMessage")
[17:38:27.501]                       }
[17:38:27.501]                       else if (inherits(cond, "warning")) {
[17:38:27.501]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:27.501]                         if (muffled) 
[17:38:27.501]                           invokeRestart("muffleWarning")
[17:38:27.501]                       }
[17:38:27.501]                       else if (inherits(cond, "condition")) {
[17:38:27.501]                         if (!is.null(pattern)) {
[17:38:27.501]                           computeRestarts <- base::computeRestarts
[17:38:27.501]                           grepl <- base::grepl
[17:38:27.501]                           restarts <- computeRestarts(cond)
[17:38:27.501]                           for (restart in restarts) {
[17:38:27.501]                             name <- restart$name
[17:38:27.501]                             if (is.null(name)) 
[17:38:27.501]                               next
[17:38:27.501]                             if (!grepl(pattern, name)) 
[17:38:27.501]                               next
[17:38:27.501]                             invokeRestart(restart)
[17:38:27.501]                             muffled <- TRUE
[17:38:27.501]                             break
[17:38:27.501]                           }
[17:38:27.501]                         }
[17:38:27.501]                       }
[17:38:27.501]                       invisible(muffled)
[17:38:27.501]                     }
[17:38:27.501]                     muffleCondition(cond, pattern = "^muffle")
[17:38:27.501]                   }
[17:38:27.501]                 }
[17:38:27.501]                 else {
[17:38:27.501]                   if (TRUE) {
[17:38:27.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:27.501]                     {
[17:38:27.501]                       inherits <- base::inherits
[17:38:27.501]                       invokeRestart <- base::invokeRestart
[17:38:27.501]                       is.null <- base::is.null
[17:38:27.501]                       muffled <- FALSE
[17:38:27.501]                       if (inherits(cond, "message")) {
[17:38:27.501]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:27.501]                         if (muffled) 
[17:38:27.501]                           invokeRestart("muffleMessage")
[17:38:27.501]                       }
[17:38:27.501]                       else if (inherits(cond, "warning")) {
[17:38:27.501]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:27.501]                         if (muffled) 
[17:38:27.501]                           invokeRestart("muffleWarning")
[17:38:27.501]                       }
[17:38:27.501]                       else if (inherits(cond, "condition")) {
[17:38:27.501]                         if (!is.null(pattern)) {
[17:38:27.501]                           computeRestarts <- base::computeRestarts
[17:38:27.501]                           grepl <- base::grepl
[17:38:27.501]                           restarts <- computeRestarts(cond)
[17:38:27.501]                           for (restart in restarts) {
[17:38:27.501]                             name <- restart$name
[17:38:27.501]                             if (is.null(name)) 
[17:38:27.501]                               next
[17:38:27.501]                             if (!grepl(pattern, name)) 
[17:38:27.501]                               next
[17:38:27.501]                             invokeRestart(restart)
[17:38:27.501]                             muffled <- TRUE
[17:38:27.501]                             break
[17:38:27.501]                           }
[17:38:27.501]                         }
[17:38:27.501]                       }
[17:38:27.501]                       invisible(muffled)
[17:38:27.501]                     }
[17:38:27.501]                     muffleCondition(cond, pattern = "^muffle")
[17:38:27.501]                   }
[17:38:27.501]                 }
[17:38:27.501]             }
[17:38:27.501]         }))
[17:38:27.501]     }, error = function(ex) {
[17:38:27.501]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:27.501]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:27.501]                 ...future.rng), started = ...future.startTime, 
[17:38:27.501]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:27.501]             version = "1.8"), class = "FutureResult")
[17:38:27.501]     }, finally = {
[17:38:27.501]         if (!identical(...future.workdir, getwd())) 
[17:38:27.501]             setwd(...future.workdir)
[17:38:27.501]         {
[17:38:27.501]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:27.501]                 ...future.oldOptions$nwarnings <- NULL
[17:38:27.501]             }
[17:38:27.501]             base::options(...future.oldOptions)
[17:38:27.501]             if (.Platform$OS.type == "windows") {
[17:38:27.501]                 old_names <- names(...future.oldEnvVars)
[17:38:27.501]                 envs <- base::Sys.getenv()
[17:38:27.501]                 names <- names(envs)
[17:38:27.501]                 common <- intersect(names, old_names)
[17:38:27.501]                 added <- setdiff(names, old_names)
[17:38:27.501]                 removed <- setdiff(old_names, names)
[17:38:27.501]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:27.501]                   envs[common]]
[17:38:27.501]                 NAMES <- toupper(changed)
[17:38:27.501]                 args <- list()
[17:38:27.501]                 for (kk in seq_along(NAMES)) {
[17:38:27.501]                   name <- changed[[kk]]
[17:38:27.501]                   NAME <- NAMES[[kk]]
[17:38:27.501]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:27.501]                     next
[17:38:27.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:27.501]                 }
[17:38:27.501]                 NAMES <- toupper(added)
[17:38:27.501]                 for (kk in seq_along(NAMES)) {
[17:38:27.501]                   name <- added[[kk]]
[17:38:27.501]                   NAME <- NAMES[[kk]]
[17:38:27.501]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:27.501]                     next
[17:38:27.501]                   args[[name]] <- ""
[17:38:27.501]                 }
[17:38:27.501]                 NAMES <- toupper(removed)
[17:38:27.501]                 for (kk in seq_along(NAMES)) {
[17:38:27.501]                   name <- removed[[kk]]
[17:38:27.501]                   NAME <- NAMES[[kk]]
[17:38:27.501]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:27.501]                     next
[17:38:27.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:27.501]                 }
[17:38:27.501]                 if (length(args) > 0) 
[17:38:27.501]                   base::do.call(base::Sys.setenv, args = args)
[17:38:27.501]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:27.501]             }
[17:38:27.501]             else {
[17:38:27.501]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:27.501]             }
[17:38:27.501]             {
[17:38:27.501]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:27.501]                   0L) {
[17:38:27.501]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:27.501]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:27.501]                   base::options(opts)
[17:38:27.501]                 }
[17:38:27.501]                 {
[17:38:27.501]                   {
[17:38:27.501]                     NULL
[17:38:27.501]                     RNGkind("Mersenne-Twister")
[17:38:27.501]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:27.501]                       inherits = FALSE)
[17:38:27.501]                   }
[17:38:27.501]                   options(future.plan = NULL)
[17:38:27.501]                   if (is.na(NA_character_)) 
[17:38:27.501]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:27.501]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:27.501]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:27.501]                     .init = FALSE)
[17:38:27.501]                 }
[17:38:27.501]             }
[17:38:27.501]         }
[17:38:27.501]     })
[17:38:27.501]     if (TRUE) {
[17:38:27.501]         base::sink(type = "output", split = FALSE)
[17:38:27.501]         if (TRUE) {
[17:38:27.501]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:27.501]         }
[17:38:27.501]         else {
[17:38:27.501]             ...future.result["stdout"] <- base::list(NULL)
[17:38:27.501]         }
[17:38:27.501]         base::close(...future.stdout)
[17:38:27.501]         ...future.stdout <- NULL
[17:38:27.501]     }
[17:38:27.501]     ...future.result$conditions <- ...future.conditions
[17:38:27.501]     ...future.result$finished <- base::Sys.time()
[17:38:27.501]     ...future.result
[17:38:27.501] }
[17:38:27.502] plan(): Setting new future strategy stack:
[17:38:27.503] List of future strategies:
[17:38:27.503] 1. sequential:
[17:38:27.503]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:27.503]    - tweaked: FALSE
[17:38:27.503]    - call: NULL
[17:38:27.503] plan(): nbrOfWorkers() = 1
[17:38:27.504] plan(): Setting new future strategy stack:
[17:38:27.504] List of future strategies:
[17:38:27.504] 1. multisession:
[17:38:27.504]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:38:27.504]    - tweaked: FALSE
[17:38:27.504]    - call: plan(strategy)
[17:38:27.507] plan(): nbrOfWorkers() = 1
[17:38:27.507] SequentialFuture started (and completed)
[17:38:27.508] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:38:27.511] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[17:38:27.511] future_lapply() ...
[17:38:27.515] Number of chunks: 1
[17:38:27.515] getGlobalsAndPackagesXApply() ...
[17:38:27.515]  - future.globals: TRUE
[17:38:27.515] getGlobalsAndPackages() ...
[17:38:27.515] Searching for globals...
[17:38:27.518] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:38:27.518] Searching for globals ... DONE
[17:38:27.518] Resolving globals: FALSE
[17:38:27.519] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:38:27.519] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:38:27.519] - globals: [1] ‘FUN’
[17:38:27.519] 
[17:38:27.519] getGlobalsAndPackages() ... DONE
[17:38:27.520]  - globals found/used: [n=1] ‘FUN’
[17:38:27.520]  - needed namespaces: [n=0] 
[17:38:27.520] Finding globals ... DONE
[17:38:27.520]  - use_args: TRUE
[17:38:27.520]  - Getting '...' globals ...
[17:38:27.520] resolve() on list ...
[17:38:27.520]  recursive: 0
[17:38:27.520]  length: 1
[17:38:27.521]  elements: ‘...’
[17:38:27.521]  length: 0 (resolved future 1)
[17:38:27.521] resolve() on list ... DONE
[17:38:27.521]    - '...' content: [n=0] 
[17:38:27.521] List of 1
[17:38:27.521]  $ ...: list()
[17:38:27.521]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:27.521]  - attr(*, "where")=List of 1
[17:38:27.521]   ..$ ...:<environment: 0x5628abee0428> 
[17:38:27.521]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:27.521]  - attr(*, "resolved")= logi TRUE
[17:38:27.521]  - attr(*, "total_size")= num NA
[17:38:27.523]  - Getting '...' globals ... DONE
[17:38:27.524] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:38:27.524] List of 2
[17:38:27.524]  $ ...future.FUN:function (x)  
[17:38:27.524]  $ ...          : list()
[17:38:27.524]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:27.524]  - attr(*, "where")=List of 2
[17:38:27.524]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:27.524]   ..$ ...          :<environment: 0x5628abee0428> 
[17:38:27.524]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:27.524]  - attr(*, "resolved")= logi FALSE
[17:38:27.524]  - attr(*, "total_size")= num 4720
[17:38:27.526] Packages to be attached in all futures: [n=0] 
[17:38:27.526] getGlobalsAndPackagesXApply() ... DONE
[17:38:27.527] Number of futures (= number of chunks): 1
[17:38:27.527] Launching 1 futures (chunks) ...
[17:38:27.527] Chunk #1 of 1 ...
[17:38:27.527]  - Finding globals in 'X' for chunk #1 ...
[17:38:27.527] getGlobalsAndPackages() ...
[17:38:27.527] Searching for globals...
[17:38:27.527] 
[17:38:27.528] Searching for globals ... DONE
[17:38:27.528] - globals: [0] <none>
[17:38:27.528] getGlobalsAndPackages() ... DONE
[17:38:27.528]    + additional globals found: [n=0] 
[17:38:27.528]    + additional namespaces needed: [n=0] 
[17:38:27.528]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:27.528]  - seeds: <none>
[17:38:27.528]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:27.528] getGlobalsAndPackages() ...
[17:38:27.528] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:27.529] Resolving globals: FALSE
[17:38:27.529] Tweak future expression to call with '...' arguments ...
[17:38:27.529] {
[17:38:27.529]     do.call(function(...) {
[17:38:27.529]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:27.529]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:27.529]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:27.529]             on.exit(options(oopts), add = TRUE)
[17:38:27.529]         }
[17:38:27.529]         {
[17:38:27.529]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:27.529]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:27.529]                 ...future.FUN(...future.X_jj, ...)
[17:38:27.529]             })
[17:38:27.529]         }
[17:38:27.529]     }, args = future.call.arguments)
[17:38:27.529] }
[17:38:27.529] Tweak future expression to call with '...' arguments ... DONE
[17:38:27.529] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:27.529] 
[17:38:27.530] getGlobalsAndPackages() ... DONE
[17:38:27.530] run() for ‘Future’ ...
[17:38:27.530] - state: ‘created’
[17:38:27.530] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:27.534] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:27.534] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:27.534]   - Field: ‘label’
[17:38:27.534]   - Field: ‘local’
[17:38:27.534]   - Field: ‘owner’
[17:38:27.534]   - Field: ‘envir’
[17:38:27.534]   - Field: ‘packages’
[17:38:27.534]   - Field: ‘gc’
[17:38:27.534]   - Field: ‘conditions’
[17:38:27.535]   - Field: ‘expr’
[17:38:27.535]   - Field: ‘uuid’
[17:38:27.535]   - Field: ‘seed’
[17:38:27.535]   - Field: ‘version’
[17:38:27.535]   - Field: ‘result’
[17:38:27.535]   - Field: ‘asynchronous’
[17:38:27.535]   - Field: ‘calls’
[17:38:27.535]   - Field: ‘globals’
[17:38:27.535]   - Field: ‘stdout’
[17:38:27.535]   - Field: ‘earlySignal’
[17:38:27.535]   - Field: ‘lazy’
[17:38:27.536]   - Field: ‘state’
[17:38:27.536] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:27.536] - Launch lazy future ...
[17:38:27.536] Packages needed by the future expression (n = 0): <none>
[17:38:27.536] Packages needed by future strategies (n = 0): <none>
[17:38:27.537] {
[17:38:27.537]     {
[17:38:27.537]         {
[17:38:27.537]             ...future.startTime <- base::Sys.time()
[17:38:27.537]             {
[17:38:27.537]                 {
[17:38:27.537]                   {
[17:38:27.537]                     base::local({
[17:38:27.537]                       has_future <- base::requireNamespace("future", 
[17:38:27.537]                         quietly = TRUE)
[17:38:27.537]                       if (has_future) {
[17:38:27.537]                         ns <- base::getNamespace("future")
[17:38:27.537]                         version <- ns[[".package"]][["version"]]
[17:38:27.537]                         if (is.null(version)) 
[17:38:27.537]                           version <- utils::packageVersion("future")
[17:38:27.537]                       }
[17:38:27.537]                       else {
[17:38:27.537]                         version <- NULL
[17:38:27.537]                       }
[17:38:27.537]                       if (!has_future || version < "1.8.0") {
[17:38:27.537]                         info <- base::c(r_version = base::gsub("R version ", 
[17:38:27.537]                           "", base::R.version$version.string), 
[17:38:27.537]                           platform = base::sprintf("%s (%s-bit)", 
[17:38:27.537]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:27.537]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:27.537]                             "release", "version")], collapse = " "), 
[17:38:27.537]                           hostname = base::Sys.info()[["nodename"]])
[17:38:27.537]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:38:27.537]                           info)
[17:38:27.537]                         info <- base::paste(info, collapse = "; ")
[17:38:27.537]                         if (!has_future) {
[17:38:27.537]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:27.537]                             info)
[17:38:27.537]                         }
[17:38:27.537]                         else {
[17:38:27.537]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:27.537]                             info, version)
[17:38:27.537]                         }
[17:38:27.537]                         base::stop(msg)
[17:38:27.537]                       }
[17:38:27.537]                     })
[17:38:27.537]                   }
[17:38:27.537]                   ...future.strategy.old <- future::plan("list")
[17:38:27.537]                   options(future.plan = NULL)
[17:38:27.537]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:27.537]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:27.537]                 }
[17:38:27.537]                 ...future.workdir <- getwd()
[17:38:27.537]             }
[17:38:27.537]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:27.537]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:27.537]         }
[17:38:27.537]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:27.537]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:27.537]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:27.537]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:27.537]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:27.537]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:27.537]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:27.537]             base::names(...future.oldOptions))
[17:38:27.537]     }
[17:38:27.537]     if (FALSE) {
[17:38:27.537]     }
[17:38:27.537]     else {
[17:38:27.537]         if (FALSE) {
[17:38:27.537]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:27.537]                 open = "w")
[17:38:27.537]         }
[17:38:27.537]         else {
[17:38:27.537]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:27.537]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:27.537]         }
[17:38:27.537]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:27.537]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:27.537]             base::sink(type = "output", split = FALSE)
[17:38:27.537]             base::close(...future.stdout)
[17:38:27.537]         }, add = TRUE)
[17:38:27.537]     }
[17:38:27.537]     ...future.frame <- base::sys.nframe()
[17:38:27.537]     ...future.conditions <- base::list()
[17:38:27.537]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:27.537]     if (FALSE) {
[17:38:27.537]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:27.537]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:27.537]     }
[17:38:27.537]     ...future.result <- base::tryCatch({
[17:38:27.537]         base::withCallingHandlers({
[17:38:27.537]             ...future.value <- base::withVisible(base::local({
[17:38:27.537]                 do.call(function(...) {
[17:38:27.537]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:27.537]                   if (!identical(...future.globals.maxSize.org, 
[17:38:27.537]                     ...future.globals.maxSize)) {
[17:38:27.537]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:27.537]                     on.exit(options(oopts), add = TRUE)
[17:38:27.537]                   }
[17:38:27.537]                   {
[17:38:27.537]                     lapply(seq_along(...future.elements_ii), 
[17:38:27.537]                       FUN = function(jj) {
[17:38:27.537]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:27.537]                         ...future.FUN(...future.X_jj, ...)
[17:38:27.537]                       })
[17:38:27.537]                   }
[17:38:27.537]                 }, args = future.call.arguments)
[17:38:27.537]             }))
[17:38:27.537]             future::FutureResult(value = ...future.value$value, 
[17:38:27.537]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:27.537]                   ...future.rng), globalenv = if (FALSE) 
[17:38:27.537]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:27.537]                     ...future.globalenv.names))
[17:38:27.537]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:27.537]         }, condition = base::local({
[17:38:27.537]             c <- base::c
[17:38:27.537]             inherits <- base::inherits
[17:38:27.537]             invokeRestart <- base::invokeRestart
[17:38:27.537]             length <- base::length
[17:38:27.537]             list <- base::list
[17:38:27.537]             seq.int <- base::seq.int
[17:38:27.537]             signalCondition <- base::signalCondition
[17:38:27.537]             sys.calls <- base::sys.calls
[17:38:27.537]             `[[` <- base::`[[`
[17:38:27.537]             `+` <- base::`+`
[17:38:27.537]             `<<-` <- base::`<<-`
[17:38:27.537]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:27.537]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:27.537]                   3L)]
[17:38:27.537]             }
[17:38:27.537]             function(cond) {
[17:38:27.537]                 is_error <- inherits(cond, "error")
[17:38:27.537]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:27.537]                   NULL)
[17:38:27.537]                 if (is_error) {
[17:38:27.537]                   sessionInformation <- function() {
[17:38:27.537]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:27.537]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:27.537]                       search = base::search(), system = base::Sys.info())
[17:38:27.537]                   }
[17:38:27.537]                   ...future.conditions[[length(...future.conditions) + 
[17:38:27.537]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:27.537]                     cond$call), session = sessionInformation(), 
[17:38:27.537]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:27.537]                   signalCondition(cond)
[17:38:27.537]                 }
[17:38:27.537]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:27.537]                 "immediateCondition"))) {
[17:38:27.537]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:27.537]                   ...future.conditions[[length(...future.conditions) + 
[17:38:27.537]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:27.537]                   if (TRUE && !signal) {
[17:38:27.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:27.537]                     {
[17:38:27.537]                       inherits <- base::inherits
[17:38:27.537]                       invokeRestart <- base::invokeRestart
[17:38:27.537]                       is.null <- base::is.null
[17:38:27.537]                       muffled <- FALSE
[17:38:27.537]                       if (inherits(cond, "message")) {
[17:38:27.537]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:27.537]                         if (muffled) 
[17:38:27.537]                           invokeRestart("muffleMessage")
[17:38:27.537]                       }
[17:38:27.537]                       else if (inherits(cond, "warning")) {
[17:38:27.537]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:27.537]                         if (muffled) 
[17:38:27.537]                           invokeRestart("muffleWarning")
[17:38:27.537]                       }
[17:38:27.537]                       else if (inherits(cond, "condition")) {
[17:38:27.537]                         if (!is.null(pattern)) {
[17:38:27.537]                           computeRestarts <- base::computeRestarts
[17:38:27.537]                           grepl <- base::grepl
[17:38:27.537]                           restarts <- computeRestarts(cond)
[17:38:27.537]                           for (restart in restarts) {
[17:38:27.537]                             name <- restart$name
[17:38:27.537]                             if (is.null(name)) 
[17:38:27.537]                               next
[17:38:27.537]                             if (!grepl(pattern, name)) 
[17:38:27.537]                               next
[17:38:27.537]                             invokeRestart(restart)
[17:38:27.537]                             muffled <- TRUE
[17:38:27.537]                             break
[17:38:27.537]                           }
[17:38:27.537]                         }
[17:38:27.537]                       }
[17:38:27.537]                       invisible(muffled)
[17:38:27.537]                     }
[17:38:27.537]                     muffleCondition(cond, pattern = "^muffle")
[17:38:27.537]                   }
[17:38:27.537]                 }
[17:38:27.537]                 else {
[17:38:27.537]                   if (TRUE) {
[17:38:27.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:27.537]                     {
[17:38:27.537]                       inherits <- base::inherits
[17:38:27.537]                       invokeRestart <- base::invokeRestart
[17:38:27.537]                       is.null <- base::is.null
[17:38:27.537]                       muffled <- FALSE
[17:38:27.537]                       if (inherits(cond, "message")) {
[17:38:27.537]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:27.537]                         if (muffled) 
[17:38:27.537]                           invokeRestart("muffleMessage")
[17:38:27.537]                       }
[17:38:27.537]                       else if (inherits(cond, "warning")) {
[17:38:27.537]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:27.537]                         if (muffled) 
[17:38:27.537]                           invokeRestart("muffleWarning")
[17:38:27.537]                       }
[17:38:27.537]                       else if (inherits(cond, "condition")) {
[17:38:27.537]                         if (!is.null(pattern)) {
[17:38:27.537]                           computeRestarts <- base::computeRestarts
[17:38:27.537]                           grepl <- base::grepl
[17:38:27.537]                           restarts <- computeRestarts(cond)
[17:38:27.537]                           for (restart in restarts) {
[17:38:27.537]                             name <- restart$name
[17:38:27.537]                             if (is.null(name)) 
[17:38:27.537]                               next
[17:38:27.537]                             if (!grepl(pattern, name)) 
[17:38:27.537]                               next
[17:38:27.537]                             invokeRestart(restart)
[17:38:27.537]                             muffled <- TRUE
[17:38:27.537]                             break
[17:38:27.537]                           }
[17:38:27.537]                         }
[17:38:27.537]                       }
[17:38:27.537]                       invisible(muffled)
[17:38:27.537]                     }
[17:38:27.537]                     muffleCondition(cond, pattern = "^muffle")
[17:38:27.537]                   }
[17:38:27.537]                 }
[17:38:27.537]             }
[17:38:27.537]         }))
[17:38:27.537]     }, error = function(ex) {
[17:38:27.537]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:27.537]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:27.537]                 ...future.rng), started = ...future.startTime, 
[17:38:27.537]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:27.537]             version = "1.8"), class = "FutureResult")
[17:38:27.537]     }, finally = {
[17:38:27.537]         if (!identical(...future.workdir, getwd())) 
[17:38:27.537]             setwd(...future.workdir)
[17:38:27.537]         {
[17:38:27.537]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:27.537]                 ...future.oldOptions$nwarnings <- NULL
[17:38:27.537]             }
[17:38:27.537]             base::options(...future.oldOptions)
[17:38:27.537]             if (.Platform$OS.type == "windows") {
[17:38:27.537]                 old_names <- names(...future.oldEnvVars)
[17:38:27.537]                 envs <- base::Sys.getenv()
[17:38:27.537]                 names <- names(envs)
[17:38:27.537]                 common <- intersect(names, old_names)
[17:38:27.537]                 added <- setdiff(names, old_names)
[17:38:27.537]                 removed <- setdiff(old_names, names)
[17:38:27.537]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:27.537]                   envs[common]]
[17:38:27.537]                 NAMES <- toupper(changed)
[17:38:27.537]                 args <- list()
[17:38:27.537]                 for (kk in seq_along(NAMES)) {
[17:38:27.537]                   name <- changed[[kk]]
[17:38:27.537]                   NAME <- NAMES[[kk]]
[17:38:27.537]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:27.537]                     next
[17:38:27.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:27.537]                 }
[17:38:27.537]                 NAMES <- toupper(added)
[17:38:27.537]                 for (kk in seq_along(NAMES)) {
[17:38:27.537]                   name <- added[[kk]]
[17:38:27.537]                   NAME <- NAMES[[kk]]
[17:38:27.537]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:27.537]                     next
[17:38:27.537]                   args[[name]] <- ""
[17:38:27.537]                 }
[17:38:27.537]                 NAMES <- toupper(removed)
[17:38:27.537]                 for (kk in seq_along(NAMES)) {
[17:38:27.537]                   name <- removed[[kk]]
[17:38:27.537]                   NAME <- NAMES[[kk]]
[17:38:27.537]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:27.537]                     next
[17:38:27.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:27.537]                 }
[17:38:27.537]                 if (length(args) > 0) 
[17:38:27.537]                   base::do.call(base::Sys.setenv, args = args)
[17:38:27.537]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:27.537]             }
[17:38:27.537]             else {
[17:38:27.537]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:27.537]             }
[17:38:27.537]             {
[17:38:27.537]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:27.537]                   0L) {
[17:38:27.537]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:27.537]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:27.537]                   base::options(opts)
[17:38:27.537]                 }
[17:38:27.537]                 {
[17:38:27.537]                   {
[17:38:27.537]                     NULL
[17:38:27.537]                     RNGkind("Mersenne-Twister")
[17:38:27.537]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:27.537]                       inherits = FALSE)
[17:38:27.537]                   }
[17:38:27.537]                   options(future.plan = NULL)
[17:38:27.537]                   if (is.na(NA_character_)) 
[17:38:27.537]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:27.537]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:27.537]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:27.537]                     .init = FALSE)
[17:38:27.537]                 }
[17:38:27.537]             }
[17:38:27.537]         }
[17:38:27.537]     })
[17:38:27.537]     if (TRUE) {
[17:38:27.537]         base::sink(type = "output", split = FALSE)
[17:38:27.537]         if (FALSE) {
[17:38:27.537]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:27.537]         }
[17:38:27.537]         else {
[17:38:27.537]             ...future.result["stdout"] <- base::list(NULL)
[17:38:27.537]         }
[17:38:27.537]         base::close(...future.stdout)
[17:38:27.537]         ...future.stdout <- NULL
[17:38:27.537]     }
[17:38:27.537]     ...future.result$conditions <- ...future.conditions
[17:38:27.537]     ...future.result$finished <- base::Sys.time()
[17:38:27.537]     ...future.result
[17:38:27.537] }
[17:38:27.538] assign_globals() ...
[17:38:27.538] List of 5
[17:38:27.538]  $ ...future.FUN            :function (x)  
[17:38:27.538]  $ future.call.arguments    : list()
[17:38:27.538]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:27.538]  $ ...future.elements_ii    :List of 2
[17:38:27.538]   ..$ : int 1
[17:38:27.538]   ..$ : int 0
[17:38:27.538]  $ ...future.seeds_ii       : NULL
[17:38:27.538]  $ ...future.globals.maxSize: NULL
[17:38:27.538]  - attr(*, "where")=List of 5
[17:38:27.538]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:27.538]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:27.538]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:27.538]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:27.538]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:27.538]  - attr(*, "resolved")= logi FALSE
[17:38:27.538]  - attr(*, "total_size")= num 4720
[17:38:27.538]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:27.538]  - attr(*, "already-done")= logi TRUE
[17:38:27.572] - reassign environment for ‘...future.FUN’
[17:38:27.572] - copied ‘...future.FUN’ to environment
[17:38:27.572] - copied ‘future.call.arguments’ to environment
[17:38:27.572] - copied ‘...future.elements_ii’ to environment
[17:38:27.572] - copied ‘...future.seeds_ii’ to environment
[17:38:27.572] - copied ‘...future.globals.maxSize’ to environment
[17:38:27.573] assign_globals() ... done
[17:38:27.573] plan(): Setting new future strategy stack:
[17:38:27.573] List of future strategies:
[17:38:27.573] 1. sequential:
[17:38:27.573]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:27.573]    - tweaked: FALSE
[17:38:27.573]    - call: NULL
[17:38:27.574] plan(): nbrOfWorkers() = 1
[17:38:28.075] plan(): Setting new future strategy stack:
[17:38:28.075] List of future strategies:
[17:38:28.075] 1. multisession:
[17:38:28.075]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:38:28.075]    - tweaked: FALSE
[17:38:28.075]    - call: plan(strategy)
[17:38:28.080] plan(): nbrOfWorkers() = 1
[17:38:28.080] SequentialFuture started (and completed)
[17:38:28.080] - Launch lazy future ... done
[17:38:28.080] run() for ‘SequentialFuture’ ... done
[17:38:28.080] Created future:
[17:38:28.081] SequentialFuture:
[17:38:28.081] Label: ‘future_lapply-1’
[17:38:28.081] Expression:
[17:38:28.081] {
[17:38:28.081]     do.call(function(...) {
[17:38:28.081]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:28.081]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:28.081]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:28.081]             on.exit(options(oopts), add = TRUE)
[17:38:28.081]         }
[17:38:28.081]         {
[17:38:28.081]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:28.081]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:28.081]                 ...future.FUN(...future.X_jj, ...)
[17:38:28.081]             })
[17:38:28.081]         }
[17:38:28.081]     }, args = future.call.arguments)
[17:38:28.081] }
[17:38:28.081] Lazy evaluation: FALSE
[17:38:28.081] Asynchronous evaluation: FALSE
[17:38:28.081] Local evaluation: TRUE
[17:38:28.081] Environment: R_GlobalEnv
[17:38:28.081] Capture standard output: FALSE
[17:38:28.081] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:28.081] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:28.081] Packages: <none>
[17:38:28.081] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:28.081] Resolved: TRUE
[17:38:28.081] Value: 112 bytes of class ‘list’
[17:38:28.081] Early signaling: FALSE
[17:38:28.081] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:28.081] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:28.082] Chunk #1 of 1 ... DONE
[17:38:28.082] Launching 1 futures (chunks) ... DONE
[17:38:28.082] Resolving 1 futures (chunks) ...
[17:38:28.082] resolve() on list ...
[17:38:28.082]  recursive: 0
[17:38:28.082]  length: 1
[17:38:28.082] 
[17:38:28.083] resolved() for ‘SequentialFuture’ ...
[17:38:28.083] - state: ‘finished’
[17:38:28.083] - run: TRUE
[17:38:28.083] - result: ‘FutureResult’
[17:38:28.083] resolved() for ‘SequentialFuture’ ... done
[17:38:28.083] Future #1
[17:38:28.083] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:28.083] - nx: 1
[17:38:28.083] - relay: TRUE
[17:38:28.084] - stdout: TRUE
[17:38:28.084] - signal: TRUE
[17:38:28.084] - resignal: FALSE
[17:38:28.084] - force: TRUE
[17:38:28.084] - relayed: [n=1] FALSE
[17:38:28.084] - queued futures: [n=1] FALSE
[17:38:28.084]  - until=1
[17:38:28.084]  - relaying element #1
[17:38:28.084] - relayed: [n=1] TRUE
[17:38:28.084] - queued futures: [n=1] TRUE
[17:38:28.085] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:28.085]  length: 0 (resolved future 1)
[17:38:28.085] Relaying remaining futures
[17:38:28.085] signalConditionsASAP(NULL, pos=0) ...
[17:38:28.085] - nx: 1
[17:38:28.085] - relay: TRUE
[17:38:28.085] - stdout: TRUE
[17:38:28.085] - signal: TRUE
[17:38:28.085] - resignal: FALSE
[17:38:28.085] - force: TRUE
[17:38:28.085] - relayed: [n=1] TRUE
[17:38:28.085] - queued futures: [n=1] TRUE
 - flush all
[17:38:28.086] - relayed: [n=1] TRUE
[17:38:28.086] - queued futures: [n=1] TRUE
[17:38:28.086] signalConditionsASAP(NULL, pos=0) ... done
[17:38:28.086] resolve() on list ... DONE
[17:38:28.086]  - Number of value chunks collected: 1
[17:38:28.086] Resolving 1 futures (chunks) ... DONE
[17:38:28.086] Reducing values from 1 chunks ...
[17:38:28.086]  - Number of values collected after concatenation: 2
[17:38:28.086]  - Number of values expected: 2
[17:38:28.086] Reducing values from 1 chunks ... DONE
[17:38:28.087] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[17:38:28.087] future_lapply() ...
[17:38:28.091] Number of chunks: 1
[17:38:28.091] getGlobalsAndPackagesXApply() ...
[17:38:28.091]  - future.globals: TRUE
[17:38:28.091] getGlobalsAndPackages() ...
[17:38:28.091] Searching for globals...
[17:38:28.093] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:38:28.093] Searching for globals ... DONE
[17:38:28.093] Resolving globals: FALSE
[17:38:28.093] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:38:28.094] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:38:28.094] - globals: [1] ‘FUN’
[17:38:28.094] 
[17:38:28.094] getGlobalsAndPackages() ... DONE
[17:38:28.094]  - globals found/used: [n=1] ‘FUN’
[17:38:28.094]  - needed namespaces: [n=0] 
[17:38:28.094] Finding globals ... DONE
[17:38:28.094]  - use_args: TRUE
[17:38:28.095]  - Getting '...' globals ...
[17:38:28.095] resolve() on list ...
[17:38:28.095]  recursive: 0
[17:38:28.095]  length: 1
[17:38:28.095]  elements: ‘...’
[17:38:28.095]  length: 0 (resolved future 1)
[17:38:28.095] resolve() on list ... DONE
[17:38:28.096]    - '...' content: [n=0] 
[17:38:28.096] List of 1
[17:38:28.096]  $ ...: list()
[17:38:28.096]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:28.096]  - attr(*, "where")=List of 1
[17:38:28.096]   ..$ ...:<environment: 0x5628aa79a810> 
[17:38:28.096]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:28.096]  - attr(*, "resolved")= logi TRUE
[17:38:28.096]  - attr(*, "total_size")= num NA
[17:38:28.098]  - Getting '...' globals ... DONE
[17:38:28.098] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:38:28.099] List of 2
[17:38:28.099]  $ ...future.FUN:function (x)  
[17:38:28.099]  $ ...          : list()
[17:38:28.099]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:28.099]  - attr(*, "where")=List of 2
[17:38:28.099]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:28.099]   ..$ ...          :<environment: 0x5628aa79a810> 
[17:38:28.099]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:28.099]  - attr(*, "resolved")= logi FALSE
[17:38:28.099]  - attr(*, "total_size")= num 4720
[17:38:28.101] Packages to be attached in all futures: [n=0] 
[17:38:28.101] getGlobalsAndPackagesXApply() ... DONE
[17:38:28.101] Number of futures (= number of chunks): 1
[17:38:28.102] Launching 1 futures (chunks) ...
[17:38:28.102] Chunk #1 of 1 ...
[17:38:28.102]  - Finding globals in 'X' for chunk #1 ...
[17:38:28.102] getGlobalsAndPackages() ...
[17:38:28.102] Searching for globals...
[17:38:28.102] 
[17:38:28.102] Searching for globals ... DONE
[17:38:28.102] - globals: [0] <none>
[17:38:28.103] getGlobalsAndPackages() ... DONE
[17:38:28.103]    + additional globals found: [n=0] 
[17:38:28.103]    + additional namespaces needed: [n=0] 
[17:38:28.103]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:28.103]  - seeds: <none>
[17:38:28.103]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:28.103] getGlobalsAndPackages() ...
[17:38:28.103] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:28.103] Resolving globals: FALSE
[17:38:28.103] Tweak future expression to call with '...' arguments ...
[17:38:28.104] {
[17:38:28.104]     do.call(function(...) {
[17:38:28.104]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:28.104]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:28.104]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:28.104]             on.exit(options(oopts), add = TRUE)
[17:38:28.104]         }
[17:38:28.104]         {
[17:38:28.104]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:28.104]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:28.104]                 ...future.FUN(...future.X_jj, ...)
[17:38:28.104]             })
[17:38:28.104]         }
[17:38:28.104]     }, args = future.call.arguments)
[17:38:28.104] }
[17:38:28.104] Tweak future expression to call with '...' arguments ... DONE
[17:38:28.104] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:28.104] 
[17:38:28.104] getGlobalsAndPackages() ... DONE
[17:38:28.105] run() for ‘Future’ ...
[17:38:28.105] - state: ‘created’
[17:38:28.105] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:28.110] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:28.110] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:28.111]   - Field: ‘label’
[17:38:28.111]   - Field: ‘local’
[17:38:28.111]   - Field: ‘owner’
[17:38:28.111]   - Field: ‘envir’
[17:38:28.111]   - Field: ‘packages’
[17:38:28.111]   - Field: ‘gc’
[17:38:28.111]   - Field: ‘conditions’
[17:38:28.111]   - Field: ‘expr’
[17:38:28.112]   - Field: ‘uuid’
[17:38:28.112]   - Field: ‘seed’
[17:38:28.112]   - Field: ‘version’
[17:38:28.112]   - Field: ‘result’
[17:38:28.112]   - Field: ‘asynchronous’
[17:38:28.112]   - Field: ‘calls’
[17:38:28.112]   - Field: ‘globals’
[17:38:28.112]   - Field: ‘stdout’
[17:38:28.112]   - Field: ‘earlySignal’
[17:38:28.112]   - Field: ‘lazy’
[17:38:28.112]   - Field: ‘state’
[17:38:28.113] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:28.113] - Launch lazy future ...
[17:38:28.113] Packages needed by the future expression (n = 0): <none>
[17:38:28.113] Packages needed by future strategies (n = 0): <none>
[17:38:28.113] {
[17:38:28.113]     {
[17:38:28.113]         {
[17:38:28.113]             ...future.startTime <- base::Sys.time()
[17:38:28.113]             {
[17:38:28.113]                 {
[17:38:28.113]                   {
[17:38:28.113]                     base::local({
[17:38:28.113]                       has_future <- base::requireNamespace("future", 
[17:38:28.113]                         quietly = TRUE)
[17:38:28.113]                       if (has_future) {
[17:38:28.113]                         ns <- base::getNamespace("future")
[17:38:28.113]                         version <- ns[[".package"]][["version"]]
[17:38:28.113]                         if (is.null(version)) 
[17:38:28.113]                           version <- utils::packageVersion("future")
[17:38:28.113]                       }
[17:38:28.113]                       else {
[17:38:28.113]                         version <- NULL
[17:38:28.113]                       }
[17:38:28.113]                       if (!has_future || version < "1.8.0") {
[17:38:28.113]                         info <- base::c(r_version = base::gsub("R version ", 
[17:38:28.113]                           "", base::R.version$version.string), 
[17:38:28.113]                           platform = base::sprintf("%s (%s-bit)", 
[17:38:28.113]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:28.113]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:28.113]                             "release", "version")], collapse = " "), 
[17:38:28.113]                           hostname = base::Sys.info()[["nodename"]])
[17:38:28.113]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:38:28.113]                           info)
[17:38:28.113]                         info <- base::paste(info, collapse = "; ")
[17:38:28.113]                         if (!has_future) {
[17:38:28.113]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:28.113]                             info)
[17:38:28.113]                         }
[17:38:28.113]                         else {
[17:38:28.113]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:28.113]                             info, version)
[17:38:28.113]                         }
[17:38:28.113]                         base::stop(msg)
[17:38:28.113]                       }
[17:38:28.113]                     })
[17:38:28.113]                   }
[17:38:28.113]                   ...future.strategy.old <- future::plan("list")
[17:38:28.113]                   options(future.plan = NULL)
[17:38:28.113]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:28.113]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:28.113]                 }
[17:38:28.113]                 ...future.workdir <- getwd()
[17:38:28.113]             }
[17:38:28.113]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:28.113]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:28.113]         }
[17:38:28.113]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:28.113]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:28.113]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:28.113]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:28.113]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:28.113]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:28.113]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:28.113]             base::names(...future.oldOptions))
[17:38:28.113]     }
[17:38:28.113]     if (FALSE) {
[17:38:28.113]     }
[17:38:28.113]     else {
[17:38:28.113]         if (TRUE) {
[17:38:28.113]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:28.113]                 open = "w")
[17:38:28.113]         }
[17:38:28.113]         else {
[17:38:28.113]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:28.113]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:28.113]         }
[17:38:28.113]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:28.113]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:28.113]             base::sink(type = "output", split = FALSE)
[17:38:28.113]             base::close(...future.stdout)
[17:38:28.113]         }, add = TRUE)
[17:38:28.113]     }
[17:38:28.113]     ...future.frame <- base::sys.nframe()
[17:38:28.113]     ...future.conditions <- base::list()
[17:38:28.113]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:28.113]     if (FALSE) {
[17:38:28.113]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:28.113]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:28.113]     }
[17:38:28.113]     ...future.result <- base::tryCatch({
[17:38:28.113]         base::withCallingHandlers({
[17:38:28.113]             ...future.value <- base::withVisible(base::local({
[17:38:28.113]                 do.call(function(...) {
[17:38:28.113]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:28.113]                   if (!identical(...future.globals.maxSize.org, 
[17:38:28.113]                     ...future.globals.maxSize)) {
[17:38:28.113]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:28.113]                     on.exit(options(oopts), add = TRUE)
[17:38:28.113]                   }
[17:38:28.113]                   {
[17:38:28.113]                     lapply(seq_along(...future.elements_ii), 
[17:38:28.113]                       FUN = function(jj) {
[17:38:28.113]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:28.113]                         ...future.FUN(...future.X_jj, ...)
[17:38:28.113]                       })
[17:38:28.113]                   }
[17:38:28.113]                 }, args = future.call.arguments)
[17:38:28.113]             }))
[17:38:28.113]             future::FutureResult(value = ...future.value$value, 
[17:38:28.113]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:28.113]                   ...future.rng), globalenv = if (FALSE) 
[17:38:28.113]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:28.113]                     ...future.globalenv.names))
[17:38:28.113]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:28.113]         }, condition = base::local({
[17:38:28.113]             c <- base::c
[17:38:28.113]             inherits <- base::inherits
[17:38:28.113]             invokeRestart <- base::invokeRestart
[17:38:28.113]             length <- base::length
[17:38:28.113]             list <- base::list
[17:38:28.113]             seq.int <- base::seq.int
[17:38:28.113]             signalCondition <- base::signalCondition
[17:38:28.113]             sys.calls <- base::sys.calls
[17:38:28.113]             `[[` <- base::`[[`
[17:38:28.113]             `+` <- base::`+`
[17:38:28.113]             `<<-` <- base::`<<-`
[17:38:28.113]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:28.113]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:28.113]                   3L)]
[17:38:28.113]             }
[17:38:28.113]             function(cond) {
[17:38:28.113]                 is_error <- inherits(cond, "error")
[17:38:28.113]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:28.113]                   NULL)
[17:38:28.113]                 if (is_error) {
[17:38:28.113]                   sessionInformation <- function() {
[17:38:28.113]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:28.113]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:28.113]                       search = base::search(), system = base::Sys.info())
[17:38:28.113]                   }
[17:38:28.113]                   ...future.conditions[[length(...future.conditions) + 
[17:38:28.113]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:28.113]                     cond$call), session = sessionInformation(), 
[17:38:28.113]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:28.113]                   signalCondition(cond)
[17:38:28.113]                 }
[17:38:28.113]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:28.113]                 "immediateCondition"))) {
[17:38:28.113]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:28.113]                   ...future.conditions[[length(...future.conditions) + 
[17:38:28.113]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:28.113]                   if (TRUE && !signal) {
[17:38:28.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:28.113]                     {
[17:38:28.113]                       inherits <- base::inherits
[17:38:28.113]                       invokeRestart <- base::invokeRestart
[17:38:28.113]                       is.null <- base::is.null
[17:38:28.113]                       muffled <- FALSE
[17:38:28.113]                       if (inherits(cond, "message")) {
[17:38:28.113]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:28.113]                         if (muffled) 
[17:38:28.113]                           invokeRestart("muffleMessage")
[17:38:28.113]                       }
[17:38:28.113]                       else if (inherits(cond, "warning")) {
[17:38:28.113]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:28.113]                         if (muffled) 
[17:38:28.113]                           invokeRestart("muffleWarning")
[17:38:28.113]                       }
[17:38:28.113]                       else if (inherits(cond, "condition")) {
[17:38:28.113]                         if (!is.null(pattern)) {
[17:38:28.113]                           computeRestarts <- base::computeRestarts
[17:38:28.113]                           grepl <- base::grepl
[17:38:28.113]                           restarts <- computeRestarts(cond)
[17:38:28.113]                           for (restart in restarts) {
[17:38:28.113]                             name <- restart$name
[17:38:28.113]                             if (is.null(name)) 
[17:38:28.113]                               next
[17:38:28.113]                             if (!grepl(pattern, name)) 
[17:38:28.113]                               next
[17:38:28.113]                             invokeRestart(restart)
[17:38:28.113]                             muffled <- TRUE
[17:38:28.113]                             break
[17:38:28.113]                           }
[17:38:28.113]                         }
[17:38:28.113]                       }
[17:38:28.113]                       invisible(muffled)
[17:38:28.113]                     }
[17:38:28.113]                     muffleCondition(cond, pattern = "^muffle")
[17:38:28.113]                   }
[17:38:28.113]                 }
[17:38:28.113]                 else {
[17:38:28.113]                   if (TRUE) {
[17:38:28.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:28.113]                     {
[17:38:28.113]                       inherits <- base::inherits
[17:38:28.113]                       invokeRestart <- base::invokeRestart
[17:38:28.113]                       is.null <- base::is.null
[17:38:28.113]                       muffled <- FALSE
[17:38:28.113]                       if (inherits(cond, "message")) {
[17:38:28.113]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:28.113]                         if (muffled) 
[17:38:28.113]                           invokeRestart("muffleMessage")
[17:38:28.113]                       }
[17:38:28.113]                       else if (inherits(cond, "warning")) {
[17:38:28.113]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:28.113]                         if (muffled) 
[17:38:28.113]                           invokeRestart("muffleWarning")
[17:38:28.113]                       }
[17:38:28.113]                       else if (inherits(cond, "condition")) {
[17:38:28.113]                         if (!is.null(pattern)) {
[17:38:28.113]                           computeRestarts <- base::computeRestarts
[17:38:28.113]                           grepl <- base::grepl
[17:38:28.113]                           restarts <- computeRestarts(cond)
[17:38:28.113]                           for (restart in restarts) {
[17:38:28.113]                             name <- restart$name
[17:38:28.113]                             if (is.null(name)) 
[17:38:28.113]                               next
[17:38:28.113]                             if (!grepl(pattern, name)) 
[17:38:28.113]                               next
[17:38:28.113]                             invokeRestart(restart)
[17:38:28.113]                             muffled <- TRUE
[17:38:28.113]                             break
[17:38:28.113]                           }
[17:38:28.113]                         }
[17:38:28.113]                       }
[17:38:28.113]                       invisible(muffled)
[17:38:28.113]                     }
[17:38:28.113]                     muffleCondition(cond, pattern = "^muffle")
[17:38:28.113]                   }
[17:38:28.113]                 }
[17:38:28.113]             }
[17:38:28.113]         }))
[17:38:28.113]     }, error = function(ex) {
[17:38:28.113]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:28.113]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:28.113]                 ...future.rng), started = ...future.startTime, 
[17:38:28.113]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:28.113]             version = "1.8"), class = "FutureResult")
[17:38:28.113]     }, finally = {
[17:38:28.113]         if (!identical(...future.workdir, getwd())) 
[17:38:28.113]             setwd(...future.workdir)
[17:38:28.113]         {
[17:38:28.113]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:28.113]                 ...future.oldOptions$nwarnings <- NULL
[17:38:28.113]             }
[17:38:28.113]             base::options(...future.oldOptions)
[17:38:28.113]             if (.Platform$OS.type == "windows") {
[17:38:28.113]                 old_names <- names(...future.oldEnvVars)
[17:38:28.113]                 envs <- base::Sys.getenv()
[17:38:28.113]                 names <- names(envs)
[17:38:28.113]                 common <- intersect(names, old_names)
[17:38:28.113]                 added <- setdiff(names, old_names)
[17:38:28.113]                 removed <- setdiff(old_names, names)
[17:38:28.113]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:28.113]                   envs[common]]
[17:38:28.113]                 NAMES <- toupper(changed)
[17:38:28.113]                 args <- list()
[17:38:28.113]                 for (kk in seq_along(NAMES)) {
[17:38:28.113]                   name <- changed[[kk]]
[17:38:28.113]                   NAME <- NAMES[[kk]]
[17:38:28.113]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:28.113]                     next
[17:38:28.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:28.113]                 }
[17:38:28.113]                 NAMES <- toupper(added)
[17:38:28.113]                 for (kk in seq_along(NAMES)) {
[17:38:28.113]                   name <- added[[kk]]
[17:38:28.113]                   NAME <- NAMES[[kk]]
[17:38:28.113]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:28.113]                     next
[17:38:28.113]                   args[[name]] <- ""
[17:38:28.113]                 }
[17:38:28.113]                 NAMES <- toupper(removed)
[17:38:28.113]                 for (kk in seq_along(NAMES)) {
[17:38:28.113]                   name <- removed[[kk]]
[17:38:28.113]                   NAME <- NAMES[[kk]]
[17:38:28.113]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:28.113]                     next
[17:38:28.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:28.113]                 }
[17:38:28.113]                 if (length(args) > 0) 
[17:38:28.113]                   base::do.call(base::Sys.setenv, args = args)
[17:38:28.113]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:28.113]             }
[17:38:28.113]             else {
[17:38:28.113]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:28.113]             }
[17:38:28.113]             {
[17:38:28.113]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:28.113]                   0L) {
[17:38:28.113]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:28.113]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:28.113]                   base::options(opts)
[17:38:28.113]                 }
[17:38:28.113]                 {
[17:38:28.113]                   {
[17:38:28.113]                     NULL
[17:38:28.113]                     RNGkind("Mersenne-Twister")
[17:38:28.113]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:28.113]                       inherits = FALSE)
[17:38:28.113]                   }
[17:38:28.113]                   options(future.plan = NULL)
[17:38:28.113]                   if (is.na(NA_character_)) 
[17:38:28.113]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:28.113]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:28.113]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:28.113]                     .init = FALSE)
[17:38:28.113]                 }
[17:38:28.113]             }
[17:38:28.113]         }
[17:38:28.113]     })
[17:38:28.113]     if (TRUE) {
[17:38:28.113]         base::sink(type = "output", split = FALSE)
[17:38:28.113]         if (TRUE) {
[17:38:28.113]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:28.113]         }
[17:38:28.113]         else {
[17:38:28.113]             ...future.result["stdout"] <- base::list(NULL)
[17:38:28.113]         }
[17:38:28.113]         base::close(...future.stdout)
[17:38:28.113]         ...future.stdout <- NULL
[17:38:28.113]     }
[17:38:28.113]     ...future.result$conditions <- ...future.conditions
[17:38:28.113]     ...future.result$finished <- base::Sys.time()
[17:38:28.113]     ...future.result
[17:38:28.113] }
[17:38:28.115] assign_globals() ...
[17:38:28.115] List of 5
[17:38:28.115]  $ ...future.FUN            :function (x)  
[17:38:28.115]  $ future.call.arguments    : list()
[17:38:28.115]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:28.115]  $ ...future.elements_ii    :List of 2
[17:38:28.115]   ..$ : int 1
[17:38:28.115]   ..$ : int 0
[17:38:28.115]  $ ...future.seeds_ii       : NULL
[17:38:28.115]  $ ...future.globals.maxSize: NULL
[17:38:28.115]  - attr(*, "where")=List of 5
[17:38:28.115]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:28.115]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:28.115]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:28.115]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:28.115]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:28.115]  - attr(*, "resolved")= logi FALSE
[17:38:28.115]  - attr(*, "total_size")= num 4720
[17:38:28.115]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:28.115]  - attr(*, "already-done")= logi TRUE
[17:38:28.120] - reassign environment for ‘...future.FUN’
[17:38:28.120] - copied ‘...future.FUN’ to environment
[17:38:28.120] - copied ‘future.call.arguments’ to environment
[17:38:28.121] - copied ‘...future.elements_ii’ to environment
[17:38:28.121] - copied ‘...future.seeds_ii’ to environment
[17:38:28.121] - copied ‘...future.globals.maxSize’ to environment
[17:38:28.121] assign_globals() ... done
[17:38:28.121] plan(): Setting new future strategy stack:
[17:38:28.121] List of future strategies:
[17:38:28.121] 1. sequential:
[17:38:28.121]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:28.121]    - tweaked: FALSE
[17:38:28.121]    - call: NULL
[17:38:28.122] plan(): nbrOfWorkers() = 1
[17:38:28.623] plan(): Setting new future strategy stack:
[17:38:28.623] List of future strategies:
[17:38:28.623] 1. multisession:
[17:38:28.623]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:38:28.623]    - tweaked: FALSE
[17:38:28.623]    - call: plan(strategy)
[17:38:28.628] plan(): nbrOfWorkers() = 1
[17:38:28.628] SequentialFuture started (and completed)
[17:38:28.628] - Launch lazy future ... done
[17:38:28.628] run() for ‘SequentialFuture’ ... done
[17:38:28.628] Created future:
[17:38:28.629] SequentialFuture:
[17:38:28.629] Label: ‘future_lapply-1’
[17:38:28.629] Expression:
[17:38:28.629] {
[17:38:28.629]     do.call(function(...) {
[17:38:28.629]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:28.629]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:28.629]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:28.629]             on.exit(options(oopts), add = TRUE)
[17:38:28.629]         }
[17:38:28.629]         {
[17:38:28.629]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:28.629]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:28.629]                 ...future.FUN(...future.X_jj, ...)
[17:38:28.629]             })
[17:38:28.629]         }
[17:38:28.629]     }, args = future.call.arguments)
[17:38:28.629] }
[17:38:28.629] Lazy evaluation: FALSE
[17:38:28.629] Asynchronous evaluation: FALSE
[17:38:28.629] Local evaluation: TRUE
[17:38:28.629] Environment: R_GlobalEnv
[17:38:28.629] Capture standard output: TRUE
[17:38:28.629] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:28.629] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:28.629] Packages: <none>
[17:38:28.629] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:28.629] Resolved: TRUE
[17:38:28.629] Value: 112 bytes of class ‘list’
[17:38:28.629] Early signaling: FALSE
[17:38:28.629] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:28.629] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:28.630] Chunk #1 of 1 ... DONE
[17:38:28.630] Launching 1 futures (chunks) ... DONE
[17:38:28.630] Resolving 1 futures (chunks) ...
[17:38:28.630] resolve() on list ...
[17:38:28.630]  recursive: 0
[17:38:28.630]  length: 1
[17:38:28.630] 
[17:38:28.630] resolved() for ‘SequentialFuture’ ...
[17:38:28.631] - state: ‘finished’
[17:38:28.631] - run: TRUE
[17:38:28.631] - result: ‘FutureResult’
[17:38:28.631] resolved() for ‘SequentialFuture’ ... done
[17:38:28.631] Future #1
[17:38:28.631] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:28.631] - nx: 1
[17:38:28.631] - relay: TRUE
[17:38:28.631] - stdout: TRUE
[17:38:28.631] - signal: TRUE
[17:38:28.632] - resignal: FALSE
[17:38:28.632] - force: TRUE
[17:38:28.632] - relayed: [n=1] FALSE
[17:38:28.632] - queued futures: [n=1] FALSE
[17:38:28.632]  - until=1
[17:38:28.632]  - relaying element #1
[17:38:28.632] - relayed: [n=1] TRUE
[17:38:28.632] - queued futures: [n=1] TRUE
[17:38:28.632] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:28.633]  length: 0 (resolved future 1)
[17:38:28.633] Relaying remaining futures
[17:38:28.633] signalConditionsASAP(NULL, pos=0) ...
[17:38:28.633] - nx: 1
[17:38:28.633] - relay: TRUE
[17:38:28.633] - stdout: TRUE
[17:38:28.633] - signal: TRUE
[17:38:28.633] - resignal: FALSE
[17:38:28.633] - force: TRUE
[17:38:28.633] - relayed: [n=1] TRUE
[17:38:28.633] - queued futures: [n=1] TRUE
 - flush all
[17:38:28.634] - relayed: [n=1] TRUE
[17:38:28.634] - queued futures: [n=1] TRUE
[17:38:28.634] signalConditionsASAP(NULL, pos=0) ... done
[17:38:28.634] resolve() on list ... DONE
[17:38:28.634]  - Number of value chunks collected: 1
[17:38:28.634] Resolving 1 futures (chunks) ... DONE
[17:38:28.634] Reducing values from 1 chunks ...
[17:38:28.634]  - Number of values collected after concatenation: 2
[17:38:28.634]  - Number of values expected: 2
[17:38:28.634] Reducing values from 1 chunks ... DONE
[17:38:28.635] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[17:38:28.635] future_lapply() ...
[17:38:28.639] Number of chunks: 1
[17:38:28.639] getGlobalsAndPackagesXApply() ...
[17:38:28.639]  - future.globals: TRUE
[17:38:28.639] getGlobalsAndPackages() ...
[17:38:28.639] Searching for globals...
[17:38:28.640] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:38:28.641] Searching for globals ... DONE
[17:38:28.641] Resolving globals: FALSE
[17:38:28.641] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:38:28.641] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:38:28.642] - globals: [1] ‘FUN’
[17:38:28.642] 
[17:38:28.642] getGlobalsAndPackages() ... DONE
[17:38:28.642]  - globals found/used: [n=1] ‘FUN’
[17:38:28.642]  - needed namespaces: [n=0] 
[17:38:28.642] Finding globals ... DONE
[17:38:28.642]  - use_args: TRUE
[17:38:28.642]  - Getting '...' globals ...
[17:38:28.643] resolve() on list ...
[17:38:28.643]  recursive: 0
[17:38:28.643]  length: 1
[17:38:28.643]  elements: ‘...’
[17:38:28.643]  length: 0 (resolved future 1)
[17:38:28.643] resolve() on list ... DONE
[17:38:28.643]    - '...' content: [n=0] 
[17:38:28.645] List of 1
[17:38:28.645]  $ ...: list()
[17:38:28.645]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:28.645]  - attr(*, "where")=List of 1
[17:38:28.645]   ..$ ...:<environment: 0x5628abc7a700> 
[17:38:28.645]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:28.645]  - attr(*, "resolved")= logi TRUE
[17:38:28.645]  - attr(*, "total_size")= num NA
[17:38:28.648]  - Getting '...' globals ... DONE
[17:38:28.648] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:38:28.648] List of 2
[17:38:28.648]  $ ...future.FUN:function (x)  
[17:38:28.648]  $ ...          : list()
[17:38:28.648]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:28.648]  - attr(*, "where")=List of 2
[17:38:28.648]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:28.648]   ..$ ...          :<environment: 0x5628abc7a700> 
[17:38:28.648]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:28.648]  - attr(*, "resolved")= logi FALSE
[17:38:28.648]  - attr(*, "total_size")= num 4720
[17:38:28.650] Packages to be attached in all futures: [n=0] 
[17:38:28.651] getGlobalsAndPackagesXApply() ... DONE
[17:38:28.651] Number of futures (= number of chunks): 1
[17:38:28.651] Launching 1 futures (chunks) ...
[17:38:28.651] Chunk #1 of 1 ...
[17:38:28.651]  - Finding globals in 'X' for chunk #1 ...
[17:38:28.651] getGlobalsAndPackages() ...
[17:38:28.651] Searching for globals...
[17:38:28.652] 
[17:38:28.652] Searching for globals ... DONE
[17:38:28.652] - globals: [0] <none>
[17:38:28.652] getGlobalsAndPackages() ... DONE
[17:38:28.652]    + additional globals found: [n=0] 
[17:38:28.652]    + additional namespaces needed: [n=0] 
[17:38:28.652]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:28.652]  - seeds: <none>
[17:38:28.652]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:28.652] getGlobalsAndPackages() ...
[17:38:28.653] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:28.653] Resolving globals: FALSE
[17:38:28.653] Tweak future expression to call with '...' arguments ...
[17:38:28.653] {
[17:38:28.653]     do.call(function(...) {
[17:38:28.653]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:28.653]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:28.653]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:28.653]             on.exit(options(oopts), add = TRUE)
[17:38:28.653]         }
[17:38:28.653]         {
[17:38:28.653]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:28.653]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:28.653]                 ...future.FUN(...future.X_jj, ...)
[17:38:28.653]             })
[17:38:28.653]         }
[17:38:28.653]     }, args = future.call.arguments)
[17:38:28.653] }
[17:38:28.653] Tweak future expression to call with '...' arguments ... DONE
[17:38:28.653] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:28.654] 
[17:38:28.654] getGlobalsAndPackages() ... DONE
[17:38:28.654] run() for ‘Future’ ...
[17:38:28.654] - state: ‘created’
[17:38:28.654] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:28.658] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:28.658] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:28.658]   - Field: ‘label’
[17:38:28.658]   - Field: ‘local’
[17:38:28.658]   - Field: ‘owner’
[17:38:28.658]   - Field: ‘envir’
[17:38:28.658]   - Field: ‘packages’
[17:38:28.658]   - Field: ‘gc’
[17:38:28.659]   - Field: ‘conditions’
[17:38:28.659]   - Field: ‘expr’
[17:38:28.659]   - Field: ‘uuid’
[17:38:28.659]   - Field: ‘seed’
[17:38:28.659]   - Field: ‘version’
[17:38:28.659]   - Field: ‘result’
[17:38:28.659]   - Field: ‘asynchronous’
[17:38:28.659]   - Field: ‘calls’
[17:38:28.659]   - Field: ‘globals’
[17:38:28.659]   - Field: ‘stdout’
[17:38:28.659]   - Field: ‘earlySignal’
[17:38:28.660]   - Field: ‘lazy’
[17:38:28.660]   - Field: ‘state’
[17:38:28.660] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:28.660] - Launch lazy future ...
[17:38:28.660] Packages needed by the future expression (n = 0): <none>
[17:38:28.660] Packages needed by future strategies (n = 0): <none>
[17:38:28.661] {
[17:38:28.661]     {
[17:38:28.661]         {
[17:38:28.661]             ...future.startTime <- base::Sys.time()
[17:38:28.661]             {
[17:38:28.661]                 {
[17:38:28.661]                   {
[17:38:28.661]                     base::local({
[17:38:28.661]                       has_future <- base::requireNamespace("future", 
[17:38:28.661]                         quietly = TRUE)
[17:38:28.661]                       if (has_future) {
[17:38:28.661]                         ns <- base::getNamespace("future")
[17:38:28.661]                         version <- ns[[".package"]][["version"]]
[17:38:28.661]                         if (is.null(version)) 
[17:38:28.661]                           version <- utils::packageVersion("future")
[17:38:28.661]                       }
[17:38:28.661]                       else {
[17:38:28.661]                         version <- NULL
[17:38:28.661]                       }
[17:38:28.661]                       if (!has_future || version < "1.8.0") {
[17:38:28.661]                         info <- base::c(r_version = base::gsub("R version ", 
[17:38:28.661]                           "", base::R.version$version.string), 
[17:38:28.661]                           platform = base::sprintf("%s (%s-bit)", 
[17:38:28.661]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:28.661]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:28.661]                             "release", "version")], collapse = " "), 
[17:38:28.661]                           hostname = base::Sys.info()[["nodename"]])
[17:38:28.661]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:38:28.661]                           info)
[17:38:28.661]                         info <- base::paste(info, collapse = "; ")
[17:38:28.661]                         if (!has_future) {
[17:38:28.661]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:28.661]                             info)
[17:38:28.661]                         }
[17:38:28.661]                         else {
[17:38:28.661]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:28.661]                             info, version)
[17:38:28.661]                         }
[17:38:28.661]                         base::stop(msg)
[17:38:28.661]                       }
[17:38:28.661]                     })
[17:38:28.661]                   }
[17:38:28.661]                   ...future.strategy.old <- future::plan("list")
[17:38:28.661]                   options(future.plan = NULL)
[17:38:28.661]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:28.661]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:28.661]                 }
[17:38:28.661]                 ...future.workdir <- getwd()
[17:38:28.661]             }
[17:38:28.661]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:28.661]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:28.661]         }
[17:38:28.661]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:28.661]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:28.661]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:28.661]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:28.661]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:28.661]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:28.661]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:28.661]             base::names(...future.oldOptions))
[17:38:28.661]     }
[17:38:28.661]     if (TRUE) {
[17:38:28.661]     }
[17:38:28.661]     else {
[17:38:28.661]         if (NA) {
[17:38:28.661]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:28.661]                 open = "w")
[17:38:28.661]         }
[17:38:28.661]         else {
[17:38:28.661]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:28.661]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:28.661]         }
[17:38:28.661]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:28.661]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:28.661]             base::sink(type = "output", split = FALSE)
[17:38:28.661]             base::close(...future.stdout)
[17:38:28.661]         }, add = TRUE)
[17:38:28.661]     }
[17:38:28.661]     ...future.frame <- base::sys.nframe()
[17:38:28.661]     ...future.conditions <- base::list()
[17:38:28.661]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:28.661]     if (FALSE) {
[17:38:28.661]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:28.661]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:28.661]     }
[17:38:28.661]     ...future.result <- base::tryCatch({
[17:38:28.661]         base::withCallingHandlers({
[17:38:28.661]             ...future.value <- base::withVisible(base::local({
[17:38:28.661]                 do.call(function(...) {
[17:38:28.661]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:28.661]                   if (!identical(...future.globals.maxSize.org, 
[17:38:28.661]                     ...future.globals.maxSize)) {
[17:38:28.661]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:28.661]                     on.exit(options(oopts), add = TRUE)
[17:38:28.661]                   }
[17:38:28.661]                   {
[17:38:28.661]                     lapply(seq_along(...future.elements_ii), 
[17:38:28.661]                       FUN = function(jj) {
[17:38:28.661]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:28.661]                         ...future.FUN(...future.X_jj, ...)
[17:38:28.661]                       })
[17:38:28.661]                   }
[17:38:28.661]                 }, args = future.call.arguments)
[17:38:28.661]             }))
[17:38:28.661]             future::FutureResult(value = ...future.value$value, 
[17:38:28.661]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:28.661]                   ...future.rng), globalenv = if (FALSE) 
[17:38:28.661]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:28.661]                     ...future.globalenv.names))
[17:38:28.661]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:28.661]         }, condition = base::local({
[17:38:28.661]             c <- base::c
[17:38:28.661]             inherits <- base::inherits
[17:38:28.661]             invokeRestart <- base::invokeRestart
[17:38:28.661]             length <- base::length
[17:38:28.661]             list <- base::list
[17:38:28.661]             seq.int <- base::seq.int
[17:38:28.661]             signalCondition <- base::signalCondition
[17:38:28.661]             sys.calls <- base::sys.calls
[17:38:28.661]             `[[` <- base::`[[`
[17:38:28.661]             `+` <- base::`+`
[17:38:28.661]             `<<-` <- base::`<<-`
[17:38:28.661]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:28.661]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:28.661]                   3L)]
[17:38:28.661]             }
[17:38:28.661]             function(cond) {
[17:38:28.661]                 is_error <- inherits(cond, "error")
[17:38:28.661]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:28.661]                   NULL)
[17:38:28.661]                 if (is_error) {
[17:38:28.661]                   sessionInformation <- function() {
[17:38:28.661]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:28.661]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:28.661]                       search = base::search(), system = base::Sys.info())
[17:38:28.661]                   }
[17:38:28.661]                   ...future.conditions[[length(...future.conditions) + 
[17:38:28.661]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:28.661]                     cond$call), session = sessionInformation(), 
[17:38:28.661]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:28.661]                   signalCondition(cond)
[17:38:28.661]                 }
[17:38:28.661]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:28.661]                 "immediateCondition"))) {
[17:38:28.661]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:28.661]                   ...future.conditions[[length(...future.conditions) + 
[17:38:28.661]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:28.661]                   if (TRUE && !signal) {
[17:38:28.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:28.661]                     {
[17:38:28.661]                       inherits <- base::inherits
[17:38:28.661]                       invokeRestart <- base::invokeRestart
[17:38:28.661]                       is.null <- base::is.null
[17:38:28.661]                       muffled <- FALSE
[17:38:28.661]                       if (inherits(cond, "message")) {
[17:38:28.661]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:28.661]                         if (muffled) 
[17:38:28.661]                           invokeRestart("muffleMessage")
[17:38:28.661]                       }
[17:38:28.661]                       else if (inherits(cond, "warning")) {
[17:38:28.661]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:28.661]                         if (muffled) 
[17:38:28.661]                           invokeRestart("muffleWarning")
[17:38:28.661]                       }
[17:38:28.661]                       else if (inherits(cond, "condition")) {
[17:38:28.661]                         if (!is.null(pattern)) {
[17:38:28.661]                           computeRestarts <- base::computeRestarts
[17:38:28.661]                           grepl <- base::grepl
[17:38:28.661]                           restarts <- computeRestarts(cond)
[17:38:28.661]                           for (restart in restarts) {
[17:38:28.661]                             name <- restart$name
[17:38:28.661]                             if (is.null(name)) 
[17:38:28.661]                               next
[17:38:28.661]                             if (!grepl(pattern, name)) 
[17:38:28.661]                               next
[17:38:28.661]                             invokeRestart(restart)
[17:38:28.661]                             muffled <- TRUE
[17:38:28.661]                             break
[17:38:28.661]                           }
[17:38:28.661]                         }
[17:38:28.661]                       }
[17:38:28.661]                       invisible(muffled)
[17:38:28.661]                     }
[17:38:28.661]                     muffleCondition(cond, pattern = "^muffle")
[17:38:28.661]                   }
[17:38:28.661]                 }
[17:38:28.661]                 else {
[17:38:28.661]                   if (TRUE) {
[17:38:28.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:28.661]                     {
[17:38:28.661]                       inherits <- base::inherits
[17:38:28.661]                       invokeRestart <- base::invokeRestart
[17:38:28.661]                       is.null <- base::is.null
[17:38:28.661]                       muffled <- FALSE
[17:38:28.661]                       if (inherits(cond, "message")) {
[17:38:28.661]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:28.661]                         if (muffled) 
[17:38:28.661]                           invokeRestart("muffleMessage")
[17:38:28.661]                       }
[17:38:28.661]                       else if (inherits(cond, "warning")) {
[17:38:28.661]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:28.661]                         if (muffled) 
[17:38:28.661]                           invokeRestart("muffleWarning")
[17:38:28.661]                       }
[17:38:28.661]                       else if (inherits(cond, "condition")) {
[17:38:28.661]                         if (!is.null(pattern)) {
[17:38:28.661]                           computeRestarts <- base::computeRestarts
[17:38:28.661]                           grepl <- base::grepl
[17:38:28.661]                           restarts <- computeRestarts(cond)
[17:38:28.661]                           for (restart in restarts) {
[17:38:28.661]                             name <- restart$name
[17:38:28.661]                             if (is.null(name)) 
[17:38:28.661]                               next
[17:38:28.661]                             if (!grepl(pattern, name)) 
[17:38:28.661]                               next
[17:38:28.661]                             invokeRestart(restart)
[17:38:28.661]                             muffled <- TRUE
[17:38:28.661]                             break
[17:38:28.661]                           }
[17:38:28.661]                         }
[17:38:28.661]                       }
[17:38:28.661]                       invisible(muffled)
[17:38:28.661]                     }
[17:38:28.661]                     muffleCondition(cond, pattern = "^muffle")
[17:38:28.661]                   }
[17:38:28.661]                 }
[17:38:28.661]             }
[17:38:28.661]         }))
[17:38:28.661]     }, error = function(ex) {
[17:38:28.661]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:28.661]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:28.661]                 ...future.rng), started = ...future.startTime, 
[17:38:28.661]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:28.661]             version = "1.8"), class = "FutureResult")
[17:38:28.661]     }, finally = {
[17:38:28.661]         if (!identical(...future.workdir, getwd())) 
[17:38:28.661]             setwd(...future.workdir)
[17:38:28.661]         {
[17:38:28.661]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:28.661]                 ...future.oldOptions$nwarnings <- NULL
[17:38:28.661]             }
[17:38:28.661]             base::options(...future.oldOptions)
[17:38:28.661]             if (.Platform$OS.type == "windows") {
[17:38:28.661]                 old_names <- names(...future.oldEnvVars)
[17:38:28.661]                 envs <- base::Sys.getenv()
[17:38:28.661]                 names <- names(envs)
[17:38:28.661]                 common <- intersect(names, old_names)
[17:38:28.661]                 added <- setdiff(names, old_names)
[17:38:28.661]                 removed <- setdiff(old_names, names)
[17:38:28.661]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:28.661]                   envs[common]]
[17:38:28.661]                 NAMES <- toupper(changed)
[17:38:28.661]                 args <- list()
[17:38:28.661]                 for (kk in seq_along(NAMES)) {
[17:38:28.661]                   name <- changed[[kk]]
[17:38:28.661]                   NAME <- NAMES[[kk]]
[17:38:28.661]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:28.661]                     next
[17:38:28.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:28.661]                 }
[17:38:28.661]                 NAMES <- toupper(added)
[17:38:28.661]                 for (kk in seq_along(NAMES)) {
[17:38:28.661]                   name <- added[[kk]]
[17:38:28.661]                   NAME <- NAMES[[kk]]
[17:38:28.661]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:28.661]                     next
[17:38:28.661]                   args[[name]] <- ""
[17:38:28.661]                 }
[17:38:28.661]                 NAMES <- toupper(removed)
[17:38:28.661]                 for (kk in seq_along(NAMES)) {
[17:38:28.661]                   name <- removed[[kk]]
[17:38:28.661]                   NAME <- NAMES[[kk]]
[17:38:28.661]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:28.661]                     next
[17:38:28.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:28.661]                 }
[17:38:28.661]                 if (length(args) > 0) 
[17:38:28.661]                   base::do.call(base::Sys.setenv, args = args)
[17:38:28.661]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:28.661]             }
[17:38:28.661]             else {
[17:38:28.661]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:28.661]             }
[17:38:28.661]             {
[17:38:28.661]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:28.661]                   0L) {
[17:38:28.661]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:28.661]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:28.661]                   base::options(opts)
[17:38:28.661]                 }
[17:38:28.661]                 {
[17:38:28.661]                   {
[17:38:28.661]                     NULL
[17:38:28.661]                     RNGkind("Mersenne-Twister")
[17:38:28.661]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:28.661]                       inherits = FALSE)
[17:38:28.661]                   }
[17:38:28.661]                   options(future.plan = NULL)
[17:38:28.661]                   if (is.na(NA_character_)) 
[17:38:28.661]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:28.661]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:28.661]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:28.661]                     .init = FALSE)
[17:38:28.661]                 }
[17:38:28.661]             }
[17:38:28.661]         }
[17:38:28.661]     })
[17:38:28.661]     if (FALSE) {
[17:38:28.661]         base::sink(type = "output", split = FALSE)
[17:38:28.661]         if (NA) {
[17:38:28.661]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:28.661]         }
[17:38:28.661]         else {
[17:38:28.661]             ...future.result["stdout"] <- base::list(NULL)
[17:38:28.661]         }
[17:38:28.661]         base::close(...future.stdout)
[17:38:28.661]         ...future.stdout <- NULL
[17:38:28.661]     }
[17:38:28.661]     ...future.result$conditions <- ...future.conditions
[17:38:28.661]     ...future.result$finished <- base::Sys.time()
[17:38:28.661]     ...future.result
[17:38:28.661] }
[17:38:28.662] assign_globals() ...
[17:38:28.662] List of 5
[17:38:28.662]  $ ...future.FUN            :function (x)  
[17:38:28.662]  $ future.call.arguments    : list()
[17:38:28.662]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:28.662]  $ ...future.elements_ii    :List of 2
[17:38:28.662]   ..$ : int 1
[17:38:28.662]   ..$ : int 0
[17:38:28.662]  $ ...future.seeds_ii       : NULL
[17:38:28.662]  $ ...future.globals.maxSize: NULL
[17:38:28.662]  - attr(*, "where")=List of 5
[17:38:28.662]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:28.662]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:28.662]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:28.662]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:28.662]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:28.662]  - attr(*, "resolved")= logi FALSE
[17:38:28.662]  - attr(*, "total_size")= num 4720
[17:38:28.662]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:28.662]  - attr(*, "already-done")= logi TRUE
[17:38:28.667] - reassign environment for ‘...future.FUN’
[17:38:28.667] - copied ‘...future.FUN’ to environment
[17:38:28.667] - copied ‘future.call.arguments’ to environment
[17:38:28.667] - copied ‘...future.elements_ii’ to environment
[17:38:28.668] - copied ‘...future.seeds_ii’ to environment
[17:38:28.668] - copied ‘...future.globals.maxSize’ to environment
[17:38:28.668] assign_globals() ... done
[17:38:28.668] plan(): Setting new future strategy stack:
[17:38:28.668] List of future strategies:
[17:38:28.668] 1. sequential:
[17:38:28.668]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:28.668]    - tweaked: FALSE
[17:38:28.668]    - call: NULL
[17:38:28.669] plan(): nbrOfWorkers() = 1
[17:38:29.170] plan(): Setting new future strategy stack:
[17:38:29.170] List of future strategies:
[17:38:29.170] 1. multisession:
[17:38:29.170]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:38:29.170]    - tweaked: FALSE
[17:38:29.170]    - call: plan(strategy)
[17:38:29.174] plan(): nbrOfWorkers() = 1
[17:38:29.174] SequentialFuture started (and completed)
[17:38:29.175] - Launch lazy future ... done
[17:38:29.175] run() for ‘SequentialFuture’ ... done
[17:38:29.175] Created future:
[17:38:29.175] SequentialFuture:
[17:38:29.175] Label: ‘future_lapply-1’
[17:38:29.175] Expression:
[17:38:29.175] {
[17:38:29.175]     do.call(function(...) {
[17:38:29.175]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:29.175]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:29.175]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:29.175]             on.exit(options(oopts), add = TRUE)
[17:38:29.175]         }
[17:38:29.175]         {
[17:38:29.175]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:29.175]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:29.175]                 ...future.FUN(...future.X_jj, ...)
[17:38:29.175]             })
[17:38:29.175]         }
[17:38:29.175]     }, args = future.call.arguments)
[17:38:29.175] }
[17:38:29.175] Lazy evaluation: FALSE
[17:38:29.175] Asynchronous evaluation: FALSE
[17:38:29.175] Local evaluation: TRUE
[17:38:29.175] Environment: R_GlobalEnv
[17:38:29.175] Capture standard output: NA
[17:38:29.175] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:29.175] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:29.175] Packages: <none>
[17:38:29.175] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:29.175] Resolved: TRUE
[17:38:29.175] Value: 112 bytes of class ‘list’
[17:38:29.175] Early signaling: FALSE
[17:38:29.175] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:29.175] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:29.176] Chunk #1 of 1 ... DONE
[17:38:29.176] Launching 1 futures (chunks) ... DONE
[17:38:29.176] Resolving 1 futures (chunks) ...
[17:38:29.176] resolve() on list ...
[17:38:29.176]  recursive: 0
[17:38:29.177]  length: 1
[17:38:29.177] 
[17:38:29.177] resolved() for ‘SequentialFuture’ ...
[17:38:29.177] - state: ‘finished’
[17:38:29.177] - run: TRUE
[17:38:29.177] - result: ‘FutureResult’
[17:38:29.177] resolved() for ‘SequentialFuture’ ... done
[17:38:29.177] Future #1
[17:38:29.177] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:29.178] - nx: 1
[17:38:29.178] - relay: TRUE
[17:38:29.178] - stdout: TRUE
[17:38:29.178] - signal: TRUE
[17:38:29.178] - resignal: FALSE
[17:38:29.180] - force: TRUE
[17:38:29.180] - relayed: [n=1] FALSE
[17:38:29.180] - queued futures: [n=1] FALSE
[17:38:29.180]  - until=1
[17:38:29.180]  - relaying element #1
[17:38:29.180] - relayed: [n=1] TRUE
[17:38:29.180] - queued futures: [n=1] TRUE
[17:38:29.181] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:29.181]  length: 0 (resolved future 1)
[17:38:29.181] Relaying remaining futures
[17:38:29.181] signalConditionsASAP(NULL, pos=0) ...
[17:38:29.181] - nx: 1
[17:38:29.181] - relay: TRUE
[17:38:29.181] - stdout: TRUE
[17:38:29.181] - signal: TRUE
[17:38:29.181] - resignal: FALSE
[17:38:29.181] - force: TRUE
[17:38:29.182] - relayed: [n=1] TRUE
[17:38:29.182] - queued futures: [n=1] TRUE
 - flush all
[17:38:29.182] - relayed: [n=1] TRUE
[17:38:29.182] - queued futures: [n=1] TRUE
[17:38:29.182] signalConditionsASAP(NULL, pos=0) ... done
[17:38:29.182] resolve() on list ... DONE
[17:38:29.182]  - Number of value chunks collected: 1
[17:38:29.182] Resolving 1 futures (chunks) ... DONE
[17:38:29.182] Reducing values from 1 chunks ...
[17:38:29.183]  - Number of values collected after concatenation: 2
[17:38:29.183]  - Number of values expected: 2
[17:38:29.183] Reducing values from 1 chunks ... DONE
[17:38:29.183] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[17:38:29.183] future_mapply() ...
[17:38:29.187] Number of chunks: 1
[17:38:29.187] getGlobalsAndPackagesXApply() ...
[17:38:29.187]  - future.globals: TRUE
[17:38:29.187] getGlobalsAndPackages() ...
[17:38:29.187] Searching for globals...
[17:38:29.189] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:38:29.189] Searching for globals ... DONE
[17:38:29.189] Resolving globals: FALSE
[17:38:29.189] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:38:29.190] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:38:29.190] - globals: [1] ‘FUN’
[17:38:29.190] 
[17:38:29.190] getGlobalsAndPackages() ... DONE
[17:38:29.190]  - globals found/used: [n=1] ‘FUN’
[17:38:29.190]  - needed namespaces: [n=0] 
[17:38:29.190] Finding globals ... DONE
[17:38:29.190] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:38:29.191] List of 2
[17:38:29.191]  $ ...future.FUN:function (x, y)  
[17:38:29.191]  $ MoreArgs     : NULL
[17:38:29.191]  - attr(*, "where")=List of 2
[17:38:29.191]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:29.191]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:38:29.191]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:29.191]  - attr(*, "resolved")= logi FALSE
[17:38:29.191]  - attr(*, "total_size")= num NA
[17:38:29.193] Packages to be attached in all futures: [n=0] 
[17:38:29.193] getGlobalsAndPackagesXApply() ... DONE
[17:38:29.193] Number of futures (= number of chunks): 1
[17:38:29.193] Launching 1 futures (chunks) ...
[17:38:29.194] Chunk #1 of 1 ...
[17:38:29.194]  - Finding globals in '...' for chunk #1 ...
[17:38:29.194] getGlobalsAndPackages() ...
[17:38:29.194] Searching for globals...
[17:38:29.194] 
[17:38:29.194] Searching for globals ... DONE
[17:38:29.194] - globals: [0] <none>
[17:38:29.194] getGlobalsAndPackages() ... DONE
[17:38:29.195]    + additional globals found: [n=0] 
[17:38:29.195]    + additional namespaces needed: [n=0] 
[17:38:29.195]  - Finding globals in '...' for chunk #1 ... DONE
[17:38:29.195]  - seeds: <none>
[17:38:29.195]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:29.195] getGlobalsAndPackages() ...
[17:38:29.195] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:29.195] Resolving globals: FALSE
[17:38:29.196] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:38:29.196] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:38:29.196] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:29.196] 
[17:38:29.196] getGlobalsAndPackages() ... DONE
[17:38:29.197] run() for ‘Future’ ...
[17:38:29.197] - state: ‘created’
[17:38:29.197] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:29.201] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:29.201] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:29.201]   - Field: ‘label’
[17:38:29.201]   - Field: ‘local’
[17:38:29.201]   - Field: ‘owner’
[17:38:29.201]   - Field: ‘envir’
[17:38:29.201]   - Field: ‘packages’
[17:38:29.201]   - Field: ‘gc’
[17:38:29.201]   - Field: ‘conditions’
[17:38:29.202]   - Field: ‘expr’
[17:38:29.202]   - Field: ‘uuid’
[17:38:29.202]   - Field: ‘seed’
[17:38:29.202]   - Field: ‘version’
[17:38:29.202]   - Field: ‘result’
[17:38:29.202]   - Field: ‘asynchronous’
[17:38:29.202]   - Field: ‘calls’
[17:38:29.202]   - Field: ‘globals’
[17:38:29.202]   - Field: ‘stdout’
[17:38:29.202]   - Field: ‘earlySignal’
[17:38:29.202]   - Field: ‘lazy’
[17:38:29.202]   - Field: ‘state’
[17:38:29.203] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:29.203] - Launch lazy future ...
[17:38:29.203] Packages needed by the future expression (n = 0): <none>
[17:38:29.203] Packages needed by future strategies (n = 0): <none>
[17:38:29.203] {
[17:38:29.203]     {
[17:38:29.203]         {
[17:38:29.203]             ...future.startTime <- base::Sys.time()
[17:38:29.203]             {
[17:38:29.203]                 {
[17:38:29.203]                   {
[17:38:29.203]                     base::local({
[17:38:29.203]                       has_future <- base::requireNamespace("future", 
[17:38:29.203]                         quietly = TRUE)
[17:38:29.203]                       if (has_future) {
[17:38:29.203]                         ns <- base::getNamespace("future")
[17:38:29.203]                         version <- ns[[".package"]][["version"]]
[17:38:29.203]                         if (is.null(version)) 
[17:38:29.203]                           version <- utils::packageVersion("future")
[17:38:29.203]                       }
[17:38:29.203]                       else {
[17:38:29.203]                         version <- NULL
[17:38:29.203]                       }
[17:38:29.203]                       if (!has_future || version < "1.8.0") {
[17:38:29.203]                         info <- base::c(r_version = base::gsub("R version ", 
[17:38:29.203]                           "", base::R.version$version.string), 
[17:38:29.203]                           platform = base::sprintf("%s (%s-bit)", 
[17:38:29.203]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:29.203]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:29.203]                             "release", "version")], collapse = " "), 
[17:38:29.203]                           hostname = base::Sys.info()[["nodename"]])
[17:38:29.203]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:38:29.203]                           info)
[17:38:29.203]                         info <- base::paste(info, collapse = "; ")
[17:38:29.203]                         if (!has_future) {
[17:38:29.203]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:29.203]                             info)
[17:38:29.203]                         }
[17:38:29.203]                         else {
[17:38:29.203]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:29.203]                             info, version)
[17:38:29.203]                         }
[17:38:29.203]                         base::stop(msg)
[17:38:29.203]                       }
[17:38:29.203]                     })
[17:38:29.203]                   }
[17:38:29.203]                   ...future.strategy.old <- future::plan("list")
[17:38:29.203]                   options(future.plan = NULL)
[17:38:29.203]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:29.203]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:29.203]                 }
[17:38:29.203]                 ...future.workdir <- getwd()
[17:38:29.203]             }
[17:38:29.203]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:29.203]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:29.203]         }
[17:38:29.203]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:29.203]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:29.203]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:29.203]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:29.203]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:29.203]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:29.203]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:29.203]             base::names(...future.oldOptions))
[17:38:29.203]     }
[17:38:29.203]     if (FALSE) {
[17:38:29.203]     }
[17:38:29.203]     else {
[17:38:29.203]         if (FALSE) {
[17:38:29.203]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:29.203]                 open = "w")
[17:38:29.203]         }
[17:38:29.203]         else {
[17:38:29.203]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:29.203]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:29.203]         }
[17:38:29.203]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:29.203]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:29.203]             base::sink(type = "output", split = FALSE)
[17:38:29.203]             base::close(...future.stdout)
[17:38:29.203]         }, add = TRUE)
[17:38:29.203]     }
[17:38:29.203]     ...future.frame <- base::sys.nframe()
[17:38:29.203]     ...future.conditions <- base::list()
[17:38:29.203]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:29.203]     if (FALSE) {
[17:38:29.203]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:29.203]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:29.203]     }
[17:38:29.203]     ...future.result <- base::tryCatch({
[17:38:29.203]         base::withCallingHandlers({
[17:38:29.203]             ...future.value <- base::withVisible(base::local({
[17:38:29.203]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:29.203]                 if (!identical(...future.globals.maxSize.org, 
[17:38:29.203]                   ...future.globals.maxSize)) {
[17:38:29.203]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:29.203]                   on.exit(options(oopts), add = TRUE)
[17:38:29.203]                 }
[17:38:29.203]                 {
[17:38:29.203]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:29.203]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:38:29.203]                     USE.NAMES = FALSE)
[17:38:29.203]                   do.call(mapply, args = args)
[17:38:29.203]                 }
[17:38:29.203]             }))
[17:38:29.203]             future::FutureResult(value = ...future.value$value, 
[17:38:29.203]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:29.203]                   ...future.rng), globalenv = if (FALSE) 
[17:38:29.203]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:29.203]                     ...future.globalenv.names))
[17:38:29.203]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:29.203]         }, condition = base::local({
[17:38:29.203]             c <- base::c
[17:38:29.203]             inherits <- base::inherits
[17:38:29.203]             invokeRestart <- base::invokeRestart
[17:38:29.203]             length <- base::length
[17:38:29.203]             list <- base::list
[17:38:29.203]             seq.int <- base::seq.int
[17:38:29.203]             signalCondition <- base::signalCondition
[17:38:29.203]             sys.calls <- base::sys.calls
[17:38:29.203]             `[[` <- base::`[[`
[17:38:29.203]             `+` <- base::`+`
[17:38:29.203]             `<<-` <- base::`<<-`
[17:38:29.203]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:29.203]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:29.203]                   3L)]
[17:38:29.203]             }
[17:38:29.203]             function(cond) {
[17:38:29.203]                 is_error <- inherits(cond, "error")
[17:38:29.203]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:29.203]                   NULL)
[17:38:29.203]                 if (is_error) {
[17:38:29.203]                   sessionInformation <- function() {
[17:38:29.203]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:29.203]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:29.203]                       search = base::search(), system = base::Sys.info())
[17:38:29.203]                   }
[17:38:29.203]                   ...future.conditions[[length(...future.conditions) + 
[17:38:29.203]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:29.203]                     cond$call), session = sessionInformation(), 
[17:38:29.203]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:29.203]                   signalCondition(cond)
[17:38:29.203]                 }
[17:38:29.203]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:29.203]                 "immediateCondition"))) {
[17:38:29.203]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:29.203]                   ...future.conditions[[length(...future.conditions) + 
[17:38:29.203]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:29.203]                   if (TRUE && !signal) {
[17:38:29.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:29.203]                     {
[17:38:29.203]                       inherits <- base::inherits
[17:38:29.203]                       invokeRestart <- base::invokeRestart
[17:38:29.203]                       is.null <- base::is.null
[17:38:29.203]                       muffled <- FALSE
[17:38:29.203]                       if (inherits(cond, "message")) {
[17:38:29.203]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:29.203]                         if (muffled) 
[17:38:29.203]                           invokeRestart("muffleMessage")
[17:38:29.203]                       }
[17:38:29.203]                       else if (inherits(cond, "warning")) {
[17:38:29.203]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:29.203]                         if (muffled) 
[17:38:29.203]                           invokeRestart("muffleWarning")
[17:38:29.203]                       }
[17:38:29.203]                       else if (inherits(cond, "condition")) {
[17:38:29.203]                         if (!is.null(pattern)) {
[17:38:29.203]                           computeRestarts <- base::computeRestarts
[17:38:29.203]                           grepl <- base::grepl
[17:38:29.203]                           restarts <- computeRestarts(cond)
[17:38:29.203]                           for (restart in restarts) {
[17:38:29.203]                             name <- restart$name
[17:38:29.203]                             if (is.null(name)) 
[17:38:29.203]                               next
[17:38:29.203]                             if (!grepl(pattern, name)) 
[17:38:29.203]                               next
[17:38:29.203]                             invokeRestart(restart)
[17:38:29.203]                             muffled <- TRUE
[17:38:29.203]                             break
[17:38:29.203]                           }
[17:38:29.203]                         }
[17:38:29.203]                       }
[17:38:29.203]                       invisible(muffled)
[17:38:29.203]                     }
[17:38:29.203]                     muffleCondition(cond, pattern = "^muffle")
[17:38:29.203]                   }
[17:38:29.203]                 }
[17:38:29.203]                 else {
[17:38:29.203]                   if (TRUE) {
[17:38:29.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:29.203]                     {
[17:38:29.203]                       inherits <- base::inherits
[17:38:29.203]                       invokeRestart <- base::invokeRestart
[17:38:29.203]                       is.null <- base::is.null
[17:38:29.203]                       muffled <- FALSE
[17:38:29.203]                       if (inherits(cond, "message")) {
[17:38:29.203]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:29.203]                         if (muffled) 
[17:38:29.203]                           invokeRestart("muffleMessage")
[17:38:29.203]                       }
[17:38:29.203]                       else if (inherits(cond, "warning")) {
[17:38:29.203]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:29.203]                         if (muffled) 
[17:38:29.203]                           invokeRestart("muffleWarning")
[17:38:29.203]                       }
[17:38:29.203]                       else if (inherits(cond, "condition")) {
[17:38:29.203]                         if (!is.null(pattern)) {
[17:38:29.203]                           computeRestarts <- base::computeRestarts
[17:38:29.203]                           grepl <- base::grepl
[17:38:29.203]                           restarts <- computeRestarts(cond)
[17:38:29.203]                           for (restart in restarts) {
[17:38:29.203]                             name <- restart$name
[17:38:29.203]                             if (is.null(name)) 
[17:38:29.203]                               next
[17:38:29.203]                             if (!grepl(pattern, name)) 
[17:38:29.203]                               next
[17:38:29.203]                             invokeRestart(restart)
[17:38:29.203]                             muffled <- TRUE
[17:38:29.203]                             break
[17:38:29.203]                           }
[17:38:29.203]                         }
[17:38:29.203]                       }
[17:38:29.203]                       invisible(muffled)
[17:38:29.203]                     }
[17:38:29.203]                     muffleCondition(cond, pattern = "^muffle")
[17:38:29.203]                   }
[17:38:29.203]                 }
[17:38:29.203]             }
[17:38:29.203]         }))
[17:38:29.203]     }, error = function(ex) {
[17:38:29.203]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:29.203]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:29.203]                 ...future.rng), started = ...future.startTime, 
[17:38:29.203]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:29.203]             version = "1.8"), class = "FutureResult")
[17:38:29.203]     }, finally = {
[17:38:29.203]         if (!identical(...future.workdir, getwd())) 
[17:38:29.203]             setwd(...future.workdir)
[17:38:29.203]         {
[17:38:29.203]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:29.203]                 ...future.oldOptions$nwarnings <- NULL
[17:38:29.203]             }
[17:38:29.203]             base::options(...future.oldOptions)
[17:38:29.203]             if (.Platform$OS.type == "windows") {
[17:38:29.203]                 old_names <- names(...future.oldEnvVars)
[17:38:29.203]                 envs <- base::Sys.getenv()
[17:38:29.203]                 names <- names(envs)
[17:38:29.203]                 common <- intersect(names, old_names)
[17:38:29.203]                 added <- setdiff(names, old_names)
[17:38:29.203]                 removed <- setdiff(old_names, names)
[17:38:29.203]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:29.203]                   envs[common]]
[17:38:29.203]                 NAMES <- toupper(changed)
[17:38:29.203]                 args <- list()
[17:38:29.203]                 for (kk in seq_along(NAMES)) {
[17:38:29.203]                   name <- changed[[kk]]
[17:38:29.203]                   NAME <- NAMES[[kk]]
[17:38:29.203]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:29.203]                     next
[17:38:29.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:29.203]                 }
[17:38:29.203]                 NAMES <- toupper(added)
[17:38:29.203]                 for (kk in seq_along(NAMES)) {
[17:38:29.203]                   name <- added[[kk]]
[17:38:29.203]                   NAME <- NAMES[[kk]]
[17:38:29.203]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:29.203]                     next
[17:38:29.203]                   args[[name]] <- ""
[17:38:29.203]                 }
[17:38:29.203]                 NAMES <- toupper(removed)
[17:38:29.203]                 for (kk in seq_along(NAMES)) {
[17:38:29.203]                   name <- removed[[kk]]
[17:38:29.203]                   NAME <- NAMES[[kk]]
[17:38:29.203]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:29.203]                     next
[17:38:29.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:29.203]                 }
[17:38:29.203]                 if (length(args) > 0) 
[17:38:29.203]                   base::do.call(base::Sys.setenv, args = args)
[17:38:29.203]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:29.203]             }
[17:38:29.203]             else {
[17:38:29.203]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:29.203]             }
[17:38:29.203]             {
[17:38:29.203]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:29.203]                   0L) {
[17:38:29.203]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:29.203]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:29.203]                   base::options(opts)
[17:38:29.203]                 }
[17:38:29.203]                 {
[17:38:29.203]                   {
[17:38:29.203]                     NULL
[17:38:29.203]                     RNGkind("Mersenne-Twister")
[17:38:29.203]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:29.203]                       inherits = FALSE)
[17:38:29.203]                   }
[17:38:29.203]                   options(future.plan = NULL)
[17:38:29.203]                   if (is.na(NA_character_)) 
[17:38:29.203]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:29.203]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:29.203]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:29.203]                     .init = FALSE)
[17:38:29.203]                 }
[17:38:29.203]             }
[17:38:29.203]         }
[17:38:29.203]     })
[17:38:29.203]     if (TRUE) {
[17:38:29.203]         base::sink(type = "output", split = FALSE)
[17:38:29.203]         if (FALSE) {
[17:38:29.203]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:29.203]         }
[17:38:29.203]         else {
[17:38:29.203]             ...future.result["stdout"] <- base::list(NULL)
[17:38:29.203]         }
[17:38:29.203]         base::close(...future.stdout)
[17:38:29.203]         ...future.stdout <- NULL
[17:38:29.203]     }
[17:38:29.203]     ...future.result$conditions <- ...future.conditions
[17:38:29.203]     ...future.result$finished <- base::Sys.time()
[17:38:29.203]     ...future.result
[17:38:29.203] }
[17:38:29.205] assign_globals() ...
[17:38:29.205] List of 5
[17:38:29.205]  $ ...future.FUN            :function (x, y)  
[17:38:29.205]  $ MoreArgs                 : NULL
[17:38:29.205]  $ ...future.elements_ii    :List of 2
[17:38:29.205]   ..$ :List of 2
[17:38:29.205]   .. ..$ : int 1
[17:38:29.205]   .. ..$ : int 0
[17:38:29.205]   ..$ :List of 2
[17:38:29.205]   .. ..$ : int 0
[17:38:29.205]   .. ..$ : int 1
[17:38:29.205]  $ ...future.seeds_ii       : NULL
[17:38:29.205]  $ ...future.globals.maxSize: NULL
[17:38:29.205]  - attr(*, "where")=List of 5
[17:38:29.205]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:29.205]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:38:29.205]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:29.205]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:29.205]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:29.205]  - attr(*, "resolved")= logi FALSE
[17:38:29.205]  - attr(*, "total_size")= num 6480
[17:38:29.205]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:29.205]  - attr(*, "already-done")= logi TRUE
[17:38:29.211] - reassign environment for ‘...future.FUN’
[17:38:29.212] - copied ‘...future.FUN’ to environment
[17:38:29.213] - copied ‘MoreArgs’ to environment
[17:38:29.213] - copied ‘...future.elements_ii’ to environment
[17:38:29.213] - copied ‘...future.seeds_ii’ to environment
[17:38:29.213] - copied ‘...future.globals.maxSize’ to environment
[17:38:29.213] assign_globals() ... done
[17:38:29.213] plan(): Setting new future strategy stack:
[17:38:29.214] List of future strategies:
[17:38:29.214] 1. sequential:
[17:38:29.214]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:29.214]    - tweaked: FALSE
[17:38:29.214]    - call: NULL
[17:38:29.214] plan(): nbrOfWorkers() = 1
[17:38:29.716] plan(): Setting new future strategy stack:
[17:38:29.716] List of future strategies:
[17:38:29.716] 1. multisession:
[17:38:29.716]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:38:29.716]    - tweaked: FALSE
[17:38:29.716]    - call: plan(strategy)
[17:38:29.720] plan(): nbrOfWorkers() = 1
[17:38:29.720] SequentialFuture started (and completed)
[17:38:29.720] - Launch lazy future ... done
[17:38:29.721] run() for ‘SequentialFuture’ ... done
[17:38:29.721] Created future:
[17:38:29.721] SequentialFuture:
[17:38:29.721] Label: ‘future_mapply-1’
[17:38:29.721] Expression:
[17:38:29.721] {
[17:38:29.721]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:29.721]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:29.721]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:29.721]         on.exit(options(oopts), add = TRUE)
[17:38:29.721]     }
[17:38:29.721]     {
[17:38:29.721]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:29.721]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:38:29.721]         do.call(mapply, args = args)
[17:38:29.721]     }
[17:38:29.721] }
[17:38:29.721] Lazy evaluation: FALSE
[17:38:29.721] Asynchronous evaluation: FALSE
[17:38:29.721] Local evaluation: TRUE
[17:38:29.721] Environment: R_GlobalEnv
[17:38:29.721] Capture standard output: FALSE
[17:38:29.721] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:29.721] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:29.721] Packages: <none>
[17:38:29.721] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:29.721] Resolved: TRUE
[17:38:29.721] Value: 224 bytes of class ‘list’
[17:38:29.721] Early signaling: FALSE
[17:38:29.721] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:29.721] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:29.722] Chunk #1 of 1 ... DONE
[17:38:29.722] Launching 1 futures (chunks) ... DONE
[17:38:29.722] Resolving 1 futures (chunks) ...
[17:38:29.722] resolve() on list ...
[17:38:29.722]  recursive: 0
[17:38:29.722]  length: 1
[17:38:29.722] 
[17:38:29.723] resolved() for ‘SequentialFuture’ ...
[17:38:29.723] - state: ‘finished’
[17:38:29.723] - run: TRUE
[17:38:29.723] - result: ‘FutureResult’
[17:38:29.723] resolved() for ‘SequentialFuture’ ... done
[17:38:29.723] Future #1
[17:38:29.723] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:29.723] - nx: 1
[17:38:29.723] - relay: TRUE
[17:38:29.724] - stdout: TRUE
[17:38:29.724] - signal: TRUE
[17:38:29.724] - resignal: FALSE
[17:38:29.724] - force: TRUE
[17:38:29.724] - relayed: [n=1] FALSE
[17:38:29.724] - queued futures: [n=1] FALSE
[17:38:29.724]  - until=1
[17:38:29.724]  - relaying element #1
[17:38:29.724] - relayed: [n=1] TRUE
[17:38:29.724] - queued futures: [n=1] TRUE
[17:38:29.725] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:29.725]  length: 0 (resolved future 1)
[17:38:29.725] Relaying remaining futures
[17:38:29.725] signalConditionsASAP(NULL, pos=0) ...
[17:38:29.725] - nx: 1
[17:38:29.725] - relay: TRUE
[17:38:29.725] - stdout: TRUE
[17:38:29.725] - signal: TRUE
[17:38:29.725] - resignal: FALSE
[17:38:29.725] - force: TRUE
[17:38:29.725] - relayed: [n=1] TRUE
[17:38:29.726] - queued futures: [n=1] TRUE
 - flush all
[17:38:29.726] - relayed: [n=1] TRUE
[17:38:29.726] - queued futures: [n=1] TRUE
[17:38:29.726] signalConditionsASAP(NULL, pos=0) ... done
[17:38:29.726] resolve() on list ... DONE
[17:38:29.726]  - Number of value chunks collected: 1
[17:38:29.726] Resolving 1 futures (chunks) ... DONE
[17:38:29.726] Reducing values from 1 chunks ...
[17:38:29.726]  - Number of values collected after concatenation: 2
[17:38:29.727]  - Number of values expected: 2
[17:38:29.727] Reducing values from 1 chunks ... DONE
[17:38:29.727] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[17:38:29.727] future_mapply() ...
[17:38:29.730] Number of chunks: 1
[17:38:29.731] getGlobalsAndPackagesXApply() ...
[17:38:29.731]  - future.globals: TRUE
[17:38:29.731] getGlobalsAndPackages() ...
[17:38:29.731] Searching for globals...
[17:38:29.733] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:38:29.733] Searching for globals ... DONE
[17:38:29.733] Resolving globals: FALSE
[17:38:29.733] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:38:29.734] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:38:29.734] - globals: [1] ‘FUN’
[17:38:29.734] 
[17:38:29.734] getGlobalsAndPackages() ... DONE
[17:38:29.734]  - globals found/used: [n=1] ‘FUN’
[17:38:29.734]  - needed namespaces: [n=0] 
[17:38:29.734] Finding globals ... DONE
[17:38:29.734] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:38:29.735] List of 2
[17:38:29.735]  $ ...future.FUN:function (x, y)  
[17:38:29.735]  $ MoreArgs     : NULL
[17:38:29.735]  - attr(*, "where")=List of 2
[17:38:29.735]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:29.735]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:38:29.735]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:29.735]  - attr(*, "resolved")= logi FALSE
[17:38:29.735]  - attr(*, "total_size")= num NA
[17:38:29.737] Packages to be attached in all futures: [n=0] 
[17:38:29.738] getGlobalsAndPackagesXApply() ... DONE
[17:38:29.738] Number of futures (= number of chunks): 1
[17:38:29.738] Launching 1 futures (chunks) ...
[17:38:29.738] Chunk #1 of 1 ...
[17:38:29.738]  - Finding globals in '...' for chunk #1 ...
[17:38:29.738] getGlobalsAndPackages() ...
[17:38:29.738] Searching for globals...
[17:38:29.739] 
[17:38:29.739] Searching for globals ... DONE
[17:38:29.739] - globals: [0] <none>
[17:38:29.739] getGlobalsAndPackages() ... DONE
[17:38:29.739]    + additional globals found: [n=0] 
[17:38:29.739]    + additional namespaces needed: [n=0] 
[17:38:29.739]  - Finding globals in '...' for chunk #1 ... DONE
[17:38:29.739]  - seeds: <none>
[17:38:29.739]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:29.739] getGlobalsAndPackages() ...
[17:38:29.740] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:29.740] Resolving globals: FALSE
[17:38:29.740] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:38:29.741] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:38:29.741] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:29.741] 
[17:38:29.741] getGlobalsAndPackages() ... DONE
[17:38:29.741] run() for ‘Future’ ...
[17:38:29.741] - state: ‘created’
[17:38:29.742] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:29.745] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:29.745] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:29.746]   - Field: ‘label’
[17:38:29.746]   - Field: ‘local’
[17:38:29.746]   - Field: ‘owner’
[17:38:29.746]   - Field: ‘envir’
[17:38:29.746]   - Field: ‘packages’
[17:38:29.746]   - Field: ‘gc’
[17:38:29.746]   - Field: ‘conditions’
[17:38:29.746]   - Field: ‘expr’
[17:38:29.746]   - Field: ‘uuid’
[17:38:29.746]   - Field: ‘seed’
[17:38:29.747]   - Field: ‘version’
[17:38:29.747]   - Field: ‘result’
[17:38:29.747]   - Field: ‘asynchronous’
[17:38:29.747]   - Field: ‘calls’
[17:38:29.747]   - Field: ‘globals’
[17:38:29.747]   - Field: ‘stdout’
[17:38:29.747]   - Field: ‘earlySignal’
[17:38:29.747]   - Field: ‘lazy’
[17:38:29.747]   - Field: ‘state’
[17:38:29.747] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:29.748] - Launch lazy future ...
[17:38:29.748] Packages needed by the future expression (n = 0): <none>
[17:38:29.748] Packages needed by future strategies (n = 0): <none>
[17:38:29.748] {
[17:38:29.748]     {
[17:38:29.748]         {
[17:38:29.748]             ...future.startTime <- base::Sys.time()
[17:38:29.748]             {
[17:38:29.748]                 {
[17:38:29.748]                   {
[17:38:29.748]                     base::local({
[17:38:29.748]                       has_future <- base::requireNamespace("future", 
[17:38:29.748]                         quietly = TRUE)
[17:38:29.748]                       if (has_future) {
[17:38:29.748]                         ns <- base::getNamespace("future")
[17:38:29.748]                         version <- ns[[".package"]][["version"]]
[17:38:29.748]                         if (is.null(version)) 
[17:38:29.748]                           version <- utils::packageVersion("future")
[17:38:29.748]                       }
[17:38:29.748]                       else {
[17:38:29.748]                         version <- NULL
[17:38:29.748]                       }
[17:38:29.748]                       if (!has_future || version < "1.8.0") {
[17:38:29.748]                         info <- base::c(r_version = base::gsub("R version ", 
[17:38:29.748]                           "", base::R.version$version.string), 
[17:38:29.748]                           platform = base::sprintf("%s (%s-bit)", 
[17:38:29.748]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:29.748]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:29.748]                             "release", "version")], collapse = " "), 
[17:38:29.748]                           hostname = base::Sys.info()[["nodename"]])
[17:38:29.748]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:38:29.748]                           info)
[17:38:29.748]                         info <- base::paste(info, collapse = "; ")
[17:38:29.748]                         if (!has_future) {
[17:38:29.748]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:29.748]                             info)
[17:38:29.748]                         }
[17:38:29.748]                         else {
[17:38:29.748]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:29.748]                             info, version)
[17:38:29.748]                         }
[17:38:29.748]                         base::stop(msg)
[17:38:29.748]                       }
[17:38:29.748]                     })
[17:38:29.748]                   }
[17:38:29.748]                   ...future.strategy.old <- future::plan("list")
[17:38:29.748]                   options(future.plan = NULL)
[17:38:29.748]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:29.748]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:29.748]                 }
[17:38:29.748]                 ...future.workdir <- getwd()
[17:38:29.748]             }
[17:38:29.748]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:29.748]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:29.748]         }
[17:38:29.748]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:29.748]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:29.748]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:29.748]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:29.748]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:29.748]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:29.748]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:29.748]             base::names(...future.oldOptions))
[17:38:29.748]     }
[17:38:29.748]     if (FALSE) {
[17:38:29.748]     }
[17:38:29.748]     else {
[17:38:29.748]         if (TRUE) {
[17:38:29.748]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:29.748]                 open = "w")
[17:38:29.748]         }
[17:38:29.748]         else {
[17:38:29.748]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:29.748]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:29.748]         }
[17:38:29.748]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:29.748]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:29.748]             base::sink(type = "output", split = FALSE)
[17:38:29.748]             base::close(...future.stdout)
[17:38:29.748]         }, add = TRUE)
[17:38:29.748]     }
[17:38:29.748]     ...future.frame <- base::sys.nframe()
[17:38:29.748]     ...future.conditions <- base::list()
[17:38:29.748]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:29.748]     if (FALSE) {
[17:38:29.748]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:29.748]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:29.748]     }
[17:38:29.748]     ...future.result <- base::tryCatch({
[17:38:29.748]         base::withCallingHandlers({
[17:38:29.748]             ...future.value <- base::withVisible(base::local({
[17:38:29.748]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:29.748]                 if (!identical(...future.globals.maxSize.org, 
[17:38:29.748]                   ...future.globals.maxSize)) {
[17:38:29.748]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:29.748]                   on.exit(options(oopts), add = TRUE)
[17:38:29.748]                 }
[17:38:29.748]                 {
[17:38:29.748]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:29.748]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:38:29.748]                     USE.NAMES = FALSE)
[17:38:29.748]                   do.call(mapply, args = args)
[17:38:29.748]                 }
[17:38:29.748]             }))
[17:38:29.748]             future::FutureResult(value = ...future.value$value, 
[17:38:29.748]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:29.748]                   ...future.rng), globalenv = if (FALSE) 
[17:38:29.748]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:29.748]                     ...future.globalenv.names))
[17:38:29.748]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:29.748]         }, condition = base::local({
[17:38:29.748]             c <- base::c
[17:38:29.748]             inherits <- base::inherits
[17:38:29.748]             invokeRestart <- base::invokeRestart
[17:38:29.748]             length <- base::length
[17:38:29.748]             list <- base::list
[17:38:29.748]             seq.int <- base::seq.int
[17:38:29.748]             signalCondition <- base::signalCondition
[17:38:29.748]             sys.calls <- base::sys.calls
[17:38:29.748]             `[[` <- base::`[[`
[17:38:29.748]             `+` <- base::`+`
[17:38:29.748]             `<<-` <- base::`<<-`
[17:38:29.748]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:29.748]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:29.748]                   3L)]
[17:38:29.748]             }
[17:38:29.748]             function(cond) {
[17:38:29.748]                 is_error <- inherits(cond, "error")
[17:38:29.748]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:29.748]                   NULL)
[17:38:29.748]                 if (is_error) {
[17:38:29.748]                   sessionInformation <- function() {
[17:38:29.748]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:29.748]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:29.748]                       search = base::search(), system = base::Sys.info())
[17:38:29.748]                   }
[17:38:29.748]                   ...future.conditions[[length(...future.conditions) + 
[17:38:29.748]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:29.748]                     cond$call), session = sessionInformation(), 
[17:38:29.748]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:29.748]                   signalCondition(cond)
[17:38:29.748]                 }
[17:38:29.748]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:29.748]                 "immediateCondition"))) {
[17:38:29.748]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:29.748]                   ...future.conditions[[length(...future.conditions) + 
[17:38:29.748]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:29.748]                   if (TRUE && !signal) {
[17:38:29.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:29.748]                     {
[17:38:29.748]                       inherits <- base::inherits
[17:38:29.748]                       invokeRestart <- base::invokeRestart
[17:38:29.748]                       is.null <- base::is.null
[17:38:29.748]                       muffled <- FALSE
[17:38:29.748]                       if (inherits(cond, "message")) {
[17:38:29.748]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:29.748]                         if (muffled) 
[17:38:29.748]                           invokeRestart("muffleMessage")
[17:38:29.748]                       }
[17:38:29.748]                       else if (inherits(cond, "warning")) {
[17:38:29.748]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:29.748]                         if (muffled) 
[17:38:29.748]                           invokeRestart("muffleWarning")
[17:38:29.748]                       }
[17:38:29.748]                       else if (inherits(cond, "condition")) {
[17:38:29.748]                         if (!is.null(pattern)) {
[17:38:29.748]                           computeRestarts <- base::computeRestarts
[17:38:29.748]                           grepl <- base::grepl
[17:38:29.748]                           restarts <- computeRestarts(cond)
[17:38:29.748]                           for (restart in restarts) {
[17:38:29.748]                             name <- restart$name
[17:38:29.748]                             if (is.null(name)) 
[17:38:29.748]                               next
[17:38:29.748]                             if (!grepl(pattern, name)) 
[17:38:29.748]                               next
[17:38:29.748]                             invokeRestart(restart)
[17:38:29.748]                             muffled <- TRUE
[17:38:29.748]                             break
[17:38:29.748]                           }
[17:38:29.748]                         }
[17:38:29.748]                       }
[17:38:29.748]                       invisible(muffled)
[17:38:29.748]                     }
[17:38:29.748]                     muffleCondition(cond, pattern = "^muffle")
[17:38:29.748]                   }
[17:38:29.748]                 }
[17:38:29.748]                 else {
[17:38:29.748]                   if (TRUE) {
[17:38:29.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:29.748]                     {
[17:38:29.748]                       inherits <- base::inherits
[17:38:29.748]                       invokeRestart <- base::invokeRestart
[17:38:29.748]                       is.null <- base::is.null
[17:38:29.748]                       muffled <- FALSE
[17:38:29.748]                       if (inherits(cond, "message")) {
[17:38:29.748]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:29.748]                         if (muffled) 
[17:38:29.748]                           invokeRestart("muffleMessage")
[17:38:29.748]                       }
[17:38:29.748]                       else if (inherits(cond, "warning")) {
[17:38:29.748]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:29.748]                         if (muffled) 
[17:38:29.748]                           invokeRestart("muffleWarning")
[17:38:29.748]                       }
[17:38:29.748]                       else if (inherits(cond, "condition")) {
[17:38:29.748]                         if (!is.null(pattern)) {
[17:38:29.748]                           computeRestarts <- base::computeRestarts
[17:38:29.748]                           grepl <- base::grepl
[17:38:29.748]                           restarts <- computeRestarts(cond)
[17:38:29.748]                           for (restart in restarts) {
[17:38:29.748]                             name <- restart$name
[17:38:29.748]                             if (is.null(name)) 
[17:38:29.748]                               next
[17:38:29.748]                             if (!grepl(pattern, name)) 
[17:38:29.748]                               next
[17:38:29.748]                             invokeRestart(restart)
[17:38:29.748]                             muffled <- TRUE
[17:38:29.748]                             break
[17:38:29.748]                           }
[17:38:29.748]                         }
[17:38:29.748]                       }
[17:38:29.748]                       invisible(muffled)
[17:38:29.748]                     }
[17:38:29.748]                     muffleCondition(cond, pattern = "^muffle")
[17:38:29.748]                   }
[17:38:29.748]                 }
[17:38:29.748]             }
[17:38:29.748]         }))
[17:38:29.748]     }, error = function(ex) {
[17:38:29.748]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:29.748]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:29.748]                 ...future.rng), started = ...future.startTime, 
[17:38:29.748]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:29.748]             version = "1.8"), class = "FutureResult")
[17:38:29.748]     }, finally = {
[17:38:29.748]         if (!identical(...future.workdir, getwd())) 
[17:38:29.748]             setwd(...future.workdir)
[17:38:29.748]         {
[17:38:29.748]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:29.748]                 ...future.oldOptions$nwarnings <- NULL
[17:38:29.748]             }
[17:38:29.748]             base::options(...future.oldOptions)
[17:38:29.748]             if (.Platform$OS.type == "windows") {
[17:38:29.748]                 old_names <- names(...future.oldEnvVars)
[17:38:29.748]                 envs <- base::Sys.getenv()
[17:38:29.748]                 names <- names(envs)
[17:38:29.748]                 common <- intersect(names, old_names)
[17:38:29.748]                 added <- setdiff(names, old_names)
[17:38:29.748]                 removed <- setdiff(old_names, names)
[17:38:29.748]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:29.748]                   envs[common]]
[17:38:29.748]                 NAMES <- toupper(changed)
[17:38:29.748]                 args <- list()
[17:38:29.748]                 for (kk in seq_along(NAMES)) {
[17:38:29.748]                   name <- changed[[kk]]
[17:38:29.748]                   NAME <- NAMES[[kk]]
[17:38:29.748]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:29.748]                     next
[17:38:29.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:29.748]                 }
[17:38:29.748]                 NAMES <- toupper(added)
[17:38:29.748]                 for (kk in seq_along(NAMES)) {
[17:38:29.748]                   name <- added[[kk]]
[17:38:29.748]                   NAME <- NAMES[[kk]]
[17:38:29.748]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:29.748]                     next
[17:38:29.748]                   args[[name]] <- ""
[17:38:29.748]                 }
[17:38:29.748]                 NAMES <- toupper(removed)
[17:38:29.748]                 for (kk in seq_along(NAMES)) {
[17:38:29.748]                   name <- removed[[kk]]
[17:38:29.748]                   NAME <- NAMES[[kk]]
[17:38:29.748]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:29.748]                     next
[17:38:29.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:29.748]                 }
[17:38:29.748]                 if (length(args) > 0) 
[17:38:29.748]                   base::do.call(base::Sys.setenv, args = args)
[17:38:29.748]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:29.748]             }
[17:38:29.748]             else {
[17:38:29.748]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:29.748]             }
[17:38:29.748]             {
[17:38:29.748]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:29.748]                   0L) {
[17:38:29.748]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:29.748]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:29.748]                   base::options(opts)
[17:38:29.748]                 }
[17:38:29.748]                 {
[17:38:29.748]                   {
[17:38:29.748]                     NULL
[17:38:29.748]                     RNGkind("Mersenne-Twister")
[17:38:29.748]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:29.748]                       inherits = FALSE)
[17:38:29.748]                   }
[17:38:29.748]                   options(future.plan = NULL)
[17:38:29.748]                   if (is.na(NA_character_)) 
[17:38:29.748]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:29.748]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:29.748]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:29.748]                     .init = FALSE)
[17:38:29.748]                 }
[17:38:29.748]             }
[17:38:29.748]         }
[17:38:29.748]     })
[17:38:29.748]     if (TRUE) {
[17:38:29.748]         base::sink(type = "output", split = FALSE)
[17:38:29.748]         if (TRUE) {
[17:38:29.748]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:29.748]         }
[17:38:29.748]         else {
[17:38:29.748]             ...future.result["stdout"] <- base::list(NULL)
[17:38:29.748]         }
[17:38:29.748]         base::close(...future.stdout)
[17:38:29.748]         ...future.stdout <- NULL
[17:38:29.748]     }
[17:38:29.748]     ...future.result$conditions <- ...future.conditions
[17:38:29.748]     ...future.result$finished <- base::Sys.time()
[17:38:29.748]     ...future.result
[17:38:29.748] }
[17:38:29.752] assign_globals() ...
[17:38:29.752] List of 5
[17:38:29.752]  $ ...future.FUN            :function (x, y)  
[17:38:29.752]  $ MoreArgs                 : NULL
[17:38:29.752]  $ ...future.elements_ii    :List of 2
[17:38:29.752]   ..$ :List of 2
[17:38:29.752]   .. ..$ : int 1
[17:38:29.752]   .. ..$ : int 0
[17:38:29.752]   ..$ :List of 2
[17:38:29.752]   .. ..$ : int 0
[17:38:29.752]   .. ..$ : int 1
[17:38:29.752]  $ ...future.seeds_ii       : NULL
[17:38:29.752]  $ ...future.globals.maxSize: NULL
[17:38:29.752]  - attr(*, "where")=List of 5
[17:38:29.752]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:29.752]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:38:29.752]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:29.752]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:29.752]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:29.752]  - attr(*, "resolved")= logi FALSE
[17:38:29.752]  - attr(*, "total_size")= num 6480
[17:38:29.752]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:29.752]  - attr(*, "already-done")= logi TRUE
[17:38:29.758] - reassign environment for ‘...future.FUN’
[17:38:29.758] - copied ‘...future.FUN’ to environment
[17:38:29.758] - copied ‘MoreArgs’ to environment
[17:38:29.758] - copied ‘...future.elements_ii’ to environment
[17:38:29.758] - copied ‘...future.seeds_ii’ to environment
[17:38:29.759] - copied ‘...future.globals.maxSize’ to environment
[17:38:29.759] assign_globals() ... done
[17:38:29.759] plan(): Setting new future strategy stack:
[17:38:29.759] List of future strategies:
[17:38:29.759] 1. sequential:
[17:38:29.759]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:29.759]    - tweaked: FALSE
[17:38:29.759]    - call: NULL
[17:38:29.759] plan(): nbrOfWorkers() = 1
[17:38:30.261] plan(): Setting new future strategy stack:
[17:38:30.261] List of future strategies:
[17:38:30.261] 1. multisession:
[17:38:30.261]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:38:30.261]    - tweaked: FALSE
[17:38:30.261]    - call: plan(strategy)
[17:38:30.266] plan(): nbrOfWorkers() = 1
[17:38:30.266] SequentialFuture started (and completed)
[17:38:30.266] - Launch lazy future ... done
[17:38:30.266] run() for ‘SequentialFuture’ ... done
[17:38:30.266] Created future:
[17:38:30.266] SequentialFuture:
[17:38:30.266] Label: ‘future_mapply-1’
[17:38:30.266] Expression:
[17:38:30.266] {
[17:38:30.266]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:30.266]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:30.266]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:30.266]         on.exit(options(oopts), add = TRUE)
[17:38:30.266]     }
[17:38:30.266]     {
[17:38:30.266]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:30.266]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:38:30.266]         do.call(mapply, args = args)
[17:38:30.266]     }
[17:38:30.266] }
[17:38:30.266] Lazy evaluation: FALSE
[17:38:30.266] Asynchronous evaluation: FALSE
[17:38:30.266] Local evaluation: TRUE
[17:38:30.266] Environment: R_GlobalEnv
[17:38:30.266] Capture standard output: TRUE
[17:38:30.266] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:30.266] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:30.266] Packages: <none>
[17:38:30.266] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:30.266] Resolved: TRUE
[17:38:30.266] Value: 224 bytes of class ‘list’
[17:38:30.266] Early signaling: FALSE
[17:38:30.266] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:30.266] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:30.267] Chunk #1 of 1 ... DONE
[17:38:30.267] Launching 1 futures (chunks) ... DONE
[17:38:30.267] Resolving 1 futures (chunks) ...
[17:38:30.268] resolve() on list ...
[17:38:30.268]  recursive: 0
[17:38:30.268]  length: 1
[17:38:30.268] 
[17:38:30.268] resolved() for ‘SequentialFuture’ ...
[17:38:30.268] - state: ‘finished’
[17:38:30.268] - run: TRUE
[17:38:30.268] - result: ‘FutureResult’
[17:38:30.268] resolved() for ‘SequentialFuture’ ... done
[17:38:30.268] Future #1
[17:38:30.269] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:30.269] - nx: 1
[17:38:30.269] - relay: TRUE
[17:38:30.269] - stdout: TRUE
[17:38:30.269] - signal: TRUE
[17:38:30.269] - resignal: FALSE
[17:38:30.269] - force: TRUE
[17:38:30.269] - relayed: [n=1] FALSE
[17:38:30.269] - queued futures: [n=1] FALSE
[17:38:30.269]  - until=1
[17:38:30.269]  - relaying element #1
[17:38:30.270] - relayed: [n=1] TRUE
[17:38:30.270] - queued futures: [n=1] TRUE
[17:38:30.270] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:30.270]  length: 0 (resolved future 1)
[17:38:30.270] Relaying remaining futures
[17:38:30.270] signalConditionsASAP(NULL, pos=0) ...
[17:38:30.270] - nx: 1
[17:38:30.270] - relay: TRUE
[17:38:30.270] - stdout: TRUE
[17:38:30.270] - signal: TRUE
[17:38:30.271] - resignal: FALSE
[17:38:30.271] - force: TRUE
[17:38:30.271] - relayed: [n=1] TRUE
[17:38:30.271] - queued futures: [n=1] TRUE
 - flush all
[17:38:30.271] - relayed: [n=1] TRUE
[17:38:30.271] - queued futures: [n=1] TRUE
[17:38:30.271] signalConditionsASAP(NULL, pos=0) ... done
[17:38:30.271] resolve() on list ... DONE
[17:38:30.271]  - Number of value chunks collected: 1
[17:38:30.271] Resolving 1 futures (chunks) ... DONE
[17:38:30.271] Reducing values from 1 chunks ...
[17:38:30.272]  - Number of values collected after concatenation: 2
[17:38:30.272]  - Number of values expected: 2
[17:38:30.272] Reducing values from 1 chunks ... DONE
[17:38:30.272] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[17:38:30.272] future_mapply() ...
[17:38:30.275] Number of chunks: 1
[17:38:30.276] getGlobalsAndPackagesXApply() ...
[17:38:30.276]  - future.globals: TRUE
[17:38:30.276] getGlobalsAndPackages() ...
[17:38:30.276] Searching for globals...
[17:38:30.277] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:38:30.278] Searching for globals ... DONE
[17:38:30.278] Resolving globals: FALSE
[17:38:30.278] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:38:30.278] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:38:30.279] - globals: [1] ‘FUN’
[17:38:30.279] 
[17:38:30.279] getGlobalsAndPackages() ... DONE
[17:38:30.279]  - globals found/used: [n=1] ‘FUN’
[17:38:30.279]  - needed namespaces: [n=0] 
[17:38:30.279] Finding globals ... DONE
[17:38:30.279] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:38:30.279] List of 2
[17:38:30.279]  $ ...future.FUN:function (x, y)  
[17:38:30.279]  $ MoreArgs     : NULL
[17:38:30.279]  - attr(*, "where")=List of 2
[17:38:30.279]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:30.279]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:38:30.279]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:30.279]  - attr(*, "resolved")= logi FALSE
[17:38:30.279]  - attr(*, "total_size")= num NA
[17:38:30.282] Packages to be attached in all futures: [n=0] 
[17:38:30.282] getGlobalsAndPackagesXApply() ... DONE
[17:38:30.282] Number of futures (= number of chunks): 1
[17:38:30.282] Launching 1 futures (chunks) ...
[17:38:30.282] Chunk #1 of 1 ...
[17:38:30.282]  - Finding globals in '...' for chunk #1 ...
[17:38:30.283] getGlobalsAndPackages() ...
[17:38:30.283] Searching for globals...
[17:38:30.283] 
[17:38:30.283] Searching for globals ... DONE
[17:38:30.283] - globals: [0] <none>
[17:38:30.285] getGlobalsAndPackages() ... DONE
[17:38:30.285]    + additional globals found: [n=0] 
[17:38:30.285]    + additional namespaces needed: [n=0] 
[17:38:30.285]  - Finding globals in '...' for chunk #1 ... DONE
[17:38:30.285]  - seeds: <none>
[17:38:30.285]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:30.286] getGlobalsAndPackages() ...
[17:38:30.286] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:30.286] Resolving globals: FALSE
[17:38:30.286] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:38:30.287] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:38:30.287] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:30.287] 
[17:38:30.287] getGlobalsAndPackages() ... DONE
[17:38:30.287] run() for ‘Future’ ...
[17:38:30.288] - state: ‘created’
[17:38:30.288] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:30.291] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:30.291] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:30.291]   - Field: ‘label’
[17:38:30.292]   - Field: ‘local’
[17:38:30.292]   - Field: ‘owner’
[17:38:30.292]   - Field: ‘envir’
[17:38:30.292]   - Field: ‘packages’
[17:38:30.292]   - Field: ‘gc’
[17:38:30.292]   - Field: ‘conditions’
[17:38:30.292]   - Field: ‘expr’
[17:38:30.292]   - Field: ‘uuid’
[17:38:30.292]   - Field: ‘seed’
[17:38:30.292]   - Field: ‘version’
[17:38:30.293]   - Field: ‘result’
[17:38:30.293]   - Field: ‘asynchronous’
[17:38:30.293]   - Field: ‘calls’
[17:38:30.293]   - Field: ‘globals’
[17:38:30.293]   - Field: ‘stdout’
[17:38:30.293]   - Field: ‘earlySignal’
[17:38:30.293]   - Field: ‘lazy’
[17:38:30.293]   - Field: ‘state’
[17:38:30.293] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:30.293] - Launch lazy future ...
[17:38:30.294] Packages needed by the future expression (n = 0): <none>
[17:38:30.294] Packages needed by future strategies (n = 0): <none>
[17:38:30.294] {
[17:38:30.294]     {
[17:38:30.294]         {
[17:38:30.294]             ...future.startTime <- base::Sys.time()
[17:38:30.294]             {
[17:38:30.294]                 {
[17:38:30.294]                   {
[17:38:30.294]                     base::local({
[17:38:30.294]                       has_future <- base::requireNamespace("future", 
[17:38:30.294]                         quietly = TRUE)
[17:38:30.294]                       if (has_future) {
[17:38:30.294]                         ns <- base::getNamespace("future")
[17:38:30.294]                         version <- ns[[".package"]][["version"]]
[17:38:30.294]                         if (is.null(version)) 
[17:38:30.294]                           version <- utils::packageVersion("future")
[17:38:30.294]                       }
[17:38:30.294]                       else {
[17:38:30.294]                         version <- NULL
[17:38:30.294]                       }
[17:38:30.294]                       if (!has_future || version < "1.8.0") {
[17:38:30.294]                         info <- base::c(r_version = base::gsub("R version ", 
[17:38:30.294]                           "", base::R.version$version.string), 
[17:38:30.294]                           platform = base::sprintf("%s (%s-bit)", 
[17:38:30.294]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:30.294]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:30.294]                             "release", "version")], collapse = " "), 
[17:38:30.294]                           hostname = base::Sys.info()[["nodename"]])
[17:38:30.294]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:38:30.294]                           info)
[17:38:30.294]                         info <- base::paste(info, collapse = "; ")
[17:38:30.294]                         if (!has_future) {
[17:38:30.294]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:30.294]                             info)
[17:38:30.294]                         }
[17:38:30.294]                         else {
[17:38:30.294]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:30.294]                             info, version)
[17:38:30.294]                         }
[17:38:30.294]                         base::stop(msg)
[17:38:30.294]                       }
[17:38:30.294]                     })
[17:38:30.294]                   }
[17:38:30.294]                   ...future.strategy.old <- future::plan("list")
[17:38:30.294]                   options(future.plan = NULL)
[17:38:30.294]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:30.294]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:30.294]                 }
[17:38:30.294]                 ...future.workdir <- getwd()
[17:38:30.294]             }
[17:38:30.294]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:30.294]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:30.294]         }
[17:38:30.294]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:30.294]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:30.294]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:30.294]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:30.294]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:30.294]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:30.294]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:30.294]             base::names(...future.oldOptions))
[17:38:30.294]     }
[17:38:30.294]     if (TRUE) {
[17:38:30.294]     }
[17:38:30.294]     else {
[17:38:30.294]         if (NA) {
[17:38:30.294]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:30.294]                 open = "w")
[17:38:30.294]         }
[17:38:30.294]         else {
[17:38:30.294]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:30.294]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:30.294]         }
[17:38:30.294]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:30.294]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:30.294]             base::sink(type = "output", split = FALSE)
[17:38:30.294]             base::close(...future.stdout)
[17:38:30.294]         }, add = TRUE)
[17:38:30.294]     }
[17:38:30.294]     ...future.frame <- base::sys.nframe()
[17:38:30.294]     ...future.conditions <- base::list()
[17:38:30.294]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:30.294]     if (FALSE) {
[17:38:30.294]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:30.294]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:30.294]     }
[17:38:30.294]     ...future.result <- base::tryCatch({
[17:38:30.294]         base::withCallingHandlers({
[17:38:30.294]             ...future.value <- base::withVisible(base::local({
[17:38:30.294]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:30.294]                 if (!identical(...future.globals.maxSize.org, 
[17:38:30.294]                   ...future.globals.maxSize)) {
[17:38:30.294]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:30.294]                   on.exit(options(oopts), add = TRUE)
[17:38:30.294]                 }
[17:38:30.294]                 {
[17:38:30.294]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:30.294]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:38:30.294]                     USE.NAMES = FALSE)
[17:38:30.294]                   do.call(mapply, args = args)
[17:38:30.294]                 }
[17:38:30.294]             }))
[17:38:30.294]             future::FutureResult(value = ...future.value$value, 
[17:38:30.294]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:30.294]                   ...future.rng), globalenv = if (FALSE) 
[17:38:30.294]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:30.294]                     ...future.globalenv.names))
[17:38:30.294]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:30.294]         }, condition = base::local({
[17:38:30.294]             c <- base::c
[17:38:30.294]             inherits <- base::inherits
[17:38:30.294]             invokeRestart <- base::invokeRestart
[17:38:30.294]             length <- base::length
[17:38:30.294]             list <- base::list
[17:38:30.294]             seq.int <- base::seq.int
[17:38:30.294]             signalCondition <- base::signalCondition
[17:38:30.294]             sys.calls <- base::sys.calls
[17:38:30.294]             `[[` <- base::`[[`
[17:38:30.294]             `+` <- base::`+`
[17:38:30.294]             `<<-` <- base::`<<-`
[17:38:30.294]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:30.294]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:30.294]                   3L)]
[17:38:30.294]             }
[17:38:30.294]             function(cond) {
[17:38:30.294]                 is_error <- inherits(cond, "error")
[17:38:30.294]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:30.294]                   NULL)
[17:38:30.294]                 if (is_error) {
[17:38:30.294]                   sessionInformation <- function() {
[17:38:30.294]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:30.294]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:30.294]                       search = base::search(), system = base::Sys.info())
[17:38:30.294]                   }
[17:38:30.294]                   ...future.conditions[[length(...future.conditions) + 
[17:38:30.294]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:30.294]                     cond$call), session = sessionInformation(), 
[17:38:30.294]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:30.294]                   signalCondition(cond)
[17:38:30.294]                 }
[17:38:30.294]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:30.294]                 "immediateCondition"))) {
[17:38:30.294]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:30.294]                   ...future.conditions[[length(...future.conditions) + 
[17:38:30.294]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:30.294]                   if (TRUE && !signal) {
[17:38:30.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:30.294]                     {
[17:38:30.294]                       inherits <- base::inherits
[17:38:30.294]                       invokeRestart <- base::invokeRestart
[17:38:30.294]                       is.null <- base::is.null
[17:38:30.294]                       muffled <- FALSE
[17:38:30.294]                       if (inherits(cond, "message")) {
[17:38:30.294]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:30.294]                         if (muffled) 
[17:38:30.294]                           invokeRestart("muffleMessage")
[17:38:30.294]                       }
[17:38:30.294]                       else if (inherits(cond, "warning")) {
[17:38:30.294]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:30.294]                         if (muffled) 
[17:38:30.294]                           invokeRestart("muffleWarning")
[17:38:30.294]                       }
[17:38:30.294]                       else if (inherits(cond, "condition")) {
[17:38:30.294]                         if (!is.null(pattern)) {
[17:38:30.294]                           computeRestarts <- base::computeRestarts
[17:38:30.294]                           grepl <- base::grepl
[17:38:30.294]                           restarts <- computeRestarts(cond)
[17:38:30.294]                           for (restart in restarts) {
[17:38:30.294]                             name <- restart$name
[17:38:30.294]                             if (is.null(name)) 
[17:38:30.294]                               next
[17:38:30.294]                             if (!grepl(pattern, name)) 
[17:38:30.294]                               next
[17:38:30.294]                             invokeRestart(restart)
[17:38:30.294]                             muffled <- TRUE
[17:38:30.294]                             break
[17:38:30.294]                           }
[17:38:30.294]                         }
[17:38:30.294]                       }
[17:38:30.294]                       invisible(muffled)
[17:38:30.294]                     }
[17:38:30.294]                     muffleCondition(cond, pattern = "^muffle")
[17:38:30.294]                   }
[17:38:30.294]                 }
[17:38:30.294]                 else {
[17:38:30.294]                   if (TRUE) {
[17:38:30.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:30.294]                     {
[17:38:30.294]                       inherits <- base::inherits
[17:38:30.294]                       invokeRestart <- base::invokeRestart
[17:38:30.294]                       is.null <- base::is.null
[17:38:30.294]                       muffled <- FALSE
[17:38:30.294]                       if (inherits(cond, "message")) {
[17:38:30.294]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:30.294]                         if (muffled) 
[17:38:30.294]                           invokeRestart("muffleMessage")
[17:38:30.294]                       }
[17:38:30.294]                       else if (inherits(cond, "warning")) {
[17:38:30.294]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:30.294]                         if (muffled) 
[17:38:30.294]                           invokeRestart("muffleWarning")
[17:38:30.294]                       }
[17:38:30.294]                       else if (inherits(cond, "condition")) {
[17:38:30.294]                         if (!is.null(pattern)) {
[17:38:30.294]                           computeRestarts <- base::computeRestarts
[17:38:30.294]                           grepl <- base::grepl
[17:38:30.294]                           restarts <- computeRestarts(cond)
[17:38:30.294]                           for (restart in restarts) {
[17:38:30.294]                             name <- restart$name
[17:38:30.294]                             if (is.null(name)) 
[17:38:30.294]                               next
[17:38:30.294]                             if (!grepl(pattern, name)) 
[17:38:30.294]                               next
[17:38:30.294]                             invokeRestart(restart)
[17:38:30.294]                             muffled <- TRUE
[17:38:30.294]                             break
[17:38:30.294]                           }
[17:38:30.294]                         }
[17:38:30.294]                       }
[17:38:30.294]                       invisible(muffled)
[17:38:30.294]                     }
[17:38:30.294]                     muffleCondition(cond, pattern = "^muffle")
[17:38:30.294]                   }
[17:38:30.294]                 }
[17:38:30.294]             }
[17:38:30.294]         }))
[17:38:30.294]     }, error = function(ex) {
[17:38:30.294]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:30.294]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:30.294]                 ...future.rng), started = ...future.startTime, 
[17:38:30.294]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:30.294]             version = "1.8"), class = "FutureResult")
[17:38:30.294]     }, finally = {
[17:38:30.294]         if (!identical(...future.workdir, getwd())) 
[17:38:30.294]             setwd(...future.workdir)
[17:38:30.294]         {
[17:38:30.294]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:30.294]                 ...future.oldOptions$nwarnings <- NULL
[17:38:30.294]             }
[17:38:30.294]             base::options(...future.oldOptions)
[17:38:30.294]             if (.Platform$OS.type == "windows") {
[17:38:30.294]                 old_names <- names(...future.oldEnvVars)
[17:38:30.294]                 envs <- base::Sys.getenv()
[17:38:30.294]                 names <- names(envs)
[17:38:30.294]                 common <- intersect(names, old_names)
[17:38:30.294]                 added <- setdiff(names, old_names)
[17:38:30.294]                 removed <- setdiff(old_names, names)
[17:38:30.294]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:30.294]                   envs[common]]
[17:38:30.294]                 NAMES <- toupper(changed)
[17:38:30.294]                 args <- list()
[17:38:30.294]                 for (kk in seq_along(NAMES)) {
[17:38:30.294]                   name <- changed[[kk]]
[17:38:30.294]                   NAME <- NAMES[[kk]]
[17:38:30.294]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:30.294]                     next
[17:38:30.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:30.294]                 }
[17:38:30.294]                 NAMES <- toupper(added)
[17:38:30.294]                 for (kk in seq_along(NAMES)) {
[17:38:30.294]                   name <- added[[kk]]
[17:38:30.294]                   NAME <- NAMES[[kk]]
[17:38:30.294]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:30.294]                     next
[17:38:30.294]                   args[[name]] <- ""
[17:38:30.294]                 }
[17:38:30.294]                 NAMES <- toupper(removed)
[17:38:30.294]                 for (kk in seq_along(NAMES)) {
[17:38:30.294]                   name <- removed[[kk]]
[17:38:30.294]                   NAME <- NAMES[[kk]]
[17:38:30.294]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:30.294]                     next
[17:38:30.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:30.294]                 }
[17:38:30.294]                 if (length(args) > 0) 
[17:38:30.294]                   base::do.call(base::Sys.setenv, args = args)
[17:38:30.294]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:30.294]             }
[17:38:30.294]             else {
[17:38:30.294]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:30.294]             }
[17:38:30.294]             {
[17:38:30.294]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:30.294]                   0L) {
[17:38:30.294]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:30.294]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:30.294]                   base::options(opts)
[17:38:30.294]                 }
[17:38:30.294]                 {
[17:38:30.294]                   {
[17:38:30.294]                     NULL
[17:38:30.294]                     RNGkind("Mersenne-Twister")
[17:38:30.294]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:30.294]                       inherits = FALSE)
[17:38:30.294]                   }
[17:38:30.294]                   options(future.plan = NULL)
[17:38:30.294]                   if (is.na(NA_character_)) 
[17:38:30.294]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:30.294]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:30.294]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:30.294]                     .init = FALSE)
[17:38:30.294]                 }
[17:38:30.294]             }
[17:38:30.294]         }
[17:38:30.294]     })
[17:38:30.294]     if (FALSE) {
[17:38:30.294]         base::sink(type = "output", split = FALSE)
[17:38:30.294]         if (NA) {
[17:38:30.294]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:30.294]         }
[17:38:30.294]         else {
[17:38:30.294]             ...future.result["stdout"] <- base::list(NULL)
[17:38:30.294]         }
[17:38:30.294]         base::close(...future.stdout)
[17:38:30.294]         ...future.stdout <- NULL
[17:38:30.294]     }
[17:38:30.294]     ...future.result$conditions <- ...future.conditions
[17:38:30.294]     ...future.result$finished <- base::Sys.time()
[17:38:30.294]     ...future.result
[17:38:30.294] }
[17:38:30.296] assign_globals() ...
[17:38:30.296] List of 5
[17:38:30.296]  $ ...future.FUN            :function (x, y)  
[17:38:30.296]  $ MoreArgs                 : NULL
[17:38:30.296]  $ ...future.elements_ii    :List of 2
[17:38:30.296]   ..$ :List of 2
[17:38:30.296]   .. ..$ : int 1
[17:38:30.296]   .. ..$ : int 0
[17:38:30.296]   ..$ :List of 2
[17:38:30.296]   .. ..$ : int 0
[17:38:30.296]   .. ..$ : int 1
[17:38:30.296]  $ ...future.seeds_ii       : NULL
[17:38:30.296]  $ ...future.globals.maxSize: NULL
[17:38:30.296]  - attr(*, "where")=List of 5
[17:38:30.296]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:30.296]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:38:30.296]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:30.296]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:30.296]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:30.296]  - attr(*, "resolved")= logi FALSE
[17:38:30.296]  - attr(*, "total_size")= num 6480
[17:38:30.296]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:30.296]  - attr(*, "already-done")= logi TRUE
[17:38:30.301] - reassign environment for ‘...future.FUN’
[17:38:30.301] - copied ‘...future.FUN’ to environment
[17:38:30.301] - copied ‘MoreArgs’ to environment
[17:38:30.302] - copied ‘...future.elements_ii’ to environment
[17:38:30.302] - copied ‘...future.seeds_ii’ to environment
[17:38:30.302] - copied ‘...future.globals.maxSize’ to environment
[17:38:30.302] assign_globals() ... done
[17:38:30.302] plan(): Setting new future strategy stack:
[17:38:30.302] List of future strategies:
[17:38:30.302] 1. sequential:
[17:38:30.302]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:30.302]    - tweaked: FALSE
[17:38:30.302]    - call: NULL
[17:38:30.303] plan(): nbrOfWorkers() = 1
[17:38:30.804] plan(): Setting new future strategy stack:
[17:38:30.804] List of future strategies:
[17:38:30.804] 1. multisession:
[17:38:30.804]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:38:30.804]    - tweaked: FALSE
[17:38:30.804]    - call: plan(strategy)
[17:38:30.809] plan(): nbrOfWorkers() = 1
[17:38:30.809] SequentialFuture started (and completed)
[17:38:30.809] - Launch lazy future ... done
[17:38:30.809] run() for ‘SequentialFuture’ ... done
[17:38:30.809] Created future:
[17:38:30.809] SequentialFuture:
[17:38:30.809] Label: ‘future_mapply-1’
[17:38:30.809] Expression:
[17:38:30.809] {
[17:38:30.809]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:30.809]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:30.809]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:30.809]         on.exit(options(oopts), add = TRUE)
[17:38:30.809]     }
[17:38:30.809]     {
[17:38:30.809]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:30.809]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:38:30.809]         do.call(mapply, args = args)
[17:38:30.809]     }
[17:38:30.809] }
[17:38:30.809] Lazy evaluation: FALSE
[17:38:30.809] Asynchronous evaluation: FALSE
[17:38:30.809] Local evaluation: TRUE
[17:38:30.809] Environment: R_GlobalEnv
[17:38:30.809] Capture standard output: NA
[17:38:30.809] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:30.809] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:30.809] Packages: <none>
[17:38:30.809] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:30.809] Resolved: TRUE
[17:38:30.809] Value: 224 bytes of class ‘list’
[17:38:30.809] Early signaling: FALSE
[17:38:30.809] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:30.809] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:30.810] Chunk #1 of 1 ... DONE
[17:38:30.811] Launching 1 futures (chunks) ... DONE
[17:38:30.811] Resolving 1 futures (chunks) ...
[17:38:30.811] resolve() on list ...
[17:38:30.811]  recursive: 0
[17:38:30.811]  length: 1
[17:38:30.811] 
[17:38:30.811] resolved() for ‘SequentialFuture’ ...
[17:38:30.811] - state: ‘finished’
[17:38:30.811] - run: TRUE
[17:38:30.811] - result: ‘FutureResult’
[17:38:30.812] resolved() for ‘SequentialFuture’ ... done
[17:38:30.812] Future #1
[17:38:30.812] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:30.812] - nx: 1
[17:38:30.812] - relay: TRUE
[17:38:30.812] - stdout: TRUE
[17:38:30.812] - signal: TRUE
[17:38:30.812] - resignal: FALSE
[17:38:30.812] - force: TRUE
[17:38:30.813] - relayed: [n=1] FALSE
[17:38:30.813] - queued futures: [n=1] FALSE
[17:38:30.813]  - until=1
[17:38:30.813]  - relaying element #1
[17:38:30.813] - relayed: [n=1] TRUE
[17:38:30.813] - queued futures: [n=1] TRUE
[17:38:30.813] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:30.813]  length: 0 (resolved future 1)
[17:38:30.813] Relaying remaining futures
[17:38:30.813] signalConditionsASAP(NULL, pos=0) ...
[17:38:30.814] - nx: 1
[17:38:30.814] - relay: TRUE
[17:38:30.814] - stdout: TRUE
[17:38:30.814] - signal: TRUE
[17:38:30.814] - resignal: FALSE
[17:38:30.814] - force: TRUE
[17:38:30.814] - relayed: [n=1] TRUE
[17:38:30.814] - queued futures: [n=1] TRUE
 - flush all
[17:38:30.814] - relayed: [n=1] TRUE
[17:38:30.814] - queued futures: [n=1] TRUE
[17:38:30.814] signalConditionsASAP(NULL, pos=0) ... done
[17:38:30.815] resolve() on list ... DONE
[17:38:30.815]  - Number of value chunks collected: 1
[17:38:30.815] Resolving 1 futures (chunks) ... DONE
[17:38:30.815] Reducing values from 1 chunks ...
[17:38:30.815]  - Number of values collected after concatenation: 2
[17:38:30.815]  - Number of values expected: 2
[17:38:30.815] Reducing values from 1 chunks ... DONE
[17:38:30.815] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 1 cores ... DONE
  - Testing with 2 cores ...
* plan('multicore') ...
[17:38:30.821] plan(): Setting new future strategy stack:
[17:38:30.821] List of future strategies:
[17:38:30.821] 1. multicore:
[17:38:30.821]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:30.821]    - tweaked: FALSE
[17:38:30.821]    - call: plan(strategy)
[17:38:30.825] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[17:38:30.825] future_lapply() ...
[17:38:30.830] Number of chunks: 2
[17:38:30.831] getGlobalsAndPackagesXApply() ...
[17:38:30.831]  - future.globals: TRUE
[17:38:30.831] getGlobalsAndPackages() ...
[17:38:30.831] Searching for globals...
[17:38:30.832] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:38:30.832] Searching for globals ... DONE
[17:38:30.832] Resolving globals: FALSE
[17:38:30.833] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:38:30.833] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:38:30.833] - globals: [1] ‘FUN’
[17:38:30.833] 
[17:38:30.833] getGlobalsAndPackages() ... DONE
[17:38:30.834]  - globals found/used: [n=1] ‘FUN’
[17:38:30.834]  - needed namespaces: [n=0] 
[17:38:30.834] Finding globals ... DONE
[17:38:30.834]  - use_args: TRUE
[17:38:30.834]  - Getting '...' globals ...
[17:38:30.834] resolve() on list ...
[17:38:30.834]  recursive: 0
[17:38:30.834]  length: 1
[17:38:30.835]  elements: ‘...’
[17:38:30.835]  length: 0 (resolved future 1)
[17:38:30.835] resolve() on list ... DONE
[17:38:30.835]    - '...' content: [n=0] 
[17:38:30.835] List of 1
[17:38:30.835]  $ ...: list()
[17:38:30.835]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:30.835]  - attr(*, "where")=List of 1
[17:38:30.835]   ..$ ...:<environment: 0x5628aa9c5000> 
[17:38:30.835]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:30.835]  - attr(*, "resolved")= logi TRUE
[17:38:30.835]  - attr(*, "total_size")= num NA
[17:38:30.838]  - Getting '...' globals ... DONE
[17:38:30.838] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:38:30.838] List of 2
[17:38:30.838]  $ ...future.FUN:function (x)  
[17:38:30.838]  $ ...          : list()
[17:38:30.838]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:30.838]  - attr(*, "where")=List of 2
[17:38:30.838]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:30.838]   ..$ ...          :<environment: 0x5628aa9c5000> 
[17:38:30.838]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:30.838]  - attr(*, "resolved")= logi FALSE
[17:38:30.838]  - attr(*, "total_size")= num 4720
[17:38:30.840] Packages to be attached in all futures: [n=0] 
[17:38:30.841] getGlobalsAndPackagesXApply() ... DONE
[17:38:30.841] Number of futures (= number of chunks): 2
[17:38:30.841] Launching 2 futures (chunks) ...
[17:38:30.841] Chunk #1 of 2 ...
[17:38:30.841]  - Finding globals in 'X' for chunk #1 ...
[17:38:30.841] getGlobalsAndPackages() ...
[17:38:30.841] Searching for globals...
[17:38:30.841] 
[17:38:30.842] Searching for globals ... DONE
[17:38:30.842] - globals: [0] <none>
[17:38:30.842] getGlobalsAndPackages() ... DONE
[17:38:30.842]    + additional globals found: [n=0] 
[17:38:30.842]    + additional namespaces needed: [n=0] 
[17:38:30.842]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:30.842]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:30.842]  - seeds: <none>
[17:38:30.842]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:30.842] getGlobalsAndPackages() ...
[17:38:30.842] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:30.843] Resolving globals: FALSE
[17:38:30.843] Tweak future expression to call with '...' arguments ...
[17:38:30.843] {
[17:38:30.843]     do.call(function(...) {
[17:38:30.843]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:30.843]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:30.843]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:30.843]             on.exit(options(oopts), add = TRUE)
[17:38:30.843]         }
[17:38:30.843]         {
[17:38:30.843]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:30.843]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:30.843]                 ...future.FUN(...future.X_jj, ...)
[17:38:30.843]             })
[17:38:30.843]         }
[17:38:30.843]     }, args = future.call.arguments)
[17:38:30.843] }
[17:38:30.843] Tweak future expression to call with '...' arguments ... DONE
[17:38:30.843] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:30.843] 
[17:38:30.844] getGlobalsAndPackages() ... DONE
[17:38:30.844] run() for ‘Future’ ...
[17:38:30.844] - state: ‘created’
[17:38:30.844] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:30.848] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:30.848] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:30.848]   - Field: ‘label’
[17:38:30.848]   - Field: ‘local’
[17:38:30.848]   - Field: ‘owner’
[17:38:30.848]   - Field: ‘envir’
[17:38:30.848]   - Field: ‘workers’
[17:38:30.848]   - Field: ‘packages’
[17:38:30.849]   - Field: ‘gc’
[17:38:30.849]   - Field: ‘job’
[17:38:30.849]   - Field: ‘conditions’
[17:38:30.849]   - Field: ‘expr’
[17:38:30.849]   - Field: ‘uuid’
[17:38:30.849]   - Field: ‘seed’
[17:38:30.849]   - Field: ‘version’
[17:38:30.849]   - Field: ‘result’
[17:38:30.849]   - Field: ‘asynchronous’
[17:38:30.849]   - Field: ‘calls’
[17:38:30.849]   - Field: ‘globals’
[17:38:30.850]   - Field: ‘stdout’
[17:38:30.850]   - Field: ‘earlySignal’
[17:38:30.850]   - Field: ‘lazy’
[17:38:30.850]   - Field: ‘state’
[17:38:30.850] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:30.850] - Launch lazy future ...
[17:38:30.851] Packages needed by the future expression (n = 0): <none>
[17:38:30.851] Packages needed by future strategies (n = 0): <none>
[17:38:30.853] {
[17:38:30.853]     {
[17:38:30.853]         {
[17:38:30.853]             ...future.startTime <- base::Sys.time()
[17:38:30.853]             {
[17:38:30.853]                 {
[17:38:30.853]                   {
[17:38:30.853]                     {
[17:38:30.853]                       base::local({
[17:38:30.853]                         has_future <- base::requireNamespace("future", 
[17:38:30.853]                           quietly = TRUE)
[17:38:30.853]                         if (has_future) {
[17:38:30.853]                           ns <- base::getNamespace("future")
[17:38:30.853]                           version <- ns[[".package"]][["version"]]
[17:38:30.853]                           if (is.null(version)) 
[17:38:30.853]                             version <- utils::packageVersion("future")
[17:38:30.853]                         }
[17:38:30.853]                         else {
[17:38:30.853]                           version <- NULL
[17:38:30.853]                         }
[17:38:30.853]                         if (!has_future || version < "1.8.0") {
[17:38:30.853]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:30.853]                             "", base::R.version$version.string), 
[17:38:30.853]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:30.853]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:30.853]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:30.853]                               "release", "version")], collapse = " "), 
[17:38:30.853]                             hostname = base::Sys.info()[["nodename"]])
[17:38:30.853]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:30.853]                             info)
[17:38:30.853]                           info <- base::paste(info, collapse = "; ")
[17:38:30.853]                           if (!has_future) {
[17:38:30.853]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:30.853]                               info)
[17:38:30.853]                           }
[17:38:30.853]                           else {
[17:38:30.853]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:30.853]                               info, version)
[17:38:30.853]                           }
[17:38:30.853]                           base::stop(msg)
[17:38:30.853]                         }
[17:38:30.853]                       })
[17:38:30.853]                     }
[17:38:30.853]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:30.853]                     base::options(mc.cores = 1L)
[17:38:30.853]                   }
[17:38:30.853]                   ...future.strategy.old <- future::plan("list")
[17:38:30.853]                   options(future.plan = NULL)
[17:38:30.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:30.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:30.853]                 }
[17:38:30.853]                 ...future.workdir <- getwd()
[17:38:30.853]             }
[17:38:30.853]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:30.853]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:30.853]         }
[17:38:30.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:30.853]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:30.853]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:30.853]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:30.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:30.853]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:30.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:30.853]             base::names(...future.oldOptions))
[17:38:30.853]     }
[17:38:30.853]     if (FALSE) {
[17:38:30.853]     }
[17:38:30.853]     else {
[17:38:30.853]         if (FALSE) {
[17:38:30.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:30.853]                 open = "w")
[17:38:30.853]         }
[17:38:30.853]         else {
[17:38:30.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:30.853]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:30.853]         }
[17:38:30.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:30.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:30.853]             base::sink(type = "output", split = FALSE)
[17:38:30.853]             base::close(...future.stdout)
[17:38:30.853]         }, add = TRUE)
[17:38:30.853]     }
[17:38:30.853]     ...future.frame <- base::sys.nframe()
[17:38:30.853]     ...future.conditions <- base::list()
[17:38:30.853]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:30.853]     if (FALSE) {
[17:38:30.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:30.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:30.853]     }
[17:38:30.853]     ...future.result <- base::tryCatch({
[17:38:30.853]         base::withCallingHandlers({
[17:38:30.853]             ...future.value <- base::withVisible(base::local({
[17:38:30.853]                 withCallingHandlers({
[17:38:30.853]                   {
[17:38:30.853]                     do.call(function(...) {
[17:38:30.853]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:30.853]                       if (!identical(...future.globals.maxSize.org, 
[17:38:30.853]                         ...future.globals.maxSize)) {
[17:38:30.853]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:30.853]                         on.exit(options(oopts), add = TRUE)
[17:38:30.853]                       }
[17:38:30.853]                       {
[17:38:30.853]                         lapply(seq_along(...future.elements_ii), 
[17:38:30.853]                           FUN = function(jj) {
[17:38:30.853]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:30.853]                             ...future.FUN(...future.X_jj, ...)
[17:38:30.853]                           })
[17:38:30.853]                       }
[17:38:30.853]                     }, args = future.call.arguments)
[17:38:30.853]                   }
[17:38:30.853]                 }, immediateCondition = function(cond) {
[17:38:30.853]                   save_rds <- function (object, pathname, ...) 
[17:38:30.853]                   {
[17:38:30.853]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:30.853]                     if (file_test("-f", pathname_tmp)) {
[17:38:30.853]                       fi_tmp <- file.info(pathname_tmp)
[17:38:30.853]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:30.853]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:30.853]                         fi_tmp[["mtime"]])
[17:38:30.853]                     }
[17:38:30.853]                     tryCatch({
[17:38:30.853]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:30.853]                     }, error = function(ex) {
[17:38:30.853]                       msg <- conditionMessage(ex)
[17:38:30.853]                       fi_tmp <- file.info(pathname_tmp)
[17:38:30.853]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:30.853]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:30.853]                         fi_tmp[["mtime"]], msg)
[17:38:30.853]                       ex$message <- msg
[17:38:30.853]                       stop(ex)
[17:38:30.853]                     })
[17:38:30.853]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:30.853]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:30.853]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:30.853]                       fi_tmp <- file.info(pathname_tmp)
[17:38:30.853]                       fi <- file.info(pathname)
[17:38:30.853]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:30.853]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:30.853]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:30.853]                         fi[["size"]], fi[["mtime"]])
[17:38:30.853]                       stop(msg)
[17:38:30.853]                     }
[17:38:30.853]                     invisible(pathname)
[17:38:30.853]                   }
[17:38:30.853]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:30.853]                     rootPath = tempdir()) 
[17:38:30.853]                   {
[17:38:30.853]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:30.853]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:30.853]                       tmpdir = path, fileext = ".rds")
[17:38:30.853]                     save_rds(obj, file)
[17:38:30.853]                   }
[17:38:30.853]                   saveImmediateCondition(cond, path = "/tmp/RtmpBrP0ee/.future/immediateConditions")
[17:38:30.853]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:30.853]                   {
[17:38:30.853]                     inherits <- base::inherits
[17:38:30.853]                     invokeRestart <- base::invokeRestart
[17:38:30.853]                     is.null <- base::is.null
[17:38:30.853]                     muffled <- FALSE
[17:38:30.853]                     if (inherits(cond, "message")) {
[17:38:30.853]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:30.853]                       if (muffled) 
[17:38:30.853]                         invokeRestart("muffleMessage")
[17:38:30.853]                     }
[17:38:30.853]                     else if (inherits(cond, "warning")) {
[17:38:30.853]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:30.853]                       if (muffled) 
[17:38:30.853]                         invokeRestart("muffleWarning")
[17:38:30.853]                     }
[17:38:30.853]                     else if (inherits(cond, "condition")) {
[17:38:30.853]                       if (!is.null(pattern)) {
[17:38:30.853]                         computeRestarts <- base::computeRestarts
[17:38:30.853]                         grepl <- base::grepl
[17:38:30.853]                         restarts <- computeRestarts(cond)
[17:38:30.853]                         for (restart in restarts) {
[17:38:30.853]                           name <- restart$name
[17:38:30.853]                           if (is.null(name)) 
[17:38:30.853]                             next
[17:38:30.853]                           if (!grepl(pattern, name)) 
[17:38:30.853]                             next
[17:38:30.853]                           invokeRestart(restart)
[17:38:30.853]                           muffled <- TRUE
[17:38:30.853]                           break
[17:38:30.853]                         }
[17:38:30.853]                       }
[17:38:30.853]                     }
[17:38:30.853]                     invisible(muffled)
[17:38:30.853]                   }
[17:38:30.853]                   muffleCondition(cond)
[17:38:30.853]                 })
[17:38:30.853]             }))
[17:38:30.853]             future::FutureResult(value = ...future.value$value, 
[17:38:30.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:30.853]                   ...future.rng), globalenv = if (FALSE) 
[17:38:30.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:30.853]                     ...future.globalenv.names))
[17:38:30.853]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:30.853]         }, condition = base::local({
[17:38:30.853]             c <- base::c
[17:38:30.853]             inherits <- base::inherits
[17:38:30.853]             invokeRestart <- base::invokeRestart
[17:38:30.853]             length <- base::length
[17:38:30.853]             list <- base::list
[17:38:30.853]             seq.int <- base::seq.int
[17:38:30.853]             signalCondition <- base::signalCondition
[17:38:30.853]             sys.calls <- base::sys.calls
[17:38:30.853]             `[[` <- base::`[[`
[17:38:30.853]             `+` <- base::`+`
[17:38:30.853]             `<<-` <- base::`<<-`
[17:38:30.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:30.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:30.853]                   3L)]
[17:38:30.853]             }
[17:38:30.853]             function(cond) {
[17:38:30.853]                 is_error <- inherits(cond, "error")
[17:38:30.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:30.853]                   NULL)
[17:38:30.853]                 if (is_error) {
[17:38:30.853]                   sessionInformation <- function() {
[17:38:30.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:30.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:30.853]                       search = base::search(), system = base::Sys.info())
[17:38:30.853]                   }
[17:38:30.853]                   ...future.conditions[[length(...future.conditions) + 
[17:38:30.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:30.853]                     cond$call), session = sessionInformation(), 
[17:38:30.853]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:30.853]                   signalCondition(cond)
[17:38:30.853]                 }
[17:38:30.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:30.853]                 "immediateCondition"))) {
[17:38:30.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:30.853]                   ...future.conditions[[length(...future.conditions) + 
[17:38:30.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:30.853]                   if (TRUE && !signal) {
[17:38:30.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:30.853]                     {
[17:38:30.853]                       inherits <- base::inherits
[17:38:30.853]                       invokeRestart <- base::invokeRestart
[17:38:30.853]                       is.null <- base::is.null
[17:38:30.853]                       muffled <- FALSE
[17:38:30.853]                       if (inherits(cond, "message")) {
[17:38:30.853]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:30.853]                         if (muffled) 
[17:38:30.853]                           invokeRestart("muffleMessage")
[17:38:30.853]                       }
[17:38:30.853]                       else if (inherits(cond, "warning")) {
[17:38:30.853]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:30.853]                         if (muffled) 
[17:38:30.853]                           invokeRestart("muffleWarning")
[17:38:30.853]                       }
[17:38:30.853]                       else if (inherits(cond, "condition")) {
[17:38:30.853]                         if (!is.null(pattern)) {
[17:38:30.853]                           computeRestarts <- base::computeRestarts
[17:38:30.853]                           grepl <- base::grepl
[17:38:30.853]                           restarts <- computeRestarts(cond)
[17:38:30.853]                           for (restart in restarts) {
[17:38:30.853]                             name <- restart$name
[17:38:30.853]                             if (is.null(name)) 
[17:38:30.853]                               next
[17:38:30.853]                             if (!grepl(pattern, name)) 
[17:38:30.853]                               next
[17:38:30.853]                             invokeRestart(restart)
[17:38:30.853]                             muffled <- TRUE
[17:38:30.853]                             break
[17:38:30.853]                           }
[17:38:30.853]                         }
[17:38:30.853]                       }
[17:38:30.853]                       invisible(muffled)
[17:38:30.853]                     }
[17:38:30.853]                     muffleCondition(cond, pattern = "^muffle")
[17:38:30.853]                   }
[17:38:30.853]                 }
[17:38:30.853]                 else {
[17:38:30.853]                   if (TRUE) {
[17:38:30.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:30.853]                     {
[17:38:30.853]                       inherits <- base::inherits
[17:38:30.853]                       invokeRestart <- base::invokeRestart
[17:38:30.853]                       is.null <- base::is.null
[17:38:30.853]                       muffled <- FALSE
[17:38:30.853]                       if (inherits(cond, "message")) {
[17:38:30.853]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:30.853]                         if (muffled) 
[17:38:30.853]                           invokeRestart("muffleMessage")
[17:38:30.853]                       }
[17:38:30.853]                       else if (inherits(cond, "warning")) {
[17:38:30.853]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:30.853]                         if (muffled) 
[17:38:30.853]                           invokeRestart("muffleWarning")
[17:38:30.853]                       }
[17:38:30.853]                       else if (inherits(cond, "condition")) {
[17:38:30.853]                         if (!is.null(pattern)) {
[17:38:30.853]                           computeRestarts <- base::computeRestarts
[17:38:30.853]                           grepl <- base::grepl
[17:38:30.853]                           restarts <- computeRestarts(cond)
[17:38:30.853]                           for (restart in restarts) {
[17:38:30.853]                             name <- restart$name
[17:38:30.853]                             if (is.null(name)) 
[17:38:30.853]                               next
[17:38:30.853]                             if (!grepl(pattern, name)) 
[17:38:30.853]                               next
[17:38:30.853]                             invokeRestart(restart)
[17:38:30.853]                             muffled <- TRUE
[17:38:30.853]                             break
[17:38:30.853]                           }
[17:38:30.853]                         }
[17:38:30.853]                       }
[17:38:30.853]                       invisible(muffled)
[17:38:30.853]                     }
[17:38:30.853]                     muffleCondition(cond, pattern = "^muffle")
[17:38:30.853]                   }
[17:38:30.853]                 }
[17:38:30.853]             }
[17:38:30.853]         }))
[17:38:30.853]     }, error = function(ex) {
[17:38:30.853]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:30.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:30.853]                 ...future.rng), started = ...future.startTime, 
[17:38:30.853]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:30.853]             version = "1.8"), class = "FutureResult")
[17:38:30.853]     }, finally = {
[17:38:30.853]         if (!identical(...future.workdir, getwd())) 
[17:38:30.853]             setwd(...future.workdir)
[17:38:30.853]         {
[17:38:30.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:30.853]                 ...future.oldOptions$nwarnings <- NULL
[17:38:30.853]             }
[17:38:30.853]             base::options(...future.oldOptions)
[17:38:30.853]             if (.Platform$OS.type == "windows") {
[17:38:30.853]                 old_names <- names(...future.oldEnvVars)
[17:38:30.853]                 envs <- base::Sys.getenv()
[17:38:30.853]                 names <- names(envs)
[17:38:30.853]                 common <- intersect(names, old_names)
[17:38:30.853]                 added <- setdiff(names, old_names)
[17:38:30.853]                 removed <- setdiff(old_names, names)
[17:38:30.853]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:30.853]                   envs[common]]
[17:38:30.853]                 NAMES <- toupper(changed)
[17:38:30.853]                 args <- list()
[17:38:30.853]                 for (kk in seq_along(NAMES)) {
[17:38:30.853]                   name <- changed[[kk]]
[17:38:30.853]                   NAME <- NAMES[[kk]]
[17:38:30.853]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:30.853]                     next
[17:38:30.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:30.853]                 }
[17:38:30.853]                 NAMES <- toupper(added)
[17:38:30.853]                 for (kk in seq_along(NAMES)) {
[17:38:30.853]                   name <- added[[kk]]
[17:38:30.853]                   NAME <- NAMES[[kk]]
[17:38:30.853]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:30.853]                     next
[17:38:30.853]                   args[[name]] <- ""
[17:38:30.853]                 }
[17:38:30.853]                 NAMES <- toupper(removed)
[17:38:30.853]                 for (kk in seq_along(NAMES)) {
[17:38:30.853]                   name <- removed[[kk]]
[17:38:30.853]                   NAME <- NAMES[[kk]]
[17:38:30.853]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:30.853]                     next
[17:38:30.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:30.853]                 }
[17:38:30.853]                 if (length(args) > 0) 
[17:38:30.853]                   base::do.call(base::Sys.setenv, args = args)
[17:38:30.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:30.853]             }
[17:38:30.853]             else {
[17:38:30.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:30.853]             }
[17:38:30.853]             {
[17:38:30.853]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:30.853]                   0L) {
[17:38:30.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:30.853]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:30.853]                   base::options(opts)
[17:38:30.853]                 }
[17:38:30.853]                 {
[17:38:30.853]                   {
[17:38:30.853]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:30.853]                     NULL
[17:38:30.853]                   }
[17:38:30.853]                   options(future.plan = NULL)
[17:38:30.853]                   if (is.na(NA_character_)) 
[17:38:30.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:30.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:30.853]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:30.853]                     .init = FALSE)
[17:38:30.853]                 }
[17:38:30.853]             }
[17:38:30.853]         }
[17:38:30.853]     })
[17:38:30.853]     if (TRUE) {
[17:38:30.853]         base::sink(type = "output", split = FALSE)
[17:38:30.853]         if (FALSE) {
[17:38:30.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:30.853]         }
[17:38:30.853]         else {
[17:38:30.853]             ...future.result["stdout"] <- base::list(NULL)
[17:38:30.853]         }
[17:38:30.853]         base::close(...future.stdout)
[17:38:30.853]         ...future.stdout <- NULL
[17:38:30.853]     }
[17:38:30.853]     ...future.result$conditions <- ...future.conditions
[17:38:30.853]     ...future.result$finished <- base::Sys.time()
[17:38:30.853]     ...future.result
[17:38:30.853] }
[17:38:30.856] assign_globals() ...
[17:38:30.856] List of 5
[17:38:30.856]  $ ...future.FUN            :function (x)  
[17:38:30.856]  $ future.call.arguments    : list()
[17:38:30.856]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:30.856]  $ ...future.elements_ii    :List of 1
[17:38:30.856]   ..$ : int 1
[17:38:30.856]  $ ...future.seeds_ii       : NULL
[17:38:30.856]  $ ...future.globals.maxSize: NULL
[17:38:30.856]  - attr(*, "where")=List of 5
[17:38:30.856]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:30.856]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:30.856]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:30.856]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:30.856]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:30.856]  - attr(*, "resolved")= logi FALSE
[17:38:30.856]  - attr(*, "total_size")= num 4720
[17:38:30.856]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:30.856]  - attr(*, "already-done")= logi TRUE
[17:38:30.861] - reassign environment for ‘...future.FUN’
[17:38:30.861] - copied ‘...future.FUN’ to environment
[17:38:30.861] - copied ‘future.call.arguments’ to environment
[17:38:30.861] - copied ‘...future.elements_ii’ to environment
[17:38:30.861] - copied ‘...future.seeds_ii’ to environment
[17:38:30.861] - copied ‘...future.globals.maxSize’ to environment
[17:38:30.861] assign_globals() ... done
[17:38:30.862] requestCore(): workers = 2
[17:38:30.865] MulticoreFuture started
[17:38:30.865] - Launch lazy future ... done
[17:38:30.865] plan(): Setting new future strategy stack:
[17:38:30.865] run() for ‘MulticoreFuture’ ... done
[17:38:30.866] Created future:
[17:38:30.866] List of future strategies:
[17:38:30.866] 1. sequential:
[17:38:30.866]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:30.866]    - tweaked: FALSE
[17:38:30.866]    - call: NULL
[17:38:30.867] plan(): nbrOfWorkers() = 1
[17:38:30.866] MulticoreFuture:
[17:38:30.866] Label: ‘future_lapply-1’
[17:38:30.866] Expression:
[17:38:30.866] {
[17:38:30.866]     do.call(function(...) {
[17:38:30.866]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:30.866]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:30.866]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:30.866]             on.exit(options(oopts), add = TRUE)
[17:38:30.866]         }
[17:38:30.866]         {
[17:38:30.866]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:30.866]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:30.866]                 ...future.FUN(...future.X_jj, ...)
[17:38:30.866]             })
[17:38:30.866]         }
[17:38:30.866]     }, args = future.call.arguments)
[17:38:30.866] }
[17:38:30.866] Lazy evaluation: FALSE
[17:38:30.866] Asynchronous evaluation: TRUE
[17:38:30.866] Local evaluation: TRUE
[17:38:30.866] Environment: R_GlobalEnv
[17:38:30.866] Capture standard output: FALSE
[17:38:30.866] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:30.866] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:30.866] Packages: <none>
[17:38:30.866] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:30.866] Resolved: FALSE
[17:38:30.866] Value: <not collected>
[17:38:30.866] Conditions captured: <none>
[17:38:30.866] Early signaling: FALSE
[17:38:30.866] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:30.866] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:30.882] Chunk #1 of 2 ... DONE
[17:38:30.882] Chunk #2 of 2 ...
[17:38:30.882]  - Finding globals in 'X' for chunk #2 ...
[17:38:30.883] getGlobalsAndPackages() ...
[17:38:30.883] Searching for globals...
[17:38:30.883] 
[17:38:30.884] Searching for globals ... DONE
[17:38:30.884] - globals: [0] <none>
[17:38:30.884] getGlobalsAndPackages() ... DONE
[17:38:30.884]    + additional globals found: [n=0] 
[17:38:30.884]    + additional namespaces needed: [n=0] 
[17:38:30.885]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:30.885]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:30.885]  - seeds: <none>
[17:38:30.885]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:30.886] getGlobalsAndPackages() ...
[17:38:30.886] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:30.886] Resolving globals: FALSE
[17:38:30.886] Tweak future expression to call with '...' arguments ...
[17:38:30.886] {
[17:38:30.886]     do.call(function(...) {
[17:38:30.886]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:30.886]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:30.886]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:30.886]             on.exit(options(oopts), add = TRUE)
[17:38:30.886]         }
[17:38:30.886]         {
[17:38:30.886]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:30.886]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:30.886]                 ...future.FUN(...future.X_jj, ...)
[17:38:30.886]             })
[17:38:30.886]         }
[17:38:30.886]     }, args = future.call.arguments)
[17:38:30.886] }
[17:38:30.887] Tweak future expression to call with '...' arguments ... DONE
[17:38:30.888] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:30.888] 
[17:38:30.888] getGlobalsAndPackages() ... DONE
[17:38:30.889] run() for ‘Future’ ...
[17:38:30.889] - state: ‘created’
[17:38:30.889] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:30.895] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:30.895] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:30.895]   - Field: ‘label’
[17:38:30.895]   - Field: ‘local’
[17:38:30.895]   - Field: ‘owner’
[17:38:30.896]   - Field: ‘envir’
[17:38:30.896]   - Field: ‘workers’
[17:38:30.896]   - Field: ‘packages’
[17:38:30.896]   - Field: ‘gc’
[17:38:30.896]   - Field: ‘job’
[17:38:30.896]   - Field: ‘conditions’
[17:38:30.896]   - Field: ‘expr’
[17:38:30.897]   - Field: ‘uuid’
[17:38:30.897]   - Field: ‘seed’
[17:38:30.897]   - Field: ‘version’
[17:38:30.897]   - Field: ‘result’
[17:38:30.897]   - Field: ‘asynchronous’
[17:38:30.897]   - Field: ‘calls’
[17:38:30.897]   - Field: ‘globals’
[17:38:30.898]   - Field: ‘stdout’
[17:38:30.898]   - Field: ‘earlySignal’
[17:38:30.898]   - Field: ‘lazy’
[17:38:30.898]   - Field: ‘state’
[17:38:30.898] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:30.898] - Launch lazy future ...
[17:38:30.899] Packages needed by the future expression (n = 0): <none>
[17:38:30.899] Packages needed by future strategies (n = 0): <none>
[17:38:30.900] {
[17:38:30.900]     {
[17:38:30.900]         {
[17:38:30.900]             ...future.startTime <- base::Sys.time()
[17:38:30.900]             {
[17:38:30.900]                 {
[17:38:30.900]                   {
[17:38:30.900]                     {
[17:38:30.900]                       base::local({
[17:38:30.900]                         has_future <- base::requireNamespace("future", 
[17:38:30.900]                           quietly = TRUE)
[17:38:30.900]                         if (has_future) {
[17:38:30.900]                           ns <- base::getNamespace("future")
[17:38:30.900]                           version <- ns[[".package"]][["version"]]
[17:38:30.900]                           if (is.null(version)) 
[17:38:30.900]                             version <- utils::packageVersion("future")
[17:38:30.900]                         }
[17:38:30.900]                         else {
[17:38:30.900]                           version <- NULL
[17:38:30.900]                         }
[17:38:30.900]                         if (!has_future || version < "1.8.0") {
[17:38:30.900]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:30.900]                             "", base::R.version$version.string), 
[17:38:30.900]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:30.900]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:30.900]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:30.900]                               "release", "version")], collapse = " "), 
[17:38:30.900]                             hostname = base::Sys.info()[["nodename"]])
[17:38:30.900]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:30.900]                             info)
[17:38:30.900]                           info <- base::paste(info, collapse = "; ")
[17:38:30.900]                           if (!has_future) {
[17:38:30.900]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:30.900]                               info)
[17:38:30.900]                           }
[17:38:30.900]                           else {
[17:38:30.900]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:30.900]                               info, version)
[17:38:30.900]                           }
[17:38:30.900]                           base::stop(msg)
[17:38:30.900]                         }
[17:38:30.900]                       })
[17:38:30.900]                     }
[17:38:30.900]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:30.900]                     base::options(mc.cores = 1L)
[17:38:30.900]                   }
[17:38:30.900]                   ...future.strategy.old <- future::plan("list")
[17:38:30.900]                   options(future.plan = NULL)
[17:38:30.900]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:30.900]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:30.900]                 }
[17:38:30.900]                 ...future.workdir <- getwd()
[17:38:30.900]             }
[17:38:30.900]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:30.900]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:30.900]         }
[17:38:30.900]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:30.900]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:30.900]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:30.900]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:30.900]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:30.900]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:30.900]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:30.900]             base::names(...future.oldOptions))
[17:38:30.900]     }
[17:38:30.900]     if (FALSE) {
[17:38:30.900]     }
[17:38:30.900]     else {
[17:38:30.900]         if (FALSE) {
[17:38:30.900]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:30.900]                 open = "w")
[17:38:30.900]         }
[17:38:30.900]         else {
[17:38:30.900]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:30.900]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:30.900]         }
[17:38:30.900]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:30.900]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:30.900]             base::sink(type = "output", split = FALSE)
[17:38:30.900]             base::close(...future.stdout)
[17:38:30.900]         }, add = TRUE)
[17:38:30.900]     }
[17:38:30.900]     ...future.frame <- base::sys.nframe()
[17:38:30.900]     ...future.conditions <- base::list()
[17:38:30.900]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:30.900]     if (FALSE) {
[17:38:30.900]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:30.900]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:30.900]     }
[17:38:30.900]     ...future.result <- base::tryCatch({
[17:38:30.900]         base::withCallingHandlers({
[17:38:30.900]             ...future.value <- base::withVisible(base::local({
[17:38:30.900]                 withCallingHandlers({
[17:38:30.900]                   {
[17:38:30.900]                     do.call(function(...) {
[17:38:30.900]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:30.900]                       if (!identical(...future.globals.maxSize.org, 
[17:38:30.900]                         ...future.globals.maxSize)) {
[17:38:30.900]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:30.900]                         on.exit(options(oopts), add = TRUE)
[17:38:30.900]                       }
[17:38:30.900]                       {
[17:38:30.900]                         lapply(seq_along(...future.elements_ii), 
[17:38:30.900]                           FUN = function(jj) {
[17:38:30.900]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:30.900]                             ...future.FUN(...future.X_jj, ...)
[17:38:30.900]                           })
[17:38:30.900]                       }
[17:38:30.900]                     }, args = future.call.arguments)
[17:38:30.900]                   }
[17:38:30.900]                 }, immediateCondition = function(cond) {
[17:38:30.900]                   save_rds <- function (object, pathname, ...) 
[17:38:30.900]                   {
[17:38:30.900]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:30.900]                     if (file_test("-f", pathname_tmp)) {
[17:38:30.900]                       fi_tmp <- file.info(pathname_tmp)
[17:38:30.900]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:30.900]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:30.900]                         fi_tmp[["mtime"]])
[17:38:30.900]                     }
[17:38:30.900]                     tryCatch({
[17:38:30.900]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:30.900]                     }, error = function(ex) {
[17:38:30.900]                       msg <- conditionMessage(ex)
[17:38:30.900]                       fi_tmp <- file.info(pathname_tmp)
[17:38:30.900]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:30.900]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:30.900]                         fi_tmp[["mtime"]], msg)
[17:38:30.900]                       ex$message <- msg
[17:38:30.900]                       stop(ex)
[17:38:30.900]                     })
[17:38:30.900]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:30.900]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:30.900]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:30.900]                       fi_tmp <- file.info(pathname_tmp)
[17:38:30.900]                       fi <- file.info(pathname)
[17:38:30.900]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:30.900]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:30.900]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:30.900]                         fi[["size"]], fi[["mtime"]])
[17:38:30.900]                       stop(msg)
[17:38:30.900]                     }
[17:38:30.900]                     invisible(pathname)
[17:38:30.900]                   }
[17:38:30.900]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:30.900]                     rootPath = tempdir()) 
[17:38:30.900]                   {
[17:38:30.900]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:30.900]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:30.900]                       tmpdir = path, fileext = ".rds")
[17:38:30.900]                     save_rds(obj, file)
[17:38:30.900]                   }
[17:38:30.900]                   saveImmediateCondition(cond, path = "/tmp/RtmpBrP0ee/.future/immediateConditions")
[17:38:30.900]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:30.900]                   {
[17:38:30.900]                     inherits <- base::inherits
[17:38:30.900]                     invokeRestart <- base::invokeRestart
[17:38:30.900]                     is.null <- base::is.null
[17:38:30.900]                     muffled <- FALSE
[17:38:30.900]                     if (inherits(cond, "message")) {
[17:38:30.900]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:30.900]                       if (muffled) 
[17:38:30.900]                         invokeRestart("muffleMessage")
[17:38:30.900]                     }
[17:38:30.900]                     else if (inherits(cond, "warning")) {
[17:38:30.900]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:30.900]                       if (muffled) 
[17:38:30.900]                         invokeRestart("muffleWarning")
[17:38:30.900]                     }
[17:38:30.900]                     else if (inherits(cond, "condition")) {
[17:38:30.900]                       if (!is.null(pattern)) {
[17:38:30.900]                         computeRestarts <- base::computeRestarts
[17:38:30.900]                         grepl <- base::grepl
[17:38:30.900]                         restarts <- computeRestarts(cond)
[17:38:30.900]                         for (restart in restarts) {
[17:38:30.900]                           name <- restart$name
[17:38:30.900]                           if (is.null(name)) 
[17:38:30.900]                             next
[17:38:30.900]                           if (!grepl(pattern, name)) 
[17:38:30.900]                             next
[17:38:30.900]                           invokeRestart(restart)
[17:38:30.900]                           muffled <- TRUE
[17:38:30.900]                           break
[17:38:30.900]                         }
[17:38:30.900]                       }
[17:38:30.900]                     }
[17:38:30.900]                     invisible(muffled)
[17:38:30.900]                   }
[17:38:30.900]                   muffleCondition(cond)
[17:38:30.900]                 })
[17:38:30.900]             }))
[17:38:30.900]             future::FutureResult(value = ...future.value$value, 
[17:38:30.900]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:30.900]                   ...future.rng), globalenv = if (FALSE) 
[17:38:30.900]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:30.900]                     ...future.globalenv.names))
[17:38:30.900]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:30.900]         }, condition = base::local({
[17:38:30.900]             c <- base::c
[17:38:30.900]             inherits <- base::inherits
[17:38:30.900]             invokeRestart <- base::invokeRestart
[17:38:30.900]             length <- base::length
[17:38:30.900]             list <- base::list
[17:38:30.900]             seq.int <- base::seq.int
[17:38:30.900]             signalCondition <- base::signalCondition
[17:38:30.900]             sys.calls <- base::sys.calls
[17:38:30.900]             `[[` <- base::`[[`
[17:38:30.900]             `+` <- base::`+`
[17:38:30.900]             `<<-` <- base::`<<-`
[17:38:30.900]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:30.900]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:30.900]                   3L)]
[17:38:30.900]             }
[17:38:30.900]             function(cond) {
[17:38:30.900]                 is_error <- inherits(cond, "error")
[17:38:30.900]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:30.900]                   NULL)
[17:38:30.900]                 if (is_error) {
[17:38:30.900]                   sessionInformation <- function() {
[17:38:30.900]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:30.900]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:30.900]                       search = base::search(), system = base::Sys.info())
[17:38:30.900]                   }
[17:38:30.900]                   ...future.conditions[[length(...future.conditions) + 
[17:38:30.900]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:30.900]                     cond$call), session = sessionInformation(), 
[17:38:30.900]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:30.900]                   signalCondition(cond)
[17:38:30.900]                 }
[17:38:30.900]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:30.900]                 "immediateCondition"))) {
[17:38:30.900]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:30.900]                   ...future.conditions[[length(...future.conditions) + 
[17:38:30.900]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:30.900]                   if (TRUE && !signal) {
[17:38:30.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:30.900]                     {
[17:38:30.900]                       inherits <- base::inherits
[17:38:30.900]                       invokeRestart <- base::invokeRestart
[17:38:30.900]                       is.null <- base::is.null
[17:38:30.900]                       muffled <- FALSE
[17:38:30.900]                       if (inherits(cond, "message")) {
[17:38:30.900]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:30.900]                         if (muffled) 
[17:38:30.900]                           invokeRestart("muffleMessage")
[17:38:30.900]                       }
[17:38:30.900]                       else if (inherits(cond, "warning")) {
[17:38:30.900]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:30.900]                         if (muffled) 
[17:38:30.900]                           invokeRestart("muffleWarning")
[17:38:30.900]                       }
[17:38:30.900]                       else if (inherits(cond, "condition")) {
[17:38:30.900]                         if (!is.null(pattern)) {
[17:38:30.900]                           computeRestarts <- base::computeRestarts
[17:38:30.900]                           grepl <- base::grepl
[17:38:30.900]                           restarts <- computeRestarts(cond)
[17:38:30.900]                           for (restart in restarts) {
[17:38:30.900]                             name <- restart$name
[17:38:30.900]                             if (is.null(name)) 
[17:38:30.900]                               next
[17:38:30.900]                             if (!grepl(pattern, name)) 
[17:38:30.900]                               next
[17:38:30.900]                             invokeRestart(restart)
[17:38:30.900]                             muffled <- TRUE
[17:38:30.900]                             break
[17:38:30.900]                           }
[17:38:30.900]                         }
[17:38:30.900]                       }
[17:38:30.900]                       invisible(muffled)
[17:38:30.900]                     }
[17:38:30.900]                     muffleCondition(cond, pattern = "^muffle")
[17:38:30.900]                   }
[17:38:30.900]                 }
[17:38:30.900]                 else {
[17:38:30.900]                   if (TRUE) {
[17:38:30.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:30.900]                     {
[17:38:30.900]                       inherits <- base::inherits
[17:38:30.900]                       invokeRestart <- base::invokeRestart
[17:38:30.900]                       is.null <- base::is.null
[17:38:30.900]                       muffled <- FALSE
[17:38:30.900]                       if (inherits(cond, "message")) {
[17:38:30.900]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:30.900]                         if (muffled) 
[17:38:30.900]                           invokeRestart("muffleMessage")
[17:38:30.900]                       }
[17:38:30.900]                       else if (inherits(cond, "warning")) {
[17:38:30.900]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:30.900]                         if (muffled) 
[17:38:30.900]                           invokeRestart("muffleWarning")
[17:38:30.900]                       }
[17:38:30.900]                       else if (inherits(cond, "condition")) {
[17:38:30.900]                         if (!is.null(pattern)) {
[17:38:30.900]                           computeRestarts <- base::computeRestarts
[17:38:30.900]                           grepl <- base::grepl
[17:38:30.900]                           restarts <- computeRestarts(cond)
[17:38:30.900]                           for (restart in restarts) {
[17:38:30.900]                             name <- restart$name
[17:38:30.900]                             if (is.null(name)) 
[17:38:30.900]                               next
[17:38:30.900]                             if (!grepl(pattern, name)) 
[17:38:30.900]                               next
[17:38:30.900]                             invokeRestart(restart)
[17:38:30.900]                             muffled <- TRUE
[17:38:30.900]                             break
[17:38:30.900]                           }
[17:38:30.900]                         }
[17:38:30.900]                       }
[17:38:30.900]                       invisible(muffled)
[17:38:30.900]                     }
[17:38:30.900]                     muffleCondition(cond, pattern = "^muffle")
[17:38:30.900]                   }
[17:38:30.900]                 }
[17:38:30.900]             }
[17:38:30.900]         }))
[17:38:30.900]     }, error = function(ex) {
[17:38:30.900]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:30.900]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:30.900]                 ...future.rng), started = ...future.startTime, 
[17:38:30.900]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:30.900]             version = "1.8"), class = "FutureResult")
[17:38:30.900]     }, finally = {
[17:38:30.900]         if (!identical(...future.workdir, getwd())) 
[17:38:30.900]             setwd(...future.workdir)
[17:38:30.900]         {
[17:38:30.900]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:30.900]                 ...future.oldOptions$nwarnings <- NULL
[17:38:30.900]             }
[17:38:30.900]             base::options(...future.oldOptions)
[17:38:30.900]             if (.Platform$OS.type == "windows") {
[17:38:30.900]                 old_names <- names(...future.oldEnvVars)
[17:38:30.900]                 envs <- base::Sys.getenv()
[17:38:30.900]                 names <- names(envs)
[17:38:30.900]                 common <- intersect(names, old_names)
[17:38:30.900]                 added <- setdiff(names, old_names)
[17:38:30.900]                 removed <- setdiff(old_names, names)
[17:38:30.900]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:30.900]                   envs[common]]
[17:38:30.900]                 NAMES <- toupper(changed)
[17:38:30.900]                 args <- list()
[17:38:30.900]                 for (kk in seq_along(NAMES)) {
[17:38:30.900]                   name <- changed[[kk]]
[17:38:30.900]                   NAME <- NAMES[[kk]]
[17:38:30.900]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:30.900]                     next
[17:38:30.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:30.900]                 }
[17:38:30.900]                 NAMES <- toupper(added)
[17:38:30.900]                 for (kk in seq_along(NAMES)) {
[17:38:30.900]                   name <- added[[kk]]
[17:38:30.900]                   NAME <- NAMES[[kk]]
[17:38:30.900]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:30.900]                     next
[17:38:30.900]                   args[[name]] <- ""
[17:38:30.900]                 }
[17:38:30.900]                 NAMES <- toupper(removed)
[17:38:30.900]                 for (kk in seq_along(NAMES)) {
[17:38:30.900]                   name <- removed[[kk]]
[17:38:30.900]                   NAME <- NAMES[[kk]]
[17:38:30.900]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:30.900]                     next
[17:38:30.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:30.900]                 }
[17:38:30.900]                 if (length(args) > 0) 
[17:38:30.900]                   base::do.call(base::Sys.setenv, args = args)
[17:38:30.900]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:30.900]             }
[17:38:30.900]             else {
[17:38:30.900]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:30.900]             }
[17:38:30.900]             {
[17:38:30.900]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:30.900]                   0L) {
[17:38:30.900]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:30.900]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:30.900]                   base::options(opts)
[17:38:30.900]                 }
[17:38:30.900]                 {
[17:38:30.900]                   {
[17:38:30.900]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:30.900]                     NULL
[17:38:30.900]                   }
[17:38:30.900]                   options(future.plan = NULL)
[17:38:30.900]                   if (is.na(NA_character_)) 
[17:38:30.900]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:30.900]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:30.900]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:30.900]                     .init = FALSE)
[17:38:30.900]                 }
[17:38:30.900]             }
[17:38:30.900]         }
[17:38:30.900]     })
[17:38:30.900]     if (TRUE) {
[17:38:30.900]         base::sink(type = "output", split = FALSE)
[17:38:30.900]         if (FALSE) {
[17:38:30.900]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:30.900]         }
[17:38:30.900]         else {
[17:38:30.900]             ...future.result["stdout"] <- base::list(NULL)
[17:38:30.900]         }
[17:38:30.900]         base::close(...future.stdout)
[17:38:30.900]         ...future.stdout <- NULL
[17:38:30.900]     }
[17:38:30.900]     ...future.result$conditions <- ...future.conditions
[17:38:30.900]     ...future.result$finished <- base::Sys.time()
[17:38:30.900]     ...future.result
[17:38:30.900] }
[17:38:30.903] assign_globals() ...
[17:38:30.903] List of 5
[17:38:30.903]  $ ...future.FUN            :function (x)  
[17:38:30.903]  $ future.call.arguments    : list()
[17:38:30.903]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:30.903]  $ ...future.elements_ii    :List of 1
[17:38:30.903]   ..$ : int 0
[17:38:30.903]  $ ...future.seeds_ii       : NULL
[17:38:30.903]  $ ...future.globals.maxSize: NULL
[17:38:30.903]  - attr(*, "where")=List of 5
[17:38:30.903]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:30.903]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:30.903]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:30.903]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:30.903]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:30.903]  - attr(*, "resolved")= logi FALSE
[17:38:30.903]  - attr(*, "total_size")= num 4720
[17:38:30.903]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:30.903]  - attr(*, "already-done")= logi TRUE
[17:38:30.910] - reassign environment for ‘...future.FUN’
[17:38:30.910] - copied ‘...future.FUN’ to environment
[17:38:30.910] - copied ‘future.call.arguments’ to environment
[17:38:30.910] - copied ‘...future.elements_ii’ to environment
[17:38:30.911] - copied ‘...future.seeds_ii’ to environment
[17:38:30.911] - copied ‘...future.globals.maxSize’ to environment
[17:38:30.911] assign_globals() ... done
[17:38:30.911] requestCore(): workers = 2
[17:38:30.921] MulticoreFuture started
[17:38:30.921] - Launch lazy future ... done
[17:38:30.922] run() for ‘MulticoreFuture’ ... done
[17:38:30.922] plan(): Setting new future strategy stack:
[17:38:30.923] Created future:
[17:38:30.923] List of future strategies:
[17:38:30.923] 1. sequential:
[17:38:30.923]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:30.923]    - tweaked: FALSE
[17:38:30.923]    - call: NULL
[17:38:30.924] plan(): nbrOfWorkers() = 1
[17:38:30.926] plan(): Setting new future strategy stack:
[17:38:30.926] List of future strategies:
[17:38:30.926] 1. multicore:
[17:38:30.926]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:30.926]    - tweaked: FALSE
[17:38:30.926]    - call: plan(strategy)
[17:38:30.932] plan(): nbrOfWorkers() = 2
[17:38:30.923] MulticoreFuture:
[17:38:30.923] Label: ‘future_lapply-2’
[17:38:30.923] Expression:
[17:38:30.923] {
[17:38:30.923]     do.call(function(...) {
[17:38:30.923]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:30.923]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:30.923]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:30.923]             on.exit(options(oopts), add = TRUE)
[17:38:30.923]         }
[17:38:30.923]         {
[17:38:30.923]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:30.923]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:30.923]                 ...future.FUN(...future.X_jj, ...)
[17:38:30.923]             })
[17:38:30.923]         }
[17:38:30.923]     }, args = future.call.arguments)
[17:38:30.923] }
[17:38:30.923] Lazy evaluation: FALSE
[17:38:30.923] Asynchronous evaluation: TRUE
[17:38:30.923] Local evaluation: TRUE
[17:38:30.923] Environment: R_GlobalEnv
[17:38:30.923] Capture standard output: FALSE
[17:38:30.923] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:30.923] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:30.923] Packages: <none>
[17:38:30.923] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:30.923] Resolved: TRUE
[17:38:30.923] Value: <not collected>
[17:38:30.923] Conditions captured: <none>
[17:38:30.923] Early signaling: FALSE
[17:38:30.923] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:30.923] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:30.933] Chunk #2 of 2 ... DONE
[17:38:30.933] Launching 2 futures (chunks) ... DONE
[17:38:30.933] Resolving 2 futures (chunks) ...
[17:38:30.934] resolve() on list ...
[17:38:30.934]  recursive: 0
[17:38:30.934]  length: 2
[17:38:30.934] 
[17:38:30.945] Future #2
[17:38:30.946] result() for MulticoreFuture ...
[17:38:30.948] result() for MulticoreFuture ...
[17:38:30.948] result() for MulticoreFuture ... done
[17:38:30.948] result() for MulticoreFuture ... done
[17:38:30.949] result() for MulticoreFuture ...
[17:38:30.949] result() for MulticoreFuture ... done
[17:38:30.949] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:38:30.949] - nx: 2
[17:38:30.949] - relay: TRUE
[17:38:30.949] - stdout: TRUE
[17:38:30.949] - signal: TRUE
[17:38:30.950] - resignal: FALSE
[17:38:30.950] - force: TRUE
[17:38:30.950] - relayed: [n=2] FALSE, FALSE
[17:38:30.950] - queued futures: [n=2] FALSE, FALSE
[17:38:30.950]  - until=1
[17:38:30.950]  - relaying element #1
[17:38:30.950] - relayed: [n=2] FALSE, FALSE
[17:38:30.950] - queued futures: [n=2] FALSE, TRUE
[17:38:30.951] signalConditionsASAP(NULL, pos=2) ... done
[17:38:30.951]  length: 1 (resolved future 2)
[17:38:31.370] plan(): Setting new future strategy stack:
[17:38:31.370] List of future strategies:
[17:38:31.370] 1. multicore:
[17:38:31.370]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:31.370]    - tweaked: FALSE
[17:38:31.370]    - call: plan(strategy)
[17:38:31.375] plan(): nbrOfWorkers() = 2
[17:38:31.375] Future #1
[17:38:31.375] result() for MulticoreFuture ...
[17:38:31.376] result() for MulticoreFuture ...
[17:38:31.376] result() for MulticoreFuture ... done
[17:38:31.377] result() for MulticoreFuture ... done
[17:38:31.377] result() for MulticoreFuture ...
[17:38:31.377] result() for MulticoreFuture ... done
[17:38:31.377] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:38:31.377] - nx: 2
[17:38:31.377] - relay: TRUE
[17:38:31.377] - stdout: TRUE
[17:38:31.377] - signal: TRUE
[17:38:31.377] - resignal: FALSE
[17:38:31.378] - force: TRUE
[17:38:31.378] - relayed: [n=2] FALSE, FALSE
[17:38:31.378] - queued futures: [n=2] FALSE, TRUE
[17:38:31.378]  - until=1
[17:38:31.378]  - relaying element #1
[17:38:31.378] result() for MulticoreFuture ...
[17:38:31.378] result() for MulticoreFuture ... done
[17:38:31.378] result() for MulticoreFuture ...
[17:38:31.378] result() for MulticoreFuture ... done
[17:38:31.379] result() for MulticoreFuture ...
[17:38:31.379] result() for MulticoreFuture ... done
[17:38:31.379] result() for MulticoreFuture ...
[17:38:31.379] result() for MulticoreFuture ... done
[17:38:31.379] - relayed: [n=2] TRUE, FALSE
[17:38:31.379] - queued futures: [n=2] TRUE, TRUE
[17:38:31.379] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:38:31.379]  length: 0 (resolved future 1)
[17:38:31.379] Relaying remaining futures
[17:38:31.380] signalConditionsASAP(NULL, pos=0) ...
[17:38:31.380] - nx: 2
[17:38:31.380] - relay: TRUE
[17:38:31.380] - stdout: TRUE
[17:38:31.380] - signal: TRUE
[17:38:31.380] - resignal: FALSE
[17:38:31.380] - force: TRUE
[17:38:31.380] - relayed: [n=2] TRUE, FALSE
[17:38:31.380] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:31.381]  - relaying element #2
[17:38:31.381] result() for MulticoreFuture ...
[17:38:31.381] result() for MulticoreFuture ... done
[17:38:31.381] result() for MulticoreFuture ...
[17:38:31.381] result() for MulticoreFuture ... done
[17:38:31.381] result() for MulticoreFuture ...
[17:38:31.381] result() for MulticoreFuture ... done
[17:38:31.381] result() for MulticoreFuture ...
[17:38:31.382] result() for MulticoreFuture ... done
[17:38:31.382] - relayed: [n=2] TRUE, TRUE
[17:38:31.382] - queued futures: [n=2] TRUE, TRUE
[17:38:31.382] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:38:31.382] resolve() on list ... DONE
[17:38:31.382] result() for MulticoreFuture ...
[17:38:31.382] result() for MulticoreFuture ... done
[17:38:31.382] result() for MulticoreFuture ...
[17:38:31.382] result() for MulticoreFuture ... done
[17:38:31.383] result() for MulticoreFuture ...
[17:38:31.383] result() for MulticoreFuture ... done
[17:38:31.383] result() for MulticoreFuture ...
[17:38:31.383] result() for MulticoreFuture ... done
[17:38:31.383]  - Number of value chunks collected: 2
[17:38:31.383] Resolving 2 futures (chunks) ... DONE
[17:38:31.383] Reducing values from 2 chunks ...
[17:38:31.383]  - Number of values collected after concatenation: 2
[17:38:31.383]  - Number of values expected: 2
[17:38:31.384] Reducing values from 2 chunks ... DONE
[17:38:31.384] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[17:38:31.384] future_lapply() ...
[17:38:31.389] Number of chunks: 2
[17:38:31.389] getGlobalsAndPackagesXApply() ...
[17:38:31.389]  - future.globals: TRUE
[17:38:31.389] getGlobalsAndPackages() ...
[17:38:31.390] Searching for globals...
[17:38:31.391] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:38:31.391] Searching for globals ... DONE
[17:38:31.391] Resolving globals: FALSE
[17:38:31.392] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:38:31.392] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:38:31.392] - globals: [1] ‘FUN’
[17:38:31.393] 
[17:38:31.393] getGlobalsAndPackages() ... DONE
[17:38:31.393]  - globals found/used: [n=1] ‘FUN’
[17:38:31.393]  - needed namespaces: [n=0] 
[17:38:31.393] Finding globals ... DONE
[17:38:31.393]  - use_args: TRUE
[17:38:31.393]  - Getting '...' globals ...
[17:38:31.394] resolve() on list ...
[17:38:31.394]  recursive: 0
[17:38:31.394]  length: 1
[17:38:31.394]  elements: ‘...’
[17:38:31.394]  length: 0 (resolved future 1)
[17:38:31.394] resolve() on list ... DONE
[17:38:31.394]    - '...' content: [n=0] 
[17:38:31.394] List of 1
[17:38:31.394]  $ ...: list()
[17:38:31.394]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:31.394]  - attr(*, "where")=List of 1
[17:38:31.394]   ..$ ...:<environment: 0x5628ab8f2760> 
[17:38:31.394]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:31.394]  - attr(*, "resolved")= logi TRUE
[17:38:31.394]  - attr(*, "total_size")= num NA
[17:38:31.399]  - Getting '...' globals ... DONE
[17:38:31.400] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:38:31.400] List of 2
[17:38:31.400]  $ ...future.FUN:function (x)  
[17:38:31.400]  $ ...          : list()
[17:38:31.400]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:31.400]  - attr(*, "where")=List of 2
[17:38:31.400]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:31.400]   ..$ ...          :<environment: 0x5628ab8f2760> 
[17:38:31.400]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:31.400]  - attr(*, "resolved")= logi FALSE
[17:38:31.400]  - attr(*, "total_size")= num 4720
[17:38:31.402] Packages to be attached in all futures: [n=0] 
[17:38:31.403] getGlobalsAndPackagesXApply() ... DONE
[17:38:31.403] Number of futures (= number of chunks): 2
[17:38:31.403] Launching 2 futures (chunks) ...
[17:38:31.403] Chunk #1 of 2 ...
[17:38:31.403]  - Finding globals in 'X' for chunk #1 ...
[17:38:31.403] getGlobalsAndPackages() ...
[17:38:31.403] Searching for globals...
[17:38:31.404] 
[17:38:31.404] Searching for globals ... DONE
[17:38:31.404] - globals: [0] <none>
[17:38:31.404] getGlobalsAndPackages() ... DONE
[17:38:31.404]    + additional globals found: [n=0] 
[17:38:31.404]    + additional namespaces needed: [n=0] 
[17:38:31.404]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:31.404]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:31.404]  - seeds: <none>
[17:38:31.404]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:31.405] getGlobalsAndPackages() ...
[17:38:31.405] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:31.405] Resolving globals: FALSE
[17:38:31.405] Tweak future expression to call with '...' arguments ...
[17:38:31.405] {
[17:38:31.405]     do.call(function(...) {
[17:38:31.405]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:31.405]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:31.405]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:31.405]             on.exit(options(oopts), add = TRUE)
[17:38:31.405]         }
[17:38:31.405]         {
[17:38:31.405]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:31.405]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:31.405]                 ...future.FUN(...future.X_jj, ...)
[17:38:31.405]             })
[17:38:31.405]         }
[17:38:31.405]     }, args = future.call.arguments)
[17:38:31.405] }
[17:38:31.405] Tweak future expression to call with '...' arguments ... DONE
[17:38:31.406] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:31.406] 
[17:38:31.406] getGlobalsAndPackages() ... DONE
[17:38:31.406] run() for ‘Future’ ...
[17:38:31.406] - state: ‘created’
[17:38:31.406] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:31.410] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:31.410] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:31.411]   - Field: ‘label’
[17:38:31.411]   - Field: ‘local’
[17:38:31.411]   - Field: ‘owner’
[17:38:31.411]   - Field: ‘envir’
[17:38:31.411]   - Field: ‘workers’
[17:38:31.411]   - Field: ‘packages’
[17:38:31.411]   - Field: ‘gc’
[17:38:31.411]   - Field: ‘job’
[17:38:31.412]   - Field: ‘conditions’
[17:38:31.412]   - Field: ‘expr’
[17:38:31.412]   - Field: ‘uuid’
[17:38:31.412]   - Field: ‘seed’
[17:38:31.412]   - Field: ‘version’
[17:38:31.412]   - Field: ‘result’
[17:38:31.412]   - Field: ‘asynchronous’
[17:38:31.412]   - Field: ‘calls’
[17:38:31.412]   - Field: ‘globals’
[17:38:31.413]   - Field: ‘stdout’
[17:38:31.413]   - Field: ‘earlySignal’
[17:38:31.413]   - Field: ‘lazy’
[17:38:31.413]   - Field: ‘state’
[17:38:31.413] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:31.413] - Launch lazy future ...
[17:38:31.413] Packages needed by the future expression (n = 0): <none>
[17:38:31.414] Packages needed by future strategies (n = 0): <none>
[17:38:31.414] {
[17:38:31.414]     {
[17:38:31.414]         {
[17:38:31.414]             ...future.startTime <- base::Sys.time()
[17:38:31.414]             {
[17:38:31.414]                 {
[17:38:31.414]                   {
[17:38:31.414]                     {
[17:38:31.414]                       base::local({
[17:38:31.414]                         has_future <- base::requireNamespace("future", 
[17:38:31.414]                           quietly = TRUE)
[17:38:31.414]                         if (has_future) {
[17:38:31.414]                           ns <- base::getNamespace("future")
[17:38:31.414]                           version <- ns[[".package"]][["version"]]
[17:38:31.414]                           if (is.null(version)) 
[17:38:31.414]                             version <- utils::packageVersion("future")
[17:38:31.414]                         }
[17:38:31.414]                         else {
[17:38:31.414]                           version <- NULL
[17:38:31.414]                         }
[17:38:31.414]                         if (!has_future || version < "1.8.0") {
[17:38:31.414]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:31.414]                             "", base::R.version$version.string), 
[17:38:31.414]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:31.414]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:31.414]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:31.414]                               "release", "version")], collapse = " "), 
[17:38:31.414]                             hostname = base::Sys.info()[["nodename"]])
[17:38:31.414]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:31.414]                             info)
[17:38:31.414]                           info <- base::paste(info, collapse = "; ")
[17:38:31.414]                           if (!has_future) {
[17:38:31.414]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:31.414]                               info)
[17:38:31.414]                           }
[17:38:31.414]                           else {
[17:38:31.414]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:31.414]                               info, version)
[17:38:31.414]                           }
[17:38:31.414]                           base::stop(msg)
[17:38:31.414]                         }
[17:38:31.414]                       })
[17:38:31.414]                     }
[17:38:31.414]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:31.414]                     base::options(mc.cores = 1L)
[17:38:31.414]                   }
[17:38:31.414]                   ...future.strategy.old <- future::plan("list")
[17:38:31.414]                   options(future.plan = NULL)
[17:38:31.414]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:31.414]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:31.414]                 }
[17:38:31.414]                 ...future.workdir <- getwd()
[17:38:31.414]             }
[17:38:31.414]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:31.414]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:31.414]         }
[17:38:31.414]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:31.414]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:31.414]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:31.414]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:31.414]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:31.414]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:31.414]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:31.414]             base::names(...future.oldOptions))
[17:38:31.414]     }
[17:38:31.414]     if (FALSE) {
[17:38:31.414]     }
[17:38:31.414]     else {
[17:38:31.414]         if (TRUE) {
[17:38:31.414]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:31.414]                 open = "w")
[17:38:31.414]         }
[17:38:31.414]         else {
[17:38:31.414]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:31.414]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:31.414]         }
[17:38:31.414]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:31.414]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:31.414]             base::sink(type = "output", split = FALSE)
[17:38:31.414]             base::close(...future.stdout)
[17:38:31.414]         }, add = TRUE)
[17:38:31.414]     }
[17:38:31.414]     ...future.frame <- base::sys.nframe()
[17:38:31.414]     ...future.conditions <- base::list()
[17:38:31.414]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:31.414]     if (FALSE) {
[17:38:31.414]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:31.414]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:31.414]     }
[17:38:31.414]     ...future.result <- base::tryCatch({
[17:38:31.414]         base::withCallingHandlers({
[17:38:31.414]             ...future.value <- base::withVisible(base::local({
[17:38:31.414]                 withCallingHandlers({
[17:38:31.414]                   {
[17:38:31.414]                     do.call(function(...) {
[17:38:31.414]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:31.414]                       if (!identical(...future.globals.maxSize.org, 
[17:38:31.414]                         ...future.globals.maxSize)) {
[17:38:31.414]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:31.414]                         on.exit(options(oopts), add = TRUE)
[17:38:31.414]                       }
[17:38:31.414]                       {
[17:38:31.414]                         lapply(seq_along(...future.elements_ii), 
[17:38:31.414]                           FUN = function(jj) {
[17:38:31.414]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:31.414]                             ...future.FUN(...future.X_jj, ...)
[17:38:31.414]                           })
[17:38:31.414]                       }
[17:38:31.414]                     }, args = future.call.arguments)
[17:38:31.414]                   }
[17:38:31.414]                 }, immediateCondition = function(cond) {
[17:38:31.414]                   save_rds <- function (object, pathname, ...) 
[17:38:31.414]                   {
[17:38:31.414]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:31.414]                     if (file_test("-f", pathname_tmp)) {
[17:38:31.414]                       fi_tmp <- file.info(pathname_tmp)
[17:38:31.414]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:31.414]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:31.414]                         fi_tmp[["mtime"]])
[17:38:31.414]                     }
[17:38:31.414]                     tryCatch({
[17:38:31.414]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:31.414]                     }, error = function(ex) {
[17:38:31.414]                       msg <- conditionMessage(ex)
[17:38:31.414]                       fi_tmp <- file.info(pathname_tmp)
[17:38:31.414]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:31.414]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:31.414]                         fi_tmp[["mtime"]], msg)
[17:38:31.414]                       ex$message <- msg
[17:38:31.414]                       stop(ex)
[17:38:31.414]                     })
[17:38:31.414]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:31.414]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:31.414]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:31.414]                       fi_tmp <- file.info(pathname_tmp)
[17:38:31.414]                       fi <- file.info(pathname)
[17:38:31.414]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:31.414]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:31.414]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:31.414]                         fi[["size"]], fi[["mtime"]])
[17:38:31.414]                       stop(msg)
[17:38:31.414]                     }
[17:38:31.414]                     invisible(pathname)
[17:38:31.414]                   }
[17:38:31.414]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:31.414]                     rootPath = tempdir()) 
[17:38:31.414]                   {
[17:38:31.414]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:31.414]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:31.414]                       tmpdir = path, fileext = ".rds")
[17:38:31.414]                     save_rds(obj, file)
[17:38:31.414]                   }
[17:38:31.414]                   saveImmediateCondition(cond, path = "/tmp/RtmpBrP0ee/.future/immediateConditions")
[17:38:31.414]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:31.414]                   {
[17:38:31.414]                     inherits <- base::inherits
[17:38:31.414]                     invokeRestart <- base::invokeRestart
[17:38:31.414]                     is.null <- base::is.null
[17:38:31.414]                     muffled <- FALSE
[17:38:31.414]                     if (inherits(cond, "message")) {
[17:38:31.414]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:31.414]                       if (muffled) 
[17:38:31.414]                         invokeRestart("muffleMessage")
[17:38:31.414]                     }
[17:38:31.414]                     else if (inherits(cond, "warning")) {
[17:38:31.414]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:31.414]                       if (muffled) 
[17:38:31.414]                         invokeRestart("muffleWarning")
[17:38:31.414]                     }
[17:38:31.414]                     else if (inherits(cond, "condition")) {
[17:38:31.414]                       if (!is.null(pattern)) {
[17:38:31.414]                         computeRestarts <- base::computeRestarts
[17:38:31.414]                         grepl <- base::grepl
[17:38:31.414]                         restarts <- computeRestarts(cond)
[17:38:31.414]                         for (restart in restarts) {
[17:38:31.414]                           name <- restart$name
[17:38:31.414]                           if (is.null(name)) 
[17:38:31.414]                             next
[17:38:31.414]                           if (!grepl(pattern, name)) 
[17:38:31.414]                             next
[17:38:31.414]                           invokeRestart(restart)
[17:38:31.414]                           muffled <- TRUE
[17:38:31.414]                           break
[17:38:31.414]                         }
[17:38:31.414]                       }
[17:38:31.414]                     }
[17:38:31.414]                     invisible(muffled)
[17:38:31.414]                   }
[17:38:31.414]                   muffleCondition(cond)
[17:38:31.414]                 })
[17:38:31.414]             }))
[17:38:31.414]             future::FutureResult(value = ...future.value$value, 
[17:38:31.414]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:31.414]                   ...future.rng), globalenv = if (FALSE) 
[17:38:31.414]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:31.414]                     ...future.globalenv.names))
[17:38:31.414]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:31.414]         }, condition = base::local({
[17:38:31.414]             c <- base::c
[17:38:31.414]             inherits <- base::inherits
[17:38:31.414]             invokeRestart <- base::invokeRestart
[17:38:31.414]             length <- base::length
[17:38:31.414]             list <- base::list
[17:38:31.414]             seq.int <- base::seq.int
[17:38:31.414]             signalCondition <- base::signalCondition
[17:38:31.414]             sys.calls <- base::sys.calls
[17:38:31.414]             `[[` <- base::`[[`
[17:38:31.414]             `+` <- base::`+`
[17:38:31.414]             `<<-` <- base::`<<-`
[17:38:31.414]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:31.414]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:31.414]                   3L)]
[17:38:31.414]             }
[17:38:31.414]             function(cond) {
[17:38:31.414]                 is_error <- inherits(cond, "error")
[17:38:31.414]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:31.414]                   NULL)
[17:38:31.414]                 if (is_error) {
[17:38:31.414]                   sessionInformation <- function() {
[17:38:31.414]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:31.414]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:31.414]                       search = base::search(), system = base::Sys.info())
[17:38:31.414]                   }
[17:38:31.414]                   ...future.conditions[[length(...future.conditions) + 
[17:38:31.414]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:31.414]                     cond$call), session = sessionInformation(), 
[17:38:31.414]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:31.414]                   signalCondition(cond)
[17:38:31.414]                 }
[17:38:31.414]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:31.414]                 "immediateCondition"))) {
[17:38:31.414]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:31.414]                   ...future.conditions[[length(...future.conditions) + 
[17:38:31.414]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:31.414]                   if (TRUE && !signal) {
[17:38:31.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:31.414]                     {
[17:38:31.414]                       inherits <- base::inherits
[17:38:31.414]                       invokeRestart <- base::invokeRestart
[17:38:31.414]                       is.null <- base::is.null
[17:38:31.414]                       muffled <- FALSE
[17:38:31.414]                       if (inherits(cond, "message")) {
[17:38:31.414]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:31.414]                         if (muffled) 
[17:38:31.414]                           invokeRestart("muffleMessage")
[17:38:31.414]                       }
[17:38:31.414]                       else if (inherits(cond, "warning")) {
[17:38:31.414]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:31.414]                         if (muffled) 
[17:38:31.414]                           invokeRestart("muffleWarning")
[17:38:31.414]                       }
[17:38:31.414]                       else if (inherits(cond, "condition")) {
[17:38:31.414]                         if (!is.null(pattern)) {
[17:38:31.414]                           computeRestarts <- base::computeRestarts
[17:38:31.414]                           grepl <- base::grepl
[17:38:31.414]                           restarts <- computeRestarts(cond)
[17:38:31.414]                           for (restart in restarts) {
[17:38:31.414]                             name <- restart$name
[17:38:31.414]                             if (is.null(name)) 
[17:38:31.414]                               next
[17:38:31.414]                             if (!grepl(pattern, name)) 
[17:38:31.414]                               next
[17:38:31.414]                             invokeRestart(restart)
[17:38:31.414]                             muffled <- TRUE
[17:38:31.414]                             break
[17:38:31.414]                           }
[17:38:31.414]                         }
[17:38:31.414]                       }
[17:38:31.414]                       invisible(muffled)
[17:38:31.414]                     }
[17:38:31.414]                     muffleCondition(cond, pattern = "^muffle")
[17:38:31.414]                   }
[17:38:31.414]                 }
[17:38:31.414]                 else {
[17:38:31.414]                   if (TRUE) {
[17:38:31.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:31.414]                     {
[17:38:31.414]                       inherits <- base::inherits
[17:38:31.414]                       invokeRestart <- base::invokeRestart
[17:38:31.414]                       is.null <- base::is.null
[17:38:31.414]                       muffled <- FALSE
[17:38:31.414]                       if (inherits(cond, "message")) {
[17:38:31.414]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:31.414]                         if (muffled) 
[17:38:31.414]                           invokeRestart("muffleMessage")
[17:38:31.414]                       }
[17:38:31.414]                       else if (inherits(cond, "warning")) {
[17:38:31.414]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:31.414]                         if (muffled) 
[17:38:31.414]                           invokeRestart("muffleWarning")
[17:38:31.414]                       }
[17:38:31.414]                       else if (inherits(cond, "condition")) {
[17:38:31.414]                         if (!is.null(pattern)) {
[17:38:31.414]                           computeRestarts <- base::computeRestarts
[17:38:31.414]                           grepl <- base::grepl
[17:38:31.414]                           restarts <- computeRestarts(cond)
[17:38:31.414]                           for (restart in restarts) {
[17:38:31.414]                             name <- restart$name
[17:38:31.414]                             if (is.null(name)) 
[17:38:31.414]                               next
[17:38:31.414]                             if (!grepl(pattern, name)) 
[17:38:31.414]                               next
[17:38:31.414]                             invokeRestart(restart)
[17:38:31.414]                             muffled <- TRUE
[17:38:31.414]                             break
[17:38:31.414]                           }
[17:38:31.414]                         }
[17:38:31.414]                       }
[17:38:31.414]                       invisible(muffled)
[17:38:31.414]                     }
[17:38:31.414]                     muffleCondition(cond, pattern = "^muffle")
[17:38:31.414]                   }
[17:38:31.414]                 }
[17:38:31.414]             }
[17:38:31.414]         }))
[17:38:31.414]     }, error = function(ex) {
[17:38:31.414]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:31.414]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:31.414]                 ...future.rng), started = ...future.startTime, 
[17:38:31.414]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:31.414]             version = "1.8"), class = "FutureResult")
[17:38:31.414]     }, finally = {
[17:38:31.414]         if (!identical(...future.workdir, getwd())) 
[17:38:31.414]             setwd(...future.workdir)
[17:38:31.414]         {
[17:38:31.414]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:31.414]                 ...future.oldOptions$nwarnings <- NULL
[17:38:31.414]             }
[17:38:31.414]             base::options(...future.oldOptions)
[17:38:31.414]             if (.Platform$OS.type == "windows") {
[17:38:31.414]                 old_names <- names(...future.oldEnvVars)
[17:38:31.414]                 envs <- base::Sys.getenv()
[17:38:31.414]                 names <- names(envs)
[17:38:31.414]                 common <- intersect(names, old_names)
[17:38:31.414]                 added <- setdiff(names, old_names)
[17:38:31.414]                 removed <- setdiff(old_names, names)
[17:38:31.414]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:31.414]                   envs[common]]
[17:38:31.414]                 NAMES <- toupper(changed)
[17:38:31.414]                 args <- list()
[17:38:31.414]                 for (kk in seq_along(NAMES)) {
[17:38:31.414]                   name <- changed[[kk]]
[17:38:31.414]                   NAME <- NAMES[[kk]]
[17:38:31.414]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:31.414]                     next
[17:38:31.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:31.414]                 }
[17:38:31.414]                 NAMES <- toupper(added)
[17:38:31.414]                 for (kk in seq_along(NAMES)) {
[17:38:31.414]                   name <- added[[kk]]
[17:38:31.414]                   NAME <- NAMES[[kk]]
[17:38:31.414]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:31.414]                     next
[17:38:31.414]                   args[[name]] <- ""
[17:38:31.414]                 }
[17:38:31.414]                 NAMES <- toupper(removed)
[17:38:31.414]                 for (kk in seq_along(NAMES)) {
[17:38:31.414]                   name <- removed[[kk]]
[17:38:31.414]                   NAME <- NAMES[[kk]]
[17:38:31.414]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:31.414]                     next
[17:38:31.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:31.414]                 }
[17:38:31.414]                 if (length(args) > 0) 
[17:38:31.414]                   base::do.call(base::Sys.setenv, args = args)
[17:38:31.414]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:31.414]             }
[17:38:31.414]             else {
[17:38:31.414]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:31.414]             }
[17:38:31.414]             {
[17:38:31.414]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:31.414]                   0L) {
[17:38:31.414]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:31.414]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:31.414]                   base::options(opts)
[17:38:31.414]                 }
[17:38:31.414]                 {
[17:38:31.414]                   {
[17:38:31.414]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:31.414]                     NULL
[17:38:31.414]                   }
[17:38:31.414]                   options(future.plan = NULL)
[17:38:31.414]                   if (is.na(NA_character_)) 
[17:38:31.414]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:31.414]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:31.414]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:31.414]                     .init = FALSE)
[17:38:31.414]                 }
[17:38:31.414]             }
[17:38:31.414]         }
[17:38:31.414]     })
[17:38:31.414]     if (TRUE) {
[17:38:31.414]         base::sink(type = "output", split = FALSE)
[17:38:31.414]         if (TRUE) {
[17:38:31.414]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:31.414]         }
[17:38:31.414]         else {
[17:38:31.414]             ...future.result["stdout"] <- base::list(NULL)
[17:38:31.414]         }
[17:38:31.414]         base::close(...future.stdout)
[17:38:31.414]         ...future.stdout <- NULL
[17:38:31.414]     }
[17:38:31.414]     ...future.result$conditions <- ...future.conditions
[17:38:31.414]     ...future.result$finished <- base::Sys.time()
[17:38:31.414]     ...future.result
[17:38:31.414] }
[17:38:31.416] assign_globals() ...
[17:38:31.417] List of 5
[17:38:31.417]  $ ...future.FUN            :function (x)  
[17:38:31.417]  $ future.call.arguments    : list()
[17:38:31.417]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:31.417]  $ ...future.elements_ii    :List of 1
[17:38:31.417]   ..$ : int 1
[17:38:31.417]  $ ...future.seeds_ii       : NULL
[17:38:31.417]  $ ...future.globals.maxSize: NULL
[17:38:31.417]  - attr(*, "where")=List of 5
[17:38:31.417]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:31.417]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:31.417]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:31.417]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:31.417]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:31.417]  - attr(*, "resolved")= logi FALSE
[17:38:31.417]  - attr(*, "total_size")= num 4720
[17:38:31.417]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:31.417]  - attr(*, "already-done")= logi TRUE
[17:38:31.421] - reassign environment for ‘...future.FUN’
[17:38:31.421] - copied ‘...future.FUN’ to environment
[17:38:31.421] - copied ‘future.call.arguments’ to environment
[17:38:31.421] - copied ‘...future.elements_ii’ to environment
[17:38:31.421] - copied ‘...future.seeds_ii’ to environment
[17:38:31.422] - copied ‘...future.globals.maxSize’ to environment
[17:38:31.422] assign_globals() ... done
[17:38:31.422] requestCore(): workers = 2
[17:38:31.424] MulticoreFuture started
[17:38:31.424] - Launch lazy future ... done
[17:38:31.425] run() for ‘MulticoreFuture’ ... done
[17:38:31.425] Created future:
[17:38:31.425] plan(): Setting new future strategy stack:
[17:38:31.425] List of future strategies:
[17:38:31.425] 1. sequential:
[17:38:31.425]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:31.425]    - tweaked: FALSE
[17:38:31.425]    - call: NULL
[17:38:31.426] plan(): nbrOfWorkers() = 1
[17:38:31.425] MulticoreFuture:
[17:38:31.425] Label: ‘future_lapply-1’
[17:38:31.425] Expression:
[17:38:31.425] {
[17:38:31.425]     do.call(function(...) {
[17:38:31.425]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:31.425]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:31.425]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:31.425]             on.exit(options(oopts), add = TRUE)
[17:38:31.425]         }
[17:38:31.425]         {
[17:38:31.425]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:31.425]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:31.425]                 ...future.FUN(...future.X_jj, ...)
[17:38:31.425]             })
[17:38:31.425]         }
[17:38:31.425]     }, args = future.call.arguments)
[17:38:31.425] }
[17:38:31.425] Lazy evaluation: FALSE
[17:38:31.425] Asynchronous evaluation: TRUE
[17:38:31.425] Local evaluation: TRUE
[17:38:31.425] Environment: R_GlobalEnv
[17:38:31.425] Capture standard output: TRUE
[17:38:31.425] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:31.425] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:31.425] Packages: <none>
[17:38:31.425] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:31.425] Resolved: FALSE
[17:38:31.425] Value: <not collected>
[17:38:31.425] Conditions captured: <none>
[17:38:31.425] Early signaling: FALSE
[17:38:31.425] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:31.425] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:31.438] Chunk #1 of 2 ... DONE
[17:38:31.438] Chunk #2 of 2 ...
[17:38:31.438]  - Finding globals in 'X' for chunk #2 ...
[17:38:31.439] getGlobalsAndPackages() ...
[17:38:31.439] Searching for globals...
[17:38:31.439] 
[17:38:31.439] Searching for globals ... DONE
[17:38:31.440] - globals: [0] <none>
[17:38:31.440] getGlobalsAndPackages() ... DONE
[17:38:31.440]    + additional globals found: [n=0] 
[17:38:31.440]    + additional namespaces needed: [n=0] 
[17:38:31.440]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:31.440]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:31.441]  - seeds: <none>
[17:38:31.441]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:31.441] getGlobalsAndPackages() ...
[17:38:31.441] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:31.441] Resolving globals: FALSE
[17:38:31.441] Tweak future expression to call with '...' arguments ...
[17:38:31.442] {
[17:38:31.442]     do.call(function(...) {
[17:38:31.442]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:31.442]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:31.442]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:31.442]             on.exit(options(oopts), add = TRUE)
[17:38:31.442]         }
[17:38:31.442]         {
[17:38:31.442]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:31.442]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:31.442]                 ...future.FUN(...future.X_jj, ...)
[17:38:31.442]             })
[17:38:31.442]         }
[17:38:31.442]     }, args = future.call.arguments)
[17:38:31.442] }
[17:38:31.442] Tweak future expression to call with '...' arguments ... DONE
[17:38:31.446] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:31.447] 
[17:38:31.447] getGlobalsAndPackages() ... DONE
[17:38:31.448] run() for ‘Future’ ...
[17:38:31.448] - state: ‘created’
[17:38:31.449] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:31.456] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:31.456] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:31.456]   - Field: ‘label’
[17:38:31.456]   - Field: ‘local’
[17:38:31.456]   - Field: ‘owner’
[17:38:31.457]   - Field: ‘envir’
[17:38:31.457]   - Field: ‘workers’
[17:38:31.457]   - Field: ‘packages’
[17:38:31.457]   - Field: ‘gc’
[17:38:31.457]   - Field: ‘job’
[17:38:31.457]   - Field: ‘conditions’
[17:38:31.457]   - Field: ‘expr’
[17:38:31.457]   - Field: ‘uuid’
[17:38:31.458]   - Field: ‘seed’
[17:38:31.458]   - Field: ‘version’
[17:38:31.458]   - Field: ‘result’
[17:38:31.458]   - Field: ‘asynchronous’
[17:38:31.458]   - Field: ‘calls’
[17:38:31.459]   - Field: ‘globals’
[17:38:31.459]   - Field: ‘stdout’
[17:38:31.459]   - Field: ‘earlySignal’
[17:38:31.459]   - Field: ‘lazy’
[17:38:31.459]   - Field: ‘state’
[17:38:31.459] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:31.459] - Launch lazy future ...
[17:38:31.460] Packages needed by the future expression (n = 0): <none>
[17:38:31.460] Packages needed by future strategies (n = 0): <none>
[17:38:31.461] {
[17:38:31.461]     {
[17:38:31.461]         {
[17:38:31.461]             ...future.startTime <- base::Sys.time()
[17:38:31.461]             {
[17:38:31.461]                 {
[17:38:31.461]                   {
[17:38:31.461]                     {
[17:38:31.461]                       base::local({
[17:38:31.461]                         has_future <- base::requireNamespace("future", 
[17:38:31.461]                           quietly = TRUE)
[17:38:31.461]                         if (has_future) {
[17:38:31.461]                           ns <- base::getNamespace("future")
[17:38:31.461]                           version <- ns[[".package"]][["version"]]
[17:38:31.461]                           if (is.null(version)) 
[17:38:31.461]                             version <- utils::packageVersion("future")
[17:38:31.461]                         }
[17:38:31.461]                         else {
[17:38:31.461]                           version <- NULL
[17:38:31.461]                         }
[17:38:31.461]                         if (!has_future || version < "1.8.0") {
[17:38:31.461]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:31.461]                             "", base::R.version$version.string), 
[17:38:31.461]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:31.461]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:31.461]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:31.461]                               "release", "version")], collapse = " "), 
[17:38:31.461]                             hostname = base::Sys.info()[["nodename"]])
[17:38:31.461]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:31.461]                             info)
[17:38:31.461]                           info <- base::paste(info, collapse = "; ")
[17:38:31.461]                           if (!has_future) {
[17:38:31.461]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:31.461]                               info)
[17:38:31.461]                           }
[17:38:31.461]                           else {
[17:38:31.461]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:31.461]                               info, version)
[17:38:31.461]                           }
[17:38:31.461]                           base::stop(msg)
[17:38:31.461]                         }
[17:38:31.461]                       })
[17:38:31.461]                     }
[17:38:31.461]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:31.461]                     base::options(mc.cores = 1L)
[17:38:31.461]                   }
[17:38:31.461]                   ...future.strategy.old <- future::plan("list")
[17:38:31.461]                   options(future.plan = NULL)
[17:38:31.461]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:31.461]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:31.461]                 }
[17:38:31.461]                 ...future.workdir <- getwd()
[17:38:31.461]             }
[17:38:31.461]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:31.461]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:31.461]         }
[17:38:31.461]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:31.461]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:31.461]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:31.461]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:31.461]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:31.461]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:31.461]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:31.461]             base::names(...future.oldOptions))
[17:38:31.461]     }
[17:38:31.461]     if (FALSE) {
[17:38:31.461]     }
[17:38:31.461]     else {
[17:38:31.461]         if (TRUE) {
[17:38:31.461]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:31.461]                 open = "w")
[17:38:31.461]         }
[17:38:31.461]         else {
[17:38:31.461]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:31.461]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:31.461]         }
[17:38:31.461]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:31.461]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:31.461]             base::sink(type = "output", split = FALSE)
[17:38:31.461]             base::close(...future.stdout)
[17:38:31.461]         }, add = TRUE)
[17:38:31.461]     }
[17:38:31.461]     ...future.frame <- base::sys.nframe()
[17:38:31.461]     ...future.conditions <- base::list()
[17:38:31.461]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:31.461]     if (FALSE) {
[17:38:31.461]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:31.461]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:31.461]     }
[17:38:31.461]     ...future.result <- base::tryCatch({
[17:38:31.461]         base::withCallingHandlers({
[17:38:31.461]             ...future.value <- base::withVisible(base::local({
[17:38:31.461]                 withCallingHandlers({
[17:38:31.461]                   {
[17:38:31.461]                     do.call(function(...) {
[17:38:31.461]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:31.461]                       if (!identical(...future.globals.maxSize.org, 
[17:38:31.461]                         ...future.globals.maxSize)) {
[17:38:31.461]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:31.461]                         on.exit(options(oopts), add = TRUE)
[17:38:31.461]                       }
[17:38:31.461]                       {
[17:38:31.461]                         lapply(seq_along(...future.elements_ii), 
[17:38:31.461]                           FUN = function(jj) {
[17:38:31.461]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:31.461]                             ...future.FUN(...future.X_jj, ...)
[17:38:31.461]                           })
[17:38:31.461]                       }
[17:38:31.461]                     }, args = future.call.arguments)
[17:38:31.461]                   }
[17:38:31.461]                 }, immediateCondition = function(cond) {
[17:38:31.461]                   save_rds <- function (object, pathname, ...) 
[17:38:31.461]                   {
[17:38:31.461]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:31.461]                     if (file_test("-f", pathname_tmp)) {
[17:38:31.461]                       fi_tmp <- file.info(pathname_tmp)
[17:38:31.461]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:31.461]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:31.461]                         fi_tmp[["mtime"]])
[17:38:31.461]                     }
[17:38:31.461]                     tryCatch({
[17:38:31.461]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:31.461]                     }, error = function(ex) {
[17:38:31.461]                       msg <- conditionMessage(ex)
[17:38:31.461]                       fi_tmp <- file.info(pathname_tmp)
[17:38:31.461]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:31.461]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:31.461]                         fi_tmp[["mtime"]], msg)
[17:38:31.461]                       ex$message <- msg
[17:38:31.461]                       stop(ex)
[17:38:31.461]                     })
[17:38:31.461]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:31.461]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:31.461]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:31.461]                       fi_tmp <- file.info(pathname_tmp)
[17:38:31.461]                       fi <- file.info(pathname)
[17:38:31.461]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:31.461]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:31.461]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:31.461]                         fi[["size"]], fi[["mtime"]])
[17:38:31.461]                       stop(msg)
[17:38:31.461]                     }
[17:38:31.461]                     invisible(pathname)
[17:38:31.461]                   }
[17:38:31.461]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:31.461]                     rootPath = tempdir()) 
[17:38:31.461]                   {
[17:38:31.461]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:31.461]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:31.461]                       tmpdir = path, fileext = ".rds")
[17:38:31.461]                     save_rds(obj, file)
[17:38:31.461]                   }
[17:38:31.461]                   saveImmediateCondition(cond, path = "/tmp/RtmpBrP0ee/.future/immediateConditions")
[17:38:31.461]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:31.461]                   {
[17:38:31.461]                     inherits <- base::inherits
[17:38:31.461]                     invokeRestart <- base::invokeRestart
[17:38:31.461]                     is.null <- base::is.null
[17:38:31.461]                     muffled <- FALSE
[17:38:31.461]                     if (inherits(cond, "message")) {
[17:38:31.461]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:31.461]                       if (muffled) 
[17:38:31.461]                         invokeRestart("muffleMessage")
[17:38:31.461]                     }
[17:38:31.461]                     else if (inherits(cond, "warning")) {
[17:38:31.461]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:31.461]                       if (muffled) 
[17:38:31.461]                         invokeRestart("muffleWarning")
[17:38:31.461]                     }
[17:38:31.461]                     else if (inherits(cond, "condition")) {
[17:38:31.461]                       if (!is.null(pattern)) {
[17:38:31.461]                         computeRestarts <- base::computeRestarts
[17:38:31.461]                         grepl <- base::grepl
[17:38:31.461]                         restarts <- computeRestarts(cond)
[17:38:31.461]                         for (restart in restarts) {
[17:38:31.461]                           name <- restart$name
[17:38:31.461]                           if (is.null(name)) 
[17:38:31.461]                             next
[17:38:31.461]                           if (!grepl(pattern, name)) 
[17:38:31.461]                             next
[17:38:31.461]                           invokeRestart(restart)
[17:38:31.461]                           muffled <- TRUE
[17:38:31.461]                           break
[17:38:31.461]                         }
[17:38:31.461]                       }
[17:38:31.461]                     }
[17:38:31.461]                     invisible(muffled)
[17:38:31.461]                   }
[17:38:31.461]                   muffleCondition(cond)
[17:38:31.461]                 })
[17:38:31.461]             }))
[17:38:31.461]             future::FutureResult(value = ...future.value$value, 
[17:38:31.461]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:31.461]                   ...future.rng), globalenv = if (FALSE) 
[17:38:31.461]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:31.461]                     ...future.globalenv.names))
[17:38:31.461]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:31.461]         }, condition = base::local({
[17:38:31.461]             c <- base::c
[17:38:31.461]             inherits <- base::inherits
[17:38:31.461]             invokeRestart <- base::invokeRestart
[17:38:31.461]             length <- base::length
[17:38:31.461]             list <- base::list
[17:38:31.461]             seq.int <- base::seq.int
[17:38:31.461]             signalCondition <- base::signalCondition
[17:38:31.461]             sys.calls <- base::sys.calls
[17:38:31.461]             `[[` <- base::`[[`
[17:38:31.461]             `+` <- base::`+`
[17:38:31.461]             `<<-` <- base::`<<-`
[17:38:31.461]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:31.461]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:31.461]                   3L)]
[17:38:31.461]             }
[17:38:31.461]             function(cond) {
[17:38:31.461]                 is_error <- inherits(cond, "error")
[17:38:31.461]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:31.461]                   NULL)
[17:38:31.461]                 if (is_error) {
[17:38:31.461]                   sessionInformation <- function() {
[17:38:31.461]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:31.461]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:31.461]                       search = base::search(), system = base::Sys.info())
[17:38:31.461]                   }
[17:38:31.461]                   ...future.conditions[[length(...future.conditions) + 
[17:38:31.461]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:31.461]                     cond$call), session = sessionInformation(), 
[17:38:31.461]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:31.461]                   signalCondition(cond)
[17:38:31.461]                 }
[17:38:31.461]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:31.461]                 "immediateCondition"))) {
[17:38:31.461]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:31.461]                   ...future.conditions[[length(...future.conditions) + 
[17:38:31.461]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:31.461]                   if (TRUE && !signal) {
[17:38:31.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:31.461]                     {
[17:38:31.461]                       inherits <- base::inherits
[17:38:31.461]                       invokeRestart <- base::invokeRestart
[17:38:31.461]                       is.null <- base::is.null
[17:38:31.461]                       muffled <- FALSE
[17:38:31.461]                       if (inherits(cond, "message")) {
[17:38:31.461]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:31.461]                         if (muffled) 
[17:38:31.461]                           invokeRestart("muffleMessage")
[17:38:31.461]                       }
[17:38:31.461]                       else if (inherits(cond, "warning")) {
[17:38:31.461]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:31.461]                         if (muffled) 
[17:38:31.461]                           invokeRestart("muffleWarning")
[17:38:31.461]                       }
[17:38:31.461]                       else if (inherits(cond, "condition")) {
[17:38:31.461]                         if (!is.null(pattern)) {
[17:38:31.461]                           computeRestarts <- base::computeRestarts
[17:38:31.461]                           grepl <- base::grepl
[17:38:31.461]                           restarts <- computeRestarts(cond)
[17:38:31.461]                           for (restart in restarts) {
[17:38:31.461]                             name <- restart$name
[17:38:31.461]                             if (is.null(name)) 
[17:38:31.461]                               next
[17:38:31.461]                             if (!grepl(pattern, name)) 
[17:38:31.461]                               next
[17:38:31.461]                             invokeRestart(restart)
[17:38:31.461]                             muffled <- TRUE
[17:38:31.461]                             break
[17:38:31.461]                           }
[17:38:31.461]                         }
[17:38:31.461]                       }
[17:38:31.461]                       invisible(muffled)
[17:38:31.461]                     }
[17:38:31.461]                     muffleCondition(cond, pattern = "^muffle")
[17:38:31.461]                   }
[17:38:31.461]                 }
[17:38:31.461]                 else {
[17:38:31.461]                   if (TRUE) {
[17:38:31.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:31.461]                     {
[17:38:31.461]                       inherits <- base::inherits
[17:38:31.461]                       invokeRestart <- base::invokeRestart
[17:38:31.461]                       is.null <- base::is.null
[17:38:31.461]                       muffled <- FALSE
[17:38:31.461]                       if (inherits(cond, "message")) {
[17:38:31.461]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:31.461]                         if (muffled) 
[17:38:31.461]                           invokeRestart("muffleMessage")
[17:38:31.461]                       }
[17:38:31.461]                       else if (inherits(cond, "warning")) {
[17:38:31.461]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:31.461]                         if (muffled) 
[17:38:31.461]                           invokeRestart("muffleWarning")
[17:38:31.461]                       }
[17:38:31.461]                       else if (inherits(cond, "condition")) {
[17:38:31.461]                         if (!is.null(pattern)) {
[17:38:31.461]                           computeRestarts <- base::computeRestarts
[17:38:31.461]                           grepl <- base::grepl
[17:38:31.461]                           restarts <- computeRestarts(cond)
[17:38:31.461]                           for (restart in restarts) {
[17:38:31.461]                             name <- restart$name
[17:38:31.461]                             if (is.null(name)) 
[17:38:31.461]                               next
[17:38:31.461]                             if (!grepl(pattern, name)) 
[17:38:31.461]                               next
[17:38:31.461]                             invokeRestart(restart)
[17:38:31.461]                             muffled <- TRUE
[17:38:31.461]                             break
[17:38:31.461]                           }
[17:38:31.461]                         }
[17:38:31.461]                       }
[17:38:31.461]                       invisible(muffled)
[17:38:31.461]                     }
[17:38:31.461]                     muffleCondition(cond, pattern = "^muffle")
[17:38:31.461]                   }
[17:38:31.461]                 }
[17:38:31.461]             }
[17:38:31.461]         }))
[17:38:31.461]     }, error = function(ex) {
[17:38:31.461]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:31.461]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:31.461]                 ...future.rng), started = ...future.startTime, 
[17:38:31.461]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:31.461]             version = "1.8"), class = "FutureResult")
[17:38:31.461]     }, finally = {
[17:38:31.461]         if (!identical(...future.workdir, getwd())) 
[17:38:31.461]             setwd(...future.workdir)
[17:38:31.461]         {
[17:38:31.461]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:31.461]                 ...future.oldOptions$nwarnings <- NULL
[17:38:31.461]             }
[17:38:31.461]             base::options(...future.oldOptions)
[17:38:31.461]             if (.Platform$OS.type == "windows") {
[17:38:31.461]                 old_names <- names(...future.oldEnvVars)
[17:38:31.461]                 envs <- base::Sys.getenv()
[17:38:31.461]                 names <- names(envs)
[17:38:31.461]                 common <- intersect(names, old_names)
[17:38:31.461]                 added <- setdiff(names, old_names)
[17:38:31.461]                 removed <- setdiff(old_names, names)
[17:38:31.461]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:31.461]                   envs[common]]
[17:38:31.461]                 NAMES <- toupper(changed)
[17:38:31.461]                 args <- list()
[17:38:31.461]                 for (kk in seq_along(NAMES)) {
[17:38:31.461]                   name <- changed[[kk]]
[17:38:31.461]                   NAME <- NAMES[[kk]]
[17:38:31.461]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:31.461]                     next
[17:38:31.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:31.461]                 }
[17:38:31.461]                 NAMES <- toupper(added)
[17:38:31.461]                 for (kk in seq_along(NAMES)) {
[17:38:31.461]                   name <- added[[kk]]
[17:38:31.461]                   NAME <- NAMES[[kk]]
[17:38:31.461]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:31.461]                     next
[17:38:31.461]                   args[[name]] <- ""
[17:38:31.461]                 }
[17:38:31.461]                 NAMES <- toupper(removed)
[17:38:31.461]                 for (kk in seq_along(NAMES)) {
[17:38:31.461]                   name <- removed[[kk]]
[17:38:31.461]                   NAME <- NAMES[[kk]]
[17:38:31.461]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:31.461]                     next
[17:38:31.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:31.461]                 }
[17:38:31.461]                 if (length(args) > 0) 
[17:38:31.461]                   base::do.call(base::Sys.setenv, args = args)
[17:38:31.461]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:31.461]             }
[17:38:31.461]             else {
[17:38:31.461]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:31.461]             }
[17:38:31.461]             {
[17:38:31.461]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:31.461]                   0L) {
[17:38:31.461]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:31.461]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:31.461]                   base::options(opts)
[17:38:31.461]                 }
[17:38:31.461]                 {
[17:38:31.461]                   {
[17:38:31.461]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:31.461]                     NULL
[17:38:31.461]                   }
[17:38:31.461]                   options(future.plan = NULL)
[17:38:31.461]                   if (is.na(NA_character_)) 
[17:38:31.461]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:31.461]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:31.461]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:31.461]                     .init = FALSE)
[17:38:31.461]                 }
[17:38:31.461]             }
[17:38:31.461]         }
[17:38:31.461]     })
[17:38:31.461]     if (TRUE) {
[17:38:31.461]         base::sink(type = "output", split = FALSE)
[17:38:31.461]         if (TRUE) {
[17:38:31.461]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:31.461]         }
[17:38:31.461]         else {
[17:38:31.461]             ...future.result["stdout"] <- base::list(NULL)
[17:38:31.461]         }
[17:38:31.461]         base::close(...future.stdout)
[17:38:31.461]         ...future.stdout <- NULL
[17:38:31.461]     }
[17:38:31.461]     ...future.result$conditions <- ...future.conditions
[17:38:31.461]     ...future.result$finished <- base::Sys.time()
[17:38:31.461]     ...future.result
[17:38:31.461] }
[17:38:31.464] assign_globals() ...
[17:38:31.464] List of 5
[17:38:31.464]  $ ...future.FUN            :function (x)  
[17:38:31.464]  $ future.call.arguments    : list()
[17:38:31.464]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:31.464]  $ ...future.elements_ii    :List of 1
[17:38:31.464]   ..$ : int 0
[17:38:31.464]  $ ...future.seeds_ii       : NULL
[17:38:31.464]  $ ...future.globals.maxSize: NULL
[17:38:31.464]  - attr(*, "where")=List of 5
[17:38:31.464]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:31.464]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:31.464]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:31.464]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:31.464]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:31.464]  - attr(*, "resolved")= logi FALSE
[17:38:31.464]  - attr(*, "total_size")= num 4720
[17:38:31.464]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:31.464]  - attr(*, "already-done")= logi TRUE
[17:38:31.470] - reassign environment for ‘...future.FUN’
[17:38:31.470] - copied ‘...future.FUN’ to environment
[17:38:31.470] - copied ‘future.call.arguments’ to environment
[17:38:31.471] - copied ‘...future.elements_ii’ to environment
[17:38:31.471] - copied ‘...future.seeds_ii’ to environment
[17:38:31.471] - copied ‘...future.globals.maxSize’ to environment
[17:38:31.471] assign_globals() ... done
[17:38:31.471] requestCore(): workers = 2
[17:38:31.473] MulticoreFuture started
[17:38:31.474] - Launch lazy future ... done
[17:38:31.474] run() for ‘MulticoreFuture’ ... done
[17:38:31.474] Created future:
[17:38:31.474] plan(): Setting new future strategy stack:
[17:38:31.475] List of future strategies:
[17:38:31.475] 1. sequential:
[17:38:31.475]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:31.475]    - tweaked: FALSE
[17:38:31.475]    - call: NULL
[17:38:31.476] plan(): nbrOfWorkers() = 1
[17:38:31.478] plan(): Setting new future strategy stack:
[17:38:31.478] List of future strategies:
[17:38:31.478] 1. multicore:
[17:38:31.478]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:31.478]    - tweaked: FALSE
[17:38:31.478]    - call: plan(strategy)
[17:38:31.483] plan(): nbrOfWorkers() = 2
[17:38:31.474] MulticoreFuture:
[17:38:31.474] Label: ‘future_lapply-2’
[17:38:31.474] Expression:
[17:38:31.474] {
[17:38:31.474]     do.call(function(...) {
[17:38:31.474]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:31.474]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:31.474]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:31.474]             on.exit(options(oopts), add = TRUE)
[17:38:31.474]         }
[17:38:31.474]         {
[17:38:31.474]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:31.474]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:31.474]                 ...future.FUN(...future.X_jj, ...)
[17:38:31.474]             })
[17:38:31.474]         }
[17:38:31.474]     }, args = future.call.arguments)
[17:38:31.474] }
[17:38:31.474] Lazy evaluation: FALSE
[17:38:31.474] Asynchronous evaluation: TRUE
[17:38:31.474] Local evaluation: TRUE
[17:38:31.474] Environment: R_GlobalEnv
[17:38:31.474] Capture standard output: TRUE
[17:38:31.474] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:31.474] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:31.474] Packages: <none>
[17:38:31.474] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:31.474] Resolved: TRUE
[17:38:31.474] Value: <not collected>
[17:38:31.474] Conditions captured: <none>
[17:38:31.474] Early signaling: FALSE
[17:38:31.474] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:31.474] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:31.484] Chunk #2 of 2 ... DONE
[17:38:31.485] Launching 2 futures (chunks) ... DONE
[17:38:31.485] Resolving 2 futures (chunks) ...
[17:38:31.485] resolve() on list ...
[17:38:31.485]  recursive: 0
[17:38:31.485]  length: 2
[17:38:31.485] 
[17:38:31.496] Future #2
[17:38:31.496] result() for MulticoreFuture ...
[17:38:31.497] result() for MulticoreFuture ...
[17:38:31.497] result() for MulticoreFuture ... done
[17:38:31.497] result() for MulticoreFuture ... done
[17:38:31.498] result() for MulticoreFuture ...
[17:38:31.498] result() for MulticoreFuture ... done
[17:38:31.498] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:38:31.498] - nx: 2
[17:38:31.498] - relay: TRUE
[17:38:31.498] - stdout: TRUE
[17:38:31.499] - signal: TRUE
[17:38:31.499] - resignal: FALSE
[17:38:31.499] - force: TRUE
[17:38:31.499] - relayed: [n=2] FALSE, FALSE
[17:38:31.499] - queued futures: [n=2] FALSE, FALSE
[17:38:31.499]  - until=1
[17:38:31.499]  - relaying element #1
[17:38:31.500] - relayed: [n=2] FALSE, FALSE
[17:38:31.500] - queued futures: [n=2] FALSE, TRUE
[17:38:31.500] signalConditionsASAP(NULL, pos=2) ... done
[17:38:31.500]  length: 1 (resolved future 2)
[17:38:31.929] plan(): Setting new future strategy stack:
[17:38:31.929] List of future strategies:
[17:38:31.929] 1. multicore:
[17:38:31.929]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:31.929]    - tweaked: FALSE
[17:38:31.929]    - call: plan(strategy)
[17:38:31.934] plan(): nbrOfWorkers() = 2
[17:38:31.938] Future #1
[17:38:31.938] result() for MulticoreFuture ...
[17:38:31.939] result() for MulticoreFuture ...
[17:38:31.939] result() for MulticoreFuture ... done
[17:38:31.939] result() for MulticoreFuture ... done
[17:38:31.940] result() for MulticoreFuture ...
[17:38:31.940] result() for MulticoreFuture ... done
[17:38:31.940] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:38:31.940] - nx: 2
[17:38:31.940] - relay: TRUE
[17:38:31.940] - stdout: TRUE
[17:38:31.940] - signal: TRUE
[17:38:31.941] - resignal: FALSE
[17:38:31.941] - force: TRUE
[17:38:31.941] - relayed: [n=2] FALSE, FALSE
[17:38:31.941] - queued futures: [n=2] FALSE, TRUE
[17:38:31.941]  - until=1
[17:38:31.941]  - relaying element #1
[17:38:31.941] result() for MulticoreFuture ...
[17:38:31.941] result() for MulticoreFuture ... done
[17:38:31.941] result() for MulticoreFuture ...
[17:38:31.942] result() for MulticoreFuture ... done
[17:38:31.942] result() for MulticoreFuture ...
[17:38:31.942] result() for MulticoreFuture ... done
[17:38:31.942] result() for MulticoreFuture ...
[17:38:31.942] result() for MulticoreFuture ... done
[17:38:31.942] - relayed: [n=2] TRUE, FALSE
[17:38:31.942] - queued futures: [n=2] TRUE, TRUE
[17:38:31.942] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:38:31.943]  length: 0 (resolved future 1)
[17:38:31.943] Relaying remaining futures
[17:38:31.943] signalConditionsASAP(NULL, pos=0) ...
[17:38:31.943] - nx: 2
[17:38:31.943] - relay: TRUE
[17:38:31.943] - stdout: TRUE
[17:38:31.943] - signal: TRUE
[17:38:31.943] - resignal: FALSE
[17:38:31.943] - force: TRUE
[17:38:31.943] - relayed: [n=2] TRUE, FALSE
[17:38:31.944] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:31.944]  - relaying element #2
[17:38:31.944] result() for MulticoreFuture ...
[17:38:31.944] result() for MulticoreFuture ... done
[17:38:31.944] result() for MulticoreFuture ...
[17:38:31.944] result() for MulticoreFuture ... done
[17:38:31.944] result() for MulticoreFuture ...
[17:38:31.945] result() for MulticoreFuture ... done
[17:38:31.945] result() for MulticoreFuture ...
[17:38:31.947] result() for MulticoreFuture ... done
[17:38:31.947] - relayed: [n=2] TRUE, TRUE
[17:38:31.947] - queued futures: [n=2] TRUE, TRUE
[17:38:31.948] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:38:31.948] resolve() on list ... DONE
[17:38:31.948] result() for MulticoreFuture ...
[17:38:31.948] result() for MulticoreFuture ... done
[17:38:31.948] result() for MulticoreFuture ...
[17:38:31.949] result() for MulticoreFuture ... done
[17:38:31.949] result() for MulticoreFuture ...
[17:38:31.949] result() for MulticoreFuture ... done
[17:38:31.949] result() for MulticoreFuture ...
[17:38:31.949] result() for MulticoreFuture ... done
[17:38:31.949]  - Number of value chunks collected: 2
[17:38:31.950] Resolving 2 futures (chunks) ... DONE
[17:38:31.950] Reducing values from 2 chunks ...
[17:38:31.950]  - Number of values collected after concatenation: 2
[17:38:31.950]  - Number of values expected: 2
[17:38:31.950] Reducing values from 2 chunks ... DONE
[17:38:31.950] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[17:38:31.951] future_lapply() ...
[17:38:31.956] Number of chunks: 2
[17:38:31.957] getGlobalsAndPackagesXApply() ...
[17:38:31.957]  - future.globals: TRUE
[17:38:31.957] getGlobalsAndPackages() ...
[17:38:31.957] Searching for globals...
[17:38:31.959] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:38:31.959] Searching for globals ... DONE
[17:38:31.959] Resolving globals: FALSE
[17:38:31.959] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:38:31.960] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:38:31.960] - globals: [1] ‘FUN’
[17:38:31.960] 
[17:38:31.960] getGlobalsAndPackages() ... DONE
[17:38:31.960]  - globals found/used: [n=1] ‘FUN’
[17:38:31.961]  - needed namespaces: [n=0] 
[17:38:31.961] Finding globals ... DONE
[17:38:31.961]  - use_args: TRUE
[17:38:31.961]  - Getting '...' globals ...
[17:38:31.961] resolve() on list ...
[17:38:31.961]  recursive: 0
[17:38:31.961]  length: 1
[17:38:31.961]  elements: ‘...’
[17:38:31.962]  length: 0 (resolved future 1)
[17:38:31.962] resolve() on list ... DONE
[17:38:31.962]    - '...' content: [n=0] 
[17:38:31.962] List of 1
[17:38:31.962]  $ ...: list()
[17:38:31.962]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:31.962]  - attr(*, "where")=List of 1
[17:38:31.962]   ..$ ...:<environment: 0x5628aaf91e50> 
[17:38:31.962]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:31.962]  - attr(*, "resolved")= logi TRUE
[17:38:31.962]  - attr(*, "total_size")= num NA
[17:38:31.965]  - Getting '...' globals ... DONE
[17:38:31.965] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:38:31.965] List of 2
[17:38:31.965]  $ ...future.FUN:function (x)  
[17:38:31.965]  $ ...          : list()
[17:38:31.965]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:31.965]  - attr(*, "where")=List of 2
[17:38:31.965]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:31.965]   ..$ ...          :<environment: 0x5628aaf91e50> 
[17:38:31.965]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:31.965]  - attr(*, "resolved")= logi FALSE
[17:38:31.965]  - attr(*, "total_size")= num 4720
[17:38:31.968] Packages to be attached in all futures: [n=0] 
[17:38:31.968] getGlobalsAndPackagesXApply() ... DONE
[17:38:31.968] Number of futures (= number of chunks): 2
[17:38:31.968] Launching 2 futures (chunks) ...
[17:38:31.968] Chunk #1 of 2 ...
[17:38:31.969]  - Finding globals in 'X' for chunk #1 ...
[17:38:31.969] getGlobalsAndPackages() ...
[17:38:31.969] Searching for globals...
[17:38:31.969] 
[17:38:31.969] Searching for globals ... DONE
[17:38:31.969] - globals: [0] <none>
[17:38:31.969] getGlobalsAndPackages() ... DONE
[17:38:31.969]    + additional globals found: [n=0] 
[17:38:31.969]    + additional namespaces needed: [n=0] 
[17:38:31.969]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:31.970]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:31.970]  - seeds: <none>
[17:38:31.970]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:31.970] getGlobalsAndPackages() ...
[17:38:31.970] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:31.970] Resolving globals: FALSE
[17:38:31.970] Tweak future expression to call with '...' arguments ...
[17:38:31.970] {
[17:38:31.970]     do.call(function(...) {
[17:38:31.970]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:31.970]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:31.970]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:31.970]             on.exit(options(oopts), add = TRUE)
[17:38:31.970]         }
[17:38:31.970]         {
[17:38:31.970]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:31.970]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:31.970]                 ...future.FUN(...future.X_jj, ...)
[17:38:31.970]             })
[17:38:31.970]         }
[17:38:31.970]     }, args = future.call.arguments)
[17:38:31.970] }
[17:38:31.971] Tweak future expression to call with '...' arguments ... DONE
[17:38:31.971] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:31.971] 
[17:38:31.971] getGlobalsAndPackages() ... DONE
[17:38:31.971] run() for ‘Future’ ...
[17:38:31.972] - state: ‘created’
[17:38:31.972] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:31.976] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:31.976] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:31.976]   - Field: ‘label’
[17:38:31.976]   - Field: ‘local’
[17:38:31.976]   - Field: ‘owner’
[17:38:31.976]   - Field: ‘envir’
[17:38:31.976]   - Field: ‘workers’
[17:38:31.977]   - Field: ‘packages’
[17:38:31.977]   - Field: ‘gc’
[17:38:31.977]   - Field: ‘job’
[17:38:31.977]   - Field: ‘conditions’
[17:38:31.977]   - Field: ‘expr’
[17:38:31.977]   - Field: ‘uuid’
[17:38:31.977]   - Field: ‘seed’
[17:38:31.977]   - Field: ‘version’
[17:38:31.977]   - Field: ‘result’
[17:38:31.978]   - Field: ‘asynchronous’
[17:38:31.978]   - Field: ‘calls’
[17:38:31.978]   - Field: ‘globals’
[17:38:31.978]   - Field: ‘stdout’
[17:38:31.978]   - Field: ‘earlySignal’
[17:38:31.978]   - Field: ‘lazy’
[17:38:31.978]   - Field: ‘state’
[17:38:31.978] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:31.978] - Launch lazy future ...
[17:38:31.979] Packages needed by the future expression (n = 0): <none>
[17:38:31.979] Packages needed by future strategies (n = 0): <none>
[17:38:31.981] {
[17:38:31.981]     {
[17:38:31.981]         {
[17:38:31.981]             ...future.startTime <- base::Sys.time()
[17:38:31.981]             {
[17:38:31.981]                 {
[17:38:31.981]                   {
[17:38:31.981]                     {
[17:38:31.981]                       base::local({
[17:38:31.981]                         has_future <- base::requireNamespace("future", 
[17:38:31.981]                           quietly = TRUE)
[17:38:31.981]                         if (has_future) {
[17:38:31.981]                           ns <- base::getNamespace("future")
[17:38:31.981]                           version <- ns[[".package"]][["version"]]
[17:38:31.981]                           if (is.null(version)) 
[17:38:31.981]                             version <- utils::packageVersion("future")
[17:38:31.981]                         }
[17:38:31.981]                         else {
[17:38:31.981]                           version <- NULL
[17:38:31.981]                         }
[17:38:31.981]                         if (!has_future || version < "1.8.0") {
[17:38:31.981]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:31.981]                             "", base::R.version$version.string), 
[17:38:31.981]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:31.981]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:31.981]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:31.981]                               "release", "version")], collapse = " "), 
[17:38:31.981]                             hostname = base::Sys.info()[["nodename"]])
[17:38:31.981]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:31.981]                             info)
[17:38:31.981]                           info <- base::paste(info, collapse = "; ")
[17:38:31.981]                           if (!has_future) {
[17:38:31.981]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:31.981]                               info)
[17:38:31.981]                           }
[17:38:31.981]                           else {
[17:38:31.981]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:31.981]                               info, version)
[17:38:31.981]                           }
[17:38:31.981]                           base::stop(msg)
[17:38:31.981]                         }
[17:38:31.981]                       })
[17:38:31.981]                     }
[17:38:31.981]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:31.981]                     base::options(mc.cores = 1L)
[17:38:31.981]                   }
[17:38:31.981]                   ...future.strategy.old <- future::plan("list")
[17:38:31.981]                   options(future.plan = NULL)
[17:38:31.981]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:31.981]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:31.981]                 }
[17:38:31.981]                 ...future.workdir <- getwd()
[17:38:31.981]             }
[17:38:31.981]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:31.981]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:31.981]         }
[17:38:31.981]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:31.981]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:31.981]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:31.981]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:31.981]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:31.981]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:31.981]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:31.981]             base::names(...future.oldOptions))
[17:38:31.981]     }
[17:38:31.981]     if (TRUE) {
[17:38:31.981]     }
[17:38:31.981]     else {
[17:38:31.981]         if (NA) {
[17:38:31.981]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:31.981]                 open = "w")
[17:38:31.981]         }
[17:38:31.981]         else {
[17:38:31.981]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:31.981]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:31.981]         }
[17:38:31.981]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:31.981]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:31.981]             base::sink(type = "output", split = FALSE)
[17:38:31.981]             base::close(...future.stdout)
[17:38:31.981]         }, add = TRUE)
[17:38:31.981]     }
[17:38:31.981]     ...future.frame <- base::sys.nframe()
[17:38:31.981]     ...future.conditions <- base::list()
[17:38:31.981]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:31.981]     if (FALSE) {
[17:38:31.981]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:31.981]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:31.981]     }
[17:38:31.981]     ...future.result <- base::tryCatch({
[17:38:31.981]         base::withCallingHandlers({
[17:38:31.981]             ...future.value <- base::withVisible(base::local({
[17:38:31.981]                 withCallingHandlers({
[17:38:31.981]                   {
[17:38:31.981]                     do.call(function(...) {
[17:38:31.981]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:31.981]                       if (!identical(...future.globals.maxSize.org, 
[17:38:31.981]                         ...future.globals.maxSize)) {
[17:38:31.981]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:31.981]                         on.exit(options(oopts), add = TRUE)
[17:38:31.981]                       }
[17:38:31.981]                       {
[17:38:31.981]                         lapply(seq_along(...future.elements_ii), 
[17:38:31.981]                           FUN = function(jj) {
[17:38:31.981]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:31.981]                             ...future.FUN(...future.X_jj, ...)
[17:38:31.981]                           })
[17:38:31.981]                       }
[17:38:31.981]                     }, args = future.call.arguments)
[17:38:31.981]                   }
[17:38:31.981]                 }, immediateCondition = function(cond) {
[17:38:31.981]                   save_rds <- function (object, pathname, ...) 
[17:38:31.981]                   {
[17:38:31.981]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:31.981]                     if (file_test("-f", pathname_tmp)) {
[17:38:31.981]                       fi_tmp <- file.info(pathname_tmp)
[17:38:31.981]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:31.981]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:31.981]                         fi_tmp[["mtime"]])
[17:38:31.981]                     }
[17:38:31.981]                     tryCatch({
[17:38:31.981]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:31.981]                     }, error = function(ex) {
[17:38:31.981]                       msg <- conditionMessage(ex)
[17:38:31.981]                       fi_tmp <- file.info(pathname_tmp)
[17:38:31.981]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:31.981]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:31.981]                         fi_tmp[["mtime"]], msg)
[17:38:31.981]                       ex$message <- msg
[17:38:31.981]                       stop(ex)
[17:38:31.981]                     })
[17:38:31.981]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:31.981]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:31.981]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:31.981]                       fi_tmp <- file.info(pathname_tmp)
[17:38:31.981]                       fi <- file.info(pathname)
[17:38:31.981]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:31.981]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:31.981]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:31.981]                         fi[["size"]], fi[["mtime"]])
[17:38:31.981]                       stop(msg)
[17:38:31.981]                     }
[17:38:31.981]                     invisible(pathname)
[17:38:31.981]                   }
[17:38:31.981]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:31.981]                     rootPath = tempdir()) 
[17:38:31.981]                   {
[17:38:31.981]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:31.981]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:31.981]                       tmpdir = path, fileext = ".rds")
[17:38:31.981]                     save_rds(obj, file)
[17:38:31.981]                   }
[17:38:31.981]                   saveImmediateCondition(cond, path = "/tmp/RtmpBrP0ee/.future/immediateConditions")
[17:38:31.981]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:31.981]                   {
[17:38:31.981]                     inherits <- base::inherits
[17:38:31.981]                     invokeRestart <- base::invokeRestart
[17:38:31.981]                     is.null <- base::is.null
[17:38:31.981]                     muffled <- FALSE
[17:38:31.981]                     if (inherits(cond, "message")) {
[17:38:31.981]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:31.981]                       if (muffled) 
[17:38:31.981]                         invokeRestart("muffleMessage")
[17:38:31.981]                     }
[17:38:31.981]                     else if (inherits(cond, "warning")) {
[17:38:31.981]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:31.981]                       if (muffled) 
[17:38:31.981]                         invokeRestart("muffleWarning")
[17:38:31.981]                     }
[17:38:31.981]                     else if (inherits(cond, "condition")) {
[17:38:31.981]                       if (!is.null(pattern)) {
[17:38:31.981]                         computeRestarts <- base::computeRestarts
[17:38:31.981]                         grepl <- base::grepl
[17:38:31.981]                         restarts <- computeRestarts(cond)
[17:38:31.981]                         for (restart in restarts) {
[17:38:31.981]                           name <- restart$name
[17:38:31.981]                           if (is.null(name)) 
[17:38:31.981]                             next
[17:38:31.981]                           if (!grepl(pattern, name)) 
[17:38:31.981]                             next
[17:38:31.981]                           invokeRestart(restart)
[17:38:31.981]                           muffled <- TRUE
[17:38:31.981]                           break
[17:38:31.981]                         }
[17:38:31.981]                       }
[17:38:31.981]                     }
[17:38:31.981]                     invisible(muffled)
[17:38:31.981]                   }
[17:38:31.981]                   muffleCondition(cond)
[17:38:31.981]                 })
[17:38:31.981]             }))
[17:38:31.981]             future::FutureResult(value = ...future.value$value, 
[17:38:31.981]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:31.981]                   ...future.rng), globalenv = if (FALSE) 
[17:38:31.981]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:31.981]                     ...future.globalenv.names))
[17:38:31.981]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:31.981]         }, condition = base::local({
[17:38:31.981]             c <- base::c
[17:38:31.981]             inherits <- base::inherits
[17:38:31.981]             invokeRestart <- base::invokeRestart
[17:38:31.981]             length <- base::length
[17:38:31.981]             list <- base::list
[17:38:31.981]             seq.int <- base::seq.int
[17:38:31.981]             signalCondition <- base::signalCondition
[17:38:31.981]             sys.calls <- base::sys.calls
[17:38:31.981]             `[[` <- base::`[[`
[17:38:31.981]             `+` <- base::`+`
[17:38:31.981]             `<<-` <- base::`<<-`
[17:38:31.981]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:31.981]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:31.981]                   3L)]
[17:38:31.981]             }
[17:38:31.981]             function(cond) {
[17:38:31.981]                 is_error <- inherits(cond, "error")
[17:38:31.981]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:31.981]                   NULL)
[17:38:31.981]                 if (is_error) {
[17:38:31.981]                   sessionInformation <- function() {
[17:38:31.981]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:31.981]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:31.981]                       search = base::search(), system = base::Sys.info())
[17:38:31.981]                   }
[17:38:31.981]                   ...future.conditions[[length(...future.conditions) + 
[17:38:31.981]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:31.981]                     cond$call), session = sessionInformation(), 
[17:38:31.981]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:31.981]                   signalCondition(cond)
[17:38:31.981]                 }
[17:38:31.981]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:31.981]                 "immediateCondition"))) {
[17:38:31.981]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:31.981]                   ...future.conditions[[length(...future.conditions) + 
[17:38:31.981]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:31.981]                   if (TRUE && !signal) {
[17:38:31.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:31.981]                     {
[17:38:31.981]                       inherits <- base::inherits
[17:38:31.981]                       invokeRestart <- base::invokeRestart
[17:38:31.981]                       is.null <- base::is.null
[17:38:31.981]                       muffled <- FALSE
[17:38:31.981]                       if (inherits(cond, "message")) {
[17:38:31.981]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:31.981]                         if (muffled) 
[17:38:31.981]                           invokeRestart("muffleMessage")
[17:38:31.981]                       }
[17:38:31.981]                       else if (inherits(cond, "warning")) {
[17:38:31.981]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:31.981]                         if (muffled) 
[17:38:31.981]                           invokeRestart("muffleWarning")
[17:38:31.981]                       }
[17:38:31.981]                       else if (inherits(cond, "condition")) {
[17:38:31.981]                         if (!is.null(pattern)) {
[17:38:31.981]                           computeRestarts <- base::computeRestarts
[17:38:31.981]                           grepl <- base::grepl
[17:38:31.981]                           restarts <- computeRestarts(cond)
[17:38:31.981]                           for (restart in restarts) {
[17:38:31.981]                             name <- restart$name
[17:38:31.981]                             if (is.null(name)) 
[17:38:31.981]                               next
[17:38:31.981]                             if (!grepl(pattern, name)) 
[17:38:31.981]                               next
[17:38:31.981]                             invokeRestart(restart)
[17:38:31.981]                             muffled <- TRUE
[17:38:31.981]                             break
[17:38:31.981]                           }
[17:38:31.981]                         }
[17:38:31.981]                       }
[17:38:31.981]                       invisible(muffled)
[17:38:31.981]                     }
[17:38:31.981]                     muffleCondition(cond, pattern = "^muffle")
[17:38:31.981]                   }
[17:38:31.981]                 }
[17:38:31.981]                 else {
[17:38:31.981]                   if (TRUE) {
[17:38:31.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:31.981]                     {
[17:38:31.981]                       inherits <- base::inherits
[17:38:31.981]                       invokeRestart <- base::invokeRestart
[17:38:31.981]                       is.null <- base::is.null
[17:38:31.981]                       muffled <- FALSE
[17:38:31.981]                       if (inherits(cond, "message")) {
[17:38:31.981]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:31.981]                         if (muffled) 
[17:38:31.981]                           invokeRestart("muffleMessage")
[17:38:31.981]                       }
[17:38:31.981]                       else if (inherits(cond, "warning")) {
[17:38:31.981]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:31.981]                         if (muffled) 
[17:38:31.981]                           invokeRestart("muffleWarning")
[17:38:31.981]                       }
[17:38:31.981]                       else if (inherits(cond, "condition")) {
[17:38:31.981]                         if (!is.null(pattern)) {
[17:38:31.981]                           computeRestarts <- base::computeRestarts
[17:38:31.981]                           grepl <- base::grepl
[17:38:31.981]                           restarts <- computeRestarts(cond)
[17:38:31.981]                           for (restart in restarts) {
[17:38:31.981]                             name <- restart$name
[17:38:31.981]                             if (is.null(name)) 
[17:38:31.981]                               next
[17:38:31.981]                             if (!grepl(pattern, name)) 
[17:38:31.981]                               next
[17:38:31.981]                             invokeRestart(restart)
[17:38:31.981]                             muffled <- TRUE
[17:38:31.981]                             break
[17:38:31.981]                           }
[17:38:31.981]                         }
[17:38:31.981]                       }
[17:38:31.981]                       invisible(muffled)
[17:38:31.981]                     }
[17:38:31.981]                     muffleCondition(cond, pattern = "^muffle")
[17:38:31.981]                   }
[17:38:31.981]                 }
[17:38:31.981]             }
[17:38:31.981]         }))
[17:38:31.981]     }, error = function(ex) {
[17:38:31.981]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:31.981]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:31.981]                 ...future.rng), started = ...future.startTime, 
[17:38:31.981]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:31.981]             version = "1.8"), class = "FutureResult")
[17:38:31.981]     }, finally = {
[17:38:31.981]         if (!identical(...future.workdir, getwd())) 
[17:38:31.981]             setwd(...future.workdir)
[17:38:31.981]         {
[17:38:31.981]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:31.981]                 ...future.oldOptions$nwarnings <- NULL
[17:38:31.981]             }
[17:38:31.981]             base::options(...future.oldOptions)
[17:38:31.981]             if (.Platform$OS.type == "windows") {
[17:38:31.981]                 old_names <- names(...future.oldEnvVars)
[17:38:31.981]                 envs <- base::Sys.getenv()
[17:38:31.981]                 names <- names(envs)
[17:38:31.981]                 common <- intersect(names, old_names)
[17:38:31.981]                 added <- setdiff(names, old_names)
[17:38:31.981]                 removed <- setdiff(old_names, names)
[17:38:31.981]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:31.981]                   envs[common]]
[17:38:31.981]                 NAMES <- toupper(changed)
[17:38:31.981]                 args <- list()
[17:38:31.981]                 for (kk in seq_along(NAMES)) {
[17:38:31.981]                   name <- changed[[kk]]
[17:38:31.981]                   NAME <- NAMES[[kk]]
[17:38:31.981]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:31.981]                     next
[17:38:31.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:31.981]                 }
[17:38:31.981]                 NAMES <- toupper(added)
[17:38:31.981]                 for (kk in seq_along(NAMES)) {
[17:38:31.981]                   name <- added[[kk]]
[17:38:31.981]                   NAME <- NAMES[[kk]]
[17:38:31.981]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:31.981]                     next
[17:38:31.981]                   args[[name]] <- ""
[17:38:31.981]                 }
[17:38:31.981]                 NAMES <- toupper(removed)
[17:38:31.981]                 for (kk in seq_along(NAMES)) {
[17:38:31.981]                   name <- removed[[kk]]
[17:38:31.981]                   NAME <- NAMES[[kk]]
[17:38:31.981]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:31.981]                     next
[17:38:31.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:31.981]                 }
[17:38:31.981]                 if (length(args) > 0) 
[17:38:31.981]                   base::do.call(base::Sys.setenv, args = args)
[17:38:31.981]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:31.981]             }
[17:38:31.981]             else {
[17:38:31.981]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:31.981]             }
[17:38:31.981]             {
[17:38:31.981]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:31.981]                   0L) {
[17:38:31.981]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:31.981]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:31.981]                   base::options(opts)
[17:38:31.981]                 }
[17:38:31.981]                 {
[17:38:31.981]                   {
[17:38:31.981]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:31.981]                     NULL
[17:38:31.981]                   }
[17:38:31.981]                   options(future.plan = NULL)
[17:38:31.981]                   if (is.na(NA_character_)) 
[17:38:31.981]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:31.981]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:31.981]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:31.981]                     .init = FALSE)
[17:38:31.981]                 }
[17:38:31.981]             }
[17:38:31.981]         }
[17:38:31.981]     })
[17:38:31.981]     if (FALSE) {
[17:38:31.981]         base::sink(type = "output", split = FALSE)
[17:38:31.981]         if (NA) {
[17:38:31.981]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:31.981]         }
[17:38:31.981]         else {
[17:38:31.981]             ...future.result["stdout"] <- base::list(NULL)
[17:38:31.981]         }
[17:38:31.981]         base::close(...future.stdout)
[17:38:31.981]         ...future.stdout <- NULL
[17:38:31.981]     }
[17:38:31.981]     ...future.result$conditions <- ...future.conditions
[17:38:31.981]     ...future.result$finished <- base::Sys.time()
[17:38:31.981]     ...future.result
[17:38:31.981] }
[17:38:31.983] assign_globals() ...
[17:38:31.983] List of 5
[17:38:31.983]  $ ...future.FUN            :function (x)  
[17:38:31.983]  $ future.call.arguments    : list()
[17:38:31.983]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:31.983]  $ ...future.elements_ii    :List of 1
[17:38:31.983]   ..$ : int 1
[17:38:31.983]  $ ...future.seeds_ii       : NULL
[17:38:31.983]  $ ...future.globals.maxSize: NULL
[17:38:31.983]  - attr(*, "where")=List of 5
[17:38:31.983]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:31.983]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:31.983]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:31.983]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:31.983]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:31.983]  - attr(*, "resolved")= logi FALSE
[17:38:31.983]  - attr(*, "total_size")= num 4720
[17:38:31.983]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:31.983]  - attr(*, "already-done")= logi TRUE
[17:38:31.988] - reassign environment for ‘...future.FUN’
[17:38:31.989] - copied ‘...future.FUN’ to environment
[17:38:31.989] - copied ‘future.call.arguments’ to environment
[17:38:31.989] - copied ‘...future.elements_ii’ to environment
[17:38:31.989] - copied ‘...future.seeds_ii’ to environment
[17:38:31.989] - copied ‘...future.globals.maxSize’ to environment
[17:38:31.989] assign_globals() ... done
[17:38:31.989] requestCore(): workers = 2
[17:38:31.991] MulticoreFuture started
[17:38:31.992] - Launch lazy future ... done
[17:38:31.992] run() for ‘MulticoreFuture’ ... done
[17:38:31.992] Created future:
[17:38:31.992] plan(): Setting new future strategy stack:
[17:38:31.993] List of future strategies:
[17:38:31.993] 1. sequential:
[17:38:31.993]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:31.993]    - tweaked: FALSE
[17:38:31.993]    - call: NULL
[17:38:31.994] plan(): nbrOfWorkers() = 1
[17:38:31.993] MulticoreFuture:
[17:38:31.993] Label: ‘future_lapply-1’
[17:38:31.993] Expression:
[17:38:31.993] {
[17:38:31.993]     do.call(function(...) {
[17:38:31.993]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:31.993]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:31.993]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:31.993]             on.exit(options(oopts), add = TRUE)
[17:38:31.993]         }
[17:38:31.993]         {
[17:38:31.993]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:31.993]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:31.993]                 ...future.FUN(...future.X_jj, ...)
[17:38:31.993]             })
[17:38:31.993]         }
[17:38:31.993]     }, args = future.call.arguments)
[17:38:31.993] }
[17:38:31.993] Lazy evaluation: FALSE
[17:38:31.993] Asynchronous evaluation: TRUE
[17:38:31.993] Local evaluation: TRUE
[17:38:31.993] Environment: R_GlobalEnv
[17:38:31.993] Capture standard output: NA
[17:38:31.993] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:31.993] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:31.993] Packages: <none>
[17:38:31.993] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:31.993] Resolved: FALSE
[17:38:31.993] Value: <not collected>
[17:38:31.993] Conditions captured: <none>
[17:38:31.993] Early signaling: FALSE
[17:38:31.993] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:31.993] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:32.005] Chunk #1 of 2 ... DONE
[17:38:32.006] Chunk #2 of 2 ...
[17:38:32.006]  - Finding globals in 'X' for chunk #2 ...
[17:38:32.006] getGlobalsAndPackages() ...
[17:38:32.006] Searching for globals...
[17:38:32.007] 
[17:38:32.007] Searching for globals ... DONE
[17:38:32.007] - globals: [0] <none>
[17:38:32.007] getGlobalsAndPackages() ... DONE
[17:38:32.007]    + additional globals found: [n=0] 
[17:38:32.008]    + additional namespaces needed: [n=0] 
[17:38:32.008]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:32.008]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:32.008]  - seeds: <none>
[17:38:32.008]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:32.008] getGlobalsAndPackages() ...
[17:38:32.009] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:32.009] Resolving globals: FALSE
[17:38:32.009] Tweak future expression to call with '...' arguments ...
[17:38:32.009] {
[17:38:32.009]     do.call(function(...) {
[17:38:32.009]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:32.009]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:32.009]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:32.009]             on.exit(options(oopts), add = TRUE)
[17:38:32.009]         }
[17:38:32.009]         {
[17:38:32.009]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:32.009]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:32.009]                 ...future.FUN(...future.X_jj, ...)
[17:38:32.009]             })
[17:38:32.009]         }
[17:38:32.009]     }, args = future.call.arguments)
[17:38:32.009] }
[17:38:32.010] Tweak future expression to call with '...' arguments ... DONE
[17:38:32.010] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:32.010] 
[17:38:32.011] getGlobalsAndPackages() ... DONE
[17:38:32.011] run() for ‘Future’ ...
[17:38:32.011] - state: ‘created’
[17:38:32.012] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:32.017] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:32.017] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:32.018]   - Field: ‘label’
[17:38:32.018]   - Field: ‘local’
[17:38:32.018]   - Field: ‘owner’
[17:38:32.018]   - Field: ‘envir’
[17:38:32.018]   - Field: ‘workers’
[17:38:32.018]   - Field: ‘packages’
[17:38:32.018]   - Field: ‘gc’
[17:38:32.019]   - Field: ‘job’
[17:38:32.019]   - Field: ‘conditions’
[17:38:32.019]   - Field: ‘expr’
[17:38:32.019]   - Field: ‘uuid’
[17:38:32.019]   - Field: ‘seed’
[17:38:32.019]   - Field: ‘version’
[17:38:32.020]   - Field: ‘result’
[17:38:32.020]   - Field: ‘asynchronous’
[17:38:32.020]   - Field: ‘calls’
[17:38:32.020]   - Field: ‘globals’
[17:38:32.020]   - Field: ‘stdout’
[17:38:32.020]   - Field: ‘earlySignal’
[17:38:32.020]   - Field: ‘lazy’
[17:38:32.021]   - Field: ‘state’
[17:38:32.021] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:32.021] - Launch lazy future ...
[17:38:32.022] Packages needed by the future expression (n = 0): <none>
[17:38:32.022] Packages needed by future strategies (n = 0): <none>
[17:38:32.022] {
[17:38:32.022]     {
[17:38:32.022]         {
[17:38:32.022]             ...future.startTime <- base::Sys.time()
[17:38:32.022]             {
[17:38:32.022]                 {
[17:38:32.022]                   {
[17:38:32.022]                     {
[17:38:32.022]                       base::local({
[17:38:32.022]                         has_future <- base::requireNamespace("future", 
[17:38:32.022]                           quietly = TRUE)
[17:38:32.022]                         if (has_future) {
[17:38:32.022]                           ns <- base::getNamespace("future")
[17:38:32.022]                           version <- ns[[".package"]][["version"]]
[17:38:32.022]                           if (is.null(version)) 
[17:38:32.022]                             version <- utils::packageVersion("future")
[17:38:32.022]                         }
[17:38:32.022]                         else {
[17:38:32.022]                           version <- NULL
[17:38:32.022]                         }
[17:38:32.022]                         if (!has_future || version < "1.8.0") {
[17:38:32.022]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:32.022]                             "", base::R.version$version.string), 
[17:38:32.022]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:32.022]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:32.022]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:32.022]                               "release", "version")], collapse = " "), 
[17:38:32.022]                             hostname = base::Sys.info()[["nodename"]])
[17:38:32.022]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:32.022]                             info)
[17:38:32.022]                           info <- base::paste(info, collapse = "; ")
[17:38:32.022]                           if (!has_future) {
[17:38:32.022]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:32.022]                               info)
[17:38:32.022]                           }
[17:38:32.022]                           else {
[17:38:32.022]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:32.022]                               info, version)
[17:38:32.022]                           }
[17:38:32.022]                           base::stop(msg)
[17:38:32.022]                         }
[17:38:32.022]                       })
[17:38:32.022]                     }
[17:38:32.022]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:32.022]                     base::options(mc.cores = 1L)
[17:38:32.022]                   }
[17:38:32.022]                   ...future.strategy.old <- future::plan("list")
[17:38:32.022]                   options(future.plan = NULL)
[17:38:32.022]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:32.022]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:32.022]                 }
[17:38:32.022]                 ...future.workdir <- getwd()
[17:38:32.022]             }
[17:38:32.022]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:32.022]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:32.022]         }
[17:38:32.022]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:32.022]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:32.022]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:32.022]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:32.022]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:32.022]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:32.022]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:32.022]             base::names(...future.oldOptions))
[17:38:32.022]     }
[17:38:32.022]     if (TRUE) {
[17:38:32.022]     }
[17:38:32.022]     else {
[17:38:32.022]         if (NA) {
[17:38:32.022]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:32.022]                 open = "w")
[17:38:32.022]         }
[17:38:32.022]         else {
[17:38:32.022]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:32.022]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:32.022]         }
[17:38:32.022]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:32.022]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:32.022]             base::sink(type = "output", split = FALSE)
[17:38:32.022]             base::close(...future.stdout)
[17:38:32.022]         }, add = TRUE)
[17:38:32.022]     }
[17:38:32.022]     ...future.frame <- base::sys.nframe()
[17:38:32.022]     ...future.conditions <- base::list()
[17:38:32.022]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:32.022]     if (FALSE) {
[17:38:32.022]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:32.022]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:32.022]     }
[17:38:32.022]     ...future.result <- base::tryCatch({
[17:38:32.022]         base::withCallingHandlers({
[17:38:32.022]             ...future.value <- base::withVisible(base::local({
[17:38:32.022]                 withCallingHandlers({
[17:38:32.022]                   {
[17:38:32.022]                     do.call(function(...) {
[17:38:32.022]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:32.022]                       if (!identical(...future.globals.maxSize.org, 
[17:38:32.022]                         ...future.globals.maxSize)) {
[17:38:32.022]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:32.022]                         on.exit(options(oopts), add = TRUE)
[17:38:32.022]                       }
[17:38:32.022]                       {
[17:38:32.022]                         lapply(seq_along(...future.elements_ii), 
[17:38:32.022]                           FUN = function(jj) {
[17:38:32.022]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:32.022]                             ...future.FUN(...future.X_jj, ...)
[17:38:32.022]                           })
[17:38:32.022]                       }
[17:38:32.022]                     }, args = future.call.arguments)
[17:38:32.022]                   }
[17:38:32.022]                 }, immediateCondition = function(cond) {
[17:38:32.022]                   save_rds <- function (object, pathname, ...) 
[17:38:32.022]                   {
[17:38:32.022]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:32.022]                     if (file_test("-f", pathname_tmp)) {
[17:38:32.022]                       fi_tmp <- file.info(pathname_tmp)
[17:38:32.022]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:32.022]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:32.022]                         fi_tmp[["mtime"]])
[17:38:32.022]                     }
[17:38:32.022]                     tryCatch({
[17:38:32.022]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:32.022]                     }, error = function(ex) {
[17:38:32.022]                       msg <- conditionMessage(ex)
[17:38:32.022]                       fi_tmp <- file.info(pathname_tmp)
[17:38:32.022]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:32.022]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:32.022]                         fi_tmp[["mtime"]], msg)
[17:38:32.022]                       ex$message <- msg
[17:38:32.022]                       stop(ex)
[17:38:32.022]                     })
[17:38:32.022]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:32.022]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:32.022]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:32.022]                       fi_tmp <- file.info(pathname_tmp)
[17:38:32.022]                       fi <- file.info(pathname)
[17:38:32.022]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:32.022]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:32.022]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:32.022]                         fi[["size"]], fi[["mtime"]])
[17:38:32.022]                       stop(msg)
[17:38:32.022]                     }
[17:38:32.022]                     invisible(pathname)
[17:38:32.022]                   }
[17:38:32.022]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:32.022]                     rootPath = tempdir()) 
[17:38:32.022]                   {
[17:38:32.022]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:32.022]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:32.022]                       tmpdir = path, fileext = ".rds")
[17:38:32.022]                     save_rds(obj, file)
[17:38:32.022]                   }
[17:38:32.022]                   saveImmediateCondition(cond, path = "/tmp/RtmpBrP0ee/.future/immediateConditions")
[17:38:32.022]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:32.022]                   {
[17:38:32.022]                     inherits <- base::inherits
[17:38:32.022]                     invokeRestart <- base::invokeRestart
[17:38:32.022]                     is.null <- base::is.null
[17:38:32.022]                     muffled <- FALSE
[17:38:32.022]                     if (inherits(cond, "message")) {
[17:38:32.022]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:32.022]                       if (muffled) 
[17:38:32.022]                         invokeRestart("muffleMessage")
[17:38:32.022]                     }
[17:38:32.022]                     else if (inherits(cond, "warning")) {
[17:38:32.022]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:32.022]                       if (muffled) 
[17:38:32.022]                         invokeRestart("muffleWarning")
[17:38:32.022]                     }
[17:38:32.022]                     else if (inherits(cond, "condition")) {
[17:38:32.022]                       if (!is.null(pattern)) {
[17:38:32.022]                         computeRestarts <- base::computeRestarts
[17:38:32.022]                         grepl <- base::grepl
[17:38:32.022]                         restarts <- computeRestarts(cond)
[17:38:32.022]                         for (restart in restarts) {
[17:38:32.022]                           name <- restart$name
[17:38:32.022]                           if (is.null(name)) 
[17:38:32.022]                             next
[17:38:32.022]                           if (!grepl(pattern, name)) 
[17:38:32.022]                             next
[17:38:32.022]                           invokeRestart(restart)
[17:38:32.022]                           muffled <- TRUE
[17:38:32.022]                           break
[17:38:32.022]                         }
[17:38:32.022]                       }
[17:38:32.022]                     }
[17:38:32.022]                     invisible(muffled)
[17:38:32.022]                   }
[17:38:32.022]                   muffleCondition(cond)
[17:38:32.022]                 })
[17:38:32.022]             }))
[17:38:32.022]             future::FutureResult(value = ...future.value$value, 
[17:38:32.022]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:32.022]                   ...future.rng), globalenv = if (FALSE) 
[17:38:32.022]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:32.022]                     ...future.globalenv.names))
[17:38:32.022]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:32.022]         }, condition = base::local({
[17:38:32.022]             c <- base::c
[17:38:32.022]             inherits <- base::inherits
[17:38:32.022]             invokeRestart <- base::invokeRestart
[17:38:32.022]             length <- base::length
[17:38:32.022]             list <- base::list
[17:38:32.022]             seq.int <- base::seq.int
[17:38:32.022]             signalCondition <- base::signalCondition
[17:38:32.022]             sys.calls <- base::sys.calls
[17:38:32.022]             `[[` <- base::`[[`
[17:38:32.022]             `+` <- base::`+`
[17:38:32.022]             `<<-` <- base::`<<-`
[17:38:32.022]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:32.022]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:32.022]                   3L)]
[17:38:32.022]             }
[17:38:32.022]             function(cond) {
[17:38:32.022]                 is_error <- inherits(cond, "error")
[17:38:32.022]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:32.022]                   NULL)
[17:38:32.022]                 if (is_error) {
[17:38:32.022]                   sessionInformation <- function() {
[17:38:32.022]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:32.022]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:32.022]                       search = base::search(), system = base::Sys.info())
[17:38:32.022]                   }
[17:38:32.022]                   ...future.conditions[[length(...future.conditions) + 
[17:38:32.022]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:32.022]                     cond$call), session = sessionInformation(), 
[17:38:32.022]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:32.022]                   signalCondition(cond)
[17:38:32.022]                 }
[17:38:32.022]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:32.022]                 "immediateCondition"))) {
[17:38:32.022]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:32.022]                   ...future.conditions[[length(...future.conditions) + 
[17:38:32.022]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:32.022]                   if (TRUE && !signal) {
[17:38:32.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:32.022]                     {
[17:38:32.022]                       inherits <- base::inherits
[17:38:32.022]                       invokeRestart <- base::invokeRestart
[17:38:32.022]                       is.null <- base::is.null
[17:38:32.022]                       muffled <- FALSE
[17:38:32.022]                       if (inherits(cond, "message")) {
[17:38:32.022]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:32.022]                         if (muffled) 
[17:38:32.022]                           invokeRestart("muffleMessage")
[17:38:32.022]                       }
[17:38:32.022]                       else if (inherits(cond, "warning")) {
[17:38:32.022]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:32.022]                         if (muffled) 
[17:38:32.022]                           invokeRestart("muffleWarning")
[17:38:32.022]                       }
[17:38:32.022]                       else if (inherits(cond, "condition")) {
[17:38:32.022]                         if (!is.null(pattern)) {
[17:38:32.022]                           computeRestarts <- base::computeRestarts
[17:38:32.022]                           grepl <- base::grepl
[17:38:32.022]                           restarts <- computeRestarts(cond)
[17:38:32.022]                           for (restart in restarts) {
[17:38:32.022]                             name <- restart$name
[17:38:32.022]                             if (is.null(name)) 
[17:38:32.022]                               next
[17:38:32.022]                             if (!grepl(pattern, name)) 
[17:38:32.022]                               next
[17:38:32.022]                             invokeRestart(restart)
[17:38:32.022]                             muffled <- TRUE
[17:38:32.022]                             break
[17:38:32.022]                           }
[17:38:32.022]                         }
[17:38:32.022]                       }
[17:38:32.022]                       invisible(muffled)
[17:38:32.022]                     }
[17:38:32.022]                     muffleCondition(cond, pattern = "^muffle")
[17:38:32.022]                   }
[17:38:32.022]                 }
[17:38:32.022]                 else {
[17:38:32.022]                   if (TRUE) {
[17:38:32.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:32.022]                     {
[17:38:32.022]                       inherits <- base::inherits
[17:38:32.022]                       invokeRestart <- base::invokeRestart
[17:38:32.022]                       is.null <- base::is.null
[17:38:32.022]                       muffled <- FALSE
[17:38:32.022]                       if (inherits(cond, "message")) {
[17:38:32.022]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:32.022]                         if (muffled) 
[17:38:32.022]                           invokeRestart("muffleMessage")
[17:38:32.022]                       }
[17:38:32.022]                       else if (inherits(cond, "warning")) {
[17:38:32.022]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:32.022]                         if (muffled) 
[17:38:32.022]                           invokeRestart("muffleWarning")
[17:38:32.022]                       }
[17:38:32.022]                       else if (inherits(cond, "condition")) {
[17:38:32.022]                         if (!is.null(pattern)) {
[17:38:32.022]                           computeRestarts <- base::computeRestarts
[17:38:32.022]                           grepl <- base::grepl
[17:38:32.022]                           restarts <- computeRestarts(cond)
[17:38:32.022]                           for (restart in restarts) {
[17:38:32.022]                             name <- restart$name
[17:38:32.022]                             if (is.null(name)) 
[17:38:32.022]                               next
[17:38:32.022]                             if (!grepl(pattern, name)) 
[17:38:32.022]                               next
[17:38:32.022]                             invokeRestart(restart)
[17:38:32.022]                             muffled <- TRUE
[17:38:32.022]                             break
[17:38:32.022]                           }
[17:38:32.022]                         }
[17:38:32.022]                       }
[17:38:32.022]                       invisible(muffled)
[17:38:32.022]                     }
[17:38:32.022]                     muffleCondition(cond, pattern = "^muffle")
[17:38:32.022]                   }
[17:38:32.022]                 }
[17:38:32.022]             }
[17:38:32.022]         }))
[17:38:32.022]     }, error = function(ex) {
[17:38:32.022]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:32.022]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:32.022]                 ...future.rng), started = ...future.startTime, 
[17:38:32.022]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:32.022]             version = "1.8"), class = "FutureResult")
[17:38:32.022]     }, finally = {
[17:38:32.022]         if (!identical(...future.workdir, getwd())) 
[17:38:32.022]             setwd(...future.workdir)
[17:38:32.022]         {
[17:38:32.022]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:32.022]                 ...future.oldOptions$nwarnings <- NULL
[17:38:32.022]             }
[17:38:32.022]             base::options(...future.oldOptions)
[17:38:32.022]             if (.Platform$OS.type == "windows") {
[17:38:32.022]                 old_names <- names(...future.oldEnvVars)
[17:38:32.022]                 envs <- base::Sys.getenv()
[17:38:32.022]                 names <- names(envs)
[17:38:32.022]                 common <- intersect(names, old_names)
[17:38:32.022]                 added <- setdiff(names, old_names)
[17:38:32.022]                 removed <- setdiff(old_names, names)
[17:38:32.022]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:32.022]                   envs[common]]
[17:38:32.022]                 NAMES <- toupper(changed)
[17:38:32.022]                 args <- list()
[17:38:32.022]                 for (kk in seq_along(NAMES)) {
[17:38:32.022]                   name <- changed[[kk]]
[17:38:32.022]                   NAME <- NAMES[[kk]]
[17:38:32.022]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:32.022]                     next
[17:38:32.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:32.022]                 }
[17:38:32.022]                 NAMES <- toupper(added)
[17:38:32.022]                 for (kk in seq_along(NAMES)) {
[17:38:32.022]                   name <- added[[kk]]
[17:38:32.022]                   NAME <- NAMES[[kk]]
[17:38:32.022]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:32.022]                     next
[17:38:32.022]                   args[[name]] <- ""
[17:38:32.022]                 }
[17:38:32.022]                 NAMES <- toupper(removed)
[17:38:32.022]                 for (kk in seq_along(NAMES)) {
[17:38:32.022]                   name <- removed[[kk]]
[17:38:32.022]                   NAME <- NAMES[[kk]]
[17:38:32.022]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:32.022]                     next
[17:38:32.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:32.022]                 }
[17:38:32.022]                 if (length(args) > 0) 
[17:38:32.022]                   base::do.call(base::Sys.setenv, args = args)
[17:38:32.022]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:32.022]             }
[17:38:32.022]             else {
[17:38:32.022]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:32.022]             }
[17:38:32.022]             {
[17:38:32.022]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:32.022]                   0L) {
[17:38:32.022]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:32.022]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:32.022]                   base::options(opts)
[17:38:32.022]                 }
[17:38:32.022]                 {
[17:38:32.022]                   {
[17:38:32.022]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:32.022]                     NULL
[17:38:32.022]                   }
[17:38:32.022]                   options(future.plan = NULL)
[17:38:32.022]                   if (is.na(NA_character_)) 
[17:38:32.022]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:32.022]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:32.022]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:32.022]                     .init = FALSE)
[17:38:32.022]                 }
[17:38:32.022]             }
[17:38:32.022]         }
[17:38:32.022]     })
[17:38:32.022]     if (FALSE) {
[17:38:32.022]         base::sink(type = "output", split = FALSE)
[17:38:32.022]         if (NA) {
[17:38:32.022]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:32.022]         }
[17:38:32.022]         else {
[17:38:32.022]             ...future.result["stdout"] <- base::list(NULL)
[17:38:32.022]         }
[17:38:32.022]         base::close(...future.stdout)
[17:38:32.022]         ...future.stdout <- NULL
[17:38:32.022]     }
[17:38:32.022]     ...future.result$conditions <- ...future.conditions
[17:38:32.022]     ...future.result$finished <- base::Sys.time()
[17:38:32.022]     ...future.result
[17:38:32.022] }
[17:38:32.026] assign_globals() ...
[17:38:32.026] List of 5
[17:38:32.026]  $ ...future.FUN            :function (x)  
[17:38:32.026]  $ future.call.arguments    : list()
[17:38:32.026]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:32.026]  $ ...future.elements_ii    :List of 1
[17:38:32.026]   ..$ : int 0
[17:38:32.026]  $ ...future.seeds_ii       : NULL
[17:38:32.026]  $ ...future.globals.maxSize: NULL
[17:38:32.026]  - attr(*, "where")=List of 5
[17:38:32.026]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:32.026]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:32.026]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:32.026]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:32.026]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:32.026]  - attr(*, "resolved")= logi FALSE
[17:38:32.026]  - attr(*, "total_size")= num 4720
[17:38:32.026]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:32.026]  - attr(*, "already-done")= logi TRUE
[17:38:32.033] - reassign environment for ‘...future.FUN’
[17:38:32.033] - copied ‘...future.FUN’ to environment
[17:38:32.033] - copied ‘future.call.arguments’ to environment
[17:38:32.033] - copied ‘...future.elements_ii’ to environment
[17:38:32.033] - copied ‘...future.seeds_ii’ to environment
[17:38:32.034] - copied ‘...future.globals.maxSize’ to environment
[17:38:32.034] assign_globals() ... done
[17:38:32.034] requestCore(): workers = 2
[17:38:32.036] MulticoreFuture started
[17:38:32.037] - Launch lazy future ... done
[17:38:32.037] plan(): Setting new future strategy stack:
[17:38:32.037] run() for ‘MulticoreFuture’ ... done
[17:38:32.042] Created future:
[17:38:32.042] List of future strategies:
[17:38:32.042] 1. sequential:
[17:38:32.042]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:32.042]    - tweaked: FALSE
[17:38:32.042]    - call: NULL
[17:38:32.044] plan(): nbrOfWorkers() = 1
[17:38:32.046] plan(): Setting new future strategy stack:
[17:38:32.047] List of future strategies:
[17:38:32.047] 1. multicore:
[17:38:32.047]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:32.047]    - tweaked: FALSE
[17:38:32.047]    - call: plan(strategy)
[17:38:32.053] plan(): nbrOfWorkers() = 2
[17:38:32.042] MulticoreFuture:
[17:38:32.042] Label: ‘future_lapply-2’
[17:38:32.042] Expression:
[17:38:32.042] {
[17:38:32.042]     do.call(function(...) {
[17:38:32.042]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:32.042]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:32.042]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:32.042]             on.exit(options(oopts), add = TRUE)
[17:38:32.042]         }
[17:38:32.042]         {
[17:38:32.042]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:32.042]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:32.042]                 ...future.FUN(...future.X_jj, ...)
[17:38:32.042]             })
[17:38:32.042]         }
[17:38:32.042]     }, args = future.call.arguments)
[17:38:32.042] }
[17:38:32.042] Lazy evaluation: FALSE
[17:38:32.042] Asynchronous evaluation: TRUE
[17:38:32.042] Local evaluation: TRUE
[17:38:32.042] Environment: R_GlobalEnv
[17:38:32.042] Capture standard output: NA
[17:38:32.042] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:32.042] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:32.042] Packages: <none>
[17:38:32.042] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:32.042] Resolved: TRUE
[17:38:32.042] Value: <not collected>
[17:38:32.042] Conditions captured: <none>
[17:38:32.042] Early signaling: FALSE
[17:38:32.042] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:32.042] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:32.054] Chunk #2 of 2 ... DONE
[17:38:32.054] Launching 2 futures (chunks) ... DONE
[17:38:32.054] Resolving 2 futures (chunks) ...
[17:38:32.055] resolve() on list ...
[17:38:32.055]  recursive: 0
[17:38:32.055]  length: 2
[17:38:32.055] 
[17:38:32.066] Future #2
[17:38:32.066] result() for MulticoreFuture ...
[17:38:32.067] result() for MulticoreFuture ...
[17:38:32.068] result() for MulticoreFuture ... done
[17:38:32.068] result() for MulticoreFuture ... done
[17:38:32.068] result() for MulticoreFuture ...
[17:38:32.068] result() for MulticoreFuture ... done
[17:38:32.068] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:38:32.069] - nx: 2
[17:38:32.069] - relay: TRUE
[17:38:32.069] - stdout: TRUE
[17:38:32.069] - signal: TRUE
[17:38:32.069] - resignal: FALSE
[17:38:32.070] - force: TRUE
[17:38:32.070] - relayed: [n=2] FALSE, FALSE
[17:38:32.070] - queued futures: [n=2] FALSE, FALSE
[17:38:32.070]  - until=1
[17:38:32.070]  - relaying element #1
[17:38:32.071] - relayed: [n=2] FALSE, FALSE
[17:38:32.071] - queued futures: [n=2] FALSE, TRUE
[17:38:32.071] signalConditionsASAP(NULL, pos=2) ... done
[17:38:32.071]  length: 1 (resolved future 2)
[17:38:32.496] plan(): Setting new future strategy stack:
[17:38:32.497] List of future strategies:
[17:38:32.497] 1. multicore:
[17:38:32.497]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:32.497]    - tweaked: FALSE
[17:38:32.497]    - call: plan(strategy)
[17:38:32.501] plan(): nbrOfWorkers() = 2
[17:38:32.511] Future #1
[17:38:32.511] result() for MulticoreFuture ...
[17:38:32.512] result() for MulticoreFuture ...
[17:38:32.512] result() for MulticoreFuture ... done
[17:38:32.512] result() for MulticoreFuture ... done
[17:38:32.512] result() for MulticoreFuture ...
[17:38:32.512] result() for MulticoreFuture ... done
[17:38:32.512] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:38:32.512] - nx: 2
[17:38:32.513] - relay: TRUE
[17:38:32.513] - stdout: TRUE
[17:38:32.513] - signal: TRUE
[17:38:32.513] - resignal: FALSE
[17:38:32.513] - force: TRUE
[17:38:32.513] - relayed: [n=2] FALSE, FALSE
[17:38:32.513] - queued futures: [n=2] FALSE, TRUE
[17:38:32.513]  - until=1
[17:38:32.513]  - relaying element #1
[17:38:32.514] result() for MulticoreFuture ...
[17:38:32.514] result() for MulticoreFuture ... done
[17:38:32.514] result() for MulticoreFuture ...
[17:38:32.514] result() for MulticoreFuture ... done
[17:38:32.514] result() for MulticoreFuture ...
[17:38:32.514] result() for MulticoreFuture ... done
[17:38:32.514] result() for MulticoreFuture ...
[17:38:32.514] result() for MulticoreFuture ... done
[17:38:32.514] - relayed: [n=2] TRUE, FALSE
[17:38:32.515] - queued futures: [n=2] TRUE, TRUE
[17:38:32.515] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:38:32.515]  length: 0 (resolved future 1)
[17:38:32.515] Relaying remaining futures
[17:38:32.515] signalConditionsASAP(NULL, pos=0) ...
[17:38:32.515] - nx: 2
[17:38:32.515] - relay: TRUE
[17:38:32.515] - stdout: TRUE
[17:38:32.515] - signal: TRUE
[17:38:32.515] - resignal: FALSE
[17:38:32.516] - force: TRUE
[17:38:32.516] - relayed: [n=2] TRUE, FALSE
[17:38:32.516] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:32.516]  - relaying element #2
[17:38:32.516] result() for MulticoreFuture ...
[17:38:32.516] result() for MulticoreFuture ... done
[17:38:32.516] result() for MulticoreFuture ...
[17:38:32.516] result() for MulticoreFuture ... done
[17:38:32.517] result() for MulticoreFuture ...
[17:38:32.517] result() for MulticoreFuture ... done
[17:38:32.517] result() for MulticoreFuture ...
[17:38:32.517] result() for MulticoreFuture ... done
[17:38:32.517] - relayed: [n=2] TRUE, TRUE
[17:38:32.517] - queued futures: [n=2] TRUE, TRUE
[17:38:32.517] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:38:32.517] resolve() on list ... DONE
[17:38:32.517] result() for MulticoreFuture ...
[17:38:32.518] result() for MulticoreFuture ... done
[17:38:32.518] result() for MulticoreFuture ...
[17:38:32.518] result() for MulticoreFuture ... done
[17:38:32.518] result() for MulticoreFuture ...
[17:38:32.518] result() for MulticoreFuture ... done
[17:38:32.518] result() for MulticoreFuture ...
[17:38:32.518] result() for MulticoreFuture ... done
[17:38:32.518]  - Number of value chunks collected: 2
[17:38:32.518] Resolving 2 futures (chunks) ... DONE
[17:38:32.519] Reducing values from 2 chunks ...
[17:38:32.519]  - Number of values collected after concatenation: 2
[17:38:32.519]  - Number of values expected: 2
[17:38:32.519] Reducing values from 2 chunks ... DONE
[17:38:32.519] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[17:38:32.519] future_mapply() ...
[17:38:32.524] Number of chunks: 2
[17:38:32.524] getGlobalsAndPackagesXApply() ...
[17:38:32.524]  - future.globals: TRUE
[17:38:32.524] getGlobalsAndPackages() ...
[17:38:32.525] Searching for globals...
[17:38:32.527] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:38:32.527] Searching for globals ... DONE
[17:38:32.527] Resolving globals: FALSE
[17:38:32.527] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:38:32.528] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:38:32.528] - globals: [1] ‘FUN’
[17:38:32.528] 
[17:38:32.528] getGlobalsAndPackages() ... DONE
[17:38:32.528]  - globals found/used: [n=1] ‘FUN’
[17:38:32.528]  - needed namespaces: [n=0] 
[17:38:32.528] Finding globals ... DONE
[17:38:32.529] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:38:32.529] List of 2
[17:38:32.529]  $ ...future.FUN:function (x, y)  
[17:38:32.529]  $ MoreArgs     : NULL
[17:38:32.529]  - attr(*, "where")=List of 2
[17:38:32.529]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:32.529]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:38:32.529]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:32.529]  - attr(*, "resolved")= logi FALSE
[17:38:32.529]  - attr(*, "total_size")= num NA
[17:38:32.532] Packages to be attached in all futures: [n=0] 
[17:38:32.532] getGlobalsAndPackagesXApply() ... DONE
[17:38:32.532] Number of futures (= number of chunks): 2
[17:38:32.532] Launching 2 futures (chunks) ...
[17:38:32.532] Chunk #1 of 2 ...
[17:38:32.532]  - Finding globals in '...' for chunk #1 ...
[17:38:32.532] getGlobalsAndPackages() ...
[17:38:32.533] Searching for globals...
[17:38:32.533] 
[17:38:32.533] Searching for globals ... DONE
[17:38:32.533] - globals: [0] <none>
[17:38:32.533] getGlobalsAndPackages() ... DONE
[17:38:32.535]    + additional globals found: [n=0] 
[17:38:32.535]    + additional namespaces needed: [n=0] 
[17:38:32.535]  - Finding globals in '...' for chunk #1 ... DONE
[17:38:32.535]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:32.536]  - seeds: <none>
[17:38:32.536]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:32.536] getGlobalsAndPackages() ...
[17:38:32.536] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:32.536] Resolving globals: FALSE
[17:38:32.537] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:38:32.537] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:38:32.537] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:32.538] 
[17:38:32.538] getGlobalsAndPackages() ... DONE
[17:38:32.538] run() for ‘Future’ ...
[17:38:32.538] - state: ‘created’
[17:38:32.538] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:32.542] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:32.542] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:32.543]   - Field: ‘label’
[17:38:32.543]   - Field: ‘local’
[17:38:32.543]   - Field: ‘owner’
[17:38:32.543]   - Field: ‘envir’
[17:38:32.543]   - Field: ‘workers’
[17:38:32.543]   - Field: ‘packages’
[17:38:32.543]   - Field: ‘gc’
[17:38:32.543]   - Field: ‘job’
[17:38:32.543]   - Field: ‘conditions’
[17:38:32.543]   - Field: ‘expr’
[17:38:32.544]   - Field: ‘uuid’
[17:38:32.544]   - Field: ‘seed’
[17:38:32.544]   - Field: ‘version’
[17:38:32.544]   - Field: ‘result’
[17:38:32.544]   - Field: ‘asynchronous’
[17:38:32.544]   - Field: ‘calls’
[17:38:32.544]   - Field: ‘globals’
[17:38:32.544]   - Field: ‘stdout’
[17:38:32.544]   - Field: ‘earlySignal’
[17:38:32.544]   - Field: ‘lazy’
[17:38:32.545]   - Field: ‘state’
[17:38:32.545] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:32.545] - Launch lazy future ...
[17:38:32.545] Packages needed by the future expression (n = 0): <none>
[17:38:32.545] Packages needed by future strategies (n = 0): <none>
[17:38:32.546] {
[17:38:32.546]     {
[17:38:32.546]         {
[17:38:32.546]             ...future.startTime <- base::Sys.time()
[17:38:32.546]             {
[17:38:32.546]                 {
[17:38:32.546]                   {
[17:38:32.546]                     {
[17:38:32.546]                       base::local({
[17:38:32.546]                         has_future <- base::requireNamespace("future", 
[17:38:32.546]                           quietly = TRUE)
[17:38:32.546]                         if (has_future) {
[17:38:32.546]                           ns <- base::getNamespace("future")
[17:38:32.546]                           version <- ns[[".package"]][["version"]]
[17:38:32.546]                           if (is.null(version)) 
[17:38:32.546]                             version <- utils::packageVersion("future")
[17:38:32.546]                         }
[17:38:32.546]                         else {
[17:38:32.546]                           version <- NULL
[17:38:32.546]                         }
[17:38:32.546]                         if (!has_future || version < "1.8.0") {
[17:38:32.546]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:32.546]                             "", base::R.version$version.string), 
[17:38:32.546]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:32.546]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:32.546]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:32.546]                               "release", "version")], collapse = " "), 
[17:38:32.546]                             hostname = base::Sys.info()[["nodename"]])
[17:38:32.546]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:32.546]                             info)
[17:38:32.546]                           info <- base::paste(info, collapse = "; ")
[17:38:32.546]                           if (!has_future) {
[17:38:32.546]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:32.546]                               info)
[17:38:32.546]                           }
[17:38:32.546]                           else {
[17:38:32.546]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:32.546]                               info, version)
[17:38:32.546]                           }
[17:38:32.546]                           base::stop(msg)
[17:38:32.546]                         }
[17:38:32.546]                       })
[17:38:32.546]                     }
[17:38:32.546]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:32.546]                     base::options(mc.cores = 1L)
[17:38:32.546]                   }
[17:38:32.546]                   ...future.strategy.old <- future::plan("list")
[17:38:32.546]                   options(future.plan = NULL)
[17:38:32.546]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:32.546]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:32.546]                 }
[17:38:32.546]                 ...future.workdir <- getwd()
[17:38:32.546]             }
[17:38:32.546]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:32.546]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:32.546]         }
[17:38:32.546]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:32.546]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:32.546]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:32.546]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:32.546]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:32.546]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:32.546]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:32.546]             base::names(...future.oldOptions))
[17:38:32.546]     }
[17:38:32.546]     if (FALSE) {
[17:38:32.546]     }
[17:38:32.546]     else {
[17:38:32.546]         if (FALSE) {
[17:38:32.546]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:32.546]                 open = "w")
[17:38:32.546]         }
[17:38:32.546]         else {
[17:38:32.546]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:32.546]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:32.546]         }
[17:38:32.546]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:32.546]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:32.546]             base::sink(type = "output", split = FALSE)
[17:38:32.546]             base::close(...future.stdout)
[17:38:32.546]         }, add = TRUE)
[17:38:32.546]     }
[17:38:32.546]     ...future.frame <- base::sys.nframe()
[17:38:32.546]     ...future.conditions <- base::list()
[17:38:32.546]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:32.546]     if (FALSE) {
[17:38:32.546]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:32.546]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:32.546]     }
[17:38:32.546]     ...future.result <- base::tryCatch({
[17:38:32.546]         base::withCallingHandlers({
[17:38:32.546]             ...future.value <- base::withVisible(base::local({
[17:38:32.546]                 withCallingHandlers({
[17:38:32.546]                   {
[17:38:32.546]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:32.546]                     if (!identical(...future.globals.maxSize.org, 
[17:38:32.546]                       ...future.globals.maxSize)) {
[17:38:32.546]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:32.546]                       on.exit(options(oopts), add = TRUE)
[17:38:32.546]                     }
[17:38:32.546]                     {
[17:38:32.546]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:32.546]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:38:32.546]                         USE.NAMES = FALSE)
[17:38:32.546]                       do.call(mapply, args = args)
[17:38:32.546]                     }
[17:38:32.546]                   }
[17:38:32.546]                 }, immediateCondition = function(cond) {
[17:38:32.546]                   save_rds <- function (object, pathname, ...) 
[17:38:32.546]                   {
[17:38:32.546]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:32.546]                     if (file_test("-f", pathname_tmp)) {
[17:38:32.546]                       fi_tmp <- file.info(pathname_tmp)
[17:38:32.546]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:32.546]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:32.546]                         fi_tmp[["mtime"]])
[17:38:32.546]                     }
[17:38:32.546]                     tryCatch({
[17:38:32.546]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:32.546]                     }, error = function(ex) {
[17:38:32.546]                       msg <- conditionMessage(ex)
[17:38:32.546]                       fi_tmp <- file.info(pathname_tmp)
[17:38:32.546]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:32.546]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:32.546]                         fi_tmp[["mtime"]], msg)
[17:38:32.546]                       ex$message <- msg
[17:38:32.546]                       stop(ex)
[17:38:32.546]                     })
[17:38:32.546]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:32.546]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:32.546]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:32.546]                       fi_tmp <- file.info(pathname_tmp)
[17:38:32.546]                       fi <- file.info(pathname)
[17:38:32.546]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:32.546]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:32.546]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:32.546]                         fi[["size"]], fi[["mtime"]])
[17:38:32.546]                       stop(msg)
[17:38:32.546]                     }
[17:38:32.546]                     invisible(pathname)
[17:38:32.546]                   }
[17:38:32.546]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:32.546]                     rootPath = tempdir()) 
[17:38:32.546]                   {
[17:38:32.546]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:32.546]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:32.546]                       tmpdir = path, fileext = ".rds")
[17:38:32.546]                     save_rds(obj, file)
[17:38:32.546]                   }
[17:38:32.546]                   saveImmediateCondition(cond, path = "/tmp/RtmpBrP0ee/.future/immediateConditions")
[17:38:32.546]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:32.546]                   {
[17:38:32.546]                     inherits <- base::inherits
[17:38:32.546]                     invokeRestart <- base::invokeRestart
[17:38:32.546]                     is.null <- base::is.null
[17:38:32.546]                     muffled <- FALSE
[17:38:32.546]                     if (inherits(cond, "message")) {
[17:38:32.546]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:32.546]                       if (muffled) 
[17:38:32.546]                         invokeRestart("muffleMessage")
[17:38:32.546]                     }
[17:38:32.546]                     else if (inherits(cond, "warning")) {
[17:38:32.546]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:32.546]                       if (muffled) 
[17:38:32.546]                         invokeRestart("muffleWarning")
[17:38:32.546]                     }
[17:38:32.546]                     else if (inherits(cond, "condition")) {
[17:38:32.546]                       if (!is.null(pattern)) {
[17:38:32.546]                         computeRestarts <- base::computeRestarts
[17:38:32.546]                         grepl <- base::grepl
[17:38:32.546]                         restarts <- computeRestarts(cond)
[17:38:32.546]                         for (restart in restarts) {
[17:38:32.546]                           name <- restart$name
[17:38:32.546]                           if (is.null(name)) 
[17:38:32.546]                             next
[17:38:32.546]                           if (!grepl(pattern, name)) 
[17:38:32.546]                             next
[17:38:32.546]                           invokeRestart(restart)
[17:38:32.546]                           muffled <- TRUE
[17:38:32.546]                           break
[17:38:32.546]                         }
[17:38:32.546]                       }
[17:38:32.546]                     }
[17:38:32.546]                     invisible(muffled)
[17:38:32.546]                   }
[17:38:32.546]                   muffleCondition(cond)
[17:38:32.546]                 })
[17:38:32.546]             }))
[17:38:32.546]             future::FutureResult(value = ...future.value$value, 
[17:38:32.546]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:32.546]                   ...future.rng), globalenv = if (FALSE) 
[17:38:32.546]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:32.546]                     ...future.globalenv.names))
[17:38:32.546]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:32.546]         }, condition = base::local({
[17:38:32.546]             c <- base::c
[17:38:32.546]             inherits <- base::inherits
[17:38:32.546]             invokeRestart <- base::invokeRestart
[17:38:32.546]             length <- base::length
[17:38:32.546]             list <- base::list
[17:38:32.546]             seq.int <- base::seq.int
[17:38:32.546]             signalCondition <- base::signalCondition
[17:38:32.546]             sys.calls <- base::sys.calls
[17:38:32.546]             `[[` <- base::`[[`
[17:38:32.546]             `+` <- base::`+`
[17:38:32.546]             `<<-` <- base::`<<-`
[17:38:32.546]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:32.546]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:32.546]                   3L)]
[17:38:32.546]             }
[17:38:32.546]             function(cond) {
[17:38:32.546]                 is_error <- inherits(cond, "error")
[17:38:32.546]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:32.546]                   NULL)
[17:38:32.546]                 if (is_error) {
[17:38:32.546]                   sessionInformation <- function() {
[17:38:32.546]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:32.546]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:32.546]                       search = base::search(), system = base::Sys.info())
[17:38:32.546]                   }
[17:38:32.546]                   ...future.conditions[[length(...future.conditions) + 
[17:38:32.546]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:32.546]                     cond$call), session = sessionInformation(), 
[17:38:32.546]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:32.546]                   signalCondition(cond)
[17:38:32.546]                 }
[17:38:32.546]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:32.546]                 "immediateCondition"))) {
[17:38:32.546]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:32.546]                   ...future.conditions[[length(...future.conditions) + 
[17:38:32.546]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:32.546]                   if (TRUE && !signal) {
[17:38:32.546]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:32.546]                     {
[17:38:32.546]                       inherits <- base::inherits
[17:38:32.546]                       invokeRestart <- base::invokeRestart
[17:38:32.546]                       is.null <- base::is.null
[17:38:32.546]                       muffled <- FALSE
[17:38:32.546]                       if (inherits(cond, "message")) {
[17:38:32.546]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:32.546]                         if (muffled) 
[17:38:32.546]                           invokeRestart("muffleMessage")
[17:38:32.546]                       }
[17:38:32.546]                       else if (inherits(cond, "warning")) {
[17:38:32.546]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:32.546]                         if (muffled) 
[17:38:32.546]                           invokeRestart("muffleWarning")
[17:38:32.546]                       }
[17:38:32.546]                       else if (inherits(cond, "condition")) {
[17:38:32.546]                         if (!is.null(pattern)) {
[17:38:32.546]                           computeRestarts <- base::computeRestarts
[17:38:32.546]                           grepl <- base::grepl
[17:38:32.546]                           restarts <- computeRestarts(cond)
[17:38:32.546]                           for (restart in restarts) {
[17:38:32.546]                             name <- restart$name
[17:38:32.546]                             if (is.null(name)) 
[17:38:32.546]                               next
[17:38:32.546]                             if (!grepl(pattern, name)) 
[17:38:32.546]                               next
[17:38:32.546]                             invokeRestart(restart)
[17:38:32.546]                             muffled <- TRUE
[17:38:32.546]                             break
[17:38:32.546]                           }
[17:38:32.546]                         }
[17:38:32.546]                       }
[17:38:32.546]                       invisible(muffled)
[17:38:32.546]                     }
[17:38:32.546]                     muffleCondition(cond, pattern = "^muffle")
[17:38:32.546]                   }
[17:38:32.546]                 }
[17:38:32.546]                 else {
[17:38:32.546]                   if (TRUE) {
[17:38:32.546]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:32.546]                     {
[17:38:32.546]                       inherits <- base::inherits
[17:38:32.546]                       invokeRestart <- base::invokeRestart
[17:38:32.546]                       is.null <- base::is.null
[17:38:32.546]                       muffled <- FALSE
[17:38:32.546]                       if (inherits(cond, "message")) {
[17:38:32.546]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:32.546]                         if (muffled) 
[17:38:32.546]                           invokeRestart("muffleMessage")
[17:38:32.546]                       }
[17:38:32.546]                       else if (inherits(cond, "warning")) {
[17:38:32.546]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:32.546]                         if (muffled) 
[17:38:32.546]                           invokeRestart("muffleWarning")
[17:38:32.546]                       }
[17:38:32.546]                       else if (inherits(cond, "condition")) {
[17:38:32.546]                         if (!is.null(pattern)) {
[17:38:32.546]                           computeRestarts <- base::computeRestarts
[17:38:32.546]                           grepl <- base::grepl
[17:38:32.546]                           restarts <- computeRestarts(cond)
[17:38:32.546]                           for (restart in restarts) {
[17:38:32.546]                             name <- restart$name
[17:38:32.546]                             if (is.null(name)) 
[17:38:32.546]                               next
[17:38:32.546]                             if (!grepl(pattern, name)) 
[17:38:32.546]                               next
[17:38:32.546]                             invokeRestart(restart)
[17:38:32.546]                             muffled <- TRUE
[17:38:32.546]                             break
[17:38:32.546]                           }
[17:38:32.546]                         }
[17:38:32.546]                       }
[17:38:32.546]                       invisible(muffled)
[17:38:32.546]                     }
[17:38:32.546]                     muffleCondition(cond, pattern = "^muffle")
[17:38:32.546]                   }
[17:38:32.546]                 }
[17:38:32.546]             }
[17:38:32.546]         }))
[17:38:32.546]     }, error = function(ex) {
[17:38:32.546]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:32.546]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:32.546]                 ...future.rng), started = ...future.startTime, 
[17:38:32.546]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:32.546]             version = "1.8"), class = "FutureResult")
[17:38:32.546]     }, finally = {
[17:38:32.546]         if (!identical(...future.workdir, getwd())) 
[17:38:32.546]             setwd(...future.workdir)
[17:38:32.546]         {
[17:38:32.546]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:32.546]                 ...future.oldOptions$nwarnings <- NULL
[17:38:32.546]             }
[17:38:32.546]             base::options(...future.oldOptions)
[17:38:32.546]             if (.Platform$OS.type == "windows") {
[17:38:32.546]                 old_names <- names(...future.oldEnvVars)
[17:38:32.546]                 envs <- base::Sys.getenv()
[17:38:32.546]                 names <- names(envs)
[17:38:32.546]                 common <- intersect(names, old_names)
[17:38:32.546]                 added <- setdiff(names, old_names)
[17:38:32.546]                 removed <- setdiff(old_names, names)
[17:38:32.546]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:32.546]                   envs[common]]
[17:38:32.546]                 NAMES <- toupper(changed)
[17:38:32.546]                 args <- list()
[17:38:32.546]                 for (kk in seq_along(NAMES)) {
[17:38:32.546]                   name <- changed[[kk]]
[17:38:32.546]                   NAME <- NAMES[[kk]]
[17:38:32.546]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:32.546]                     next
[17:38:32.546]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:32.546]                 }
[17:38:32.546]                 NAMES <- toupper(added)
[17:38:32.546]                 for (kk in seq_along(NAMES)) {
[17:38:32.546]                   name <- added[[kk]]
[17:38:32.546]                   NAME <- NAMES[[kk]]
[17:38:32.546]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:32.546]                     next
[17:38:32.546]                   args[[name]] <- ""
[17:38:32.546]                 }
[17:38:32.546]                 NAMES <- toupper(removed)
[17:38:32.546]                 for (kk in seq_along(NAMES)) {
[17:38:32.546]                   name <- removed[[kk]]
[17:38:32.546]                   NAME <- NAMES[[kk]]
[17:38:32.546]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:32.546]                     next
[17:38:32.546]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:32.546]                 }
[17:38:32.546]                 if (length(args) > 0) 
[17:38:32.546]                   base::do.call(base::Sys.setenv, args = args)
[17:38:32.546]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:32.546]             }
[17:38:32.546]             else {
[17:38:32.546]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:32.546]             }
[17:38:32.546]             {
[17:38:32.546]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:32.546]                   0L) {
[17:38:32.546]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:32.546]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:32.546]                   base::options(opts)
[17:38:32.546]                 }
[17:38:32.546]                 {
[17:38:32.546]                   {
[17:38:32.546]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:32.546]                     NULL
[17:38:32.546]                   }
[17:38:32.546]                   options(future.plan = NULL)
[17:38:32.546]                   if (is.na(NA_character_)) 
[17:38:32.546]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:32.546]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:32.546]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:32.546]                     .init = FALSE)
[17:38:32.546]                 }
[17:38:32.546]             }
[17:38:32.546]         }
[17:38:32.546]     })
[17:38:32.546]     if (TRUE) {
[17:38:32.546]         base::sink(type = "output", split = FALSE)
[17:38:32.546]         if (FALSE) {
[17:38:32.546]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:32.546]         }
[17:38:32.546]         else {
[17:38:32.546]             ...future.result["stdout"] <- base::list(NULL)
[17:38:32.546]         }
[17:38:32.546]         base::close(...future.stdout)
[17:38:32.546]         ...future.stdout <- NULL
[17:38:32.546]     }
[17:38:32.546]     ...future.result$conditions <- ...future.conditions
[17:38:32.546]     ...future.result$finished <- base::Sys.time()
[17:38:32.546]     ...future.result
[17:38:32.546] }
[17:38:32.548] assign_globals() ...
[17:38:32.548] List of 5
[17:38:32.548]  $ ...future.FUN            :function (x, y)  
[17:38:32.548]  $ MoreArgs                 : NULL
[17:38:32.548]  $ ...future.elements_ii    :List of 2
[17:38:32.548]   ..$ :List of 1
[17:38:32.548]   .. ..$ : int 1
[17:38:32.548]   ..$ :List of 1
[17:38:32.548]   .. ..$ : int 0
[17:38:32.548]  $ ...future.seeds_ii       : NULL
[17:38:32.548]  $ ...future.globals.maxSize: NULL
[17:38:32.548]  - attr(*, "where")=List of 5
[17:38:32.548]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:32.548]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:38:32.548]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:32.548]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:32.548]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:32.548]  - attr(*, "resolved")= logi FALSE
[17:38:32.548]  - attr(*, "total_size")= num 6368
[17:38:32.548]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:32.548]  - attr(*, "already-done")= logi TRUE
[17:38:32.553] - reassign environment for ‘...future.FUN’
[17:38:32.553] - copied ‘...future.FUN’ to environment
[17:38:32.554] - copied ‘MoreArgs’ to environment
[17:38:32.554] - copied ‘...future.elements_ii’ to environment
[17:38:32.554] - copied ‘...future.seeds_ii’ to environment
[17:38:32.554] - copied ‘...future.globals.maxSize’ to environment
[17:38:32.554] assign_globals() ... done
[17:38:32.554] requestCore(): workers = 2
[17:38:32.556] MulticoreFuture started
[17:38:32.557] - Launch lazy future ... done
[17:38:32.557] run() for ‘MulticoreFuture’ ... done
[17:38:32.557] Created future:
[17:38:32.557] plan(): Setting new future strategy stack:
[17:38:32.558] List of future strategies:
[17:38:32.558] 1. sequential:
[17:38:32.558]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:32.558]    - tweaked: FALSE
[17:38:32.558]    - call: NULL
[17:38:32.559] plan(): nbrOfWorkers() = 1
[17:38:32.557] MulticoreFuture:
[17:38:32.557] Label: ‘future_mapply-1’
[17:38:32.557] Expression:
[17:38:32.557] {
[17:38:32.557]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:32.557]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:32.557]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:32.557]         on.exit(options(oopts), add = TRUE)
[17:38:32.557]     }
[17:38:32.557]     {
[17:38:32.557]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:32.557]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:38:32.557]         do.call(mapply, args = args)
[17:38:32.557]     }
[17:38:32.557] }
[17:38:32.557] Lazy evaluation: FALSE
[17:38:32.557] Asynchronous evaluation: TRUE
[17:38:32.557] Local evaluation: TRUE
[17:38:32.557] Environment: R_GlobalEnv
[17:38:32.557] Capture standard output: FALSE
[17:38:32.557] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:32.557] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:32.557] Packages: <none>
[17:38:32.557] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:32.557] Resolved: FALSE
[17:38:32.557] Value: <not collected>
[17:38:32.557] Conditions captured: <none>
[17:38:32.557] Early signaling: FALSE
[17:38:32.557] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:32.557] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:32.570] Chunk #1 of 2 ... DONE
[17:38:32.570] Chunk #2 of 2 ...
[17:38:32.571]  - Finding globals in '...' for chunk #2 ...
[17:38:32.571] getGlobalsAndPackages() ...
[17:38:32.571] Searching for globals...
[17:38:32.572] 
[17:38:32.572] Searching for globals ... DONE
[17:38:32.572] - globals: [0] <none>
[17:38:32.572] getGlobalsAndPackages() ... DONE
[17:38:32.572]    + additional globals found: [n=0] 
[17:38:32.572]    + additional namespaces needed: [n=0] 
[17:38:32.573]  - Finding globals in '...' for chunk #2 ... DONE
[17:38:32.573]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:32.573]  - seeds: <none>
[17:38:32.573]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:32.573] getGlobalsAndPackages() ...
[17:38:32.573] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:32.574] Resolving globals: FALSE
[17:38:32.574] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:38:32.575] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:38:32.575] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:32.576] 
[17:38:32.576] getGlobalsAndPackages() ... DONE
[17:38:32.576] run() for ‘Future’ ...
[17:38:32.577] - state: ‘created’
[17:38:32.577] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:32.582] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:32.582] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:32.582]   - Field: ‘label’
[17:38:32.582]   - Field: ‘local’
[17:38:32.583]   - Field: ‘owner’
[17:38:32.583]   - Field: ‘envir’
[17:38:32.583]   - Field: ‘workers’
[17:38:32.583]   - Field: ‘packages’
[17:38:32.583]   - Field: ‘gc’
[17:38:32.583]   - Field: ‘job’
[17:38:32.584]   - Field: ‘conditions’
[17:38:32.584]   - Field: ‘expr’
[17:38:32.584]   - Field: ‘uuid’
[17:38:32.584]   - Field: ‘seed’
[17:38:32.584]   - Field: ‘version’
[17:38:32.584]   - Field: ‘result’
[17:38:32.584]   - Field: ‘asynchronous’
[17:38:32.585]   - Field: ‘calls’
[17:38:32.585]   - Field: ‘globals’
[17:38:32.585]   - Field: ‘stdout’
[17:38:32.585]   - Field: ‘earlySignal’
[17:38:32.585]   - Field: ‘lazy’
[17:38:32.585]   - Field: ‘state’
[17:38:32.589] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:32.589] - Launch lazy future ...
[17:38:32.590] Packages needed by the future expression (n = 0): <none>
[17:38:32.590] Packages needed by future strategies (n = 0): <none>
[17:38:32.591] {
[17:38:32.591]     {
[17:38:32.591]         {
[17:38:32.591]             ...future.startTime <- base::Sys.time()
[17:38:32.591]             {
[17:38:32.591]                 {
[17:38:32.591]                   {
[17:38:32.591]                     {
[17:38:32.591]                       base::local({
[17:38:32.591]                         has_future <- base::requireNamespace("future", 
[17:38:32.591]                           quietly = TRUE)
[17:38:32.591]                         if (has_future) {
[17:38:32.591]                           ns <- base::getNamespace("future")
[17:38:32.591]                           version <- ns[[".package"]][["version"]]
[17:38:32.591]                           if (is.null(version)) 
[17:38:32.591]                             version <- utils::packageVersion("future")
[17:38:32.591]                         }
[17:38:32.591]                         else {
[17:38:32.591]                           version <- NULL
[17:38:32.591]                         }
[17:38:32.591]                         if (!has_future || version < "1.8.0") {
[17:38:32.591]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:32.591]                             "", base::R.version$version.string), 
[17:38:32.591]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:32.591]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:32.591]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:32.591]                               "release", "version")], collapse = " "), 
[17:38:32.591]                             hostname = base::Sys.info()[["nodename"]])
[17:38:32.591]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:32.591]                             info)
[17:38:32.591]                           info <- base::paste(info, collapse = "; ")
[17:38:32.591]                           if (!has_future) {
[17:38:32.591]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:32.591]                               info)
[17:38:32.591]                           }
[17:38:32.591]                           else {
[17:38:32.591]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:32.591]                               info, version)
[17:38:32.591]                           }
[17:38:32.591]                           base::stop(msg)
[17:38:32.591]                         }
[17:38:32.591]                       })
[17:38:32.591]                     }
[17:38:32.591]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:32.591]                     base::options(mc.cores = 1L)
[17:38:32.591]                   }
[17:38:32.591]                   ...future.strategy.old <- future::plan("list")
[17:38:32.591]                   options(future.plan = NULL)
[17:38:32.591]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:32.591]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:32.591]                 }
[17:38:32.591]                 ...future.workdir <- getwd()
[17:38:32.591]             }
[17:38:32.591]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:32.591]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:32.591]         }
[17:38:32.591]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:32.591]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:32.591]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:32.591]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:32.591]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:32.591]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:32.591]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:32.591]             base::names(...future.oldOptions))
[17:38:32.591]     }
[17:38:32.591]     if (FALSE) {
[17:38:32.591]     }
[17:38:32.591]     else {
[17:38:32.591]         if (FALSE) {
[17:38:32.591]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:32.591]                 open = "w")
[17:38:32.591]         }
[17:38:32.591]         else {
[17:38:32.591]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:32.591]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:32.591]         }
[17:38:32.591]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:32.591]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:32.591]             base::sink(type = "output", split = FALSE)
[17:38:32.591]             base::close(...future.stdout)
[17:38:32.591]         }, add = TRUE)
[17:38:32.591]     }
[17:38:32.591]     ...future.frame <- base::sys.nframe()
[17:38:32.591]     ...future.conditions <- base::list()
[17:38:32.591]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:32.591]     if (FALSE) {
[17:38:32.591]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:32.591]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:32.591]     }
[17:38:32.591]     ...future.result <- base::tryCatch({
[17:38:32.591]         base::withCallingHandlers({
[17:38:32.591]             ...future.value <- base::withVisible(base::local({
[17:38:32.591]                 withCallingHandlers({
[17:38:32.591]                   {
[17:38:32.591]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:32.591]                     if (!identical(...future.globals.maxSize.org, 
[17:38:32.591]                       ...future.globals.maxSize)) {
[17:38:32.591]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:32.591]                       on.exit(options(oopts), add = TRUE)
[17:38:32.591]                     }
[17:38:32.591]                     {
[17:38:32.591]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:32.591]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:38:32.591]                         USE.NAMES = FALSE)
[17:38:32.591]                       do.call(mapply, args = args)
[17:38:32.591]                     }
[17:38:32.591]                   }
[17:38:32.591]                 }, immediateCondition = function(cond) {
[17:38:32.591]                   save_rds <- function (object, pathname, ...) 
[17:38:32.591]                   {
[17:38:32.591]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:32.591]                     if (file_test("-f", pathname_tmp)) {
[17:38:32.591]                       fi_tmp <- file.info(pathname_tmp)
[17:38:32.591]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:32.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:32.591]                         fi_tmp[["mtime"]])
[17:38:32.591]                     }
[17:38:32.591]                     tryCatch({
[17:38:32.591]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:32.591]                     }, error = function(ex) {
[17:38:32.591]                       msg <- conditionMessage(ex)
[17:38:32.591]                       fi_tmp <- file.info(pathname_tmp)
[17:38:32.591]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:32.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:32.591]                         fi_tmp[["mtime"]], msg)
[17:38:32.591]                       ex$message <- msg
[17:38:32.591]                       stop(ex)
[17:38:32.591]                     })
[17:38:32.591]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:32.591]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:32.591]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:32.591]                       fi_tmp <- file.info(pathname_tmp)
[17:38:32.591]                       fi <- file.info(pathname)
[17:38:32.591]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:32.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:32.591]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:32.591]                         fi[["size"]], fi[["mtime"]])
[17:38:32.591]                       stop(msg)
[17:38:32.591]                     }
[17:38:32.591]                     invisible(pathname)
[17:38:32.591]                   }
[17:38:32.591]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:32.591]                     rootPath = tempdir()) 
[17:38:32.591]                   {
[17:38:32.591]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:32.591]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:32.591]                       tmpdir = path, fileext = ".rds")
[17:38:32.591]                     save_rds(obj, file)
[17:38:32.591]                   }
[17:38:32.591]                   saveImmediateCondition(cond, path = "/tmp/RtmpBrP0ee/.future/immediateConditions")
[17:38:32.591]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:32.591]                   {
[17:38:32.591]                     inherits <- base::inherits
[17:38:32.591]                     invokeRestart <- base::invokeRestart
[17:38:32.591]                     is.null <- base::is.null
[17:38:32.591]                     muffled <- FALSE
[17:38:32.591]                     if (inherits(cond, "message")) {
[17:38:32.591]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:32.591]                       if (muffled) 
[17:38:32.591]                         invokeRestart("muffleMessage")
[17:38:32.591]                     }
[17:38:32.591]                     else if (inherits(cond, "warning")) {
[17:38:32.591]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:32.591]                       if (muffled) 
[17:38:32.591]                         invokeRestart("muffleWarning")
[17:38:32.591]                     }
[17:38:32.591]                     else if (inherits(cond, "condition")) {
[17:38:32.591]                       if (!is.null(pattern)) {
[17:38:32.591]                         computeRestarts <- base::computeRestarts
[17:38:32.591]                         grepl <- base::grepl
[17:38:32.591]                         restarts <- computeRestarts(cond)
[17:38:32.591]                         for (restart in restarts) {
[17:38:32.591]                           name <- restart$name
[17:38:32.591]                           if (is.null(name)) 
[17:38:32.591]                             next
[17:38:32.591]                           if (!grepl(pattern, name)) 
[17:38:32.591]                             next
[17:38:32.591]                           invokeRestart(restart)
[17:38:32.591]                           muffled <- TRUE
[17:38:32.591]                           break
[17:38:32.591]                         }
[17:38:32.591]                       }
[17:38:32.591]                     }
[17:38:32.591]                     invisible(muffled)
[17:38:32.591]                   }
[17:38:32.591]                   muffleCondition(cond)
[17:38:32.591]                 })
[17:38:32.591]             }))
[17:38:32.591]             future::FutureResult(value = ...future.value$value, 
[17:38:32.591]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:32.591]                   ...future.rng), globalenv = if (FALSE) 
[17:38:32.591]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:32.591]                     ...future.globalenv.names))
[17:38:32.591]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:32.591]         }, condition = base::local({
[17:38:32.591]             c <- base::c
[17:38:32.591]             inherits <- base::inherits
[17:38:32.591]             invokeRestart <- base::invokeRestart
[17:38:32.591]             length <- base::length
[17:38:32.591]             list <- base::list
[17:38:32.591]             seq.int <- base::seq.int
[17:38:32.591]             signalCondition <- base::signalCondition
[17:38:32.591]             sys.calls <- base::sys.calls
[17:38:32.591]             `[[` <- base::`[[`
[17:38:32.591]             `+` <- base::`+`
[17:38:32.591]             `<<-` <- base::`<<-`
[17:38:32.591]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:32.591]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:32.591]                   3L)]
[17:38:32.591]             }
[17:38:32.591]             function(cond) {
[17:38:32.591]                 is_error <- inherits(cond, "error")
[17:38:32.591]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:32.591]                   NULL)
[17:38:32.591]                 if (is_error) {
[17:38:32.591]                   sessionInformation <- function() {
[17:38:32.591]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:32.591]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:32.591]                       search = base::search(), system = base::Sys.info())
[17:38:32.591]                   }
[17:38:32.591]                   ...future.conditions[[length(...future.conditions) + 
[17:38:32.591]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:32.591]                     cond$call), session = sessionInformation(), 
[17:38:32.591]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:32.591]                   signalCondition(cond)
[17:38:32.591]                 }
[17:38:32.591]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:32.591]                 "immediateCondition"))) {
[17:38:32.591]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:32.591]                   ...future.conditions[[length(...future.conditions) + 
[17:38:32.591]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:32.591]                   if (TRUE && !signal) {
[17:38:32.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:32.591]                     {
[17:38:32.591]                       inherits <- base::inherits
[17:38:32.591]                       invokeRestart <- base::invokeRestart
[17:38:32.591]                       is.null <- base::is.null
[17:38:32.591]                       muffled <- FALSE
[17:38:32.591]                       if (inherits(cond, "message")) {
[17:38:32.591]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:32.591]                         if (muffled) 
[17:38:32.591]                           invokeRestart("muffleMessage")
[17:38:32.591]                       }
[17:38:32.591]                       else if (inherits(cond, "warning")) {
[17:38:32.591]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:32.591]                         if (muffled) 
[17:38:32.591]                           invokeRestart("muffleWarning")
[17:38:32.591]                       }
[17:38:32.591]                       else if (inherits(cond, "condition")) {
[17:38:32.591]                         if (!is.null(pattern)) {
[17:38:32.591]                           computeRestarts <- base::computeRestarts
[17:38:32.591]                           grepl <- base::grepl
[17:38:32.591]                           restarts <- computeRestarts(cond)
[17:38:32.591]                           for (restart in restarts) {
[17:38:32.591]                             name <- restart$name
[17:38:32.591]                             if (is.null(name)) 
[17:38:32.591]                               next
[17:38:32.591]                             if (!grepl(pattern, name)) 
[17:38:32.591]                               next
[17:38:32.591]                             invokeRestart(restart)
[17:38:32.591]                             muffled <- TRUE
[17:38:32.591]                             break
[17:38:32.591]                           }
[17:38:32.591]                         }
[17:38:32.591]                       }
[17:38:32.591]                       invisible(muffled)
[17:38:32.591]                     }
[17:38:32.591]                     muffleCondition(cond, pattern = "^muffle")
[17:38:32.591]                   }
[17:38:32.591]                 }
[17:38:32.591]                 else {
[17:38:32.591]                   if (TRUE) {
[17:38:32.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:32.591]                     {
[17:38:32.591]                       inherits <- base::inherits
[17:38:32.591]                       invokeRestart <- base::invokeRestart
[17:38:32.591]                       is.null <- base::is.null
[17:38:32.591]                       muffled <- FALSE
[17:38:32.591]                       if (inherits(cond, "message")) {
[17:38:32.591]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:32.591]                         if (muffled) 
[17:38:32.591]                           invokeRestart("muffleMessage")
[17:38:32.591]                       }
[17:38:32.591]                       else if (inherits(cond, "warning")) {
[17:38:32.591]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:32.591]                         if (muffled) 
[17:38:32.591]                           invokeRestart("muffleWarning")
[17:38:32.591]                       }
[17:38:32.591]                       else if (inherits(cond, "condition")) {
[17:38:32.591]                         if (!is.null(pattern)) {
[17:38:32.591]                           computeRestarts <- base::computeRestarts
[17:38:32.591]                           grepl <- base::grepl
[17:38:32.591]                           restarts <- computeRestarts(cond)
[17:38:32.591]                           for (restart in restarts) {
[17:38:32.591]                             name <- restart$name
[17:38:32.591]                             if (is.null(name)) 
[17:38:32.591]                               next
[17:38:32.591]                             if (!grepl(pattern, name)) 
[17:38:32.591]                               next
[17:38:32.591]                             invokeRestart(restart)
[17:38:32.591]                             muffled <- TRUE
[17:38:32.591]                             break
[17:38:32.591]                           }
[17:38:32.591]                         }
[17:38:32.591]                       }
[17:38:32.591]                       invisible(muffled)
[17:38:32.591]                     }
[17:38:32.591]                     muffleCondition(cond, pattern = "^muffle")
[17:38:32.591]                   }
[17:38:32.591]                 }
[17:38:32.591]             }
[17:38:32.591]         }))
[17:38:32.591]     }, error = function(ex) {
[17:38:32.591]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:32.591]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:32.591]                 ...future.rng), started = ...future.startTime, 
[17:38:32.591]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:32.591]             version = "1.8"), class = "FutureResult")
[17:38:32.591]     }, finally = {
[17:38:32.591]         if (!identical(...future.workdir, getwd())) 
[17:38:32.591]             setwd(...future.workdir)
[17:38:32.591]         {
[17:38:32.591]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:32.591]                 ...future.oldOptions$nwarnings <- NULL
[17:38:32.591]             }
[17:38:32.591]             base::options(...future.oldOptions)
[17:38:32.591]             if (.Platform$OS.type == "windows") {
[17:38:32.591]                 old_names <- names(...future.oldEnvVars)
[17:38:32.591]                 envs <- base::Sys.getenv()
[17:38:32.591]                 names <- names(envs)
[17:38:32.591]                 common <- intersect(names, old_names)
[17:38:32.591]                 added <- setdiff(names, old_names)
[17:38:32.591]                 removed <- setdiff(old_names, names)
[17:38:32.591]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:32.591]                   envs[common]]
[17:38:32.591]                 NAMES <- toupper(changed)
[17:38:32.591]                 args <- list()
[17:38:32.591]                 for (kk in seq_along(NAMES)) {
[17:38:32.591]                   name <- changed[[kk]]
[17:38:32.591]                   NAME <- NAMES[[kk]]
[17:38:32.591]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:32.591]                     next
[17:38:32.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:32.591]                 }
[17:38:32.591]                 NAMES <- toupper(added)
[17:38:32.591]                 for (kk in seq_along(NAMES)) {
[17:38:32.591]                   name <- added[[kk]]
[17:38:32.591]                   NAME <- NAMES[[kk]]
[17:38:32.591]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:32.591]                     next
[17:38:32.591]                   args[[name]] <- ""
[17:38:32.591]                 }
[17:38:32.591]                 NAMES <- toupper(removed)
[17:38:32.591]                 for (kk in seq_along(NAMES)) {
[17:38:32.591]                   name <- removed[[kk]]
[17:38:32.591]                   NAME <- NAMES[[kk]]
[17:38:32.591]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:32.591]                     next
[17:38:32.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:32.591]                 }
[17:38:32.591]                 if (length(args) > 0) 
[17:38:32.591]                   base::do.call(base::Sys.setenv, args = args)
[17:38:32.591]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:32.591]             }
[17:38:32.591]             else {
[17:38:32.591]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:32.591]             }
[17:38:32.591]             {
[17:38:32.591]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:32.591]                   0L) {
[17:38:32.591]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:32.591]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:32.591]                   base::options(opts)
[17:38:32.591]                 }
[17:38:32.591]                 {
[17:38:32.591]                   {
[17:38:32.591]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:32.591]                     NULL
[17:38:32.591]                   }
[17:38:32.591]                   options(future.plan = NULL)
[17:38:32.591]                   if (is.na(NA_character_)) 
[17:38:32.591]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:32.591]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:32.591]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:32.591]                     .init = FALSE)
[17:38:32.591]                 }
[17:38:32.591]             }
[17:38:32.591]         }
[17:38:32.591]     })
[17:38:32.591]     if (TRUE) {
[17:38:32.591]         base::sink(type = "output", split = FALSE)
[17:38:32.591]         if (FALSE) {
[17:38:32.591]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:32.591]         }
[17:38:32.591]         else {
[17:38:32.591]             ...future.result["stdout"] <- base::list(NULL)
[17:38:32.591]         }
[17:38:32.591]         base::close(...future.stdout)
[17:38:32.591]         ...future.stdout <- NULL
[17:38:32.591]     }
[17:38:32.591]     ...future.result$conditions <- ...future.conditions
[17:38:32.591]     ...future.result$finished <- base::Sys.time()
[17:38:32.591]     ...future.result
[17:38:32.591] }
[17:38:32.594] assign_globals() ...
[17:38:32.595] List of 5
[17:38:32.595]  $ ...future.FUN            :function (x, y)  
[17:38:32.595]  $ MoreArgs                 : NULL
[17:38:32.595]  $ ...future.elements_ii    :List of 2
[17:38:32.595]   ..$ :List of 1
[17:38:32.595]   .. ..$ : int 0
[17:38:32.595]   ..$ :List of 1
[17:38:32.595]   .. ..$ : int 1
[17:38:32.595]  $ ...future.seeds_ii       : NULL
[17:38:32.595]  $ ...future.globals.maxSize: NULL
[17:38:32.595]  - attr(*, "where")=List of 5
[17:38:32.595]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:32.595]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:38:32.595]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:32.595]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:32.595]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:32.595]  - attr(*, "resolved")= logi FALSE
[17:38:32.595]  - attr(*, "total_size")= num 6368
[17:38:32.595]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:32.595]  - attr(*, "already-done")= logi TRUE
[17:38:32.603] - reassign environment for ‘...future.FUN’
[17:38:32.603] - copied ‘...future.FUN’ to environment
[17:38:32.603] - copied ‘MoreArgs’ to environment
[17:38:32.604] - copied ‘...future.elements_ii’ to environment
[17:38:32.604] - copied ‘...future.seeds_ii’ to environment
[17:38:32.604] - copied ‘...future.globals.maxSize’ to environment
[17:38:32.604] assign_globals() ... done
[17:38:32.604] requestCore(): workers = 2
[17:38:32.606] MulticoreFuture started
[17:38:32.607] - Launch lazy future ... done
[17:38:32.607] run() for ‘MulticoreFuture’ ... done
[17:38:32.607] Created future:
[17:38:32.607] plan(): Setting new future strategy stack:
[17:38:32.608] List of future strategies:
[17:38:32.608] 1. sequential:
[17:38:32.608]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:32.608]    - tweaked: FALSE
[17:38:32.608]    - call: NULL
[17:38:32.609] plan(): nbrOfWorkers() = 1
[17:38:32.611] plan(): Setting new future strategy stack:
[17:38:32.611] List of future strategies:
[17:38:32.611] 1. multicore:
[17:38:32.611]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:32.611]    - tweaked: FALSE
[17:38:32.611]    - call: plan(strategy)
[17:38:32.616] plan(): nbrOfWorkers() = 2
[17:38:32.607] MulticoreFuture:
[17:38:32.607] Label: ‘future_mapply-2’
[17:38:32.607] Expression:
[17:38:32.607] {
[17:38:32.607]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:32.607]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:32.607]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:32.607]         on.exit(options(oopts), add = TRUE)
[17:38:32.607]     }
[17:38:32.607]     {
[17:38:32.607]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:32.607]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:38:32.607]         do.call(mapply, args = args)
[17:38:32.607]     }
[17:38:32.607] }
[17:38:32.607] Lazy evaluation: FALSE
[17:38:32.607] Asynchronous evaluation: TRUE
[17:38:32.607] Local evaluation: TRUE
[17:38:32.607] Environment: R_GlobalEnv
[17:38:32.607] Capture standard output: FALSE
[17:38:32.607] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:32.607] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:32.607] Packages: <none>
[17:38:32.607] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:32.607] Resolved: TRUE
[17:38:32.607] Value: <not collected>
[17:38:32.607] Conditions captured: <none>
[17:38:32.607] Early signaling: FALSE
[17:38:32.607] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:32.607] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:32.617] Chunk #2 of 2 ... DONE
[17:38:32.617] Launching 2 futures (chunks) ... DONE
[17:38:32.617] Resolving 2 futures (chunks) ...
[17:38:32.618] resolve() on list ...
[17:38:32.618]  recursive: 0
[17:38:32.618]  length: 2
[17:38:32.618] 
[17:38:32.629] Future #2
[17:38:32.629] result() for MulticoreFuture ...
[17:38:32.630] result() for MulticoreFuture ...
[17:38:32.630] result() for MulticoreFuture ... done
[17:38:32.630] result() for MulticoreFuture ... done
[17:38:32.631] result() for MulticoreFuture ...
[17:38:32.631] result() for MulticoreFuture ... done
[17:38:32.631] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:38:32.631] - nx: 2
[17:38:32.631] - relay: TRUE
[17:38:32.632] - stdout: TRUE
[17:38:32.632] - signal: TRUE
[17:38:32.632] - resignal: FALSE
[17:38:32.632] - force: TRUE
[17:38:32.632] - relayed: [n=2] FALSE, FALSE
[17:38:32.632] - queued futures: [n=2] FALSE, FALSE
[17:38:32.633]  - until=1
[17:38:32.633]  - relaying element #1
[17:38:32.633] - relayed: [n=2] FALSE, FALSE
[17:38:32.633] - queued futures: [n=2] FALSE, TRUE
[17:38:32.633] signalConditionsASAP(NULL, pos=2) ... done
[17:38:32.633]  length: 1 (resolved future 2)
[17:38:33.062] plan(): Setting new future strategy stack:
[17:38:33.062] List of future strategies:
[17:38:33.062] 1. multicore:
[17:38:33.062]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:33.062]    - tweaked: FALSE
[17:38:33.062]    - call: plan(strategy)
[17:38:33.066] plan(): nbrOfWorkers() = 2
[17:38:33.072] Future #1
[17:38:33.072] result() for MulticoreFuture ...
[17:38:33.073] result() for MulticoreFuture ...
[17:38:33.073] result() for MulticoreFuture ... done
[17:38:33.073] result() for MulticoreFuture ... done
[17:38:33.073] result() for MulticoreFuture ...
[17:38:33.074] result() for MulticoreFuture ... done
[17:38:33.074] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:38:33.074] - nx: 2
[17:38:33.074] - relay: TRUE
[17:38:33.074] - stdout: TRUE
[17:38:33.074] - signal: TRUE
[17:38:33.074] - resignal: FALSE
[17:38:33.074] - force: TRUE
[17:38:33.075] - relayed: [n=2] FALSE, FALSE
[17:38:33.075] - queued futures: [n=2] FALSE, TRUE
[17:38:33.075]  - until=1
[17:38:33.075]  - relaying element #1
[17:38:33.075] result() for MulticoreFuture ...
[17:38:33.075] result() for MulticoreFuture ... done
[17:38:33.075] result() for MulticoreFuture ...
[17:38:33.075] result() for MulticoreFuture ... done
[17:38:33.075] result() for MulticoreFuture ...
[17:38:33.076] result() for MulticoreFuture ... done
[17:38:33.076] result() for MulticoreFuture ...
[17:38:33.076] result() for MulticoreFuture ... done
[17:38:33.076] - relayed: [n=2] TRUE, FALSE
[17:38:33.076] - queued futures: [n=2] TRUE, TRUE
[17:38:33.076] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:38:33.076]  length: 0 (resolved future 1)
[17:38:33.077] Relaying remaining futures
[17:38:33.077] signalConditionsASAP(NULL, pos=0) ...
[17:38:33.077] - nx: 2
[17:38:33.077] - relay: TRUE
[17:38:33.077] - stdout: TRUE
[17:38:33.077] - signal: TRUE
[17:38:33.077] - resignal: FALSE
[17:38:33.077] - force: TRUE
[17:38:33.077] - relayed: [n=2] TRUE, FALSE
[17:38:33.077] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:33.078]  - relaying element #2
[17:38:33.078] result() for MulticoreFuture ...
[17:38:33.078] result() for MulticoreFuture ... done
[17:38:33.078] result() for MulticoreFuture ...
[17:38:33.078] result() for MulticoreFuture ... done
[17:38:33.078] result() for MulticoreFuture ...
[17:38:33.078] result() for MulticoreFuture ... done
[17:38:33.078] result() for MulticoreFuture ...
[17:38:33.079] result() for MulticoreFuture ... done
[17:38:33.079] - relayed: [n=2] TRUE, TRUE
[17:38:33.079] - queued futures: [n=2] TRUE, TRUE
[17:38:33.079] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:38:33.079] resolve() on list ... DONE
[17:38:33.079] result() for MulticoreFuture ...
[17:38:33.079] result() for MulticoreFuture ... done
[17:38:33.079] result() for MulticoreFuture ...
[17:38:33.079] result() for MulticoreFuture ... done
[17:38:33.080] result() for MulticoreFuture ...
[17:38:33.080] result() for MulticoreFuture ... done
[17:38:33.080] result() for MulticoreFuture ...
[17:38:33.080] result() for MulticoreFuture ... done
[17:38:33.080]  - Number of value chunks collected: 2
[17:38:33.080] Resolving 2 futures (chunks) ... DONE
[17:38:33.080] Reducing values from 2 chunks ...
[17:38:33.080]  - Number of values collected after concatenation: 2
[17:38:33.081]  - Number of values expected: 2
[17:38:33.081] Reducing values from 2 chunks ... DONE
[17:38:33.081] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[17:38:33.081] future_mapply() ...
[17:38:33.088] Number of chunks: 2
[17:38:33.089] getGlobalsAndPackagesXApply() ...
[17:38:33.089]  - future.globals: TRUE
[17:38:33.089] getGlobalsAndPackages() ...
[17:38:33.089] Searching for globals...
[17:38:33.091] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:38:33.091] Searching for globals ... DONE
[17:38:33.092] Resolving globals: FALSE
[17:38:33.092] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:38:33.093] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:38:33.093] - globals: [1] ‘FUN’
[17:38:33.093] 
[17:38:33.093] getGlobalsAndPackages() ... DONE
[17:38:33.093]  - globals found/used: [n=1] ‘FUN’
[17:38:33.093]  - needed namespaces: [n=0] 
[17:38:33.093] Finding globals ... DONE
[17:38:33.094] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:38:33.094] List of 2
[17:38:33.094]  $ ...future.FUN:function (x, y)  
[17:38:33.094]  $ MoreArgs     : NULL
[17:38:33.094]  - attr(*, "where")=List of 2
[17:38:33.094]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:33.094]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:38:33.094]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:33.094]  - attr(*, "resolved")= logi FALSE
[17:38:33.094]  - attr(*, "total_size")= num NA
[17:38:33.097] Packages to be attached in all futures: [n=0] 
[17:38:33.097] getGlobalsAndPackagesXApply() ... DONE
[17:38:33.097] Number of futures (= number of chunks): 2
[17:38:33.097] Launching 2 futures (chunks) ...
[17:38:33.097] Chunk #1 of 2 ...
[17:38:33.097]  - Finding globals in '...' for chunk #1 ...
[17:38:33.098] getGlobalsAndPackages() ...
[17:38:33.098] Searching for globals...
[17:38:33.098] 
[17:38:33.098] Searching for globals ... DONE
[17:38:33.098] - globals: [0] <none>
[17:38:33.098] getGlobalsAndPackages() ... DONE
[17:38:33.098]    + additional globals found: [n=0] 
[17:38:33.098]    + additional namespaces needed: [n=0] 
[17:38:33.099]  - Finding globals in '...' for chunk #1 ... DONE
[17:38:33.099]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:33.099]  - seeds: <none>
[17:38:33.099]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:33.099] getGlobalsAndPackages() ...
[17:38:33.099] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:33.099] Resolving globals: FALSE
[17:38:33.100] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:38:33.100] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:38:33.100] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:33.100] 
[17:38:33.100] getGlobalsAndPackages() ... DONE
[17:38:33.101] run() for ‘Future’ ...
[17:38:33.101] - state: ‘created’
[17:38:33.101] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:33.105] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:33.105] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:33.105]   - Field: ‘label’
[17:38:33.105]   - Field: ‘local’
[17:38:33.105]   - Field: ‘owner’
[17:38:33.105]   - Field: ‘envir’
[17:38:33.105]   - Field: ‘workers’
[17:38:33.105]   - Field: ‘packages’
[17:38:33.105]   - Field: ‘gc’
[17:38:33.106]   - Field: ‘job’
[17:38:33.106]   - Field: ‘conditions’
[17:38:33.106]   - Field: ‘expr’
[17:38:33.106]   - Field: ‘uuid’
[17:38:33.106]   - Field: ‘seed’
[17:38:33.106]   - Field: ‘version’
[17:38:33.106]   - Field: ‘result’
[17:38:33.106]   - Field: ‘asynchronous’
[17:38:33.106]   - Field: ‘calls’
[17:38:33.106]   - Field: ‘globals’
[17:38:33.106]   - Field: ‘stdout’
[17:38:33.107]   - Field: ‘earlySignal’
[17:38:33.107]   - Field: ‘lazy’
[17:38:33.107]   - Field: ‘state’
[17:38:33.107] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:33.107] - Launch lazy future ...
[17:38:33.107] Packages needed by the future expression (n = 0): <none>
[17:38:33.107] Packages needed by future strategies (n = 0): <none>
[17:38:33.108] {
[17:38:33.108]     {
[17:38:33.108]         {
[17:38:33.108]             ...future.startTime <- base::Sys.time()
[17:38:33.108]             {
[17:38:33.108]                 {
[17:38:33.108]                   {
[17:38:33.108]                     {
[17:38:33.108]                       base::local({
[17:38:33.108]                         has_future <- base::requireNamespace("future", 
[17:38:33.108]                           quietly = TRUE)
[17:38:33.108]                         if (has_future) {
[17:38:33.108]                           ns <- base::getNamespace("future")
[17:38:33.108]                           version <- ns[[".package"]][["version"]]
[17:38:33.108]                           if (is.null(version)) 
[17:38:33.108]                             version <- utils::packageVersion("future")
[17:38:33.108]                         }
[17:38:33.108]                         else {
[17:38:33.108]                           version <- NULL
[17:38:33.108]                         }
[17:38:33.108]                         if (!has_future || version < "1.8.0") {
[17:38:33.108]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:33.108]                             "", base::R.version$version.string), 
[17:38:33.108]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:33.108]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:33.108]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:33.108]                               "release", "version")], collapse = " "), 
[17:38:33.108]                             hostname = base::Sys.info()[["nodename"]])
[17:38:33.108]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:33.108]                             info)
[17:38:33.108]                           info <- base::paste(info, collapse = "; ")
[17:38:33.108]                           if (!has_future) {
[17:38:33.108]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:33.108]                               info)
[17:38:33.108]                           }
[17:38:33.108]                           else {
[17:38:33.108]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:33.108]                               info, version)
[17:38:33.108]                           }
[17:38:33.108]                           base::stop(msg)
[17:38:33.108]                         }
[17:38:33.108]                       })
[17:38:33.108]                     }
[17:38:33.108]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:33.108]                     base::options(mc.cores = 1L)
[17:38:33.108]                   }
[17:38:33.108]                   ...future.strategy.old <- future::plan("list")
[17:38:33.108]                   options(future.plan = NULL)
[17:38:33.108]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:33.108]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:33.108]                 }
[17:38:33.108]                 ...future.workdir <- getwd()
[17:38:33.108]             }
[17:38:33.108]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:33.108]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:33.108]         }
[17:38:33.108]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:33.108]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:33.108]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:33.108]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:33.108]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:33.108]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:33.108]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:33.108]             base::names(...future.oldOptions))
[17:38:33.108]     }
[17:38:33.108]     if (FALSE) {
[17:38:33.108]     }
[17:38:33.108]     else {
[17:38:33.108]         if (TRUE) {
[17:38:33.108]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:33.108]                 open = "w")
[17:38:33.108]         }
[17:38:33.108]         else {
[17:38:33.108]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:33.108]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:33.108]         }
[17:38:33.108]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:33.108]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:33.108]             base::sink(type = "output", split = FALSE)
[17:38:33.108]             base::close(...future.stdout)
[17:38:33.108]         }, add = TRUE)
[17:38:33.108]     }
[17:38:33.108]     ...future.frame <- base::sys.nframe()
[17:38:33.108]     ...future.conditions <- base::list()
[17:38:33.108]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:33.108]     if (FALSE) {
[17:38:33.108]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:33.108]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:33.108]     }
[17:38:33.108]     ...future.result <- base::tryCatch({
[17:38:33.108]         base::withCallingHandlers({
[17:38:33.108]             ...future.value <- base::withVisible(base::local({
[17:38:33.108]                 withCallingHandlers({
[17:38:33.108]                   {
[17:38:33.108]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:33.108]                     if (!identical(...future.globals.maxSize.org, 
[17:38:33.108]                       ...future.globals.maxSize)) {
[17:38:33.108]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:33.108]                       on.exit(options(oopts), add = TRUE)
[17:38:33.108]                     }
[17:38:33.108]                     {
[17:38:33.108]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:33.108]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:38:33.108]                         USE.NAMES = FALSE)
[17:38:33.108]                       do.call(mapply, args = args)
[17:38:33.108]                     }
[17:38:33.108]                   }
[17:38:33.108]                 }, immediateCondition = function(cond) {
[17:38:33.108]                   save_rds <- function (object, pathname, ...) 
[17:38:33.108]                   {
[17:38:33.108]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:33.108]                     if (file_test("-f", pathname_tmp)) {
[17:38:33.108]                       fi_tmp <- file.info(pathname_tmp)
[17:38:33.108]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:33.108]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:33.108]                         fi_tmp[["mtime"]])
[17:38:33.108]                     }
[17:38:33.108]                     tryCatch({
[17:38:33.108]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:33.108]                     }, error = function(ex) {
[17:38:33.108]                       msg <- conditionMessage(ex)
[17:38:33.108]                       fi_tmp <- file.info(pathname_tmp)
[17:38:33.108]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:33.108]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:33.108]                         fi_tmp[["mtime"]], msg)
[17:38:33.108]                       ex$message <- msg
[17:38:33.108]                       stop(ex)
[17:38:33.108]                     })
[17:38:33.108]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:33.108]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:33.108]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:33.108]                       fi_tmp <- file.info(pathname_tmp)
[17:38:33.108]                       fi <- file.info(pathname)
[17:38:33.108]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:33.108]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:33.108]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:33.108]                         fi[["size"]], fi[["mtime"]])
[17:38:33.108]                       stop(msg)
[17:38:33.108]                     }
[17:38:33.108]                     invisible(pathname)
[17:38:33.108]                   }
[17:38:33.108]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:33.108]                     rootPath = tempdir()) 
[17:38:33.108]                   {
[17:38:33.108]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:33.108]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:33.108]                       tmpdir = path, fileext = ".rds")
[17:38:33.108]                     save_rds(obj, file)
[17:38:33.108]                   }
[17:38:33.108]                   saveImmediateCondition(cond, path = "/tmp/RtmpBrP0ee/.future/immediateConditions")
[17:38:33.108]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:33.108]                   {
[17:38:33.108]                     inherits <- base::inherits
[17:38:33.108]                     invokeRestart <- base::invokeRestart
[17:38:33.108]                     is.null <- base::is.null
[17:38:33.108]                     muffled <- FALSE
[17:38:33.108]                     if (inherits(cond, "message")) {
[17:38:33.108]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:33.108]                       if (muffled) 
[17:38:33.108]                         invokeRestart("muffleMessage")
[17:38:33.108]                     }
[17:38:33.108]                     else if (inherits(cond, "warning")) {
[17:38:33.108]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:33.108]                       if (muffled) 
[17:38:33.108]                         invokeRestart("muffleWarning")
[17:38:33.108]                     }
[17:38:33.108]                     else if (inherits(cond, "condition")) {
[17:38:33.108]                       if (!is.null(pattern)) {
[17:38:33.108]                         computeRestarts <- base::computeRestarts
[17:38:33.108]                         grepl <- base::grepl
[17:38:33.108]                         restarts <- computeRestarts(cond)
[17:38:33.108]                         for (restart in restarts) {
[17:38:33.108]                           name <- restart$name
[17:38:33.108]                           if (is.null(name)) 
[17:38:33.108]                             next
[17:38:33.108]                           if (!grepl(pattern, name)) 
[17:38:33.108]                             next
[17:38:33.108]                           invokeRestart(restart)
[17:38:33.108]                           muffled <- TRUE
[17:38:33.108]                           break
[17:38:33.108]                         }
[17:38:33.108]                       }
[17:38:33.108]                     }
[17:38:33.108]                     invisible(muffled)
[17:38:33.108]                   }
[17:38:33.108]                   muffleCondition(cond)
[17:38:33.108]                 })
[17:38:33.108]             }))
[17:38:33.108]             future::FutureResult(value = ...future.value$value, 
[17:38:33.108]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:33.108]                   ...future.rng), globalenv = if (FALSE) 
[17:38:33.108]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:33.108]                     ...future.globalenv.names))
[17:38:33.108]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:33.108]         }, condition = base::local({
[17:38:33.108]             c <- base::c
[17:38:33.108]             inherits <- base::inherits
[17:38:33.108]             invokeRestart <- base::invokeRestart
[17:38:33.108]             length <- base::length
[17:38:33.108]             list <- base::list
[17:38:33.108]             seq.int <- base::seq.int
[17:38:33.108]             signalCondition <- base::signalCondition
[17:38:33.108]             sys.calls <- base::sys.calls
[17:38:33.108]             `[[` <- base::`[[`
[17:38:33.108]             `+` <- base::`+`
[17:38:33.108]             `<<-` <- base::`<<-`
[17:38:33.108]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:33.108]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:33.108]                   3L)]
[17:38:33.108]             }
[17:38:33.108]             function(cond) {
[17:38:33.108]                 is_error <- inherits(cond, "error")
[17:38:33.108]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:33.108]                   NULL)
[17:38:33.108]                 if (is_error) {
[17:38:33.108]                   sessionInformation <- function() {
[17:38:33.108]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:33.108]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:33.108]                       search = base::search(), system = base::Sys.info())
[17:38:33.108]                   }
[17:38:33.108]                   ...future.conditions[[length(...future.conditions) + 
[17:38:33.108]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:33.108]                     cond$call), session = sessionInformation(), 
[17:38:33.108]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:33.108]                   signalCondition(cond)
[17:38:33.108]                 }
[17:38:33.108]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:33.108]                 "immediateCondition"))) {
[17:38:33.108]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:33.108]                   ...future.conditions[[length(...future.conditions) + 
[17:38:33.108]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:33.108]                   if (TRUE && !signal) {
[17:38:33.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:33.108]                     {
[17:38:33.108]                       inherits <- base::inherits
[17:38:33.108]                       invokeRestart <- base::invokeRestart
[17:38:33.108]                       is.null <- base::is.null
[17:38:33.108]                       muffled <- FALSE
[17:38:33.108]                       if (inherits(cond, "message")) {
[17:38:33.108]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:33.108]                         if (muffled) 
[17:38:33.108]                           invokeRestart("muffleMessage")
[17:38:33.108]                       }
[17:38:33.108]                       else if (inherits(cond, "warning")) {
[17:38:33.108]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:33.108]                         if (muffled) 
[17:38:33.108]                           invokeRestart("muffleWarning")
[17:38:33.108]                       }
[17:38:33.108]                       else if (inherits(cond, "condition")) {
[17:38:33.108]                         if (!is.null(pattern)) {
[17:38:33.108]                           computeRestarts <- base::computeRestarts
[17:38:33.108]                           grepl <- base::grepl
[17:38:33.108]                           restarts <- computeRestarts(cond)
[17:38:33.108]                           for (restart in restarts) {
[17:38:33.108]                             name <- restart$name
[17:38:33.108]                             if (is.null(name)) 
[17:38:33.108]                               next
[17:38:33.108]                             if (!grepl(pattern, name)) 
[17:38:33.108]                               next
[17:38:33.108]                             invokeRestart(restart)
[17:38:33.108]                             muffled <- TRUE
[17:38:33.108]                             break
[17:38:33.108]                           }
[17:38:33.108]                         }
[17:38:33.108]                       }
[17:38:33.108]                       invisible(muffled)
[17:38:33.108]                     }
[17:38:33.108]                     muffleCondition(cond, pattern = "^muffle")
[17:38:33.108]                   }
[17:38:33.108]                 }
[17:38:33.108]                 else {
[17:38:33.108]                   if (TRUE) {
[17:38:33.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:33.108]                     {
[17:38:33.108]                       inherits <- base::inherits
[17:38:33.108]                       invokeRestart <- base::invokeRestart
[17:38:33.108]                       is.null <- base::is.null
[17:38:33.108]                       muffled <- FALSE
[17:38:33.108]                       if (inherits(cond, "message")) {
[17:38:33.108]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:33.108]                         if (muffled) 
[17:38:33.108]                           invokeRestart("muffleMessage")
[17:38:33.108]                       }
[17:38:33.108]                       else if (inherits(cond, "warning")) {
[17:38:33.108]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:33.108]                         if (muffled) 
[17:38:33.108]                           invokeRestart("muffleWarning")
[17:38:33.108]                       }
[17:38:33.108]                       else if (inherits(cond, "condition")) {
[17:38:33.108]                         if (!is.null(pattern)) {
[17:38:33.108]                           computeRestarts <- base::computeRestarts
[17:38:33.108]                           grepl <- base::grepl
[17:38:33.108]                           restarts <- computeRestarts(cond)
[17:38:33.108]                           for (restart in restarts) {
[17:38:33.108]                             name <- restart$name
[17:38:33.108]                             if (is.null(name)) 
[17:38:33.108]                               next
[17:38:33.108]                             if (!grepl(pattern, name)) 
[17:38:33.108]                               next
[17:38:33.108]                             invokeRestart(restart)
[17:38:33.108]                             muffled <- TRUE
[17:38:33.108]                             break
[17:38:33.108]                           }
[17:38:33.108]                         }
[17:38:33.108]                       }
[17:38:33.108]                       invisible(muffled)
[17:38:33.108]                     }
[17:38:33.108]                     muffleCondition(cond, pattern = "^muffle")
[17:38:33.108]                   }
[17:38:33.108]                 }
[17:38:33.108]             }
[17:38:33.108]         }))
[17:38:33.108]     }, error = function(ex) {
[17:38:33.108]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:33.108]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:33.108]                 ...future.rng), started = ...future.startTime, 
[17:38:33.108]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:33.108]             version = "1.8"), class = "FutureResult")
[17:38:33.108]     }, finally = {
[17:38:33.108]         if (!identical(...future.workdir, getwd())) 
[17:38:33.108]             setwd(...future.workdir)
[17:38:33.108]         {
[17:38:33.108]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:33.108]                 ...future.oldOptions$nwarnings <- NULL
[17:38:33.108]             }
[17:38:33.108]             base::options(...future.oldOptions)
[17:38:33.108]             if (.Platform$OS.type == "windows") {
[17:38:33.108]                 old_names <- names(...future.oldEnvVars)
[17:38:33.108]                 envs <- base::Sys.getenv()
[17:38:33.108]                 names <- names(envs)
[17:38:33.108]                 common <- intersect(names, old_names)
[17:38:33.108]                 added <- setdiff(names, old_names)
[17:38:33.108]                 removed <- setdiff(old_names, names)
[17:38:33.108]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:33.108]                   envs[common]]
[17:38:33.108]                 NAMES <- toupper(changed)
[17:38:33.108]                 args <- list()
[17:38:33.108]                 for (kk in seq_along(NAMES)) {
[17:38:33.108]                   name <- changed[[kk]]
[17:38:33.108]                   NAME <- NAMES[[kk]]
[17:38:33.108]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:33.108]                     next
[17:38:33.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:33.108]                 }
[17:38:33.108]                 NAMES <- toupper(added)
[17:38:33.108]                 for (kk in seq_along(NAMES)) {
[17:38:33.108]                   name <- added[[kk]]
[17:38:33.108]                   NAME <- NAMES[[kk]]
[17:38:33.108]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:33.108]                     next
[17:38:33.108]                   args[[name]] <- ""
[17:38:33.108]                 }
[17:38:33.108]                 NAMES <- toupper(removed)
[17:38:33.108]                 for (kk in seq_along(NAMES)) {
[17:38:33.108]                   name <- removed[[kk]]
[17:38:33.108]                   NAME <- NAMES[[kk]]
[17:38:33.108]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:33.108]                     next
[17:38:33.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:33.108]                 }
[17:38:33.108]                 if (length(args) > 0) 
[17:38:33.108]                   base::do.call(base::Sys.setenv, args = args)
[17:38:33.108]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:33.108]             }
[17:38:33.108]             else {
[17:38:33.108]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:33.108]             }
[17:38:33.108]             {
[17:38:33.108]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:33.108]                   0L) {
[17:38:33.108]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:33.108]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:33.108]                   base::options(opts)
[17:38:33.108]                 }
[17:38:33.108]                 {
[17:38:33.108]                   {
[17:38:33.108]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:33.108]                     NULL
[17:38:33.108]                   }
[17:38:33.108]                   options(future.plan = NULL)
[17:38:33.108]                   if (is.na(NA_character_)) 
[17:38:33.108]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:33.108]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:33.108]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:33.108]                     .init = FALSE)
[17:38:33.108]                 }
[17:38:33.108]             }
[17:38:33.108]         }
[17:38:33.108]     })
[17:38:33.108]     if (TRUE) {
[17:38:33.108]         base::sink(type = "output", split = FALSE)
[17:38:33.108]         if (TRUE) {
[17:38:33.108]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:33.108]         }
[17:38:33.108]         else {
[17:38:33.108]             ...future.result["stdout"] <- base::list(NULL)
[17:38:33.108]         }
[17:38:33.108]         base::close(...future.stdout)
[17:38:33.108]         ...future.stdout <- NULL
[17:38:33.108]     }
[17:38:33.108]     ...future.result$conditions <- ...future.conditions
[17:38:33.108]     ...future.result$finished <- base::Sys.time()
[17:38:33.108]     ...future.result
[17:38:33.108] }
[17:38:33.110] assign_globals() ...
[17:38:33.110] List of 5
[17:38:33.110]  $ ...future.FUN            :function (x, y)  
[17:38:33.110]  $ MoreArgs                 : NULL
[17:38:33.110]  $ ...future.elements_ii    :List of 2
[17:38:33.110]   ..$ :List of 1
[17:38:33.110]   .. ..$ : int 1
[17:38:33.110]   ..$ :List of 1
[17:38:33.110]   .. ..$ : int 0
[17:38:33.110]  $ ...future.seeds_ii       : NULL
[17:38:33.110]  $ ...future.globals.maxSize: NULL
[17:38:33.110]  - attr(*, "where")=List of 5
[17:38:33.110]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:33.110]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:38:33.110]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:33.110]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:33.110]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:33.110]  - attr(*, "resolved")= logi FALSE
[17:38:33.110]  - attr(*, "total_size")= num 6368
[17:38:33.110]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:33.110]  - attr(*, "already-done")= logi TRUE
[17:38:33.115] - reassign environment for ‘...future.FUN’
[17:38:33.115] - copied ‘...future.FUN’ to environment
[17:38:33.115] - copied ‘MoreArgs’ to environment
[17:38:33.116] - copied ‘...future.elements_ii’ to environment
[17:38:33.116] - copied ‘...future.seeds_ii’ to environment
[17:38:33.116] - copied ‘...future.globals.maxSize’ to environment
[17:38:33.116] assign_globals() ... done
[17:38:33.118] requestCore(): workers = 2
[17:38:33.120] MulticoreFuture started
[17:38:33.121] - Launch lazy future ... done
[17:38:33.122] plan(): Setting new future strategy stack:
[17:38:33.121] run() for ‘MulticoreFuture’ ... done
[17:38:33.122] Created future:
[17:38:33.122] List of future strategies:
[17:38:33.122] 1. sequential:
[17:38:33.122]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:33.122]    - tweaked: FALSE
[17:38:33.122]    - call: NULL
[17:38:33.124] plan(): nbrOfWorkers() = 1
[17:38:33.122] MulticoreFuture:
[17:38:33.122] Label: ‘future_mapply-1’
[17:38:33.122] Expression:
[17:38:33.122] {
[17:38:33.122]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:33.122]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:33.122]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:33.122]         on.exit(options(oopts), add = TRUE)
[17:38:33.122]     }
[17:38:33.122]     {
[17:38:33.122]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:33.122]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:38:33.122]         do.call(mapply, args = args)
[17:38:33.122]     }
[17:38:33.122] }
[17:38:33.122] Lazy evaluation: FALSE
[17:38:33.122] Asynchronous evaluation: TRUE
[17:38:33.122] Local evaluation: TRUE
[17:38:33.122] Environment: R_GlobalEnv
[17:38:33.122] Capture standard output: TRUE
[17:38:33.122] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:33.122] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:33.122] Packages: <none>
[17:38:33.122] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:33.122] Resolved: FALSE
[17:38:33.122] Value: <not collected>
[17:38:33.122] Conditions captured: <none>
[17:38:33.122] Early signaling: FALSE
[17:38:33.122] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:33.122] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:33.136] Chunk #1 of 2 ... DONE
[17:38:33.137] Chunk #2 of 2 ...
[17:38:33.137]  - Finding globals in '...' for chunk #2 ...
[17:38:33.137] getGlobalsAndPackages() ...
[17:38:33.138] Searching for globals...
[17:38:33.139] 
[17:38:33.139] Searching for globals ... DONE
[17:38:33.139] - globals: [0] <none>
[17:38:33.139] getGlobalsAndPackages() ... DONE
[17:38:33.139]    + additional globals found: [n=0] 
[17:38:33.139]    + additional namespaces needed: [n=0] 
[17:38:33.140]  - Finding globals in '...' for chunk #2 ... DONE
[17:38:33.140]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:33.140]  - seeds: <none>
[17:38:33.140]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:33.140] getGlobalsAndPackages() ...
[17:38:33.140] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:33.141] Resolving globals: FALSE
[17:38:33.142] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:38:33.143] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:38:33.143] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:33.143] 
[17:38:33.143] getGlobalsAndPackages() ... DONE
[17:38:33.144] run() for ‘Future’ ...
[17:38:33.144] - state: ‘created’
[17:38:33.144] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:33.149] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:33.150] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:33.150]   - Field: ‘label’
[17:38:33.150]   - Field: ‘local’
[17:38:33.150]   - Field: ‘owner’
[17:38:33.150]   - Field: ‘envir’
[17:38:33.151]   - Field: ‘workers’
[17:38:33.151]   - Field: ‘packages’
[17:38:33.151]   - Field: ‘gc’
[17:38:33.151]   - Field: ‘job’
[17:38:33.151]   - Field: ‘conditions’
[17:38:33.151]   - Field: ‘expr’
[17:38:33.151]   - Field: ‘uuid’
[17:38:33.152]   - Field: ‘seed’
[17:38:33.152]   - Field: ‘version’
[17:38:33.152]   - Field: ‘result’
[17:38:33.152]   - Field: ‘asynchronous’
[17:38:33.152]   - Field: ‘calls’
[17:38:33.152]   - Field: ‘globals’
[17:38:33.152]   - Field: ‘stdout’
[17:38:33.153]   - Field: ‘earlySignal’
[17:38:33.153]   - Field: ‘lazy’
[17:38:33.153]   - Field: ‘state’
[17:38:33.153] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:33.153] - Launch lazy future ...
[17:38:33.153] Packages needed by the future expression (n = 0): <none>
[17:38:33.154] Packages needed by future strategies (n = 0): <none>
[17:38:33.154] {
[17:38:33.154]     {
[17:38:33.154]         {
[17:38:33.154]             ...future.startTime <- base::Sys.time()
[17:38:33.154]             {
[17:38:33.154]                 {
[17:38:33.154]                   {
[17:38:33.154]                     {
[17:38:33.154]                       base::local({
[17:38:33.154]                         has_future <- base::requireNamespace("future", 
[17:38:33.154]                           quietly = TRUE)
[17:38:33.154]                         if (has_future) {
[17:38:33.154]                           ns <- base::getNamespace("future")
[17:38:33.154]                           version <- ns[[".package"]][["version"]]
[17:38:33.154]                           if (is.null(version)) 
[17:38:33.154]                             version <- utils::packageVersion("future")
[17:38:33.154]                         }
[17:38:33.154]                         else {
[17:38:33.154]                           version <- NULL
[17:38:33.154]                         }
[17:38:33.154]                         if (!has_future || version < "1.8.0") {
[17:38:33.154]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:33.154]                             "", base::R.version$version.string), 
[17:38:33.154]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:33.154]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:33.154]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:33.154]                               "release", "version")], collapse = " "), 
[17:38:33.154]                             hostname = base::Sys.info()[["nodename"]])
[17:38:33.154]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:33.154]                             info)
[17:38:33.154]                           info <- base::paste(info, collapse = "; ")
[17:38:33.154]                           if (!has_future) {
[17:38:33.154]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:33.154]                               info)
[17:38:33.154]                           }
[17:38:33.154]                           else {
[17:38:33.154]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:33.154]                               info, version)
[17:38:33.154]                           }
[17:38:33.154]                           base::stop(msg)
[17:38:33.154]                         }
[17:38:33.154]                       })
[17:38:33.154]                     }
[17:38:33.154]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:33.154]                     base::options(mc.cores = 1L)
[17:38:33.154]                   }
[17:38:33.154]                   ...future.strategy.old <- future::plan("list")
[17:38:33.154]                   options(future.plan = NULL)
[17:38:33.154]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:33.154]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:33.154]                 }
[17:38:33.154]                 ...future.workdir <- getwd()
[17:38:33.154]             }
[17:38:33.154]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:33.154]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:33.154]         }
[17:38:33.154]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:33.154]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:33.154]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:33.154]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:33.154]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:33.154]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:33.154]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:33.154]             base::names(...future.oldOptions))
[17:38:33.154]     }
[17:38:33.154]     if (FALSE) {
[17:38:33.154]     }
[17:38:33.154]     else {
[17:38:33.154]         if (TRUE) {
[17:38:33.154]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:33.154]                 open = "w")
[17:38:33.154]         }
[17:38:33.154]         else {
[17:38:33.154]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:33.154]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:33.154]         }
[17:38:33.154]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:33.154]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:33.154]             base::sink(type = "output", split = FALSE)
[17:38:33.154]             base::close(...future.stdout)
[17:38:33.154]         }, add = TRUE)
[17:38:33.154]     }
[17:38:33.154]     ...future.frame <- base::sys.nframe()
[17:38:33.154]     ...future.conditions <- base::list()
[17:38:33.154]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:33.154]     if (FALSE) {
[17:38:33.154]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:33.154]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:33.154]     }
[17:38:33.154]     ...future.result <- base::tryCatch({
[17:38:33.154]         base::withCallingHandlers({
[17:38:33.154]             ...future.value <- base::withVisible(base::local({
[17:38:33.154]                 withCallingHandlers({
[17:38:33.154]                   {
[17:38:33.154]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:33.154]                     if (!identical(...future.globals.maxSize.org, 
[17:38:33.154]                       ...future.globals.maxSize)) {
[17:38:33.154]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:33.154]                       on.exit(options(oopts), add = TRUE)
[17:38:33.154]                     }
[17:38:33.154]                     {
[17:38:33.154]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:33.154]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:38:33.154]                         USE.NAMES = FALSE)
[17:38:33.154]                       do.call(mapply, args = args)
[17:38:33.154]                     }
[17:38:33.154]                   }
[17:38:33.154]                 }, immediateCondition = function(cond) {
[17:38:33.154]                   save_rds <- function (object, pathname, ...) 
[17:38:33.154]                   {
[17:38:33.154]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:33.154]                     if (file_test("-f", pathname_tmp)) {
[17:38:33.154]                       fi_tmp <- file.info(pathname_tmp)
[17:38:33.154]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:33.154]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:33.154]                         fi_tmp[["mtime"]])
[17:38:33.154]                     }
[17:38:33.154]                     tryCatch({
[17:38:33.154]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:33.154]                     }, error = function(ex) {
[17:38:33.154]                       msg <- conditionMessage(ex)
[17:38:33.154]                       fi_tmp <- file.info(pathname_tmp)
[17:38:33.154]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:33.154]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:33.154]                         fi_tmp[["mtime"]], msg)
[17:38:33.154]                       ex$message <- msg
[17:38:33.154]                       stop(ex)
[17:38:33.154]                     })
[17:38:33.154]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:33.154]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:33.154]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:33.154]                       fi_tmp <- file.info(pathname_tmp)
[17:38:33.154]                       fi <- file.info(pathname)
[17:38:33.154]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:33.154]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:33.154]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:33.154]                         fi[["size"]], fi[["mtime"]])
[17:38:33.154]                       stop(msg)
[17:38:33.154]                     }
[17:38:33.154]                     invisible(pathname)
[17:38:33.154]                   }
[17:38:33.154]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:33.154]                     rootPath = tempdir()) 
[17:38:33.154]                   {
[17:38:33.154]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:33.154]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:33.154]                       tmpdir = path, fileext = ".rds")
[17:38:33.154]                     save_rds(obj, file)
[17:38:33.154]                   }
[17:38:33.154]                   saveImmediateCondition(cond, path = "/tmp/RtmpBrP0ee/.future/immediateConditions")
[17:38:33.154]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:33.154]                   {
[17:38:33.154]                     inherits <- base::inherits
[17:38:33.154]                     invokeRestart <- base::invokeRestart
[17:38:33.154]                     is.null <- base::is.null
[17:38:33.154]                     muffled <- FALSE
[17:38:33.154]                     if (inherits(cond, "message")) {
[17:38:33.154]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:33.154]                       if (muffled) 
[17:38:33.154]                         invokeRestart("muffleMessage")
[17:38:33.154]                     }
[17:38:33.154]                     else if (inherits(cond, "warning")) {
[17:38:33.154]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:33.154]                       if (muffled) 
[17:38:33.154]                         invokeRestart("muffleWarning")
[17:38:33.154]                     }
[17:38:33.154]                     else if (inherits(cond, "condition")) {
[17:38:33.154]                       if (!is.null(pattern)) {
[17:38:33.154]                         computeRestarts <- base::computeRestarts
[17:38:33.154]                         grepl <- base::grepl
[17:38:33.154]                         restarts <- computeRestarts(cond)
[17:38:33.154]                         for (restart in restarts) {
[17:38:33.154]                           name <- restart$name
[17:38:33.154]                           if (is.null(name)) 
[17:38:33.154]                             next
[17:38:33.154]                           if (!grepl(pattern, name)) 
[17:38:33.154]                             next
[17:38:33.154]                           invokeRestart(restart)
[17:38:33.154]                           muffled <- TRUE
[17:38:33.154]                           break
[17:38:33.154]                         }
[17:38:33.154]                       }
[17:38:33.154]                     }
[17:38:33.154]                     invisible(muffled)
[17:38:33.154]                   }
[17:38:33.154]                   muffleCondition(cond)
[17:38:33.154]                 })
[17:38:33.154]             }))
[17:38:33.154]             future::FutureResult(value = ...future.value$value, 
[17:38:33.154]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:33.154]                   ...future.rng), globalenv = if (FALSE) 
[17:38:33.154]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:33.154]                     ...future.globalenv.names))
[17:38:33.154]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:33.154]         }, condition = base::local({
[17:38:33.154]             c <- base::c
[17:38:33.154]             inherits <- base::inherits
[17:38:33.154]             invokeRestart <- base::invokeRestart
[17:38:33.154]             length <- base::length
[17:38:33.154]             list <- base::list
[17:38:33.154]             seq.int <- base::seq.int
[17:38:33.154]             signalCondition <- base::signalCondition
[17:38:33.154]             sys.calls <- base::sys.calls
[17:38:33.154]             `[[` <- base::`[[`
[17:38:33.154]             `+` <- base::`+`
[17:38:33.154]             `<<-` <- base::`<<-`
[17:38:33.154]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:33.154]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:33.154]                   3L)]
[17:38:33.154]             }
[17:38:33.154]             function(cond) {
[17:38:33.154]                 is_error <- inherits(cond, "error")
[17:38:33.154]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:33.154]                   NULL)
[17:38:33.154]                 if (is_error) {
[17:38:33.154]                   sessionInformation <- function() {
[17:38:33.154]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:33.154]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:33.154]                       search = base::search(), system = base::Sys.info())
[17:38:33.154]                   }
[17:38:33.154]                   ...future.conditions[[length(...future.conditions) + 
[17:38:33.154]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:33.154]                     cond$call), session = sessionInformation(), 
[17:38:33.154]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:33.154]                   signalCondition(cond)
[17:38:33.154]                 }
[17:38:33.154]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:33.154]                 "immediateCondition"))) {
[17:38:33.154]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:33.154]                   ...future.conditions[[length(...future.conditions) + 
[17:38:33.154]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:33.154]                   if (TRUE && !signal) {
[17:38:33.154]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:33.154]                     {
[17:38:33.154]                       inherits <- base::inherits
[17:38:33.154]                       invokeRestart <- base::invokeRestart
[17:38:33.154]                       is.null <- base::is.null
[17:38:33.154]                       muffled <- FALSE
[17:38:33.154]                       if (inherits(cond, "message")) {
[17:38:33.154]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:33.154]                         if (muffled) 
[17:38:33.154]                           invokeRestart("muffleMessage")
[17:38:33.154]                       }
[17:38:33.154]                       else if (inherits(cond, "warning")) {
[17:38:33.154]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:33.154]                         if (muffled) 
[17:38:33.154]                           invokeRestart("muffleWarning")
[17:38:33.154]                       }
[17:38:33.154]                       else if (inherits(cond, "condition")) {
[17:38:33.154]                         if (!is.null(pattern)) {
[17:38:33.154]                           computeRestarts <- base::computeRestarts
[17:38:33.154]                           grepl <- base::grepl
[17:38:33.154]                           restarts <- computeRestarts(cond)
[17:38:33.154]                           for (restart in restarts) {
[17:38:33.154]                             name <- restart$name
[17:38:33.154]                             if (is.null(name)) 
[17:38:33.154]                               next
[17:38:33.154]                             if (!grepl(pattern, name)) 
[17:38:33.154]                               next
[17:38:33.154]                             invokeRestart(restart)
[17:38:33.154]                             muffled <- TRUE
[17:38:33.154]                             break
[17:38:33.154]                           }
[17:38:33.154]                         }
[17:38:33.154]                       }
[17:38:33.154]                       invisible(muffled)
[17:38:33.154]                     }
[17:38:33.154]                     muffleCondition(cond, pattern = "^muffle")
[17:38:33.154]                   }
[17:38:33.154]                 }
[17:38:33.154]                 else {
[17:38:33.154]                   if (TRUE) {
[17:38:33.154]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:33.154]                     {
[17:38:33.154]                       inherits <- base::inherits
[17:38:33.154]                       invokeRestart <- base::invokeRestart
[17:38:33.154]                       is.null <- base::is.null
[17:38:33.154]                       muffled <- FALSE
[17:38:33.154]                       if (inherits(cond, "message")) {
[17:38:33.154]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:33.154]                         if (muffled) 
[17:38:33.154]                           invokeRestart("muffleMessage")
[17:38:33.154]                       }
[17:38:33.154]                       else if (inherits(cond, "warning")) {
[17:38:33.154]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:33.154]                         if (muffled) 
[17:38:33.154]                           invokeRestart("muffleWarning")
[17:38:33.154]                       }
[17:38:33.154]                       else if (inherits(cond, "condition")) {
[17:38:33.154]                         if (!is.null(pattern)) {
[17:38:33.154]                           computeRestarts <- base::computeRestarts
[17:38:33.154]                           grepl <- base::grepl
[17:38:33.154]                           restarts <- computeRestarts(cond)
[17:38:33.154]                           for (restart in restarts) {
[17:38:33.154]                             name <- restart$name
[17:38:33.154]                             if (is.null(name)) 
[17:38:33.154]                               next
[17:38:33.154]                             if (!grepl(pattern, name)) 
[17:38:33.154]                               next
[17:38:33.154]                             invokeRestart(restart)
[17:38:33.154]                             muffled <- TRUE
[17:38:33.154]                             break
[17:38:33.154]                           }
[17:38:33.154]                         }
[17:38:33.154]                       }
[17:38:33.154]                       invisible(muffled)
[17:38:33.154]                     }
[17:38:33.154]                     muffleCondition(cond, pattern = "^muffle")
[17:38:33.154]                   }
[17:38:33.154]                 }
[17:38:33.154]             }
[17:38:33.154]         }))
[17:38:33.154]     }, error = function(ex) {
[17:38:33.154]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:33.154]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:33.154]                 ...future.rng), started = ...future.startTime, 
[17:38:33.154]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:33.154]             version = "1.8"), class = "FutureResult")
[17:38:33.154]     }, finally = {
[17:38:33.154]         if (!identical(...future.workdir, getwd())) 
[17:38:33.154]             setwd(...future.workdir)
[17:38:33.154]         {
[17:38:33.154]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:33.154]                 ...future.oldOptions$nwarnings <- NULL
[17:38:33.154]             }
[17:38:33.154]             base::options(...future.oldOptions)
[17:38:33.154]             if (.Platform$OS.type == "windows") {
[17:38:33.154]                 old_names <- names(...future.oldEnvVars)
[17:38:33.154]                 envs <- base::Sys.getenv()
[17:38:33.154]                 names <- names(envs)
[17:38:33.154]                 common <- intersect(names, old_names)
[17:38:33.154]                 added <- setdiff(names, old_names)
[17:38:33.154]                 removed <- setdiff(old_names, names)
[17:38:33.154]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:33.154]                   envs[common]]
[17:38:33.154]                 NAMES <- toupper(changed)
[17:38:33.154]                 args <- list()
[17:38:33.154]                 for (kk in seq_along(NAMES)) {
[17:38:33.154]                   name <- changed[[kk]]
[17:38:33.154]                   NAME <- NAMES[[kk]]
[17:38:33.154]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:33.154]                     next
[17:38:33.154]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:33.154]                 }
[17:38:33.154]                 NAMES <- toupper(added)
[17:38:33.154]                 for (kk in seq_along(NAMES)) {
[17:38:33.154]                   name <- added[[kk]]
[17:38:33.154]                   NAME <- NAMES[[kk]]
[17:38:33.154]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:33.154]                     next
[17:38:33.154]                   args[[name]] <- ""
[17:38:33.154]                 }
[17:38:33.154]                 NAMES <- toupper(removed)
[17:38:33.154]                 for (kk in seq_along(NAMES)) {
[17:38:33.154]                   name <- removed[[kk]]
[17:38:33.154]                   NAME <- NAMES[[kk]]
[17:38:33.154]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:33.154]                     next
[17:38:33.154]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:33.154]                 }
[17:38:33.154]                 if (length(args) > 0) 
[17:38:33.154]                   base::do.call(base::Sys.setenv, args = args)
[17:38:33.154]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:33.154]             }
[17:38:33.154]             else {
[17:38:33.154]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:33.154]             }
[17:38:33.154]             {
[17:38:33.154]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:33.154]                   0L) {
[17:38:33.154]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:33.154]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:33.154]                   base::options(opts)
[17:38:33.154]                 }
[17:38:33.154]                 {
[17:38:33.154]                   {
[17:38:33.154]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:33.154]                     NULL
[17:38:33.154]                   }
[17:38:33.154]                   options(future.plan = NULL)
[17:38:33.154]                   if (is.na(NA_character_)) 
[17:38:33.154]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:33.154]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:33.154]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:33.154]                     .init = FALSE)
[17:38:33.154]                 }
[17:38:33.154]             }
[17:38:33.154]         }
[17:38:33.154]     })
[17:38:33.154]     if (TRUE) {
[17:38:33.154]         base::sink(type = "output", split = FALSE)
[17:38:33.154]         if (TRUE) {
[17:38:33.154]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:33.154]         }
[17:38:33.154]         else {
[17:38:33.154]             ...future.result["stdout"] <- base::list(NULL)
[17:38:33.154]         }
[17:38:33.154]         base::close(...future.stdout)
[17:38:33.154]         ...future.stdout <- NULL
[17:38:33.154]     }
[17:38:33.154]     ...future.result$conditions <- ...future.conditions
[17:38:33.154]     ...future.result$finished <- base::Sys.time()
[17:38:33.154]     ...future.result
[17:38:33.154] }
[17:38:33.158] assign_globals() ...
[17:38:33.158] List of 5
[17:38:33.158]  $ ...future.FUN            :function (x, y)  
[17:38:33.158]  $ MoreArgs                 : NULL
[17:38:33.158]  $ ...future.elements_ii    :List of 2
[17:38:33.158]   ..$ :List of 1
[17:38:33.158]   .. ..$ : int 0
[17:38:33.158]   ..$ :List of 1
[17:38:33.158]   .. ..$ : int 1
[17:38:33.158]  $ ...future.seeds_ii       : NULL
[17:38:33.158]  $ ...future.globals.maxSize: NULL
[17:38:33.158]  - attr(*, "where")=List of 5
[17:38:33.158]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:33.158]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:38:33.158]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:33.158]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:33.158]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:33.158]  - attr(*, "resolved")= logi FALSE
[17:38:33.158]  - attr(*, "total_size")= num 6368
[17:38:33.158]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:33.158]  - attr(*, "already-done")= logi TRUE
[17:38:33.165] - reassign environment for ‘...future.FUN’
[17:38:33.165] - copied ‘...future.FUN’ to environment
[17:38:33.165] - copied ‘MoreArgs’ to environment
[17:38:33.165] - copied ‘...future.elements_ii’ to environment
[17:38:33.165] - copied ‘...future.seeds_ii’ to environment
[17:38:33.166] - copied ‘...future.globals.maxSize’ to environment
[17:38:33.166] assign_globals() ... done
[17:38:33.166] requestCore(): workers = 2
[17:38:33.168] MulticoreFuture started
[17:38:33.169] - Launch lazy future ... done
[17:38:33.169] run() for ‘MulticoreFuture’ ... done
[17:38:33.169] Created future:
[17:38:33.169] plan(): Setting new future strategy stack:
[17:38:33.170] List of future strategies:
[17:38:33.170] 1. sequential:
[17:38:33.170]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:33.170]    - tweaked: FALSE
[17:38:33.170]    - call: NULL
[17:38:33.171] plan(): nbrOfWorkers() = 1
[17:38:33.173] plan(): Setting new future strategy stack:
[17:38:33.173] List of future strategies:
[17:38:33.173] 1. multicore:
[17:38:33.173]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:33.173]    - tweaked: FALSE
[17:38:33.173]    - call: plan(strategy)
[17:38:33.178] plan(): nbrOfWorkers() = 2
[17:38:33.169] MulticoreFuture:
[17:38:33.169] Label: ‘future_mapply-2’
[17:38:33.169] Expression:
[17:38:33.169] {
[17:38:33.169]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:33.169]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:33.169]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:33.169]         on.exit(options(oopts), add = TRUE)
[17:38:33.169]     }
[17:38:33.169]     {
[17:38:33.169]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:33.169]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:38:33.169]         do.call(mapply, args = args)
[17:38:33.169]     }
[17:38:33.169] }
[17:38:33.169] Lazy evaluation: FALSE
[17:38:33.169] Asynchronous evaluation: TRUE
[17:38:33.169] Local evaluation: TRUE
[17:38:33.169] Environment: R_GlobalEnv
[17:38:33.169] Capture standard output: TRUE
[17:38:33.169] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:33.169] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:33.169] Packages: <none>
[17:38:33.169] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:33.169] Resolved: TRUE
[17:38:33.169] Value: <not collected>
[17:38:33.169] Conditions captured: <none>
[17:38:33.169] Early signaling: FALSE
[17:38:33.169] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:33.169] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:33.179] Chunk #2 of 2 ... DONE
[17:38:33.179] Launching 2 futures (chunks) ... DONE
[17:38:33.180] Resolving 2 futures (chunks) ...
[17:38:33.180] resolve() on list ...
[17:38:33.180]  recursive: 0
[17:38:33.180]  length: 2
[17:38:33.180] 
[17:38:33.191] Future #2
[17:38:33.191] result() for MulticoreFuture ...
[17:38:33.192] result() for MulticoreFuture ...
[17:38:33.193] result() for MulticoreFuture ... done
[17:38:33.193] result() for MulticoreFuture ... done
[17:38:33.193] result() for MulticoreFuture ...
[17:38:33.193] result() for MulticoreFuture ... done
[17:38:33.193] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:38:33.194] - nx: 2
[17:38:33.194] - relay: TRUE
[17:38:33.194] - stdout: TRUE
[17:38:33.194] - signal: TRUE
[17:38:33.194] - resignal: FALSE
[17:38:33.194] - force: TRUE
[17:38:33.195] - relayed: [n=2] FALSE, FALSE
[17:38:33.195] - queued futures: [n=2] FALSE, FALSE
[17:38:33.195]  - until=1
[17:38:33.195]  - relaying element #1
[17:38:33.195] - relayed: [n=2] FALSE, FALSE
[17:38:33.195] - queued futures: [n=2] FALSE, TRUE
[17:38:33.196] signalConditionsASAP(NULL, pos=2) ... done
[17:38:33.196]  length: 1 (resolved future 2)
[17:38:33.627] plan(): Setting new future strategy stack:
[17:38:33.627] List of future strategies:
[17:38:33.627] 1. multicore:
[17:38:33.627]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:33.627]    - tweaked: FALSE
[17:38:33.627]    - call: plan(strategy)
[17:38:33.632] plan(): nbrOfWorkers() = 2
[17:38:33.637] Future #1
[17:38:33.638] result() for MulticoreFuture ...
[17:38:33.639] result() for MulticoreFuture ...
[17:38:33.639] result() for MulticoreFuture ... done
[17:38:33.639] result() for MulticoreFuture ... done
[17:38:33.639] result() for MulticoreFuture ...
[17:38:33.639] result() for MulticoreFuture ... done
[17:38:33.640] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:38:33.640] - nx: 2
[17:38:33.640] - relay: TRUE
[17:38:33.640] - stdout: TRUE
[17:38:33.640] - signal: TRUE
[17:38:33.640] - resignal: FALSE
[17:38:33.640] - force: TRUE
[17:38:33.641] - relayed: [n=2] FALSE, FALSE
[17:38:33.641] - queued futures: [n=2] FALSE, TRUE
[17:38:33.641]  - until=1
[17:38:33.641]  - relaying element #1
[17:38:33.641] result() for MulticoreFuture ...
[17:38:33.641] result() for MulticoreFuture ... done
[17:38:33.641] result() for MulticoreFuture ...
[17:38:33.641] result() for MulticoreFuture ... done
[17:38:33.641] result() for MulticoreFuture ...
[17:38:33.642] result() for MulticoreFuture ... done
[17:38:33.642] result() for MulticoreFuture ...
[17:38:33.642] result() for MulticoreFuture ... done
[17:38:33.642] - relayed: [n=2] TRUE, FALSE
[17:38:33.642] - queued futures: [n=2] TRUE, TRUE
[17:38:33.642] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:38:33.642]  length: 0 (resolved future 1)
[17:38:33.643] Relaying remaining futures
[17:38:33.643] signalConditionsASAP(NULL, pos=0) ...
[17:38:33.643] - nx: 2
[17:38:33.643] - relay: TRUE
[17:38:33.643] - stdout: TRUE
[17:38:33.643] - signal: TRUE
[17:38:33.643] - resignal: FALSE
[17:38:33.643] - force: TRUE
[17:38:33.643] - relayed: [n=2] TRUE, FALSE
[17:38:33.643] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:33.644]  - relaying element #2
[17:38:33.644] result() for MulticoreFuture ...
[17:38:33.644] result() for MulticoreFuture ... done
[17:38:33.644] result() for MulticoreFuture ...
[17:38:33.644] result() for MulticoreFuture ... done
[17:38:33.644] result() for MulticoreFuture ...
[17:38:33.644] result() for MulticoreFuture ... done
[17:38:33.645] result() for MulticoreFuture ...
[17:38:33.645] result() for MulticoreFuture ... done
[17:38:33.645] - relayed: [n=2] TRUE, TRUE
[17:38:33.645] - queued futures: [n=2] TRUE, TRUE
[17:38:33.645] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:38:33.645] resolve() on list ... DONE
[17:38:33.645] result() for MulticoreFuture ...
[17:38:33.645] result() for MulticoreFuture ... done
[17:38:33.645] result() for MulticoreFuture ...
[17:38:33.645] result() for MulticoreFuture ... done
[17:38:33.646] result() for MulticoreFuture ...
[17:38:33.646] result() for MulticoreFuture ... done
[17:38:33.646] result() for MulticoreFuture ...
[17:38:33.646] result() for MulticoreFuture ... done
[17:38:33.646]  - Number of value chunks collected: 2
[17:38:33.646] Resolving 2 futures (chunks) ... DONE
[17:38:33.646] Reducing values from 2 chunks ...
[17:38:33.646]  - Number of values collected after concatenation: 2
[17:38:33.647]  - Number of values expected: 2
[17:38:33.647] Reducing values from 2 chunks ... DONE
[17:38:33.647] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[17:38:33.647] future_mapply() ...
[17:38:33.651] Number of chunks: 2
[17:38:33.652] getGlobalsAndPackagesXApply() ...
[17:38:33.652]  - future.globals: TRUE
[17:38:33.652] getGlobalsAndPackages() ...
[17:38:33.652] Searching for globals...
[17:38:33.654] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:38:33.654] Searching for globals ... DONE
[17:38:33.654] Resolving globals: FALSE
[17:38:33.655] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:38:33.655] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:38:33.655] - globals: [1] ‘FUN’
[17:38:33.655] 
[17:38:33.655] getGlobalsAndPackages() ... DONE
[17:38:33.655]  - globals found/used: [n=1] ‘FUN’
[17:38:33.656]  - needed namespaces: [n=0] 
[17:38:33.656] Finding globals ... DONE
[17:38:33.656] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:38:33.656] List of 2
[17:38:33.656]  $ ...future.FUN:function (x, y)  
[17:38:33.656]  $ MoreArgs     : NULL
[17:38:33.656]  - attr(*, "where")=List of 2
[17:38:33.656]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:33.656]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:38:33.656]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:33.656]  - attr(*, "resolved")= logi FALSE
[17:38:33.656]  - attr(*, "total_size")= num NA
[17:38:33.659] Packages to be attached in all futures: [n=0] 
[17:38:33.659] getGlobalsAndPackagesXApply() ... DONE
[17:38:33.659] Number of futures (= number of chunks): 2
[17:38:33.659] Launching 2 futures (chunks) ...
[17:38:33.659] Chunk #1 of 2 ...
[17:38:33.660]  - Finding globals in '...' for chunk #1 ...
[17:38:33.660] getGlobalsAndPackages() ...
[17:38:33.660] Searching for globals...
[17:38:33.660] 
[17:38:33.660] Searching for globals ... DONE
[17:38:33.660] - globals: [0] <none>
[17:38:33.660] getGlobalsAndPackages() ... DONE
[17:38:33.661]    + additional globals found: [n=0] 
[17:38:33.661]    + additional namespaces needed: [n=0] 
[17:38:33.661]  - Finding globals in '...' for chunk #1 ... DONE
[17:38:33.661]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:33.661]  - seeds: <none>
[17:38:33.661]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:33.661] getGlobalsAndPackages() ...
[17:38:33.661] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:33.661] Resolving globals: FALSE
[17:38:33.662] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:38:33.662] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:38:33.662] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:33.663] 
[17:38:33.663] getGlobalsAndPackages() ... DONE
[17:38:33.663] run() for ‘Future’ ...
[17:38:33.663] - state: ‘created’
[17:38:33.663] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:33.667] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:33.667] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:33.667]   - Field: ‘label’
[17:38:33.667]   - Field: ‘local’
[17:38:33.667]   - Field: ‘owner’
[17:38:33.667]   - Field: ‘envir’
[17:38:33.667]   - Field: ‘workers’
[17:38:33.669]   - Field: ‘packages’
[17:38:33.670]   - Field: ‘gc’
[17:38:33.670]   - Field: ‘job’
[17:38:33.670]   - Field: ‘conditions’
[17:38:33.670]   - Field: ‘expr’
[17:38:33.670]   - Field: ‘uuid’
[17:38:33.670]   - Field: ‘seed’
[17:38:33.670]   - Field: ‘version’
[17:38:33.670]   - Field: ‘result’
[17:38:33.671]   - Field: ‘asynchronous’
[17:38:33.671]   - Field: ‘calls’
[17:38:33.671]   - Field: ‘globals’
[17:38:33.671]   - Field: ‘stdout’
[17:38:33.671]   - Field: ‘earlySignal’
[17:38:33.671]   - Field: ‘lazy’
[17:38:33.671]   - Field: ‘state’
[17:38:33.671] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:33.671] - Launch lazy future ...
[17:38:33.672] Packages needed by the future expression (n = 0): <none>
[17:38:33.672] Packages needed by future strategies (n = 0): <none>
[17:38:33.672] {
[17:38:33.672]     {
[17:38:33.672]         {
[17:38:33.672]             ...future.startTime <- base::Sys.time()
[17:38:33.672]             {
[17:38:33.672]                 {
[17:38:33.672]                   {
[17:38:33.672]                     {
[17:38:33.672]                       base::local({
[17:38:33.672]                         has_future <- base::requireNamespace("future", 
[17:38:33.672]                           quietly = TRUE)
[17:38:33.672]                         if (has_future) {
[17:38:33.672]                           ns <- base::getNamespace("future")
[17:38:33.672]                           version <- ns[[".package"]][["version"]]
[17:38:33.672]                           if (is.null(version)) 
[17:38:33.672]                             version <- utils::packageVersion("future")
[17:38:33.672]                         }
[17:38:33.672]                         else {
[17:38:33.672]                           version <- NULL
[17:38:33.672]                         }
[17:38:33.672]                         if (!has_future || version < "1.8.0") {
[17:38:33.672]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:33.672]                             "", base::R.version$version.string), 
[17:38:33.672]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:33.672]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:33.672]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:33.672]                               "release", "version")], collapse = " "), 
[17:38:33.672]                             hostname = base::Sys.info()[["nodename"]])
[17:38:33.672]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:33.672]                             info)
[17:38:33.672]                           info <- base::paste(info, collapse = "; ")
[17:38:33.672]                           if (!has_future) {
[17:38:33.672]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:33.672]                               info)
[17:38:33.672]                           }
[17:38:33.672]                           else {
[17:38:33.672]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:33.672]                               info, version)
[17:38:33.672]                           }
[17:38:33.672]                           base::stop(msg)
[17:38:33.672]                         }
[17:38:33.672]                       })
[17:38:33.672]                     }
[17:38:33.672]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:33.672]                     base::options(mc.cores = 1L)
[17:38:33.672]                   }
[17:38:33.672]                   ...future.strategy.old <- future::plan("list")
[17:38:33.672]                   options(future.plan = NULL)
[17:38:33.672]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:33.672]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:33.672]                 }
[17:38:33.672]                 ...future.workdir <- getwd()
[17:38:33.672]             }
[17:38:33.672]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:33.672]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:33.672]         }
[17:38:33.672]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:33.672]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:33.672]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:33.672]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:33.672]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:33.672]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:33.672]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:33.672]             base::names(...future.oldOptions))
[17:38:33.672]     }
[17:38:33.672]     if (TRUE) {
[17:38:33.672]     }
[17:38:33.672]     else {
[17:38:33.672]         if (NA) {
[17:38:33.672]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:33.672]                 open = "w")
[17:38:33.672]         }
[17:38:33.672]         else {
[17:38:33.672]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:33.672]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:33.672]         }
[17:38:33.672]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:33.672]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:33.672]             base::sink(type = "output", split = FALSE)
[17:38:33.672]             base::close(...future.stdout)
[17:38:33.672]         }, add = TRUE)
[17:38:33.672]     }
[17:38:33.672]     ...future.frame <- base::sys.nframe()
[17:38:33.672]     ...future.conditions <- base::list()
[17:38:33.672]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:33.672]     if (FALSE) {
[17:38:33.672]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:33.672]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:33.672]     }
[17:38:33.672]     ...future.result <- base::tryCatch({
[17:38:33.672]         base::withCallingHandlers({
[17:38:33.672]             ...future.value <- base::withVisible(base::local({
[17:38:33.672]                 withCallingHandlers({
[17:38:33.672]                   {
[17:38:33.672]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:33.672]                     if (!identical(...future.globals.maxSize.org, 
[17:38:33.672]                       ...future.globals.maxSize)) {
[17:38:33.672]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:33.672]                       on.exit(options(oopts), add = TRUE)
[17:38:33.672]                     }
[17:38:33.672]                     {
[17:38:33.672]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:33.672]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:38:33.672]                         USE.NAMES = FALSE)
[17:38:33.672]                       do.call(mapply, args = args)
[17:38:33.672]                     }
[17:38:33.672]                   }
[17:38:33.672]                 }, immediateCondition = function(cond) {
[17:38:33.672]                   save_rds <- function (object, pathname, ...) 
[17:38:33.672]                   {
[17:38:33.672]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:33.672]                     if (file_test("-f", pathname_tmp)) {
[17:38:33.672]                       fi_tmp <- file.info(pathname_tmp)
[17:38:33.672]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:33.672]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:33.672]                         fi_tmp[["mtime"]])
[17:38:33.672]                     }
[17:38:33.672]                     tryCatch({
[17:38:33.672]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:33.672]                     }, error = function(ex) {
[17:38:33.672]                       msg <- conditionMessage(ex)
[17:38:33.672]                       fi_tmp <- file.info(pathname_tmp)
[17:38:33.672]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:33.672]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:33.672]                         fi_tmp[["mtime"]], msg)
[17:38:33.672]                       ex$message <- msg
[17:38:33.672]                       stop(ex)
[17:38:33.672]                     })
[17:38:33.672]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:33.672]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:33.672]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:33.672]                       fi_tmp <- file.info(pathname_tmp)
[17:38:33.672]                       fi <- file.info(pathname)
[17:38:33.672]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:33.672]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:33.672]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:33.672]                         fi[["size"]], fi[["mtime"]])
[17:38:33.672]                       stop(msg)
[17:38:33.672]                     }
[17:38:33.672]                     invisible(pathname)
[17:38:33.672]                   }
[17:38:33.672]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:33.672]                     rootPath = tempdir()) 
[17:38:33.672]                   {
[17:38:33.672]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:33.672]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:33.672]                       tmpdir = path, fileext = ".rds")
[17:38:33.672]                     save_rds(obj, file)
[17:38:33.672]                   }
[17:38:33.672]                   saveImmediateCondition(cond, path = "/tmp/RtmpBrP0ee/.future/immediateConditions")
[17:38:33.672]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:33.672]                   {
[17:38:33.672]                     inherits <- base::inherits
[17:38:33.672]                     invokeRestart <- base::invokeRestart
[17:38:33.672]                     is.null <- base::is.null
[17:38:33.672]                     muffled <- FALSE
[17:38:33.672]                     if (inherits(cond, "message")) {
[17:38:33.672]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:33.672]                       if (muffled) 
[17:38:33.672]                         invokeRestart("muffleMessage")
[17:38:33.672]                     }
[17:38:33.672]                     else if (inherits(cond, "warning")) {
[17:38:33.672]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:33.672]                       if (muffled) 
[17:38:33.672]                         invokeRestart("muffleWarning")
[17:38:33.672]                     }
[17:38:33.672]                     else if (inherits(cond, "condition")) {
[17:38:33.672]                       if (!is.null(pattern)) {
[17:38:33.672]                         computeRestarts <- base::computeRestarts
[17:38:33.672]                         grepl <- base::grepl
[17:38:33.672]                         restarts <- computeRestarts(cond)
[17:38:33.672]                         for (restart in restarts) {
[17:38:33.672]                           name <- restart$name
[17:38:33.672]                           if (is.null(name)) 
[17:38:33.672]                             next
[17:38:33.672]                           if (!grepl(pattern, name)) 
[17:38:33.672]                             next
[17:38:33.672]                           invokeRestart(restart)
[17:38:33.672]                           muffled <- TRUE
[17:38:33.672]                           break
[17:38:33.672]                         }
[17:38:33.672]                       }
[17:38:33.672]                     }
[17:38:33.672]                     invisible(muffled)
[17:38:33.672]                   }
[17:38:33.672]                   muffleCondition(cond)
[17:38:33.672]                 })
[17:38:33.672]             }))
[17:38:33.672]             future::FutureResult(value = ...future.value$value, 
[17:38:33.672]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:33.672]                   ...future.rng), globalenv = if (FALSE) 
[17:38:33.672]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:33.672]                     ...future.globalenv.names))
[17:38:33.672]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:33.672]         }, condition = base::local({
[17:38:33.672]             c <- base::c
[17:38:33.672]             inherits <- base::inherits
[17:38:33.672]             invokeRestart <- base::invokeRestart
[17:38:33.672]             length <- base::length
[17:38:33.672]             list <- base::list
[17:38:33.672]             seq.int <- base::seq.int
[17:38:33.672]             signalCondition <- base::signalCondition
[17:38:33.672]             sys.calls <- base::sys.calls
[17:38:33.672]             `[[` <- base::`[[`
[17:38:33.672]             `+` <- base::`+`
[17:38:33.672]             `<<-` <- base::`<<-`
[17:38:33.672]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:33.672]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:33.672]                   3L)]
[17:38:33.672]             }
[17:38:33.672]             function(cond) {
[17:38:33.672]                 is_error <- inherits(cond, "error")
[17:38:33.672]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:33.672]                   NULL)
[17:38:33.672]                 if (is_error) {
[17:38:33.672]                   sessionInformation <- function() {
[17:38:33.672]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:33.672]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:33.672]                       search = base::search(), system = base::Sys.info())
[17:38:33.672]                   }
[17:38:33.672]                   ...future.conditions[[length(...future.conditions) + 
[17:38:33.672]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:33.672]                     cond$call), session = sessionInformation(), 
[17:38:33.672]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:33.672]                   signalCondition(cond)
[17:38:33.672]                 }
[17:38:33.672]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:33.672]                 "immediateCondition"))) {
[17:38:33.672]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:33.672]                   ...future.conditions[[length(...future.conditions) + 
[17:38:33.672]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:33.672]                   if (TRUE && !signal) {
[17:38:33.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:33.672]                     {
[17:38:33.672]                       inherits <- base::inherits
[17:38:33.672]                       invokeRestart <- base::invokeRestart
[17:38:33.672]                       is.null <- base::is.null
[17:38:33.672]                       muffled <- FALSE
[17:38:33.672]                       if (inherits(cond, "message")) {
[17:38:33.672]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:33.672]                         if (muffled) 
[17:38:33.672]                           invokeRestart("muffleMessage")
[17:38:33.672]                       }
[17:38:33.672]                       else if (inherits(cond, "warning")) {
[17:38:33.672]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:33.672]                         if (muffled) 
[17:38:33.672]                           invokeRestart("muffleWarning")
[17:38:33.672]                       }
[17:38:33.672]                       else if (inherits(cond, "condition")) {
[17:38:33.672]                         if (!is.null(pattern)) {
[17:38:33.672]                           computeRestarts <- base::computeRestarts
[17:38:33.672]                           grepl <- base::grepl
[17:38:33.672]                           restarts <- computeRestarts(cond)
[17:38:33.672]                           for (restart in restarts) {
[17:38:33.672]                             name <- restart$name
[17:38:33.672]                             if (is.null(name)) 
[17:38:33.672]                               next
[17:38:33.672]                             if (!grepl(pattern, name)) 
[17:38:33.672]                               next
[17:38:33.672]                             invokeRestart(restart)
[17:38:33.672]                             muffled <- TRUE
[17:38:33.672]                             break
[17:38:33.672]                           }
[17:38:33.672]                         }
[17:38:33.672]                       }
[17:38:33.672]                       invisible(muffled)
[17:38:33.672]                     }
[17:38:33.672]                     muffleCondition(cond, pattern = "^muffle")
[17:38:33.672]                   }
[17:38:33.672]                 }
[17:38:33.672]                 else {
[17:38:33.672]                   if (TRUE) {
[17:38:33.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:33.672]                     {
[17:38:33.672]                       inherits <- base::inherits
[17:38:33.672]                       invokeRestart <- base::invokeRestart
[17:38:33.672]                       is.null <- base::is.null
[17:38:33.672]                       muffled <- FALSE
[17:38:33.672]                       if (inherits(cond, "message")) {
[17:38:33.672]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:33.672]                         if (muffled) 
[17:38:33.672]                           invokeRestart("muffleMessage")
[17:38:33.672]                       }
[17:38:33.672]                       else if (inherits(cond, "warning")) {
[17:38:33.672]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:33.672]                         if (muffled) 
[17:38:33.672]                           invokeRestart("muffleWarning")
[17:38:33.672]                       }
[17:38:33.672]                       else if (inherits(cond, "condition")) {
[17:38:33.672]                         if (!is.null(pattern)) {
[17:38:33.672]                           computeRestarts <- base::computeRestarts
[17:38:33.672]                           grepl <- base::grepl
[17:38:33.672]                           restarts <- computeRestarts(cond)
[17:38:33.672]                           for (restart in restarts) {
[17:38:33.672]                             name <- restart$name
[17:38:33.672]                             if (is.null(name)) 
[17:38:33.672]                               next
[17:38:33.672]                             if (!grepl(pattern, name)) 
[17:38:33.672]                               next
[17:38:33.672]                             invokeRestart(restart)
[17:38:33.672]                             muffled <- TRUE
[17:38:33.672]                             break
[17:38:33.672]                           }
[17:38:33.672]                         }
[17:38:33.672]                       }
[17:38:33.672]                       invisible(muffled)
[17:38:33.672]                     }
[17:38:33.672]                     muffleCondition(cond, pattern = "^muffle")
[17:38:33.672]                   }
[17:38:33.672]                 }
[17:38:33.672]             }
[17:38:33.672]         }))
[17:38:33.672]     }, error = function(ex) {
[17:38:33.672]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:33.672]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:33.672]                 ...future.rng), started = ...future.startTime, 
[17:38:33.672]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:33.672]             version = "1.8"), class = "FutureResult")
[17:38:33.672]     }, finally = {
[17:38:33.672]         if (!identical(...future.workdir, getwd())) 
[17:38:33.672]             setwd(...future.workdir)
[17:38:33.672]         {
[17:38:33.672]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:33.672]                 ...future.oldOptions$nwarnings <- NULL
[17:38:33.672]             }
[17:38:33.672]             base::options(...future.oldOptions)
[17:38:33.672]             if (.Platform$OS.type == "windows") {
[17:38:33.672]                 old_names <- names(...future.oldEnvVars)
[17:38:33.672]                 envs <- base::Sys.getenv()
[17:38:33.672]                 names <- names(envs)
[17:38:33.672]                 common <- intersect(names, old_names)
[17:38:33.672]                 added <- setdiff(names, old_names)
[17:38:33.672]                 removed <- setdiff(old_names, names)
[17:38:33.672]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:33.672]                   envs[common]]
[17:38:33.672]                 NAMES <- toupper(changed)
[17:38:33.672]                 args <- list()
[17:38:33.672]                 for (kk in seq_along(NAMES)) {
[17:38:33.672]                   name <- changed[[kk]]
[17:38:33.672]                   NAME <- NAMES[[kk]]
[17:38:33.672]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:33.672]                     next
[17:38:33.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:33.672]                 }
[17:38:33.672]                 NAMES <- toupper(added)
[17:38:33.672]                 for (kk in seq_along(NAMES)) {
[17:38:33.672]                   name <- added[[kk]]
[17:38:33.672]                   NAME <- NAMES[[kk]]
[17:38:33.672]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:33.672]                     next
[17:38:33.672]                   args[[name]] <- ""
[17:38:33.672]                 }
[17:38:33.672]                 NAMES <- toupper(removed)
[17:38:33.672]                 for (kk in seq_along(NAMES)) {
[17:38:33.672]                   name <- removed[[kk]]
[17:38:33.672]                   NAME <- NAMES[[kk]]
[17:38:33.672]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:33.672]                     next
[17:38:33.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:33.672]                 }
[17:38:33.672]                 if (length(args) > 0) 
[17:38:33.672]                   base::do.call(base::Sys.setenv, args = args)
[17:38:33.672]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:33.672]             }
[17:38:33.672]             else {
[17:38:33.672]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:33.672]             }
[17:38:33.672]             {
[17:38:33.672]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:33.672]                   0L) {
[17:38:33.672]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:33.672]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:33.672]                   base::options(opts)
[17:38:33.672]                 }
[17:38:33.672]                 {
[17:38:33.672]                   {
[17:38:33.672]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:33.672]                     NULL
[17:38:33.672]                   }
[17:38:33.672]                   options(future.plan = NULL)
[17:38:33.672]                   if (is.na(NA_character_)) 
[17:38:33.672]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:33.672]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:33.672]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:33.672]                     .init = FALSE)
[17:38:33.672]                 }
[17:38:33.672]             }
[17:38:33.672]         }
[17:38:33.672]     })
[17:38:33.672]     if (FALSE) {
[17:38:33.672]         base::sink(type = "output", split = FALSE)
[17:38:33.672]         if (NA) {
[17:38:33.672]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:33.672]         }
[17:38:33.672]         else {
[17:38:33.672]             ...future.result["stdout"] <- base::list(NULL)
[17:38:33.672]         }
[17:38:33.672]         base::close(...future.stdout)
[17:38:33.672]         ...future.stdout <- NULL
[17:38:33.672]     }
[17:38:33.672]     ...future.result$conditions <- ...future.conditions
[17:38:33.672]     ...future.result$finished <- base::Sys.time()
[17:38:33.672]     ...future.result
[17:38:33.672] }
[17:38:33.675] assign_globals() ...
[17:38:33.675] List of 5
[17:38:33.675]  $ ...future.FUN            :function (x, y)  
[17:38:33.675]  $ MoreArgs                 : NULL
[17:38:33.675]  $ ...future.elements_ii    :List of 2
[17:38:33.675]   ..$ :List of 1
[17:38:33.675]   .. ..$ : int 1
[17:38:33.675]   ..$ :List of 1
[17:38:33.675]   .. ..$ : int 0
[17:38:33.675]  $ ...future.seeds_ii       : NULL
[17:38:33.675]  $ ...future.globals.maxSize: NULL
[17:38:33.675]  - attr(*, "where")=List of 5
[17:38:33.675]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:33.675]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:38:33.675]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:33.675]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:33.675]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:33.675]  - attr(*, "resolved")= logi FALSE
[17:38:33.675]  - attr(*, "total_size")= num 6368
[17:38:33.675]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:33.675]  - attr(*, "already-done")= logi TRUE
[17:38:33.680] - reassign environment for ‘...future.FUN’
[17:38:33.680] - copied ‘...future.FUN’ to environment
[17:38:33.680] - copied ‘MoreArgs’ to environment
[17:38:33.680] - copied ‘...future.elements_ii’ to environment
[17:38:33.680] - copied ‘...future.seeds_ii’ to environment
[17:38:33.680] - copied ‘...future.globals.maxSize’ to environment
[17:38:33.680] assign_globals() ... done
[17:38:33.680] requestCore(): workers = 2
[17:38:33.683] MulticoreFuture started
[17:38:33.683] - Launch lazy future ... done
[17:38:33.683] run() for ‘MulticoreFuture’ ... done
[17:38:33.683] Created future:
[17:38:33.684] plan(): Setting new future strategy stack:
[17:38:33.684] List of future strategies:
[17:38:33.684] 1. sequential:
[17:38:33.684]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:33.684]    - tweaked: FALSE
[17:38:33.684]    - call: NULL
[17:38:33.685] plan(): nbrOfWorkers() = 1
[17:38:33.684] MulticoreFuture:
[17:38:33.684] Label: ‘future_mapply-1’
[17:38:33.684] Expression:
[17:38:33.684] {
[17:38:33.684]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:33.684]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:33.684]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:33.684]         on.exit(options(oopts), add = TRUE)
[17:38:33.684]     }
[17:38:33.684]     {
[17:38:33.684]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:33.684]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:38:33.684]         do.call(mapply, args = args)
[17:38:33.684]     }
[17:38:33.684] }
[17:38:33.684] Lazy evaluation: FALSE
[17:38:33.684] Asynchronous evaluation: TRUE
[17:38:33.684] Local evaluation: TRUE
[17:38:33.684] Environment: R_GlobalEnv
[17:38:33.684] Capture standard output: NA
[17:38:33.684] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:33.684] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:33.684] Packages: <none>
[17:38:33.684] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:33.684] Resolved: FALSE
[17:38:33.684] Value: <not collected>
[17:38:33.684] Conditions captured: <none>
[17:38:33.684] Early signaling: FALSE
[17:38:33.684] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:33.684] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:33.696] Chunk #1 of 2 ... DONE
[17:38:33.696] Chunk #2 of 2 ...
[17:38:33.697]  - Finding globals in '...' for chunk #2 ...
[17:38:33.697] getGlobalsAndPackages() ...
[17:38:33.697] Searching for globals...
[17:38:33.698] 
[17:38:33.698] Searching for globals ... DONE
[17:38:33.698] - globals: [0] <none>
[17:38:33.698] getGlobalsAndPackages() ... DONE
[17:38:33.698]    + additional globals found: [n=0] 
[17:38:33.698]    + additional namespaces needed: [n=0] 
[17:38:33.699]  - Finding globals in '...' for chunk #2 ... DONE
[17:38:33.699]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:33.699]  - seeds: <none>
[17:38:33.699]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:33.699] getGlobalsAndPackages() ...
[17:38:33.699] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:33.699] Resolving globals: FALSE
[17:38:33.700] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:38:33.701] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:38:33.701] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:33.702] 
[17:38:33.702] getGlobalsAndPackages() ... DONE
[17:38:33.702] run() for ‘Future’ ...
[17:38:33.703] - state: ‘created’
[17:38:33.703] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:33.709] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:33.709] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:33.709]   - Field: ‘label’
[17:38:33.709]   - Field: ‘local’
[17:38:33.709]   - Field: ‘owner’
[17:38:33.710]   - Field: ‘envir’
[17:38:33.710]   - Field: ‘workers’
[17:38:33.710]   - Field: ‘packages’
[17:38:33.710]   - Field: ‘gc’
[17:38:33.710]   - Field: ‘job’
[17:38:33.710]   - Field: ‘conditions’
[17:38:33.710]   - Field: ‘expr’
[17:38:33.711]   - Field: ‘uuid’
[17:38:33.711]   - Field: ‘seed’
[17:38:33.711]   - Field: ‘version’
[17:38:33.711]   - Field: ‘result’
[17:38:33.711]   - Field: ‘asynchronous’
[17:38:33.711]   - Field: ‘calls’
[17:38:33.711]   - Field: ‘globals’
[17:38:33.712]   - Field: ‘stdout’
[17:38:33.712]   - Field: ‘earlySignal’
[17:38:33.712]   - Field: ‘lazy’
[17:38:33.712]   - Field: ‘state’
[17:38:33.712] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:33.712] - Launch lazy future ...
[17:38:33.713] Packages needed by the future expression (n = 0): <none>
[17:38:33.713] Packages needed by future strategies (n = 0): <none>
[17:38:33.714] {
[17:38:33.714]     {
[17:38:33.714]         {
[17:38:33.714]             ...future.startTime <- base::Sys.time()
[17:38:33.714]             {
[17:38:33.714]                 {
[17:38:33.714]                   {
[17:38:33.714]                     {
[17:38:33.714]                       base::local({
[17:38:33.714]                         has_future <- base::requireNamespace("future", 
[17:38:33.714]                           quietly = TRUE)
[17:38:33.714]                         if (has_future) {
[17:38:33.714]                           ns <- base::getNamespace("future")
[17:38:33.714]                           version <- ns[[".package"]][["version"]]
[17:38:33.714]                           if (is.null(version)) 
[17:38:33.714]                             version <- utils::packageVersion("future")
[17:38:33.714]                         }
[17:38:33.714]                         else {
[17:38:33.714]                           version <- NULL
[17:38:33.714]                         }
[17:38:33.714]                         if (!has_future || version < "1.8.0") {
[17:38:33.714]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:33.714]                             "", base::R.version$version.string), 
[17:38:33.714]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:33.714]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:33.714]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:33.714]                               "release", "version")], collapse = " "), 
[17:38:33.714]                             hostname = base::Sys.info()[["nodename"]])
[17:38:33.714]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:33.714]                             info)
[17:38:33.714]                           info <- base::paste(info, collapse = "; ")
[17:38:33.714]                           if (!has_future) {
[17:38:33.714]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:33.714]                               info)
[17:38:33.714]                           }
[17:38:33.714]                           else {
[17:38:33.714]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:33.714]                               info, version)
[17:38:33.714]                           }
[17:38:33.714]                           base::stop(msg)
[17:38:33.714]                         }
[17:38:33.714]                       })
[17:38:33.714]                     }
[17:38:33.714]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:33.714]                     base::options(mc.cores = 1L)
[17:38:33.714]                   }
[17:38:33.714]                   ...future.strategy.old <- future::plan("list")
[17:38:33.714]                   options(future.plan = NULL)
[17:38:33.714]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:33.714]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:33.714]                 }
[17:38:33.714]                 ...future.workdir <- getwd()
[17:38:33.714]             }
[17:38:33.714]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:33.714]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:33.714]         }
[17:38:33.714]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:33.714]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:33.714]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:33.714]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:33.714]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:33.714]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:33.714]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:33.714]             base::names(...future.oldOptions))
[17:38:33.714]     }
[17:38:33.714]     if (TRUE) {
[17:38:33.714]     }
[17:38:33.714]     else {
[17:38:33.714]         if (NA) {
[17:38:33.714]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:33.714]                 open = "w")
[17:38:33.714]         }
[17:38:33.714]         else {
[17:38:33.714]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:33.714]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:33.714]         }
[17:38:33.714]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:33.714]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:33.714]             base::sink(type = "output", split = FALSE)
[17:38:33.714]             base::close(...future.stdout)
[17:38:33.714]         }, add = TRUE)
[17:38:33.714]     }
[17:38:33.714]     ...future.frame <- base::sys.nframe()
[17:38:33.714]     ...future.conditions <- base::list()
[17:38:33.714]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:33.714]     if (FALSE) {
[17:38:33.714]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:33.714]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:33.714]     }
[17:38:33.714]     ...future.result <- base::tryCatch({
[17:38:33.714]         base::withCallingHandlers({
[17:38:33.714]             ...future.value <- base::withVisible(base::local({
[17:38:33.714]                 withCallingHandlers({
[17:38:33.714]                   {
[17:38:33.714]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:33.714]                     if (!identical(...future.globals.maxSize.org, 
[17:38:33.714]                       ...future.globals.maxSize)) {
[17:38:33.714]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:33.714]                       on.exit(options(oopts), add = TRUE)
[17:38:33.714]                     }
[17:38:33.714]                     {
[17:38:33.714]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:33.714]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:38:33.714]                         USE.NAMES = FALSE)
[17:38:33.714]                       do.call(mapply, args = args)
[17:38:33.714]                     }
[17:38:33.714]                   }
[17:38:33.714]                 }, immediateCondition = function(cond) {
[17:38:33.714]                   save_rds <- function (object, pathname, ...) 
[17:38:33.714]                   {
[17:38:33.714]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:33.714]                     if (file_test("-f", pathname_tmp)) {
[17:38:33.714]                       fi_tmp <- file.info(pathname_tmp)
[17:38:33.714]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:33.714]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:33.714]                         fi_tmp[["mtime"]])
[17:38:33.714]                     }
[17:38:33.714]                     tryCatch({
[17:38:33.714]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:33.714]                     }, error = function(ex) {
[17:38:33.714]                       msg <- conditionMessage(ex)
[17:38:33.714]                       fi_tmp <- file.info(pathname_tmp)
[17:38:33.714]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:33.714]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:33.714]                         fi_tmp[["mtime"]], msg)
[17:38:33.714]                       ex$message <- msg
[17:38:33.714]                       stop(ex)
[17:38:33.714]                     })
[17:38:33.714]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:33.714]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:33.714]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:33.714]                       fi_tmp <- file.info(pathname_tmp)
[17:38:33.714]                       fi <- file.info(pathname)
[17:38:33.714]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:33.714]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:33.714]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:33.714]                         fi[["size"]], fi[["mtime"]])
[17:38:33.714]                       stop(msg)
[17:38:33.714]                     }
[17:38:33.714]                     invisible(pathname)
[17:38:33.714]                   }
[17:38:33.714]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:33.714]                     rootPath = tempdir()) 
[17:38:33.714]                   {
[17:38:33.714]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:33.714]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:33.714]                       tmpdir = path, fileext = ".rds")
[17:38:33.714]                     save_rds(obj, file)
[17:38:33.714]                   }
[17:38:33.714]                   saveImmediateCondition(cond, path = "/tmp/RtmpBrP0ee/.future/immediateConditions")
[17:38:33.714]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:33.714]                   {
[17:38:33.714]                     inherits <- base::inherits
[17:38:33.714]                     invokeRestart <- base::invokeRestart
[17:38:33.714]                     is.null <- base::is.null
[17:38:33.714]                     muffled <- FALSE
[17:38:33.714]                     if (inherits(cond, "message")) {
[17:38:33.714]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:33.714]                       if (muffled) 
[17:38:33.714]                         invokeRestart("muffleMessage")
[17:38:33.714]                     }
[17:38:33.714]                     else if (inherits(cond, "warning")) {
[17:38:33.714]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:33.714]                       if (muffled) 
[17:38:33.714]                         invokeRestart("muffleWarning")
[17:38:33.714]                     }
[17:38:33.714]                     else if (inherits(cond, "condition")) {
[17:38:33.714]                       if (!is.null(pattern)) {
[17:38:33.714]                         computeRestarts <- base::computeRestarts
[17:38:33.714]                         grepl <- base::grepl
[17:38:33.714]                         restarts <- computeRestarts(cond)
[17:38:33.714]                         for (restart in restarts) {
[17:38:33.714]                           name <- restart$name
[17:38:33.714]                           if (is.null(name)) 
[17:38:33.714]                             next
[17:38:33.714]                           if (!grepl(pattern, name)) 
[17:38:33.714]                             next
[17:38:33.714]                           invokeRestart(restart)
[17:38:33.714]                           muffled <- TRUE
[17:38:33.714]                           break
[17:38:33.714]                         }
[17:38:33.714]                       }
[17:38:33.714]                     }
[17:38:33.714]                     invisible(muffled)
[17:38:33.714]                   }
[17:38:33.714]                   muffleCondition(cond)
[17:38:33.714]                 })
[17:38:33.714]             }))
[17:38:33.714]             future::FutureResult(value = ...future.value$value, 
[17:38:33.714]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:33.714]                   ...future.rng), globalenv = if (FALSE) 
[17:38:33.714]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:33.714]                     ...future.globalenv.names))
[17:38:33.714]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:33.714]         }, condition = base::local({
[17:38:33.714]             c <- base::c
[17:38:33.714]             inherits <- base::inherits
[17:38:33.714]             invokeRestart <- base::invokeRestart
[17:38:33.714]             length <- base::length
[17:38:33.714]             list <- base::list
[17:38:33.714]             seq.int <- base::seq.int
[17:38:33.714]             signalCondition <- base::signalCondition
[17:38:33.714]             sys.calls <- base::sys.calls
[17:38:33.714]             `[[` <- base::`[[`
[17:38:33.714]             `+` <- base::`+`
[17:38:33.714]             `<<-` <- base::`<<-`
[17:38:33.714]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:33.714]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:33.714]                   3L)]
[17:38:33.714]             }
[17:38:33.714]             function(cond) {
[17:38:33.714]                 is_error <- inherits(cond, "error")
[17:38:33.714]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:33.714]                   NULL)
[17:38:33.714]                 if (is_error) {
[17:38:33.714]                   sessionInformation <- function() {
[17:38:33.714]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:33.714]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:33.714]                       search = base::search(), system = base::Sys.info())
[17:38:33.714]                   }
[17:38:33.714]                   ...future.conditions[[length(...future.conditions) + 
[17:38:33.714]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:33.714]                     cond$call), session = sessionInformation(), 
[17:38:33.714]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:33.714]                   signalCondition(cond)
[17:38:33.714]                 }
[17:38:33.714]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:33.714]                 "immediateCondition"))) {
[17:38:33.714]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:33.714]                   ...future.conditions[[length(...future.conditions) + 
[17:38:33.714]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:33.714]                   if (TRUE && !signal) {
[17:38:33.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:33.714]                     {
[17:38:33.714]                       inherits <- base::inherits
[17:38:33.714]                       invokeRestart <- base::invokeRestart
[17:38:33.714]                       is.null <- base::is.null
[17:38:33.714]                       muffled <- FALSE
[17:38:33.714]                       if (inherits(cond, "message")) {
[17:38:33.714]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:33.714]                         if (muffled) 
[17:38:33.714]                           invokeRestart("muffleMessage")
[17:38:33.714]                       }
[17:38:33.714]                       else if (inherits(cond, "warning")) {
[17:38:33.714]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:33.714]                         if (muffled) 
[17:38:33.714]                           invokeRestart("muffleWarning")
[17:38:33.714]                       }
[17:38:33.714]                       else if (inherits(cond, "condition")) {
[17:38:33.714]                         if (!is.null(pattern)) {
[17:38:33.714]                           computeRestarts <- base::computeRestarts
[17:38:33.714]                           grepl <- base::grepl
[17:38:33.714]                           restarts <- computeRestarts(cond)
[17:38:33.714]                           for (restart in restarts) {
[17:38:33.714]                             name <- restart$name
[17:38:33.714]                             if (is.null(name)) 
[17:38:33.714]                               next
[17:38:33.714]                             if (!grepl(pattern, name)) 
[17:38:33.714]                               next
[17:38:33.714]                             invokeRestart(restart)
[17:38:33.714]                             muffled <- TRUE
[17:38:33.714]                             break
[17:38:33.714]                           }
[17:38:33.714]                         }
[17:38:33.714]                       }
[17:38:33.714]                       invisible(muffled)
[17:38:33.714]                     }
[17:38:33.714]                     muffleCondition(cond, pattern = "^muffle")
[17:38:33.714]                   }
[17:38:33.714]                 }
[17:38:33.714]                 else {
[17:38:33.714]                   if (TRUE) {
[17:38:33.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:33.714]                     {
[17:38:33.714]                       inherits <- base::inherits
[17:38:33.714]                       invokeRestart <- base::invokeRestart
[17:38:33.714]                       is.null <- base::is.null
[17:38:33.714]                       muffled <- FALSE
[17:38:33.714]                       if (inherits(cond, "message")) {
[17:38:33.714]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:33.714]                         if (muffled) 
[17:38:33.714]                           invokeRestart("muffleMessage")
[17:38:33.714]                       }
[17:38:33.714]                       else if (inherits(cond, "warning")) {
[17:38:33.714]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:33.714]                         if (muffled) 
[17:38:33.714]                           invokeRestart("muffleWarning")
[17:38:33.714]                       }
[17:38:33.714]                       else if (inherits(cond, "condition")) {
[17:38:33.714]                         if (!is.null(pattern)) {
[17:38:33.714]                           computeRestarts <- base::computeRestarts
[17:38:33.714]                           grepl <- base::grepl
[17:38:33.714]                           restarts <- computeRestarts(cond)
[17:38:33.714]                           for (restart in restarts) {
[17:38:33.714]                             name <- restart$name
[17:38:33.714]                             if (is.null(name)) 
[17:38:33.714]                               next
[17:38:33.714]                             if (!grepl(pattern, name)) 
[17:38:33.714]                               next
[17:38:33.714]                             invokeRestart(restart)
[17:38:33.714]                             muffled <- TRUE
[17:38:33.714]                             break
[17:38:33.714]                           }
[17:38:33.714]                         }
[17:38:33.714]                       }
[17:38:33.714]                       invisible(muffled)
[17:38:33.714]                     }
[17:38:33.714]                     muffleCondition(cond, pattern = "^muffle")
[17:38:33.714]                   }
[17:38:33.714]                 }
[17:38:33.714]             }
[17:38:33.714]         }))
[17:38:33.714]     }, error = function(ex) {
[17:38:33.714]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:33.714]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:33.714]                 ...future.rng), started = ...future.startTime, 
[17:38:33.714]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:33.714]             version = "1.8"), class = "FutureResult")
[17:38:33.714]     }, finally = {
[17:38:33.714]         if (!identical(...future.workdir, getwd())) 
[17:38:33.714]             setwd(...future.workdir)
[17:38:33.714]         {
[17:38:33.714]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:33.714]                 ...future.oldOptions$nwarnings <- NULL
[17:38:33.714]             }
[17:38:33.714]             base::options(...future.oldOptions)
[17:38:33.714]             if (.Platform$OS.type == "windows") {
[17:38:33.714]                 old_names <- names(...future.oldEnvVars)
[17:38:33.714]                 envs <- base::Sys.getenv()
[17:38:33.714]                 names <- names(envs)
[17:38:33.714]                 common <- intersect(names, old_names)
[17:38:33.714]                 added <- setdiff(names, old_names)
[17:38:33.714]                 removed <- setdiff(old_names, names)
[17:38:33.714]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:33.714]                   envs[common]]
[17:38:33.714]                 NAMES <- toupper(changed)
[17:38:33.714]                 args <- list()
[17:38:33.714]                 for (kk in seq_along(NAMES)) {
[17:38:33.714]                   name <- changed[[kk]]
[17:38:33.714]                   NAME <- NAMES[[kk]]
[17:38:33.714]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:33.714]                     next
[17:38:33.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:33.714]                 }
[17:38:33.714]                 NAMES <- toupper(added)
[17:38:33.714]                 for (kk in seq_along(NAMES)) {
[17:38:33.714]                   name <- added[[kk]]
[17:38:33.714]                   NAME <- NAMES[[kk]]
[17:38:33.714]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:33.714]                     next
[17:38:33.714]                   args[[name]] <- ""
[17:38:33.714]                 }
[17:38:33.714]                 NAMES <- toupper(removed)
[17:38:33.714]                 for (kk in seq_along(NAMES)) {
[17:38:33.714]                   name <- removed[[kk]]
[17:38:33.714]                   NAME <- NAMES[[kk]]
[17:38:33.714]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:33.714]                     next
[17:38:33.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:33.714]                 }
[17:38:33.714]                 if (length(args) > 0) 
[17:38:33.714]                   base::do.call(base::Sys.setenv, args = args)
[17:38:33.714]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:33.714]             }
[17:38:33.714]             else {
[17:38:33.714]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:33.714]             }
[17:38:33.714]             {
[17:38:33.714]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:33.714]                   0L) {
[17:38:33.714]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:33.714]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:33.714]                   base::options(opts)
[17:38:33.714]                 }
[17:38:33.714]                 {
[17:38:33.714]                   {
[17:38:33.714]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:33.714]                     NULL
[17:38:33.714]                   }
[17:38:33.714]                   options(future.plan = NULL)
[17:38:33.714]                   if (is.na(NA_character_)) 
[17:38:33.714]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:33.714]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:33.714]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:33.714]                     .init = FALSE)
[17:38:33.714]                 }
[17:38:33.714]             }
[17:38:33.714]         }
[17:38:33.714]     })
[17:38:33.714]     if (FALSE) {
[17:38:33.714]         base::sink(type = "output", split = FALSE)
[17:38:33.714]         if (NA) {
[17:38:33.714]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:33.714]         }
[17:38:33.714]         else {
[17:38:33.714]             ...future.result["stdout"] <- base::list(NULL)
[17:38:33.714]         }
[17:38:33.714]         base::close(...future.stdout)
[17:38:33.714]         ...future.stdout <- NULL
[17:38:33.714]     }
[17:38:33.714]     ...future.result$conditions <- ...future.conditions
[17:38:33.714]     ...future.result$finished <- base::Sys.time()
[17:38:33.714]     ...future.result
[17:38:33.714] }
[17:38:33.717] assign_globals() ...
[17:38:33.717] List of 5
[17:38:33.717]  $ ...future.FUN            :function (x, y)  
[17:38:33.717]  $ MoreArgs                 : NULL
[17:38:33.717]  $ ...future.elements_ii    :List of 2
[17:38:33.717]   ..$ :List of 1
[17:38:33.717]   .. ..$ : int 0
[17:38:33.717]   ..$ :List of 1
[17:38:33.717]   .. ..$ : int 1
[17:38:33.717]  $ ...future.seeds_ii       : NULL
[17:38:33.717]  $ ...future.globals.maxSize: NULL
[17:38:33.717]  - attr(*, "where")=List of 5
[17:38:33.717]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:33.717]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:38:33.717]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:33.717]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:33.717]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:33.717]  - attr(*, "resolved")= logi FALSE
[17:38:33.717]  - attr(*, "total_size")= num 6368
[17:38:33.717]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:33.717]  - attr(*, "already-done")= logi TRUE
[17:38:33.735] - reassign environment for ‘...future.FUN’
[17:38:33.735] - copied ‘...future.FUN’ to environment
[17:38:33.735] - copied ‘MoreArgs’ to environment
[17:38:33.735] - copied ‘...future.elements_ii’ to environment
[17:38:33.735] - copied ‘...future.seeds_ii’ to environment
[17:38:33.735] - copied ‘...future.globals.maxSize’ to environment
[17:38:33.735] assign_globals() ... done
[17:38:33.736] requestCore(): workers = 2
[17:38:33.738] MulticoreFuture started
[17:38:33.739] - Launch lazy future ... done
[17:38:33.739] run() for ‘MulticoreFuture’ ... done
[17:38:33.739] plan(): Setting new future strategy stack:
[17:38:33.739] Created future:
[17:38:33.740] List of future strategies:
[17:38:33.740] 1. sequential:
[17:38:33.740]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:33.740]    - tweaked: FALSE
[17:38:33.740]    - call: NULL
[17:38:33.741] plan(): nbrOfWorkers() = 1
[17:38:33.743] plan(): Setting new future strategy stack:
[17:38:33.744] List of future strategies:
[17:38:33.744] 1. multicore:
[17:38:33.744]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:33.744]    - tweaked: FALSE
[17:38:33.744]    - call: plan(strategy)
[17:38:33.750] plan(): nbrOfWorkers() = 2
[17:38:33.740] MulticoreFuture:
[17:38:33.740] Label: ‘future_mapply-2’
[17:38:33.740] Expression:
[17:38:33.740] {
[17:38:33.740]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:33.740]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:33.740]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:33.740]         on.exit(options(oopts), add = TRUE)
[17:38:33.740]     }
[17:38:33.740]     {
[17:38:33.740]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:33.740]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:38:33.740]         do.call(mapply, args = args)
[17:38:33.740]     }
[17:38:33.740] }
[17:38:33.740] Lazy evaluation: FALSE
[17:38:33.740] Asynchronous evaluation: TRUE
[17:38:33.740] Local evaluation: TRUE
[17:38:33.740] Environment: R_GlobalEnv
[17:38:33.740] Capture standard output: NA
[17:38:33.740] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:33.740] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:33.740] Packages: <none>
[17:38:33.740] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:33.740] Resolved: TRUE
[17:38:33.740] Value: <not collected>
[17:38:33.740] Conditions captured: <none>
[17:38:33.740] Early signaling: FALSE
[17:38:33.740] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:33.740] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:33.751] Chunk #2 of 2 ... DONE
[17:38:33.751] Launching 2 futures (chunks) ... DONE
[17:38:33.751] Resolving 2 futures (chunks) ...
[17:38:33.752] resolve() on list ...
[17:38:33.752]  recursive: 0
[17:38:33.752]  length: 2
[17:38:33.752] 
[17:38:33.763] Future #2
[17:38:33.763] result() for MulticoreFuture ...
[17:38:33.765] result() for MulticoreFuture ...
[17:38:33.765] result() for MulticoreFuture ... done
[17:38:33.765] result() for MulticoreFuture ... done
[17:38:33.765] result() for MulticoreFuture ...
[17:38:33.766] result() for MulticoreFuture ... done
[17:38:33.766] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:38:33.766] - nx: 2
[17:38:33.766] - relay: TRUE
[17:38:33.767] - stdout: TRUE
[17:38:33.767] - signal: TRUE
[17:38:33.767] - resignal: FALSE
[17:38:33.767] - force: TRUE
[17:38:33.767] - relayed: [n=2] FALSE, FALSE
[17:38:33.767] - queued futures: [n=2] FALSE, FALSE
[17:38:33.767]  - until=1
[17:38:33.768]  - relaying element #1
[17:38:33.768] - relayed: [n=2] FALSE, FALSE
[17:38:33.768] - queued futures: [n=2] FALSE, TRUE
[17:38:33.768] signalConditionsASAP(NULL, pos=2) ... done
[17:38:33.768]  length: 1 (resolved future 2)
[17:38:34.188] plan(): Setting new future strategy stack:
[17:38:34.188] List of future strategies:
[17:38:34.188] 1. multicore:
[17:38:34.188]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:34.188]    - tweaked: FALSE
[17:38:34.188]    - call: plan(strategy)
[17:38:34.192] plan(): nbrOfWorkers() = 2
[17:38:34.193] Future #1
[17:38:34.193] result() for MulticoreFuture ...
[17:38:34.194] result() for MulticoreFuture ...
[17:38:34.194] result() for MulticoreFuture ... done
[17:38:34.194] result() for MulticoreFuture ... done
[17:38:34.194] result() for MulticoreFuture ...
[17:38:34.194] result() for MulticoreFuture ... done
[17:38:34.194] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:38:34.194] - nx: 2
[17:38:34.195] - relay: TRUE
[17:38:34.195] - stdout: TRUE
[17:38:34.195] - signal: TRUE
[17:38:34.195] - resignal: FALSE
[17:38:34.195] - force: TRUE
[17:38:34.195] - relayed: [n=2] FALSE, FALSE
[17:38:34.195] - queued futures: [n=2] FALSE, TRUE
[17:38:34.195]  - until=1
[17:38:34.195]  - relaying element #1
[17:38:34.196] result() for MulticoreFuture ...
[17:38:34.196] result() for MulticoreFuture ... done
[17:38:34.196] result() for MulticoreFuture ...
[17:38:34.196] result() for MulticoreFuture ... done
[17:38:34.196] result() for MulticoreFuture ...
[17:38:34.196] result() for MulticoreFuture ... done
[17:38:34.196] result() for MulticoreFuture ...
[17:38:34.196] result() for MulticoreFuture ... done
[17:38:34.197] - relayed: [n=2] TRUE, FALSE
[17:38:34.197] - queued futures: [n=2] TRUE, TRUE
[17:38:34.197] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:38:34.197]  length: 0 (resolved future 1)
[17:38:34.197] Relaying remaining futures
[17:38:34.197] signalConditionsASAP(NULL, pos=0) ...
[17:38:34.197] - nx: 2
[17:38:34.197] - relay: TRUE
[17:38:34.197] - stdout: TRUE
[17:38:34.198] - signal: TRUE
[17:38:34.198] - resignal: FALSE
[17:38:34.198] - force: TRUE
[17:38:34.198] - relayed: [n=2] TRUE, FALSE
[17:38:34.198] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:34.198]  - relaying element #2
[17:38:34.198] result() for MulticoreFuture ...
[17:38:34.198] result() for MulticoreFuture ... done
[17:38:34.198] result() for MulticoreFuture ...
[17:38:34.199] result() for MulticoreFuture ... done
[17:38:34.199] result() for MulticoreFuture ...
[17:38:34.199] result() for MulticoreFuture ... done
[17:38:34.199] result() for MulticoreFuture ...
[17:38:34.199] result() for MulticoreFuture ... done
[17:38:34.199] - relayed: [n=2] TRUE, TRUE
[17:38:34.199] - queued futures: [n=2] TRUE, TRUE
[17:38:34.199] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:38:34.200] resolve() on list ... DONE
[17:38:34.200] result() for MulticoreFuture ...
[17:38:34.200] result() for MulticoreFuture ... done
[17:38:34.200] result() for MulticoreFuture ...
[17:38:34.200] result() for MulticoreFuture ... done
[17:38:34.200] result() for MulticoreFuture ...
[17:38:34.200] result() for MulticoreFuture ... done
[17:38:34.200] result() for MulticoreFuture ...
[17:38:34.201] result() for MulticoreFuture ... done
[17:38:34.201]  - Number of value chunks collected: 2
[17:38:34.201] Resolving 2 futures (chunks) ... DONE
[17:38:34.201] Reducing values from 2 chunks ...
[17:38:34.201]  - Number of values collected after concatenation: 2
[17:38:34.201]  - Number of values expected: 2
[17:38:34.201] Reducing values from 2 chunks ... DONE
[17:38:34.201] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[17:38:34.202] plan(): Setting new future strategy stack:
[17:38:34.202] List of future strategies:
[17:38:34.202] 1. multisession:
[17:38:34.202]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:38:34.202]    - tweaked: FALSE
[17:38:34.202]    - call: plan(strategy)
[17:38:34.202] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:38:34.203] multisession:
[17:38:34.203] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:38:34.203] - tweaked: FALSE
[17:38:34.203] - call: plan(strategy)
[17:38:34.209] getGlobalsAndPackages() ...
[17:38:34.209] Not searching for globals
[17:38:34.209] - globals: [0] <none>
[17:38:34.209] getGlobalsAndPackages() ... DONE
[17:38:34.210] [local output] makeClusterPSOCK() ...
[17:38:34.257] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:38:34.258] [local output] Base port: 11357
[17:38:34.258] [local output] Getting setup options for 2 cluster nodes ...
[17:38:34.258] [local output]  - Node 1 of 2 ...
[17:38:34.258] [local output] localMachine=TRUE => revtunnel=FALSE

[17:38:34.259] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpBrP0ee/worker.rank=1.parallelly.parent=37817.93b958498390.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpBrP0ee/worker.rank=1.parallelly.parent=37817.93b958498390.pid")'’
[17:38:34.449] - Possible to infer worker's PID: TRUE
[17:38:34.449] [local output] Rscript port: 11357

[17:38:34.449] [local output]  - Node 2 of 2 ...
[17:38:34.450] [local output] localMachine=TRUE => revtunnel=FALSE

[17:38:34.450] [local output] Rscript port: 11357

[17:38:34.451] [local output] Getting setup options for 2 cluster nodes ... done
[17:38:34.451] [local output]  - Parallel setup requested for some PSOCK nodes
[17:38:34.451] [local output] Setting up PSOCK nodes in parallel
[17:38:34.451] List of 36
[17:38:34.451]  $ worker          : chr "localhost"
[17:38:34.451]   ..- attr(*, "localhost")= logi TRUE
[17:38:34.451]  $ master          : chr "localhost"
[17:38:34.451]  $ port            : int 11357
[17:38:34.451]  $ connectTimeout  : num 120
[17:38:34.451]  $ timeout         : num 2592000
[17:38:34.451]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:38:34.451]  $ homogeneous     : logi TRUE
[17:38:34.451]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:38:34.451]  $ rscript_envs    : NULL
[17:38:34.451]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:38:34.451]  $ rscript_startup : NULL
[17:38:34.451]  $ rscript_sh      : chr "sh"
[17:38:34.451]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:38:34.451]  $ methods         : logi TRUE
[17:38:34.451]  $ socketOptions   : chr "no-delay"
[17:38:34.451]  $ useXDR          : logi FALSE
[17:38:34.451]  $ outfile         : chr "/dev/null"
[17:38:34.451]  $ renice          : int NA
[17:38:34.451]  $ rshcmd          : NULL
[17:38:34.451]  $ user            : chr(0) 
[17:38:34.451]  $ revtunnel       : logi FALSE
[17:38:34.451]  $ rshlogfile      : NULL
[17:38:34.451]  $ rshopts         : chr(0) 
[17:38:34.451]  $ rank            : int 1
[17:38:34.451]  $ manual          : logi FALSE
[17:38:34.451]  $ dryrun          : logi FALSE
[17:38:34.451]  $ quiet           : logi FALSE
[17:38:34.451]  $ setup_strategy  : chr "parallel"
[17:38:34.451]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:38:34.451]  $ pidfile         : chr "/tmp/RtmpBrP0ee/worker.rank=1.parallelly.parent=37817.93b958498390.pid"
[17:38:34.451]  $ rshcmd_label    : NULL
[17:38:34.451]  $ rsh_call        : NULL
[17:38:34.451]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:38:34.451]  $ localMachine    : logi TRUE
[17:38:34.451]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:38:34.451]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:38:34.451]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:38:34.451]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:38:34.451]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:38:34.451]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:38:34.451]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:38:34.451]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:38:34.451]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:38:34.451]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:38:34.451]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:38:34.451]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:38:34.451]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:38:34.451]  $ arguments       :List of 28
[17:38:34.451]   ..$ worker          : chr "localhost"
[17:38:34.451]   ..$ master          : NULL
[17:38:34.451]   ..$ port            : int 11357
[17:38:34.451]   ..$ connectTimeout  : num 120
[17:38:34.451]   ..$ timeout         : num 2592000
[17:38:34.451]   ..$ rscript         : NULL
[17:38:34.451]   ..$ homogeneous     : NULL
[17:38:34.451]   ..$ rscript_args    : NULL
[17:38:34.451]   ..$ rscript_envs    : NULL
[17:38:34.451]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:38:34.451]   ..$ rscript_startup : NULL
[17:38:34.451]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:38:34.451]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:38:34.451]   ..$ methods         : logi TRUE
[17:38:34.451]   ..$ socketOptions   : chr "no-delay"
[17:38:34.451]   ..$ useXDR          : logi FALSE
[17:38:34.451]   ..$ outfile         : chr "/dev/null"
[17:38:34.451]   ..$ renice          : int NA
[17:38:34.451]   ..$ rshcmd          : NULL
[17:38:34.451]   ..$ user            : NULL
[17:38:34.451]   ..$ revtunnel       : logi NA
[17:38:34.451]   ..$ rshlogfile      : NULL
[17:38:34.451]   ..$ rshopts         : NULL
[17:38:34.451]   ..$ rank            : int 1
[17:38:34.451]   ..$ manual          : logi FALSE
[17:38:34.451]   ..$ dryrun          : logi FALSE
[17:38:34.451]   ..$ quiet           : logi FALSE
[17:38:34.451]   ..$ setup_strategy  : chr "parallel"
[17:38:34.451]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:38:34.468] [local output] System call to launch all workers:
[17:38:34.468] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpBrP0ee/worker.rank=1.parallelly.parent=37817.93b958498390.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11357 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:38:34.468] [local output] Starting PSOCK main server
[17:38:34.474] [local output] Workers launched
[17:38:34.474] [local output] Waiting for workers to connect back
[17:38:34.474]  - [local output] 0 workers out of 2 ready
[17:38:34.717]  - [local output] 0 workers out of 2 ready
[17:38:34.717]  - [local output] 1 workers out of 2 ready
[17:38:34.719]  - [local output] 1 workers out of 2 ready
[17:38:34.719]  - [local output] 2 workers out of 2 ready
[17:38:34.719] [local output] Launching of workers completed
[17:38:34.720] [local output] Collecting session information from workers
[17:38:34.721] [local output]  - Worker #1 of 2
[17:38:34.721] [local output]  - Worker #2 of 2
[17:38:34.721] [local output] makeClusterPSOCK() ... done
[17:38:34.733] Packages needed by the future expression (n = 0): <none>
[17:38:34.733] Packages needed by future strategies (n = 0): <none>
[17:38:34.733] {
[17:38:34.733]     {
[17:38:34.733]         {
[17:38:34.733]             ...future.startTime <- base::Sys.time()
[17:38:34.733]             {
[17:38:34.733]                 {
[17:38:34.733]                   {
[17:38:34.733]                     {
[17:38:34.733]                       base::local({
[17:38:34.733]                         has_future <- base::requireNamespace("future", 
[17:38:34.733]                           quietly = TRUE)
[17:38:34.733]                         if (has_future) {
[17:38:34.733]                           ns <- base::getNamespace("future")
[17:38:34.733]                           version <- ns[[".package"]][["version"]]
[17:38:34.733]                           if (is.null(version)) 
[17:38:34.733]                             version <- utils::packageVersion("future")
[17:38:34.733]                         }
[17:38:34.733]                         else {
[17:38:34.733]                           version <- NULL
[17:38:34.733]                         }
[17:38:34.733]                         if (!has_future || version < "1.8.0") {
[17:38:34.733]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:34.733]                             "", base::R.version$version.string), 
[17:38:34.733]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:34.733]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:34.733]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:34.733]                               "release", "version")], collapse = " "), 
[17:38:34.733]                             hostname = base::Sys.info()[["nodename"]])
[17:38:34.733]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:34.733]                             info)
[17:38:34.733]                           info <- base::paste(info, collapse = "; ")
[17:38:34.733]                           if (!has_future) {
[17:38:34.733]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:34.733]                               info)
[17:38:34.733]                           }
[17:38:34.733]                           else {
[17:38:34.733]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:34.733]                               info, version)
[17:38:34.733]                           }
[17:38:34.733]                           base::stop(msg)
[17:38:34.733]                         }
[17:38:34.733]                       })
[17:38:34.733]                     }
[17:38:34.733]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:34.733]                     base::options(mc.cores = 1L)
[17:38:34.733]                   }
[17:38:34.733]                   ...future.strategy.old <- future::plan("list")
[17:38:34.733]                   options(future.plan = NULL)
[17:38:34.733]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:34.733]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:34.733]                 }
[17:38:34.733]                 ...future.workdir <- getwd()
[17:38:34.733]             }
[17:38:34.733]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:34.733]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:34.733]         }
[17:38:34.733]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:34.733]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:34.733]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:34.733]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:34.733]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:34.733]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:34.733]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:34.733]             base::names(...future.oldOptions))
[17:38:34.733]     }
[17:38:34.733]     if (FALSE) {
[17:38:34.733]     }
[17:38:34.733]     else {
[17:38:34.733]         if (TRUE) {
[17:38:34.733]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:34.733]                 open = "w")
[17:38:34.733]         }
[17:38:34.733]         else {
[17:38:34.733]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:34.733]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:34.733]         }
[17:38:34.733]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:34.733]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:34.733]             base::sink(type = "output", split = FALSE)
[17:38:34.733]             base::close(...future.stdout)
[17:38:34.733]         }, add = TRUE)
[17:38:34.733]     }
[17:38:34.733]     ...future.frame <- base::sys.nframe()
[17:38:34.733]     ...future.conditions <- base::list()
[17:38:34.733]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:34.733]     if (FALSE) {
[17:38:34.733]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:34.733]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:34.733]     }
[17:38:34.733]     ...future.result <- base::tryCatch({
[17:38:34.733]         base::withCallingHandlers({
[17:38:34.733]             ...future.value <- base::withVisible(base::local({
[17:38:34.733]                 ...future.makeSendCondition <- base::local({
[17:38:34.733]                   sendCondition <- NULL
[17:38:34.733]                   function(frame = 1L) {
[17:38:34.733]                     if (is.function(sendCondition)) 
[17:38:34.733]                       return(sendCondition)
[17:38:34.733]                     ns <- getNamespace("parallel")
[17:38:34.733]                     if (exists("sendData", mode = "function", 
[17:38:34.733]                       envir = ns)) {
[17:38:34.733]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:34.733]                         envir = ns)
[17:38:34.733]                       envir <- sys.frame(frame)
[17:38:34.733]                       master <- NULL
[17:38:34.733]                       while (!identical(envir, .GlobalEnv) && 
[17:38:34.733]                         !identical(envir, emptyenv())) {
[17:38:34.733]                         if (exists("master", mode = "list", envir = envir, 
[17:38:34.733]                           inherits = FALSE)) {
[17:38:34.733]                           master <- get("master", mode = "list", 
[17:38:34.733]                             envir = envir, inherits = FALSE)
[17:38:34.733]                           if (inherits(master, c("SOCKnode", 
[17:38:34.733]                             "SOCK0node"))) {
[17:38:34.733]                             sendCondition <<- function(cond) {
[17:38:34.733]                               data <- list(type = "VALUE", value = cond, 
[17:38:34.733]                                 success = TRUE)
[17:38:34.733]                               parallel_sendData(master, data)
[17:38:34.733]                             }
[17:38:34.733]                             return(sendCondition)
[17:38:34.733]                           }
[17:38:34.733]                         }
[17:38:34.733]                         frame <- frame + 1L
[17:38:34.733]                         envir <- sys.frame(frame)
[17:38:34.733]                       }
[17:38:34.733]                     }
[17:38:34.733]                     sendCondition <<- function(cond) NULL
[17:38:34.733]                   }
[17:38:34.733]                 })
[17:38:34.733]                 withCallingHandlers({
[17:38:34.733]                   NA
[17:38:34.733]                 }, immediateCondition = function(cond) {
[17:38:34.733]                   sendCondition <- ...future.makeSendCondition()
[17:38:34.733]                   sendCondition(cond)
[17:38:34.733]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:34.733]                   {
[17:38:34.733]                     inherits <- base::inherits
[17:38:34.733]                     invokeRestart <- base::invokeRestart
[17:38:34.733]                     is.null <- base::is.null
[17:38:34.733]                     muffled <- FALSE
[17:38:34.733]                     if (inherits(cond, "message")) {
[17:38:34.733]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:34.733]                       if (muffled) 
[17:38:34.733]                         invokeRestart("muffleMessage")
[17:38:34.733]                     }
[17:38:34.733]                     else if (inherits(cond, "warning")) {
[17:38:34.733]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:34.733]                       if (muffled) 
[17:38:34.733]                         invokeRestart("muffleWarning")
[17:38:34.733]                     }
[17:38:34.733]                     else if (inherits(cond, "condition")) {
[17:38:34.733]                       if (!is.null(pattern)) {
[17:38:34.733]                         computeRestarts <- base::computeRestarts
[17:38:34.733]                         grepl <- base::grepl
[17:38:34.733]                         restarts <- computeRestarts(cond)
[17:38:34.733]                         for (restart in restarts) {
[17:38:34.733]                           name <- restart$name
[17:38:34.733]                           if (is.null(name)) 
[17:38:34.733]                             next
[17:38:34.733]                           if (!grepl(pattern, name)) 
[17:38:34.733]                             next
[17:38:34.733]                           invokeRestart(restart)
[17:38:34.733]                           muffled <- TRUE
[17:38:34.733]                           break
[17:38:34.733]                         }
[17:38:34.733]                       }
[17:38:34.733]                     }
[17:38:34.733]                     invisible(muffled)
[17:38:34.733]                   }
[17:38:34.733]                   muffleCondition(cond)
[17:38:34.733]                 })
[17:38:34.733]             }))
[17:38:34.733]             future::FutureResult(value = ...future.value$value, 
[17:38:34.733]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:34.733]                   ...future.rng), globalenv = if (FALSE) 
[17:38:34.733]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:34.733]                     ...future.globalenv.names))
[17:38:34.733]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:34.733]         }, condition = base::local({
[17:38:34.733]             c <- base::c
[17:38:34.733]             inherits <- base::inherits
[17:38:34.733]             invokeRestart <- base::invokeRestart
[17:38:34.733]             length <- base::length
[17:38:34.733]             list <- base::list
[17:38:34.733]             seq.int <- base::seq.int
[17:38:34.733]             signalCondition <- base::signalCondition
[17:38:34.733]             sys.calls <- base::sys.calls
[17:38:34.733]             `[[` <- base::`[[`
[17:38:34.733]             `+` <- base::`+`
[17:38:34.733]             `<<-` <- base::`<<-`
[17:38:34.733]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:34.733]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:34.733]                   3L)]
[17:38:34.733]             }
[17:38:34.733]             function(cond) {
[17:38:34.733]                 is_error <- inherits(cond, "error")
[17:38:34.733]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:34.733]                   NULL)
[17:38:34.733]                 if (is_error) {
[17:38:34.733]                   sessionInformation <- function() {
[17:38:34.733]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:34.733]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:34.733]                       search = base::search(), system = base::Sys.info())
[17:38:34.733]                   }
[17:38:34.733]                   ...future.conditions[[length(...future.conditions) + 
[17:38:34.733]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:34.733]                     cond$call), session = sessionInformation(), 
[17:38:34.733]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:34.733]                   signalCondition(cond)
[17:38:34.733]                 }
[17:38:34.733]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:34.733]                 "immediateCondition"))) {
[17:38:34.733]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:34.733]                   ...future.conditions[[length(...future.conditions) + 
[17:38:34.733]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:34.733]                   if (TRUE && !signal) {
[17:38:34.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:34.733]                     {
[17:38:34.733]                       inherits <- base::inherits
[17:38:34.733]                       invokeRestart <- base::invokeRestart
[17:38:34.733]                       is.null <- base::is.null
[17:38:34.733]                       muffled <- FALSE
[17:38:34.733]                       if (inherits(cond, "message")) {
[17:38:34.733]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:34.733]                         if (muffled) 
[17:38:34.733]                           invokeRestart("muffleMessage")
[17:38:34.733]                       }
[17:38:34.733]                       else if (inherits(cond, "warning")) {
[17:38:34.733]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:34.733]                         if (muffled) 
[17:38:34.733]                           invokeRestart("muffleWarning")
[17:38:34.733]                       }
[17:38:34.733]                       else if (inherits(cond, "condition")) {
[17:38:34.733]                         if (!is.null(pattern)) {
[17:38:34.733]                           computeRestarts <- base::computeRestarts
[17:38:34.733]                           grepl <- base::grepl
[17:38:34.733]                           restarts <- computeRestarts(cond)
[17:38:34.733]                           for (restart in restarts) {
[17:38:34.733]                             name <- restart$name
[17:38:34.733]                             if (is.null(name)) 
[17:38:34.733]                               next
[17:38:34.733]                             if (!grepl(pattern, name)) 
[17:38:34.733]                               next
[17:38:34.733]                             invokeRestart(restart)
[17:38:34.733]                             muffled <- TRUE
[17:38:34.733]                             break
[17:38:34.733]                           }
[17:38:34.733]                         }
[17:38:34.733]                       }
[17:38:34.733]                       invisible(muffled)
[17:38:34.733]                     }
[17:38:34.733]                     muffleCondition(cond, pattern = "^muffle")
[17:38:34.733]                   }
[17:38:34.733]                 }
[17:38:34.733]                 else {
[17:38:34.733]                   if (TRUE) {
[17:38:34.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:34.733]                     {
[17:38:34.733]                       inherits <- base::inherits
[17:38:34.733]                       invokeRestart <- base::invokeRestart
[17:38:34.733]                       is.null <- base::is.null
[17:38:34.733]                       muffled <- FALSE
[17:38:34.733]                       if (inherits(cond, "message")) {
[17:38:34.733]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:34.733]                         if (muffled) 
[17:38:34.733]                           invokeRestart("muffleMessage")
[17:38:34.733]                       }
[17:38:34.733]                       else if (inherits(cond, "warning")) {
[17:38:34.733]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:34.733]                         if (muffled) 
[17:38:34.733]                           invokeRestart("muffleWarning")
[17:38:34.733]                       }
[17:38:34.733]                       else if (inherits(cond, "condition")) {
[17:38:34.733]                         if (!is.null(pattern)) {
[17:38:34.733]                           computeRestarts <- base::computeRestarts
[17:38:34.733]                           grepl <- base::grepl
[17:38:34.733]                           restarts <- computeRestarts(cond)
[17:38:34.733]                           for (restart in restarts) {
[17:38:34.733]                             name <- restart$name
[17:38:34.733]                             if (is.null(name)) 
[17:38:34.733]                               next
[17:38:34.733]                             if (!grepl(pattern, name)) 
[17:38:34.733]                               next
[17:38:34.733]                             invokeRestart(restart)
[17:38:34.733]                             muffled <- TRUE
[17:38:34.733]                             break
[17:38:34.733]                           }
[17:38:34.733]                         }
[17:38:34.733]                       }
[17:38:34.733]                       invisible(muffled)
[17:38:34.733]                     }
[17:38:34.733]                     muffleCondition(cond, pattern = "^muffle")
[17:38:34.733]                   }
[17:38:34.733]                 }
[17:38:34.733]             }
[17:38:34.733]         }))
[17:38:34.733]     }, error = function(ex) {
[17:38:34.733]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:34.733]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:34.733]                 ...future.rng), started = ...future.startTime, 
[17:38:34.733]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:34.733]             version = "1.8"), class = "FutureResult")
[17:38:34.733]     }, finally = {
[17:38:34.733]         if (!identical(...future.workdir, getwd())) 
[17:38:34.733]             setwd(...future.workdir)
[17:38:34.733]         {
[17:38:34.733]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:34.733]                 ...future.oldOptions$nwarnings <- NULL
[17:38:34.733]             }
[17:38:34.733]             base::options(...future.oldOptions)
[17:38:34.733]             if (.Platform$OS.type == "windows") {
[17:38:34.733]                 old_names <- names(...future.oldEnvVars)
[17:38:34.733]                 envs <- base::Sys.getenv()
[17:38:34.733]                 names <- names(envs)
[17:38:34.733]                 common <- intersect(names, old_names)
[17:38:34.733]                 added <- setdiff(names, old_names)
[17:38:34.733]                 removed <- setdiff(old_names, names)
[17:38:34.733]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:34.733]                   envs[common]]
[17:38:34.733]                 NAMES <- toupper(changed)
[17:38:34.733]                 args <- list()
[17:38:34.733]                 for (kk in seq_along(NAMES)) {
[17:38:34.733]                   name <- changed[[kk]]
[17:38:34.733]                   NAME <- NAMES[[kk]]
[17:38:34.733]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:34.733]                     next
[17:38:34.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:34.733]                 }
[17:38:34.733]                 NAMES <- toupper(added)
[17:38:34.733]                 for (kk in seq_along(NAMES)) {
[17:38:34.733]                   name <- added[[kk]]
[17:38:34.733]                   NAME <- NAMES[[kk]]
[17:38:34.733]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:34.733]                     next
[17:38:34.733]                   args[[name]] <- ""
[17:38:34.733]                 }
[17:38:34.733]                 NAMES <- toupper(removed)
[17:38:34.733]                 for (kk in seq_along(NAMES)) {
[17:38:34.733]                   name <- removed[[kk]]
[17:38:34.733]                   NAME <- NAMES[[kk]]
[17:38:34.733]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:34.733]                     next
[17:38:34.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:34.733]                 }
[17:38:34.733]                 if (length(args) > 0) 
[17:38:34.733]                   base::do.call(base::Sys.setenv, args = args)
[17:38:34.733]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:34.733]             }
[17:38:34.733]             else {
[17:38:34.733]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:34.733]             }
[17:38:34.733]             {
[17:38:34.733]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:34.733]                   0L) {
[17:38:34.733]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:34.733]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:34.733]                   base::options(opts)
[17:38:34.733]                 }
[17:38:34.733]                 {
[17:38:34.733]                   {
[17:38:34.733]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:34.733]                     NULL
[17:38:34.733]                   }
[17:38:34.733]                   options(future.plan = NULL)
[17:38:34.733]                   if (is.na(NA_character_)) 
[17:38:34.733]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:34.733]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:34.733]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:34.733]                     .init = FALSE)
[17:38:34.733]                 }
[17:38:34.733]             }
[17:38:34.733]         }
[17:38:34.733]     })
[17:38:34.733]     if (TRUE) {
[17:38:34.733]         base::sink(type = "output", split = FALSE)
[17:38:34.733]         if (TRUE) {
[17:38:34.733]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:34.733]         }
[17:38:34.733]         else {
[17:38:34.733]             ...future.result["stdout"] <- base::list(NULL)
[17:38:34.733]         }
[17:38:34.733]         base::close(...future.stdout)
[17:38:34.733]         ...future.stdout <- NULL
[17:38:34.733]     }
[17:38:34.733]     ...future.result$conditions <- ...future.conditions
[17:38:34.733]     ...future.result$finished <- base::Sys.time()
[17:38:34.733]     ...future.result
[17:38:34.733] }
[17:38:34.789] MultisessionFuture started
[17:38:34.789] result() for ClusterFuture ...
[17:38:34.790] receiveMessageFromWorker() for ClusterFuture ...
[17:38:34.790] - Validating connection of MultisessionFuture
[17:38:34.822] - received message: FutureResult
[17:38:34.822] - Received FutureResult
[17:38:34.822] - Erased future from FutureRegistry
[17:38:34.823] result() for ClusterFuture ...
[17:38:34.823] - result already collected: FutureResult
[17:38:34.823] result() for ClusterFuture ... done
[17:38:34.823] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:34.823] result() for ClusterFuture ... done
[17:38:34.823] result() for ClusterFuture ...
[17:38:34.823] - result already collected: FutureResult
[17:38:34.823] result() for ClusterFuture ... done
[17:38:34.824] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:38:34.827] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[17:38:34.828] future_lapply() ...
[17:38:34.832] Number of chunks: 2
[17:38:34.832] getGlobalsAndPackagesXApply() ...
[17:38:34.832]  - future.globals: TRUE
[17:38:34.832] getGlobalsAndPackages() ...
[17:38:34.833] Searching for globals...
[17:38:34.834] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:38:34.834] Searching for globals ... DONE
[17:38:34.835] Resolving globals: FALSE
[17:38:34.835] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:38:34.835] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:38:34.836] - globals: [1] ‘FUN’
[17:38:34.836] 
[17:38:34.836] getGlobalsAndPackages() ... DONE
[17:38:34.836]  - globals found/used: [n=1] ‘FUN’
[17:38:34.836]  - needed namespaces: [n=0] 
[17:38:34.836] Finding globals ... DONE
[17:38:34.836]  - use_args: TRUE
[17:38:34.836]  - Getting '...' globals ...
[17:38:34.837] resolve() on list ...
[17:38:34.837]  recursive: 0
[17:38:34.837]  length: 1
[17:38:34.837]  elements: ‘...’
[17:38:34.837]  length: 0 (resolved future 1)
[17:38:34.837] resolve() on list ... DONE
[17:38:34.838]    - '...' content: [n=0] 
[17:38:34.838] List of 1
[17:38:34.838]  $ ...: list()
[17:38:34.838]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:34.838]  - attr(*, "where")=List of 1
[17:38:34.838]   ..$ ...:<environment: 0x5628ace38830> 
[17:38:34.838]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:34.838]  - attr(*, "resolved")= logi TRUE
[17:38:34.838]  - attr(*, "total_size")= num NA
[17:38:34.841]  - Getting '...' globals ... DONE
[17:38:34.841] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:38:34.841] List of 2
[17:38:34.841]  $ ...future.FUN:function (x)  
[17:38:34.841]  $ ...          : list()
[17:38:34.841]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:34.841]  - attr(*, "where")=List of 2
[17:38:34.841]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:34.841]   ..$ ...          :<environment: 0x5628ace38830> 
[17:38:34.841]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:34.841]  - attr(*, "resolved")= logi FALSE
[17:38:34.841]  - attr(*, "total_size")= num 4720
[17:38:34.844] Packages to be attached in all futures: [n=0] 
[17:38:34.844] getGlobalsAndPackagesXApply() ... DONE
[17:38:34.845] Number of futures (= number of chunks): 2
[17:38:34.845] Launching 2 futures (chunks) ...
[17:38:34.845] Chunk #1 of 2 ...
[17:38:34.845]  - Finding globals in 'X' for chunk #1 ...
[17:38:34.845] getGlobalsAndPackages() ...
[17:38:34.845] Searching for globals...
[17:38:34.846] 
[17:38:34.846] Searching for globals ... DONE
[17:38:34.846] - globals: [0] <none>
[17:38:34.846] getGlobalsAndPackages() ... DONE
[17:38:34.846]    + additional globals found: [n=0] 
[17:38:34.846]    + additional namespaces needed: [n=0] 
[17:38:34.846]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:34.846]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:34.847]  - seeds: <none>
[17:38:34.847]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:34.847] getGlobalsAndPackages() ...
[17:38:34.847] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:34.847] Resolving globals: FALSE
[17:38:34.847] Tweak future expression to call with '...' arguments ...
[17:38:34.847] {
[17:38:34.847]     do.call(function(...) {
[17:38:34.847]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:34.847]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:34.847]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:34.847]             on.exit(options(oopts), add = TRUE)
[17:38:34.847]         }
[17:38:34.847]         {
[17:38:34.847]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:34.847]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:34.847]                 ...future.FUN(...future.X_jj, ...)
[17:38:34.847]             })
[17:38:34.847]         }
[17:38:34.847]     }, args = future.call.arguments)
[17:38:34.847] }
[17:38:34.848] Tweak future expression to call with '...' arguments ... DONE
[17:38:34.848] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:34.848] 
[17:38:34.848] getGlobalsAndPackages() ... DONE
[17:38:34.849] run() for ‘Future’ ...
[17:38:34.849] - state: ‘created’
[17:38:34.849] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:34.863] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:34.863] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:34.863]   - Field: ‘node’
[17:38:34.863]   - Field: ‘label’
[17:38:34.863]   - Field: ‘local’
[17:38:34.864]   - Field: ‘owner’
[17:38:34.864]   - Field: ‘envir’
[17:38:34.864]   - Field: ‘workers’
[17:38:34.864]   - Field: ‘packages’
[17:38:34.864]   - Field: ‘gc’
[17:38:34.864]   - Field: ‘conditions’
[17:38:34.864]   - Field: ‘persistent’
[17:38:34.864]   - Field: ‘expr’
[17:38:34.864]   - Field: ‘uuid’
[17:38:34.865]   - Field: ‘seed’
[17:38:34.865]   - Field: ‘version’
[17:38:34.865]   - Field: ‘result’
[17:38:34.865]   - Field: ‘asynchronous’
[17:38:34.865]   - Field: ‘calls’
[17:38:34.865]   - Field: ‘globals’
[17:38:34.865]   - Field: ‘stdout’
[17:38:34.865]   - Field: ‘earlySignal’
[17:38:34.866]   - Field: ‘lazy’
[17:38:34.866]   - Field: ‘state’
[17:38:34.866] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:34.866] - Launch lazy future ...
[17:38:34.866] Packages needed by the future expression (n = 0): <none>
[17:38:34.866] Packages needed by future strategies (n = 0): <none>
[17:38:34.867] {
[17:38:34.867]     {
[17:38:34.867]         {
[17:38:34.867]             ...future.startTime <- base::Sys.time()
[17:38:34.867]             {
[17:38:34.867]                 {
[17:38:34.867]                   {
[17:38:34.867]                     {
[17:38:34.867]                       base::local({
[17:38:34.867]                         has_future <- base::requireNamespace("future", 
[17:38:34.867]                           quietly = TRUE)
[17:38:34.867]                         if (has_future) {
[17:38:34.867]                           ns <- base::getNamespace("future")
[17:38:34.867]                           version <- ns[[".package"]][["version"]]
[17:38:34.867]                           if (is.null(version)) 
[17:38:34.867]                             version <- utils::packageVersion("future")
[17:38:34.867]                         }
[17:38:34.867]                         else {
[17:38:34.867]                           version <- NULL
[17:38:34.867]                         }
[17:38:34.867]                         if (!has_future || version < "1.8.0") {
[17:38:34.867]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:34.867]                             "", base::R.version$version.string), 
[17:38:34.867]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:34.867]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:34.867]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:34.867]                               "release", "version")], collapse = " "), 
[17:38:34.867]                             hostname = base::Sys.info()[["nodename"]])
[17:38:34.867]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:34.867]                             info)
[17:38:34.867]                           info <- base::paste(info, collapse = "; ")
[17:38:34.867]                           if (!has_future) {
[17:38:34.867]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:34.867]                               info)
[17:38:34.867]                           }
[17:38:34.867]                           else {
[17:38:34.867]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:34.867]                               info, version)
[17:38:34.867]                           }
[17:38:34.867]                           base::stop(msg)
[17:38:34.867]                         }
[17:38:34.867]                       })
[17:38:34.867]                     }
[17:38:34.867]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:34.867]                     base::options(mc.cores = 1L)
[17:38:34.867]                   }
[17:38:34.867]                   ...future.strategy.old <- future::plan("list")
[17:38:34.867]                   options(future.plan = NULL)
[17:38:34.867]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:34.867]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:34.867]                 }
[17:38:34.867]                 ...future.workdir <- getwd()
[17:38:34.867]             }
[17:38:34.867]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:34.867]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:34.867]         }
[17:38:34.867]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:34.867]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:34.867]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:34.867]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:34.867]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:34.867]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:34.867]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:34.867]             base::names(...future.oldOptions))
[17:38:34.867]     }
[17:38:34.867]     if (FALSE) {
[17:38:34.867]     }
[17:38:34.867]     else {
[17:38:34.867]         if (FALSE) {
[17:38:34.867]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:34.867]                 open = "w")
[17:38:34.867]         }
[17:38:34.867]         else {
[17:38:34.867]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:34.867]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:34.867]         }
[17:38:34.867]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:34.867]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:34.867]             base::sink(type = "output", split = FALSE)
[17:38:34.867]             base::close(...future.stdout)
[17:38:34.867]         }, add = TRUE)
[17:38:34.867]     }
[17:38:34.867]     ...future.frame <- base::sys.nframe()
[17:38:34.867]     ...future.conditions <- base::list()
[17:38:34.867]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:34.867]     if (FALSE) {
[17:38:34.867]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:34.867]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:34.867]     }
[17:38:34.867]     ...future.result <- base::tryCatch({
[17:38:34.867]         base::withCallingHandlers({
[17:38:34.867]             ...future.value <- base::withVisible(base::local({
[17:38:34.867]                 ...future.makeSendCondition <- base::local({
[17:38:34.867]                   sendCondition <- NULL
[17:38:34.867]                   function(frame = 1L) {
[17:38:34.867]                     if (is.function(sendCondition)) 
[17:38:34.867]                       return(sendCondition)
[17:38:34.867]                     ns <- getNamespace("parallel")
[17:38:34.867]                     if (exists("sendData", mode = "function", 
[17:38:34.867]                       envir = ns)) {
[17:38:34.867]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:34.867]                         envir = ns)
[17:38:34.867]                       envir <- sys.frame(frame)
[17:38:34.867]                       master <- NULL
[17:38:34.867]                       while (!identical(envir, .GlobalEnv) && 
[17:38:34.867]                         !identical(envir, emptyenv())) {
[17:38:34.867]                         if (exists("master", mode = "list", envir = envir, 
[17:38:34.867]                           inherits = FALSE)) {
[17:38:34.867]                           master <- get("master", mode = "list", 
[17:38:34.867]                             envir = envir, inherits = FALSE)
[17:38:34.867]                           if (inherits(master, c("SOCKnode", 
[17:38:34.867]                             "SOCK0node"))) {
[17:38:34.867]                             sendCondition <<- function(cond) {
[17:38:34.867]                               data <- list(type = "VALUE", value = cond, 
[17:38:34.867]                                 success = TRUE)
[17:38:34.867]                               parallel_sendData(master, data)
[17:38:34.867]                             }
[17:38:34.867]                             return(sendCondition)
[17:38:34.867]                           }
[17:38:34.867]                         }
[17:38:34.867]                         frame <- frame + 1L
[17:38:34.867]                         envir <- sys.frame(frame)
[17:38:34.867]                       }
[17:38:34.867]                     }
[17:38:34.867]                     sendCondition <<- function(cond) NULL
[17:38:34.867]                   }
[17:38:34.867]                 })
[17:38:34.867]                 withCallingHandlers({
[17:38:34.867]                   {
[17:38:34.867]                     do.call(function(...) {
[17:38:34.867]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:34.867]                       if (!identical(...future.globals.maxSize.org, 
[17:38:34.867]                         ...future.globals.maxSize)) {
[17:38:34.867]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:34.867]                         on.exit(options(oopts), add = TRUE)
[17:38:34.867]                       }
[17:38:34.867]                       {
[17:38:34.867]                         lapply(seq_along(...future.elements_ii), 
[17:38:34.867]                           FUN = function(jj) {
[17:38:34.867]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:34.867]                             ...future.FUN(...future.X_jj, ...)
[17:38:34.867]                           })
[17:38:34.867]                       }
[17:38:34.867]                     }, args = future.call.arguments)
[17:38:34.867]                   }
[17:38:34.867]                 }, immediateCondition = function(cond) {
[17:38:34.867]                   sendCondition <- ...future.makeSendCondition()
[17:38:34.867]                   sendCondition(cond)
[17:38:34.867]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:34.867]                   {
[17:38:34.867]                     inherits <- base::inherits
[17:38:34.867]                     invokeRestart <- base::invokeRestart
[17:38:34.867]                     is.null <- base::is.null
[17:38:34.867]                     muffled <- FALSE
[17:38:34.867]                     if (inherits(cond, "message")) {
[17:38:34.867]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:34.867]                       if (muffled) 
[17:38:34.867]                         invokeRestart("muffleMessage")
[17:38:34.867]                     }
[17:38:34.867]                     else if (inherits(cond, "warning")) {
[17:38:34.867]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:34.867]                       if (muffled) 
[17:38:34.867]                         invokeRestart("muffleWarning")
[17:38:34.867]                     }
[17:38:34.867]                     else if (inherits(cond, "condition")) {
[17:38:34.867]                       if (!is.null(pattern)) {
[17:38:34.867]                         computeRestarts <- base::computeRestarts
[17:38:34.867]                         grepl <- base::grepl
[17:38:34.867]                         restarts <- computeRestarts(cond)
[17:38:34.867]                         for (restart in restarts) {
[17:38:34.867]                           name <- restart$name
[17:38:34.867]                           if (is.null(name)) 
[17:38:34.867]                             next
[17:38:34.867]                           if (!grepl(pattern, name)) 
[17:38:34.867]                             next
[17:38:34.867]                           invokeRestart(restart)
[17:38:34.867]                           muffled <- TRUE
[17:38:34.867]                           break
[17:38:34.867]                         }
[17:38:34.867]                       }
[17:38:34.867]                     }
[17:38:34.867]                     invisible(muffled)
[17:38:34.867]                   }
[17:38:34.867]                   muffleCondition(cond)
[17:38:34.867]                 })
[17:38:34.867]             }))
[17:38:34.867]             future::FutureResult(value = ...future.value$value, 
[17:38:34.867]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:34.867]                   ...future.rng), globalenv = if (FALSE) 
[17:38:34.867]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:34.867]                     ...future.globalenv.names))
[17:38:34.867]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:34.867]         }, condition = base::local({
[17:38:34.867]             c <- base::c
[17:38:34.867]             inherits <- base::inherits
[17:38:34.867]             invokeRestart <- base::invokeRestart
[17:38:34.867]             length <- base::length
[17:38:34.867]             list <- base::list
[17:38:34.867]             seq.int <- base::seq.int
[17:38:34.867]             signalCondition <- base::signalCondition
[17:38:34.867]             sys.calls <- base::sys.calls
[17:38:34.867]             `[[` <- base::`[[`
[17:38:34.867]             `+` <- base::`+`
[17:38:34.867]             `<<-` <- base::`<<-`
[17:38:34.867]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:34.867]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:34.867]                   3L)]
[17:38:34.867]             }
[17:38:34.867]             function(cond) {
[17:38:34.867]                 is_error <- inherits(cond, "error")
[17:38:34.867]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:34.867]                   NULL)
[17:38:34.867]                 if (is_error) {
[17:38:34.867]                   sessionInformation <- function() {
[17:38:34.867]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:34.867]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:34.867]                       search = base::search(), system = base::Sys.info())
[17:38:34.867]                   }
[17:38:34.867]                   ...future.conditions[[length(...future.conditions) + 
[17:38:34.867]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:34.867]                     cond$call), session = sessionInformation(), 
[17:38:34.867]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:34.867]                   signalCondition(cond)
[17:38:34.867]                 }
[17:38:34.867]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:34.867]                 "immediateCondition"))) {
[17:38:34.867]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:34.867]                   ...future.conditions[[length(...future.conditions) + 
[17:38:34.867]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:34.867]                   if (TRUE && !signal) {
[17:38:34.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:34.867]                     {
[17:38:34.867]                       inherits <- base::inherits
[17:38:34.867]                       invokeRestart <- base::invokeRestart
[17:38:34.867]                       is.null <- base::is.null
[17:38:34.867]                       muffled <- FALSE
[17:38:34.867]                       if (inherits(cond, "message")) {
[17:38:34.867]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:34.867]                         if (muffled) 
[17:38:34.867]                           invokeRestart("muffleMessage")
[17:38:34.867]                       }
[17:38:34.867]                       else if (inherits(cond, "warning")) {
[17:38:34.867]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:34.867]                         if (muffled) 
[17:38:34.867]                           invokeRestart("muffleWarning")
[17:38:34.867]                       }
[17:38:34.867]                       else if (inherits(cond, "condition")) {
[17:38:34.867]                         if (!is.null(pattern)) {
[17:38:34.867]                           computeRestarts <- base::computeRestarts
[17:38:34.867]                           grepl <- base::grepl
[17:38:34.867]                           restarts <- computeRestarts(cond)
[17:38:34.867]                           for (restart in restarts) {
[17:38:34.867]                             name <- restart$name
[17:38:34.867]                             if (is.null(name)) 
[17:38:34.867]                               next
[17:38:34.867]                             if (!grepl(pattern, name)) 
[17:38:34.867]                               next
[17:38:34.867]                             invokeRestart(restart)
[17:38:34.867]                             muffled <- TRUE
[17:38:34.867]                             break
[17:38:34.867]                           }
[17:38:34.867]                         }
[17:38:34.867]                       }
[17:38:34.867]                       invisible(muffled)
[17:38:34.867]                     }
[17:38:34.867]                     muffleCondition(cond, pattern = "^muffle")
[17:38:34.867]                   }
[17:38:34.867]                 }
[17:38:34.867]                 else {
[17:38:34.867]                   if (TRUE) {
[17:38:34.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:34.867]                     {
[17:38:34.867]                       inherits <- base::inherits
[17:38:34.867]                       invokeRestart <- base::invokeRestart
[17:38:34.867]                       is.null <- base::is.null
[17:38:34.867]                       muffled <- FALSE
[17:38:34.867]                       if (inherits(cond, "message")) {
[17:38:34.867]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:34.867]                         if (muffled) 
[17:38:34.867]                           invokeRestart("muffleMessage")
[17:38:34.867]                       }
[17:38:34.867]                       else if (inherits(cond, "warning")) {
[17:38:34.867]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:34.867]                         if (muffled) 
[17:38:34.867]                           invokeRestart("muffleWarning")
[17:38:34.867]                       }
[17:38:34.867]                       else if (inherits(cond, "condition")) {
[17:38:34.867]                         if (!is.null(pattern)) {
[17:38:34.867]                           computeRestarts <- base::computeRestarts
[17:38:34.867]                           grepl <- base::grepl
[17:38:34.867]                           restarts <- computeRestarts(cond)
[17:38:34.867]                           for (restart in restarts) {
[17:38:34.867]                             name <- restart$name
[17:38:34.867]                             if (is.null(name)) 
[17:38:34.867]                               next
[17:38:34.867]                             if (!grepl(pattern, name)) 
[17:38:34.867]                               next
[17:38:34.867]                             invokeRestart(restart)
[17:38:34.867]                             muffled <- TRUE
[17:38:34.867]                             break
[17:38:34.867]                           }
[17:38:34.867]                         }
[17:38:34.867]                       }
[17:38:34.867]                       invisible(muffled)
[17:38:34.867]                     }
[17:38:34.867]                     muffleCondition(cond, pattern = "^muffle")
[17:38:34.867]                   }
[17:38:34.867]                 }
[17:38:34.867]             }
[17:38:34.867]         }))
[17:38:34.867]     }, error = function(ex) {
[17:38:34.867]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:34.867]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:34.867]                 ...future.rng), started = ...future.startTime, 
[17:38:34.867]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:34.867]             version = "1.8"), class = "FutureResult")
[17:38:34.867]     }, finally = {
[17:38:34.867]         if (!identical(...future.workdir, getwd())) 
[17:38:34.867]             setwd(...future.workdir)
[17:38:34.867]         {
[17:38:34.867]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:34.867]                 ...future.oldOptions$nwarnings <- NULL
[17:38:34.867]             }
[17:38:34.867]             base::options(...future.oldOptions)
[17:38:34.867]             if (.Platform$OS.type == "windows") {
[17:38:34.867]                 old_names <- names(...future.oldEnvVars)
[17:38:34.867]                 envs <- base::Sys.getenv()
[17:38:34.867]                 names <- names(envs)
[17:38:34.867]                 common <- intersect(names, old_names)
[17:38:34.867]                 added <- setdiff(names, old_names)
[17:38:34.867]                 removed <- setdiff(old_names, names)
[17:38:34.867]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:34.867]                   envs[common]]
[17:38:34.867]                 NAMES <- toupper(changed)
[17:38:34.867]                 args <- list()
[17:38:34.867]                 for (kk in seq_along(NAMES)) {
[17:38:34.867]                   name <- changed[[kk]]
[17:38:34.867]                   NAME <- NAMES[[kk]]
[17:38:34.867]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:34.867]                     next
[17:38:34.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:34.867]                 }
[17:38:34.867]                 NAMES <- toupper(added)
[17:38:34.867]                 for (kk in seq_along(NAMES)) {
[17:38:34.867]                   name <- added[[kk]]
[17:38:34.867]                   NAME <- NAMES[[kk]]
[17:38:34.867]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:34.867]                     next
[17:38:34.867]                   args[[name]] <- ""
[17:38:34.867]                 }
[17:38:34.867]                 NAMES <- toupper(removed)
[17:38:34.867]                 for (kk in seq_along(NAMES)) {
[17:38:34.867]                   name <- removed[[kk]]
[17:38:34.867]                   NAME <- NAMES[[kk]]
[17:38:34.867]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:34.867]                     next
[17:38:34.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:34.867]                 }
[17:38:34.867]                 if (length(args) > 0) 
[17:38:34.867]                   base::do.call(base::Sys.setenv, args = args)
[17:38:34.867]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:34.867]             }
[17:38:34.867]             else {
[17:38:34.867]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:34.867]             }
[17:38:34.867]             {
[17:38:34.867]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:34.867]                   0L) {
[17:38:34.867]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:34.867]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:34.867]                   base::options(opts)
[17:38:34.867]                 }
[17:38:34.867]                 {
[17:38:34.867]                   {
[17:38:34.867]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:34.867]                     NULL
[17:38:34.867]                   }
[17:38:34.867]                   options(future.plan = NULL)
[17:38:34.867]                   if (is.na(NA_character_)) 
[17:38:34.867]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:34.867]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:34.867]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:34.867]                     .init = FALSE)
[17:38:34.867]                 }
[17:38:34.867]             }
[17:38:34.867]         }
[17:38:34.867]     })
[17:38:34.867]     if (TRUE) {
[17:38:34.867]         base::sink(type = "output", split = FALSE)
[17:38:34.867]         if (FALSE) {
[17:38:34.867]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:34.867]         }
[17:38:34.867]         else {
[17:38:34.867]             ...future.result["stdout"] <- base::list(NULL)
[17:38:34.867]         }
[17:38:34.867]         base::close(...future.stdout)
[17:38:34.867]         ...future.stdout <- NULL
[17:38:34.867]     }
[17:38:34.867]     ...future.result$conditions <- ...future.conditions
[17:38:34.867]     ...future.result$finished <- base::Sys.time()
[17:38:34.867]     ...future.result
[17:38:34.867] }
[17:38:34.870] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[17:38:34.870] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[17:38:34.871] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[17:38:34.871] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:38:34.871] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:38:34.872] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:38:34.872] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:38:34.872] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:38:34.873] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:38:34.873] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:38:34.873] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:38:34.873] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[17:38:34.874] MultisessionFuture started
[17:38:34.874] - Launch lazy future ... done
[17:38:34.874] run() for ‘MultisessionFuture’ ... done
[17:38:34.874] Created future:
[17:38:34.874] MultisessionFuture:
[17:38:34.874] Label: ‘future_lapply-1’
[17:38:34.874] Expression:
[17:38:34.874] {
[17:38:34.874]     do.call(function(...) {
[17:38:34.874]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:34.874]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:34.874]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:34.874]             on.exit(options(oopts), add = TRUE)
[17:38:34.874]         }
[17:38:34.874]         {
[17:38:34.874]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:34.874]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:34.874]                 ...future.FUN(...future.X_jj, ...)
[17:38:34.874]             })
[17:38:34.874]         }
[17:38:34.874]     }, args = future.call.arguments)
[17:38:34.874] }
[17:38:34.874] Lazy evaluation: FALSE
[17:38:34.874] Asynchronous evaluation: TRUE
[17:38:34.874] Local evaluation: TRUE
[17:38:34.874] Environment: R_GlobalEnv
[17:38:34.874] Capture standard output: FALSE
[17:38:34.874] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:34.874] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:34.874] Packages: <none>
[17:38:34.874] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:34.874] Resolved: FALSE
[17:38:34.874] Value: <not collected>
[17:38:34.874] Conditions captured: <none>
[17:38:34.874] Early signaling: FALSE
[17:38:34.874] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:34.874] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:34.886] Chunk #1 of 2 ... DONE
[17:38:34.887] Chunk #2 of 2 ...
[17:38:34.887]  - Finding globals in 'X' for chunk #2 ...
[17:38:34.887] getGlobalsAndPackages() ...
[17:38:34.887] Searching for globals...
[17:38:34.887] 
[17:38:34.887] Searching for globals ... DONE
[17:38:34.888] - globals: [0] <none>
[17:38:34.888] getGlobalsAndPackages() ... DONE
[17:38:34.888]    + additional globals found: [n=0] 
[17:38:34.888]    + additional namespaces needed: [n=0] 
[17:38:34.888]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:34.888]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:34.888]  - seeds: <none>
[17:38:34.888]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:34.889] getGlobalsAndPackages() ...
[17:38:34.889] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:34.889] Resolving globals: FALSE
[17:38:34.889] Tweak future expression to call with '...' arguments ...
[17:38:34.889] {
[17:38:34.889]     do.call(function(...) {
[17:38:34.889]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:34.889]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:34.889]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:34.889]             on.exit(options(oopts), add = TRUE)
[17:38:34.889]         }
[17:38:34.889]         {
[17:38:34.889]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:34.889]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:34.889]                 ...future.FUN(...future.X_jj, ...)
[17:38:34.889]             })
[17:38:34.889]         }
[17:38:34.889]     }, args = future.call.arguments)
[17:38:34.889] }
[17:38:34.889] Tweak future expression to call with '...' arguments ... DONE
[17:38:34.890] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:34.890] 
[17:38:34.890] getGlobalsAndPackages() ... DONE
[17:38:34.890] run() for ‘Future’ ...
[17:38:34.890] - state: ‘created’
[17:38:34.891] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:34.906] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:34.906] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:34.906]   - Field: ‘node’
[17:38:34.906]   - Field: ‘label’
[17:38:34.906]   - Field: ‘local’
[17:38:34.906]   - Field: ‘owner’
[17:38:34.906]   - Field: ‘envir’
[17:38:34.906]   - Field: ‘workers’
[17:38:34.906]   - Field: ‘packages’
[17:38:34.907]   - Field: ‘gc’
[17:38:34.907]   - Field: ‘conditions’
[17:38:34.907]   - Field: ‘persistent’
[17:38:34.907]   - Field: ‘expr’
[17:38:34.907]   - Field: ‘uuid’
[17:38:34.907]   - Field: ‘seed’
[17:38:34.907]   - Field: ‘version’
[17:38:34.907]   - Field: ‘result’
[17:38:34.907]   - Field: ‘asynchronous’
[17:38:34.908]   - Field: ‘calls’
[17:38:34.908]   - Field: ‘globals’
[17:38:34.908]   - Field: ‘stdout’
[17:38:34.908]   - Field: ‘earlySignal’
[17:38:34.908]   - Field: ‘lazy’
[17:38:34.908]   - Field: ‘state’
[17:38:34.908] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:34.909] - Launch lazy future ...
[17:38:34.909] Packages needed by the future expression (n = 0): <none>
[17:38:34.909] Packages needed by future strategies (n = 0): <none>
[17:38:34.909] {
[17:38:34.909]     {
[17:38:34.909]         {
[17:38:34.909]             ...future.startTime <- base::Sys.time()
[17:38:34.909]             {
[17:38:34.909]                 {
[17:38:34.909]                   {
[17:38:34.909]                     {
[17:38:34.909]                       base::local({
[17:38:34.909]                         has_future <- base::requireNamespace("future", 
[17:38:34.909]                           quietly = TRUE)
[17:38:34.909]                         if (has_future) {
[17:38:34.909]                           ns <- base::getNamespace("future")
[17:38:34.909]                           version <- ns[[".package"]][["version"]]
[17:38:34.909]                           if (is.null(version)) 
[17:38:34.909]                             version <- utils::packageVersion("future")
[17:38:34.909]                         }
[17:38:34.909]                         else {
[17:38:34.909]                           version <- NULL
[17:38:34.909]                         }
[17:38:34.909]                         if (!has_future || version < "1.8.0") {
[17:38:34.909]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:34.909]                             "", base::R.version$version.string), 
[17:38:34.909]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:34.909]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:34.909]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:34.909]                               "release", "version")], collapse = " "), 
[17:38:34.909]                             hostname = base::Sys.info()[["nodename"]])
[17:38:34.909]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:34.909]                             info)
[17:38:34.909]                           info <- base::paste(info, collapse = "; ")
[17:38:34.909]                           if (!has_future) {
[17:38:34.909]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:34.909]                               info)
[17:38:34.909]                           }
[17:38:34.909]                           else {
[17:38:34.909]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:34.909]                               info, version)
[17:38:34.909]                           }
[17:38:34.909]                           base::stop(msg)
[17:38:34.909]                         }
[17:38:34.909]                       })
[17:38:34.909]                     }
[17:38:34.909]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:34.909]                     base::options(mc.cores = 1L)
[17:38:34.909]                   }
[17:38:34.909]                   ...future.strategy.old <- future::plan("list")
[17:38:34.909]                   options(future.plan = NULL)
[17:38:34.909]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:34.909]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:34.909]                 }
[17:38:34.909]                 ...future.workdir <- getwd()
[17:38:34.909]             }
[17:38:34.909]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:34.909]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:34.909]         }
[17:38:34.909]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:34.909]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:34.909]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:34.909]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:34.909]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:34.909]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:34.909]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:34.909]             base::names(...future.oldOptions))
[17:38:34.909]     }
[17:38:34.909]     if (FALSE) {
[17:38:34.909]     }
[17:38:34.909]     else {
[17:38:34.909]         if (FALSE) {
[17:38:34.909]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:34.909]                 open = "w")
[17:38:34.909]         }
[17:38:34.909]         else {
[17:38:34.909]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:34.909]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:34.909]         }
[17:38:34.909]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:34.909]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:34.909]             base::sink(type = "output", split = FALSE)
[17:38:34.909]             base::close(...future.stdout)
[17:38:34.909]         }, add = TRUE)
[17:38:34.909]     }
[17:38:34.909]     ...future.frame <- base::sys.nframe()
[17:38:34.909]     ...future.conditions <- base::list()
[17:38:34.909]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:34.909]     if (FALSE) {
[17:38:34.909]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:34.909]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:34.909]     }
[17:38:34.909]     ...future.result <- base::tryCatch({
[17:38:34.909]         base::withCallingHandlers({
[17:38:34.909]             ...future.value <- base::withVisible(base::local({
[17:38:34.909]                 ...future.makeSendCondition <- base::local({
[17:38:34.909]                   sendCondition <- NULL
[17:38:34.909]                   function(frame = 1L) {
[17:38:34.909]                     if (is.function(sendCondition)) 
[17:38:34.909]                       return(sendCondition)
[17:38:34.909]                     ns <- getNamespace("parallel")
[17:38:34.909]                     if (exists("sendData", mode = "function", 
[17:38:34.909]                       envir = ns)) {
[17:38:34.909]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:34.909]                         envir = ns)
[17:38:34.909]                       envir <- sys.frame(frame)
[17:38:34.909]                       master <- NULL
[17:38:34.909]                       while (!identical(envir, .GlobalEnv) && 
[17:38:34.909]                         !identical(envir, emptyenv())) {
[17:38:34.909]                         if (exists("master", mode = "list", envir = envir, 
[17:38:34.909]                           inherits = FALSE)) {
[17:38:34.909]                           master <- get("master", mode = "list", 
[17:38:34.909]                             envir = envir, inherits = FALSE)
[17:38:34.909]                           if (inherits(master, c("SOCKnode", 
[17:38:34.909]                             "SOCK0node"))) {
[17:38:34.909]                             sendCondition <<- function(cond) {
[17:38:34.909]                               data <- list(type = "VALUE", value = cond, 
[17:38:34.909]                                 success = TRUE)
[17:38:34.909]                               parallel_sendData(master, data)
[17:38:34.909]                             }
[17:38:34.909]                             return(sendCondition)
[17:38:34.909]                           }
[17:38:34.909]                         }
[17:38:34.909]                         frame <- frame + 1L
[17:38:34.909]                         envir <- sys.frame(frame)
[17:38:34.909]                       }
[17:38:34.909]                     }
[17:38:34.909]                     sendCondition <<- function(cond) NULL
[17:38:34.909]                   }
[17:38:34.909]                 })
[17:38:34.909]                 withCallingHandlers({
[17:38:34.909]                   {
[17:38:34.909]                     do.call(function(...) {
[17:38:34.909]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:34.909]                       if (!identical(...future.globals.maxSize.org, 
[17:38:34.909]                         ...future.globals.maxSize)) {
[17:38:34.909]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:34.909]                         on.exit(options(oopts), add = TRUE)
[17:38:34.909]                       }
[17:38:34.909]                       {
[17:38:34.909]                         lapply(seq_along(...future.elements_ii), 
[17:38:34.909]                           FUN = function(jj) {
[17:38:34.909]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:34.909]                             ...future.FUN(...future.X_jj, ...)
[17:38:34.909]                           })
[17:38:34.909]                       }
[17:38:34.909]                     }, args = future.call.arguments)
[17:38:34.909]                   }
[17:38:34.909]                 }, immediateCondition = function(cond) {
[17:38:34.909]                   sendCondition <- ...future.makeSendCondition()
[17:38:34.909]                   sendCondition(cond)
[17:38:34.909]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:34.909]                   {
[17:38:34.909]                     inherits <- base::inherits
[17:38:34.909]                     invokeRestart <- base::invokeRestart
[17:38:34.909]                     is.null <- base::is.null
[17:38:34.909]                     muffled <- FALSE
[17:38:34.909]                     if (inherits(cond, "message")) {
[17:38:34.909]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:34.909]                       if (muffled) 
[17:38:34.909]                         invokeRestart("muffleMessage")
[17:38:34.909]                     }
[17:38:34.909]                     else if (inherits(cond, "warning")) {
[17:38:34.909]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:34.909]                       if (muffled) 
[17:38:34.909]                         invokeRestart("muffleWarning")
[17:38:34.909]                     }
[17:38:34.909]                     else if (inherits(cond, "condition")) {
[17:38:34.909]                       if (!is.null(pattern)) {
[17:38:34.909]                         computeRestarts <- base::computeRestarts
[17:38:34.909]                         grepl <- base::grepl
[17:38:34.909]                         restarts <- computeRestarts(cond)
[17:38:34.909]                         for (restart in restarts) {
[17:38:34.909]                           name <- restart$name
[17:38:34.909]                           if (is.null(name)) 
[17:38:34.909]                             next
[17:38:34.909]                           if (!grepl(pattern, name)) 
[17:38:34.909]                             next
[17:38:34.909]                           invokeRestart(restart)
[17:38:34.909]                           muffled <- TRUE
[17:38:34.909]                           break
[17:38:34.909]                         }
[17:38:34.909]                       }
[17:38:34.909]                     }
[17:38:34.909]                     invisible(muffled)
[17:38:34.909]                   }
[17:38:34.909]                   muffleCondition(cond)
[17:38:34.909]                 })
[17:38:34.909]             }))
[17:38:34.909]             future::FutureResult(value = ...future.value$value, 
[17:38:34.909]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:34.909]                   ...future.rng), globalenv = if (FALSE) 
[17:38:34.909]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:34.909]                     ...future.globalenv.names))
[17:38:34.909]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:34.909]         }, condition = base::local({
[17:38:34.909]             c <- base::c
[17:38:34.909]             inherits <- base::inherits
[17:38:34.909]             invokeRestart <- base::invokeRestart
[17:38:34.909]             length <- base::length
[17:38:34.909]             list <- base::list
[17:38:34.909]             seq.int <- base::seq.int
[17:38:34.909]             signalCondition <- base::signalCondition
[17:38:34.909]             sys.calls <- base::sys.calls
[17:38:34.909]             `[[` <- base::`[[`
[17:38:34.909]             `+` <- base::`+`
[17:38:34.909]             `<<-` <- base::`<<-`
[17:38:34.909]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:34.909]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:34.909]                   3L)]
[17:38:34.909]             }
[17:38:34.909]             function(cond) {
[17:38:34.909]                 is_error <- inherits(cond, "error")
[17:38:34.909]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:34.909]                   NULL)
[17:38:34.909]                 if (is_error) {
[17:38:34.909]                   sessionInformation <- function() {
[17:38:34.909]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:34.909]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:34.909]                       search = base::search(), system = base::Sys.info())
[17:38:34.909]                   }
[17:38:34.909]                   ...future.conditions[[length(...future.conditions) + 
[17:38:34.909]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:34.909]                     cond$call), session = sessionInformation(), 
[17:38:34.909]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:34.909]                   signalCondition(cond)
[17:38:34.909]                 }
[17:38:34.909]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:34.909]                 "immediateCondition"))) {
[17:38:34.909]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:34.909]                   ...future.conditions[[length(...future.conditions) + 
[17:38:34.909]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:34.909]                   if (TRUE && !signal) {
[17:38:34.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:34.909]                     {
[17:38:34.909]                       inherits <- base::inherits
[17:38:34.909]                       invokeRestart <- base::invokeRestart
[17:38:34.909]                       is.null <- base::is.null
[17:38:34.909]                       muffled <- FALSE
[17:38:34.909]                       if (inherits(cond, "message")) {
[17:38:34.909]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:34.909]                         if (muffled) 
[17:38:34.909]                           invokeRestart("muffleMessage")
[17:38:34.909]                       }
[17:38:34.909]                       else if (inherits(cond, "warning")) {
[17:38:34.909]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:34.909]                         if (muffled) 
[17:38:34.909]                           invokeRestart("muffleWarning")
[17:38:34.909]                       }
[17:38:34.909]                       else if (inherits(cond, "condition")) {
[17:38:34.909]                         if (!is.null(pattern)) {
[17:38:34.909]                           computeRestarts <- base::computeRestarts
[17:38:34.909]                           grepl <- base::grepl
[17:38:34.909]                           restarts <- computeRestarts(cond)
[17:38:34.909]                           for (restart in restarts) {
[17:38:34.909]                             name <- restart$name
[17:38:34.909]                             if (is.null(name)) 
[17:38:34.909]                               next
[17:38:34.909]                             if (!grepl(pattern, name)) 
[17:38:34.909]                               next
[17:38:34.909]                             invokeRestart(restart)
[17:38:34.909]                             muffled <- TRUE
[17:38:34.909]                             break
[17:38:34.909]                           }
[17:38:34.909]                         }
[17:38:34.909]                       }
[17:38:34.909]                       invisible(muffled)
[17:38:34.909]                     }
[17:38:34.909]                     muffleCondition(cond, pattern = "^muffle")
[17:38:34.909]                   }
[17:38:34.909]                 }
[17:38:34.909]                 else {
[17:38:34.909]                   if (TRUE) {
[17:38:34.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:34.909]                     {
[17:38:34.909]                       inherits <- base::inherits
[17:38:34.909]                       invokeRestart <- base::invokeRestart
[17:38:34.909]                       is.null <- base::is.null
[17:38:34.909]                       muffled <- FALSE
[17:38:34.909]                       if (inherits(cond, "message")) {
[17:38:34.909]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:34.909]                         if (muffled) 
[17:38:34.909]                           invokeRestart("muffleMessage")
[17:38:34.909]                       }
[17:38:34.909]                       else if (inherits(cond, "warning")) {
[17:38:34.909]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:34.909]                         if (muffled) 
[17:38:34.909]                           invokeRestart("muffleWarning")
[17:38:34.909]                       }
[17:38:34.909]                       else if (inherits(cond, "condition")) {
[17:38:34.909]                         if (!is.null(pattern)) {
[17:38:34.909]                           computeRestarts <- base::computeRestarts
[17:38:34.909]                           grepl <- base::grepl
[17:38:34.909]                           restarts <- computeRestarts(cond)
[17:38:34.909]                           for (restart in restarts) {
[17:38:34.909]                             name <- restart$name
[17:38:34.909]                             if (is.null(name)) 
[17:38:34.909]                               next
[17:38:34.909]                             if (!grepl(pattern, name)) 
[17:38:34.909]                               next
[17:38:34.909]                             invokeRestart(restart)
[17:38:34.909]                             muffled <- TRUE
[17:38:34.909]                             break
[17:38:34.909]                           }
[17:38:34.909]                         }
[17:38:34.909]                       }
[17:38:34.909]                       invisible(muffled)
[17:38:34.909]                     }
[17:38:34.909]                     muffleCondition(cond, pattern = "^muffle")
[17:38:34.909]                   }
[17:38:34.909]                 }
[17:38:34.909]             }
[17:38:34.909]         }))
[17:38:34.909]     }, error = function(ex) {
[17:38:34.909]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:34.909]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:34.909]                 ...future.rng), started = ...future.startTime, 
[17:38:34.909]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:34.909]             version = "1.8"), class = "FutureResult")
[17:38:34.909]     }, finally = {
[17:38:34.909]         if (!identical(...future.workdir, getwd())) 
[17:38:34.909]             setwd(...future.workdir)
[17:38:34.909]         {
[17:38:34.909]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:34.909]                 ...future.oldOptions$nwarnings <- NULL
[17:38:34.909]             }
[17:38:34.909]             base::options(...future.oldOptions)
[17:38:34.909]             if (.Platform$OS.type == "windows") {
[17:38:34.909]                 old_names <- names(...future.oldEnvVars)
[17:38:34.909]                 envs <- base::Sys.getenv()
[17:38:34.909]                 names <- names(envs)
[17:38:34.909]                 common <- intersect(names, old_names)
[17:38:34.909]                 added <- setdiff(names, old_names)
[17:38:34.909]                 removed <- setdiff(old_names, names)
[17:38:34.909]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:34.909]                   envs[common]]
[17:38:34.909]                 NAMES <- toupper(changed)
[17:38:34.909]                 args <- list()
[17:38:34.909]                 for (kk in seq_along(NAMES)) {
[17:38:34.909]                   name <- changed[[kk]]
[17:38:34.909]                   NAME <- NAMES[[kk]]
[17:38:34.909]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:34.909]                     next
[17:38:34.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:34.909]                 }
[17:38:34.909]                 NAMES <- toupper(added)
[17:38:34.909]                 for (kk in seq_along(NAMES)) {
[17:38:34.909]                   name <- added[[kk]]
[17:38:34.909]                   NAME <- NAMES[[kk]]
[17:38:34.909]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:34.909]                     next
[17:38:34.909]                   args[[name]] <- ""
[17:38:34.909]                 }
[17:38:34.909]                 NAMES <- toupper(removed)
[17:38:34.909]                 for (kk in seq_along(NAMES)) {
[17:38:34.909]                   name <- removed[[kk]]
[17:38:34.909]                   NAME <- NAMES[[kk]]
[17:38:34.909]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:34.909]                     next
[17:38:34.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:34.909]                 }
[17:38:34.909]                 if (length(args) > 0) 
[17:38:34.909]                   base::do.call(base::Sys.setenv, args = args)
[17:38:34.909]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:34.909]             }
[17:38:34.909]             else {
[17:38:34.909]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:34.909]             }
[17:38:34.909]             {
[17:38:34.909]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:34.909]                   0L) {
[17:38:34.909]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:34.909]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:34.909]                   base::options(opts)
[17:38:34.909]                 }
[17:38:34.909]                 {
[17:38:34.909]                   {
[17:38:34.909]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:34.909]                     NULL
[17:38:34.909]                   }
[17:38:34.909]                   options(future.plan = NULL)
[17:38:34.909]                   if (is.na(NA_character_)) 
[17:38:34.909]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:34.909]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:34.909]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:34.909]                     .init = FALSE)
[17:38:34.909]                 }
[17:38:34.909]             }
[17:38:34.909]         }
[17:38:34.909]     })
[17:38:34.909]     if (TRUE) {
[17:38:34.909]         base::sink(type = "output", split = FALSE)
[17:38:34.909]         if (FALSE) {
[17:38:34.909]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:34.909]         }
[17:38:34.909]         else {
[17:38:34.909]             ...future.result["stdout"] <- base::list(NULL)
[17:38:34.909]         }
[17:38:34.909]         base::close(...future.stdout)
[17:38:34.909]         ...future.stdout <- NULL
[17:38:34.909]     }
[17:38:34.909]     ...future.result$conditions <- ...future.conditions
[17:38:34.909]     ...future.result$finished <- base::Sys.time()
[17:38:34.909]     ...future.result
[17:38:34.909] }
[17:38:34.962] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[17:38:34.962] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[17:38:34.963] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[17:38:34.963] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:38:34.964] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:38:34.964] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:38:34.964] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:38:34.964] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:38:34.965] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:38:34.965] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:38:34.965] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:38:34.965] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[17:38:34.966] MultisessionFuture started
[17:38:34.966] - Launch lazy future ... done
[17:38:34.966] run() for ‘MultisessionFuture’ ... done
[17:38:34.966] Created future:
[17:38:34.966] MultisessionFuture:
[17:38:34.966] Label: ‘future_lapply-2’
[17:38:34.966] Expression:
[17:38:34.966] {
[17:38:34.966]     do.call(function(...) {
[17:38:34.966]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:34.966]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:34.966]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:34.966]             on.exit(options(oopts), add = TRUE)
[17:38:34.966]         }
[17:38:34.966]         {
[17:38:34.966]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:34.966]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:34.966]                 ...future.FUN(...future.X_jj, ...)
[17:38:34.966]             })
[17:38:34.966]         }
[17:38:34.966]     }, args = future.call.arguments)
[17:38:34.966] }
[17:38:34.966] Lazy evaluation: FALSE
[17:38:34.966] Asynchronous evaluation: TRUE
[17:38:34.966] Local evaluation: TRUE
[17:38:34.966] Environment: R_GlobalEnv
[17:38:34.966] Capture standard output: FALSE
[17:38:34.966] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:34.966] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:34.966] Packages: <none>
[17:38:34.966] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:34.966] Resolved: FALSE
[17:38:34.966] Value: <not collected>
[17:38:34.966] Conditions captured: <none>
[17:38:34.966] Early signaling: FALSE
[17:38:34.966] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:34.966] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:34.978] Chunk #2 of 2 ... DONE
[17:38:34.978] Launching 2 futures (chunks) ... DONE
[17:38:34.979] Resolving 2 futures (chunks) ...
[17:38:34.979] resolve() on list ...
[17:38:34.979]  recursive: 0
[17:38:34.979]  length: 2
[17:38:34.979] 
[17:38:35.056] receiveMessageFromWorker() for ClusterFuture ...
[17:38:35.056] - Validating connection of MultisessionFuture
[17:38:35.056] - received message: FutureResult
[17:38:35.056] - Received FutureResult
[17:38:35.056] - Erased future from FutureRegistry
[17:38:35.057] result() for ClusterFuture ...
[17:38:35.057] - result already collected: FutureResult
[17:38:35.057] result() for ClusterFuture ... done
[17:38:35.057] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:35.057] Future #2
[17:38:35.057] result() for ClusterFuture ...
[17:38:35.057] - result already collected: FutureResult
[17:38:35.057] result() for ClusterFuture ... done
[17:38:35.057] result() for ClusterFuture ...
[17:38:35.057] - result already collected: FutureResult
[17:38:35.057] result() for ClusterFuture ... done
[17:38:35.058] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:38:35.058] - nx: 2
[17:38:35.058] - relay: TRUE
[17:38:35.058] - stdout: TRUE
[17:38:35.058] - signal: TRUE
[17:38:35.058] - resignal: FALSE
[17:38:35.058] - force: TRUE
[17:38:35.058] - relayed: [n=2] FALSE, FALSE
[17:38:35.058] - queued futures: [n=2] FALSE, FALSE
[17:38:35.058]  - until=1
[17:38:35.058]  - relaying element #1
[17:38:35.058] - relayed: [n=2] FALSE, FALSE
[17:38:35.059] - queued futures: [n=2] FALSE, TRUE
[17:38:35.059] signalConditionsASAP(NULL, pos=2) ... done
[17:38:35.059]  length: 1 (resolved future 2)
[17:38:35.420] receiveMessageFromWorker() for ClusterFuture ...
[17:38:35.420] - Validating connection of MultisessionFuture
[17:38:35.421] - received message: FutureResult
[17:38:35.421] - Received FutureResult
[17:38:35.421] - Erased future from FutureRegistry
[17:38:35.421] result() for ClusterFuture ...
[17:38:35.421] - result already collected: FutureResult
[17:38:35.422] result() for ClusterFuture ... done
[17:38:35.422] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:35.422] Future #1
[17:38:35.422] result() for ClusterFuture ...
[17:38:35.422] - result already collected: FutureResult
[17:38:35.422] result() for ClusterFuture ... done
[17:38:35.422] result() for ClusterFuture ...
[17:38:35.422] - result already collected: FutureResult
[17:38:35.422] result() for ClusterFuture ... done
[17:38:35.422] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:38:35.422] - nx: 2
[17:38:35.423] - relay: TRUE
[17:38:35.423] - stdout: TRUE
[17:38:35.423] - signal: TRUE
[17:38:35.423] - resignal: FALSE
[17:38:35.423] - force: TRUE
[17:38:35.423] - relayed: [n=2] FALSE, FALSE
[17:38:35.423] - queued futures: [n=2] FALSE, TRUE
[17:38:35.423]  - until=1
[17:38:35.423]  - relaying element #1
[17:38:35.423] result() for ClusterFuture ...
[17:38:35.423] - result already collected: FutureResult
[17:38:35.423] result() for ClusterFuture ... done
[17:38:35.424] result() for ClusterFuture ...
[17:38:35.424] - result already collected: FutureResult
[17:38:35.424] result() for ClusterFuture ... done
[17:38:35.424] result() for ClusterFuture ...
[17:38:35.424] - result already collected: FutureResult
[17:38:35.424] result() for ClusterFuture ... done
[17:38:35.424] result() for ClusterFuture ...
[17:38:35.424] - result already collected: FutureResult
[17:38:35.424] result() for ClusterFuture ... done
[17:38:35.424] - relayed: [n=2] TRUE, FALSE
[17:38:35.424] - queued futures: [n=2] TRUE, TRUE
[17:38:35.425] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:38:35.425]  length: 0 (resolved future 1)
[17:38:35.425] Relaying remaining futures
[17:38:35.425] signalConditionsASAP(NULL, pos=0) ...
[17:38:35.425] - nx: 2
[17:38:35.425] - relay: TRUE
[17:38:35.425] - stdout: TRUE
[17:38:35.425] - signal: TRUE
[17:38:35.425] - resignal: FALSE
[17:38:35.425] - force: TRUE
[17:38:35.425] - relayed: [n=2] TRUE, FALSE
[17:38:35.425] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:35.426]  - relaying element #2
[17:38:35.426] result() for ClusterFuture ...
[17:38:35.426] - result already collected: FutureResult
[17:38:35.426] result() for ClusterFuture ... done
[17:38:35.426] result() for ClusterFuture ...
[17:38:35.426] - result already collected: FutureResult
[17:38:35.426] result() for ClusterFuture ... done
[17:38:35.426] result() for ClusterFuture ...
[17:38:35.426] - result already collected: FutureResult
[17:38:35.426] result() for ClusterFuture ... done
[17:38:35.426] result() for ClusterFuture ...
[17:38:35.426] - result already collected: FutureResult
[17:38:35.427] result() for ClusterFuture ... done
[17:38:35.427] - relayed: [n=2] TRUE, TRUE
[17:38:35.427] - queued futures: [n=2] TRUE, TRUE
[17:38:35.427] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:38:35.427] resolve() on list ... DONE
[17:38:35.427] result() for ClusterFuture ...
[17:38:35.427] - result already collected: FutureResult
[17:38:35.427] result() for ClusterFuture ... done
[17:38:35.427] result() for ClusterFuture ...
[17:38:35.427] - result already collected: FutureResult
[17:38:35.427] result() for ClusterFuture ... done
[17:38:35.427] result() for ClusterFuture ...
[17:38:35.428] - result already collected: FutureResult
[17:38:35.428] result() for ClusterFuture ... done
[17:38:35.428] result() for ClusterFuture ...
[17:38:35.428] - result already collected: FutureResult
[17:38:35.428] result() for ClusterFuture ... done
[17:38:35.428]  - Number of value chunks collected: 2
[17:38:35.428] Resolving 2 futures (chunks) ... DONE
[17:38:35.428] Reducing values from 2 chunks ...
[17:38:35.428]  - Number of values collected after concatenation: 2
[17:38:35.428]  - Number of values expected: 2
[17:38:35.428] Reducing values from 2 chunks ... DONE
[17:38:35.429] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[17:38:35.429] future_lapply() ...
[17:38:35.433] Number of chunks: 2
[17:38:35.433] getGlobalsAndPackagesXApply() ...
[17:38:35.433]  - future.globals: TRUE
[17:38:35.433] getGlobalsAndPackages() ...
[17:38:35.433] Searching for globals...
[17:38:35.435] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:38:35.435] Searching for globals ... DONE
[17:38:35.435] Resolving globals: FALSE
[17:38:35.435] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:38:35.436] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:38:35.436] - globals: [1] ‘FUN’
[17:38:35.436] 
[17:38:35.436] getGlobalsAndPackages() ... DONE
[17:38:35.436]  - globals found/used: [n=1] ‘FUN’
[17:38:35.436]  - needed namespaces: [n=0] 
[17:38:35.436] Finding globals ... DONE
[17:38:35.436]  - use_args: TRUE
[17:38:35.437]  - Getting '...' globals ...
[17:38:35.437] resolve() on list ...
[17:38:35.437]  recursive: 0
[17:38:35.437]  length: 1
[17:38:35.437]  elements: ‘...’
[17:38:35.437]  length: 0 (resolved future 1)
[17:38:35.437] resolve() on list ... DONE
[17:38:35.437]    - '...' content: [n=0] 
[17:38:35.438] List of 1
[17:38:35.438]  $ ...: list()
[17:38:35.438]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:35.438]  - attr(*, "where")=List of 1
[17:38:35.438]   ..$ ...:<environment: 0x5628aa173e70> 
[17:38:35.438]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:35.438]  - attr(*, "resolved")= logi TRUE
[17:38:35.438]  - attr(*, "total_size")= num NA
[17:38:35.440]  - Getting '...' globals ... DONE
[17:38:35.440] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:38:35.440] List of 2
[17:38:35.440]  $ ...future.FUN:function (x)  
[17:38:35.440]  $ ...          : list()
[17:38:35.440]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:35.440]  - attr(*, "where")=List of 2
[17:38:35.440]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:35.440]   ..$ ...          :<environment: 0x5628aa173e70> 
[17:38:35.440]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:35.440]  - attr(*, "resolved")= logi FALSE
[17:38:35.440]  - attr(*, "total_size")= num 4720
[17:38:35.443] Packages to be attached in all futures: [n=0] 
[17:38:35.443] getGlobalsAndPackagesXApply() ... DONE
[17:38:35.443] Number of futures (= number of chunks): 2
[17:38:35.443] Launching 2 futures (chunks) ...
[17:38:35.443] Chunk #1 of 2 ...
[17:38:35.444]  - Finding globals in 'X' for chunk #1 ...
[17:38:35.444] getGlobalsAndPackages() ...
[17:38:35.444] Searching for globals...
[17:38:35.444] 
[17:38:35.444] Searching for globals ... DONE
[17:38:35.444] - globals: [0] <none>
[17:38:35.444] getGlobalsAndPackages() ... DONE
[17:38:35.444]    + additional globals found: [n=0] 
[17:38:35.444]    + additional namespaces needed: [n=0] 
[17:38:35.445]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:35.445]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:35.445]  - seeds: <none>
[17:38:35.445]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:35.445] getGlobalsAndPackages() ...
[17:38:35.445] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:35.445] Resolving globals: FALSE
[17:38:35.445] Tweak future expression to call with '...' arguments ...
[17:38:35.445] {
[17:38:35.445]     do.call(function(...) {
[17:38:35.445]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:35.445]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:35.445]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:35.445]             on.exit(options(oopts), add = TRUE)
[17:38:35.445]         }
[17:38:35.445]         {
[17:38:35.445]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:35.445]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:35.445]                 ...future.FUN(...future.X_jj, ...)
[17:38:35.445]             })
[17:38:35.445]         }
[17:38:35.445]     }, args = future.call.arguments)
[17:38:35.445] }
[17:38:35.446] Tweak future expression to call with '...' arguments ... DONE
[17:38:35.446] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:35.446] 
[17:38:35.446] getGlobalsAndPackages() ... DONE
[17:38:35.446] run() for ‘Future’ ...
[17:38:35.446] - state: ‘created’
[17:38:35.447] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:35.460] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:35.460] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:35.460]   - Field: ‘node’
[17:38:35.461]   - Field: ‘label’
[17:38:35.461]   - Field: ‘local’
[17:38:35.461]   - Field: ‘owner’
[17:38:35.461]   - Field: ‘envir’
[17:38:35.461]   - Field: ‘workers’
[17:38:35.461]   - Field: ‘packages’
[17:38:35.461]   - Field: ‘gc’
[17:38:35.461]   - Field: ‘conditions’
[17:38:35.461]   - Field: ‘persistent’
[17:38:35.461]   - Field: ‘expr’
[17:38:35.461]   - Field: ‘uuid’
[17:38:35.462]   - Field: ‘seed’
[17:38:35.462]   - Field: ‘version’
[17:38:35.462]   - Field: ‘result’
[17:38:35.462]   - Field: ‘asynchronous’
[17:38:35.462]   - Field: ‘calls’
[17:38:35.462]   - Field: ‘globals’
[17:38:35.462]   - Field: ‘stdout’
[17:38:35.462]   - Field: ‘earlySignal’
[17:38:35.462]   - Field: ‘lazy’
[17:38:35.462]   - Field: ‘state’
[17:38:35.462] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:35.463] - Launch lazy future ...
[17:38:35.463] Packages needed by the future expression (n = 0): <none>
[17:38:35.463] Packages needed by future strategies (n = 0): <none>
[17:38:35.463] {
[17:38:35.463]     {
[17:38:35.463]         {
[17:38:35.463]             ...future.startTime <- base::Sys.time()
[17:38:35.463]             {
[17:38:35.463]                 {
[17:38:35.463]                   {
[17:38:35.463]                     {
[17:38:35.463]                       base::local({
[17:38:35.463]                         has_future <- base::requireNamespace("future", 
[17:38:35.463]                           quietly = TRUE)
[17:38:35.463]                         if (has_future) {
[17:38:35.463]                           ns <- base::getNamespace("future")
[17:38:35.463]                           version <- ns[[".package"]][["version"]]
[17:38:35.463]                           if (is.null(version)) 
[17:38:35.463]                             version <- utils::packageVersion("future")
[17:38:35.463]                         }
[17:38:35.463]                         else {
[17:38:35.463]                           version <- NULL
[17:38:35.463]                         }
[17:38:35.463]                         if (!has_future || version < "1.8.0") {
[17:38:35.463]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:35.463]                             "", base::R.version$version.string), 
[17:38:35.463]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:35.463]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:35.463]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:35.463]                               "release", "version")], collapse = " "), 
[17:38:35.463]                             hostname = base::Sys.info()[["nodename"]])
[17:38:35.463]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:35.463]                             info)
[17:38:35.463]                           info <- base::paste(info, collapse = "; ")
[17:38:35.463]                           if (!has_future) {
[17:38:35.463]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:35.463]                               info)
[17:38:35.463]                           }
[17:38:35.463]                           else {
[17:38:35.463]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:35.463]                               info, version)
[17:38:35.463]                           }
[17:38:35.463]                           base::stop(msg)
[17:38:35.463]                         }
[17:38:35.463]                       })
[17:38:35.463]                     }
[17:38:35.463]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:35.463]                     base::options(mc.cores = 1L)
[17:38:35.463]                   }
[17:38:35.463]                   ...future.strategy.old <- future::plan("list")
[17:38:35.463]                   options(future.plan = NULL)
[17:38:35.463]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:35.463]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:35.463]                 }
[17:38:35.463]                 ...future.workdir <- getwd()
[17:38:35.463]             }
[17:38:35.463]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:35.463]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:35.463]         }
[17:38:35.463]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:35.463]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:35.463]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:35.463]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:35.463]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:35.463]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:35.463]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:35.463]             base::names(...future.oldOptions))
[17:38:35.463]     }
[17:38:35.463]     if (FALSE) {
[17:38:35.463]     }
[17:38:35.463]     else {
[17:38:35.463]         if (TRUE) {
[17:38:35.463]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:35.463]                 open = "w")
[17:38:35.463]         }
[17:38:35.463]         else {
[17:38:35.463]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:35.463]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:35.463]         }
[17:38:35.463]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:35.463]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:35.463]             base::sink(type = "output", split = FALSE)
[17:38:35.463]             base::close(...future.stdout)
[17:38:35.463]         }, add = TRUE)
[17:38:35.463]     }
[17:38:35.463]     ...future.frame <- base::sys.nframe()
[17:38:35.463]     ...future.conditions <- base::list()
[17:38:35.463]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:35.463]     if (FALSE) {
[17:38:35.463]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:35.463]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:35.463]     }
[17:38:35.463]     ...future.result <- base::tryCatch({
[17:38:35.463]         base::withCallingHandlers({
[17:38:35.463]             ...future.value <- base::withVisible(base::local({
[17:38:35.463]                 ...future.makeSendCondition <- base::local({
[17:38:35.463]                   sendCondition <- NULL
[17:38:35.463]                   function(frame = 1L) {
[17:38:35.463]                     if (is.function(sendCondition)) 
[17:38:35.463]                       return(sendCondition)
[17:38:35.463]                     ns <- getNamespace("parallel")
[17:38:35.463]                     if (exists("sendData", mode = "function", 
[17:38:35.463]                       envir = ns)) {
[17:38:35.463]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:35.463]                         envir = ns)
[17:38:35.463]                       envir <- sys.frame(frame)
[17:38:35.463]                       master <- NULL
[17:38:35.463]                       while (!identical(envir, .GlobalEnv) && 
[17:38:35.463]                         !identical(envir, emptyenv())) {
[17:38:35.463]                         if (exists("master", mode = "list", envir = envir, 
[17:38:35.463]                           inherits = FALSE)) {
[17:38:35.463]                           master <- get("master", mode = "list", 
[17:38:35.463]                             envir = envir, inherits = FALSE)
[17:38:35.463]                           if (inherits(master, c("SOCKnode", 
[17:38:35.463]                             "SOCK0node"))) {
[17:38:35.463]                             sendCondition <<- function(cond) {
[17:38:35.463]                               data <- list(type = "VALUE", value = cond, 
[17:38:35.463]                                 success = TRUE)
[17:38:35.463]                               parallel_sendData(master, data)
[17:38:35.463]                             }
[17:38:35.463]                             return(sendCondition)
[17:38:35.463]                           }
[17:38:35.463]                         }
[17:38:35.463]                         frame <- frame + 1L
[17:38:35.463]                         envir <- sys.frame(frame)
[17:38:35.463]                       }
[17:38:35.463]                     }
[17:38:35.463]                     sendCondition <<- function(cond) NULL
[17:38:35.463]                   }
[17:38:35.463]                 })
[17:38:35.463]                 withCallingHandlers({
[17:38:35.463]                   {
[17:38:35.463]                     do.call(function(...) {
[17:38:35.463]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:35.463]                       if (!identical(...future.globals.maxSize.org, 
[17:38:35.463]                         ...future.globals.maxSize)) {
[17:38:35.463]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:35.463]                         on.exit(options(oopts), add = TRUE)
[17:38:35.463]                       }
[17:38:35.463]                       {
[17:38:35.463]                         lapply(seq_along(...future.elements_ii), 
[17:38:35.463]                           FUN = function(jj) {
[17:38:35.463]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:35.463]                             ...future.FUN(...future.X_jj, ...)
[17:38:35.463]                           })
[17:38:35.463]                       }
[17:38:35.463]                     }, args = future.call.arguments)
[17:38:35.463]                   }
[17:38:35.463]                 }, immediateCondition = function(cond) {
[17:38:35.463]                   sendCondition <- ...future.makeSendCondition()
[17:38:35.463]                   sendCondition(cond)
[17:38:35.463]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:35.463]                   {
[17:38:35.463]                     inherits <- base::inherits
[17:38:35.463]                     invokeRestart <- base::invokeRestart
[17:38:35.463]                     is.null <- base::is.null
[17:38:35.463]                     muffled <- FALSE
[17:38:35.463]                     if (inherits(cond, "message")) {
[17:38:35.463]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:35.463]                       if (muffled) 
[17:38:35.463]                         invokeRestart("muffleMessage")
[17:38:35.463]                     }
[17:38:35.463]                     else if (inherits(cond, "warning")) {
[17:38:35.463]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:35.463]                       if (muffled) 
[17:38:35.463]                         invokeRestart("muffleWarning")
[17:38:35.463]                     }
[17:38:35.463]                     else if (inherits(cond, "condition")) {
[17:38:35.463]                       if (!is.null(pattern)) {
[17:38:35.463]                         computeRestarts <- base::computeRestarts
[17:38:35.463]                         grepl <- base::grepl
[17:38:35.463]                         restarts <- computeRestarts(cond)
[17:38:35.463]                         for (restart in restarts) {
[17:38:35.463]                           name <- restart$name
[17:38:35.463]                           if (is.null(name)) 
[17:38:35.463]                             next
[17:38:35.463]                           if (!grepl(pattern, name)) 
[17:38:35.463]                             next
[17:38:35.463]                           invokeRestart(restart)
[17:38:35.463]                           muffled <- TRUE
[17:38:35.463]                           break
[17:38:35.463]                         }
[17:38:35.463]                       }
[17:38:35.463]                     }
[17:38:35.463]                     invisible(muffled)
[17:38:35.463]                   }
[17:38:35.463]                   muffleCondition(cond)
[17:38:35.463]                 })
[17:38:35.463]             }))
[17:38:35.463]             future::FutureResult(value = ...future.value$value, 
[17:38:35.463]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:35.463]                   ...future.rng), globalenv = if (FALSE) 
[17:38:35.463]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:35.463]                     ...future.globalenv.names))
[17:38:35.463]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:35.463]         }, condition = base::local({
[17:38:35.463]             c <- base::c
[17:38:35.463]             inherits <- base::inherits
[17:38:35.463]             invokeRestart <- base::invokeRestart
[17:38:35.463]             length <- base::length
[17:38:35.463]             list <- base::list
[17:38:35.463]             seq.int <- base::seq.int
[17:38:35.463]             signalCondition <- base::signalCondition
[17:38:35.463]             sys.calls <- base::sys.calls
[17:38:35.463]             `[[` <- base::`[[`
[17:38:35.463]             `+` <- base::`+`
[17:38:35.463]             `<<-` <- base::`<<-`
[17:38:35.463]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:35.463]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:35.463]                   3L)]
[17:38:35.463]             }
[17:38:35.463]             function(cond) {
[17:38:35.463]                 is_error <- inherits(cond, "error")
[17:38:35.463]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:35.463]                   NULL)
[17:38:35.463]                 if (is_error) {
[17:38:35.463]                   sessionInformation <- function() {
[17:38:35.463]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:35.463]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:35.463]                       search = base::search(), system = base::Sys.info())
[17:38:35.463]                   }
[17:38:35.463]                   ...future.conditions[[length(...future.conditions) + 
[17:38:35.463]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:35.463]                     cond$call), session = sessionInformation(), 
[17:38:35.463]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:35.463]                   signalCondition(cond)
[17:38:35.463]                 }
[17:38:35.463]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:35.463]                 "immediateCondition"))) {
[17:38:35.463]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:35.463]                   ...future.conditions[[length(...future.conditions) + 
[17:38:35.463]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:35.463]                   if (TRUE && !signal) {
[17:38:35.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:35.463]                     {
[17:38:35.463]                       inherits <- base::inherits
[17:38:35.463]                       invokeRestart <- base::invokeRestart
[17:38:35.463]                       is.null <- base::is.null
[17:38:35.463]                       muffled <- FALSE
[17:38:35.463]                       if (inherits(cond, "message")) {
[17:38:35.463]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:35.463]                         if (muffled) 
[17:38:35.463]                           invokeRestart("muffleMessage")
[17:38:35.463]                       }
[17:38:35.463]                       else if (inherits(cond, "warning")) {
[17:38:35.463]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:35.463]                         if (muffled) 
[17:38:35.463]                           invokeRestart("muffleWarning")
[17:38:35.463]                       }
[17:38:35.463]                       else if (inherits(cond, "condition")) {
[17:38:35.463]                         if (!is.null(pattern)) {
[17:38:35.463]                           computeRestarts <- base::computeRestarts
[17:38:35.463]                           grepl <- base::grepl
[17:38:35.463]                           restarts <- computeRestarts(cond)
[17:38:35.463]                           for (restart in restarts) {
[17:38:35.463]                             name <- restart$name
[17:38:35.463]                             if (is.null(name)) 
[17:38:35.463]                               next
[17:38:35.463]                             if (!grepl(pattern, name)) 
[17:38:35.463]                               next
[17:38:35.463]                             invokeRestart(restart)
[17:38:35.463]                             muffled <- TRUE
[17:38:35.463]                             break
[17:38:35.463]                           }
[17:38:35.463]                         }
[17:38:35.463]                       }
[17:38:35.463]                       invisible(muffled)
[17:38:35.463]                     }
[17:38:35.463]                     muffleCondition(cond, pattern = "^muffle")
[17:38:35.463]                   }
[17:38:35.463]                 }
[17:38:35.463]                 else {
[17:38:35.463]                   if (TRUE) {
[17:38:35.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:35.463]                     {
[17:38:35.463]                       inherits <- base::inherits
[17:38:35.463]                       invokeRestart <- base::invokeRestart
[17:38:35.463]                       is.null <- base::is.null
[17:38:35.463]                       muffled <- FALSE
[17:38:35.463]                       if (inherits(cond, "message")) {
[17:38:35.463]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:35.463]                         if (muffled) 
[17:38:35.463]                           invokeRestart("muffleMessage")
[17:38:35.463]                       }
[17:38:35.463]                       else if (inherits(cond, "warning")) {
[17:38:35.463]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:35.463]                         if (muffled) 
[17:38:35.463]                           invokeRestart("muffleWarning")
[17:38:35.463]                       }
[17:38:35.463]                       else if (inherits(cond, "condition")) {
[17:38:35.463]                         if (!is.null(pattern)) {
[17:38:35.463]                           computeRestarts <- base::computeRestarts
[17:38:35.463]                           grepl <- base::grepl
[17:38:35.463]                           restarts <- computeRestarts(cond)
[17:38:35.463]                           for (restart in restarts) {
[17:38:35.463]                             name <- restart$name
[17:38:35.463]                             if (is.null(name)) 
[17:38:35.463]                               next
[17:38:35.463]                             if (!grepl(pattern, name)) 
[17:38:35.463]                               next
[17:38:35.463]                             invokeRestart(restart)
[17:38:35.463]                             muffled <- TRUE
[17:38:35.463]                             break
[17:38:35.463]                           }
[17:38:35.463]                         }
[17:38:35.463]                       }
[17:38:35.463]                       invisible(muffled)
[17:38:35.463]                     }
[17:38:35.463]                     muffleCondition(cond, pattern = "^muffle")
[17:38:35.463]                   }
[17:38:35.463]                 }
[17:38:35.463]             }
[17:38:35.463]         }))
[17:38:35.463]     }, error = function(ex) {
[17:38:35.463]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:35.463]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:35.463]                 ...future.rng), started = ...future.startTime, 
[17:38:35.463]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:35.463]             version = "1.8"), class = "FutureResult")
[17:38:35.463]     }, finally = {
[17:38:35.463]         if (!identical(...future.workdir, getwd())) 
[17:38:35.463]             setwd(...future.workdir)
[17:38:35.463]         {
[17:38:35.463]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:35.463]                 ...future.oldOptions$nwarnings <- NULL
[17:38:35.463]             }
[17:38:35.463]             base::options(...future.oldOptions)
[17:38:35.463]             if (.Platform$OS.type == "windows") {
[17:38:35.463]                 old_names <- names(...future.oldEnvVars)
[17:38:35.463]                 envs <- base::Sys.getenv()
[17:38:35.463]                 names <- names(envs)
[17:38:35.463]                 common <- intersect(names, old_names)
[17:38:35.463]                 added <- setdiff(names, old_names)
[17:38:35.463]                 removed <- setdiff(old_names, names)
[17:38:35.463]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:35.463]                   envs[common]]
[17:38:35.463]                 NAMES <- toupper(changed)
[17:38:35.463]                 args <- list()
[17:38:35.463]                 for (kk in seq_along(NAMES)) {
[17:38:35.463]                   name <- changed[[kk]]
[17:38:35.463]                   NAME <- NAMES[[kk]]
[17:38:35.463]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:35.463]                     next
[17:38:35.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:35.463]                 }
[17:38:35.463]                 NAMES <- toupper(added)
[17:38:35.463]                 for (kk in seq_along(NAMES)) {
[17:38:35.463]                   name <- added[[kk]]
[17:38:35.463]                   NAME <- NAMES[[kk]]
[17:38:35.463]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:35.463]                     next
[17:38:35.463]                   args[[name]] <- ""
[17:38:35.463]                 }
[17:38:35.463]                 NAMES <- toupper(removed)
[17:38:35.463]                 for (kk in seq_along(NAMES)) {
[17:38:35.463]                   name <- removed[[kk]]
[17:38:35.463]                   NAME <- NAMES[[kk]]
[17:38:35.463]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:35.463]                     next
[17:38:35.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:35.463]                 }
[17:38:35.463]                 if (length(args) > 0) 
[17:38:35.463]                   base::do.call(base::Sys.setenv, args = args)
[17:38:35.463]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:35.463]             }
[17:38:35.463]             else {
[17:38:35.463]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:35.463]             }
[17:38:35.463]             {
[17:38:35.463]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:35.463]                   0L) {
[17:38:35.463]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:35.463]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:35.463]                   base::options(opts)
[17:38:35.463]                 }
[17:38:35.463]                 {
[17:38:35.463]                   {
[17:38:35.463]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:35.463]                     NULL
[17:38:35.463]                   }
[17:38:35.463]                   options(future.plan = NULL)
[17:38:35.463]                   if (is.na(NA_character_)) 
[17:38:35.463]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:35.463]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:35.463]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:35.463]                     .init = FALSE)
[17:38:35.463]                 }
[17:38:35.463]             }
[17:38:35.463]         }
[17:38:35.463]     })
[17:38:35.463]     if (TRUE) {
[17:38:35.463]         base::sink(type = "output", split = FALSE)
[17:38:35.463]         if (TRUE) {
[17:38:35.463]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:35.463]         }
[17:38:35.463]         else {
[17:38:35.463]             ...future.result["stdout"] <- base::list(NULL)
[17:38:35.463]         }
[17:38:35.463]         base::close(...future.stdout)
[17:38:35.463]         ...future.stdout <- NULL
[17:38:35.463]     }
[17:38:35.463]     ...future.result$conditions <- ...future.conditions
[17:38:35.463]     ...future.result$finished <- base::Sys.time()
[17:38:35.463]     ...future.result
[17:38:35.463] }
[17:38:35.466] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[17:38:35.466] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[17:38:35.466] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[17:38:35.467] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:38:35.467] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:38:35.467] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:38:35.467] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:38:35.468] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:38:35.468] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:38:35.468] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:38:35.468] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:38:35.468] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[17:38:35.469] MultisessionFuture started
[17:38:35.469] - Launch lazy future ... done
[17:38:35.469] run() for ‘MultisessionFuture’ ... done
[17:38:35.469] Created future:
[17:38:35.469] MultisessionFuture:
[17:38:35.469] Label: ‘future_lapply-1’
[17:38:35.469] Expression:
[17:38:35.469] {
[17:38:35.469]     do.call(function(...) {
[17:38:35.469]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:35.469]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:35.469]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:35.469]             on.exit(options(oopts), add = TRUE)
[17:38:35.469]         }
[17:38:35.469]         {
[17:38:35.469]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:35.469]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:35.469]                 ...future.FUN(...future.X_jj, ...)
[17:38:35.469]             })
[17:38:35.469]         }
[17:38:35.469]     }, args = future.call.arguments)
[17:38:35.469] }
[17:38:35.469] Lazy evaluation: FALSE
[17:38:35.469] Asynchronous evaluation: TRUE
[17:38:35.469] Local evaluation: TRUE
[17:38:35.469] Environment: R_GlobalEnv
[17:38:35.469] Capture standard output: TRUE
[17:38:35.469] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:35.469] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:35.469] Packages: <none>
[17:38:35.469] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:35.469] Resolved: FALSE
[17:38:35.469] Value: <not collected>
[17:38:35.469] Conditions captured: <none>
[17:38:35.469] Early signaling: FALSE
[17:38:35.469] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:35.469] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:35.481] Chunk #1 of 2 ... DONE
[17:38:35.481] Chunk #2 of 2 ...
[17:38:35.481]  - Finding globals in 'X' for chunk #2 ...
[17:38:35.481] getGlobalsAndPackages() ...
[17:38:35.481] Searching for globals...
[17:38:35.481] 
[17:38:35.482] Searching for globals ... DONE
[17:38:35.482] - globals: [0] <none>
[17:38:35.482] getGlobalsAndPackages() ... DONE
[17:38:35.482]    + additional globals found: [n=0] 
[17:38:35.482]    + additional namespaces needed: [n=0] 
[17:38:35.482]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:35.482]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:35.482]  - seeds: <none>
[17:38:35.482]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:35.482] getGlobalsAndPackages() ...
[17:38:35.483] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:35.483] Resolving globals: FALSE
[17:38:35.483] Tweak future expression to call with '...' arguments ...
[17:38:35.483] {
[17:38:35.483]     do.call(function(...) {
[17:38:35.483]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:35.483]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:35.483]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:35.483]             on.exit(options(oopts), add = TRUE)
[17:38:35.483]         }
[17:38:35.483]         {
[17:38:35.483]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:35.483]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:35.483]                 ...future.FUN(...future.X_jj, ...)
[17:38:35.483]             })
[17:38:35.483]         }
[17:38:35.483]     }, args = future.call.arguments)
[17:38:35.483] }
[17:38:35.483] Tweak future expression to call with '...' arguments ... DONE
[17:38:35.483] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:35.484] 
[17:38:35.484] getGlobalsAndPackages() ... DONE
[17:38:35.484] run() for ‘Future’ ...
[17:38:35.484] - state: ‘created’
[17:38:35.484] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:35.498] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:35.498] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:35.498]   - Field: ‘node’
[17:38:35.498]   - Field: ‘label’
[17:38:35.498]   - Field: ‘local’
[17:38:35.498]   - Field: ‘owner’
[17:38:35.498]   - Field: ‘envir’
[17:38:35.498]   - Field: ‘workers’
[17:38:35.498]   - Field: ‘packages’
[17:38:35.499]   - Field: ‘gc’
[17:38:35.499]   - Field: ‘conditions’
[17:38:35.499]   - Field: ‘persistent’
[17:38:35.499]   - Field: ‘expr’
[17:38:35.499]   - Field: ‘uuid’
[17:38:35.499]   - Field: ‘seed’
[17:38:35.499]   - Field: ‘version’
[17:38:35.499]   - Field: ‘result’
[17:38:35.499]   - Field: ‘asynchronous’
[17:38:35.499]   - Field: ‘calls’
[17:38:35.499]   - Field: ‘globals’
[17:38:35.500]   - Field: ‘stdout’
[17:38:35.500]   - Field: ‘earlySignal’
[17:38:35.500]   - Field: ‘lazy’
[17:38:35.500]   - Field: ‘state’
[17:38:35.500] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:35.500] - Launch lazy future ...
[17:38:35.500] Packages needed by the future expression (n = 0): <none>
[17:38:35.500] Packages needed by future strategies (n = 0): <none>
[17:38:35.501] {
[17:38:35.501]     {
[17:38:35.501]         {
[17:38:35.501]             ...future.startTime <- base::Sys.time()
[17:38:35.501]             {
[17:38:35.501]                 {
[17:38:35.501]                   {
[17:38:35.501]                     {
[17:38:35.501]                       base::local({
[17:38:35.501]                         has_future <- base::requireNamespace("future", 
[17:38:35.501]                           quietly = TRUE)
[17:38:35.501]                         if (has_future) {
[17:38:35.501]                           ns <- base::getNamespace("future")
[17:38:35.501]                           version <- ns[[".package"]][["version"]]
[17:38:35.501]                           if (is.null(version)) 
[17:38:35.501]                             version <- utils::packageVersion("future")
[17:38:35.501]                         }
[17:38:35.501]                         else {
[17:38:35.501]                           version <- NULL
[17:38:35.501]                         }
[17:38:35.501]                         if (!has_future || version < "1.8.0") {
[17:38:35.501]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:35.501]                             "", base::R.version$version.string), 
[17:38:35.501]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:35.501]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:35.501]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:35.501]                               "release", "version")], collapse = " "), 
[17:38:35.501]                             hostname = base::Sys.info()[["nodename"]])
[17:38:35.501]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:35.501]                             info)
[17:38:35.501]                           info <- base::paste(info, collapse = "; ")
[17:38:35.501]                           if (!has_future) {
[17:38:35.501]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:35.501]                               info)
[17:38:35.501]                           }
[17:38:35.501]                           else {
[17:38:35.501]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:35.501]                               info, version)
[17:38:35.501]                           }
[17:38:35.501]                           base::stop(msg)
[17:38:35.501]                         }
[17:38:35.501]                       })
[17:38:35.501]                     }
[17:38:35.501]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:35.501]                     base::options(mc.cores = 1L)
[17:38:35.501]                   }
[17:38:35.501]                   ...future.strategy.old <- future::plan("list")
[17:38:35.501]                   options(future.plan = NULL)
[17:38:35.501]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:35.501]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:35.501]                 }
[17:38:35.501]                 ...future.workdir <- getwd()
[17:38:35.501]             }
[17:38:35.501]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:35.501]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:35.501]         }
[17:38:35.501]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:35.501]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:35.501]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:35.501]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:35.501]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:35.501]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:35.501]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:35.501]             base::names(...future.oldOptions))
[17:38:35.501]     }
[17:38:35.501]     if (FALSE) {
[17:38:35.501]     }
[17:38:35.501]     else {
[17:38:35.501]         if (TRUE) {
[17:38:35.501]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:35.501]                 open = "w")
[17:38:35.501]         }
[17:38:35.501]         else {
[17:38:35.501]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:35.501]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:35.501]         }
[17:38:35.501]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:35.501]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:35.501]             base::sink(type = "output", split = FALSE)
[17:38:35.501]             base::close(...future.stdout)
[17:38:35.501]         }, add = TRUE)
[17:38:35.501]     }
[17:38:35.501]     ...future.frame <- base::sys.nframe()
[17:38:35.501]     ...future.conditions <- base::list()
[17:38:35.501]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:35.501]     if (FALSE) {
[17:38:35.501]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:35.501]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:35.501]     }
[17:38:35.501]     ...future.result <- base::tryCatch({
[17:38:35.501]         base::withCallingHandlers({
[17:38:35.501]             ...future.value <- base::withVisible(base::local({
[17:38:35.501]                 ...future.makeSendCondition <- base::local({
[17:38:35.501]                   sendCondition <- NULL
[17:38:35.501]                   function(frame = 1L) {
[17:38:35.501]                     if (is.function(sendCondition)) 
[17:38:35.501]                       return(sendCondition)
[17:38:35.501]                     ns <- getNamespace("parallel")
[17:38:35.501]                     if (exists("sendData", mode = "function", 
[17:38:35.501]                       envir = ns)) {
[17:38:35.501]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:35.501]                         envir = ns)
[17:38:35.501]                       envir <- sys.frame(frame)
[17:38:35.501]                       master <- NULL
[17:38:35.501]                       while (!identical(envir, .GlobalEnv) && 
[17:38:35.501]                         !identical(envir, emptyenv())) {
[17:38:35.501]                         if (exists("master", mode = "list", envir = envir, 
[17:38:35.501]                           inherits = FALSE)) {
[17:38:35.501]                           master <- get("master", mode = "list", 
[17:38:35.501]                             envir = envir, inherits = FALSE)
[17:38:35.501]                           if (inherits(master, c("SOCKnode", 
[17:38:35.501]                             "SOCK0node"))) {
[17:38:35.501]                             sendCondition <<- function(cond) {
[17:38:35.501]                               data <- list(type = "VALUE", value = cond, 
[17:38:35.501]                                 success = TRUE)
[17:38:35.501]                               parallel_sendData(master, data)
[17:38:35.501]                             }
[17:38:35.501]                             return(sendCondition)
[17:38:35.501]                           }
[17:38:35.501]                         }
[17:38:35.501]                         frame <- frame + 1L
[17:38:35.501]                         envir <- sys.frame(frame)
[17:38:35.501]                       }
[17:38:35.501]                     }
[17:38:35.501]                     sendCondition <<- function(cond) NULL
[17:38:35.501]                   }
[17:38:35.501]                 })
[17:38:35.501]                 withCallingHandlers({
[17:38:35.501]                   {
[17:38:35.501]                     do.call(function(...) {
[17:38:35.501]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:35.501]                       if (!identical(...future.globals.maxSize.org, 
[17:38:35.501]                         ...future.globals.maxSize)) {
[17:38:35.501]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:35.501]                         on.exit(options(oopts), add = TRUE)
[17:38:35.501]                       }
[17:38:35.501]                       {
[17:38:35.501]                         lapply(seq_along(...future.elements_ii), 
[17:38:35.501]                           FUN = function(jj) {
[17:38:35.501]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:35.501]                             ...future.FUN(...future.X_jj, ...)
[17:38:35.501]                           })
[17:38:35.501]                       }
[17:38:35.501]                     }, args = future.call.arguments)
[17:38:35.501]                   }
[17:38:35.501]                 }, immediateCondition = function(cond) {
[17:38:35.501]                   sendCondition <- ...future.makeSendCondition()
[17:38:35.501]                   sendCondition(cond)
[17:38:35.501]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:35.501]                   {
[17:38:35.501]                     inherits <- base::inherits
[17:38:35.501]                     invokeRestart <- base::invokeRestart
[17:38:35.501]                     is.null <- base::is.null
[17:38:35.501]                     muffled <- FALSE
[17:38:35.501]                     if (inherits(cond, "message")) {
[17:38:35.501]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:35.501]                       if (muffled) 
[17:38:35.501]                         invokeRestart("muffleMessage")
[17:38:35.501]                     }
[17:38:35.501]                     else if (inherits(cond, "warning")) {
[17:38:35.501]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:35.501]                       if (muffled) 
[17:38:35.501]                         invokeRestart("muffleWarning")
[17:38:35.501]                     }
[17:38:35.501]                     else if (inherits(cond, "condition")) {
[17:38:35.501]                       if (!is.null(pattern)) {
[17:38:35.501]                         computeRestarts <- base::computeRestarts
[17:38:35.501]                         grepl <- base::grepl
[17:38:35.501]                         restarts <- computeRestarts(cond)
[17:38:35.501]                         for (restart in restarts) {
[17:38:35.501]                           name <- restart$name
[17:38:35.501]                           if (is.null(name)) 
[17:38:35.501]                             next
[17:38:35.501]                           if (!grepl(pattern, name)) 
[17:38:35.501]                             next
[17:38:35.501]                           invokeRestart(restart)
[17:38:35.501]                           muffled <- TRUE
[17:38:35.501]                           break
[17:38:35.501]                         }
[17:38:35.501]                       }
[17:38:35.501]                     }
[17:38:35.501]                     invisible(muffled)
[17:38:35.501]                   }
[17:38:35.501]                   muffleCondition(cond)
[17:38:35.501]                 })
[17:38:35.501]             }))
[17:38:35.501]             future::FutureResult(value = ...future.value$value, 
[17:38:35.501]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:35.501]                   ...future.rng), globalenv = if (FALSE) 
[17:38:35.501]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:35.501]                     ...future.globalenv.names))
[17:38:35.501]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:35.501]         }, condition = base::local({
[17:38:35.501]             c <- base::c
[17:38:35.501]             inherits <- base::inherits
[17:38:35.501]             invokeRestart <- base::invokeRestart
[17:38:35.501]             length <- base::length
[17:38:35.501]             list <- base::list
[17:38:35.501]             seq.int <- base::seq.int
[17:38:35.501]             signalCondition <- base::signalCondition
[17:38:35.501]             sys.calls <- base::sys.calls
[17:38:35.501]             `[[` <- base::`[[`
[17:38:35.501]             `+` <- base::`+`
[17:38:35.501]             `<<-` <- base::`<<-`
[17:38:35.501]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:35.501]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:35.501]                   3L)]
[17:38:35.501]             }
[17:38:35.501]             function(cond) {
[17:38:35.501]                 is_error <- inherits(cond, "error")
[17:38:35.501]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:35.501]                   NULL)
[17:38:35.501]                 if (is_error) {
[17:38:35.501]                   sessionInformation <- function() {
[17:38:35.501]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:35.501]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:35.501]                       search = base::search(), system = base::Sys.info())
[17:38:35.501]                   }
[17:38:35.501]                   ...future.conditions[[length(...future.conditions) + 
[17:38:35.501]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:35.501]                     cond$call), session = sessionInformation(), 
[17:38:35.501]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:35.501]                   signalCondition(cond)
[17:38:35.501]                 }
[17:38:35.501]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:35.501]                 "immediateCondition"))) {
[17:38:35.501]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:35.501]                   ...future.conditions[[length(...future.conditions) + 
[17:38:35.501]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:35.501]                   if (TRUE && !signal) {
[17:38:35.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:35.501]                     {
[17:38:35.501]                       inherits <- base::inherits
[17:38:35.501]                       invokeRestart <- base::invokeRestart
[17:38:35.501]                       is.null <- base::is.null
[17:38:35.501]                       muffled <- FALSE
[17:38:35.501]                       if (inherits(cond, "message")) {
[17:38:35.501]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:35.501]                         if (muffled) 
[17:38:35.501]                           invokeRestart("muffleMessage")
[17:38:35.501]                       }
[17:38:35.501]                       else if (inherits(cond, "warning")) {
[17:38:35.501]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:35.501]                         if (muffled) 
[17:38:35.501]                           invokeRestart("muffleWarning")
[17:38:35.501]                       }
[17:38:35.501]                       else if (inherits(cond, "condition")) {
[17:38:35.501]                         if (!is.null(pattern)) {
[17:38:35.501]                           computeRestarts <- base::computeRestarts
[17:38:35.501]                           grepl <- base::grepl
[17:38:35.501]                           restarts <- computeRestarts(cond)
[17:38:35.501]                           for (restart in restarts) {
[17:38:35.501]                             name <- restart$name
[17:38:35.501]                             if (is.null(name)) 
[17:38:35.501]                               next
[17:38:35.501]                             if (!grepl(pattern, name)) 
[17:38:35.501]                               next
[17:38:35.501]                             invokeRestart(restart)
[17:38:35.501]                             muffled <- TRUE
[17:38:35.501]                             break
[17:38:35.501]                           }
[17:38:35.501]                         }
[17:38:35.501]                       }
[17:38:35.501]                       invisible(muffled)
[17:38:35.501]                     }
[17:38:35.501]                     muffleCondition(cond, pattern = "^muffle")
[17:38:35.501]                   }
[17:38:35.501]                 }
[17:38:35.501]                 else {
[17:38:35.501]                   if (TRUE) {
[17:38:35.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:35.501]                     {
[17:38:35.501]                       inherits <- base::inherits
[17:38:35.501]                       invokeRestart <- base::invokeRestart
[17:38:35.501]                       is.null <- base::is.null
[17:38:35.501]                       muffled <- FALSE
[17:38:35.501]                       if (inherits(cond, "message")) {
[17:38:35.501]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:35.501]                         if (muffled) 
[17:38:35.501]                           invokeRestart("muffleMessage")
[17:38:35.501]                       }
[17:38:35.501]                       else if (inherits(cond, "warning")) {
[17:38:35.501]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:35.501]                         if (muffled) 
[17:38:35.501]                           invokeRestart("muffleWarning")
[17:38:35.501]                       }
[17:38:35.501]                       else if (inherits(cond, "condition")) {
[17:38:35.501]                         if (!is.null(pattern)) {
[17:38:35.501]                           computeRestarts <- base::computeRestarts
[17:38:35.501]                           grepl <- base::grepl
[17:38:35.501]                           restarts <- computeRestarts(cond)
[17:38:35.501]                           for (restart in restarts) {
[17:38:35.501]                             name <- restart$name
[17:38:35.501]                             if (is.null(name)) 
[17:38:35.501]                               next
[17:38:35.501]                             if (!grepl(pattern, name)) 
[17:38:35.501]                               next
[17:38:35.501]                             invokeRestart(restart)
[17:38:35.501]                             muffled <- TRUE
[17:38:35.501]                             break
[17:38:35.501]                           }
[17:38:35.501]                         }
[17:38:35.501]                       }
[17:38:35.501]                       invisible(muffled)
[17:38:35.501]                     }
[17:38:35.501]                     muffleCondition(cond, pattern = "^muffle")
[17:38:35.501]                   }
[17:38:35.501]                 }
[17:38:35.501]             }
[17:38:35.501]         }))
[17:38:35.501]     }, error = function(ex) {
[17:38:35.501]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:35.501]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:35.501]                 ...future.rng), started = ...future.startTime, 
[17:38:35.501]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:35.501]             version = "1.8"), class = "FutureResult")
[17:38:35.501]     }, finally = {
[17:38:35.501]         if (!identical(...future.workdir, getwd())) 
[17:38:35.501]             setwd(...future.workdir)
[17:38:35.501]         {
[17:38:35.501]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:35.501]                 ...future.oldOptions$nwarnings <- NULL
[17:38:35.501]             }
[17:38:35.501]             base::options(...future.oldOptions)
[17:38:35.501]             if (.Platform$OS.type == "windows") {
[17:38:35.501]                 old_names <- names(...future.oldEnvVars)
[17:38:35.501]                 envs <- base::Sys.getenv()
[17:38:35.501]                 names <- names(envs)
[17:38:35.501]                 common <- intersect(names, old_names)
[17:38:35.501]                 added <- setdiff(names, old_names)
[17:38:35.501]                 removed <- setdiff(old_names, names)
[17:38:35.501]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:35.501]                   envs[common]]
[17:38:35.501]                 NAMES <- toupper(changed)
[17:38:35.501]                 args <- list()
[17:38:35.501]                 for (kk in seq_along(NAMES)) {
[17:38:35.501]                   name <- changed[[kk]]
[17:38:35.501]                   NAME <- NAMES[[kk]]
[17:38:35.501]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:35.501]                     next
[17:38:35.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:35.501]                 }
[17:38:35.501]                 NAMES <- toupper(added)
[17:38:35.501]                 for (kk in seq_along(NAMES)) {
[17:38:35.501]                   name <- added[[kk]]
[17:38:35.501]                   NAME <- NAMES[[kk]]
[17:38:35.501]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:35.501]                     next
[17:38:35.501]                   args[[name]] <- ""
[17:38:35.501]                 }
[17:38:35.501]                 NAMES <- toupper(removed)
[17:38:35.501]                 for (kk in seq_along(NAMES)) {
[17:38:35.501]                   name <- removed[[kk]]
[17:38:35.501]                   NAME <- NAMES[[kk]]
[17:38:35.501]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:35.501]                     next
[17:38:35.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:35.501]                 }
[17:38:35.501]                 if (length(args) > 0) 
[17:38:35.501]                   base::do.call(base::Sys.setenv, args = args)
[17:38:35.501]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:35.501]             }
[17:38:35.501]             else {
[17:38:35.501]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:35.501]             }
[17:38:35.501]             {
[17:38:35.501]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:35.501]                   0L) {
[17:38:35.501]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:35.501]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:35.501]                   base::options(opts)
[17:38:35.501]                 }
[17:38:35.501]                 {
[17:38:35.501]                   {
[17:38:35.501]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:35.501]                     NULL
[17:38:35.501]                   }
[17:38:35.501]                   options(future.plan = NULL)
[17:38:35.501]                   if (is.na(NA_character_)) 
[17:38:35.501]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:35.501]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:35.501]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:35.501]                     .init = FALSE)
[17:38:35.501]                 }
[17:38:35.501]             }
[17:38:35.501]         }
[17:38:35.501]     })
[17:38:35.501]     if (TRUE) {
[17:38:35.501]         base::sink(type = "output", split = FALSE)
[17:38:35.501]         if (TRUE) {
[17:38:35.501]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:35.501]         }
[17:38:35.501]         else {
[17:38:35.501]             ...future.result["stdout"] <- base::list(NULL)
[17:38:35.501]         }
[17:38:35.501]         base::close(...future.stdout)
[17:38:35.501]         ...future.stdout <- NULL
[17:38:35.501]     }
[17:38:35.501]     ...future.result$conditions <- ...future.conditions
[17:38:35.501]     ...future.result$finished <- base::Sys.time()
[17:38:35.501]     ...future.result
[17:38:35.501] }
[17:38:35.503] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[17:38:35.504] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[17:38:35.504] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[17:38:35.504] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:38:35.505] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:38:35.505] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:38:35.505] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:38:35.505] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:38:35.506] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:38:35.506] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:38:35.506] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:38:35.506] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[17:38:35.507] MultisessionFuture started
[17:38:35.507] - Launch lazy future ... done
[17:38:35.507] run() for ‘MultisessionFuture’ ... done
[17:38:35.507] Created future:
[17:38:35.507] MultisessionFuture:
[17:38:35.507] Label: ‘future_lapply-2’
[17:38:35.507] Expression:
[17:38:35.507] {
[17:38:35.507]     do.call(function(...) {
[17:38:35.507]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:35.507]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:35.507]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:35.507]             on.exit(options(oopts), add = TRUE)
[17:38:35.507]         }
[17:38:35.507]         {
[17:38:35.507]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:35.507]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:35.507]                 ...future.FUN(...future.X_jj, ...)
[17:38:35.507]             })
[17:38:35.507]         }
[17:38:35.507]     }, args = future.call.arguments)
[17:38:35.507] }
[17:38:35.507] Lazy evaluation: FALSE
[17:38:35.507] Asynchronous evaluation: TRUE
[17:38:35.507] Local evaluation: TRUE
[17:38:35.507] Environment: R_GlobalEnv
[17:38:35.507] Capture standard output: TRUE
[17:38:35.507] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:35.507] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:35.507] Packages: <none>
[17:38:35.507] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:35.507] Resolved: FALSE
[17:38:35.507] Value: <not collected>
[17:38:35.507] Conditions captured: <none>
[17:38:35.507] Early signaling: FALSE
[17:38:35.507] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:35.507] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:35.519] Chunk #2 of 2 ... DONE
[17:38:35.519] Launching 2 futures (chunks) ... DONE
[17:38:35.519] Resolving 2 futures (chunks) ...
[17:38:35.519] resolve() on list ...
[17:38:35.519]  recursive: 0
[17:38:35.520]  length: 2
[17:38:35.520] 
[17:38:35.562] receiveMessageFromWorker() for ClusterFuture ...
[17:38:35.562] - Validating connection of MultisessionFuture
[17:38:35.562] - received message: FutureResult
[17:38:35.562] - Received FutureResult
[17:38:35.562] - Erased future from FutureRegistry
[17:38:35.562] result() for ClusterFuture ...
[17:38:35.562] - result already collected: FutureResult
[17:38:35.563] result() for ClusterFuture ... done
[17:38:35.563] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:35.563] Future #2
[17:38:35.563] result() for ClusterFuture ...
[17:38:35.563] - result already collected: FutureResult
[17:38:35.563] result() for ClusterFuture ... done
[17:38:35.563] result() for ClusterFuture ...
[17:38:35.563] - result already collected: FutureResult
[17:38:35.563] result() for ClusterFuture ... done
[17:38:35.563] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:38:35.563] - nx: 2
[17:38:35.564] - relay: TRUE
[17:38:35.564] - stdout: TRUE
[17:38:35.564] - signal: TRUE
[17:38:35.564] - resignal: FALSE
[17:38:35.564] - force: TRUE
[17:38:35.564] - relayed: [n=2] FALSE, FALSE
[17:38:35.564] - queued futures: [n=2] FALSE, FALSE
[17:38:35.564]  - until=1
[17:38:35.564]  - relaying element #1
[17:38:35.564] - relayed: [n=2] FALSE, FALSE
[17:38:35.564] - queued futures: [n=2] FALSE, TRUE
[17:38:35.565] signalConditionsASAP(NULL, pos=2) ... done
[17:38:35.565]  length: 1 (resolved future 2)
[17:38:36.015] receiveMessageFromWorker() for ClusterFuture ...
[17:38:36.015] - Validating connection of MultisessionFuture
[17:38:36.015] - received message: FutureResult
[17:38:36.016] - Received FutureResult
[17:38:36.016] - Erased future from FutureRegistry
[17:38:36.016] result() for ClusterFuture ...
[17:38:36.016] - result already collected: FutureResult
[17:38:36.016] result() for ClusterFuture ... done
[17:38:36.016] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:36.016] Future #1
[17:38:36.016] result() for ClusterFuture ...
[17:38:36.016] - result already collected: FutureResult
[17:38:36.016] result() for ClusterFuture ... done
[17:38:36.017] result() for ClusterFuture ...
[17:38:36.017] - result already collected: FutureResult
[17:38:36.017] result() for ClusterFuture ... done
[17:38:36.017] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:38:36.017] - nx: 2
[17:38:36.017] - relay: TRUE
[17:38:36.017] - stdout: TRUE
[17:38:36.017] - signal: TRUE
[17:38:36.017] - resignal: FALSE
[17:38:36.017] - force: TRUE
[17:38:36.017] - relayed: [n=2] FALSE, FALSE
[17:38:36.017] - queued futures: [n=2] FALSE, TRUE
[17:38:36.018]  - until=1
[17:38:36.018]  - relaying element #1
[17:38:36.018] result() for ClusterFuture ...
[17:38:36.018] - result already collected: FutureResult
[17:38:36.018] result() for ClusterFuture ... done
[17:38:36.018] result() for ClusterFuture ...
[17:38:36.018] - result already collected: FutureResult
[17:38:36.018] result() for ClusterFuture ... done
[17:38:36.018] result() for ClusterFuture ...
[17:38:36.018] - result already collected: FutureResult
[17:38:36.018] result() for ClusterFuture ... done
[17:38:36.019] result() for ClusterFuture ...
[17:38:36.019] - result already collected: FutureResult
[17:38:36.019] result() for ClusterFuture ... done
[17:38:36.019] - relayed: [n=2] TRUE, FALSE
[17:38:36.019] - queued futures: [n=2] TRUE, TRUE
[17:38:36.019] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:38:36.019]  length: 0 (resolved future 1)
[17:38:36.019] Relaying remaining futures
[17:38:36.019] signalConditionsASAP(NULL, pos=0) ...
[17:38:36.019] - nx: 2
[17:38:36.019] - relay: TRUE
[17:38:36.019] - stdout: TRUE
[17:38:36.020] - signal: TRUE
[17:38:36.020] - resignal: FALSE
[17:38:36.020] - force: TRUE
[17:38:36.020] - relayed: [n=2] TRUE, FALSE
[17:38:36.020] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:36.020]  - relaying element #2
[17:38:36.020] result() for ClusterFuture ...
[17:38:36.020] - result already collected: FutureResult
[17:38:36.020] result() for ClusterFuture ... done
[17:38:36.020] result() for ClusterFuture ...
[17:38:36.020] - result already collected: FutureResult
[17:38:36.022] result() for ClusterFuture ... done
[17:38:36.023] result() for ClusterFuture ...
[17:38:36.023] - result already collected: FutureResult
[17:38:36.023] result() for ClusterFuture ... done
[17:38:36.023] result() for ClusterFuture ...
[17:38:36.023] - result already collected: FutureResult
[17:38:36.023] result() for ClusterFuture ... done
[17:38:36.023] - relayed: [n=2] TRUE, TRUE
[17:38:36.023] - queued futures: [n=2] TRUE, TRUE
[17:38:36.023] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:38:36.023] resolve() on list ... DONE
[17:38:36.023] result() for ClusterFuture ...
[17:38:36.024] - result already collected: FutureResult
[17:38:36.024] result() for ClusterFuture ... done
[17:38:36.024] result() for ClusterFuture ...
[17:38:36.024] - result already collected: FutureResult
[17:38:36.024] result() for ClusterFuture ... done
[17:38:36.024] result() for ClusterFuture ...
[17:38:36.024] - result already collected: FutureResult
[17:38:36.024] result() for ClusterFuture ... done
[17:38:36.024] result() for ClusterFuture ...
[17:38:36.024] - result already collected: FutureResult
[17:38:36.024] result() for ClusterFuture ... done
[17:38:36.025]  - Number of value chunks collected: 2
[17:38:36.025] Resolving 2 futures (chunks) ... DONE
[17:38:36.025] Reducing values from 2 chunks ...
[17:38:36.025]  - Number of values collected after concatenation: 2
[17:38:36.025]  - Number of values expected: 2
[17:38:36.025] Reducing values from 2 chunks ... DONE
[17:38:36.025] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[17:38:36.025] future_lapply() ...
[17:38:36.030] Number of chunks: 2
[17:38:36.030] getGlobalsAndPackagesXApply() ...
[17:38:36.030]  - future.globals: TRUE
[17:38:36.030] getGlobalsAndPackages() ...
[17:38:36.030] Searching for globals...
[17:38:36.031] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:38:36.032] Searching for globals ... DONE
[17:38:36.032] Resolving globals: FALSE
[17:38:36.032] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:38:36.032] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:38:36.033] - globals: [1] ‘FUN’
[17:38:36.033] 
[17:38:36.033] getGlobalsAndPackages() ... DONE
[17:38:36.033]  - globals found/used: [n=1] ‘FUN’
[17:38:36.033]  - needed namespaces: [n=0] 
[17:38:36.033] Finding globals ... DONE
[17:38:36.033]  - use_args: TRUE
[17:38:36.033]  - Getting '...' globals ...
[17:38:36.034] resolve() on list ...
[17:38:36.034]  recursive: 0
[17:38:36.034]  length: 1
[17:38:36.034]  elements: ‘...’
[17:38:36.034]  length: 0 (resolved future 1)
[17:38:36.034] resolve() on list ... DONE
[17:38:36.034]    - '...' content: [n=0] 
[17:38:36.034] List of 1
[17:38:36.034]  $ ...: list()
[17:38:36.034]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:36.034]  - attr(*, "where")=List of 1
[17:38:36.034]   ..$ ...:<environment: 0x5628ac3c9ed8> 
[17:38:36.034]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:36.034]  - attr(*, "resolved")= logi TRUE
[17:38:36.034]  - attr(*, "total_size")= num NA
[17:38:36.037]  - Getting '...' globals ... DONE
[17:38:36.037] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:38:36.037] List of 2
[17:38:36.037]  $ ...future.FUN:function (x)  
[17:38:36.037]  $ ...          : list()
[17:38:36.037]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:36.037]  - attr(*, "where")=List of 2
[17:38:36.037]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:36.037]   ..$ ...          :<environment: 0x5628ac3c9ed8> 
[17:38:36.037]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:36.037]  - attr(*, "resolved")= logi FALSE
[17:38:36.037]  - attr(*, "total_size")= num 4720
[17:38:36.039] Packages to be attached in all futures: [n=0] 
[17:38:36.039] getGlobalsAndPackagesXApply() ... DONE
[17:38:36.040] Number of futures (= number of chunks): 2
[17:38:36.040] Launching 2 futures (chunks) ...
[17:38:36.040] Chunk #1 of 2 ...
[17:38:36.040]  - Finding globals in 'X' for chunk #1 ...
[17:38:36.040] getGlobalsAndPackages() ...
[17:38:36.040] Searching for globals...
[17:38:36.040] 
[17:38:36.041] Searching for globals ... DONE
[17:38:36.041] - globals: [0] <none>
[17:38:36.041] getGlobalsAndPackages() ... DONE
[17:38:36.041]    + additional globals found: [n=0] 
[17:38:36.041]    + additional namespaces needed: [n=0] 
[17:38:36.041]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:36.041]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:36.041]  - seeds: <none>
[17:38:36.041]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:36.041] getGlobalsAndPackages() ...
[17:38:36.041] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:36.041] Resolving globals: FALSE
[17:38:36.042] Tweak future expression to call with '...' arguments ...
[17:38:36.042] {
[17:38:36.042]     do.call(function(...) {
[17:38:36.042]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:36.042]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:36.042]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:36.042]             on.exit(options(oopts), add = TRUE)
[17:38:36.042]         }
[17:38:36.042]         {
[17:38:36.042]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:36.042]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:36.042]                 ...future.FUN(...future.X_jj, ...)
[17:38:36.042]             })
[17:38:36.042]         }
[17:38:36.042]     }, args = future.call.arguments)
[17:38:36.042] }
[17:38:36.042] Tweak future expression to call with '...' arguments ... DONE
[17:38:36.042] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:36.042] 
[17:38:36.042] getGlobalsAndPackages() ... DONE
[17:38:36.043] run() for ‘Future’ ...
[17:38:36.043] - state: ‘created’
[17:38:36.043] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:36.059] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:36.059] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:36.059]   - Field: ‘node’
[17:38:36.059]   - Field: ‘label’
[17:38:36.059]   - Field: ‘local’
[17:38:36.059]   - Field: ‘owner’
[17:38:36.059]   - Field: ‘envir’
[17:38:36.059]   - Field: ‘workers’
[17:38:36.059]   - Field: ‘packages’
[17:38:36.060]   - Field: ‘gc’
[17:38:36.060]   - Field: ‘conditions’
[17:38:36.060]   - Field: ‘persistent’
[17:38:36.060]   - Field: ‘expr’
[17:38:36.060]   - Field: ‘uuid’
[17:38:36.060]   - Field: ‘seed’
[17:38:36.060]   - Field: ‘version’
[17:38:36.060]   - Field: ‘result’
[17:38:36.060]   - Field: ‘asynchronous’
[17:38:36.060]   - Field: ‘calls’
[17:38:36.060]   - Field: ‘globals’
[17:38:36.061]   - Field: ‘stdout’
[17:38:36.061]   - Field: ‘earlySignal’
[17:38:36.061]   - Field: ‘lazy’
[17:38:36.061]   - Field: ‘state’
[17:38:36.061] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:36.061] - Launch lazy future ...
[17:38:36.061] Packages needed by the future expression (n = 0): <none>
[17:38:36.061] Packages needed by future strategies (n = 0): <none>
[17:38:36.062] {
[17:38:36.062]     {
[17:38:36.062]         {
[17:38:36.062]             ...future.startTime <- base::Sys.time()
[17:38:36.062]             {
[17:38:36.062]                 {
[17:38:36.062]                   {
[17:38:36.062]                     {
[17:38:36.062]                       base::local({
[17:38:36.062]                         has_future <- base::requireNamespace("future", 
[17:38:36.062]                           quietly = TRUE)
[17:38:36.062]                         if (has_future) {
[17:38:36.062]                           ns <- base::getNamespace("future")
[17:38:36.062]                           version <- ns[[".package"]][["version"]]
[17:38:36.062]                           if (is.null(version)) 
[17:38:36.062]                             version <- utils::packageVersion("future")
[17:38:36.062]                         }
[17:38:36.062]                         else {
[17:38:36.062]                           version <- NULL
[17:38:36.062]                         }
[17:38:36.062]                         if (!has_future || version < "1.8.0") {
[17:38:36.062]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:36.062]                             "", base::R.version$version.string), 
[17:38:36.062]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:36.062]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:36.062]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:36.062]                               "release", "version")], collapse = " "), 
[17:38:36.062]                             hostname = base::Sys.info()[["nodename"]])
[17:38:36.062]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:36.062]                             info)
[17:38:36.062]                           info <- base::paste(info, collapse = "; ")
[17:38:36.062]                           if (!has_future) {
[17:38:36.062]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:36.062]                               info)
[17:38:36.062]                           }
[17:38:36.062]                           else {
[17:38:36.062]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:36.062]                               info, version)
[17:38:36.062]                           }
[17:38:36.062]                           base::stop(msg)
[17:38:36.062]                         }
[17:38:36.062]                       })
[17:38:36.062]                     }
[17:38:36.062]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:36.062]                     base::options(mc.cores = 1L)
[17:38:36.062]                   }
[17:38:36.062]                   ...future.strategy.old <- future::plan("list")
[17:38:36.062]                   options(future.plan = NULL)
[17:38:36.062]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:36.062]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:36.062]                 }
[17:38:36.062]                 ...future.workdir <- getwd()
[17:38:36.062]             }
[17:38:36.062]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:36.062]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:36.062]         }
[17:38:36.062]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:36.062]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:36.062]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:36.062]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:36.062]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:36.062]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:36.062]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:36.062]             base::names(...future.oldOptions))
[17:38:36.062]     }
[17:38:36.062]     if (TRUE) {
[17:38:36.062]     }
[17:38:36.062]     else {
[17:38:36.062]         if (NA) {
[17:38:36.062]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:36.062]                 open = "w")
[17:38:36.062]         }
[17:38:36.062]         else {
[17:38:36.062]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:36.062]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:36.062]         }
[17:38:36.062]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:36.062]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:36.062]             base::sink(type = "output", split = FALSE)
[17:38:36.062]             base::close(...future.stdout)
[17:38:36.062]         }, add = TRUE)
[17:38:36.062]     }
[17:38:36.062]     ...future.frame <- base::sys.nframe()
[17:38:36.062]     ...future.conditions <- base::list()
[17:38:36.062]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:36.062]     if (FALSE) {
[17:38:36.062]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:36.062]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:36.062]     }
[17:38:36.062]     ...future.result <- base::tryCatch({
[17:38:36.062]         base::withCallingHandlers({
[17:38:36.062]             ...future.value <- base::withVisible(base::local({
[17:38:36.062]                 ...future.makeSendCondition <- base::local({
[17:38:36.062]                   sendCondition <- NULL
[17:38:36.062]                   function(frame = 1L) {
[17:38:36.062]                     if (is.function(sendCondition)) 
[17:38:36.062]                       return(sendCondition)
[17:38:36.062]                     ns <- getNamespace("parallel")
[17:38:36.062]                     if (exists("sendData", mode = "function", 
[17:38:36.062]                       envir = ns)) {
[17:38:36.062]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:36.062]                         envir = ns)
[17:38:36.062]                       envir <- sys.frame(frame)
[17:38:36.062]                       master <- NULL
[17:38:36.062]                       while (!identical(envir, .GlobalEnv) && 
[17:38:36.062]                         !identical(envir, emptyenv())) {
[17:38:36.062]                         if (exists("master", mode = "list", envir = envir, 
[17:38:36.062]                           inherits = FALSE)) {
[17:38:36.062]                           master <- get("master", mode = "list", 
[17:38:36.062]                             envir = envir, inherits = FALSE)
[17:38:36.062]                           if (inherits(master, c("SOCKnode", 
[17:38:36.062]                             "SOCK0node"))) {
[17:38:36.062]                             sendCondition <<- function(cond) {
[17:38:36.062]                               data <- list(type = "VALUE", value = cond, 
[17:38:36.062]                                 success = TRUE)
[17:38:36.062]                               parallel_sendData(master, data)
[17:38:36.062]                             }
[17:38:36.062]                             return(sendCondition)
[17:38:36.062]                           }
[17:38:36.062]                         }
[17:38:36.062]                         frame <- frame + 1L
[17:38:36.062]                         envir <- sys.frame(frame)
[17:38:36.062]                       }
[17:38:36.062]                     }
[17:38:36.062]                     sendCondition <<- function(cond) NULL
[17:38:36.062]                   }
[17:38:36.062]                 })
[17:38:36.062]                 withCallingHandlers({
[17:38:36.062]                   {
[17:38:36.062]                     do.call(function(...) {
[17:38:36.062]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:36.062]                       if (!identical(...future.globals.maxSize.org, 
[17:38:36.062]                         ...future.globals.maxSize)) {
[17:38:36.062]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:36.062]                         on.exit(options(oopts), add = TRUE)
[17:38:36.062]                       }
[17:38:36.062]                       {
[17:38:36.062]                         lapply(seq_along(...future.elements_ii), 
[17:38:36.062]                           FUN = function(jj) {
[17:38:36.062]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:36.062]                             ...future.FUN(...future.X_jj, ...)
[17:38:36.062]                           })
[17:38:36.062]                       }
[17:38:36.062]                     }, args = future.call.arguments)
[17:38:36.062]                   }
[17:38:36.062]                 }, immediateCondition = function(cond) {
[17:38:36.062]                   sendCondition <- ...future.makeSendCondition()
[17:38:36.062]                   sendCondition(cond)
[17:38:36.062]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:36.062]                   {
[17:38:36.062]                     inherits <- base::inherits
[17:38:36.062]                     invokeRestart <- base::invokeRestart
[17:38:36.062]                     is.null <- base::is.null
[17:38:36.062]                     muffled <- FALSE
[17:38:36.062]                     if (inherits(cond, "message")) {
[17:38:36.062]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:36.062]                       if (muffled) 
[17:38:36.062]                         invokeRestart("muffleMessage")
[17:38:36.062]                     }
[17:38:36.062]                     else if (inherits(cond, "warning")) {
[17:38:36.062]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:36.062]                       if (muffled) 
[17:38:36.062]                         invokeRestart("muffleWarning")
[17:38:36.062]                     }
[17:38:36.062]                     else if (inherits(cond, "condition")) {
[17:38:36.062]                       if (!is.null(pattern)) {
[17:38:36.062]                         computeRestarts <- base::computeRestarts
[17:38:36.062]                         grepl <- base::grepl
[17:38:36.062]                         restarts <- computeRestarts(cond)
[17:38:36.062]                         for (restart in restarts) {
[17:38:36.062]                           name <- restart$name
[17:38:36.062]                           if (is.null(name)) 
[17:38:36.062]                             next
[17:38:36.062]                           if (!grepl(pattern, name)) 
[17:38:36.062]                             next
[17:38:36.062]                           invokeRestart(restart)
[17:38:36.062]                           muffled <- TRUE
[17:38:36.062]                           break
[17:38:36.062]                         }
[17:38:36.062]                       }
[17:38:36.062]                     }
[17:38:36.062]                     invisible(muffled)
[17:38:36.062]                   }
[17:38:36.062]                   muffleCondition(cond)
[17:38:36.062]                 })
[17:38:36.062]             }))
[17:38:36.062]             future::FutureResult(value = ...future.value$value, 
[17:38:36.062]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:36.062]                   ...future.rng), globalenv = if (FALSE) 
[17:38:36.062]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:36.062]                     ...future.globalenv.names))
[17:38:36.062]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:36.062]         }, condition = base::local({
[17:38:36.062]             c <- base::c
[17:38:36.062]             inherits <- base::inherits
[17:38:36.062]             invokeRestart <- base::invokeRestart
[17:38:36.062]             length <- base::length
[17:38:36.062]             list <- base::list
[17:38:36.062]             seq.int <- base::seq.int
[17:38:36.062]             signalCondition <- base::signalCondition
[17:38:36.062]             sys.calls <- base::sys.calls
[17:38:36.062]             `[[` <- base::`[[`
[17:38:36.062]             `+` <- base::`+`
[17:38:36.062]             `<<-` <- base::`<<-`
[17:38:36.062]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:36.062]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:36.062]                   3L)]
[17:38:36.062]             }
[17:38:36.062]             function(cond) {
[17:38:36.062]                 is_error <- inherits(cond, "error")
[17:38:36.062]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:36.062]                   NULL)
[17:38:36.062]                 if (is_error) {
[17:38:36.062]                   sessionInformation <- function() {
[17:38:36.062]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:36.062]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:36.062]                       search = base::search(), system = base::Sys.info())
[17:38:36.062]                   }
[17:38:36.062]                   ...future.conditions[[length(...future.conditions) + 
[17:38:36.062]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:36.062]                     cond$call), session = sessionInformation(), 
[17:38:36.062]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:36.062]                   signalCondition(cond)
[17:38:36.062]                 }
[17:38:36.062]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:36.062]                 "immediateCondition"))) {
[17:38:36.062]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:36.062]                   ...future.conditions[[length(...future.conditions) + 
[17:38:36.062]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:36.062]                   if (TRUE && !signal) {
[17:38:36.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:36.062]                     {
[17:38:36.062]                       inherits <- base::inherits
[17:38:36.062]                       invokeRestart <- base::invokeRestart
[17:38:36.062]                       is.null <- base::is.null
[17:38:36.062]                       muffled <- FALSE
[17:38:36.062]                       if (inherits(cond, "message")) {
[17:38:36.062]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:36.062]                         if (muffled) 
[17:38:36.062]                           invokeRestart("muffleMessage")
[17:38:36.062]                       }
[17:38:36.062]                       else if (inherits(cond, "warning")) {
[17:38:36.062]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:36.062]                         if (muffled) 
[17:38:36.062]                           invokeRestart("muffleWarning")
[17:38:36.062]                       }
[17:38:36.062]                       else if (inherits(cond, "condition")) {
[17:38:36.062]                         if (!is.null(pattern)) {
[17:38:36.062]                           computeRestarts <- base::computeRestarts
[17:38:36.062]                           grepl <- base::grepl
[17:38:36.062]                           restarts <- computeRestarts(cond)
[17:38:36.062]                           for (restart in restarts) {
[17:38:36.062]                             name <- restart$name
[17:38:36.062]                             if (is.null(name)) 
[17:38:36.062]                               next
[17:38:36.062]                             if (!grepl(pattern, name)) 
[17:38:36.062]                               next
[17:38:36.062]                             invokeRestart(restart)
[17:38:36.062]                             muffled <- TRUE
[17:38:36.062]                             break
[17:38:36.062]                           }
[17:38:36.062]                         }
[17:38:36.062]                       }
[17:38:36.062]                       invisible(muffled)
[17:38:36.062]                     }
[17:38:36.062]                     muffleCondition(cond, pattern = "^muffle")
[17:38:36.062]                   }
[17:38:36.062]                 }
[17:38:36.062]                 else {
[17:38:36.062]                   if (TRUE) {
[17:38:36.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:36.062]                     {
[17:38:36.062]                       inherits <- base::inherits
[17:38:36.062]                       invokeRestart <- base::invokeRestart
[17:38:36.062]                       is.null <- base::is.null
[17:38:36.062]                       muffled <- FALSE
[17:38:36.062]                       if (inherits(cond, "message")) {
[17:38:36.062]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:36.062]                         if (muffled) 
[17:38:36.062]                           invokeRestart("muffleMessage")
[17:38:36.062]                       }
[17:38:36.062]                       else if (inherits(cond, "warning")) {
[17:38:36.062]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:36.062]                         if (muffled) 
[17:38:36.062]                           invokeRestart("muffleWarning")
[17:38:36.062]                       }
[17:38:36.062]                       else if (inherits(cond, "condition")) {
[17:38:36.062]                         if (!is.null(pattern)) {
[17:38:36.062]                           computeRestarts <- base::computeRestarts
[17:38:36.062]                           grepl <- base::grepl
[17:38:36.062]                           restarts <- computeRestarts(cond)
[17:38:36.062]                           for (restart in restarts) {
[17:38:36.062]                             name <- restart$name
[17:38:36.062]                             if (is.null(name)) 
[17:38:36.062]                               next
[17:38:36.062]                             if (!grepl(pattern, name)) 
[17:38:36.062]                               next
[17:38:36.062]                             invokeRestart(restart)
[17:38:36.062]                             muffled <- TRUE
[17:38:36.062]                             break
[17:38:36.062]                           }
[17:38:36.062]                         }
[17:38:36.062]                       }
[17:38:36.062]                       invisible(muffled)
[17:38:36.062]                     }
[17:38:36.062]                     muffleCondition(cond, pattern = "^muffle")
[17:38:36.062]                   }
[17:38:36.062]                 }
[17:38:36.062]             }
[17:38:36.062]         }))
[17:38:36.062]     }, error = function(ex) {
[17:38:36.062]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:36.062]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:36.062]                 ...future.rng), started = ...future.startTime, 
[17:38:36.062]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:36.062]             version = "1.8"), class = "FutureResult")
[17:38:36.062]     }, finally = {
[17:38:36.062]         if (!identical(...future.workdir, getwd())) 
[17:38:36.062]             setwd(...future.workdir)
[17:38:36.062]         {
[17:38:36.062]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:36.062]                 ...future.oldOptions$nwarnings <- NULL
[17:38:36.062]             }
[17:38:36.062]             base::options(...future.oldOptions)
[17:38:36.062]             if (.Platform$OS.type == "windows") {
[17:38:36.062]                 old_names <- names(...future.oldEnvVars)
[17:38:36.062]                 envs <- base::Sys.getenv()
[17:38:36.062]                 names <- names(envs)
[17:38:36.062]                 common <- intersect(names, old_names)
[17:38:36.062]                 added <- setdiff(names, old_names)
[17:38:36.062]                 removed <- setdiff(old_names, names)
[17:38:36.062]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:36.062]                   envs[common]]
[17:38:36.062]                 NAMES <- toupper(changed)
[17:38:36.062]                 args <- list()
[17:38:36.062]                 for (kk in seq_along(NAMES)) {
[17:38:36.062]                   name <- changed[[kk]]
[17:38:36.062]                   NAME <- NAMES[[kk]]
[17:38:36.062]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:36.062]                     next
[17:38:36.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:36.062]                 }
[17:38:36.062]                 NAMES <- toupper(added)
[17:38:36.062]                 for (kk in seq_along(NAMES)) {
[17:38:36.062]                   name <- added[[kk]]
[17:38:36.062]                   NAME <- NAMES[[kk]]
[17:38:36.062]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:36.062]                     next
[17:38:36.062]                   args[[name]] <- ""
[17:38:36.062]                 }
[17:38:36.062]                 NAMES <- toupper(removed)
[17:38:36.062]                 for (kk in seq_along(NAMES)) {
[17:38:36.062]                   name <- removed[[kk]]
[17:38:36.062]                   NAME <- NAMES[[kk]]
[17:38:36.062]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:36.062]                     next
[17:38:36.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:36.062]                 }
[17:38:36.062]                 if (length(args) > 0) 
[17:38:36.062]                   base::do.call(base::Sys.setenv, args = args)
[17:38:36.062]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:36.062]             }
[17:38:36.062]             else {
[17:38:36.062]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:36.062]             }
[17:38:36.062]             {
[17:38:36.062]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:36.062]                   0L) {
[17:38:36.062]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:36.062]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:36.062]                   base::options(opts)
[17:38:36.062]                 }
[17:38:36.062]                 {
[17:38:36.062]                   {
[17:38:36.062]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:36.062]                     NULL
[17:38:36.062]                   }
[17:38:36.062]                   options(future.plan = NULL)
[17:38:36.062]                   if (is.na(NA_character_)) 
[17:38:36.062]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:36.062]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:36.062]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:36.062]                     .init = FALSE)
[17:38:36.062]                 }
[17:38:36.062]             }
[17:38:36.062]         }
[17:38:36.062]     })
[17:38:36.062]     if (FALSE) {
[17:38:36.062]         base::sink(type = "output", split = FALSE)
[17:38:36.062]         if (NA) {
[17:38:36.062]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:36.062]         }
[17:38:36.062]         else {
[17:38:36.062]             ...future.result["stdout"] <- base::list(NULL)
[17:38:36.062]         }
[17:38:36.062]         base::close(...future.stdout)
[17:38:36.062]         ...future.stdout <- NULL
[17:38:36.062]     }
[17:38:36.062]     ...future.result$conditions <- ...future.conditions
[17:38:36.062]     ...future.result$finished <- base::Sys.time()
[17:38:36.062]     ...future.result
[17:38:36.062] }
[17:38:36.065] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[17:38:36.065] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[17:38:36.065] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[17:38:36.065] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:38:36.066] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:38:36.066] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:38:36.066] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:38:36.066] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:38:36.067] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:38:36.067] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:38:36.067] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:38:36.067] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[17:38:36.068] MultisessionFuture started
[17:38:36.068] - Launch lazy future ... done
[17:38:36.068] run() for ‘MultisessionFuture’ ... done
[17:38:36.068] Created future:
[17:38:36.068] MultisessionFuture:
[17:38:36.068] Label: ‘future_lapply-1’
[17:38:36.068] Expression:
[17:38:36.068] {
[17:38:36.068]     do.call(function(...) {
[17:38:36.068]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:36.068]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:36.068]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:36.068]             on.exit(options(oopts), add = TRUE)
[17:38:36.068]         }
[17:38:36.068]         {
[17:38:36.068]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:36.068]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:36.068]                 ...future.FUN(...future.X_jj, ...)
[17:38:36.068]             })
[17:38:36.068]         }
[17:38:36.068]     }, args = future.call.arguments)
[17:38:36.068] }
[17:38:36.068] Lazy evaluation: FALSE
[17:38:36.068] Asynchronous evaluation: TRUE
[17:38:36.068] Local evaluation: TRUE
[17:38:36.068] Environment: R_GlobalEnv
[17:38:36.068] Capture standard output: NA
[17:38:36.068] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:36.068] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:36.068] Packages: <none>
[17:38:36.068] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:36.068] Resolved: FALSE
[17:38:36.068] Value: <not collected>
[17:38:36.068] Conditions captured: <none>
[17:38:36.068] Early signaling: FALSE
[17:38:36.068] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:36.068] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:36.080] Chunk #1 of 2 ... DONE
[17:38:36.080] Chunk #2 of 2 ...
[17:38:36.080]  - Finding globals in 'X' for chunk #2 ...
[17:38:36.080] getGlobalsAndPackages() ...
[17:38:36.080] Searching for globals...
[17:38:36.080] 
[17:38:36.080] Searching for globals ... DONE
[17:38:36.081] - globals: [0] <none>
[17:38:36.081] getGlobalsAndPackages() ... DONE
[17:38:36.081]    + additional globals found: [n=0] 
[17:38:36.081]    + additional namespaces needed: [n=0] 
[17:38:36.081]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:36.081]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:36.081]  - seeds: <none>
[17:38:36.081]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:36.081] getGlobalsAndPackages() ...
[17:38:36.081] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:36.081] Resolving globals: FALSE
[17:38:36.082] Tweak future expression to call with '...' arguments ...
[17:38:36.082] {
[17:38:36.082]     do.call(function(...) {
[17:38:36.082]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:36.082]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:36.082]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:36.082]             on.exit(options(oopts), add = TRUE)
[17:38:36.082]         }
[17:38:36.082]         {
[17:38:36.082]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:36.082]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:36.082]                 ...future.FUN(...future.X_jj, ...)
[17:38:36.082]             })
[17:38:36.082]         }
[17:38:36.082]     }, args = future.call.arguments)
[17:38:36.082] }
[17:38:36.082] Tweak future expression to call with '...' arguments ... DONE
[17:38:36.082] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:36.082] 
[17:38:36.083] getGlobalsAndPackages() ... DONE
[17:38:36.083] run() for ‘Future’ ...
[17:38:36.083] - state: ‘created’
[17:38:36.083] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:36.097] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:36.097] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:36.097]   - Field: ‘node’
[17:38:36.097]   - Field: ‘label’
[17:38:36.097]   - Field: ‘local’
[17:38:36.097]   - Field: ‘owner’
[17:38:36.098]   - Field: ‘envir’
[17:38:36.098]   - Field: ‘workers’
[17:38:36.098]   - Field: ‘packages’
[17:38:36.098]   - Field: ‘gc’
[17:38:36.098]   - Field: ‘conditions’
[17:38:36.098]   - Field: ‘persistent’
[17:38:36.098]   - Field: ‘expr’
[17:38:36.098]   - Field: ‘uuid’
[17:38:36.098]   - Field: ‘seed’
[17:38:36.098]   - Field: ‘version’
[17:38:36.098]   - Field: ‘result’
[17:38:36.099]   - Field: ‘asynchronous’
[17:38:36.099]   - Field: ‘calls’
[17:38:36.099]   - Field: ‘globals’
[17:38:36.099]   - Field: ‘stdout’
[17:38:36.099]   - Field: ‘earlySignal’
[17:38:36.099]   - Field: ‘lazy’
[17:38:36.099]   - Field: ‘state’
[17:38:36.099] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:36.099] - Launch lazy future ...
[17:38:36.100] Packages needed by the future expression (n = 0): <none>
[17:38:36.100] Packages needed by future strategies (n = 0): <none>
[17:38:36.100] {
[17:38:36.100]     {
[17:38:36.100]         {
[17:38:36.100]             ...future.startTime <- base::Sys.time()
[17:38:36.100]             {
[17:38:36.100]                 {
[17:38:36.100]                   {
[17:38:36.100]                     {
[17:38:36.100]                       base::local({
[17:38:36.100]                         has_future <- base::requireNamespace("future", 
[17:38:36.100]                           quietly = TRUE)
[17:38:36.100]                         if (has_future) {
[17:38:36.100]                           ns <- base::getNamespace("future")
[17:38:36.100]                           version <- ns[[".package"]][["version"]]
[17:38:36.100]                           if (is.null(version)) 
[17:38:36.100]                             version <- utils::packageVersion("future")
[17:38:36.100]                         }
[17:38:36.100]                         else {
[17:38:36.100]                           version <- NULL
[17:38:36.100]                         }
[17:38:36.100]                         if (!has_future || version < "1.8.0") {
[17:38:36.100]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:36.100]                             "", base::R.version$version.string), 
[17:38:36.100]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:36.100]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:36.100]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:36.100]                               "release", "version")], collapse = " "), 
[17:38:36.100]                             hostname = base::Sys.info()[["nodename"]])
[17:38:36.100]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:36.100]                             info)
[17:38:36.100]                           info <- base::paste(info, collapse = "; ")
[17:38:36.100]                           if (!has_future) {
[17:38:36.100]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:36.100]                               info)
[17:38:36.100]                           }
[17:38:36.100]                           else {
[17:38:36.100]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:36.100]                               info, version)
[17:38:36.100]                           }
[17:38:36.100]                           base::stop(msg)
[17:38:36.100]                         }
[17:38:36.100]                       })
[17:38:36.100]                     }
[17:38:36.100]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:36.100]                     base::options(mc.cores = 1L)
[17:38:36.100]                   }
[17:38:36.100]                   ...future.strategy.old <- future::plan("list")
[17:38:36.100]                   options(future.plan = NULL)
[17:38:36.100]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:36.100]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:36.100]                 }
[17:38:36.100]                 ...future.workdir <- getwd()
[17:38:36.100]             }
[17:38:36.100]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:36.100]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:36.100]         }
[17:38:36.100]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:36.100]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:36.100]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:36.100]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:36.100]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:36.100]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:36.100]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:36.100]             base::names(...future.oldOptions))
[17:38:36.100]     }
[17:38:36.100]     if (TRUE) {
[17:38:36.100]     }
[17:38:36.100]     else {
[17:38:36.100]         if (NA) {
[17:38:36.100]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:36.100]                 open = "w")
[17:38:36.100]         }
[17:38:36.100]         else {
[17:38:36.100]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:36.100]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:36.100]         }
[17:38:36.100]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:36.100]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:36.100]             base::sink(type = "output", split = FALSE)
[17:38:36.100]             base::close(...future.stdout)
[17:38:36.100]         }, add = TRUE)
[17:38:36.100]     }
[17:38:36.100]     ...future.frame <- base::sys.nframe()
[17:38:36.100]     ...future.conditions <- base::list()
[17:38:36.100]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:36.100]     if (FALSE) {
[17:38:36.100]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:36.100]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:36.100]     }
[17:38:36.100]     ...future.result <- base::tryCatch({
[17:38:36.100]         base::withCallingHandlers({
[17:38:36.100]             ...future.value <- base::withVisible(base::local({
[17:38:36.100]                 ...future.makeSendCondition <- base::local({
[17:38:36.100]                   sendCondition <- NULL
[17:38:36.100]                   function(frame = 1L) {
[17:38:36.100]                     if (is.function(sendCondition)) 
[17:38:36.100]                       return(sendCondition)
[17:38:36.100]                     ns <- getNamespace("parallel")
[17:38:36.100]                     if (exists("sendData", mode = "function", 
[17:38:36.100]                       envir = ns)) {
[17:38:36.100]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:36.100]                         envir = ns)
[17:38:36.100]                       envir <- sys.frame(frame)
[17:38:36.100]                       master <- NULL
[17:38:36.100]                       while (!identical(envir, .GlobalEnv) && 
[17:38:36.100]                         !identical(envir, emptyenv())) {
[17:38:36.100]                         if (exists("master", mode = "list", envir = envir, 
[17:38:36.100]                           inherits = FALSE)) {
[17:38:36.100]                           master <- get("master", mode = "list", 
[17:38:36.100]                             envir = envir, inherits = FALSE)
[17:38:36.100]                           if (inherits(master, c("SOCKnode", 
[17:38:36.100]                             "SOCK0node"))) {
[17:38:36.100]                             sendCondition <<- function(cond) {
[17:38:36.100]                               data <- list(type = "VALUE", value = cond, 
[17:38:36.100]                                 success = TRUE)
[17:38:36.100]                               parallel_sendData(master, data)
[17:38:36.100]                             }
[17:38:36.100]                             return(sendCondition)
[17:38:36.100]                           }
[17:38:36.100]                         }
[17:38:36.100]                         frame <- frame + 1L
[17:38:36.100]                         envir <- sys.frame(frame)
[17:38:36.100]                       }
[17:38:36.100]                     }
[17:38:36.100]                     sendCondition <<- function(cond) NULL
[17:38:36.100]                   }
[17:38:36.100]                 })
[17:38:36.100]                 withCallingHandlers({
[17:38:36.100]                   {
[17:38:36.100]                     do.call(function(...) {
[17:38:36.100]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:36.100]                       if (!identical(...future.globals.maxSize.org, 
[17:38:36.100]                         ...future.globals.maxSize)) {
[17:38:36.100]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:36.100]                         on.exit(options(oopts), add = TRUE)
[17:38:36.100]                       }
[17:38:36.100]                       {
[17:38:36.100]                         lapply(seq_along(...future.elements_ii), 
[17:38:36.100]                           FUN = function(jj) {
[17:38:36.100]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:36.100]                             ...future.FUN(...future.X_jj, ...)
[17:38:36.100]                           })
[17:38:36.100]                       }
[17:38:36.100]                     }, args = future.call.arguments)
[17:38:36.100]                   }
[17:38:36.100]                 }, immediateCondition = function(cond) {
[17:38:36.100]                   sendCondition <- ...future.makeSendCondition()
[17:38:36.100]                   sendCondition(cond)
[17:38:36.100]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:36.100]                   {
[17:38:36.100]                     inherits <- base::inherits
[17:38:36.100]                     invokeRestart <- base::invokeRestart
[17:38:36.100]                     is.null <- base::is.null
[17:38:36.100]                     muffled <- FALSE
[17:38:36.100]                     if (inherits(cond, "message")) {
[17:38:36.100]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:36.100]                       if (muffled) 
[17:38:36.100]                         invokeRestart("muffleMessage")
[17:38:36.100]                     }
[17:38:36.100]                     else if (inherits(cond, "warning")) {
[17:38:36.100]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:36.100]                       if (muffled) 
[17:38:36.100]                         invokeRestart("muffleWarning")
[17:38:36.100]                     }
[17:38:36.100]                     else if (inherits(cond, "condition")) {
[17:38:36.100]                       if (!is.null(pattern)) {
[17:38:36.100]                         computeRestarts <- base::computeRestarts
[17:38:36.100]                         grepl <- base::grepl
[17:38:36.100]                         restarts <- computeRestarts(cond)
[17:38:36.100]                         for (restart in restarts) {
[17:38:36.100]                           name <- restart$name
[17:38:36.100]                           if (is.null(name)) 
[17:38:36.100]                             next
[17:38:36.100]                           if (!grepl(pattern, name)) 
[17:38:36.100]                             next
[17:38:36.100]                           invokeRestart(restart)
[17:38:36.100]                           muffled <- TRUE
[17:38:36.100]                           break
[17:38:36.100]                         }
[17:38:36.100]                       }
[17:38:36.100]                     }
[17:38:36.100]                     invisible(muffled)
[17:38:36.100]                   }
[17:38:36.100]                   muffleCondition(cond)
[17:38:36.100]                 })
[17:38:36.100]             }))
[17:38:36.100]             future::FutureResult(value = ...future.value$value, 
[17:38:36.100]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:36.100]                   ...future.rng), globalenv = if (FALSE) 
[17:38:36.100]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:36.100]                     ...future.globalenv.names))
[17:38:36.100]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:36.100]         }, condition = base::local({
[17:38:36.100]             c <- base::c
[17:38:36.100]             inherits <- base::inherits
[17:38:36.100]             invokeRestart <- base::invokeRestart
[17:38:36.100]             length <- base::length
[17:38:36.100]             list <- base::list
[17:38:36.100]             seq.int <- base::seq.int
[17:38:36.100]             signalCondition <- base::signalCondition
[17:38:36.100]             sys.calls <- base::sys.calls
[17:38:36.100]             `[[` <- base::`[[`
[17:38:36.100]             `+` <- base::`+`
[17:38:36.100]             `<<-` <- base::`<<-`
[17:38:36.100]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:36.100]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:36.100]                   3L)]
[17:38:36.100]             }
[17:38:36.100]             function(cond) {
[17:38:36.100]                 is_error <- inherits(cond, "error")
[17:38:36.100]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:36.100]                   NULL)
[17:38:36.100]                 if (is_error) {
[17:38:36.100]                   sessionInformation <- function() {
[17:38:36.100]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:36.100]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:36.100]                       search = base::search(), system = base::Sys.info())
[17:38:36.100]                   }
[17:38:36.100]                   ...future.conditions[[length(...future.conditions) + 
[17:38:36.100]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:36.100]                     cond$call), session = sessionInformation(), 
[17:38:36.100]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:36.100]                   signalCondition(cond)
[17:38:36.100]                 }
[17:38:36.100]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:36.100]                 "immediateCondition"))) {
[17:38:36.100]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:36.100]                   ...future.conditions[[length(...future.conditions) + 
[17:38:36.100]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:36.100]                   if (TRUE && !signal) {
[17:38:36.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:36.100]                     {
[17:38:36.100]                       inherits <- base::inherits
[17:38:36.100]                       invokeRestart <- base::invokeRestart
[17:38:36.100]                       is.null <- base::is.null
[17:38:36.100]                       muffled <- FALSE
[17:38:36.100]                       if (inherits(cond, "message")) {
[17:38:36.100]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:36.100]                         if (muffled) 
[17:38:36.100]                           invokeRestart("muffleMessage")
[17:38:36.100]                       }
[17:38:36.100]                       else if (inherits(cond, "warning")) {
[17:38:36.100]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:36.100]                         if (muffled) 
[17:38:36.100]                           invokeRestart("muffleWarning")
[17:38:36.100]                       }
[17:38:36.100]                       else if (inherits(cond, "condition")) {
[17:38:36.100]                         if (!is.null(pattern)) {
[17:38:36.100]                           computeRestarts <- base::computeRestarts
[17:38:36.100]                           grepl <- base::grepl
[17:38:36.100]                           restarts <- computeRestarts(cond)
[17:38:36.100]                           for (restart in restarts) {
[17:38:36.100]                             name <- restart$name
[17:38:36.100]                             if (is.null(name)) 
[17:38:36.100]                               next
[17:38:36.100]                             if (!grepl(pattern, name)) 
[17:38:36.100]                               next
[17:38:36.100]                             invokeRestart(restart)
[17:38:36.100]                             muffled <- TRUE
[17:38:36.100]                             break
[17:38:36.100]                           }
[17:38:36.100]                         }
[17:38:36.100]                       }
[17:38:36.100]                       invisible(muffled)
[17:38:36.100]                     }
[17:38:36.100]                     muffleCondition(cond, pattern = "^muffle")
[17:38:36.100]                   }
[17:38:36.100]                 }
[17:38:36.100]                 else {
[17:38:36.100]                   if (TRUE) {
[17:38:36.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:36.100]                     {
[17:38:36.100]                       inherits <- base::inherits
[17:38:36.100]                       invokeRestart <- base::invokeRestart
[17:38:36.100]                       is.null <- base::is.null
[17:38:36.100]                       muffled <- FALSE
[17:38:36.100]                       if (inherits(cond, "message")) {
[17:38:36.100]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:36.100]                         if (muffled) 
[17:38:36.100]                           invokeRestart("muffleMessage")
[17:38:36.100]                       }
[17:38:36.100]                       else if (inherits(cond, "warning")) {
[17:38:36.100]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:36.100]                         if (muffled) 
[17:38:36.100]                           invokeRestart("muffleWarning")
[17:38:36.100]                       }
[17:38:36.100]                       else if (inherits(cond, "condition")) {
[17:38:36.100]                         if (!is.null(pattern)) {
[17:38:36.100]                           computeRestarts <- base::computeRestarts
[17:38:36.100]                           grepl <- base::grepl
[17:38:36.100]                           restarts <- computeRestarts(cond)
[17:38:36.100]                           for (restart in restarts) {
[17:38:36.100]                             name <- restart$name
[17:38:36.100]                             if (is.null(name)) 
[17:38:36.100]                               next
[17:38:36.100]                             if (!grepl(pattern, name)) 
[17:38:36.100]                               next
[17:38:36.100]                             invokeRestart(restart)
[17:38:36.100]                             muffled <- TRUE
[17:38:36.100]                             break
[17:38:36.100]                           }
[17:38:36.100]                         }
[17:38:36.100]                       }
[17:38:36.100]                       invisible(muffled)
[17:38:36.100]                     }
[17:38:36.100]                     muffleCondition(cond, pattern = "^muffle")
[17:38:36.100]                   }
[17:38:36.100]                 }
[17:38:36.100]             }
[17:38:36.100]         }))
[17:38:36.100]     }, error = function(ex) {
[17:38:36.100]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:36.100]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:36.100]                 ...future.rng), started = ...future.startTime, 
[17:38:36.100]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:36.100]             version = "1.8"), class = "FutureResult")
[17:38:36.100]     }, finally = {
[17:38:36.100]         if (!identical(...future.workdir, getwd())) 
[17:38:36.100]             setwd(...future.workdir)
[17:38:36.100]         {
[17:38:36.100]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:36.100]                 ...future.oldOptions$nwarnings <- NULL
[17:38:36.100]             }
[17:38:36.100]             base::options(...future.oldOptions)
[17:38:36.100]             if (.Platform$OS.type == "windows") {
[17:38:36.100]                 old_names <- names(...future.oldEnvVars)
[17:38:36.100]                 envs <- base::Sys.getenv()
[17:38:36.100]                 names <- names(envs)
[17:38:36.100]                 common <- intersect(names, old_names)
[17:38:36.100]                 added <- setdiff(names, old_names)
[17:38:36.100]                 removed <- setdiff(old_names, names)
[17:38:36.100]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:36.100]                   envs[common]]
[17:38:36.100]                 NAMES <- toupper(changed)
[17:38:36.100]                 args <- list()
[17:38:36.100]                 for (kk in seq_along(NAMES)) {
[17:38:36.100]                   name <- changed[[kk]]
[17:38:36.100]                   NAME <- NAMES[[kk]]
[17:38:36.100]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:36.100]                     next
[17:38:36.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:36.100]                 }
[17:38:36.100]                 NAMES <- toupper(added)
[17:38:36.100]                 for (kk in seq_along(NAMES)) {
[17:38:36.100]                   name <- added[[kk]]
[17:38:36.100]                   NAME <- NAMES[[kk]]
[17:38:36.100]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:36.100]                     next
[17:38:36.100]                   args[[name]] <- ""
[17:38:36.100]                 }
[17:38:36.100]                 NAMES <- toupper(removed)
[17:38:36.100]                 for (kk in seq_along(NAMES)) {
[17:38:36.100]                   name <- removed[[kk]]
[17:38:36.100]                   NAME <- NAMES[[kk]]
[17:38:36.100]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:36.100]                     next
[17:38:36.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:36.100]                 }
[17:38:36.100]                 if (length(args) > 0) 
[17:38:36.100]                   base::do.call(base::Sys.setenv, args = args)
[17:38:36.100]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:36.100]             }
[17:38:36.100]             else {
[17:38:36.100]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:36.100]             }
[17:38:36.100]             {
[17:38:36.100]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:36.100]                   0L) {
[17:38:36.100]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:36.100]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:36.100]                   base::options(opts)
[17:38:36.100]                 }
[17:38:36.100]                 {
[17:38:36.100]                   {
[17:38:36.100]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:36.100]                     NULL
[17:38:36.100]                   }
[17:38:36.100]                   options(future.plan = NULL)
[17:38:36.100]                   if (is.na(NA_character_)) 
[17:38:36.100]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:36.100]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:36.100]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:36.100]                     .init = FALSE)
[17:38:36.100]                 }
[17:38:36.100]             }
[17:38:36.100]         }
[17:38:36.100]     })
[17:38:36.100]     if (FALSE) {
[17:38:36.100]         base::sink(type = "output", split = FALSE)
[17:38:36.100]         if (NA) {
[17:38:36.100]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:36.100]         }
[17:38:36.100]         else {
[17:38:36.100]             ...future.result["stdout"] <- base::list(NULL)
[17:38:36.100]         }
[17:38:36.100]         base::close(...future.stdout)
[17:38:36.100]         ...future.stdout <- NULL
[17:38:36.100]     }
[17:38:36.100]     ...future.result$conditions <- ...future.conditions
[17:38:36.100]     ...future.result$finished <- base::Sys.time()
[17:38:36.100]     ...future.result
[17:38:36.100] }
[17:38:36.103] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[17:38:36.103] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[17:38:36.104] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[17:38:36.104] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:38:36.108] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:38:36.108] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:38:36.108] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:38:36.108] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:38:36.109] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:38:36.109] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:38:36.109] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:38:36.109] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[17:38:36.110] MultisessionFuture started
[17:38:36.110] - Launch lazy future ... done
[17:38:36.110] run() for ‘MultisessionFuture’ ... done
[17:38:36.110] Created future:
[17:38:36.111] MultisessionFuture:
[17:38:36.111] Label: ‘future_lapply-2’
[17:38:36.111] Expression:
[17:38:36.111] {
[17:38:36.111]     do.call(function(...) {
[17:38:36.111]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:36.111]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:36.111]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:36.111]             on.exit(options(oopts), add = TRUE)
[17:38:36.111]         }
[17:38:36.111]         {
[17:38:36.111]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:36.111]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:36.111]                 ...future.FUN(...future.X_jj, ...)
[17:38:36.111]             })
[17:38:36.111]         }
[17:38:36.111]     }, args = future.call.arguments)
[17:38:36.111] }
[17:38:36.111] Lazy evaluation: FALSE
[17:38:36.111] Asynchronous evaluation: TRUE
[17:38:36.111] Local evaluation: TRUE
[17:38:36.111] Environment: R_GlobalEnv
[17:38:36.111] Capture standard output: NA
[17:38:36.111] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:36.111] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:36.111] Packages: <none>
[17:38:36.111] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:36.111] Resolved: FALSE
[17:38:36.111] Value: <not collected>
[17:38:36.111] Conditions captured: <none>
[17:38:36.111] Early signaling: FALSE
[17:38:36.111] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:36.111] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:36.122] Chunk #2 of 2 ... DONE
[17:38:36.122] Launching 2 futures (chunks) ... DONE
[17:38:36.122] Resolving 2 futures (chunks) ...
[17:38:36.122] resolve() on list ...
[17:38:36.123]  recursive: 0
[17:38:36.123]  length: 2
[17:38:36.123] 
[17:38:36.165] receiveMessageFromWorker() for ClusterFuture ...
[17:38:36.165] - Validating connection of MultisessionFuture
[17:38:36.165] - received message: FutureResult
[17:38:36.165] - Received FutureResult
[17:38:36.165] - Erased future from FutureRegistry
[17:38:36.166] result() for ClusterFuture ...
[17:38:36.166] - result already collected: FutureResult
[17:38:36.166] result() for ClusterFuture ... done
[17:38:36.166] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:36.166] Future #2
[17:38:36.166] result() for ClusterFuture ...
[17:38:36.166] - result already collected: FutureResult
[17:38:36.166] result() for ClusterFuture ... done
[17:38:36.166] result() for ClusterFuture ...
[17:38:36.166] - result already collected: FutureResult
[17:38:36.166] result() for ClusterFuture ... done
[17:38:36.166] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:38:36.167] - nx: 2
[17:38:36.167] - relay: TRUE
[17:38:36.167] - stdout: TRUE
[17:38:36.167] - signal: TRUE
[17:38:36.167] - resignal: FALSE
[17:38:36.167] - force: TRUE
[17:38:36.167] - relayed: [n=2] FALSE, FALSE
[17:38:36.167] - queued futures: [n=2] FALSE, FALSE
[17:38:36.167]  - until=1
[17:38:36.167]  - relaying element #1
[17:38:36.167] - relayed: [n=2] FALSE, FALSE
[17:38:36.167] - queued futures: [n=2] FALSE, TRUE
[17:38:36.168] signalConditionsASAP(NULL, pos=2) ... done
[17:38:36.168]  length: 1 (resolved future 2)
[17:38:36.612] receiveMessageFromWorker() for ClusterFuture ...
[17:38:36.612] - Validating connection of MultisessionFuture
[17:38:36.613] - received message: FutureResult
[17:38:36.613] - Received FutureResult
[17:38:36.613] - Erased future from FutureRegistry
[17:38:36.613] result() for ClusterFuture ...
[17:38:36.613] - result already collected: FutureResult
[17:38:36.613] result() for ClusterFuture ... done
[17:38:36.613] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:36.613] Future #1
[17:38:36.613] result() for ClusterFuture ...
[17:38:36.613] - result already collected: FutureResult
[17:38:36.614] result() for ClusterFuture ... done
[17:38:36.614] result() for ClusterFuture ...
[17:38:36.614] - result already collected: FutureResult
[17:38:36.614] result() for ClusterFuture ... done
[17:38:36.614] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:38:36.614] - nx: 2
[17:38:36.614] - relay: TRUE
[17:38:36.614] - stdout: TRUE
[17:38:36.614] - signal: TRUE
[17:38:36.614] - resignal: FALSE
[17:38:36.614] - force: TRUE
[17:38:36.614] - relayed: [n=2] FALSE, FALSE
[17:38:36.615] - queued futures: [n=2] FALSE, TRUE
[17:38:36.615]  - until=1
[17:38:36.615]  - relaying element #1
[17:38:36.615] result() for ClusterFuture ...
[17:38:36.615] - result already collected: FutureResult
[17:38:36.615] result() for ClusterFuture ... done
[17:38:36.615] result() for ClusterFuture ...
[17:38:36.615] - result already collected: FutureResult
[17:38:36.615] result() for ClusterFuture ... done
[17:38:36.615] result() for ClusterFuture ...
[17:38:36.615] - result already collected: FutureResult
[17:38:36.616] result() for ClusterFuture ... done
[17:38:36.616] result() for ClusterFuture ...
[17:38:36.616] - result already collected: FutureResult
[17:38:36.616] result() for ClusterFuture ... done
[17:38:36.616] - relayed: [n=2] TRUE, FALSE
[17:38:36.616] - queued futures: [n=2] TRUE, TRUE
[17:38:36.616] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:38:36.616]  length: 0 (resolved future 1)
[17:38:36.616] Relaying remaining futures
[17:38:36.616] signalConditionsASAP(NULL, pos=0) ...
[17:38:36.616] - nx: 2
[17:38:36.617] - relay: TRUE
[17:38:36.617] - stdout: TRUE
[17:38:36.617] - signal: TRUE
[17:38:36.617] - resignal: FALSE
[17:38:36.617] - force: TRUE
[17:38:36.617] - relayed: [n=2] TRUE, FALSE
[17:38:36.617] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:36.617]  - relaying element #2
[17:38:36.617] result() for ClusterFuture ...
[17:38:36.617] - result already collected: FutureResult
[17:38:36.617] result() for ClusterFuture ... done
[17:38:36.618] result() for ClusterFuture ...
[17:38:36.618] - result already collected: FutureResult
[17:38:36.618] result() for ClusterFuture ... done
[17:38:36.618] result() for ClusterFuture ...
[17:38:36.618] - result already collected: FutureResult
[17:38:36.618] result() for ClusterFuture ... done
[17:38:36.618] result() for ClusterFuture ...
[17:38:36.618] - result already collected: FutureResult
[17:38:36.618] result() for ClusterFuture ... done
[17:38:36.618] - relayed: [n=2] TRUE, TRUE
[17:38:36.618] - queued futures: [n=2] TRUE, TRUE
[17:38:36.618] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:38:36.619] resolve() on list ... DONE
[17:38:36.619] result() for ClusterFuture ...
[17:38:36.619] - result already collected: FutureResult
[17:38:36.619] result() for ClusterFuture ... done
[17:38:36.619] result() for ClusterFuture ...
[17:38:36.619] - result already collected: FutureResult
[17:38:36.619] result() for ClusterFuture ... done
[17:38:36.619] result() for ClusterFuture ...
[17:38:36.619] - result already collected: FutureResult
[17:38:36.619] result() for ClusterFuture ... done
[17:38:36.619] result() for ClusterFuture ...
[17:38:36.620] - result already collected: FutureResult
[17:38:36.620] result() for ClusterFuture ... done
[17:38:36.620]  - Number of value chunks collected: 2
[17:38:36.620] Resolving 2 futures (chunks) ... DONE
[17:38:36.620] Reducing values from 2 chunks ...
[17:38:36.620]  - Number of values collected after concatenation: 2
[17:38:36.620]  - Number of values expected: 2
[17:38:36.620] Reducing values from 2 chunks ... DONE
[17:38:36.620] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[17:38:36.621] future_mapply() ...
[17:38:36.624] Number of chunks: 2
[17:38:36.624] getGlobalsAndPackagesXApply() ...
[17:38:36.625]  - future.globals: TRUE
[17:38:36.625] getGlobalsAndPackages() ...
[17:38:36.625] Searching for globals...
[17:38:36.626] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:38:36.626] Searching for globals ... DONE
[17:38:36.626] Resolving globals: FALSE
[17:38:36.627] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:38:36.627] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:38:36.627] - globals: [1] ‘FUN’
[17:38:36.627] 
[17:38:36.628] getGlobalsAndPackages() ... DONE
[17:38:36.628]  - globals found/used: [n=1] ‘FUN’
[17:38:36.628]  - needed namespaces: [n=0] 
[17:38:36.628] Finding globals ... DONE
[17:38:36.628] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:38:36.628] List of 2
[17:38:36.628]  $ ...future.FUN:function (x, y)  
[17:38:36.628]  $ MoreArgs     : NULL
[17:38:36.628]  - attr(*, "where")=List of 2
[17:38:36.628]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:36.628]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:38:36.628]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:36.628]  - attr(*, "resolved")= logi FALSE
[17:38:36.628]  - attr(*, "total_size")= num NA
[17:38:36.631] Packages to be attached in all futures: [n=0] 
[17:38:36.631] getGlobalsAndPackagesXApply() ... DONE
[17:38:36.631] Number of futures (= number of chunks): 2
[17:38:36.631] Launching 2 futures (chunks) ...
[17:38:36.631] Chunk #1 of 2 ...
[17:38:36.631]  - Finding globals in '...' for chunk #1 ...
[17:38:36.631] getGlobalsAndPackages() ...
[17:38:36.631] Searching for globals...
[17:38:36.632] 
[17:38:36.632] Searching for globals ... DONE
[17:38:36.632] - globals: [0] <none>
[17:38:36.632] getGlobalsAndPackages() ... DONE
[17:38:36.632]    + additional globals found: [n=0] 
[17:38:36.632]    + additional namespaces needed: [n=0] 
[17:38:36.632]  - Finding globals in '...' for chunk #1 ... DONE
[17:38:36.632]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:36.632]  - seeds: <none>
[17:38:36.633]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:36.633] getGlobalsAndPackages() ...
[17:38:36.633] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:36.633] Resolving globals: FALSE
[17:38:36.633] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:38:36.634] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:38:36.636] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:36.636] 
[17:38:36.636] getGlobalsAndPackages() ... DONE
[17:38:36.636] run() for ‘Future’ ...
[17:38:36.636] - state: ‘created’
[17:38:36.636] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:36.650] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:36.650] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:36.650]   - Field: ‘node’
[17:38:36.650]   - Field: ‘label’
[17:38:36.651]   - Field: ‘local’
[17:38:36.651]   - Field: ‘owner’
[17:38:36.651]   - Field: ‘envir’
[17:38:36.651]   - Field: ‘workers’
[17:38:36.651]   - Field: ‘packages’
[17:38:36.651]   - Field: ‘gc’
[17:38:36.651]   - Field: ‘conditions’
[17:38:36.651]   - Field: ‘persistent’
[17:38:36.651]   - Field: ‘expr’
[17:38:36.651]   - Field: ‘uuid’
[17:38:36.651]   - Field: ‘seed’
[17:38:36.651]   - Field: ‘version’
[17:38:36.652]   - Field: ‘result’
[17:38:36.652]   - Field: ‘asynchronous’
[17:38:36.652]   - Field: ‘calls’
[17:38:36.652]   - Field: ‘globals’
[17:38:36.652]   - Field: ‘stdout’
[17:38:36.652]   - Field: ‘earlySignal’
[17:38:36.652]   - Field: ‘lazy’
[17:38:36.652]   - Field: ‘state’
[17:38:36.652] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:36.652] - Launch lazy future ...
[17:38:36.653] Packages needed by the future expression (n = 0): <none>
[17:38:36.653] Packages needed by future strategies (n = 0): <none>
[17:38:36.653] {
[17:38:36.653]     {
[17:38:36.653]         {
[17:38:36.653]             ...future.startTime <- base::Sys.time()
[17:38:36.653]             {
[17:38:36.653]                 {
[17:38:36.653]                   {
[17:38:36.653]                     {
[17:38:36.653]                       base::local({
[17:38:36.653]                         has_future <- base::requireNamespace("future", 
[17:38:36.653]                           quietly = TRUE)
[17:38:36.653]                         if (has_future) {
[17:38:36.653]                           ns <- base::getNamespace("future")
[17:38:36.653]                           version <- ns[[".package"]][["version"]]
[17:38:36.653]                           if (is.null(version)) 
[17:38:36.653]                             version <- utils::packageVersion("future")
[17:38:36.653]                         }
[17:38:36.653]                         else {
[17:38:36.653]                           version <- NULL
[17:38:36.653]                         }
[17:38:36.653]                         if (!has_future || version < "1.8.0") {
[17:38:36.653]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:36.653]                             "", base::R.version$version.string), 
[17:38:36.653]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:36.653]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:36.653]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:36.653]                               "release", "version")], collapse = " "), 
[17:38:36.653]                             hostname = base::Sys.info()[["nodename"]])
[17:38:36.653]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:36.653]                             info)
[17:38:36.653]                           info <- base::paste(info, collapse = "; ")
[17:38:36.653]                           if (!has_future) {
[17:38:36.653]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:36.653]                               info)
[17:38:36.653]                           }
[17:38:36.653]                           else {
[17:38:36.653]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:36.653]                               info, version)
[17:38:36.653]                           }
[17:38:36.653]                           base::stop(msg)
[17:38:36.653]                         }
[17:38:36.653]                       })
[17:38:36.653]                     }
[17:38:36.653]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:36.653]                     base::options(mc.cores = 1L)
[17:38:36.653]                   }
[17:38:36.653]                   ...future.strategy.old <- future::plan("list")
[17:38:36.653]                   options(future.plan = NULL)
[17:38:36.653]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:36.653]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:36.653]                 }
[17:38:36.653]                 ...future.workdir <- getwd()
[17:38:36.653]             }
[17:38:36.653]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:36.653]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:36.653]         }
[17:38:36.653]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:36.653]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:36.653]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:36.653]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:36.653]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:36.653]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:36.653]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:36.653]             base::names(...future.oldOptions))
[17:38:36.653]     }
[17:38:36.653]     if (FALSE) {
[17:38:36.653]     }
[17:38:36.653]     else {
[17:38:36.653]         if (FALSE) {
[17:38:36.653]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:36.653]                 open = "w")
[17:38:36.653]         }
[17:38:36.653]         else {
[17:38:36.653]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:36.653]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:36.653]         }
[17:38:36.653]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:36.653]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:36.653]             base::sink(type = "output", split = FALSE)
[17:38:36.653]             base::close(...future.stdout)
[17:38:36.653]         }, add = TRUE)
[17:38:36.653]     }
[17:38:36.653]     ...future.frame <- base::sys.nframe()
[17:38:36.653]     ...future.conditions <- base::list()
[17:38:36.653]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:36.653]     if (FALSE) {
[17:38:36.653]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:36.653]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:36.653]     }
[17:38:36.653]     ...future.result <- base::tryCatch({
[17:38:36.653]         base::withCallingHandlers({
[17:38:36.653]             ...future.value <- base::withVisible(base::local({
[17:38:36.653]                 ...future.makeSendCondition <- base::local({
[17:38:36.653]                   sendCondition <- NULL
[17:38:36.653]                   function(frame = 1L) {
[17:38:36.653]                     if (is.function(sendCondition)) 
[17:38:36.653]                       return(sendCondition)
[17:38:36.653]                     ns <- getNamespace("parallel")
[17:38:36.653]                     if (exists("sendData", mode = "function", 
[17:38:36.653]                       envir = ns)) {
[17:38:36.653]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:36.653]                         envir = ns)
[17:38:36.653]                       envir <- sys.frame(frame)
[17:38:36.653]                       master <- NULL
[17:38:36.653]                       while (!identical(envir, .GlobalEnv) && 
[17:38:36.653]                         !identical(envir, emptyenv())) {
[17:38:36.653]                         if (exists("master", mode = "list", envir = envir, 
[17:38:36.653]                           inherits = FALSE)) {
[17:38:36.653]                           master <- get("master", mode = "list", 
[17:38:36.653]                             envir = envir, inherits = FALSE)
[17:38:36.653]                           if (inherits(master, c("SOCKnode", 
[17:38:36.653]                             "SOCK0node"))) {
[17:38:36.653]                             sendCondition <<- function(cond) {
[17:38:36.653]                               data <- list(type = "VALUE", value = cond, 
[17:38:36.653]                                 success = TRUE)
[17:38:36.653]                               parallel_sendData(master, data)
[17:38:36.653]                             }
[17:38:36.653]                             return(sendCondition)
[17:38:36.653]                           }
[17:38:36.653]                         }
[17:38:36.653]                         frame <- frame + 1L
[17:38:36.653]                         envir <- sys.frame(frame)
[17:38:36.653]                       }
[17:38:36.653]                     }
[17:38:36.653]                     sendCondition <<- function(cond) NULL
[17:38:36.653]                   }
[17:38:36.653]                 })
[17:38:36.653]                 withCallingHandlers({
[17:38:36.653]                   {
[17:38:36.653]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:36.653]                     if (!identical(...future.globals.maxSize.org, 
[17:38:36.653]                       ...future.globals.maxSize)) {
[17:38:36.653]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:36.653]                       on.exit(options(oopts), add = TRUE)
[17:38:36.653]                     }
[17:38:36.653]                     {
[17:38:36.653]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:36.653]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:38:36.653]                         USE.NAMES = FALSE)
[17:38:36.653]                       do.call(mapply, args = args)
[17:38:36.653]                     }
[17:38:36.653]                   }
[17:38:36.653]                 }, immediateCondition = function(cond) {
[17:38:36.653]                   sendCondition <- ...future.makeSendCondition()
[17:38:36.653]                   sendCondition(cond)
[17:38:36.653]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:36.653]                   {
[17:38:36.653]                     inherits <- base::inherits
[17:38:36.653]                     invokeRestart <- base::invokeRestart
[17:38:36.653]                     is.null <- base::is.null
[17:38:36.653]                     muffled <- FALSE
[17:38:36.653]                     if (inherits(cond, "message")) {
[17:38:36.653]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:36.653]                       if (muffled) 
[17:38:36.653]                         invokeRestart("muffleMessage")
[17:38:36.653]                     }
[17:38:36.653]                     else if (inherits(cond, "warning")) {
[17:38:36.653]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:36.653]                       if (muffled) 
[17:38:36.653]                         invokeRestart("muffleWarning")
[17:38:36.653]                     }
[17:38:36.653]                     else if (inherits(cond, "condition")) {
[17:38:36.653]                       if (!is.null(pattern)) {
[17:38:36.653]                         computeRestarts <- base::computeRestarts
[17:38:36.653]                         grepl <- base::grepl
[17:38:36.653]                         restarts <- computeRestarts(cond)
[17:38:36.653]                         for (restart in restarts) {
[17:38:36.653]                           name <- restart$name
[17:38:36.653]                           if (is.null(name)) 
[17:38:36.653]                             next
[17:38:36.653]                           if (!grepl(pattern, name)) 
[17:38:36.653]                             next
[17:38:36.653]                           invokeRestart(restart)
[17:38:36.653]                           muffled <- TRUE
[17:38:36.653]                           break
[17:38:36.653]                         }
[17:38:36.653]                       }
[17:38:36.653]                     }
[17:38:36.653]                     invisible(muffled)
[17:38:36.653]                   }
[17:38:36.653]                   muffleCondition(cond)
[17:38:36.653]                 })
[17:38:36.653]             }))
[17:38:36.653]             future::FutureResult(value = ...future.value$value, 
[17:38:36.653]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:36.653]                   ...future.rng), globalenv = if (FALSE) 
[17:38:36.653]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:36.653]                     ...future.globalenv.names))
[17:38:36.653]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:36.653]         }, condition = base::local({
[17:38:36.653]             c <- base::c
[17:38:36.653]             inherits <- base::inherits
[17:38:36.653]             invokeRestart <- base::invokeRestart
[17:38:36.653]             length <- base::length
[17:38:36.653]             list <- base::list
[17:38:36.653]             seq.int <- base::seq.int
[17:38:36.653]             signalCondition <- base::signalCondition
[17:38:36.653]             sys.calls <- base::sys.calls
[17:38:36.653]             `[[` <- base::`[[`
[17:38:36.653]             `+` <- base::`+`
[17:38:36.653]             `<<-` <- base::`<<-`
[17:38:36.653]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:36.653]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:36.653]                   3L)]
[17:38:36.653]             }
[17:38:36.653]             function(cond) {
[17:38:36.653]                 is_error <- inherits(cond, "error")
[17:38:36.653]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:36.653]                   NULL)
[17:38:36.653]                 if (is_error) {
[17:38:36.653]                   sessionInformation <- function() {
[17:38:36.653]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:36.653]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:36.653]                       search = base::search(), system = base::Sys.info())
[17:38:36.653]                   }
[17:38:36.653]                   ...future.conditions[[length(...future.conditions) + 
[17:38:36.653]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:36.653]                     cond$call), session = sessionInformation(), 
[17:38:36.653]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:36.653]                   signalCondition(cond)
[17:38:36.653]                 }
[17:38:36.653]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:36.653]                 "immediateCondition"))) {
[17:38:36.653]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:36.653]                   ...future.conditions[[length(...future.conditions) + 
[17:38:36.653]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:36.653]                   if (TRUE && !signal) {
[17:38:36.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:36.653]                     {
[17:38:36.653]                       inherits <- base::inherits
[17:38:36.653]                       invokeRestart <- base::invokeRestart
[17:38:36.653]                       is.null <- base::is.null
[17:38:36.653]                       muffled <- FALSE
[17:38:36.653]                       if (inherits(cond, "message")) {
[17:38:36.653]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:36.653]                         if (muffled) 
[17:38:36.653]                           invokeRestart("muffleMessage")
[17:38:36.653]                       }
[17:38:36.653]                       else if (inherits(cond, "warning")) {
[17:38:36.653]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:36.653]                         if (muffled) 
[17:38:36.653]                           invokeRestart("muffleWarning")
[17:38:36.653]                       }
[17:38:36.653]                       else if (inherits(cond, "condition")) {
[17:38:36.653]                         if (!is.null(pattern)) {
[17:38:36.653]                           computeRestarts <- base::computeRestarts
[17:38:36.653]                           grepl <- base::grepl
[17:38:36.653]                           restarts <- computeRestarts(cond)
[17:38:36.653]                           for (restart in restarts) {
[17:38:36.653]                             name <- restart$name
[17:38:36.653]                             if (is.null(name)) 
[17:38:36.653]                               next
[17:38:36.653]                             if (!grepl(pattern, name)) 
[17:38:36.653]                               next
[17:38:36.653]                             invokeRestart(restart)
[17:38:36.653]                             muffled <- TRUE
[17:38:36.653]                             break
[17:38:36.653]                           }
[17:38:36.653]                         }
[17:38:36.653]                       }
[17:38:36.653]                       invisible(muffled)
[17:38:36.653]                     }
[17:38:36.653]                     muffleCondition(cond, pattern = "^muffle")
[17:38:36.653]                   }
[17:38:36.653]                 }
[17:38:36.653]                 else {
[17:38:36.653]                   if (TRUE) {
[17:38:36.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:36.653]                     {
[17:38:36.653]                       inherits <- base::inherits
[17:38:36.653]                       invokeRestart <- base::invokeRestart
[17:38:36.653]                       is.null <- base::is.null
[17:38:36.653]                       muffled <- FALSE
[17:38:36.653]                       if (inherits(cond, "message")) {
[17:38:36.653]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:36.653]                         if (muffled) 
[17:38:36.653]                           invokeRestart("muffleMessage")
[17:38:36.653]                       }
[17:38:36.653]                       else if (inherits(cond, "warning")) {
[17:38:36.653]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:36.653]                         if (muffled) 
[17:38:36.653]                           invokeRestart("muffleWarning")
[17:38:36.653]                       }
[17:38:36.653]                       else if (inherits(cond, "condition")) {
[17:38:36.653]                         if (!is.null(pattern)) {
[17:38:36.653]                           computeRestarts <- base::computeRestarts
[17:38:36.653]                           grepl <- base::grepl
[17:38:36.653]                           restarts <- computeRestarts(cond)
[17:38:36.653]                           for (restart in restarts) {
[17:38:36.653]                             name <- restart$name
[17:38:36.653]                             if (is.null(name)) 
[17:38:36.653]                               next
[17:38:36.653]                             if (!grepl(pattern, name)) 
[17:38:36.653]                               next
[17:38:36.653]                             invokeRestart(restart)
[17:38:36.653]                             muffled <- TRUE
[17:38:36.653]                             break
[17:38:36.653]                           }
[17:38:36.653]                         }
[17:38:36.653]                       }
[17:38:36.653]                       invisible(muffled)
[17:38:36.653]                     }
[17:38:36.653]                     muffleCondition(cond, pattern = "^muffle")
[17:38:36.653]                   }
[17:38:36.653]                 }
[17:38:36.653]             }
[17:38:36.653]         }))
[17:38:36.653]     }, error = function(ex) {
[17:38:36.653]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:36.653]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:36.653]                 ...future.rng), started = ...future.startTime, 
[17:38:36.653]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:36.653]             version = "1.8"), class = "FutureResult")
[17:38:36.653]     }, finally = {
[17:38:36.653]         if (!identical(...future.workdir, getwd())) 
[17:38:36.653]             setwd(...future.workdir)
[17:38:36.653]         {
[17:38:36.653]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:36.653]                 ...future.oldOptions$nwarnings <- NULL
[17:38:36.653]             }
[17:38:36.653]             base::options(...future.oldOptions)
[17:38:36.653]             if (.Platform$OS.type == "windows") {
[17:38:36.653]                 old_names <- names(...future.oldEnvVars)
[17:38:36.653]                 envs <- base::Sys.getenv()
[17:38:36.653]                 names <- names(envs)
[17:38:36.653]                 common <- intersect(names, old_names)
[17:38:36.653]                 added <- setdiff(names, old_names)
[17:38:36.653]                 removed <- setdiff(old_names, names)
[17:38:36.653]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:36.653]                   envs[common]]
[17:38:36.653]                 NAMES <- toupper(changed)
[17:38:36.653]                 args <- list()
[17:38:36.653]                 for (kk in seq_along(NAMES)) {
[17:38:36.653]                   name <- changed[[kk]]
[17:38:36.653]                   NAME <- NAMES[[kk]]
[17:38:36.653]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:36.653]                     next
[17:38:36.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:36.653]                 }
[17:38:36.653]                 NAMES <- toupper(added)
[17:38:36.653]                 for (kk in seq_along(NAMES)) {
[17:38:36.653]                   name <- added[[kk]]
[17:38:36.653]                   NAME <- NAMES[[kk]]
[17:38:36.653]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:36.653]                     next
[17:38:36.653]                   args[[name]] <- ""
[17:38:36.653]                 }
[17:38:36.653]                 NAMES <- toupper(removed)
[17:38:36.653]                 for (kk in seq_along(NAMES)) {
[17:38:36.653]                   name <- removed[[kk]]
[17:38:36.653]                   NAME <- NAMES[[kk]]
[17:38:36.653]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:36.653]                     next
[17:38:36.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:36.653]                 }
[17:38:36.653]                 if (length(args) > 0) 
[17:38:36.653]                   base::do.call(base::Sys.setenv, args = args)
[17:38:36.653]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:36.653]             }
[17:38:36.653]             else {
[17:38:36.653]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:36.653]             }
[17:38:36.653]             {
[17:38:36.653]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:36.653]                   0L) {
[17:38:36.653]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:36.653]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:36.653]                   base::options(opts)
[17:38:36.653]                 }
[17:38:36.653]                 {
[17:38:36.653]                   {
[17:38:36.653]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:36.653]                     NULL
[17:38:36.653]                   }
[17:38:36.653]                   options(future.plan = NULL)
[17:38:36.653]                   if (is.na(NA_character_)) 
[17:38:36.653]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:36.653]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:36.653]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:36.653]                     .init = FALSE)
[17:38:36.653]                 }
[17:38:36.653]             }
[17:38:36.653]         }
[17:38:36.653]     })
[17:38:36.653]     if (TRUE) {
[17:38:36.653]         base::sink(type = "output", split = FALSE)
[17:38:36.653]         if (FALSE) {
[17:38:36.653]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:36.653]         }
[17:38:36.653]         else {
[17:38:36.653]             ...future.result["stdout"] <- base::list(NULL)
[17:38:36.653]         }
[17:38:36.653]         base::close(...future.stdout)
[17:38:36.653]         ...future.stdout <- NULL
[17:38:36.653]     }
[17:38:36.653]     ...future.result$conditions <- ...future.conditions
[17:38:36.653]     ...future.result$finished <- base::Sys.time()
[17:38:36.653]     ...future.result
[17:38:36.653] }
[17:38:36.656] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[17:38:36.656] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[17:38:36.656] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[17:38:36.657] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:38:36.657] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:38:36.657] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:38:36.658] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:38:36.658] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:38:36.658] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:38:36.658] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:38:36.659] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:38:36.659] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[17:38:36.659] MultisessionFuture started
[17:38:36.659] - Launch lazy future ... done
[17:38:36.659] run() for ‘MultisessionFuture’ ... done
[17:38:36.660] Created future:
[17:38:36.660] MultisessionFuture:
[17:38:36.660] Label: ‘future_mapply-1’
[17:38:36.660] Expression:
[17:38:36.660] {
[17:38:36.660]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:36.660]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:36.660]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:36.660]         on.exit(options(oopts), add = TRUE)
[17:38:36.660]     }
[17:38:36.660]     {
[17:38:36.660]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:36.660]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:38:36.660]         do.call(mapply, args = args)
[17:38:36.660]     }
[17:38:36.660] }
[17:38:36.660] Lazy evaluation: FALSE
[17:38:36.660] Asynchronous evaluation: TRUE
[17:38:36.660] Local evaluation: TRUE
[17:38:36.660] Environment: R_GlobalEnv
[17:38:36.660] Capture standard output: FALSE
[17:38:36.660] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:36.660] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:36.660] Packages: <none>
[17:38:36.660] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:36.660] Resolved: FALSE
[17:38:36.660] Value: <not collected>
[17:38:36.660] Conditions captured: <none>
[17:38:36.660] Early signaling: FALSE
[17:38:36.660] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:36.660] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:36.671] Chunk #1 of 2 ... DONE
[17:38:36.671] Chunk #2 of 2 ...
[17:38:36.671]  - Finding globals in '...' for chunk #2 ...
[17:38:36.672] getGlobalsAndPackages() ...
[17:38:36.672] Searching for globals...
[17:38:36.672] 
[17:38:36.672] Searching for globals ... DONE
[17:38:36.672] - globals: [0] <none>
[17:38:36.672] getGlobalsAndPackages() ... DONE
[17:38:36.672]    + additional globals found: [n=0] 
[17:38:36.673]    + additional namespaces needed: [n=0] 
[17:38:36.673]  - Finding globals in '...' for chunk #2 ... DONE
[17:38:36.673]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:36.673]  - seeds: <none>
[17:38:36.673]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:36.673] getGlobalsAndPackages() ...
[17:38:36.673] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:36.673] Resolving globals: FALSE
[17:38:36.674] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:38:36.674] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:38:36.674] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:36.674] 
[17:38:36.674] getGlobalsAndPackages() ... DONE
[17:38:36.675] run() for ‘Future’ ...
[17:38:36.675] - state: ‘created’
[17:38:36.675] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:36.689] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:36.689] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:36.689]   - Field: ‘node’
[17:38:36.689]   - Field: ‘label’
[17:38:36.689]   - Field: ‘local’
[17:38:36.689]   - Field: ‘owner’
[17:38:36.689]   - Field: ‘envir’
[17:38:36.689]   - Field: ‘workers’
[17:38:36.689]   - Field: ‘packages’
[17:38:36.689]   - Field: ‘gc’
[17:38:36.690]   - Field: ‘conditions’
[17:38:36.690]   - Field: ‘persistent’
[17:38:36.690]   - Field: ‘expr’
[17:38:36.690]   - Field: ‘uuid’
[17:38:36.690]   - Field: ‘seed’
[17:38:36.690]   - Field: ‘version’
[17:38:36.690]   - Field: ‘result’
[17:38:36.690]   - Field: ‘asynchronous’
[17:38:36.690]   - Field: ‘calls’
[17:38:36.690]   - Field: ‘globals’
[17:38:36.690]   - Field: ‘stdout’
[17:38:36.691]   - Field: ‘earlySignal’
[17:38:36.691]   - Field: ‘lazy’
[17:38:36.691]   - Field: ‘state’
[17:38:36.691] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:36.691] - Launch lazy future ...
[17:38:36.691] Packages needed by the future expression (n = 0): <none>
[17:38:36.691] Packages needed by future strategies (n = 0): <none>
[17:38:36.692] {
[17:38:36.692]     {
[17:38:36.692]         {
[17:38:36.692]             ...future.startTime <- base::Sys.time()
[17:38:36.692]             {
[17:38:36.692]                 {
[17:38:36.692]                   {
[17:38:36.692]                     {
[17:38:36.692]                       base::local({
[17:38:36.692]                         has_future <- base::requireNamespace("future", 
[17:38:36.692]                           quietly = TRUE)
[17:38:36.692]                         if (has_future) {
[17:38:36.692]                           ns <- base::getNamespace("future")
[17:38:36.692]                           version <- ns[[".package"]][["version"]]
[17:38:36.692]                           if (is.null(version)) 
[17:38:36.692]                             version <- utils::packageVersion("future")
[17:38:36.692]                         }
[17:38:36.692]                         else {
[17:38:36.692]                           version <- NULL
[17:38:36.692]                         }
[17:38:36.692]                         if (!has_future || version < "1.8.0") {
[17:38:36.692]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:36.692]                             "", base::R.version$version.string), 
[17:38:36.692]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:36.692]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:36.692]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:36.692]                               "release", "version")], collapse = " "), 
[17:38:36.692]                             hostname = base::Sys.info()[["nodename"]])
[17:38:36.692]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:36.692]                             info)
[17:38:36.692]                           info <- base::paste(info, collapse = "; ")
[17:38:36.692]                           if (!has_future) {
[17:38:36.692]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:36.692]                               info)
[17:38:36.692]                           }
[17:38:36.692]                           else {
[17:38:36.692]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:36.692]                               info, version)
[17:38:36.692]                           }
[17:38:36.692]                           base::stop(msg)
[17:38:36.692]                         }
[17:38:36.692]                       })
[17:38:36.692]                     }
[17:38:36.692]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:36.692]                     base::options(mc.cores = 1L)
[17:38:36.692]                   }
[17:38:36.692]                   ...future.strategy.old <- future::plan("list")
[17:38:36.692]                   options(future.plan = NULL)
[17:38:36.692]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:36.692]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:36.692]                 }
[17:38:36.692]                 ...future.workdir <- getwd()
[17:38:36.692]             }
[17:38:36.692]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:36.692]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:36.692]         }
[17:38:36.692]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:36.692]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:36.692]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:36.692]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:36.692]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:36.692]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:36.692]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:36.692]             base::names(...future.oldOptions))
[17:38:36.692]     }
[17:38:36.692]     if (FALSE) {
[17:38:36.692]     }
[17:38:36.692]     else {
[17:38:36.692]         if (FALSE) {
[17:38:36.692]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:36.692]                 open = "w")
[17:38:36.692]         }
[17:38:36.692]         else {
[17:38:36.692]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:36.692]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:36.692]         }
[17:38:36.692]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:36.692]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:36.692]             base::sink(type = "output", split = FALSE)
[17:38:36.692]             base::close(...future.stdout)
[17:38:36.692]         }, add = TRUE)
[17:38:36.692]     }
[17:38:36.692]     ...future.frame <- base::sys.nframe()
[17:38:36.692]     ...future.conditions <- base::list()
[17:38:36.692]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:36.692]     if (FALSE) {
[17:38:36.692]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:36.692]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:36.692]     }
[17:38:36.692]     ...future.result <- base::tryCatch({
[17:38:36.692]         base::withCallingHandlers({
[17:38:36.692]             ...future.value <- base::withVisible(base::local({
[17:38:36.692]                 ...future.makeSendCondition <- base::local({
[17:38:36.692]                   sendCondition <- NULL
[17:38:36.692]                   function(frame = 1L) {
[17:38:36.692]                     if (is.function(sendCondition)) 
[17:38:36.692]                       return(sendCondition)
[17:38:36.692]                     ns <- getNamespace("parallel")
[17:38:36.692]                     if (exists("sendData", mode = "function", 
[17:38:36.692]                       envir = ns)) {
[17:38:36.692]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:36.692]                         envir = ns)
[17:38:36.692]                       envir <- sys.frame(frame)
[17:38:36.692]                       master <- NULL
[17:38:36.692]                       while (!identical(envir, .GlobalEnv) && 
[17:38:36.692]                         !identical(envir, emptyenv())) {
[17:38:36.692]                         if (exists("master", mode = "list", envir = envir, 
[17:38:36.692]                           inherits = FALSE)) {
[17:38:36.692]                           master <- get("master", mode = "list", 
[17:38:36.692]                             envir = envir, inherits = FALSE)
[17:38:36.692]                           if (inherits(master, c("SOCKnode", 
[17:38:36.692]                             "SOCK0node"))) {
[17:38:36.692]                             sendCondition <<- function(cond) {
[17:38:36.692]                               data <- list(type = "VALUE", value = cond, 
[17:38:36.692]                                 success = TRUE)
[17:38:36.692]                               parallel_sendData(master, data)
[17:38:36.692]                             }
[17:38:36.692]                             return(sendCondition)
[17:38:36.692]                           }
[17:38:36.692]                         }
[17:38:36.692]                         frame <- frame + 1L
[17:38:36.692]                         envir <- sys.frame(frame)
[17:38:36.692]                       }
[17:38:36.692]                     }
[17:38:36.692]                     sendCondition <<- function(cond) NULL
[17:38:36.692]                   }
[17:38:36.692]                 })
[17:38:36.692]                 withCallingHandlers({
[17:38:36.692]                   {
[17:38:36.692]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:36.692]                     if (!identical(...future.globals.maxSize.org, 
[17:38:36.692]                       ...future.globals.maxSize)) {
[17:38:36.692]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:36.692]                       on.exit(options(oopts), add = TRUE)
[17:38:36.692]                     }
[17:38:36.692]                     {
[17:38:36.692]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:36.692]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:38:36.692]                         USE.NAMES = FALSE)
[17:38:36.692]                       do.call(mapply, args = args)
[17:38:36.692]                     }
[17:38:36.692]                   }
[17:38:36.692]                 }, immediateCondition = function(cond) {
[17:38:36.692]                   sendCondition <- ...future.makeSendCondition()
[17:38:36.692]                   sendCondition(cond)
[17:38:36.692]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:36.692]                   {
[17:38:36.692]                     inherits <- base::inherits
[17:38:36.692]                     invokeRestart <- base::invokeRestart
[17:38:36.692]                     is.null <- base::is.null
[17:38:36.692]                     muffled <- FALSE
[17:38:36.692]                     if (inherits(cond, "message")) {
[17:38:36.692]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:36.692]                       if (muffled) 
[17:38:36.692]                         invokeRestart("muffleMessage")
[17:38:36.692]                     }
[17:38:36.692]                     else if (inherits(cond, "warning")) {
[17:38:36.692]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:36.692]                       if (muffled) 
[17:38:36.692]                         invokeRestart("muffleWarning")
[17:38:36.692]                     }
[17:38:36.692]                     else if (inherits(cond, "condition")) {
[17:38:36.692]                       if (!is.null(pattern)) {
[17:38:36.692]                         computeRestarts <- base::computeRestarts
[17:38:36.692]                         grepl <- base::grepl
[17:38:36.692]                         restarts <- computeRestarts(cond)
[17:38:36.692]                         for (restart in restarts) {
[17:38:36.692]                           name <- restart$name
[17:38:36.692]                           if (is.null(name)) 
[17:38:36.692]                             next
[17:38:36.692]                           if (!grepl(pattern, name)) 
[17:38:36.692]                             next
[17:38:36.692]                           invokeRestart(restart)
[17:38:36.692]                           muffled <- TRUE
[17:38:36.692]                           break
[17:38:36.692]                         }
[17:38:36.692]                       }
[17:38:36.692]                     }
[17:38:36.692]                     invisible(muffled)
[17:38:36.692]                   }
[17:38:36.692]                   muffleCondition(cond)
[17:38:36.692]                 })
[17:38:36.692]             }))
[17:38:36.692]             future::FutureResult(value = ...future.value$value, 
[17:38:36.692]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:36.692]                   ...future.rng), globalenv = if (FALSE) 
[17:38:36.692]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:36.692]                     ...future.globalenv.names))
[17:38:36.692]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:36.692]         }, condition = base::local({
[17:38:36.692]             c <- base::c
[17:38:36.692]             inherits <- base::inherits
[17:38:36.692]             invokeRestart <- base::invokeRestart
[17:38:36.692]             length <- base::length
[17:38:36.692]             list <- base::list
[17:38:36.692]             seq.int <- base::seq.int
[17:38:36.692]             signalCondition <- base::signalCondition
[17:38:36.692]             sys.calls <- base::sys.calls
[17:38:36.692]             `[[` <- base::`[[`
[17:38:36.692]             `+` <- base::`+`
[17:38:36.692]             `<<-` <- base::`<<-`
[17:38:36.692]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:36.692]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:36.692]                   3L)]
[17:38:36.692]             }
[17:38:36.692]             function(cond) {
[17:38:36.692]                 is_error <- inherits(cond, "error")
[17:38:36.692]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:36.692]                   NULL)
[17:38:36.692]                 if (is_error) {
[17:38:36.692]                   sessionInformation <- function() {
[17:38:36.692]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:36.692]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:36.692]                       search = base::search(), system = base::Sys.info())
[17:38:36.692]                   }
[17:38:36.692]                   ...future.conditions[[length(...future.conditions) + 
[17:38:36.692]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:36.692]                     cond$call), session = sessionInformation(), 
[17:38:36.692]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:36.692]                   signalCondition(cond)
[17:38:36.692]                 }
[17:38:36.692]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:36.692]                 "immediateCondition"))) {
[17:38:36.692]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:36.692]                   ...future.conditions[[length(...future.conditions) + 
[17:38:36.692]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:36.692]                   if (TRUE && !signal) {
[17:38:36.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:36.692]                     {
[17:38:36.692]                       inherits <- base::inherits
[17:38:36.692]                       invokeRestart <- base::invokeRestart
[17:38:36.692]                       is.null <- base::is.null
[17:38:36.692]                       muffled <- FALSE
[17:38:36.692]                       if (inherits(cond, "message")) {
[17:38:36.692]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:36.692]                         if (muffled) 
[17:38:36.692]                           invokeRestart("muffleMessage")
[17:38:36.692]                       }
[17:38:36.692]                       else if (inherits(cond, "warning")) {
[17:38:36.692]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:36.692]                         if (muffled) 
[17:38:36.692]                           invokeRestart("muffleWarning")
[17:38:36.692]                       }
[17:38:36.692]                       else if (inherits(cond, "condition")) {
[17:38:36.692]                         if (!is.null(pattern)) {
[17:38:36.692]                           computeRestarts <- base::computeRestarts
[17:38:36.692]                           grepl <- base::grepl
[17:38:36.692]                           restarts <- computeRestarts(cond)
[17:38:36.692]                           for (restart in restarts) {
[17:38:36.692]                             name <- restart$name
[17:38:36.692]                             if (is.null(name)) 
[17:38:36.692]                               next
[17:38:36.692]                             if (!grepl(pattern, name)) 
[17:38:36.692]                               next
[17:38:36.692]                             invokeRestart(restart)
[17:38:36.692]                             muffled <- TRUE
[17:38:36.692]                             break
[17:38:36.692]                           }
[17:38:36.692]                         }
[17:38:36.692]                       }
[17:38:36.692]                       invisible(muffled)
[17:38:36.692]                     }
[17:38:36.692]                     muffleCondition(cond, pattern = "^muffle")
[17:38:36.692]                   }
[17:38:36.692]                 }
[17:38:36.692]                 else {
[17:38:36.692]                   if (TRUE) {
[17:38:36.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:36.692]                     {
[17:38:36.692]                       inherits <- base::inherits
[17:38:36.692]                       invokeRestart <- base::invokeRestart
[17:38:36.692]                       is.null <- base::is.null
[17:38:36.692]                       muffled <- FALSE
[17:38:36.692]                       if (inherits(cond, "message")) {
[17:38:36.692]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:36.692]                         if (muffled) 
[17:38:36.692]                           invokeRestart("muffleMessage")
[17:38:36.692]                       }
[17:38:36.692]                       else if (inherits(cond, "warning")) {
[17:38:36.692]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:36.692]                         if (muffled) 
[17:38:36.692]                           invokeRestart("muffleWarning")
[17:38:36.692]                       }
[17:38:36.692]                       else if (inherits(cond, "condition")) {
[17:38:36.692]                         if (!is.null(pattern)) {
[17:38:36.692]                           computeRestarts <- base::computeRestarts
[17:38:36.692]                           grepl <- base::grepl
[17:38:36.692]                           restarts <- computeRestarts(cond)
[17:38:36.692]                           for (restart in restarts) {
[17:38:36.692]                             name <- restart$name
[17:38:36.692]                             if (is.null(name)) 
[17:38:36.692]                               next
[17:38:36.692]                             if (!grepl(pattern, name)) 
[17:38:36.692]                               next
[17:38:36.692]                             invokeRestart(restart)
[17:38:36.692]                             muffled <- TRUE
[17:38:36.692]                             break
[17:38:36.692]                           }
[17:38:36.692]                         }
[17:38:36.692]                       }
[17:38:36.692]                       invisible(muffled)
[17:38:36.692]                     }
[17:38:36.692]                     muffleCondition(cond, pattern = "^muffle")
[17:38:36.692]                   }
[17:38:36.692]                 }
[17:38:36.692]             }
[17:38:36.692]         }))
[17:38:36.692]     }, error = function(ex) {
[17:38:36.692]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:36.692]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:36.692]                 ...future.rng), started = ...future.startTime, 
[17:38:36.692]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:36.692]             version = "1.8"), class = "FutureResult")
[17:38:36.692]     }, finally = {
[17:38:36.692]         if (!identical(...future.workdir, getwd())) 
[17:38:36.692]             setwd(...future.workdir)
[17:38:36.692]         {
[17:38:36.692]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:36.692]                 ...future.oldOptions$nwarnings <- NULL
[17:38:36.692]             }
[17:38:36.692]             base::options(...future.oldOptions)
[17:38:36.692]             if (.Platform$OS.type == "windows") {
[17:38:36.692]                 old_names <- names(...future.oldEnvVars)
[17:38:36.692]                 envs <- base::Sys.getenv()
[17:38:36.692]                 names <- names(envs)
[17:38:36.692]                 common <- intersect(names, old_names)
[17:38:36.692]                 added <- setdiff(names, old_names)
[17:38:36.692]                 removed <- setdiff(old_names, names)
[17:38:36.692]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:36.692]                   envs[common]]
[17:38:36.692]                 NAMES <- toupper(changed)
[17:38:36.692]                 args <- list()
[17:38:36.692]                 for (kk in seq_along(NAMES)) {
[17:38:36.692]                   name <- changed[[kk]]
[17:38:36.692]                   NAME <- NAMES[[kk]]
[17:38:36.692]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:36.692]                     next
[17:38:36.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:36.692]                 }
[17:38:36.692]                 NAMES <- toupper(added)
[17:38:36.692]                 for (kk in seq_along(NAMES)) {
[17:38:36.692]                   name <- added[[kk]]
[17:38:36.692]                   NAME <- NAMES[[kk]]
[17:38:36.692]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:36.692]                     next
[17:38:36.692]                   args[[name]] <- ""
[17:38:36.692]                 }
[17:38:36.692]                 NAMES <- toupper(removed)
[17:38:36.692]                 for (kk in seq_along(NAMES)) {
[17:38:36.692]                   name <- removed[[kk]]
[17:38:36.692]                   NAME <- NAMES[[kk]]
[17:38:36.692]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:36.692]                     next
[17:38:36.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:36.692]                 }
[17:38:36.692]                 if (length(args) > 0) 
[17:38:36.692]                   base::do.call(base::Sys.setenv, args = args)
[17:38:36.692]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:36.692]             }
[17:38:36.692]             else {
[17:38:36.692]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:36.692]             }
[17:38:36.692]             {
[17:38:36.692]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:36.692]                   0L) {
[17:38:36.692]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:36.692]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:36.692]                   base::options(opts)
[17:38:36.692]                 }
[17:38:36.692]                 {
[17:38:36.692]                   {
[17:38:36.692]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:36.692]                     NULL
[17:38:36.692]                   }
[17:38:36.692]                   options(future.plan = NULL)
[17:38:36.692]                   if (is.na(NA_character_)) 
[17:38:36.692]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:36.692]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:36.692]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:36.692]                     .init = FALSE)
[17:38:36.692]                 }
[17:38:36.692]             }
[17:38:36.692]         }
[17:38:36.692]     })
[17:38:36.692]     if (TRUE) {
[17:38:36.692]         base::sink(type = "output", split = FALSE)
[17:38:36.692]         if (FALSE) {
[17:38:36.692]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:36.692]         }
[17:38:36.692]         else {
[17:38:36.692]             ...future.result["stdout"] <- base::list(NULL)
[17:38:36.692]         }
[17:38:36.692]         base::close(...future.stdout)
[17:38:36.692]         ...future.stdout <- NULL
[17:38:36.692]     }
[17:38:36.692]     ...future.result$conditions <- ...future.conditions
[17:38:36.692]     ...future.result$finished <- base::Sys.time()
[17:38:36.692]     ...future.result
[17:38:36.692] }
[17:38:36.694] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[17:38:36.694] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[17:38:36.695] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[17:38:36.695] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:38:36.695] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:38:36.696] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:38:36.696] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:38:36.696] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:38:36.696] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:38:36.697] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:38:36.697] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:38:36.697] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[17:38:36.697] MultisessionFuture started
[17:38:36.698] - Launch lazy future ... done
[17:38:36.698] run() for ‘MultisessionFuture’ ... done
[17:38:36.698] Created future:
[17:38:36.699] receiveMessageFromWorker() for ClusterFuture ...
[17:38:36.699] - Validating connection of MultisessionFuture
[17:38:36.699] - received message: FutureResult
[17:38:36.700] - Received FutureResult
[17:38:36.700] - Erased future from FutureRegistry
[17:38:36.700] result() for ClusterFuture ...
[17:38:36.700] - result already collected: FutureResult
[17:38:36.700] result() for ClusterFuture ... done
[17:38:36.700] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:36.698] MultisessionFuture:
[17:38:36.698] Label: ‘future_mapply-2’
[17:38:36.698] Expression:
[17:38:36.698] {
[17:38:36.698]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:36.698]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:36.698]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:36.698]         on.exit(options(oopts), add = TRUE)
[17:38:36.698]     }
[17:38:36.698]     {
[17:38:36.698]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:36.698]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:38:36.698]         do.call(mapply, args = args)
[17:38:36.698]     }
[17:38:36.698] }
[17:38:36.698] Lazy evaluation: FALSE
[17:38:36.698] Asynchronous evaluation: TRUE
[17:38:36.698] Local evaluation: TRUE
[17:38:36.698] Environment: R_GlobalEnv
[17:38:36.698] Capture standard output: FALSE
[17:38:36.698] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:36.698] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:36.698] Packages: <none>
[17:38:36.698] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:36.698] Resolved: TRUE
[17:38:36.698] Value: <not collected>
[17:38:36.698] Conditions captured: <none>
[17:38:36.698] Early signaling: FALSE
[17:38:36.698] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:36.698] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:36.700] Chunk #2 of 2 ... DONE
[17:38:36.701] Launching 2 futures (chunks) ... DONE
[17:38:36.701] Resolving 2 futures (chunks) ...
[17:38:36.701] resolve() on list ...
[17:38:36.701]  recursive: 0
[17:38:36.701]  length: 2
[17:38:36.701] 
[17:38:36.712] Future #2
[17:38:36.712] result() for ClusterFuture ...
[17:38:36.712] - result already collected: FutureResult
[17:38:36.712] result() for ClusterFuture ... done
[17:38:36.712] result() for ClusterFuture ...
[17:38:36.712] - result already collected: FutureResult
[17:38:36.712] result() for ClusterFuture ... done
[17:38:36.712] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:38:36.712] - nx: 2
[17:38:36.713] - relay: TRUE
[17:38:36.713] - stdout: TRUE
[17:38:36.713] - signal: TRUE
[17:38:36.713] - resignal: FALSE
[17:38:36.713] - force: TRUE
[17:38:36.713] - relayed: [n=2] FALSE, FALSE
[17:38:36.713] - queued futures: [n=2] FALSE, FALSE
[17:38:36.713]  - until=1
[17:38:36.713]  - relaying element #1
[17:38:36.713] - relayed: [n=2] FALSE, FALSE
[17:38:36.713] - queued futures: [n=2] FALSE, TRUE
[17:38:36.713] signalConditionsASAP(NULL, pos=2) ... done
[17:38:36.714]  length: 1 (resolved future 2)
[17:38:37.203] receiveMessageFromWorker() for ClusterFuture ...
[17:38:37.203] - Validating connection of MultisessionFuture
[17:38:37.203] - received message: FutureResult
[17:38:37.203] - Received FutureResult
[17:38:37.204] - Erased future from FutureRegistry
[17:38:37.204] result() for ClusterFuture ...
[17:38:37.204] - result already collected: FutureResult
[17:38:37.204] result() for ClusterFuture ... done
[17:38:37.204] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:37.204] Future #1
[17:38:37.204] result() for ClusterFuture ...
[17:38:37.204] - result already collected: FutureResult
[17:38:37.204] result() for ClusterFuture ... done
[17:38:37.205] result() for ClusterFuture ...
[17:38:37.205] - result already collected: FutureResult
[17:38:37.205] result() for ClusterFuture ... done
[17:38:37.205] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:38:37.205] - nx: 2
[17:38:37.205] - relay: TRUE
[17:38:37.205] - stdout: TRUE
[17:38:37.205] - signal: TRUE
[17:38:37.205] - resignal: FALSE
[17:38:37.205] - force: TRUE
[17:38:37.205] - relayed: [n=2] FALSE, FALSE
[17:38:37.205] - queued futures: [n=2] FALSE, TRUE
[17:38:37.206]  - until=1
[17:38:37.206]  - relaying element #1
[17:38:37.206] result() for ClusterFuture ...
[17:38:37.206] - result already collected: FutureResult
[17:38:37.206] result() for ClusterFuture ... done
[17:38:37.206] result() for ClusterFuture ...
[17:38:37.206] - result already collected: FutureResult
[17:38:37.206] result() for ClusterFuture ... done
[17:38:37.206] result() for ClusterFuture ...
[17:38:37.206] - result already collected: FutureResult
[17:38:37.206] result() for ClusterFuture ... done
[17:38:37.207] result() for ClusterFuture ...
[17:38:37.207] - result already collected: FutureResult
[17:38:37.207] result() for ClusterFuture ... done
[17:38:37.207] - relayed: [n=2] TRUE, FALSE
[17:38:37.207] - queued futures: [n=2] TRUE, TRUE
[17:38:37.207] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:38:37.207]  length: 0 (resolved future 1)
[17:38:37.207] Relaying remaining futures
[17:38:37.207] signalConditionsASAP(NULL, pos=0) ...
[17:38:37.207] - nx: 2
[17:38:37.207] - relay: TRUE
[17:38:37.207] - stdout: TRUE
[17:38:37.208] - signal: TRUE
[17:38:37.208] - resignal: FALSE
[17:38:37.208] - force: TRUE
[17:38:37.208] - relayed: [n=2] TRUE, FALSE
[17:38:37.208] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:37.208]  - relaying element #2
[17:38:37.208] result() for ClusterFuture ...
[17:38:37.208] - result already collected: FutureResult
[17:38:37.208] result() for ClusterFuture ... done
[17:38:37.208] result() for ClusterFuture ...
[17:38:37.208] - result already collected: FutureResult
[17:38:37.209] result() for ClusterFuture ... done
[17:38:37.209] result() for ClusterFuture ...
[17:38:37.209] - result already collected: FutureResult
[17:38:37.209] result() for ClusterFuture ... done
[17:38:37.209] result() for ClusterFuture ...
[17:38:37.209] - result already collected: FutureResult
[17:38:37.209] result() for ClusterFuture ... done
[17:38:37.209] - relayed: [n=2] TRUE, TRUE
[17:38:37.209] - queued futures: [n=2] TRUE, TRUE
[17:38:37.209] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:38:37.209] resolve() on list ... DONE
[17:38:37.210] result() for ClusterFuture ...
[17:38:37.210] - result already collected: FutureResult
[17:38:37.210] result() for ClusterFuture ... done
[17:38:37.210] result() for ClusterFuture ...
[17:38:37.210] - result already collected: FutureResult
[17:38:37.210] result() for ClusterFuture ... done
[17:38:37.210] result() for ClusterFuture ...
[17:38:37.210] - result already collected: FutureResult
[17:38:37.210] result() for ClusterFuture ... done
[17:38:37.210] result() for ClusterFuture ...
[17:38:37.210] - result already collected: FutureResult
[17:38:37.210] result() for ClusterFuture ... done
[17:38:37.211]  - Number of value chunks collected: 2
[17:38:37.211] Resolving 2 futures (chunks) ... DONE
[17:38:37.211] Reducing values from 2 chunks ...
[17:38:37.211]  - Number of values collected after concatenation: 2
[17:38:37.211]  - Number of values expected: 2
[17:38:37.211] Reducing values from 2 chunks ... DONE
[17:38:37.211] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[17:38:37.211] future_mapply() ...
[17:38:37.215] Number of chunks: 2
[17:38:37.215] getGlobalsAndPackagesXApply() ...
[17:38:37.215]  - future.globals: TRUE
[17:38:37.216] getGlobalsAndPackages() ...
[17:38:37.216] Searching for globals...
[17:38:37.217] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:38:37.217] Searching for globals ... DONE
[17:38:37.217] Resolving globals: FALSE
[17:38:37.218] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:38:37.218] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:38:37.218] - globals: [1] ‘FUN’
[17:38:37.218] 
[17:38:37.219] getGlobalsAndPackages() ... DONE
[17:38:37.219]  - globals found/used: [n=1] ‘FUN’
[17:38:37.219]  - needed namespaces: [n=0] 
[17:38:37.219] Finding globals ... DONE
[17:38:37.219] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:38:37.219] List of 2
[17:38:37.219]  $ ...future.FUN:function (x, y)  
[17:38:37.219]  $ MoreArgs     : NULL
[17:38:37.219]  - attr(*, "where")=List of 2
[17:38:37.219]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:37.219]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:38:37.219]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:37.219]  - attr(*, "resolved")= logi FALSE
[17:38:37.219]  - attr(*, "total_size")= num NA
[17:38:37.221] Packages to be attached in all futures: [n=0] 
[17:38:37.222] getGlobalsAndPackagesXApply() ... DONE
[17:38:37.222] Number of futures (= number of chunks): 2
[17:38:37.222] Launching 2 futures (chunks) ...
[17:38:37.222] Chunk #1 of 2 ...
[17:38:37.222]  - Finding globals in '...' for chunk #1 ...
[17:38:37.222] getGlobalsAndPackages() ...
[17:38:37.222] Searching for globals...
[17:38:37.223] 
[17:38:37.223] Searching for globals ... DONE
[17:38:37.223] - globals: [0] <none>
[17:38:37.223] getGlobalsAndPackages() ... DONE
[17:38:37.223]    + additional globals found: [n=0] 
[17:38:37.223]    + additional namespaces needed: [n=0] 
[17:38:37.223]  - Finding globals in '...' for chunk #1 ... DONE
[17:38:37.223]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:37.223]  - seeds: <none>
[17:38:37.223]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:37.223] getGlobalsAndPackages() ...
[17:38:37.224] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:37.224] Resolving globals: FALSE
[17:38:37.224] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:38:37.225] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:38:37.225] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:37.225] 
[17:38:37.225] getGlobalsAndPackages() ... DONE
[17:38:37.225] run() for ‘Future’ ...
[17:38:37.225] - state: ‘created’
[17:38:37.225] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:37.239] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:37.239] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:37.239]   - Field: ‘node’
[17:38:37.239]   - Field: ‘label’
[17:38:37.239]   - Field: ‘local’
[17:38:37.239]   - Field: ‘owner’
[17:38:37.240]   - Field: ‘envir’
[17:38:37.240]   - Field: ‘workers’
[17:38:37.240]   - Field: ‘packages’
[17:38:37.240]   - Field: ‘gc’
[17:38:37.240]   - Field: ‘conditions’
[17:38:37.240]   - Field: ‘persistent’
[17:38:37.240]   - Field: ‘expr’
[17:38:37.240]   - Field: ‘uuid’
[17:38:37.240]   - Field: ‘seed’
[17:38:37.240]   - Field: ‘version’
[17:38:37.240]   - Field: ‘result’
[17:38:37.241]   - Field: ‘asynchronous’
[17:38:37.241]   - Field: ‘calls’
[17:38:37.241]   - Field: ‘globals’
[17:38:37.241]   - Field: ‘stdout’
[17:38:37.241]   - Field: ‘earlySignal’
[17:38:37.241]   - Field: ‘lazy’
[17:38:37.241]   - Field: ‘state’
[17:38:37.241] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:37.241] - Launch lazy future ...
[17:38:37.242] Packages needed by the future expression (n = 0): <none>
[17:38:37.242] Packages needed by future strategies (n = 0): <none>
[17:38:37.242] {
[17:38:37.242]     {
[17:38:37.242]         {
[17:38:37.242]             ...future.startTime <- base::Sys.time()
[17:38:37.242]             {
[17:38:37.242]                 {
[17:38:37.242]                   {
[17:38:37.242]                     {
[17:38:37.242]                       base::local({
[17:38:37.242]                         has_future <- base::requireNamespace("future", 
[17:38:37.242]                           quietly = TRUE)
[17:38:37.242]                         if (has_future) {
[17:38:37.242]                           ns <- base::getNamespace("future")
[17:38:37.242]                           version <- ns[[".package"]][["version"]]
[17:38:37.242]                           if (is.null(version)) 
[17:38:37.242]                             version <- utils::packageVersion("future")
[17:38:37.242]                         }
[17:38:37.242]                         else {
[17:38:37.242]                           version <- NULL
[17:38:37.242]                         }
[17:38:37.242]                         if (!has_future || version < "1.8.0") {
[17:38:37.242]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:37.242]                             "", base::R.version$version.string), 
[17:38:37.242]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:37.242]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:37.242]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:37.242]                               "release", "version")], collapse = " "), 
[17:38:37.242]                             hostname = base::Sys.info()[["nodename"]])
[17:38:37.242]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:37.242]                             info)
[17:38:37.242]                           info <- base::paste(info, collapse = "; ")
[17:38:37.242]                           if (!has_future) {
[17:38:37.242]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:37.242]                               info)
[17:38:37.242]                           }
[17:38:37.242]                           else {
[17:38:37.242]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:37.242]                               info, version)
[17:38:37.242]                           }
[17:38:37.242]                           base::stop(msg)
[17:38:37.242]                         }
[17:38:37.242]                       })
[17:38:37.242]                     }
[17:38:37.242]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:37.242]                     base::options(mc.cores = 1L)
[17:38:37.242]                   }
[17:38:37.242]                   ...future.strategy.old <- future::plan("list")
[17:38:37.242]                   options(future.plan = NULL)
[17:38:37.242]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:37.242]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:37.242]                 }
[17:38:37.242]                 ...future.workdir <- getwd()
[17:38:37.242]             }
[17:38:37.242]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:37.242]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:37.242]         }
[17:38:37.242]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:37.242]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:37.242]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:37.242]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:37.242]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:37.242]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:37.242]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:37.242]             base::names(...future.oldOptions))
[17:38:37.242]     }
[17:38:37.242]     if (FALSE) {
[17:38:37.242]     }
[17:38:37.242]     else {
[17:38:37.242]         if (TRUE) {
[17:38:37.242]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:37.242]                 open = "w")
[17:38:37.242]         }
[17:38:37.242]         else {
[17:38:37.242]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:37.242]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:37.242]         }
[17:38:37.242]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:37.242]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:37.242]             base::sink(type = "output", split = FALSE)
[17:38:37.242]             base::close(...future.stdout)
[17:38:37.242]         }, add = TRUE)
[17:38:37.242]     }
[17:38:37.242]     ...future.frame <- base::sys.nframe()
[17:38:37.242]     ...future.conditions <- base::list()
[17:38:37.242]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:37.242]     if (FALSE) {
[17:38:37.242]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:37.242]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:37.242]     }
[17:38:37.242]     ...future.result <- base::tryCatch({
[17:38:37.242]         base::withCallingHandlers({
[17:38:37.242]             ...future.value <- base::withVisible(base::local({
[17:38:37.242]                 ...future.makeSendCondition <- base::local({
[17:38:37.242]                   sendCondition <- NULL
[17:38:37.242]                   function(frame = 1L) {
[17:38:37.242]                     if (is.function(sendCondition)) 
[17:38:37.242]                       return(sendCondition)
[17:38:37.242]                     ns <- getNamespace("parallel")
[17:38:37.242]                     if (exists("sendData", mode = "function", 
[17:38:37.242]                       envir = ns)) {
[17:38:37.242]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:37.242]                         envir = ns)
[17:38:37.242]                       envir <- sys.frame(frame)
[17:38:37.242]                       master <- NULL
[17:38:37.242]                       while (!identical(envir, .GlobalEnv) && 
[17:38:37.242]                         !identical(envir, emptyenv())) {
[17:38:37.242]                         if (exists("master", mode = "list", envir = envir, 
[17:38:37.242]                           inherits = FALSE)) {
[17:38:37.242]                           master <- get("master", mode = "list", 
[17:38:37.242]                             envir = envir, inherits = FALSE)
[17:38:37.242]                           if (inherits(master, c("SOCKnode", 
[17:38:37.242]                             "SOCK0node"))) {
[17:38:37.242]                             sendCondition <<- function(cond) {
[17:38:37.242]                               data <- list(type = "VALUE", value = cond, 
[17:38:37.242]                                 success = TRUE)
[17:38:37.242]                               parallel_sendData(master, data)
[17:38:37.242]                             }
[17:38:37.242]                             return(sendCondition)
[17:38:37.242]                           }
[17:38:37.242]                         }
[17:38:37.242]                         frame <- frame + 1L
[17:38:37.242]                         envir <- sys.frame(frame)
[17:38:37.242]                       }
[17:38:37.242]                     }
[17:38:37.242]                     sendCondition <<- function(cond) NULL
[17:38:37.242]                   }
[17:38:37.242]                 })
[17:38:37.242]                 withCallingHandlers({
[17:38:37.242]                   {
[17:38:37.242]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:37.242]                     if (!identical(...future.globals.maxSize.org, 
[17:38:37.242]                       ...future.globals.maxSize)) {
[17:38:37.242]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:37.242]                       on.exit(options(oopts), add = TRUE)
[17:38:37.242]                     }
[17:38:37.242]                     {
[17:38:37.242]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:37.242]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:38:37.242]                         USE.NAMES = FALSE)
[17:38:37.242]                       do.call(mapply, args = args)
[17:38:37.242]                     }
[17:38:37.242]                   }
[17:38:37.242]                 }, immediateCondition = function(cond) {
[17:38:37.242]                   sendCondition <- ...future.makeSendCondition()
[17:38:37.242]                   sendCondition(cond)
[17:38:37.242]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:37.242]                   {
[17:38:37.242]                     inherits <- base::inherits
[17:38:37.242]                     invokeRestart <- base::invokeRestart
[17:38:37.242]                     is.null <- base::is.null
[17:38:37.242]                     muffled <- FALSE
[17:38:37.242]                     if (inherits(cond, "message")) {
[17:38:37.242]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:37.242]                       if (muffled) 
[17:38:37.242]                         invokeRestart("muffleMessage")
[17:38:37.242]                     }
[17:38:37.242]                     else if (inherits(cond, "warning")) {
[17:38:37.242]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:37.242]                       if (muffled) 
[17:38:37.242]                         invokeRestart("muffleWarning")
[17:38:37.242]                     }
[17:38:37.242]                     else if (inherits(cond, "condition")) {
[17:38:37.242]                       if (!is.null(pattern)) {
[17:38:37.242]                         computeRestarts <- base::computeRestarts
[17:38:37.242]                         grepl <- base::grepl
[17:38:37.242]                         restarts <- computeRestarts(cond)
[17:38:37.242]                         for (restart in restarts) {
[17:38:37.242]                           name <- restart$name
[17:38:37.242]                           if (is.null(name)) 
[17:38:37.242]                             next
[17:38:37.242]                           if (!grepl(pattern, name)) 
[17:38:37.242]                             next
[17:38:37.242]                           invokeRestart(restart)
[17:38:37.242]                           muffled <- TRUE
[17:38:37.242]                           break
[17:38:37.242]                         }
[17:38:37.242]                       }
[17:38:37.242]                     }
[17:38:37.242]                     invisible(muffled)
[17:38:37.242]                   }
[17:38:37.242]                   muffleCondition(cond)
[17:38:37.242]                 })
[17:38:37.242]             }))
[17:38:37.242]             future::FutureResult(value = ...future.value$value, 
[17:38:37.242]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:37.242]                   ...future.rng), globalenv = if (FALSE) 
[17:38:37.242]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:37.242]                     ...future.globalenv.names))
[17:38:37.242]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:37.242]         }, condition = base::local({
[17:38:37.242]             c <- base::c
[17:38:37.242]             inherits <- base::inherits
[17:38:37.242]             invokeRestart <- base::invokeRestart
[17:38:37.242]             length <- base::length
[17:38:37.242]             list <- base::list
[17:38:37.242]             seq.int <- base::seq.int
[17:38:37.242]             signalCondition <- base::signalCondition
[17:38:37.242]             sys.calls <- base::sys.calls
[17:38:37.242]             `[[` <- base::`[[`
[17:38:37.242]             `+` <- base::`+`
[17:38:37.242]             `<<-` <- base::`<<-`
[17:38:37.242]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:37.242]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:37.242]                   3L)]
[17:38:37.242]             }
[17:38:37.242]             function(cond) {
[17:38:37.242]                 is_error <- inherits(cond, "error")
[17:38:37.242]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:37.242]                   NULL)
[17:38:37.242]                 if (is_error) {
[17:38:37.242]                   sessionInformation <- function() {
[17:38:37.242]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:37.242]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:37.242]                       search = base::search(), system = base::Sys.info())
[17:38:37.242]                   }
[17:38:37.242]                   ...future.conditions[[length(...future.conditions) + 
[17:38:37.242]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:37.242]                     cond$call), session = sessionInformation(), 
[17:38:37.242]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:37.242]                   signalCondition(cond)
[17:38:37.242]                 }
[17:38:37.242]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:37.242]                 "immediateCondition"))) {
[17:38:37.242]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:37.242]                   ...future.conditions[[length(...future.conditions) + 
[17:38:37.242]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:37.242]                   if (TRUE && !signal) {
[17:38:37.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:37.242]                     {
[17:38:37.242]                       inherits <- base::inherits
[17:38:37.242]                       invokeRestart <- base::invokeRestart
[17:38:37.242]                       is.null <- base::is.null
[17:38:37.242]                       muffled <- FALSE
[17:38:37.242]                       if (inherits(cond, "message")) {
[17:38:37.242]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:37.242]                         if (muffled) 
[17:38:37.242]                           invokeRestart("muffleMessage")
[17:38:37.242]                       }
[17:38:37.242]                       else if (inherits(cond, "warning")) {
[17:38:37.242]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:37.242]                         if (muffled) 
[17:38:37.242]                           invokeRestart("muffleWarning")
[17:38:37.242]                       }
[17:38:37.242]                       else if (inherits(cond, "condition")) {
[17:38:37.242]                         if (!is.null(pattern)) {
[17:38:37.242]                           computeRestarts <- base::computeRestarts
[17:38:37.242]                           grepl <- base::grepl
[17:38:37.242]                           restarts <- computeRestarts(cond)
[17:38:37.242]                           for (restart in restarts) {
[17:38:37.242]                             name <- restart$name
[17:38:37.242]                             if (is.null(name)) 
[17:38:37.242]                               next
[17:38:37.242]                             if (!grepl(pattern, name)) 
[17:38:37.242]                               next
[17:38:37.242]                             invokeRestart(restart)
[17:38:37.242]                             muffled <- TRUE
[17:38:37.242]                             break
[17:38:37.242]                           }
[17:38:37.242]                         }
[17:38:37.242]                       }
[17:38:37.242]                       invisible(muffled)
[17:38:37.242]                     }
[17:38:37.242]                     muffleCondition(cond, pattern = "^muffle")
[17:38:37.242]                   }
[17:38:37.242]                 }
[17:38:37.242]                 else {
[17:38:37.242]                   if (TRUE) {
[17:38:37.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:37.242]                     {
[17:38:37.242]                       inherits <- base::inherits
[17:38:37.242]                       invokeRestart <- base::invokeRestart
[17:38:37.242]                       is.null <- base::is.null
[17:38:37.242]                       muffled <- FALSE
[17:38:37.242]                       if (inherits(cond, "message")) {
[17:38:37.242]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:37.242]                         if (muffled) 
[17:38:37.242]                           invokeRestart("muffleMessage")
[17:38:37.242]                       }
[17:38:37.242]                       else if (inherits(cond, "warning")) {
[17:38:37.242]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:37.242]                         if (muffled) 
[17:38:37.242]                           invokeRestart("muffleWarning")
[17:38:37.242]                       }
[17:38:37.242]                       else if (inherits(cond, "condition")) {
[17:38:37.242]                         if (!is.null(pattern)) {
[17:38:37.242]                           computeRestarts <- base::computeRestarts
[17:38:37.242]                           grepl <- base::grepl
[17:38:37.242]                           restarts <- computeRestarts(cond)
[17:38:37.242]                           for (restart in restarts) {
[17:38:37.242]                             name <- restart$name
[17:38:37.242]                             if (is.null(name)) 
[17:38:37.242]                               next
[17:38:37.242]                             if (!grepl(pattern, name)) 
[17:38:37.242]                               next
[17:38:37.242]                             invokeRestart(restart)
[17:38:37.242]                             muffled <- TRUE
[17:38:37.242]                             break
[17:38:37.242]                           }
[17:38:37.242]                         }
[17:38:37.242]                       }
[17:38:37.242]                       invisible(muffled)
[17:38:37.242]                     }
[17:38:37.242]                     muffleCondition(cond, pattern = "^muffle")
[17:38:37.242]                   }
[17:38:37.242]                 }
[17:38:37.242]             }
[17:38:37.242]         }))
[17:38:37.242]     }, error = function(ex) {
[17:38:37.242]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:37.242]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:37.242]                 ...future.rng), started = ...future.startTime, 
[17:38:37.242]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:37.242]             version = "1.8"), class = "FutureResult")
[17:38:37.242]     }, finally = {
[17:38:37.242]         if (!identical(...future.workdir, getwd())) 
[17:38:37.242]             setwd(...future.workdir)
[17:38:37.242]         {
[17:38:37.242]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:37.242]                 ...future.oldOptions$nwarnings <- NULL
[17:38:37.242]             }
[17:38:37.242]             base::options(...future.oldOptions)
[17:38:37.242]             if (.Platform$OS.type == "windows") {
[17:38:37.242]                 old_names <- names(...future.oldEnvVars)
[17:38:37.242]                 envs <- base::Sys.getenv()
[17:38:37.242]                 names <- names(envs)
[17:38:37.242]                 common <- intersect(names, old_names)
[17:38:37.242]                 added <- setdiff(names, old_names)
[17:38:37.242]                 removed <- setdiff(old_names, names)
[17:38:37.242]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:37.242]                   envs[common]]
[17:38:37.242]                 NAMES <- toupper(changed)
[17:38:37.242]                 args <- list()
[17:38:37.242]                 for (kk in seq_along(NAMES)) {
[17:38:37.242]                   name <- changed[[kk]]
[17:38:37.242]                   NAME <- NAMES[[kk]]
[17:38:37.242]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:37.242]                     next
[17:38:37.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:37.242]                 }
[17:38:37.242]                 NAMES <- toupper(added)
[17:38:37.242]                 for (kk in seq_along(NAMES)) {
[17:38:37.242]                   name <- added[[kk]]
[17:38:37.242]                   NAME <- NAMES[[kk]]
[17:38:37.242]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:37.242]                     next
[17:38:37.242]                   args[[name]] <- ""
[17:38:37.242]                 }
[17:38:37.242]                 NAMES <- toupper(removed)
[17:38:37.242]                 for (kk in seq_along(NAMES)) {
[17:38:37.242]                   name <- removed[[kk]]
[17:38:37.242]                   NAME <- NAMES[[kk]]
[17:38:37.242]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:37.242]                     next
[17:38:37.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:37.242]                 }
[17:38:37.242]                 if (length(args) > 0) 
[17:38:37.242]                   base::do.call(base::Sys.setenv, args = args)
[17:38:37.242]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:37.242]             }
[17:38:37.242]             else {
[17:38:37.242]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:37.242]             }
[17:38:37.242]             {
[17:38:37.242]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:37.242]                   0L) {
[17:38:37.242]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:37.242]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:37.242]                   base::options(opts)
[17:38:37.242]                 }
[17:38:37.242]                 {
[17:38:37.242]                   {
[17:38:37.242]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:37.242]                     NULL
[17:38:37.242]                   }
[17:38:37.242]                   options(future.plan = NULL)
[17:38:37.242]                   if (is.na(NA_character_)) 
[17:38:37.242]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:37.242]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:37.242]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:37.242]                     .init = FALSE)
[17:38:37.242]                 }
[17:38:37.242]             }
[17:38:37.242]         }
[17:38:37.242]     })
[17:38:37.242]     if (TRUE) {
[17:38:37.242]         base::sink(type = "output", split = FALSE)
[17:38:37.242]         if (TRUE) {
[17:38:37.242]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:37.242]         }
[17:38:37.242]         else {
[17:38:37.242]             ...future.result["stdout"] <- base::list(NULL)
[17:38:37.242]         }
[17:38:37.242]         base::close(...future.stdout)
[17:38:37.242]         ...future.stdout <- NULL
[17:38:37.242]     }
[17:38:37.242]     ...future.result$conditions <- ...future.conditions
[17:38:37.242]     ...future.result$finished <- base::Sys.time()
[17:38:37.242]     ...future.result
[17:38:37.242] }
[17:38:37.245] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[17:38:37.245] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[17:38:37.245] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[17:38:37.245] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:38:37.246] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:38:37.246] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:38:37.246] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:38:37.246] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:38:37.247] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:38:37.247] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:38:37.247] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:38:37.247] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[17:38:37.248] MultisessionFuture started
[17:38:37.248] - Launch lazy future ... done
[17:38:37.248] run() for ‘MultisessionFuture’ ... done
[17:38:37.248] Created future:
[17:38:37.248] MultisessionFuture:
[17:38:37.248] Label: ‘future_mapply-1’
[17:38:37.248] Expression:
[17:38:37.248] {
[17:38:37.248]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:37.248]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:37.248]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:37.248]         on.exit(options(oopts), add = TRUE)
[17:38:37.248]     }
[17:38:37.248]     {
[17:38:37.248]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:37.248]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:38:37.248]         do.call(mapply, args = args)
[17:38:37.248]     }
[17:38:37.248] }
[17:38:37.248] Lazy evaluation: FALSE
[17:38:37.248] Asynchronous evaluation: TRUE
[17:38:37.248] Local evaluation: TRUE
[17:38:37.248] Environment: R_GlobalEnv
[17:38:37.248] Capture standard output: TRUE
[17:38:37.248] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:37.248] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:37.248] Packages: <none>
[17:38:37.248] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:37.248] Resolved: FALSE
[17:38:37.248] Value: <not collected>
[17:38:37.248] Conditions captured: <none>
[17:38:37.248] Early signaling: FALSE
[17:38:37.248] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:37.248] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:37.259] Chunk #1 of 2 ... DONE
[17:38:37.260] Chunk #2 of 2 ...
[17:38:37.260]  - Finding globals in '...' for chunk #2 ...
[17:38:37.260] getGlobalsAndPackages() ...
[17:38:37.260] Searching for globals...
[17:38:37.260] 
[17:38:37.260] Searching for globals ... DONE
[17:38:37.261] - globals: [0] <none>
[17:38:37.261] getGlobalsAndPackages() ... DONE
[17:38:37.261]    + additional globals found: [n=0] 
[17:38:37.261]    + additional namespaces needed: [n=0] 
[17:38:37.261]  - Finding globals in '...' for chunk #2 ... DONE
[17:38:37.261]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:37.261]  - seeds: <none>
[17:38:37.261]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:37.261] getGlobalsAndPackages() ...
[17:38:37.261] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:37.261] Resolving globals: FALSE
[17:38:37.262] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:38:37.262] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:38:37.262] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:37.263] 
[17:38:37.263] getGlobalsAndPackages() ... DONE
[17:38:37.263] run() for ‘Future’ ...
[17:38:37.263] - state: ‘created’
[17:38:37.263] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:37.277] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:37.277] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:37.277]   - Field: ‘node’
[17:38:37.278]   - Field: ‘label’
[17:38:37.278]   - Field: ‘local’
[17:38:37.278]   - Field: ‘owner’
[17:38:37.278]   - Field: ‘envir’
[17:38:37.278]   - Field: ‘workers’
[17:38:37.278]   - Field: ‘packages’
[17:38:37.278]   - Field: ‘gc’
[17:38:37.278]   - Field: ‘conditions’
[17:38:37.278]   - Field: ‘persistent’
[17:38:37.278]   - Field: ‘expr’
[17:38:37.278]   - Field: ‘uuid’
[17:38:37.279]   - Field: ‘seed’
[17:38:37.279]   - Field: ‘version’
[17:38:37.279]   - Field: ‘result’
[17:38:37.279]   - Field: ‘asynchronous’
[17:38:37.279]   - Field: ‘calls’
[17:38:37.281]   - Field: ‘globals’
[17:38:37.281]   - Field: ‘stdout’
[17:38:37.281]   - Field: ‘earlySignal’
[17:38:37.281]   - Field: ‘lazy’
[17:38:37.281]   - Field: ‘state’
[17:38:37.281] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:37.282] - Launch lazy future ...
[17:38:37.282] Packages needed by the future expression (n = 0): <none>
[17:38:37.282] Packages needed by future strategies (n = 0): <none>
[17:38:37.282] {
[17:38:37.282]     {
[17:38:37.282]         {
[17:38:37.282]             ...future.startTime <- base::Sys.time()
[17:38:37.282]             {
[17:38:37.282]                 {
[17:38:37.282]                   {
[17:38:37.282]                     {
[17:38:37.282]                       base::local({
[17:38:37.282]                         has_future <- base::requireNamespace("future", 
[17:38:37.282]                           quietly = TRUE)
[17:38:37.282]                         if (has_future) {
[17:38:37.282]                           ns <- base::getNamespace("future")
[17:38:37.282]                           version <- ns[[".package"]][["version"]]
[17:38:37.282]                           if (is.null(version)) 
[17:38:37.282]                             version <- utils::packageVersion("future")
[17:38:37.282]                         }
[17:38:37.282]                         else {
[17:38:37.282]                           version <- NULL
[17:38:37.282]                         }
[17:38:37.282]                         if (!has_future || version < "1.8.0") {
[17:38:37.282]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:37.282]                             "", base::R.version$version.string), 
[17:38:37.282]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:37.282]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:37.282]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:37.282]                               "release", "version")], collapse = " "), 
[17:38:37.282]                             hostname = base::Sys.info()[["nodename"]])
[17:38:37.282]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:37.282]                             info)
[17:38:37.282]                           info <- base::paste(info, collapse = "; ")
[17:38:37.282]                           if (!has_future) {
[17:38:37.282]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:37.282]                               info)
[17:38:37.282]                           }
[17:38:37.282]                           else {
[17:38:37.282]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:37.282]                               info, version)
[17:38:37.282]                           }
[17:38:37.282]                           base::stop(msg)
[17:38:37.282]                         }
[17:38:37.282]                       })
[17:38:37.282]                     }
[17:38:37.282]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:37.282]                     base::options(mc.cores = 1L)
[17:38:37.282]                   }
[17:38:37.282]                   ...future.strategy.old <- future::plan("list")
[17:38:37.282]                   options(future.plan = NULL)
[17:38:37.282]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:37.282]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:37.282]                 }
[17:38:37.282]                 ...future.workdir <- getwd()
[17:38:37.282]             }
[17:38:37.282]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:37.282]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:37.282]         }
[17:38:37.282]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:37.282]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:37.282]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:37.282]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:37.282]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:37.282]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:37.282]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:37.282]             base::names(...future.oldOptions))
[17:38:37.282]     }
[17:38:37.282]     if (FALSE) {
[17:38:37.282]     }
[17:38:37.282]     else {
[17:38:37.282]         if (TRUE) {
[17:38:37.282]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:37.282]                 open = "w")
[17:38:37.282]         }
[17:38:37.282]         else {
[17:38:37.282]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:37.282]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:37.282]         }
[17:38:37.282]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:37.282]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:37.282]             base::sink(type = "output", split = FALSE)
[17:38:37.282]             base::close(...future.stdout)
[17:38:37.282]         }, add = TRUE)
[17:38:37.282]     }
[17:38:37.282]     ...future.frame <- base::sys.nframe()
[17:38:37.282]     ...future.conditions <- base::list()
[17:38:37.282]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:37.282]     if (FALSE) {
[17:38:37.282]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:37.282]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:37.282]     }
[17:38:37.282]     ...future.result <- base::tryCatch({
[17:38:37.282]         base::withCallingHandlers({
[17:38:37.282]             ...future.value <- base::withVisible(base::local({
[17:38:37.282]                 ...future.makeSendCondition <- base::local({
[17:38:37.282]                   sendCondition <- NULL
[17:38:37.282]                   function(frame = 1L) {
[17:38:37.282]                     if (is.function(sendCondition)) 
[17:38:37.282]                       return(sendCondition)
[17:38:37.282]                     ns <- getNamespace("parallel")
[17:38:37.282]                     if (exists("sendData", mode = "function", 
[17:38:37.282]                       envir = ns)) {
[17:38:37.282]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:37.282]                         envir = ns)
[17:38:37.282]                       envir <- sys.frame(frame)
[17:38:37.282]                       master <- NULL
[17:38:37.282]                       while (!identical(envir, .GlobalEnv) && 
[17:38:37.282]                         !identical(envir, emptyenv())) {
[17:38:37.282]                         if (exists("master", mode = "list", envir = envir, 
[17:38:37.282]                           inherits = FALSE)) {
[17:38:37.282]                           master <- get("master", mode = "list", 
[17:38:37.282]                             envir = envir, inherits = FALSE)
[17:38:37.282]                           if (inherits(master, c("SOCKnode", 
[17:38:37.282]                             "SOCK0node"))) {
[17:38:37.282]                             sendCondition <<- function(cond) {
[17:38:37.282]                               data <- list(type = "VALUE", value = cond, 
[17:38:37.282]                                 success = TRUE)
[17:38:37.282]                               parallel_sendData(master, data)
[17:38:37.282]                             }
[17:38:37.282]                             return(sendCondition)
[17:38:37.282]                           }
[17:38:37.282]                         }
[17:38:37.282]                         frame <- frame + 1L
[17:38:37.282]                         envir <- sys.frame(frame)
[17:38:37.282]                       }
[17:38:37.282]                     }
[17:38:37.282]                     sendCondition <<- function(cond) NULL
[17:38:37.282]                   }
[17:38:37.282]                 })
[17:38:37.282]                 withCallingHandlers({
[17:38:37.282]                   {
[17:38:37.282]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:37.282]                     if (!identical(...future.globals.maxSize.org, 
[17:38:37.282]                       ...future.globals.maxSize)) {
[17:38:37.282]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:37.282]                       on.exit(options(oopts), add = TRUE)
[17:38:37.282]                     }
[17:38:37.282]                     {
[17:38:37.282]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:37.282]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:38:37.282]                         USE.NAMES = FALSE)
[17:38:37.282]                       do.call(mapply, args = args)
[17:38:37.282]                     }
[17:38:37.282]                   }
[17:38:37.282]                 }, immediateCondition = function(cond) {
[17:38:37.282]                   sendCondition <- ...future.makeSendCondition()
[17:38:37.282]                   sendCondition(cond)
[17:38:37.282]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:37.282]                   {
[17:38:37.282]                     inherits <- base::inherits
[17:38:37.282]                     invokeRestart <- base::invokeRestart
[17:38:37.282]                     is.null <- base::is.null
[17:38:37.282]                     muffled <- FALSE
[17:38:37.282]                     if (inherits(cond, "message")) {
[17:38:37.282]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:37.282]                       if (muffled) 
[17:38:37.282]                         invokeRestart("muffleMessage")
[17:38:37.282]                     }
[17:38:37.282]                     else if (inherits(cond, "warning")) {
[17:38:37.282]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:37.282]                       if (muffled) 
[17:38:37.282]                         invokeRestart("muffleWarning")
[17:38:37.282]                     }
[17:38:37.282]                     else if (inherits(cond, "condition")) {
[17:38:37.282]                       if (!is.null(pattern)) {
[17:38:37.282]                         computeRestarts <- base::computeRestarts
[17:38:37.282]                         grepl <- base::grepl
[17:38:37.282]                         restarts <- computeRestarts(cond)
[17:38:37.282]                         for (restart in restarts) {
[17:38:37.282]                           name <- restart$name
[17:38:37.282]                           if (is.null(name)) 
[17:38:37.282]                             next
[17:38:37.282]                           if (!grepl(pattern, name)) 
[17:38:37.282]                             next
[17:38:37.282]                           invokeRestart(restart)
[17:38:37.282]                           muffled <- TRUE
[17:38:37.282]                           break
[17:38:37.282]                         }
[17:38:37.282]                       }
[17:38:37.282]                     }
[17:38:37.282]                     invisible(muffled)
[17:38:37.282]                   }
[17:38:37.282]                   muffleCondition(cond)
[17:38:37.282]                 })
[17:38:37.282]             }))
[17:38:37.282]             future::FutureResult(value = ...future.value$value, 
[17:38:37.282]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:37.282]                   ...future.rng), globalenv = if (FALSE) 
[17:38:37.282]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:37.282]                     ...future.globalenv.names))
[17:38:37.282]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:37.282]         }, condition = base::local({
[17:38:37.282]             c <- base::c
[17:38:37.282]             inherits <- base::inherits
[17:38:37.282]             invokeRestart <- base::invokeRestart
[17:38:37.282]             length <- base::length
[17:38:37.282]             list <- base::list
[17:38:37.282]             seq.int <- base::seq.int
[17:38:37.282]             signalCondition <- base::signalCondition
[17:38:37.282]             sys.calls <- base::sys.calls
[17:38:37.282]             `[[` <- base::`[[`
[17:38:37.282]             `+` <- base::`+`
[17:38:37.282]             `<<-` <- base::`<<-`
[17:38:37.282]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:37.282]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:37.282]                   3L)]
[17:38:37.282]             }
[17:38:37.282]             function(cond) {
[17:38:37.282]                 is_error <- inherits(cond, "error")
[17:38:37.282]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:37.282]                   NULL)
[17:38:37.282]                 if (is_error) {
[17:38:37.282]                   sessionInformation <- function() {
[17:38:37.282]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:37.282]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:37.282]                       search = base::search(), system = base::Sys.info())
[17:38:37.282]                   }
[17:38:37.282]                   ...future.conditions[[length(...future.conditions) + 
[17:38:37.282]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:37.282]                     cond$call), session = sessionInformation(), 
[17:38:37.282]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:37.282]                   signalCondition(cond)
[17:38:37.282]                 }
[17:38:37.282]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:37.282]                 "immediateCondition"))) {
[17:38:37.282]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:37.282]                   ...future.conditions[[length(...future.conditions) + 
[17:38:37.282]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:37.282]                   if (TRUE && !signal) {
[17:38:37.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:37.282]                     {
[17:38:37.282]                       inherits <- base::inherits
[17:38:37.282]                       invokeRestart <- base::invokeRestart
[17:38:37.282]                       is.null <- base::is.null
[17:38:37.282]                       muffled <- FALSE
[17:38:37.282]                       if (inherits(cond, "message")) {
[17:38:37.282]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:37.282]                         if (muffled) 
[17:38:37.282]                           invokeRestart("muffleMessage")
[17:38:37.282]                       }
[17:38:37.282]                       else if (inherits(cond, "warning")) {
[17:38:37.282]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:37.282]                         if (muffled) 
[17:38:37.282]                           invokeRestart("muffleWarning")
[17:38:37.282]                       }
[17:38:37.282]                       else if (inherits(cond, "condition")) {
[17:38:37.282]                         if (!is.null(pattern)) {
[17:38:37.282]                           computeRestarts <- base::computeRestarts
[17:38:37.282]                           grepl <- base::grepl
[17:38:37.282]                           restarts <- computeRestarts(cond)
[17:38:37.282]                           for (restart in restarts) {
[17:38:37.282]                             name <- restart$name
[17:38:37.282]                             if (is.null(name)) 
[17:38:37.282]                               next
[17:38:37.282]                             if (!grepl(pattern, name)) 
[17:38:37.282]                               next
[17:38:37.282]                             invokeRestart(restart)
[17:38:37.282]                             muffled <- TRUE
[17:38:37.282]                             break
[17:38:37.282]                           }
[17:38:37.282]                         }
[17:38:37.282]                       }
[17:38:37.282]                       invisible(muffled)
[17:38:37.282]                     }
[17:38:37.282]                     muffleCondition(cond, pattern = "^muffle")
[17:38:37.282]                   }
[17:38:37.282]                 }
[17:38:37.282]                 else {
[17:38:37.282]                   if (TRUE) {
[17:38:37.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:37.282]                     {
[17:38:37.282]                       inherits <- base::inherits
[17:38:37.282]                       invokeRestart <- base::invokeRestart
[17:38:37.282]                       is.null <- base::is.null
[17:38:37.282]                       muffled <- FALSE
[17:38:37.282]                       if (inherits(cond, "message")) {
[17:38:37.282]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:37.282]                         if (muffled) 
[17:38:37.282]                           invokeRestart("muffleMessage")
[17:38:37.282]                       }
[17:38:37.282]                       else if (inherits(cond, "warning")) {
[17:38:37.282]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:37.282]                         if (muffled) 
[17:38:37.282]                           invokeRestart("muffleWarning")
[17:38:37.282]                       }
[17:38:37.282]                       else if (inherits(cond, "condition")) {
[17:38:37.282]                         if (!is.null(pattern)) {
[17:38:37.282]                           computeRestarts <- base::computeRestarts
[17:38:37.282]                           grepl <- base::grepl
[17:38:37.282]                           restarts <- computeRestarts(cond)
[17:38:37.282]                           for (restart in restarts) {
[17:38:37.282]                             name <- restart$name
[17:38:37.282]                             if (is.null(name)) 
[17:38:37.282]                               next
[17:38:37.282]                             if (!grepl(pattern, name)) 
[17:38:37.282]                               next
[17:38:37.282]                             invokeRestart(restart)
[17:38:37.282]                             muffled <- TRUE
[17:38:37.282]                             break
[17:38:37.282]                           }
[17:38:37.282]                         }
[17:38:37.282]                       }
[17:38:37.282]                       invisible(muffled)
[17:38:37.282]                     }
[17:38:37.282]                     muffleCondition(cond, pattern = "^muffle")
[17:38:37.282]                   }
[17:38:37.282]                 }
[17:38:37.282]             }
[17:38:37.282]         }))
[17:38:37.282]     }, error = function(ex) {
[17:38:37.282]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:37.282]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:37.282]                 ...future.rng), started = ...future.startTime, 
[17:38:37.282]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:37.282]             version = "1.8"), class = "FutureResult")
[17:38:37.282]     }, finally = {
[17:38:37.282]         if (!identical(...future.workdir, getwd())) 
[17:38:37.282]             setwd(...future.workdir)
[17:38:37.282]         {
[17:38:37.282]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:37.282]                 ...future.oldOptions$nwarnings <- NULL
[17:38:37.282]             }
[17:38:37.282]             base::options(...future.oldOptions)
[17:38:37.282]             if (.Platform$OS.type == "windows") {
[17:38:37.282]                 old_names <- names(...future.oldEnvVars)
[17:38:37.282]                 envs <- base::Sys.getenv()
[17:38:37.282]                 names <- names(envs)
[17:38:37.282]                 common <- intersect(names, old_names)
[17:38:37.282]                 added <- setdiff(names, old_names)
[17:38:37.282]                 removed <- setdiff(old_names, names)
[17:38:37.282]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:37.282]                   envs[common]]
[17:38:37.282]                 NAMES <- toupper(changed)
[17:38:37.282]                 args <- list()
[17:38:37.282]                 for (kk in seq_along(NAMES)) {
[17:38:37.282]                   name <- changed[[kk]]
[17:38:37.282]                   NAME <- NAMES[[kk]]
[17:38:37.282]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:37.282]                     next
[17:38:37.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:37.282]                 }
[17:38:37.282]                 NAMES <- toupper(added)
[17:38:37.282]                 for (kk in seq_along(NAMES)) {
[17:38:37.282]                   name <- added[[kk]]
[17:38:37.282]                   NAME <- NAMES[[kk]]
[17:38:37.282]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:37.282]                     next
[17:38:37.282]                   args[[name]] <- ""
[17:38:37.282]                 }
[17:38:37.282]                 NAMES <- toupper(removed)
[17:38:37.282]                 for (kk in seq_along(NAMES)) {
[17:38:37.282]                   name <- removed[[kk]]
[17:38:37.282]                   NAME <- NAMES[[kk]]
[17:38:37.282]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:37.282]                     next
[17:38:37.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:37.282]                 }
[17:38:37.282]                 if (length(args) > 0) 
[17:38:37.282]                   base::do.call(base::Sys.setenv, args = args)
[17:38:37.282]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:37.282]             }
[17:38:37.282]             else {
[17:38:37.282]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:37.282]             }
[17:38:37.282]             {
[17:38:37.282]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:37.282]                   0L) {
[17:38:37.282]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:37.282]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:37.282]                   base::options(opts)
[17:38:37.282]                 }
[17:38:37.282]                 {
[17:38:37.282]                   {
[17:38:37.282]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:37.282]                     NULL
[17:38:37.282]                   }
[17:38:37.282]                   options(future.plan = NULL)
[17:38:37.282]                   if (is.na(NA_character_)) 
[17:38:37.282]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:37.282]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:37.282]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:37.282]                     .init = FALSE)
[17:38:37.282]                 }
[17:38:37.282]             }
[17:38:37.282]         }
[17:38:37.282]     })
[17:38:37.282]     if (TRUE) {
[17:38:37.282]         base::sink(type = "output", split = FALSE)
[17:38:37.282]         if (TRUE) {
[17:38:37.282]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:37.282]         }
[17:38:37.282]         else {
[17:38:37.282]             ...future.result["stdout"] <- base::list(NULL)
[17:38:37.282]         }
[17:38:37.282]         base::close(...future.stdout)
[17:38:37.282]         ...future.stdout <- NULL
[17:38:37.282]     }
[17:38:37.282]     ...future.result$conditions <- ...future.conditions
[17:38:37.282]     ...future.result$finished <- base::Sys.time()
[17:38:37.282]     ...future.result
[17:38:37.282] }
[17:38:37.285] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[17:38:37.285] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[17:38:37.286] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[17:38:37.286] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:38:37.286] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:38:37.286] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:38:37.287] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:38:37.287] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:38:37.287] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:38:37.287] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:38:37.287] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:38:37.288] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[17:38:37.288] MultisessionFuture started
[17:38:37.288] - Launch lazy future ... done
[17:38:37.288] run() for ‘MultisessionFuture’ ... done
[17:38:37.289] Created future:
[17:38:37.289] MultisessionFuture:
[17:38:37.289] Label: ‘future_mapply-2’
[17:38:37.289] Expression:
[17:38:37.289] {
[17:38:37.289]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:37.289]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:37.289]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:37.289]         on.exit(options(oopts), add = TRUE)
[17:38:37.289]     }
[17:38:37.289]     {
[17:38:37.289]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:37.289]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:38:37.289]         do.call(mapply, args = args)
[17:38:37.289]     }
[17:38:37.289] }
[17:38:37.289] Lazy evaluation: FALSE
[17:38:37.289] Asynchronous evaluation: TRUE
[17:38:37.289] Local evaluation: TRUE
[17:38:37.289] Environment: R_GlobalEnv
[17:38:37.289] Capture standard output: TRUE
[17:38:37.289] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:37.289] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:37.289] Packages: <none>
[17:38:37.289] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:37.289] Resolved: FALSE
[17:38:37.289] Value: <not collected>
[17:38:37.289] Conditions captured: <none>
[17:38:37.289] Early signaling: FALSE
[17:38:37.289] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:37.289] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:37.300] Chunk #2 of 2 ... DONE
[17:38:37.300] Launching 2 futures (chunks) ... DONE
[17:38:37.300] Resolving 2 futures (chunks) ...
[17:38:37.300] resolve() on list ...
[17:38:37.300]  recursive: 0
[17:38:37.301]  length: 2
[17:38:37.301] 
[17:38:37.342] receiveMessageFromWorker() for ClusterFuture ...
[17:38:37.343] - Validating connection of MultisessionFuture
[17:38:37.343] - received message: FutureResult
[17:38:37.343] - Received FutureResult
[17:38:37.343] - Erased future from FutureRegistry
[17:38:37.343] result() for ClusterFuture ...
[17:38:37.343] - result already collected: FutureResult
[17:38:37.343] result() for ClusterFuture ... done
[17:38:37.344] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:37.344] Future #2
[17:38:37.344] result() for ClusterFuture ...
[17:38:37.344] - result already collected: FutureResult
[17:38:37.344] result() for ClusterFuture ... done
[17:38:37.344] result() for ClusterFuture ...
[17:38:37.344] - result already collected: FutureResult
[17:38:37.344] result() for ClusterFuture ... done
[17:38:37.344] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:38:37.344] - nx: 2
[17:38:37.344] - relay: TRUE
[17:38:37.345] - stdout: TRUE
[17:38:37.345] - signal: TRUE
[17:38:37.345] - resignal: FALSE
[17:38:37.345] - force: TRUE
[17:38:37.345] - relayed: [n=2] FALSE, FALSE
[17:38:37.345] - queued futures: [n=2] FALSE, FALSE
[17:38:37.345]  - until=1
[17:38:37.345]  - relaying element #1
[17:38:37.345] - relayed: [n=2] FALSE, FALSE
[17:38:37.345] - queued futures: [n=2] FALSE, TRUE
[17:38:37.345] signalConditionsASAP(NULL, pos=2) ... done
[17:38:37.345]  length: 1 (resolved future 2)
[17:38:37.791] receiveMessageFromWorker() for ClusterFuture ...
[17:38:37.791] - Validating connection of MultisessionFuture
[17:38:37.791] - received message: FutureResult
[17:38:37.791] - Received FutureResult
[17:38:37.791] - Erased future from FutureRegistry
[17:38:37.792] result() for ClusterFuture ...
[17:38:37.792] - result already collected: FutureResult
[17:38:37.792] result() for ClusterFuture ... done
[17:38:37.792] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:37.792] Future #1
[17:38:37.792] result() for ClusterFuture ...
[17:38:37.792] - result already collected: FutureResult
[17:38:37.792] result() for ClusterFuture ... done
[17:38:37.792] result() for ClusterFuture ...
[17:38:37.793] - result already collected: FutureResult
[17:38:37.793] result() for ClusterFuture ... done
[17:38:37.793] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:38:37.793] - nx: 2
[17:38:37.793] - relay: TRUE
[17:38:37.793] - stdout: TRUE
[17:38:37.793] - signal: TRUE
[17:38:37.793] - resignal: FALSE
[17:38:37.793] - force: TRUE
[17:38:37.794] - relayed: [n=2] FALSE, FALSE
[17:38:37.794] - queued futures: [n=2] FALSE, TRUE
[17:38:37.794]  - until=1
[17:38:37.794]  - relaying element #1
[17:38:37.794] result() for ClusterFuture ...
[17:38:37.794] - result already collected: FutureResult
[17:38:37.794] result() for ClusterFuture ... done
[17:38:37.794] result() for ClusterFuture ...
[17:38:37.795] - result already collected: FutureResult
[17:38:37.795] result() for ClusterFuture ... done
[17:38:37.795] result() for ClusterFuture ...
[17:38:37.795] - result already collected: FutureResult
[17:38:37.795] result() for ClusterFuture ... done
[17:38:37.795] result() for ClusterFuture ...
[17:38:37.795] - result already collected: FutureResult
[17:38:37.795] result() for ClusterFuture ... done
[17:38:37.795] - relayed: [n=2] TRUE, FALSE
[17:38:37.795] - queued futures: [n=2] TRUE, TRUE
[17:38:37.796] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:38:37.796]  length: 0 (resolved future 1)
[17:38:37.796] Relaying remaining futures
[17:38:37.796] signalConditionsASAP(NULL, pos=0) ...
[17:38:37.796] - nx: 2
[17:38:37.796] - relay: TRUE
[17:38:37.796] - stdout: TRUE
[17:38:37.796] - signal: TRUE
[17:38:37.796] - resignal: FALSE
[17:38:37.796] - force: TRUE
[17:38:37.797] - relayed: [n=2] TRUE, FALSE
[17:38:37.797] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:37.797]  - relaying element #2
[17:38:37.797] result() for ClusterFuture ...
[17:38:37.797] - result already collected: FutureResult
[17:38:37.797] result() for ClusterFuture ... done
[17:38:37.797] result() for ClusterFuture ...
[17:38:37.797] - result already collected: FutureResult
[17:38:37.797] result() for ClusterFuture ... done
[17:38:37.797] result() for ClusterFuture ...
[17:38:37.798] - result already collected: FutureResult
[17:38:37.798] result() for ClusterFuture ... done
[17:38:37.798] result() for ClusterFuture ...
[17:38:37.798] - result already collected: FutureResult
[17:38:37.798] result() for ClusterFuture ... done
[17:38:37.798] - relayed: [n=2] TRUE, TRUE
[17:38:37.798] - queued futures: [n=2] TRUE, TRUE
[17:38:37.798] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:38:37.798] resolve() on list ... DONE
[17:38:37.798] result() for ClusterFuture ...
[17:38:37.798] - result already collected: FutureResult
[17:38:37.799] result() for ClusterFuture ... done
[17:38:37.799] result() for ClusterFuture ...
[17:38:37.799] - result already collected: FutureResult
[17:38:37.799] result() for ClusterFuture ... done
[17:38:37.799] result() for ClusterFuture ...
[17:38:37.799] - result already collected: FutureResult
[17:38:37.799] result() for ClusterFuture ... done
[17:38:37.799] result() for ClusterFuture ...
[17:38:37.799] - result already collected: FutureResult
[17:38:37.799] result() for ClusterFuture ... done
[17:38:37.799]  - Number of value chunks collected: 2
[17:38:37.799] Resolving 2 futures (chunks) ... DONE
[17:38:37.800] Reducing values from 2 chunks ...
[17:38:37.800]  - Number of values collected after concatenation: 2
[17:38:37.800]  - Number of values expected: 2
[17:38:37.800] Reducing values from 2 chunks ... DONE
[17:38:37.800] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[17:38:37.800] future_mapply() ...
[17:38:37.804] Number of chunks: 2
[17:38:37.804] getGlobalsAndPackagesXApply() ...
[17:38:37.804]  - future.globals: TRUE
[17:38:37.805] getGlobalsAndPackages() ...
[17:38:37.805] Searching for globals...
[17:38:37.806] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:38:37.806] Searching for globals ... DONE
[17:38:37.807] Resolving globals: FALSE
[17:38:37.807] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:38:37.807] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:38:37.807] - globals: [1] ‘FUN’
[17:38:37.808] 
[17:38:37.808] getGlobalsAndPackages() ... DONE
[17:38:37.808]  - globals found/used: [n=1] ‘FUN’
[17:38:37.808]  - needed namespaces: [n=0] 
[17:38:37.808] Finding globals ... DONE
[17:38:37.808] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:38:37.808] List of 2
[17:38:37.808]  $ ...future.FUN:function (x, y)  
[17:38:37.808]  $ MoreArgs     : NULL
[17:38:37.808]  - attr(*, "where")=List of 2
[17:38:37.808]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:37.808]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:38:37.808]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:37.808]  - attr(*, "resolved")= logi FALSE
[17:38:37.808]  - attr(*, "total_size")= num NA
[17:38:37.811] Packages to be attached in all futures: [n=0] 
[17:38:37.811] getGlobalsAndPackagesXApply() ... DONE
[17:38:37.811] Number of futures (= number of chunks): 2
[17:38:37.811] Launching 2 futures (chunks) ...
[17:38:37.811] Chunk #1 of 2 ...
[17:38:37.811]  - Finding globals in '...' for chunk #1 ...
[17:38:37.811] getGlobalsAndPackages() ...
[17:38:37.811] Searching for globals...
[17:38:37.812] 
[17:38:37.812] Searching for globals ... DONE
[17:38:37.812] - globals: [0] <none>
[17:38:37.812] getGlobalsAndPackages() ... DONE
[17:38:37.812]    + additional globals found: [n=0] 
[17:38:37.812]    + additional namespaces needed: [n=0] 
[17:38:37.812]  - Finding globals in '...' for chunk #1 ... DONE
[17:38:37.812]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:37.812]  - seeds: <none>
[17:38:37.813]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:37.813] getGlobalsAndPackages() ...
[17:38:37.813] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:37.813] Resolving globals: FALSE
[17:38:37.813] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:38:37.814] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:38:37.814] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:37.814] 
[17:38:37.814] getGlobalsAndPackages() ... DONE
[17:38:37.814] run() for ‘Future’ ...
[17:38:37.814] - state: ‘created’
[17:38:37.815] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:37.828] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:37.828] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:37.828]   - Field: ‘node’
[17:38:37.829]   - Field: ‘label’
[17:38:37.829]   - Field: ‘local’
[17:38:37.829]   - Field: ‘owner’
[17:38:37.829]   - Field: ‘envir’
[17:38:37.829]   - Field: ‘workers’
[17:38:37.829]   - Field: ‘packages’
[17:38:37.829]   - Field: ‘gc’
[17:38:37.829]   - Field: ‘conditions’
[17:38:37.829]   - Field: ‘persistent’
[17:38:37.829]   - Field: ‘expr’
[17:38:37.829]   - Field: ‘uuid’
[17:38:37.830]   - Field: ‘seed’
[17:38:37.830]   - Field: ‘version’
[17:38:37.830]   - Field: ‘result’
[17:38:37.830]   - Field: ‘asynchronous’
[17:38:37.830]   - Field: ‘calls’
[17:38:37.830]   - Field: ‘globals’
[17:38:37.830]   - Field: ‘stdout’
[17:38:37.830]   - Field: ‘earlySignal’
[17:38:37.830]   - Field: ‘lazy’
[17:38:37.830]   - Field: ‘state’
[17:38:37.830] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:37.831] - Launch lazy future ...
[17:38:37.831] Packages needed by the future expression (n = 0): <none>
[17:38:37.831] Packages needed by future strategies (n = 0): <none>
[17:38:37.831] {
[17:38:37.831]     {
[17:38:37.831]         {
[17:38:37.831]             ...future.startTime <- base::Sys.time()
[17:38:37.831]             {
[17:38:37.831]                 {
[17:38:37.831]                   {
[17:38:37.831]                     {
[17:38:37.831]                       base::local({
[17:38:37.831]                         has_future <- base::requireNamespace("future", 
[17:38:37.831]                           quietly = TRUE)
[17:38:37.831]                         if (has_future) {
[17:38:37.831]                           ns <- base::getNamespace("future")
[17:38:37.831]                           version <- ns[[".package"]][["version"]]
[17:38:37.831]                           if (is.null(version)) 
[17:38:37.831]                             version <- utils::packageVersion("future")
[17:38:37.831]                         }
[17:38:37.831]                         else {
[17:38:37.831]                           version <- NULL
[17:38:37.831]                         }
[17:38:37.831]                         if (!has_future || version < "1.8.0") {
[17:38:37.831]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:37.831]                             "", base::R.version$version.string), 
[17:38:37.831]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:37.831]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:37.831]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:37.831]                               "release", "version")], collapse = " "), 
[17:38:37.831]                             hostname = base::Sys.info()[["nodename"]])
[17:38:37.831]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:37.831]                             info)
[17:38:37.831]                           info <- base::paste(info, collapse = "; ")
[17:38:37.831]                           if (!has_future) {
[17:38:37.831]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:37.831]                               info)
[17:38:37.831]                           }
[17:38:37.831]                           else {
[17:38:37.831]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:37.831]                               info, version)
[17:38:37.831]                           }
[17:38:37.831]                           base::stop(msg)
[17:38:37.831]                         }
[17:38:37.831]                       })
[17:38:37.831]                     }
[17:38:37.831]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:37.831]                     base::options(mc.cores = 1L)
[17:38:37.831]                   }
[17:38:37.831]                   ...future.strategy.old <- future::plan("list")
[17:38:37.831]                   options(future.plan = NULL)
[17:38:37.831]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:37.831]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:37.831]                 }
[17:38:37.831]                 ...future.workdir <- getwd()
[17:38:37.831]             }
[17:38:37.831]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:37.831]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:37.831]         }
[17:38:37.831]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:37.831]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:37.831]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:37.831]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:37.831]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:37.831]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:37.831]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:37.831]             base::names(...future.oldOptions))
[17:38:37.831]     }
[17:38:37.831]     if (TRUE) {
[17:38:37.831]     }
[17:38:37.831]     else {
[17:38:37.831]         if (NA) {
[17:38:37.831]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:37.831]                 open = "w")
[17:38:37.831]         }
[17:38:37.831]         else {
[17:38:37.831]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:37.831]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:37.831]         }
[17:38:37.831]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:37.831]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:37.831]             base::sink(type = "output", split = FALSE)
[17:38:37.831]             base::close(...future.stdout)
[17:38:37.831]         }, add = TRUE)
[17:38:37.831]     }
[17:38:37.831]     ...future.frame <- base::sys.nframe()
[17:38:37.831]     ...future.conditions <- base::list()
[17:38:37.831]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:37.831]     if (FALSE) {
[17:38:37.831]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:37.831]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:37.831]     }
[17:38:37.831]     ...future.result <- base::tryCatch({
[17:38:37.831]         base::withCallingHandlers({
[17:38:37.831]             ...future.value <- base::withVisible(base::local({
[17:38:37.831]                 ...future.makeSendCondition <- base::local({
[17:38:37.831]                   sendCondition <- NULL
[17:38:37.831]                   function(frame = 1L) {
[17:38:37.831]                     if (is.function(sendCondition)) 
[17:38:37.831]                       return(sendCondition)
[17:38:37.831]                     ns <- getNamespace("parallel")
[17:38:37.831]                     if (exists("sendData", mode = "function", 
[17:38:37.831]                       envir = ns)) {
[17:38:37.831]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:37.831]                         envir = ns)
[17:38:37.831]                       envir <- sys.frame(frame)
[17:38:37.831]                       master <- NULL
[17:38:37.831]                       while (!identical(envir, .GlobalEnv) && 
[17:38:37.831]                         !identical(envir, emptyenv())) {
[17:38:37.831]                         if (exists("master", mode = "list", envir = envir, 
[17:38:37.831]                           inherits = FALSE)) {
[17:38:37.831]                           master <- get("master", mode = "list", 
[17:38:37.831]                             envir = envir, inherits = FALSE)
[17:38:37.831]                           if (inherits(master, c("SOCKnode", 
[17:38:37.831]                             "SOCK0node"))) {
[17:38:37.831]                             sendCondition <<- function(cond) {
[17:38:37.831]                               data <- list(type = "VALUE", value = cond, 
[17:38:37.831]                                 success = TRUE)
[17:38:37.831]                               parallel_sendData(master, data)
[17:38:37.831]                             }
[17:38:37.831]                             return(sendCondition)
[17:38:37.831]                           }
[17:38:37.831]                         }
[17:38:37.831]                         frame <- frame + 1L
[17:38:37.831]                         envir <- sys.frame(frame)
[17:38:37.831]                       }
[17:38:37.831]                     }
[17:38:37.831]                     sendCondition <<- function(cond) NULL
[17:38:37.831]                   }
[17:38:37.831]                 })
[17:38:37.831]                 withCallingHandlers({
[17:38:37.831]                   {
[17:38:37.831]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:37.831]                     if (!identical(...future.globals.maxSize.org, 
[17:38:37.831]                       ...future.globals.maxSize)) {
[17:38:37.831]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:37.831]                       on.exit(options(oopts), add = TRUE)
[17:38:37.831]                     }
[17:38:37.831]                     {
[17:38:37.831]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:37.831]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:38:37.831]                         USE.NAMES = FALSE)
[17:38:37.831]                       do.call(mapply, args = args)
[17:38:37.831]                     }
[17:38:37.831]                   }
[17:38:37.831]                 }, immediateCondition = function(cond) {
[17:38:37.831]                   sendCondition <- ...future.makeSendCondition()
[17:38:37.831]                   sendCondition(cond)
[17:38:37.831]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:37.831]                   {
[17:38:37.831]                     inherits <- base::inherits
[17:38:37.831]                     invokeRestart <- base::invokeRestart
[17:38:37.831]                     is.null <- base::is.null
[17:38:37.831]                     muffled <- FALSE
[17:38:37.831]                     if (inherits(cond, "message")) {
[17:38:37.831]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:37.831]                       if (muffled) 
[17:38:37.831]                         invokeRestart("muffleMessage")
[17:38:37.831]                     }
[17:38:37.831]                     else if (inherits(cond, "warning")) {
[17:38:37.831]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:37.831]                       if (muffled) 
[17:38:37.831]                         invokeRestart("muffleWarning")
[17:38:37.831]                     }
[17:38:37.831]                     else if (inherits(cond, "condition")) {
[17:38:37.831]                       if (!is.null(pattern)) {
[17:38:37.831]                         computeRestarts <- base::computeRestarts
[17:38:37.831]                         grepl <- base::grepl
[17:38:37.831]                         restarts <- computeRestarts(cond)
[17:38:37.831]                         for (restart in restarts) {
[17:38:37.831]                           name <- restart$name
[17:38:37.831]                           if (is.null(name)) 
[17:38:37.831]                             next
[17:38:37.831]                           if (!grepl(pattern, name)) 
[17:38:37.831]                             next
[17:38:37.831]                           invokeRestart(restart)
[17:38:37.831]                           muffled <- TRUE
[17:38:37.831]                           break
[17:38:37.831]                         }
[17:38:37.831]                       }
[17:38:37.831]                     }
[17:38:37.831]                     invisible(muffled)
[17:38:37.831]                   }
[17:38:37.831]                   muffleCondition(cond)
[17:38:37.831]                 })
[17:38:37.831]             }))
[17:38:37.831]             future::FutureResult(value = ...future.value$value, 
[17:38:37.831]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:37.831]                   ...future.rng), globalenv = if (FALSE) 
[17:38:37.831]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:37.831]                     ...future.globalenv.names))
[17:38:37.831]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:37.831]         }, condition = base::local({
[17:38:37.831]             c <- base::c
[17:38:37.831]             inherits <- base::inherits
[17:38:37.831]             invokeRestart <- base::invokeRestart
[17:38:37.831]             length <- base::length
[17:38:37.831]             list <- base::list
[17:38:37.831]             seq.int <- base::seq.int
[17:38:37.831]             signalCondition <- base::signalCondition
[17:38:37.831]             sys.calls <- base::sys.calls
[17:38:37.831]             `[[` <- base::`[[`
[17:38:37.831]             `+` <- base::`+`
[17:38:37.831]             `<<-` <- base::`<<-`
[17:38:37.831]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:37.831]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:37.831]                   3L)]
[17:38:37.831]             }
[17:38:37.831]             function(cond) {
[17:38:37.831]                 is_error <- inherits(cond, "error")
[17:38:37.831]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:37.831]                   NULL)
[17:38:37.831]                 if (is_error) {
[17:38:37.831]                   sessionInformation <- function() {
[17:38:37.831]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:37.831]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:37.831]                       search = base::search(), system = base::Sys.info())
[17:38:37.831]                   }
[17:38:37.831]                   ...future.conditions[[length(...future.conditions) + 
[17:38:37.831]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:37.831]                     cond$call), session = sessionInformation(), 
[17:38:37.831]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:37.831]                   signalCondition(cond)
[17:38:37.831]                 }
[17:38:37.831]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:37.831]                 "immediateCondition"))) {
[17:38:37.831]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:37.831]                   ...future.conditions[[length(...future.conditions) + 
[17:38:37.831]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:37.831]                   if (TRUE && !signal) {
[17:38:37.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:37.831]                     {
[17:38:37.831]                       inherits <- base::inherits
[17:38:37.831]                       invokeRestart <- base::invokeRestart
[17:38:37.831]                       is.null <- base::is.null
[17:38:37.831]                       muffled <- FALSE
[17:38:37.831]                       if (inherits(cond, "message")) {
[17:38:37.831]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:37.831]                         if (muffled) 
[17:38:37.831]                           invokeRestart("muffleMessage")
[17:38:37.831]                       }
[17:38:37.831]                       else if (inherits(cond, "warning")) {
[17:38:37.831]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:37.831]                         if (muffled) 
[17:38:37.831]                           invokeRestart("muffleWarning")
[17:38:37.831]                       }
[17:38:37.831]                       else if (inherits(cond, "condition")) {
[17:38:37.831]                         if (!is.null(pattern)) {
[17:38:37.831]                           computeRestarts <- base::computeRestarts
[17:38:37.831]                           grepl <- base::grepl
[17:38:37.831]                           restarts <- computeRestarts(cond)
[17:38:37.831]                           for (restart in restarts) {
[17:38:37.831]                             name <- restart$name
[17:38:37.831]                             if (is.null(name)) 
[17:38:37.831]                               next
[17:38:37.831]                             if (!grepl(pattern, name)) 
[17:38:37.831]                               next
[17:38:37.831]                             invokeRestart(restart)
[17:38:37.831]                             muffled <- TRUE
[17:38:37.831]                             break
[17:38:37.831]                           }
[17:38:37.831]                         }
[17:38:37.831]                       }
[17:38:37.831]                       invisible(muffled)
[17:38:37.831]                     }
[17:38:37.831]                     muffleCondition(cond, pattern = "^muffle")
[17:38:37.831]                   }
[17:38:37.831]                 }
[17:38:37.831]                 else {
[17:38:37.831]                   if (TRUE) {
[17:38:37.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:37.831]                     {
[17:38:37.831]                       inherits <- base::inherits
[17:38:37.831]                       invokeRestart <- base::invokeRestart
[17:38:37.831]                       is.null <- base::is.null
[17:38:37.831]                       muffled <- FALSE
[17:38:37.831]                       if (inherits(cond, "message")) {
[17:38:37.831]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:37.831]                         if (muffled) 
[17:38:37.831]                           invokeRestart("muffleMessage")
[17:38:37.831]                       }
[17:38:37.831]                       else if (inherits(cond, "warning")) {
[17:38:37.831]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:37.831]                         if (muffled) 
[17:38:37.831]                           invokeRestart("muffleWarning")
[17:38:37.831]                       }
[17:38:37.831]                       else if (inherits(cond, "condition")) {
[17:38:37.831]                         if (!is.null(pattern)) {
[17:38:37.831]                           computeRestarts <- base::computeRestarts
[17:38:37.831]                           grepl <- base::grepl
[17:38:37.831]                           restarts <- computeRestarts(cond)
[17:38:37.831]                           for (restart in restarts) {
[17:38:37.831]                             name <- restart$name
[17:38:37.831]                             if (is.null(name)) 
[17:38:37.831]                               next
[17:38:37.831]                             if (!grepl(pattern, name)) 
[17:38:37.831]                               next
[17:38:37.831]                             invokeRestart(restart)
[17:38:37.831]                             muffled <- TRUE
[17:38:37.831]                             break
[17:38:37.831]                           }
[17:38:37.831]                         }
[17:38:37.831]                       }
[17:38:37.831]                       invisible(muffled)
[17:38:37.831]                     }
[17:38:37.831]                     muffleCondition(cond, pattern = "^muffle")
[17:38:37.831]                   }
[17:38:37.831]                 }
[17:38:37.831]             }
[17:38:37.831]         }))
[17:38:37.831]     }, error = function(ex) {
[17:38:37.831]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:37.831]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:37.831]                 ...future.rng), started = ...future.startTime, 
[17:38:37.831]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:37.831]             version = "1.8"), class = "FutureResult")
[17:38:37.831]     }, finally = {
[17:38:37.831]         if (!identical(...future.workdir, getwd())) 
[17:38:37.831]             setwd(...future.workdir)
[17:38:37.831]         {
[17:38:37.831]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:37.831]                 ...future.oldOptions$nwarnings <- NULL
[17:38:37.831]             }
[17:38:37.831]             base::options(...future.oldOptions)
[17:38:37.831]             if (.Platform$OS.type == "windows") {
[17:38:37.831]                 old_names <- names(...future.oldEnvVars)
[17:38:37.831]                 envs <- base::Sys.getenv()
[17:38:37.831]                 names <- names(envs)
[17:38:37.831]                 common <- intersect(names, old_names)
[17:38:37.831]                 added <- setdiff(names, old_names)
[17:38:37.831]                 removed <- setdiff(old_names, names)
[17:38:37.831]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:37.831]                   envs[common]]
[17:38:37.831]                 NAMES <- toupper(changed)
[17:38:37.831]                 args <- list()
[17:38:37.831]                 for (kk in seq_along(NAMES)) {
[17:38:37.831]                   name <- changed[[kk]]
[17:38:37.831]                   NAME <- NAMES[[kk]]
[17:38:37.831]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:37.831]                     next
[17:38:37.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:37.831]                 }
[17:38:37.831]                 NAMES <- toupper(added)
[17:38:37.831]                 for (kk in seq_along(NAMES)) {
[17:38:37.831]                   name <- added[[kk]]
[17:38:37.831]                   NAME <- NAMES[[kk]]
[17:38:37.831]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:37.831]                     next
[17:38:37.831]                   args[[name]] <- ""
[17:38:37.831]                 }
[17:38:37.831]                 NAMES <- toupper(removed)
[17:38:37.831]                 for (kk in seq_along(NAMES)) {
[17:38:37.831]                   name <- removed[[kk]]
[17:38:37.831]                   NAME <- NAMES[[kk]]
[17:38:37.831]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:37.831]                     next
[17:38:37.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:37.831]                 }
[17:38:37.831]                 if (length(args) > 0) 
[17:38:37.831]                   base::do.call(base::Sys.setenv, args = args)
[17:38:37.831]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:37.831]             }
[17:38:37.831]             else {
[17:38:37.831]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:37.831]             }
[17:38:37.831]             {
[17:38:37.831]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:37.831]                   0L) {
[17:38:37.831]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:37.831]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:37.831]                   base::options(opts)
[17:38:37.831]                 }
[17:38:37.831]                 {
[17:38:37.831]                   {
[17:38:37.831]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:37.831]                     NULL
[17:38:37.831]                   }
[17:38:37.831]                   options(future.plan = NULL)
[17:38:37.831]                   if (is.na(NA_character_)) 
[17:38:37.831]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:37.831]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:37.831]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:37.831]                     .init = FALSE)
[17:38:37.831]                 }
[17:38:37.831]             }
[17:38:37.831]         }
[17:38:37.831]     })
[17:38:37.831]     if (FALSE) {
[17:38:37.831]         base::sink(type = "output", split = FALSE)
[17:38:37.831]         if (NA) {
[17:38:37.831]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:37.831]         }
[17:38:37.831]         else {
[17:38:37.831]             ...future.result["stdout"] <- base::list(NULL)
[17:38:37.831]         }
[17:38:37.831]         base::close(...future.stdout)
[17:38:37.831]         ...future.stdout <- NULL
[17:38:37.831]     }
[17:38:37.831]     ...future.result$conditions <- ...future.conditions
[17:38:37.831]     ...future.result$finished <- base::Sys.time()
[17:38:37.831]     ...future.result
[17:38:37.831] }
[17:38:37.834] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[17:38:37.834] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[17:38:37.834] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[17:38:37.835] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:38:37.835] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:38:37.835] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:38:37.835] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:38:37.835] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:38:37.836] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:38:37.836] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:38:37.836] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:38:37.836] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[17:38:37.837] MultisessionFuture started
[17:38:37.837] - Launch lazy future ... done
[17:38:37.837] run() for ‘MultisessionFuture’ ... done
[17:38:37.837] Created future:
[17:38:37.837] MultisessionFuture:
[17:38:37.837] Label: ‘future_mapply-1’
[17:38:37.837] Expression:
[17:38:37.837] {
[17:38:37.837]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:37.837]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:37.837]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:37.837]         on.exit(options(oopts), add = TRUE)
[17:38:37.837]     }
[17:38:37.837]     {
[17:38:37.837]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:37.837]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:38:37.837]         do.call(mapply, args = args)
[17:38:37.837]     }
[17:38:37.837] }
[17:38:37.837] Lazy evaluation: FALSE
[17:38:37.837] Asynchronous evaluation: TRUE
[17:38:37.837] Local evaluation: TRUE
[17:38:37.837] Environment: R_GlobalEnv
[17:38:37.837] Capture standard output: NA
[17:38:37.837] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:37.837] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:37.837] Packages: <none>
[17:38:37.837] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:37.837] Resolved: FALSE
[17:38:37.837] Value: <not collected>
[17:38:37.837] Conditions captured: <none>
[17:38:37.837] Early signaling: FALSE
[17:38:37.837] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:37.837] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:37.849] Chunk #1 of 2 ... DONE
[17:38:37.849] Chunk #2 of 2 ...
[17:38:37.849]  - Finding globals in '...' for chunk #2 ...
[17:38:37.849] getGlobalsAndPackages() ...
[17:38:37.849] Searching for globals...
[17:38:37.849] 
[17:38:37.850] Searching for globals ... DONE
[17:38:37.850] - globals: [0] <none>
[17:38:37.850] getGlobalsAndPackages() ... DONE
[17:38:37.850]    + additional globals found: [n=0] 
[17:38:37.850]    + additional namespaces needed: [n=0] 
[17:38:37.850]  - Finding globals in '...' for chunk #2 ... DONE
[17:38:37.850]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:37.850]  - seeds: <none>
[17:38:37.850]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:37.850] getGlobalsAndPackages() ...
[17:38:37.850] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:37.851] Resolving globals: FALSE
[17:38:37.851] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:38:37.851] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:38:37.852] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:37.852] 
[17:38:37.852] getGlobalsAndPackages() ... DONE
[17:38:37.852] run() for ‘Future’ ...
[17:38:37.852] - state: ‘created’
[17:38:37.852] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:37.866] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:37.866] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:37.866]   - Field: ‘node’
[17:38:37.866]   - Field: ‘label’
[17:38:37.866]   - Field: ‘local’
[17:38:37.867]   - Field: ‘owner’
[17:38:37.867]   - Field: ‘envir’
[17:38:37.867]   - Field: ‘workers’
[17:38:37.867]   - Field: ‘packages’
[17:38:37.867]   - Field: ‘gc’
[17:38:37.867]   - Field: ‘conditions’
[17:38:37.867]   - Field: ‘persistent’
[17:38:37.867]   - Field: ‘expr’
[17:38:37.867]   - Field: ‘uuid’
[17:38:37.867]   - Field: ‘seed’
[17:38:37.867]   - Field: ‘version’
[17:38:37.868]   - Field: ‘result’
[17:38:37.868]   - Field: ‘asynchronous’
[17:38:37.868]   - Field: ‘calls’
[17:38:37.868]   - Field: ‘globals’
[17:38:37.868]   - Field: ‘stdout’
[17:38:37.868]   - Field: ‘earlySignal’
[17:38:37.868]   - Field: ‘lazy’
[17:38:37.868]   - Field: ‘state’
[17:38:37.868] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:37.868] - Launch lazy future ...
[17:38:37.869] Packages needed by the future expression (n = 0): <none>
[17:38:37.869] Packages needed by future strategies (n = 0): <none>
[17:38:37.869] {
[17:38:37.869]     {
[17:38:37.869]         {
[17:38:37.869]             ...future.startTime <- base::Sys.time()
[17:38:37.869]             {
[17:38:37.869]                 {
[17:38:37.869]                   {
[17:38:37.869]                     {
[17:38:37.869]                       base::local({
[17:38:37.869]                         has_future <- base::requireNamespace("future", 
[17:38:37.869]                           quietly = TRUE)
[17:38:37.869]                         if (has_future) {
[17:38:37.869]                           ns <- base::getNamespace("future")
[17:38:37.869]                           version <- ns[[".package"]][["version"]]
[17:38:37.869]                           if (is.null(version)) 
[17:38:37.869]                             version <- utils::packageVersion("future")
[17:38:37.869]                         }
[17:38:37.869]                         else {
[17:38:37.869]                           version <- NULL
[17:38:37.869]                         }
[17:38:37.869]                         if (!has_future || version < "1.8.0") {
[17:38:37.869]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:37.869]                             "", base::R.version$version.string), 
[17:38:37.869]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:37.869]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:37.869]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:37.869]                               "release", "version")], collapse = " "), 
[17:38:37.869]                             hostname = base::Sys.info()[["nodename"]])
[17:38:37.869]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:37.869]                             info)
[17:38:37.869]                           info <- base::paste(info, collapse = "; ")
[17:38:37.869]                           if (!has_future) {
[17:38:37.869]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:37.869]                               info)
[17:38:37.869]                           }
[17:38:37.869]                           else {
[17:38:37.869]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:37.869]                               info, version)
[17:38:37.869]                           }
[17:38:37.869]                           base::stop(msg)
[17:38:37.869]                         }
[17:38:37.869]                       })
[17:38:37.869]                     }
[17:38:37.869]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:37.869]                     base::options(mc.cores = 1L)
[17:38:37.869]                   }
[17:38:37.869]                   ...future.strategy.old <- future::plan("list")
[17:38:37.869]                   options(future.plan = NULL)
[17:38:37.869]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:37.869]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:37.869]                 }
[17:38:37.869]                 ...future.workdir <- getwd()
[17:38:37.869]             }
[17:38:37.869]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:37.869]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:37.869]         }
[17:38:37.869]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:37.869]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:37.869]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:37.869]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:37.869]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:37.869]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:37.869]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:37.869]             base::names(...future.oldOptions))
[17:38:37.869]     }
[17:38:37.869]     if (TRUE) {
[17:38:37.869]     }
[17:38:37.869]     else {
[17:38:37.869]         if (NA) {
[17:38:37.869]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:37.869]                 open = "w")
[17:38:37.869]         }
[17:38:37.869]         else {
[17:38:37.869]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:37.869]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:37.869]         }
[17:38:37.869]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:37.869]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:37.869]             base::sink(type = "output", split = FALSE)
[17:38:37.869]             base::close(...future.stdout)
[17:38:37.869]         }, add = TRUE)
[17:38:37.869]     }
[17:38:37.869]     ...future.frame <- base::sys.nframe()
[17:38:37.869]     ...future.conditions <- base::list()
[17:38:37.869]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:37.869]     if (FALSE) {
[17:38:37.869]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:37.869]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:37.869]     }
[17:38:37.869]     ...future.result <- base::tryCatch({
[17:38:37.869]         base::withCallingHandlers({
[17:38:37.869]             ...future.value <- base::withVisible(base::local({
[17:38:37.869]                 ...future.makeSendCondition <- base::local({
[17:38:37.869]                   sendCondition <- NULL
[17:38:37.869]                   function(frame = 1L) {
[17:38:37.869]                     if (is.function(sendCondition)) 
[17:38:37.869]                       return(sendCondition)
[17:38:37.869]                     ns <- getNamespace("parallel")
[17:38:37.869]                     if (exists("sendData", mode = "function", 
[17:38:37.869]                       envir = ns)) {
[17:38:37.869]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:37.869]                         envir = ns)
[17:38:37.869]                       envir <- sys.frame(frame)
[17:38:37.869]                       master <- NULL
[17:38:37.869]                       while (!identical(envir, .GlobalEnv) && 
[17:38:37.869]                         !identical(envir, emptyenv())) {
[17:38:37.869]                         if (exists("master", mode = "list", envir = envir, 
[17:38:37.869]                           inherits = FALSE)) {
[17:38:37.869]                           master <- get("master", mode = "list", 
[17:38:37.869]                             envir = envir, inherits = FALSE)
[17:38:37.869]                           if (inherits(master, c("SOCKnode", 
[17:38:37.869]                             "SOCK0node"))) {
[17:38:37.869]                             sendCondition <<- function(cond) {
[17:38:37.869]                               data <- list(type = "VALUE", value = cond, 
[17:38:37.869]                                 success = TRUE)
[17:38:37.869]                               parallel_sendData(master, data)
[17:38:37.869]                             }
[17:38:37.869]                             return(sendCondition)
[17:38:37.869]                           }
[17:38:37.869]                         }
[17:38:37.869]                         frame <- frame + 1L
[17:38:37.869]                         envir <- sys.frame(frame)
[17:38:37.869]                       }
[17:38:37.869]                     }
[17:38:37.869]                     sendCondition <<- function(cond) NULL
[17:38:37.869]                   }
[17:38:37.869]                 })
[17:38:37.869]                 withCallingHandlers({
[17:38:37.869]                   {
[17:38:37.869]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:37.869]                     if (!identical(...future.globals.maxSize.org, 
[17:38:37.869]                       ...future.globals.maxSize)) {
[17:38:37.869]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:37.869]                       on.exit(options(oopts), add = TRUE)
[17:38:37.869]                     }
[17:38:37.869]                     {
[17:38:37.869]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:37.869]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:38:37.869]                         USE.NAMES = FALSE)
[17:38:37.869]                       do.call(mapply, args = args)
[17:38:37.869]                     }
[17:38:37.869]                   }
[17:38:37.869]                 }, immediateCondition = function(cond) {
[17:38:37.869]                   sendCondition <- ...future.makeSendCondition()
[17:38:37.869]                   sendCondition(cond)
[17:38:37.869]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:37.869]                   {
[17:38:37.869]                     inherits <- base::inherits
[17:38:37.869]                     invokeRestart <- base::invokeRestart
[17:38:37.869]                     is.null <- base::is.null
[17:38:37.869]                     muffled <- FALSE
[17:38:37.869]                     if (inherits(cond, "message")) {
[17:38:37.869]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:37.869]                       if (muffled) 
[17:38:37.869]                         invokeRestart("muffleMessage")
[17:38:37.869]                     }
[17:38:37.869]                     else if (inherits(cond, "warning")) {
[17:38:37.869]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:37.869]                       if (muffled) 
[17:38:37.869]                         invokeRestart("muffleWarning")
[17:38:37.869]                     }
[17:38:37.869]                     else if (inherits(cond, "condition")) {
[17:38:37.869]                       if (!is.null(pattern)) {
[17:38:37.869]                         computeRestarts <- base::computeRestarts
[17:38:37.869]                         grepl <- base::grepl
[17:38:37.869]                         restarts <- computeRestarts(cond)
[17:38:37.869]                         for (restart in restarts) {
[17:38:37.869]                           name <- restart$name
[17:38:37.869]                           if (is.null(name)) 
[17:38:37.869]                             next
[17:38:37.869]                           if (!grepl(pattern, name)) 
[17:38:37.869]                             next
[17:38:37.869]                           invokeRestart(restart)
[17:38:37.869]                           muffled <- TRUE
[17:38:37.869]                           break
[17:38:37.869]                         }
[17:38:37.869]                       }
[17:38:37.869]                     }
[17:38:37.869]                     invisible(muffled)
[17:38:37.869]                   }
[17:38:37.869]                   muffleCondition(cond)
[17:38:37.869]                 })
[17:38:37.869]             }))
[17:38:37.869]             future::FutureResult(value = ...future.value$value, 
[17:38:37.869]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:37.869]                   ...future.rng), globalenv = if (FALSE) 
[17:38:37.869]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:37.869]                     ...future.globalenv.names))
[17:38:37.869]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:37.869]         }, condition = base::local({
[17:38:37.869]             c <- base::c
[17:38:37.869]             inherits <- base::inherits
[17:38:37.869]             invokeRestart <- base::invokeRestart
[17:38:37.869]             length <- base::length
[17:38:37.869]             list <- base::list
[17:38:37.869]             seq.int <- base::seq.int
[17:38:37.869]             signalCondition <- base::signalCondition
[17:38:37.869]             sys.calls <- base::sys.calls
[17:38:37.869]             `[[` <- base::`[[`
[17:38:37.869]             `+` <- base::`+`
[17:38:37.869]             `<<-` <- base::`<<-`
[17:38:37.869]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:37.869]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:37.869]                   3L)]
[17:38:37.869]             }
[17:38:37.869]             function(cond) {
[17:38:37.869]                 is_error <- inherits(cond, "error")
[17:38:37.869]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:37.869]                   NULL)
[17:38:37.869]                 if (is_error) {
[17:38:37.869]                   sessionInformation <- function() {
[17:38:37.869]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:37.869]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:37.869]                       search = base::search(), system = base::Sys.info())
[17:38:37.869]                   }
[17:38:37.869]                   ...future.conditions[[length(...future.conditions) + 
[17:38:37.869]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:37.869]                     cond$call), session = sessionInformation(), 
[17:38:37.869]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:37.869]                   signalCondition(cond)
[17:38:37.869]                 }
[17:38:37.869]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:37.869]                 "immediateCondition"))) {
[17:38:37.869]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:37.869]                   ...future.conditions[[length(...future.conditions) + 
[17:38:37.869]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:37.869]                   if (TRUE && !signal) {
[17:38:37.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:37.869]                     {
[17:38:37.869]                       inherits <- base::inherits
[17:38:37.869]                       invokeRestart <- base::invokeRestart
[17:38:37.869]                       is.null <- base::is.null
[17:38:37.869]                       muffled <- FALSE
[17:38:37.869]                       if (inherits(cond, "message")) {
[17:38:37.869]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:37.869]                         if (muffled) 
[17:38:37.869]                           invokeRestart("muffleMessage")
[17:38:37.869]                       }
[17:38:37.869]                       else if (inherits(cond, "warning")) {
[17:38:37.869]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:37.869]                         if (muffled) 
[17:38:37.869]                           invokeRestart("muffleWarning")
[17:38:37.869]                       }
[17:38:37.869]                       else if (inherits(cond, "condition")) {
[17:38:37.869]                         if (!is.null(pattern)) {
[17:38:37.869]                           computeRestarts <- base::computeRestarts
[17:38:37.869]                           grepl <- base::grepl
[17:38:37.869]                           restarts <- computeRestarts(cond)
[17:38:37.869]                           for (restart in restarts) {
[17:38:37.869]                             name <- restart$name
[17:38:37.869]                             if (is.null(name)) 
[17:38:37.869]                               next
[17:38:37.869]                             if (!grepl(pattern, name)) 
[17:38:37.869]                               next
[17:38:37.869]                             invokeRestart(restart)
[17:38:37.869]                             muffled <- TRUE
[17:38:37.869]                             break
[17:38:37.869]                           }
[17:38:37.869]                         }
[17:38:37.869]                       }
[17:38:37.869]                       invisible(muffled)
[17:38:37.869]                     }
[17:38:37.869]                     muffleCondition(cond, pattern = "^muffle")
[17:38:37.869]                   }
[17:38:37.869]                 }
[17:38:37.869]                 else {
[17:38:37.869]                   if (TRUE) {
[17:38:37.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:37.869]                     {
[17:38:37.869]                       inherits <- base::inherits
[17:38:37.869]                       invokeRestart <- base::invokeRestart
[17:38:37.869]                       is.null <- base::is.null
[17:38:37.869]                       muffled <- FALSE
[17:38:37.869]                       if (inherits(cond, "message")) {
[17:38:37.869]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:37.869]                         if (muffled) 
[17:38:37.869]                           invokeRestart("muffleMessage")
[17:38:37.869]                       }
[17:38:37.869]                       else if (inherits(cond, "warning")) {
[17:38:37.869]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:37.869]                         if (muffled) 
[17:38:37.869]                           invokeRestart("muffleWarning")
[17:38:37.869]                       }
[17:38:37.869]                       else if (inherits(cond, "condition")) {
[17:38:37.869]                         if (!is.null(pattern)) {
[17:38:37.869]                           computeRestarts <- base::computeRestarts
[17:38:37.869]                           grepl <- base::grepl
[17:38:37.869]                           restarts <- computeRestarts(cond)
[17:38:37.869]                           for (restart in restarts) {
[17:38:37.869]                             name <- restart$name
[17:38:37.869]                             if (is.null(name)) 
[17:38:37.869]                               next
[17:38:37.869]                             if (!grepl(pattern, name)) 
[17:38:37.869]                               next
[17:38:37.869]                             invokeRestart(restart)
[17:38:37.869]                             muffled <- TRUE
[17:38:37.869]                             break
[17:38:37.869]                           }
[17:38:37.869]                         }
[17:38:37.869]                       }
[17:38:37.869]                       invisible(muffled)
[17:38:37.869]                     }
[17:38:37.869]                     muffleCondition(cond, pattern = "^muffle")
[17:38:37.869]                   }
[17:38:37.869]                 }
[17:38:37.869]             }
[17:38:37.869]         }))
[17:38:37.869]     }, error = function(ex) {
[17:38:37.869]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:37.869]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:37.869]                 ...future.rng), started = ...future.startTime, 
[17:38:37.869]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:37.869]             version = "1.8"), class = "FutureResult")
[17:38:37.869]     }, finally = {
[17:38:37.869]         if (!identical(...future.workdir, getwd())) 
[17:38:37.869]             setwd(...future.workdir)
[17:38:37.869]         {
[17:38:37.869]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:37.869]                 ...future.oldOptions$nwarnings <- NULL
[17:38:37.869]             }
[17:38:37.869]             base::options(...future.oldOptions)
[17:38:37.869]             if (.Platform$OS.type == "windows") {
[17:38:37.869]                 old_names <- names(...future.oldEnvVars)
[17:38:37.869]                 envs <- base::Sys.getenv()
[17:38:37.869]                 names <- names(envs)
[17:38:37.869]                 common <- intersect(names, old_names)
[17:38:37.869]                 added <- setdiff(names, old_names)
[17:38:37.869]                 removed <- setdiff(old_names, names)
[17:38:37.869]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:37.869]                   envs[common]]
[17:38:37.869]                 NAMES <- toupper(changed)
[17:38:37.869]                 args <- list()
[17:38:37.869]                 for (kk in seq_along(NAMES)) {
[17:38:37.869]                   name <- changed[[kk]]
[17:38:37.869]                   NAME <- NAMES[[kk]]
[17:38:37.869]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:37.869]                     next
[17:38:37.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:37.869]                 }
[17:38:37.869]                 NAMES <- toupper(added)
[17:38:37.869]                 for (kk in seq_along(NAMES)) {
[17:38:37.869]                   name <- added[[kk]]
[17:38:37.869]                   NAME <- NAMES[[kk]]
[17:38:37.869]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:37.869]                     next
[17:38:37.869]                   args[[name]] <- ""
[17:38:37.869]                 }
[17:38:37.869]                 NAMES <- toupper(removed)
[17:38:37.869]                 for (kk in seq_along(NAMES)) {
[17:38:37.869]                   name <- removed[[kk]]
[17:38:37.869]                   NAME <- NAMES[[kk]]
[17:38:37.869]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:37.869]                     next
[17:38:37.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:37.869]                 }
[17:38:37.869]                 if (length(args) > 0) 
[17:38:37.869]                   base::do.call(base::Sys.setenv, args = args)
[17:38:37.869]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:37.869]             }
[17:38:37.869]             else {
[17:38:37.869]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:37.869]             }
[17:38:37.869]             {
[17:38:37.869]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:37.869]                   0L) {
[17:38:37.869]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:37.869]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:37.869]                   base::options(opts)
[17:38:37.869]                 }
[17:38:37.869]                 {
[17:38:37.869]                   {
[17:38:37.869]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:37.869]                     NULL
[17:38:37.869]                   }
[17:38:37.869]                   options(future.plan = NULL)
[17:38:37.869]                   if (is.na(NA_character_)) 
[17:38:37.869]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:37.869]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:37.869]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:37.869]                     .init = FALSE)
[17:38:37.869]                 }
[17:38:37.869]             }
[17:38:37.869]         }
[17:38:37.869]     })
[17:38:37.869]     if (FALSE) {
[17:38:37.869]         base::sink(type = "output", split = FALSE)
[17:38:37.869]         if (NA) {
[17:38:37.869]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:37.869]         }
[17:38:37.869]         else {
[17:38:37.869]             ...future.result["stdout"] <- base::list(NULL)
[17:38:37.869]         }
[17:38:37.869]         base::close(...future.stdout)
[17:38:37.869]         ...future.stdout <- NULL
[17:38:37.869]     }
[17:38:37.869]     ...future.result$conditions <- ...future.conditions
[17:38:37.869]     ...future.result$finished <- base::Sys.time()
[17:38:37.869]     ...future.result
[17:38:37.869] }
[17:38:37.872] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[17:38:37.872] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[17:38:37.872] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[17:38:37.873] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:38:37.873] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:38:37.873] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:38:37.873] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:38:37.874] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:38:37.874] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:38:37.874] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:38:37.874] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:38:37.875] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[17:38:37.875] MultisessionFuture started
[17:38:37.875] - Launch lazy future ... done
[17:38:37.875] run() for ‘MultisessionFuture’ ... done
[17:38:37.876] Created future:
[17:38:37.876] MultisessionFuture:
[17:38:37.876] Label: ‘future_mapply-2’
[17:38:37.876] Expression:
[17:38:37.876] {
[17:38:37.876]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:37.876]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:37.876]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:37.876]         on.exit(options(oopts), add = TRUE)
[17:38:37.876]     }
[17:38:37.876]     {
[17:38:37.876]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:38:37.876]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:38:37.876]         do.call(mapply, args = args)
[17:38:37.876]     }
[17:38:37.876] }
[17:38:37.876] Lazy evaluation: FALSE
[17:38:37.876] Asynchronous evaluation: TRUE
[17:38:37.876] Local evaluation: TRUE
[17:38:37.876] Environment: R_GlobalEnv
[17:38:37.876] Capture standard output: NA
[17:38:37.876] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:37.876] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:37.876] Packages: <none>
[17:38:37.876] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:37.876] Resolved: FALSE
[17:38:37.876] Value: <not collected>
[17:38:37.876] Conditions captured: <none>
[17:38:37.876] Early signaling: FALSE
[17:38:37.876] Owner process: f4de6934-6427-dcc7-1b06-55b2ab8d8b44
[17:38:37.876] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:37.887] Chunk #2 of 2 ... DONE
[17:38:37.887] Launching 2 futures (chunks) ... DONE
[17:38:37.887] Resolving 2 futures (chunks) ...
[17:38:37.887] resolve() on list ...
[17:38:37.887]  recursive: 0
[17:38:37.888]  length: 2
[17:38:37.888] 
[17:38:37.929] receiveMessageFromWorker() for ClusterFuture ...
[17:38:37.930] - Validating connection of MultisessionFuture
[17:38:37.930] - received message: FutureResult
[17:38:37.930] - Received FutureResult
[17:38:37.930] - Erased future from FutureRegistry
[17:38:37.930] result() for ClusterFuture ...
[17:38:37.930] - result already collected: FutureResult
[17:38:37.930] result() for ClusterFuture ... done
[17:38:37.931] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:37.931] Future #2
[17:38:37.931] result() for ClusterFuture ...
[17:38:37.931] - result already collected: FutureResult
[17:38:37.931] result() for ClusterFuture ... done
[17:38:37.931] result() for ClusterFuture ...
[17:38:37.931] - result already collected: FutureResult
[17:38:37.931] result() for ClusterFuture ... done
[17:38:37.931] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:38:37.931] - nx: 2
[17:38:37.931] - relay: TRUE
[17:38:37.932] - stdout: TRUE
[17:38:37.932] - signal: TRUE
[17:38:37.932] - resignal: FALSE
[17:38:37.932] - force: TRUE
[17:38:37.932] - relayed: [n=2] FALSE, FALSE
[17:38:37.932] - queued futures: [n=2] FALSE, FALSE
[17:38:37.932]  - until=1
[17:38:37.932]  - relaying element #1
[17:38:37.932] - relayed: [n=2] FALSE, FALSE
[17:38:37.932] - queued futures: [n=2] FALSE, TRUE
[17:38:37.932] signalConditionsASAP(NULL, pos=2) ... done
[17:38:37.933]  length: 1 (resolved future 2)
[17:38:38.383] receiveMessageFromWorker() for ClusterFuture ...
[17:38:38.383] - Validating connection of MultisessionFuture
[17:38:38.383] - received message: FutureResult
[17:38:38.383] - Received FutureResult
[17:38:38.383] - Erased future from FutureRegistry
[17:38:38.384] result() for ClusterFuture ...
[17:38:38.384] - result already collected: FutureResult
[17:38:38.384] result() for ClusterFuture ... done
[17:38:38.384] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:38.384] Future #1
[17:38:38.384] result() for ClusterFuture ...
[17:38:38.384] - result already collected: FutureResult
[17:38:38.384] result() for ClusterFuture ... done
[17:38:38.384] result() for ClusterFuture ...
[17:38:38.384] - result already collected: FutureResult
[17:38:38.384] result() for ClusterFuture ... done
[17:38:38.385] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:38:38.385] - nx: 2
[17:38:38.385] - relay: TRUE
[17:38:38.385] - stdout: TRUE
[17:38:38.385] - signal: TRUE
[17:38:38.385] - resignal: FALSE
[17:38:38.387] - force: TRUE
[17:38:38.387] - relayed: [n=2] FALSE, FALSE
[17:38:38.388] - queued futures: [n=2] FALSE, TRUE
[17:38:38.388]  - until=1
[17:38:38.388]  - relaying element #1
[17:38:38.388] result() for ClusterFuture ...
[17:38:38.388] - result already collected: FutureResult
[17:38:38.388] result() for ClusterFuture ... done
[17:38:38.388] result() for ClusterFuture ...
[17:38:38.388] - result already collected: FutureResult
[17:38:38.388] result() for ClusterFuture ... done
[17:38:38.388] result() for ClusterFuture ...
[17:38:38.388] - result already collected: FutureResult
[17:38:38.389] result() for ClusterFuture ... done
[17:38:38.389] result() for ClusterFuture ...
[17:38:38.389] - result already collected: FutureResult
[17:38:38.389] result() for ClusterFuture ... done
[17:38:38.389] - relayed: [n=2] TRUE, FALSE
[17:38:38.389] - queued futures: [n=2] TRUE, TRUE
[17:38:38.389] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:38:38.389]  length: 0 (resolved future 1)
[17:38:38.389] Relaying remaining futures
[17:38:38.389] signalConditionsASAP(NULL, pos=0) ...
[17:38:38.389] - nx: 2
[17:38:38.389] - relay: TRUE
[17:38:38.390] - stdout: TRUE
[17:38:38.390] - signal: TRUE
[17:38:38.390] - resignal: FALSE
[17:38:38.390] - force: TRUE
[17:38:38.390] - relayed: [n=2] TRUE, FALSE
[17:38:38.390] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:38.390]  - relaying element #2
[17:38:38.390] result() for ClusterFuture ...
[17:38:38.390] - result already collected: FutureResult
[17:38:38.390] result() for ClusterFuture ... done
[17:38:38.390] result() for ClusterFuture ...
[17:38:38.390] - result already collected: FutureResult
[17:38:38.391] result() for ClusterFuture ... done
[17:38:38.391] result() for ClusterFuture ...
[17:38:38.391] - result already collected: FutureResult
[17:38:38.391] result() for ClusterFuture ... done
[17:38:38.391] result() for ClusterFuture ...
[17:38:38.391] - result already collected: FutureResult
[17:38:38.391] result() for ClusterFuture ... done
[17:38:38.391] - relayed: [n=2] TRUE, TRUE
[17:38:38.391] - queued futures: [n=2] TRUE, TRUE
[17:38:38.391] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:38:38.391] resolve() on list ... DONE
[17:38:38.391] result() for ClusterFuture ...
[17:38:38.392] - result already collected: FutureResult
[17:38:38.392] result() for ClusterFuture ... done
[17:38:38.392] result() for ClusterFuture ...
[17:38:38.392] - result already collected: FutureResult
[17:38:38.392] result() for ClusterFuture ... done
[17:38:38.392] result() for ClusterFuture ...
[17:38:38.392] - result already collected: FutureResult
[17:38:38.392] result() for ClusterFuture ... done
[17:38:38.392] result() for ClusterFuture ...
[17:38:38.392] - result already collected: FutureResult
[17:38:38.392] result() for ClusterFuture ... done
[17:38:38.393]  - Number of value chunks collected: 2
[17:38:38.393] Resolving 2 futures (chunks) ... DONE
[17:38:38.393] Reducing values from 2 chunks ...
[17:38:38.393]  - Number of values collected after concatenation: 2
[17:38:38.393]  - Number of values expected: 2
[17:38:38.393] Reducing values from 2 chunks ... DONE
[17:38:38.393] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 2 cores ... DONE
> 
> message("*** future_*apply() and 'future.stdout' ... DONE")
*** future_*apply() and 'future.stdout' ... DONE
> 
> source("incl/end.R")
[17:38:38.394] plan(): Setting new future strategy stack:
[17:38:38.394] List of future strategies:
[17:38:38.394] 1. FutureStrategy:
[17:38:38.394]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:38.394]    - tweaked: FALSE
[17:38:38.394]    - call: future::plan(oplan)
[17:38:38.395] plan(): nbrOfWorkers() = 1
> 
