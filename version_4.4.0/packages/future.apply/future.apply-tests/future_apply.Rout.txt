
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:36:34.365] plan(): Setting new future strategy stack:
[17:36:34.366] List of future strategies:
[17:36:34.366] 1. sequential:
[17:36:34.366]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:34.366]    - tweaked: FALSE
[17:36:34.366]    - call: future::plan("sequential")
[17:36:34.380] plan(): nbrOfWorkers() = 1
> 
> message("*** future_apply() ...")
*** future_apply() ...
> 
> z0 <- NULL
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(apply) ...")
+   X <- matrix(c(1:4, 1, 6:8), nrow = 2L)
+   
+   Y0 <- apply(X, MARGIN = 1L, FUN = table)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = table)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0, check.attributes = FALSE)) ## FIXME
+ 
+   Y2 <- future_apply(X, MARGIN = 1L, FUN = "table")
+   print(Y2)
+   stopifnot(identical(Y2, Y1))
+ 
+   Y0 <- apply(X, MARGIN = 1L, FUN = stats::quantile)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = stats::quantile)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0))
+ 
+   x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
+   names(dimnames(x)) <- c("row", "col")
+   x3 <- array(x, dim = c(dim(x), 3),
+               dimnames = c(dimnames(x), list(C = paste0("cop.", 1:3))))
+   
+   y0 <- apply(x, MARGIN = 2L, FUN = identity)
+   stopifnot(identical(y0, x))
+   y1 <- future_apply(x, MARGIN = 2L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- apply(x3, MARGIN = 2:3, FUN = identity)
+   stopifnot(identical(y0, x3))
+   y1 <- future_apply(x3, MARGIN = 2:3, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   z <- array(1:24, dim = 2:4)
+   y0 <- apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   y1 <- future_apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, MARGIN = <character>, ...) ...")
+   X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
+   y0 <- apply(X, MARGIN = "rows", FUN = identity)
+   y1 <- future_apply(X, MARGIN = "rows", FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - dim(X) > 2 ...")
+   X <- array(1:12, dim = c(2, 2, 3))
+   y0 <- apply(X, MARGIN = 1L, FUN = identity)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - not all same names ...")
+   FUN <- function(x) {
+     if (x[1] == 1L) names(x) <- letters[seq_along(x)]
+     x
+   }
+   X <- matrix(1:4, nrow = 2L, ncol = 2L)
+   y0 <- apply(X, MARGIN = 1L, FUN = FUN)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = FUN)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- example(future_apply) - reproducible RNG ...")
+   z1 <- future_apply(X, MARGIN = 1L, FUN = sample,
+           future.seed = 0xBEEF,
+           ## Test also all other 'future.*' arguments
+           future.stdout     = TRUE,
+           future.conditions = NULL,
+           future.globals    = TRUE,
+           future.packages   = NULL,
+           future.scheduling = 1.0,
+           future.chunk.size = NULL,
+           future.label      = "future_apply-%d"
+         )
+   print(z1)
+   if (is.null(z0)) {
+     z0 <- z1
+   } else {
+     stopifnot(identical(z1, z0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[17:36:34.436] plan(): Setting new future strategy stack:
[17:36:34.436] List of future strategies:
[17:36:34.436] 1. sequential:
[17:36:34.436]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:34.436]    - tweaked: FALSE
[17:36:34.436]    - call: plan(strategy)
[17:36:34.448] plan(): nbrOfWorkers() = 1
- From example(apply) ...
[17:36:34.449] getGlobalsAndPackagesXApply() ...
[17:36:34.449]  - future.globals: TRUE
[17:36:34.450] getGlobalsAndPackages() ...
[17:36:34.450] Searching for globals...
[17:36:34.489] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:36:34.489] Searching for globals ... DONE
[17:36:34.489] Resolving globals: FALSE
[17:36:34.491] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:36:34.492] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:36:34.492] - globals: [1] ‘FUN’
[17:36:34.492] 
[17:36:34.492] getGlobalsAndPackages() ... DONE
[17:36:34.492]  - globals found/used: [n=1] ‘FUN’
[17:36:34.492]  - needed namespaces: [n=0] 
[17:36:34.494] Finding globals ... DONE
[17:36:34.494]  - use_args: TRUE
[17:36:34.494]  - Getting '...' globals ...
[17:36:34.495] resolve() on list ...
[17:36:34.495]  recursive: 0
[17:36:34.495]  length: 1
[17:36:34.495]  elements: ‘...’
[17:36:34.496]  length: 0 (resolved future 1)
[17:36:34.496] resolve() on list ... DONE
[17:36:34.496]    - '...' content: [n=0] 
[17:36:34.496] List of 1
[17:36:34.496]  $ ...: list()
[17:36:34.496]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.496]  - attr(*, "where")=List of 1
[17:36:34.496]   ..$ ...:<environment: 0x556d751c6e50> 
[17:36:34.496]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.496]  - attr(*, "resolved")= logi TRUE
[17:36:34.496]  - attr(*, "total_size")= num NA
[17:36:34.501]  - Getting '...' globals ... DONE
[17:36:34.501] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:34.501] List of 2
[17:36:34.501]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:36:34.501]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:36:34.501]  $ ...          : list()
[17:36:34.501]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.501]  - attr(*, "where")=List of 2
[17:36:34.501]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:34.501]   ..$ ...          :<environment: 0x556d751c6e50> 
[17:36:34.501]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.501]  - attr(*, "resolved")= logi FALSE
[17:36:34.501]  - attr(*, "total_size")= num 354224
[17:36:34.504] Packages to be attached in all futures: [n=0] 
[17:36:34.504] getGlobalsAndPackagesXApply() ... DONE
[17:36:34.504] future_lapply() ...
[17:36:34.537] Number of chunks: 1
[17:36:34.537] getGlobalsAndPackagesXApply() ...
[17:36:34.537]  - future.globals: <name-value list> with names ‘list()’
[17:36:34.537]  - use_args: TRUE
[17:36:34.537] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:34.538] List of 2
[17:36:34.538]  $ ...          : list()
[17:36:34.538]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.538]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:36:34.538]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:36:34.538]  - attr(*, "where")=List of 2
[17:36:34.538]   ..$ ...          :<environment: 0x556d751c6e50> 
[17:36:34.538]   ..$ ...future.FUN:<environment: namespace:base> 
[17:36:34.538]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.538]  - attr(*, "resolved")= logi FALSE
[17:36:34.538]  - attr(*, "total_size")= num NA
[17:36:34.541] Packages to be attached in all futures: [n=0] 
[17:36:34.541] getGlobalsAndPackagesXApply() ... DONE
[17:36:34.541] Number of futures (= number of chunks): 1
[17:36:34.541] Launching 1 futures (chunks) ...
[17:36:34.541] Chunk #1 of 1 ...
[17:36:34.542]  - seeds: <none>
[17:36:34.542]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.542] getGlobalsAndPackages() ...
[17:36:34.542] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.542] Resolving globals: FALSE
[17:36:34.542] Tweak future expression to call with '...' arguments ...
[17:36:34.542] {
[17:36:34.542]     do.call(function(...) {
[17:36:34.542]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.542]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:34.542]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.542]             on.exit(options(oopts), add = TRUE)
[17:36:34.542]         }
[17:36:34.542]         {
[17:36:34.542]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:34.542]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.542]                 ...future.FUN(...future.X_jj, ...)
[17:36:34.542]             })
[17:36:34.542]         }
[17:36:34.542]     }, args = future.call.arguments)
[17:36:34.542] }
[17:36:34.543] Tweak future expression to call with '...' arguments ... DONE
[17:36:34.543] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.543] 
[17:36:34.543] getGlobalsAndPackages() ... DONE
[17:36:34.544] run() for ‘Future’ ...
[17:36:34.544] - state: ‘created’
[17:36:34.544] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:34.545] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:34.545] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:34.545]   - Field: ‘label’
[17:36:34.545]   - Field: ‘local’
[17:36:34.545]   - Field: ‘owner’
[17:36:34.546]   - Field: ‘envir’
[17:36:34.546]   - Field: ‘packages’
[17:36:34.547]   - Field: ‘gc’
[17:36:34.547]   - Field: ‘conditions’
[17:36:34.547]   - Field: ‘expr’
[17:36:34.547]   - Field: ‘uuid’
[17:36:34.547]   - Field: ‘seed’
[17:36:34.547]   - Field: ‘version’
[17:36:34.547]   - Field: ‘result’
[17:36:34.547]   - Field: ‘asynchronous’
[17:36:34.547]   - Field: ‘calls’
[17:36:34.547]   - Field: ‘globals’
[17:36:34.547]   - Field: ‘stdout’
[17:36:34.548]   - Field: ‘earlySignal’
[17:36:34.548]   - Field: ‘lazy’
[17:36:34.548]   - Field: ‘state’
[17:36:34.548] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:34.548] - Launch lazy future ...
[17:36:34.549] Packages needed by the future expression (n = 0): <none>
[17:36:34.549] Packages needed by future strategies (n = 0): <none>
[17:36:34.550] {
[17:36:34.550]     {
[17:36:34.550]         {
[17:36:34.550]             ...future.startTime <- base::Sys.time()
[17:36:34.550]             {
[17:36:34.550]                 {
[17:36:34.550]                   {
[17:36:34.550]                     base::local({
[17:36:34.550]                       has_future <- base::requireNamespace("future", 
[17:36:34.550]                         quietly = TRUE)
[17:36:34.550]                       if (has_future) {
[17:36:34.550]                         ns <- base::getNamespace("future")
[17:36:34.550]                         version <- ns[[".package"]][["version"]]
[17:36:34.550]                         if (is.null(version)) 
[17:36:34.550]                           version <- utils::packageVersion("future")
[17:36:34.550]                       }
[17:36:34.550]                       else {
[17:36:34.550]                         version <- NULL
[17:36:34.550]                       }
[17:36:34.550]                       if (!has_future || version < "1.8.0") {
[17:36:34.550]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:34.550]                           "", base::R.version$version.string), 
[17:36:34.550]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:34.550]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:34.550]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:34.550]                             "release", "version")], collapse = " "), 
[17:36:34.550]                           hostname = base::Sys.info()[["nodename"]])
[17:36:34.550]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:34.550]                           info)
[17:36:34.550]                         info <- base::paste(info, collapse = "; ")
[17:36:34.550]                         if (!has_future) {
[17:36:34.550]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:34.550]                             info)
[17:36:34.550]                         }
[17:36:34.550]                         else {
[17:36:34.550]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:34.550]                             info, version)
[17:36:34.550]                         }
[17:36:34.550]                         base::stop(msg)
[17:36:34.550]                       }
[17:36:34.550]                     })
[17:36:34.550]                   }
[17:36:34.550]                   ...future.strategy.old <- future::plan("list")
[17:36:34.550]                   options(future.plan = NULL)
[17:36:34.550]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:34.550]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:34.550]                 }
[17:36:34.550]                 ...future.workdir <- getwd()
[17:36:34.550]             }
[17:36:34.550]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:34.550]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:34.550]         }
[17:36:34.550]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:34.550]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:34.550]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:34.550]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:34.550]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:34.550]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:34.550]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:34.550]             base::names(...future.oldOptions))
[17:36:34.550]     }
[17:36:34.550]     if (FALSE) {
[17:36:34.550]     }
[17:36:34.550]     else {
[17:36:34.550]         if (TRUE) {
[17:36:34.550]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:34.550]                 open = "w")
[17:36:34.550]         }
[17:36:34.550]         else {
[17:36:34.550]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:34.550]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:34.550]         }
[17:36:34.550]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:34.550]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:34.550]             base::sink(type = "output", split = FALSE)
[17:36:34.550]             base::close(...future.stdout)
[17:36:34.550]         }, add = TRUE)
[17:36:34.550]     }
[17:36:34.550]     ...future.frame <- base::sys.nframe()
[17:36:34.550]     ...future.conditions <- base::list()
[17:36:34.550]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:34.550]     if (FALSE) {
[17:36:34.550]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:34.550]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:34.550]     }
[17:36:34.550]     ...future.result <- base::tryCatch({
[17:36:34.550]         base::withCallingHandlers({
[17:36:34.550]             ...future.value <- base::withVisible(base::local({
[17:36:34.550]                 do.call(function(...) {
[17:36:34.550]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.550]                   if (!identical(...future.globals.maxSize.org, 
[17:36:34.550]                     ...future.globals.maxSize)) {
[17:36:34.550]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.550]                     on.exit(options(oopts), add = TRUE)
[17:36:34.550]                   }
[17:36:34.550]                   {
[17:36:34.550]                     lapply(seq_along(...future.elements_ii), 
[17:36:34.550]                       FUN = function(jj) {
[17:36:34.550]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.550]                         ...future.FUN(...future.X_jj, ...)
[17:36:34.550]                       })
[17:36:34.550]                   }
[17:36:34.550]                 }, args = future.call.arguments)
[17:36:34.550]             }))
[17:36:34.550]             future::FutureResult(value = ...future.value$value, 
[17:36:34.550]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:34.550]                   ...future.rng), globalenv = if (FALSE) 
[17:36:34.550]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:34.550]                     ...future.globalenv.names))
[17:36:34.550]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:34.550]         }, condition = base::local({
[17:36:34.550]             c <- base::c
[17:36:34.550]             inherits <- base::inherits
[17:36:34.550]             invokeRestart <- base::invokeRestart
[17:36:34.550]             length <- base::length
[17:36:34.550]             list <- base::list
[17:36:34.550]             seq.int <- base::seq.int
[17:36:34.550]             signalCondition <- base::signalCondition
[17:36:34.550]             sys.calls <- base::sys.calls
[17:36:34.550]             `[[` <- base::`[[`
[17:36:34.550]             `+` <- base::`+`
[17:36:34.550]             `<<-` <- base::`<<-`
[17:36:34.550]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:34.550]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:34.550]                   3L)]
[17:36:34.550]             }
[17:36:34.550]             function(cond) {
[17:36:34.550]                 is_error <- inherits(cond, "error")
[17:36:34.550]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:34.550]                   NULL)
[17:36:34.550]                 if (is_error) {
[17:36:34.550]                   sessionInformation <- function() {
[17:36:34.550]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:34.550]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:34.550]                       search = base::search(), system = base::Sys.info())
[17:36:34.550]                   }
[17:36:34.550]                   ...future.conditions[[length(...future.conditions) + 
[17:36:34.550]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:34.550]                     cond$call), session = sessionInformation(), 
[17:36:34.550]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:34.550]                   signalCondition(cond)
[17:36:34.550]                 }
[17:36:34.550]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:34.550]                 "immediateCondition"))) {
[17:36:34.550]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:34.550]                   ...future.conditions[[length(...future.conditions) + 
[17:36:34.550]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:34.550]                   if (TRUE && !signal) {
[17:36:34.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:34.550]                     {
[17:36:34.550]                       inherits <- base::inherits
[17:36:34.550]                       invokeRestart <- base::invokeRestart
[17:36:34.550]                       is.null <- base::is.null
[17:36:34.550]                       muffled <- FALSE
[17:36:34.550]                       if (inherits(cond, "message")) {
[17:36:34.550]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:34.550]                         if (muffled) 
[17:36:34.550]                           invokeRestart("muffleMessage")
[17:36:34.550]                       }
[17:36:34.550]                       else if (inherits(cond, "warning")) {
[17:36:34.550]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:34.550]                         if (muffled) 
[17:36:34.550]                           invokeRestart("muffleWarning")
[17:36:34.550]                       }
[17:36:34.550]                       else if (inherits(cond, "condition")) {
[17:36:34.550]                         if (!is.null(pattern)) {
[17:36:34.550]                           computeRestarts <- base::computeRestarts
[17:36:34.550]                           grepl <- base::grepl
[17:36:34.550]                           restarts <- computeRestarts(cond)
[17:36:34.550]                           for (restart in restarts) {
[17:36:34.550]                             name <- restart$name
[17:36:34.550]                             if (is.null(name)) 
[17:36:34.550]                               next
[17:36:34.550]                             if (!grepl(pattern, name)) 
[17:36:34.550]                               next
[17:36:34.550]                             invokeRestart(restart)
[17:36:34.550]                             muffled <- TRUE
[17:36:34.550]                             break
[17:36:34.550]                           }
[17:36:34.550]                         }
[17:36:34.550]                       }
[17:36:34.550]                       invisible(muffled)
[17:36:34.550]                     }
[17:36:34.550]                     muffleCondition(cond, pattern = "^muffle")
[17:36:34.550]                   }
[17:36:34.550]                 }
[17:36:34.550]                 else {
[17:36:34.550]                   if (TRUE) {
[17:36:34.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:34.550]                     {
[17:36:34.550]                       inherits <- base::inherits
[17:36:34.550]                       invokeRestart <- base::invokeRestart
[17:36:34.550]                       is.null <- base::is.null
[17:36:34.550]                       muffled <- FALSE
[17:36:34.550]                       if (inherits(cond, "message")) {
[17:36:34.550]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:34.550]                         if (muffled) 
[17:36:34.550]                           invokeRestart("muffleMessage")
[17:36:34.550]                       }
[17:36:34.550]                       else if (inherits(cond, "warning")) {
[17:36:34.550]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:34.550]                         if (muffled) 
[17:36:34.550]                           invokeRestart("muffleWarning")
[17:36:34.550]                       }
[17:36:34.550]                       else if (inherits(cond, "condition")) {
[17:36:34.550]                         if (!is.null(pattern)) {
[17:36:34.550]                           computeRestarts <- base::computeRestarts
[17:36:34.550]                           grepl <- base::grepl
[17:36:34.550]                           restarts <- computeRestarts(cond)
[17:36:34.550]                           for (restart in restarts) {
[17:36:34.550]                             name <- restart$name
[17:36:34.550]                             if (is.null(name)) 
[17:36:34.550]                               next
[17:36:34.550]                             if (!grepl(pattern, name)) 
[17:36:34.550]                               next
[17:36:34.550]                             invokeRestart(restart)
[17:36:34.550]                             muffled <- TRUE
[17:36:34.550]                             break
[17:36:34.550]                           }
[17:36:34.550]                         }
[17:36:34.550]                       }
[17:36:34.550]                       invisible(muffled)
[17:36:34.550]                     }
[17:36:34.550]                     muffleCondition(cond, pattern = "^muffle")
[17:36:34.550]                   }
[17:36:34.550]                 }
[17:36:34.550]             }
[17:36:34.550]         }))
[17:36:34.550]     }, error = function(ex) {
[17:36:34.550]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:34.550]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:34.550]                 ...future.rng), started = ...future.startTime, 
[17:36:34.550]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:34.550]             version = "1.8"), class = "FutureResult")
[17:36:34.550]     }, finally = {
[17:36:34.550]         if (!identical(...future.workdir, getwd())) 
[17:36:34.550]             setwd(...future.workdir)
[17:36:34.550]         {
[17:36:34.550]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:34.550]                 ...future.oldOptions$nwarnings <- NULL
[17:36:34.550]             }
[17:36:34.550]             base::options(...future.oldOptions)
[17:36:34.550]             if (.Platform$OS.type == "windows") {
[17:36:34.550]                 old_names <- names(...future.oldEnvVars)
[17:36:34.550]                 envs <- base::Sys.getenv()
[17:36:34.550]                 names <- names(envs)
[17:36:34.550]                 common <- intersect(names, old_names)
[17:36:34.550]                 added <- setdiff(names, old_names)
[17:36:34.550]                 removed <- setdiff(old_names, names)
[17:36:34.550]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:34.550]                   envs[common]]
[17:36:34.550]                 NAMES <- toupper(changed)
[17:36:34.550]                 args <- list()
[17:36:34.550]                 for (kk in seq_along(NAMES)) {
[17:36:34.550]                   name <- changed[[kk]]
[17:36:34.550]                   NAME <- NAMES[[kk]]
[17:36:34.550]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.550]                     next
[17:36:34.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:34.550]                 }
[17:36:34.550]                 NAMES <- toupper(added)
[17:36:34.550]                 for (kk in seq_along(NAMES)) {
[17:36:34.550]                   name <- added[[kk]]
[17:36:34.550]                   NAME <- NAMES[[kk]]
[17:36:34.550]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.550]                     next
[17:36:34.550]                   args[[name]] <- ""
[17:36:34.550]                 }
[17:36:34.550]                 NAMES <- toupper(removed)
[17:36:34.550]                 for (kk in seq_along(NAMES)) {
[17:36:34.550]                   name <- removed[[kk]]
[17:36:34.550]                   NAME <- NAMES[[kk]]
[17:36:34.550]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.550]                     next
[17:36:34.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:34.550]                 }
[17:36:34.550]                 if (length(args) > 0) 
[17:36:34.550]                   base::do.call(base::Sys.setenv, args = args)
[17:36:34.550]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:34.550]             }
[17:36:34.550]             else {
[17:36:34.550]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:34.550]             }
[17:36:34.550]             {
[17:36:34.550]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:34.550]                   0L) {
[17:36:34.550]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:34.550]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:34.550]                   base::options(opts)
[17:36:34.550]                 }
[17:36:34.550]                 {
[17:36:34.550]                   {
[17:36:34.550]                     NULL
[17:36:34.550]                     RNGkind("Mersenne-Twister")
[17:36:34.550]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:34.550]                       inherits = FALSE)
[17:36:34.550]                   }
[17:36:34.550]                   options(future.plan = NULL)
[17:36:34.550]                   if (is.na(NA_character_)) 
[17:36:34.550]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:34.550]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:34.550]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:34.550]                     .init = FALSE)
[17:36:34.550]                 }
[17:36:34.550]             }
[17:36:34.550]         }
[17:36:34.550]     })
[17:36:34.550]     if (TRUE) {
[17:36:34.550]         base::sink(type = "output", split = FALSE)
[17:36:34.550]         if (TRUE) {
[17:36:34.550]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:34.550]         }
[17:36:34.550]         else {
[17:36:34.550]             ...future.result["stdout"] <- base::list(NULL)
[17:36:34.550]         }
[17:36:34.550]         base::close(...future.stdout)
[17:36:34.550]         ...future.stdout <- NULL
[17:36:34.550]     }
[17:36:34.550]     ...future.result$conditions <- ...future.conditions
[17:36:34.550]     ...future.result$finished <- base::Sys.time()
[17:36:34.550]     ...future.result
[17:36:34.550] }
[17:36:34.551] assign_globals() ...
[17:36:34.552] List of 5
[17:36:34.552]  $ future.call.arguments    : list()
[17:36:34.552]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.552]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:36:34.552]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:36:34.552]  $ ...future.elements_ii    :List of 2
[17:36:34.552]   ..$ : num [1:4] 1 3 1 7
[17:36:34.552]   ..$ : num [1:4] 2 4 6 8
[17:36:34.552]  $ ...future.seeds_ii       : NULL
[17:36:34.552]  $ ...future.globals.maxSize: num Inf
[17:36:34.552]  - attr(*, "resolved")= logi FALSE
[17:36:34.552]  - attr(*, "total_size")= num NA
[17:36:34.552]  - attr(*, "where")=List of 5
[17:36:34.552]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:34.552]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:34.552]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:34.552]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:34.552]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:34.552]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.552]  - attr(*, "already-done")= logi TRUE
[17:36:34.556] - copied ‘future.call.arguments’ to environment
[17:36:34.557] - copied ‘...future.FUN’ to environment
[17:36:34.557] - copied ‘...future.elements_ii’ to environment
[17:36:34.557] - copied ‘...future.seeds_ii’ to environment
[17:36:34.557] - copied ‘...future.globals.maxSize’ to environment
[17:36:34.557] assign_globals() ... done
[17:36:34.557] plan(): Setting new future strategy stack:
[17:36:34.557] List of future strategies:
[17:36:34.557] 1. sequential:
[17:36:34.557]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:34.557]    - tweaked: FALSE
[17:36:34.557]    - call: NULL
[17:36:34.558] plan(): nbrOfWorkers() = 1
[17:36:34.559] plan(): Setting new future strategy stack:
[17:36:34.559] List of future strategies:
[17:36:34.559] 1. sequential:
[17:36:34.559]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:34.559]    - tweaked: FALSE
[17:36:34.559]    - call: plan(strategy)
[17:36:34.560] plan(): nbrOfWorkers() = 1
[17:36:34.560] SequentialFuture started (and completed)
[17:36:34.560] - Launch lazy future ... done
[17:36:34.560] run() for ‘SequentialFuture’ ... done
[17:36:34.561] Created future:
[17:36:34.561] SequentialFuture:
[17:36:34.561] Label: ‘future_apply-1’
[17:36:34.561] Expression:
[17:36:34.561] {
[17:36:34.561]     do.call(function(...) {
[17:36:34.561]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.561]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:34.561]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.561]             on.exit(options(oopts), add = TRUE)
[17:36:34.561]         }
[17:36:34.561]         {
[17:36:34.561]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:34.561]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.561]                 ...future.FUN(...future.X_jj, ...)
[17:36:34.561]             })
[17:36:34.561]         }
[17:36:34.561]     }, args = future.call.arguments)
[17:36:34.561] }
[17:36:34.561] Lazy evaluation: FALSE
[17:36:34.561] Asynchronous evaluation: FALSE
[17:36:34.561] Local evaluation: TRUE
[17:36:34.561] Environment: R_GlobalEnv
[17:36:34.561] Capture standard output: TRUE
[17:36:34.561] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:34.561] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:34.561] Packages: <none>
[17:36:34.561] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:34.561] Resolved: TRUE
[17:36:34.561] Value: 2.21 KiB of class ‘list’
[17:36:34.561] Early signaling: FALSE
[17:36:34.561] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:34.561] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:34.562] Chunk #1 of 1 ... DONE
[17:36:34.562] Launching 1 futures (chunks) ... DONE
[17:36:34.562] Resolving 1 futures (chunks) ...
[17:36:34.562] resolve() on list ...
[17:36:34.563]  recursive: 0
[17:36:34.563]  length: 1
[17:36:34.563] 
[17:36:34.563] resolved() for ‘SequentialFuture’ ...
[17:36:34.563] - state: ‘finished’
[17:36:34.563] - run: TRUE
[17:36:34.563] - result: ‘FutureResult’
[17:36:34.563] resolved() for ‘SequentialFuture’ ... done
[17:36:34.563] Future #1
[17:36:34.564] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:34.564] - nx: 1
[17:36:34.564] - relay: TRUE
[17:36:34.564] - stdout: TRUE
[17:36:34.564] - signal: TRUE
[17:36:34.564] - resignal: FALSE
[17:36:34.564] - force: TRUE
[17:36:34.564] - relayed: [n=1] FALSE
[17:36:34.564] - queued futures: [n=1] FALSE
[17:36:34.565]  - until=1
[17:36:34.565]  - relaying element #1
[17:36:34.565] - relayed: [n=1] TRUE
[17:36:34.565] - queued futures: [n=1] TRUE
[17:36:34.565] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:34.565]  length: 0 (resolved future 1)
[17:36:34.565] Relaying remaining futures
[17:36:34.565] signalConditionsASAP(NULL, pos=0) ...
[17:36:34.566] - nx: 1
[17:36:34.566] - relay: TRUE
[17:36:34.566] - stdout: TRUE
[17:36:34.566] - signal: TRUE
[17:36:34.566] - resignal: FALSE
[17:36:34.566] - force: TRUE
[17:36:34.566] - relayed: [n=1] TRUE
[17:36:34.566] - queued futures: [n=1] TRUE
 - flush all
[17:36:34.566] - relayed: [n=1] TRUE
[17:36:34.566] - queued futures: [n=1] TRUE
[17:36:34.566] signalConditionsASAP(NULL, pos=0) ... done
[17:36:34.566] resolve() on list ... DONE
[17:36:34.567]  - Number of value chunks collected: 1
[17:36:34.567] Resolving 1 futures (chunks) ... DONE
[17:36:34.567] Reducing values from 1 chunks ...
[17:36:34.567]  - Number of values collected after concatenation: 2
[17:36:34.567]  - Number of values expected: 2
[17:36:34.567] Reducing values from 1 chunks ... DONE
[17:36:34.567] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:36:34.568] getGlobalsAndPackagesXApply() ...
[17:36:34.568]  - future.globals: TRUE
[17:36:34.568] getGlobalsAndPackages() ...
[17:36:34.568] Searching for globals...
[17:36:34.602] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:36:34.602] Searching for globals ... DONE
[17:36:34.602] Resolving globals: FALSE
[17:36:34.604] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:36:34.604] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:36:34.604] - globals: [1] ‘FUN’
[17:36:34.605] 
[17:36:34.605] getGlobalsAndPackages() ... DONE
[17:36:34.605]  - globals found/used: [n=1] ‘FUN’
[17:36:34.605]  - needed namespaces: [n=0] 
[17:36:34.605] Finding globals ... DONE
[17:36:34.605]  - use_args: TRUE
[17:36:34.605]  - Getting '...' globals ...
[17:36:34.605] resolve() on list ...
[17:36:34.606]  recursive: 0
[17:36:34.606]  length: 1
[17:36:34.606]  elements: ‘...’
[17:36:34.606]  length: 0 (resolved future 1)
[17:36:34.606] resolve() on list ... DONE
[17:36:34.606]    - '...' content: [n=0] 
[17:36:34.606] List of 1
[17:36:34.606]  $ ...: list()
[17:36:34.606]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.606]  - attr(*, "where")=List of 1
[17:36:34.606]   ..$ ...:<environment: 0x556d75c462e8> 
[17:36:34.606]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.606]  - attr(*, "resolved")= logi TRUE
[17:36:34.606]  - attr(*, "total_size")= num NA
[17:36:34.609]  - Getting '...' globals ... DONE
[17:36:34.609] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:34.609] List of 2
[17:36:34.609]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:36:34.609]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:36:34.609]  $ ...          : list()
[17:36:34.609]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.609]  - attr(*, "where")=List of 2
[17:36:34.609]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:34.609]   ..$ ...          :<environment: 0x556d75c462e8> 
[17:36:34.609]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.609]  - attr(*, "resolved")= logi FALSE
[17:36:34.609]  - attr(*, "total_size")= num 354224
[17:36:34.611] Packages to be attached in all futures: [n=0] 
[17:36:34.612] getGlobalsAndPackagesXApply() ... DONE
[17:36:34.612] future_lapply() ...
[17:36:34.643] Number of chunks: 1
[17:36:34.643] getGlobalsAndPackagesXApply() ...
[17:36:34.643]  - future.globals: <name-value list> with names ‘list()’
[17:36:34.643]  - use_args: TRUE
[17:36:34.643] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:34.644] List of 2
[17:36:34.644]  $ ...          : list()
[17:36:34.644]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.644]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:36:34.644]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:36:34.644]  - attr(*, "where")=List of 2
[17:36:34.644]   ..$ ...          :<environment: 0x556d75c462e8> 
[17:36:34.644]   ..$ ...future.FUN:<environment: namespace:base> 
[17:36:34.644]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.644]  - attr(*, "resolved")= logi FALSE
[17:36:34.644]  - attr(*, "total_size")= num NA
[17:36:34.647] Packages to be attached in all futures: [n=0] 
[17:36:34.647] getGlobalsAndPackagesXApply() ... DONE
[17:36:34.647] Number of futures (= number of chunks): 1
[17:36:34.647] Launching 1 futures (chunks) ...
[17:36:34.647] Chunk #1 of 1 ...
[17:36:34.647]  - seeds: <none>
[17:36:34.648]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.648] getGlobalsAndPackages() ...
[17:36:34.648] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.648] Resolving globals: FALSE
[17:36:34.648] Tweak future expression to call with '...' arguments ...
[17:36:34.648] {
[17:36:34.648]     do.call(function(...) {
[17:36:34.648]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.648]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:34.648]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.648]             on.exit(options(oopts), add = TRUE)
[17:36:34.648]         }
[17:36:34.648]         {
[17:36:34.648]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:34.648]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.648]                 ...future.FUN(...future.X_jj, ...)
[17:36:34.648]             })
[17:36:34.648]         }
[17:36:34.648]     }, args = future.call.arguments)
[17:36:34.648] }
[17:36:34.648] Tweak future expression to call with '...' arguments ... DONE
[17:36:34.649] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.649] 
[17:36:34.649] getGlobalsAndPackages() ... DONE
[17:36:34.649] run() for ‘Future’ ...
[17:36:34.649] - state: ‘created’
[17:36:34.649] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:34.650] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:34.650] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:34.650]   - Field: ‘label’
[17:36:34.650]   - Field: ‘local’
[17:36:34.650]   - Field: ‘owner’
[17:36:34.650]   - Field: ‘envir’
[17:36:34.650]   - Field: ‘packages’
[17:36:34.650]   - Field: ‘gc’
[17:36:34.650]   - Field: ‘conditions’
[17:36:34.651]   - Field: ‘expr’
[17:36:34.651]   - Field: ‘uuid’
[17:36:34.651]   - Field: ‘seed’
[17:36:34.651]   - Field: ‘version’
[17:36:34.651]   - Field: ‘result’
[17:36:34.651]   - Field: ‘asynchronous’
[17:36:34.651]   - Field: ‘calls’
[17:36:34.651]   - Field: ‘globals’
[17:36:34.651]   - Field: ‘stdout’
[17:36:34.651]   - Field: ‘earlySignal’
[17:36:34.651]   - Field: ‘lazy’
[17:36:34.652]   - Field: ‘state’
[17:36:34.652] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:34.652] - Launch lazy future ...
[17:36:34.652] Packages needed by the future expression (n = 0): <none>
[17:36:34.652] Packages needed by future strategies (n = 0): <none>
[17:36:34.652] {
[17:36:34.652]     {
[17:36:34.652]         {
[17:36:34.652]             ...future.startTime <- base::Sys.time()
[17:36:34.652]             {
[17:36:34.652]                 {
[17:36:34.652]                   {
[17:36:34.652]                     base::local({
[17:36:34.652]                       has_future <- base::requireNamespace("future", 
[17:36:34.652]                         quietly = TRUE)
[17:36:34.652]                       if (has_future) {
[17:36:34.652]                         ns <- base::getNamespace("future")
[17:36:34.652]                         version <- ns[[".package"]][["version"]]
[17:36:34.652]                         if (is.null(version)) 
[17:36:34.652]                           version <- utils::packageVersion("future")
[17:36:34.652]                       }
[17:36:34.652]                       else {
[17:36:34.652]                         version <- NULL
[17:36:34.652]                       }
[17:36:34.652]                       if (!has_future || version < "1.8.0") {
[17:36:34.652]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:34.652]                           "", base::R.version$version.string), 
[17:36:34.652]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:34.652]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:34.652]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:34.652]                             "release", "version")], collapse = " "), 
[17:36:34.652]                           hostname = base::Sys.info()[["nodename"]])
[17:36:34.652]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:34.652]                           info)
[17:36:34.652]                         info <- base::paste(info, collapse = "; ")
[17:36:34.652]                         if (!has_future) {
[17:36:34.652]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:34.652]                             info)
[17:36:34.652]                         }
[17:36:34.652]                         else {
[17:36:34.652]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:34.652]                             info, version)
[17:36:34.652]                         }
[17:36:34.652]                         base::stop(msg)
[17:36:34.652]                       }
[17:36:34.652]                     })
[17:36:34.652]                   }
[17:36:34.652]                   ...future.strategy.old <- future::plan("list")
[17:36:34.652]                   options(future.plan = NULL)
[17:36:34.652]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:34.652]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:34.652]                 }
[17:36:34.652]                 ...future.workdir <- getwd()
[17:36:34.652]             }
[17:36:34.652]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:34.652]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:34.652]         }
[17:36:34.652]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:34.652]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:34.652]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:34.652]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:34.652]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:34.652]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:34.652]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:34.652]             base::names(...future.oldOptions))
[17:36:34.652]     }
[17:36:34.652]     if (FALSE) {
[17:36:34.652]     }
[17:36:34.652]     else {
[17:36:34.652]         if (TRUE) {
[17:36:34.652]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:34.652]                 open = "w")
[17:36:34.652]         }
[17:36:34.652]         else {
[17:36:34.652]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:34.652]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:34.652]         }
[17:36:34.652]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:34.652]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:34.652]             base::sink(type = "output", split = FALSE)
[17:36:34.652]             base::close(...future.stdout)
[17:36:34.652]         }, add = TRUE)
[17:36:34.652]     }
[17:36:34.652]     ...future.frame <- base::sys.nframe()
[17:36:34.652]     ...future.conditions <- base::list()
[17:36:34.652]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:34.652]     if (FALSE) {
[17:36:34.652]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:34.652]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:34.652]     }
[17:36:34.652]     ...future.result <- base::tryCatch({
[17:36:34.652]         base::withCallingHandlers({
[17:36:34.652]             ...future.value <- base::withVisible(base::local({
[17:36:34.652]                 do.call(function(...) {
[17:36:34.652]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.652]                   if (!identical(...future.globals.maxSize.org, 
[17:36:34.652]                     ...future.globals.maxSize)) {
[17:36:34.652]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.652]                     on.exit(options(oopts), add = TRUE)
[17:36:34.652]                   }
[17:36:34.652]                   {
[17:36:34.652]                     lapply(seq_along(...future.elements_ii), 
[17:36:34.652]                       FUN = function(jj) {
[17:36:34.652]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.652]                         ...future.FUN(...future.X_jj, ...)
[17:36:34.652]                       })
[17:36:34.652]                   }
[17:36:34.652]                 }, args = future.call.arguments)
[17:36:34.652]             }))
[17:36:34.652]             future::FutureResult(value = ...future.value$value, 
[17:36:34.652]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:34.652]                   ...future.rng), globalenv = if (FALSE) 
[17:36:34.652]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:34.652]                     ...future.globalenv.names))
[17:36:34.652]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:34.652]         }, condition = base::local({
[17:36:34.652]             c <- base::c
[17:36:34.652]             inherits <- base::inherits
[17:36:34.652]             invokeRestart <- base::invokeRestart
[17:36:34.652]             length <- base::length
[17:36:34.652]             list <- base::list
[17:36:34.652]             seq.int <- base::seq.int
[17:36:34.652]             signalCondition <- base::signalCondition
[17:36:34.652]             sys.calls <- base::sys.calls
[17:36:34.652]             `[[` <- base::`[[`
[17:36:34.652]             `+` <- base::`+`
[17:36:34.652]             `<<-` <- base::`<<-`
[17:36:34.652]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:34.652]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:34.652]                   3L)]
[17:36:34.652]             }
[17:36:34.652]             function(cond) {
[17:36:34.652]                 is_error <- inherits(cond, "error")
[17:36:34.652]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:34.652]                   NULL)
[17:36:34.652]                 if (is_error) {
[17:36:34.652]                   sessionInformation <- function() {
[17:36:34.652]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:34.652]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:34.652]                       search = base::search(), system = base::Sys.info())
[17:36:34.652]                   }
[17:36:34.652]                   ...future.conditions[[length(...future.conditions) + 
[17:36:34.652]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:34.652]                     cond$call), session = sessionInformation(), 
[17:36:34.652]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:34.652]                   signalCondition(cond)
[17:36:34.652]                 }
[17:36:34.652]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:34.652]                 "immediateCondition"))) {
[17:36:34.652]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:34.652]                   ...future.conditions[[length(...future.conditions) + 
[17:36:34.652]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:34.652]                   if (TRUE && !signal) {
[17:36:34.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:34.652]                     {
[17:36:34.652]                       inherits <- base::inherits
[17:36:34.652]                       invokeRestart <- base::invokeRestart
[17:36:34.652]                       is.null <- base::is.null
[17:36:34.652]                       muffled <- FALSE
[17:36:34.652]                       if (inherits(cond, "message")) {
[17:36:34.652]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:34.652]                         if (muffled) 
[17:36:34.652]                           invokeRestart("muffleMessage")
[17:36:34.652]                       }
[17:36:34.652]                       else if (inherits(cond, "warning")) {
[17:36:34.652]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:34.652]                         if (muffled) 
[17:36:34.652]                           invokeRestart("muffleWarning")
[17:36:34.652]                       }
[17:36:34.652]                       else if (inherits(cond, "condition")) {
[17:36:34.652]                         if (!is.null(pattern)) {
[17:36:34.652]                           computeRestarts <- base::computeRestarts
[17:36:34.652]                           grepl <- base::grepl
[17:36:34.652]                           restarts <- computeRestarts(cond)
[17:36:34.652]                           for (restart in restarts) {
[17:36:34.652]                             name <- restart$name
[17:36:34.652]                             if (is.null(name)) 
[17:36:34.652]                               next
[17:36:34.652]                             if (!grepl(pattern, name)) 
[17:36:34.652]                               next
[17:36:34.652]                             invokeRestart(restart)
[17:36:34.652]                             muffled <- TRUE
[17:36:34.652]                             break
[17:36:34.652]                           }
[17:36:34.652]                         }
[17:36:34.652]                       }
[17:36:34.652]                       invisible(muffled)
[17:36:34.652]                     }
[17:36:34.652]                     muffleCondition(cond, pattern = "^muffle")
[17:36:34.652]                   }
[17:36:34.652]                 }
[17:36:34.652]                 else {
[17:36:34.652]                   if (TRUE) {
[17:36:34.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:34.652]                     {
[17:36:34.652]                       inherits <- base::inherits
[17:36:34.652]                       invokeRestart <- base::invokeRestart
[17:36:34.652]                       is.null <- base::is.null
[17:36:34.652]                       muffled <- FALSE
[17:36:34.652]                       if (inherits(cond, "message")) {
[17:36:34.652]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:34.652]                         if (muffled) 
[17:36:34.652]                           invokeRestart("muffleMessage")
[17:36:34.652]                       }
[17:36:34.652]                       else if (inherits(cond, "warning")) {
[17:36:34.652]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:34.652]                         if (muffled) 
[17:36:34.652]                           invokeRestart("muffleWarning")
[17:36:34.652]                       }
[17:36:34.652]                       else if (inherits(cond, "condition")) {
[17:36:34.652]                         if (!is.null(pattern)) {
[17:36:34.652]                           computeRestarts <- base::computeRestarts
[17:36:34.652]                           grepl <- base::grepl
[17:36:34.652]                           restarts <- computeRestarts(cond)
[17:36:34.652]                           for (restart in restarts) {
[17:36:34.652]                             name <- restart$name
[17:36:34.652]                             if (is.null(name)) 
[17:36:34.652]                               next
[17:36:34.652]                             if (!grepl(pattern, name)) 
[17:36:34.652]                               next
[17:36:34.652]                             invokeRestart(restart)
[17:36:34.652]                             muffled <- TRUE
[17:36:34.652]                             break
[17:36:34.652]                           }
[17:36:34.652]                         }
[17:36:34.652]                       }
[17:36:34.652]                       invisible(muffled)
[17:36:34.652]                     }
[17:36:34.652]                     muffleCondition(cond, pattern = "^muffle")
[17:36:34.652]                   }
[17:36:34.652]                 }
[17:36:34.652]             }
[17:36:34.652]         }))
[17:36:34.652]     }, error = function(ex) {
[17:36:34.652]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:34.652]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:34.652]                 ...future.rng), started = ...future.startTime, 
[17:36:34.652]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:34.652]             version = "1.8"), class = "FutureResult")
[17:36:34.652]     }, finally = {
[17:36:34.652]         if (!identical(...future.workdir, getwd())) 
[17:36:34.652]             setwd(...future.workdir)
[17:36:34.652]         {
[17:36:34.652]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:34.652]                 ...future.oldOptions$nwarnings <- NULL
[17:36:34.652]             }
[17:36:34.652]             base::options(...future.oldOptions)
[17:36:34.652]             if (.Platform$OS.type == "windows") {
[17:36:34.652]                 old_names <- names(...future.oldEnvVars)
[17:36:34.652]                 envs <- base::Sys.getenv()
[17:36:34.652]                 names <- names(envs)
[17:36:34.652]                 common <- intersect(names, old_names)
[17:36:34.652]                 added <- setdiff(names, old_names)
[17:36:34.652]                 removed <- setdiff(old_names, names)
[17:36:34.652]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:34.652]                   envs[common]]
[17:36:34.652]                 NAMES <- toupper(changed)
[17:36:34.652]                 args <- list()
[17:36:34.652]                 for (kk in seq_along(NAMES)) {
[17:36:34.652]                   name <- changed[[kk]]
[17:36:34.652]                   NAME <- NAMES[[kk]]
[17:36:34.652]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.652]                     next
[17:36:34.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:34.652]                 }
[17:36:34.652]                 NAMES <- toupper(added)
[17:36:34.652]                 for (kk in seq_along(NAMES)) {
[17:36:34.652]                   name <- added[[kk]]
[17:36:34.652]                   NAME <- NAMES[[kk]]
[17:36:34.652]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.652]                     next
[17:36:34.652]                   args[[name]] <- ""
[17:36:34.652]                 }
[17:36:34.652]                 NAMES <- toupper(removed)
[17:36:34.652]                 for (kk in seq_along(NAMES)) {
[17:36:34.652]                   name <- removed[[kk]]
[17:36:34.652]                   NAME <- NAMES[[kk]]
[17:36:34.652]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.652]                     next
[17:36:34.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:34.652]                 }
[17:36:34.652]                 if (length(args) > 0) 
[17:36:34.652]                   base::do.call(base::Sys.setenv, args = args)
[17:36:34.652]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:34.652]             }
[17:36:34.652]             else {
[17:36:34.652]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:34.652]             }
[17:36:34.652]             {
[17:36:34.652]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:34.652]                   0L) {
[17:36:34.652]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:34.652]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:34.652]                   base::options(opts)
[17:36:34.652]                 }
[17:36:34.652]                 {
[17:36:34.652]                   {
[17:36:34.652]                     NULL
[17:36:34.652]                     RNGkind("Mersenne-Twister")
[17:36:34.652]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:34.652]                       inherits = FALSE)
[17:36:34.652]                   }
[17:36:34.652]                   options(future.plan = NULL)
[17:36:34.652]                   if (is.na(NA_character_)) 
[17:36:34.652]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:34.652]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:34.652]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:34.652]                     .init = FALSE)
[17:36:34.652]                 }
[17:36:34.652]             }
[17:36:34.652]         }
[17:36:34.652]     })
[17:36:34.652]     if (TRUE) {
[17:36:34.652]         base::sink(type = "output", split = FALSE)
[17:36:34.652]         if (TRUE) {
[17:36:34.652]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:34.652]         }
[17:36:34.652]         else {
[17:36:34.652]             ...future.result["stdout"] <- base::list(NULL)
[17:36:34.652]         }
[17:36:34.652]         base::close(...future.stdout)
[17:36:34.652]         ...future.stdout <- NULL
[17:36:34.652]     }
[17:36:34.652]     ...future.result$conditions <- ...future.conditions
[17:36:34.652]     ...future.result$finished <- base::Sys.time()
[17:36:34.652]     ...future.result
[17:36:34.652] }
[17:36:34.654] assign_globals() ...
[17:36:34.654] List of 5
[17:36:34.654]  $ future.call.arguments    : list()
[17:36:34.654]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.654]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:36:34.654]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:36:34.654]  $ ...future.elements_ii    :List of 2
[17:36:34.654]   ..$ : num [1:4] 1 3 1 7
[17:36:34.654]   ..$ : num [1:4] 2 4 6 8
[17:36:34.654]  $ ...future.seeds_ii       : NULL
[17:36:34.654]  $ ...future.globals.maxSize: num Inf
[17:36:34.654]  - attr(*, "resolved")= logi FALSE
[17:36:34.654]  - attr(*, "total_size")= num NA
[17:36:34.654]  - attr(*, "where")=List of 5
[17:36:34.654]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:34.654]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:34.654]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:34.654]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:34.654]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:34.654]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.654]  - attr(*, "already-done")= logi TRUE
[17:36:34.660] - copied ‘future.call.arguments’ to environment
[17:36:34.660] - copied ‘...future.FUN’ to environment
[17:36:34.661] - copied ‘...future.elements_ii’ to environment
[17:36:34.661] - copied ‘...future.seeds_ii’ to environment
[17:36:34.661] - copied ‘...future.globals.maxSize’ to environment
[17:36:34.661] assign_globals() ... done
[17:36:34.661] plan(): Setting new future strategy stack:
[17:36:34.661] List of future strategies:
[17:36:34.661] 1. sequential:
[17:36:34.661]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:34.661]    - tweaked: FALSE
[17:36:34.661]    - call: NULL
[17:36:34.662] plan(): nbrOfWorkers() = 1
[17:36:34.662] plan(): Setting new future strategy stack:
[17:36:34.663] List of future strategies:
[17:36:34.663] 1. sequential:
[17:36:34.663]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:34.663]    - tweaked: FALSE
[17:36:34.663]    - call: plan(strategy)
[17:36:34.663] plan(): nbrOfWorkers() = 1
[17:36:34.663] SequentialFuture started (and completed)
[17:36:34.663] - Launch lazy future ... done
[17:36:34.663] run() for ‘SequentialFuture’ ... done
[17:36:34.663] Created future:
[17:36:34.664] SequentialFuture:
[17:36:34.664] Label: ‘future_apply-1’
[17:36:34.664] Expression:
[17:36:34.664] {
[17:36:34.664]     do.call(function(...) {
[17:36:34.664]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.664]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:34.664]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.664]             on.exit(options(oopts), add = TRUE)
[17:36:34.664]         }
[17:36:34.664]         {
[17:36:34.664]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:34.664]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.664]                 ...future.FUN(...future.X_jj, ...)
[17:36:34.664]             })
[17:36:34.664]         }
[17:36:34.664]     }, args = future.call.arguments)
[17:36:34.664] }
[17:36:34.664] Lazy evaluation: FALSE
[17:36:34.664] Asynchronous evaluation: FALSE
[17:36:34.664] Local evaluation: TRUE
[17:36:34.664] Environment: R_GlobalEnv
[17:36:34.664] Capture standard output: TRUE
[17:36:34.664] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:34.664] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:34.664] Packages: <none>
[17:36:34.664] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:34.664] Resolved: TRUE
[17:36:34.664] Value: 2.21 KiB of class ‘list’
[17:36:34.664] Early signaling: FALSE
[17:36:34.664] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:34.664] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:34.665] Chunk #1 of 1 ... DONE
[17:36:34.665] Launching 1 futures (chunks) ... DONE
[17:36:34.665] Resolving 1 futures (chunks) ...
[17:36:34.665] resolve() on list ...
[17:36:34.665]  recursive: 0
[17:36:34.665]  length: 1
[17:36:34.665] 
[17:36:34.665] resolved() for ‘SequentialFuture’ ...
[17:36:34.665] - state: ‘finished’
[17:36:34.666] - run: TRUE
[17:36:34.666] - result: ‘FutureResult’
[17:36:34.666] resolved() for ‘SequentialFuture’ ... done
[17:36:34.666] Future #1
[17:36:34.666] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:34.666] - nx: 1
[17:36:34.666] - relay: TRUE
[17:36:34.666] - stdout: TRUE
[17:36:34.666] - signal: TRUE
[17:36:34.666] - resignal: FALSE
[17:36:34.666] - force: TRUE
[17:36:34.666] - relayed: [n=1] FALSE
[17:36:34.667] - queued futures: [n=1] FALSE
[17:36:34.667]  - until=1
[17:36:34.667]  - relaying element #1
[17:36:34.667] - relayed: [n=1] TRUE
[17:36:34.667] - queued futures: [n=1] TRUE
[17:36:34.667] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:34.667]  length: 0 (resolved future 1)
[17:36:34.667] Relaying remaining futures
[17:36:34.667] signalConditionsASAP(NULL, pos=0) ...
[17:36:34.667] - nx: 1
[17:36:34.668] - relay: TRUE
[17:36:34.668] - stdout: TRUE
[17:36:34.668] - signal: TRUE
[17:36:34.668] - resignal: FALSE
[17:36:34.668] - force: TRUE
[17:36:34.668] - relayed: [n=1] TRUE
[17:36:34.668] - queued futures: [n=1] TRUE
 - flush all
[17:36:34.668] - relayed: [n=1] TRUE
[17:36:34.668] - queued futures: [n=1] TRUE
[17:36:34.668] signalConditionsASAP(NULL, pos=0) ... done
[17:36:34.668] resolve() on list ... DONE
[17:36:34.669]  - Number of value chunks collected: 1
[17:36:34.669] Resolving 1 futures (chunks) ... DONE
[17:36:34.669] Reducing values from 1 chunks ...
[17:36:34.669]  - Number of values collected after concatenation: 2
[17:36:34.669]  - Number of values expected: 2
[17:36:34.669] Reducing values from 1 chunks ... DONE
[17:36:34.669] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:36:34.671] getGlobalsAndPackagesXApply() ...
[17:36:34.671]  - future.globals: TRUE
[17:36:34.671] getGlobalsAndPackages() ...
[17:36:34.672] Searching for globals...
[17:36:34.673] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:34.673] Searching for globals ... DONE
[17:36:34.673] Resolving globals: FALSE
[17:36:34.673] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:36:34.673] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:36:34.674] - globals: [1] ‘FUN’
[17:36:34.674] - packages: [1] ‘stats’
[17:36:34.674] getGlobalsAndPackages() ... DONE
[17:36:34.674]  - globals found/used: [n=1] ‘FUN’
[17:36:34.674]  - needed namespaces: [n=1] ‘stats’
[17:36:34.674] Finding globals ... DONE
[17:36:34.674]  - use_args: TRUE
[17:36:34.674]  - Getting '...' globals ...
[17:36:34.675] resolve() on list ...
[17:36:34.675]  recursive: 0
[17:36:34.675]  length: 1
[17:36:34.675]  elements: ‘...’
[17:36:34.675]  length: 0 (resolved future 1)
[17:36:34.675] resolve() on list ... DONE
[17:36:34.675]    - '...' content: [n=0] 
[17:36:34.675] List of 1
[17:36:34.675]  $ ...: list()
[17:36:34.675]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.675]  - attr(*, "where")=List of 1
[17:36:34.675]   ..$ ...:<environment: 0x556d759ba8b0> 
[17:36:34.675]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.675]  - attr(*, "resolved")= logi TRUE
[17:36:34.675]  - attr(*, "total_size")= num NA
[17:36:34.678]  - Getting '...' globals ... DONE
[17:36:34.678] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:34.678] List of 2
[17:36:34.678]  $ ...future.FUN:function (x, ...)  
[17:36:34.678]  $ ...          : list()
[17:36:34.678]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.678]  - attr(*, "where")=List of 2
[17:36:34.678]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:34.678]   ..$ ...          :<environment: 0x556d759ba8b0> 
[17:36:34.678]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.678]  - attr(*, "resolved")= logi FALSE
[17:36:34.678]  - attr(*, "total_size")= num 1248
[17:36:34.680] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:34.680] getGlobalsAndPackagesXApply() ... DONE
[17:36:34.681] future_lapply() ...
[17:36:34.682] Number of chunks: 1
[17:36:34.683] getGlobalsAndPackagesXApply() ...
[17:36:34.683]  - future.globals: <name-value list> with names ‘list()’
[17:36:34.683]  - use_args: TRUE
[17:36:34.683] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:34.683] List of 2
[17:36:34.683]  $ ...          : list()
[17:36:34.683]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.683]  $ ...future.FUN:function (x, ...)  
[17:36:34.683]  - attr(*, "where")=List of 2
[17:36:34.683]   ..$ ...          :<environment: 0x556d759ba8b0> 
[17:36:34.683]   ..$ ...future.FUN:<environment: namespace:stats> 
[17:36:34.683]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.683]  - attr(*, "resolved")= logi FALSE
[17:36:34.683]  - attr(*, "total_size")= num NA
[17:36:34.686] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:34.686] getGlobalsAndPackagesXApply() ... DONE
[17:36:34.686] Number of futures (= number of chunks): 1
[17:36:34.686] Launching 1 futures (chunks) ...
[17:36:34.686] Chunk #1 of 1 ...
[17:36:34.686]  - seeds: <none>
[17:36:34.686]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.687] getGlobalsAndPackages() ...
[17:36:34.687] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.687] Resolving globals: FALSE
[17:36:34.687] Tweak future expression to call with '...' arguments ...
[17:36:34.687] {
[17:36:34.687]     do.call(function(...) {
[17:36:34.687]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.687]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:34.687]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.687]             on.exit(options(oopts), add = TRUE)
[17:36:34.687]         }
[17:36:34.687]         {
[17:36:34.687]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:34.687]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.687]                 ...future.FUN(...future.X_jj, ...)
[17:36:34.687]             })
[17:36:34.687]         }
[17:36:34.687]     }, args = future.call.arguments)
[17:36:34.687] }
[17:36:34.687] Tweak future expression to call with '...' arguments ... DONE
[17:36:34.688] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.688] - packages: [1] ‘stats’
[17:36:34.688] getGlobalsAndPackages() ... DONE
[17:36:34.688] run() for ‘Future’ ...
[17:36:34.688] - state: ‘created’
[17:36:34.688] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:34.689] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:34.689] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:34.689]   - Field: ‘label’
[17:36:34.689]   - Field: ‘local’
[17:36:34.689]   - Field: ‘owner’
[17:36:34.689]   - Field: ‘envir’
[17:36:34.689]   - Field: ‘packages’
[17:36:34.689]   - Field: ‘gc’
[17:36:34.689]   - Field: ‘conditions’
[17:36:34.690]   - Field: ‘expr’
[17:36:34.690]   - Field: ‘uuid’
[17:36:34.690]   - Field: ‘seed’
[17:36:34.690]   - Field: ‘version’
[17:36:34.690]   - Field: ‘result’
[17:36:34.690]   - Field: ‘asynchronous’
[17:36:34.690]   - Field: ‘calls’
[17:36:34.690]   - Field: ‘globals’
[17:36:34.690]   - Field: ‘stdout’
[17:36:34.690]   - Field: ‘earlySignal’
[17:36:34.690]   - Field: ‘lazy’
[17:36:34.691]   - Field: ‘state’
[17:36:34.691] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:34.691] - Launch lazy future ...
[17:36:34.691] Packages needed by the future expression (n = 1): ‘stats’
[17:36:34.691] Packages needed by future strategies (n = 0): <none>
[17:36:34.692] {
[17:36:34.692]     {
[17:36:34.692]         {
[17:36:34.692]             ...future.startTime <- base::Sys.time()
[17:36:34.692]             {
[17:36:34.692]                 {
[17:36:34.692]                   {
[17:36:34.692]                     {
[17:36:34.692]                       base::local({
[17:36:34.692]                         has_future <- base::requireNamespace("future", 
[17:36:34.692]                           quietly = TRUE)
[17:36:34.692]                         if (has_future) {
[17:36:34.692]                           ns <- base::getNamespace("future")
[17:36:34.692]                           version <- ns[[".package"]][["version"]]
[17:36:34.692]                           if (is.null(version)) 
[17:36:34.692]                             version <- utils::packageVersion("future")
[17:36:34.692]                         }
[17:36:34.692]                         else {
[17:36:34.692]                           version <- NULL
[17:36:34.692]                         }
[17:36:34.692]                         if (!has_future || version < "1.8.0") {
[17:36:34.692]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:34.692]                             "", base::R.version$version.string), 
[17:36:34.692]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:34.692]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:34.692]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:34.692]                               "release", "version")], collapse = " "), 
[17:36:34.692]                             hostname = base::Sys.info()[["nodename"]])
[17:36:34.692]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:34.692]                             info)
[17:36:34.692]                           info <- base::paste(info, collapse = "; ")
[17:36:34.692]                           if (!has_future) {
[17:36:34.692]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:34.692]                               info)
[17:36:34.692]                           }
[17:36:34.692]                           else {
[17:36:34.692]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:34.692]                               info, version)
[17:36:34.692]                           }
[17:36:34.692]                           base::stop(msg)
[17:36:34.692]                         }
[17:36:34.692]                       })
[17:36:34.692]                     }
[17:36:34.692]                     base::local({
[17:36:34.692]                       for (pkg in "stats") {
[17:36:34.692]                         base::loadNamespace(pkg)
[17:36:34.692]                         base::library(pkg, character.only = TRUE)
[17:36:34.692]                       }
[17:36:34.692]                     })
[17:36:34.692]                   }
[17:36:34.692]                   ...future.strategy.old <- future::plan("list")
[17:36:34.692]                   options(future.plan = NULL)
[17:36:34.692]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:34.692]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:34.692]                 }
[17:36:34.692]                 ...future.workdir <- getwd()
[17:36:34.692]             }
[17:36:34.692]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:34.692]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:34.692]         }
[17:36:34.692]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:34.692]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:34.692]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:34.692]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:34.692]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:34.692]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:34.692]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:34.692]             base::names(...future.oldOptions))
[17:36:34.692]     }
[17:36:34.692]     if (FALSE) {
[17:36:34.692]     }
[17:36:34.692]     else {
[17:36:34.692]         if (TRUE) {
[17:36:34.692]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:34.692]                 open = "w")
[17:36:34.692]         }
[17:36:34.692]         else {
[17:36:34.692]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:34.692]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:34.692]         }
[17:36:34.692]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:34.692]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:34.692]             base::sink(type = "output", split = FALSE)
[17:36:34.692]             base::close(...future.stdout)
[17:36:34.692]         }, add = TRUE)
[17:36:34.692]     }
[17:36:34.692]     ...future.frame <- base::sys.nframe()
[17:36:34.692]     ...future.conditions <- base::list()
[17:36:34.692]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:34.692]     if (FALSE) {
[17:36:34.692]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:34.692]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:34.692]     }
[17:36:34.692]     ...future.result <- base::tryCatch({
[17:36:34.692]         base::withCallingHandlers({
[17:36:34.692]             ...future.value <- base::withVisible(base::local({
[17:36:34.692]                 do.call(function(...) {
[17:36:34.692]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.692]                   if (!identical(...future.globals.maxSize.org, 
[17:36:34.692]                     ...future.globals.maxSize)) {
[17:36:34.692]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.692]                     on.exit(options(oopts), add = TRUE)
[17:36:34.692]                   }
[17:36:34.692]                   {
[17:36:34.692]                     lapply(seq_along(...future.elements_ii), 
[17:36:34.692]                       FUN = function(jj) {
[17:36:34.692]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.692]                         ...future.FUN(...future.X_jj, ...)
[17:36:34.692]                       })
[17:36:34.692]                   }
[17:36:34.692]                 }, args = future.call.arguments)
[17:36:34.692]             }))
[17:36:34.692]             future::FutureResult(value = ...future.value$value, 
[17:36:34.692]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:34.692]                   ...future.rng), globalenv = if (FALSE) 
[17:36:34.692]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:34.692]                     ...future.globalenv.names))
[17:36:34.692]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:34.692]         }, condition = base::local({
[17:36:34.692]             c <- base::c
[17:36:34.692]             inherits <- base::inherits
[17:36:34.692]             invokeRestart <- base::invokeRestart
[17:36:34.692]             length <- base::length
[17:36:34.692]             list <- base::list
[17:36:34.692]             seq.int <- base::seq.int
[17:36:34.692]             signalCondition <- base::signalCondition
[17:36:34.692]             sys.calls <- base::sys.calls
[17:36:34.692]             `[[` <- base::`[[`
[17:36:34.692]             `+` <- base::`+`
[17:36:34.692]             `<<-` <- base::`<<-`
[17:36:34.692]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:34.692]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:34.692]                   3L)]
[17:36:34.692]             }
[17:36:34.692]             function(cond) {
[17:36:34.692]                 is_error <- inherits(cond, "error")
[17:36:34.692]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:34.692]                   NULL)
[17:36:34.692]                 if (is_error) {
[17:36:34.692]                   sessionInformation <- function() {
[17:36:34.692]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:34.692]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:34.692]                       search = base::search(), system = base::Sys.info())
[17:36:34.692]                   }
[17:36:34.692]                   ...future.conditions[[length(...future.conditions) + 
[17:36:34.692]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:34.692]                     cond$call), session = sessionInformation(), 
[17:36:34.692]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:34.692]                   signalCondition(cond)
[17:36:34.692]                 }
[17:36:34.692]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:34.692]                 "immediateCondition"))) {
[17:36:34.692]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:34.692]                   ...future.conditions[[length(...future.conditions) + 
[17:36:34.692]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:34.692]                   if (TRUE && !signal) {
[17:36:34.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:34.692]                     {
[17:36:34.692]                       inherits <- base::inherits
[17:36:34.692]                       invokeRestart <- base::invokeRestart
[17:36:34.692]                       is.null <- base::is.null
[17:36:34.692]                       muffled <- FALSE
[17:36:34.692]                       if (inherits(cond, "message")) {
[17:36:34.692]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:34.692]                         if (muffled) 
[17:36:34.692]                           invokeRestart("muffleMessage")
[17:36:34.692]                       }
[17:36:34.692]                       else if (inherits(cond, "warning")) {
[17:36:34.692]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:34.692]                         if (muffled) 
[17:36:34.692]                           invokeRestart("muffleWarning")
[17:36:34.692]                       }
[17:36:34.692]                       else if (inherits(cond, "condition")) {
[17:36:34.692]                         if (!is.null(pattern)) {
[17:36:34.692]                           computeRestarts <- base::computeRestarts
[17:36:34.692]                           grepl <- base::grepl
[17:36:34.692]                           restarts <- computeRestarts(cond)
[17:36:34.692]                           for (restart in restarts) {
[17:36:34.692]                             name <- restart$name
[17:36:34.692]                             if (is.null(name)) 
[17:36:34.692]                               next
[17:36:34.692]                             if (!grepl(pattern, name)) 
[17:36:34.692]                               next
[17:36:34.692]                             invokeRestart(restart)
[17:36:34.692]                             muffled <- TRUE
[17:36:34.692]                             break
[17:36:34.692]                           }
[17:36:34.692]                         }
[17:36:34.692]                       }
[17:36:34.692]                       invisible(muffled)
[17:36:34.692]                     }
[17:36:34.692]                     muffleCondition(cond, pattern = "^muffle")
[17:36:34.692]                   }
[17:36:34.692]                 }
[17:36:34.692]                 else {
[17:36:34.692]                   if (TRUE) {
[17:36:34.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:34.692]                     {
[17:36:34.692]                       inherits <- base::inherits
[17:36:34.692]                       invokeRestart <- base::invokeRestart
[17:36:34.692]                       is.null <- base::is.null
[17:36:34.692]                       muffled <- FALSE
[17:36:34.692]                       if (inherits(cond, "message")) {
[17:36:34.692]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:34.692]                         if (muffled) 
[17:36:34.692]                           invokeRestart("muffleMessage")
[17:36:34.692]                       }
[17:36:34.692]                       else if (inherits(cond, "warning")) {
[17:36:34.692]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:34.692]                         if (muffled) 
[17:36:34.692]                           invokeRestart("muffleWarning")
[17:36:34.692]                       }
[17:36:34.692]                       else if (inherits(cond, "condition")) {
[17:36:34.692]                         if (!is.null(pattern)) {
[17:36:34.692]                           computeRestarts <- base::computeRestarts
[17:36:34.692]                           grepl <- base::grepl
[17:36:34.692]                           restarts <- computeRestarts(cond)
[17:36:34.692]                           for (restart in restarts) {
[17:36:34.692]                             name <- restart$name
[17:36:34.692]                             if (is.null(name)) 
[17:36:34.692]                               next
[17:36:34.692]                             if (!grepl(pattern, name)) 
[17:36:34.692]                               next
[17:36:34.692]                             invokeRestart(restart)
[17:36:34.692]                             muffled <- TRUE
[17:36:34.692]                             break
[17:36:34.692]                           }
[17:36:34.692]                         }
[17:36:34.692]                       }
[17:36:34.692]                       invisible(muffled)
[17:36:34.692]                     }
[17:36:34.692]                     muffleCondition(cond, pattern = "^muffle")
[17:36:34.692]                   }
[17:36:34.692]                 }
[17:36:34.692]             }
[17:36:34.692]         }))
[17:36:34.692]     }, error = function(ex) {
[17:36:34.692]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:34.692]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:34.692]                 ...future.rng), started = ...future.startTime, 
[17:36:34.692]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:34.692]             version = "1.8"), class = "FutureResult")
[17:36:34.692]     }, finally = {
[17:36:34.692]         if (!identical(...future.workdir, getwd())) 
[17:36:34.692]             setwd(...future.workdir)
[17:36:34.692]         {
[17:36:34.692]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:34.692]                 ...future.oldOptions$nwarnings <- NULL
[17:36:34.692]             }
[17:36:34.692]             base::options(...future.oldOptions)
[17:36:34.692]             if (.Platform$OS.type == "windows") {
[17:36:34.692]                 old_names <- names(...future.oldEnvVars)
[17:36:34.692]                 envs <- base::Sys.getenv()
[17:36:34.692]                 names <- names(envs)
[17:36:34.692]                 common <- intersect(names, old_names)
[17:36:34.692]                 added <- setdiff(names, old_names)
[17:36:34.692]                 removed <- setdiff(old_names, names)
[17:36:34.692]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:34.692]                   envs[common]]
[17:36:34.692]                 NAMES <- toupper(changed)
[17:36:34.692]                 args <- list()
[17:36:34.692]                 for (kk in seq_along(NAMES)) {
[17:36:34.692]                   name <- changed[[kk]]
[17:36:34.692]                   NAME <- NAMES[[kk]]
[17:36:34.692]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.692]                     next
[17:36:34.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:34.692]                 }
[17:36:34.692]                 NAMES <- toupper(added)
[17:36:34.692]                 for (kk in seq_along(NAMES)) {
[17:36:34.692]                   name <- added[[kk]]
[17:36:34.692]                   NAME <- NAMES[[kk]]
[17:36:34.692]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.692]                     next
[17:36:34.692]                   args[[name]] <- ""
[17:36:34.692]                 }
[17:36:34.692]                 NAMES <- toupper(removed)
[17:36:34.692]                 for (kk in seq_along(NAMES)) {
[17:36:34.692]                   name <- removed[[kk]]
[17:36:34.692]                   NAME <- NAMES[[kk]]
[17:36:34.692]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.692]                     next
[17:36:34.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:34.692]                 }
[17:36:34.692]                 if (length(args) > 0) 
[17:36:34.692]                   base::do.call(base::Sys.setenv, args = args)
[17:36:34.692]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:34.692]             }
[17:36:34.692]             else {
[17:36:34.692]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:34.692]             }
[17:36:34.692]             {
[17:36:34.692]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:34.692]                   0L) {
[17:36:34.692]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:34.692]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:34.692]                   base::options(opts)
[17:36:34.692]                 }
[17:36:34.692]                 {
[17:36:34.692]                   {
[17:36:34.692]                     NULL
[17:36:34.692]                     RNGkind("Mersenne-Twister")
[17:36:34.692]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:34.692]                       inherits = FALSE)
[17:36:34.692]                   }
[17:36:34.692]                   options(future.plan = NULL)
[17:36:34.692]                   if (is.na(NA_character_)) 
[17:36:34.692]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:34.692]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:34.692]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:34.692]                     .init = FALSE)
[17:36:34.692]                 }
[17:36:34.692]             }
[17:36:34.692]         }
[17:36:34.692]     })
[17:36:34.692]     if (TRUE) {
[17:36:34.692]         base::sink(type = "output", split = FALSE)
[17:36:34.692]         if (TRUE) {
[17:36:34.692]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:34.692]         }
[17:36:34.692]         else {
[17:36:34.692]             ...future.result["stdout"] <- base::list(NULL)
[17:36:34.692]         }
[17:36:34.692]         base::close(...future.stdout)
[17:36:34.692]         ...future.stdout <- NULL
[17:36:34.692]     }
[17:36:34.692]     ...future.result$conditions <- ...future.conditions
[17:36:34.692]     ...future.result$finished <- base::Sys.time()
[17:36:34.692]     ...future.result
[17:36:34.692] }
[17:36:34.693] assign_globals() ...
[17:36:34.693] List of 5
[17:36:34.693]  $ future.call.arguments    : list()
[17:36:34.693]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.693]  $ ...future.FUN            :function (x, ...)  
[17:36:34.693]  $ ...future.elements_ii    :List of 2
[17:36:34.693]   ..$ : num [1:4] 1 3 1 7
[17:36:34.693]   ..$ : num [1:4] 2 4 6 8
[17:36:34.693]  $ ...future.seeds_ii       : NULL
[17:36:34.693]  $ ...future.globals.maxSize: num Inf
[17:36:34.693]  - attr(*, "resolved")= logi FALSE
[17:36:34.693]  - attr(*, "total_size")= num NA
[17:36:34.693]  - attr(*, "where")=List of 5
[17:36:34.693]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:34.693]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:34.693]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:34.693]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:34.693]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:34.693]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.693]  - attr(*, "already-done")= logi TRUE
[17:36:34.698] - copied ‘future.call.arguments’ to environment
[17:36:34.698] - copied ‘...future.FUN’ to environment
[17:36:34.699] - copied ‘...future.elements_ii’ to environment
[17:36:34.699] - copied ‘...future.seeds_ii’ to environment
[17:36:34.699] - copied ‘...future.globals.maxSize’ to environment
[17:36:34.699] assign_globals() ... done
[17:36:34.699] plan(): Setting new future strategy stack:
[17:36:34.699] List of future strategies:
[17:36:34.699] 1. sequential:
[17:36:34.699]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:34.699]    - tweaked: FALSE
[17:36:34.699]    - call: NULL
[17:36:34.700] plan(): nbrOfWorkers() = 1
[17:36:34.701] plan(): Setting new future strategy stack:
[17:36:34.701] List of future strategies:
[17:36:34.701] 1. sequential:
[17:36:34.701]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:34.701]    - tweaked: FALSE
[17:36:34.701]    - call: plan(strategy)
[17:36:34.701] plan(): nbrOfWorkers() = 1
[17:36:34.702] SequentialFuture started (and completed)
[17:36:34.702] - Launch lazy future ... done
[17:36:34.702] run() for ‘SequentialFuture’ ... done
[17:36:34.702] Created future:
[17:36:34.702] SequentialFuture:
[17:36:34.702] Label: ‘future_apply-1’
[17:36:34.702] Expression:
[17:36:34.702] {
[17:36:34.702]     do.call(function(...) {
[17:36:34.702]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.702]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:34.702]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.702]             on.exit(options(oopts), add = TRUE)
[17:36:34.702]         }
[17:36:34.702]         {
[17:36:34.702]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:34.702]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.702]                 ...future.FUN(...future.X_jj, ...)
[17:36:34.702]             })
[17:36:34.702]         }
[17:36:34.702]     }, args = future.call.arguments)
[17:36:34.702] }
[17:36:34.702] Lazy evaluation: FALSE
[17:36:34.702] Asynchronous evaluation: FALSE
[17:36:34.702] Local evaluation: TRUE
[17:36:34.702] Environment: R_GlobalEnv
[17:36:34.702] Capture standard output: TRUE
[17:36:34.702] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:34.702] Globals: 5 objects totaling 1.43 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:34.702] Packages: 1 packages (‘stats’)
[17:36:34.702] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:34.702] Resolved: TRUE
[17:36:34.702] Value: 1.14 KiB of class ‘list’
[17:36:34.702] Early signaling: FALSE
[17:36:34.702] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:34.702] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:34.703] Chunk #1 of 1 ... DONE
[17:36:34.703] Launching 1 futures (chunks) ... DONE
[17:36:34.703] Resolving 1 futures (chunks) ...
[17:36:34.703] resolve() on list ...
[17:36:34.703]  recursive: 0
[17:36:34.704]  length: 1
[17:36:34.704] 
[17:36:34.704] resolved() for ‘SequentialFuture’ ...
[17:36:34.704] - state: ‘finished’
[17:36:34.704] - run: TRUE
[17:36:34.704] - result: ‘FutureResult’
[17:36:34.704] resolved() for ‘SequentialFuture’ ... done
[17:36:34.704] Future #1
[17:36:34.704] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:34.704] - nx: 1
[17:36:34.705] - relay: TRUE
[17:36:34.705] - stdout: TRUE
[17:36:34.705] - signal: TRUE
[17:36:34.705] - resignal: FALSE
[17:36:34.705] - force: TRUE
[17:36:34.705] - relayed: [n=1] FALSE
[17:36:34.705] - queued futures: [n=1] FALSE
[17:36:34.705]  - until=1
[17:36:34.705]  - relaying element #1
[17:36:34.705] - relayed: [n=1] TRUE
[17:36:34.706] - queued futures: [n=1] TRUE
[17:36:34.706] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:34.706]  length: 0 (resolved future 1)
[17:36:34.706] Relaying remaining futures
[17:36:34.706] signalConditionsASAP(NULL, pos=0) ...
[17:36:34.706] - nx: 1
[17:36:34.706] - relay: TRUE
[17:36:34.706] - stdout: TRUE
[17:36:34.706] - signal: TRUE
[17:36:34.708] - resignal: FALSE
[17:36:34.708] - force: TRUE
[17:36:34.708] - relayed: [n=1] TRUE
[17:36:34.708] - queued futures: [n=1] TRUE
 - flush all
[17:36:34.708] - relayed: [n=1] TRUE
[17:36:34.708] - queued futures: [n=1] TRUE
[17:36:34.708] signalConditionsASAP(NULL, pos=0) ... done
[17:36:34.709] resolve() on list ... DONE
[17:36:34.709]  - Number of value chunks collected: 1
[17:36:34.709] Resolving 1 futures (chunks) ... DONE
[17:36:34.709] Reducing values from 1 chunks ...
[17:36:34.709]  - Number of values collected after concatenation: 2
[17:36:34.709]  - Number of values expected: 2
[17:36:34.709] Reducing values from 1 chunks ... DONE
[17:36:34.709] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[17:36:34.710] getGlobalsAndPackagesXApply() ...
[17:36:34.710]  - future.globals: TRUE
[17:36:34.710] getGlobalsAndPackages() ...
[17:36:34.710] Searching for globals...
[17:36:34.711] - globals found: [1] ‘FUN’
[17:36:34.711] Searching for globals ... DONE
[17:36:34.711] Resolving globals: FALSE
[17:36:34.712] The total size of the 1 globals is 848 bytes (848 bytes)
[17:36:34.712] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:36:34.712] - globals: [1] ‘FUN’
[17:36:34.712] 
[17:36:34.712] getGlobalsAndPackages() ... DONE
[17:36:34.712]  - globals found/used: [n=1] ‘FUN’
[17:36:34.713]  - needed namespaces: [n=0] 
[17:36:34.713] Finding globals ... DONE
[17:36:34.713]  - use_args: TRUE
[17:36:34.713]  - Getting '...' globals ...
[17:36:34.713] resolve() on list ...
[17:36:34.713]  recursive: 0
[17:36:34.713]  length: 1
[17:36:34.713]  elements: ‘...’
[17:36:34.714]  length: 0 (resolved future 1)
[17:36:34.714] resolve() on list ... DONE
[17:36:34.714]    - '...' content: [n=0] 
[17:36:34.714] List of 1
[17:36:34.714]  $ ...: list()
[17:36:34.714]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.714]  - attr(*, "where")=List of 1
[17:36:34.714]   ..$ ...:<environment: 0x556d74229138> 
[17:36:34.714]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.714]  - attr(*, "resolved")= logi TRUE
[17:36:34.714]  - attr(*, "total_size")= num NA
[17:36:34.716]  - Getting '...' globals ... DONE
[17:36:34.716] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:34.716] List of 2
[17:36:34.716]  $ ...future.FUN:function (x)  
[17:36:34.716]  $ ...          : list()
[17:36:34.716]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.716]  - attr(*, "where")=List of 2
[17:36:34.716]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:34.716]   ..$ ...          :<environment: 0x556d74229138> 
[17:36:34.716]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.716]  - attr(*, "resolved")= logi FALSE
[17:36:34.716]  - attr(*, "total_size")= num 848
[17:36:34.719] Packages to be attached in all futures: [n=0] 
[17:36:34.719] getGlobalsAndPackagesXApply() ... DONE
[17:36:34.719] future_lapply() ...
[17:36:34.720] Number of chunks: 1
[17:36:34.720] getGlobalsAndPackagesXApply() ...
[17:36:34.720]  - future.globals: <name-value list> with names ‘list()’
[17:36:34.720]  - use_args: TRUE
[17:36:34.720] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:34.720] List of 2
[17:36:34.720]  $ ...          : list()
[17:36:34.720]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.720]  $ ...future.FUN:function (x)  
[17:36:34.720]  - attr(*, "where")=List of 2
[17:36:34.720]   ..$ ...          :<environment: 0x556d74229138> 
[17:36:34.720]   ..$ ...future.FUN:<environment: namespace:base> 
[17:36:34.720]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.720]  - attr(*, "resolved")= logi FALSE
[17:36:34.720]  - attr(*, "total_size")= num NA
[17:36:34.723] Packages to be attached in all futures: [n=0] 
[17:36:34.724] getGlobalsAndPackagesXApply() ... DONE
[17:36:34.724] Number of futures (= number of chunks): 1
[17:36:34.724] Launching 1 futures (chunks) ...
[17:36:34.724] Chunk #1 of 1 ...
[17:36:34.724]  - seeds: <none>
[17:36:34.724]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.724] getGlobalsAndPackages() ...
[17:36:34.724] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.725] Resolving globals: FALSE
[17:36:34.725] Tweak future expression to call with '...' arguments ...
[17:36:34.725] {
[17:36:34.725]     do.call(function(...) {
[17:36:34.725]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.725]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:34.725]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.725]             on.exit(options(oopts), add = TRUE)
[17:36:34.725]         }
[17:36:34.725]         {
[17:36:34.725]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:34.725]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.725]                 ...future.FUN(...future.X_jj, ...)
[17:36:34.725]             })
[17:36:34.725]         }
[17:36:34.725]     }, args = future.call.arguments)
[17:36:34.725] }
[17:36:34.725] Tweak future expression to call with '...' arguments ... DONE
[17:36:34.725] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.725] 
[17:36:34.726] getGlobalsAndPackages() ... DONE
[17:36:34.726] run() for ‘Future’ ...
[17:36:34.726] - state: ‘created’
[17:36:34.726] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:34.726] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:34.726] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:34.727]   - Field: ‘label’
[17:36:34.727]   - Field: ‘local’
[17:36:34.727]   - Field: ‘owner’
[17:36:34.727]   - Field: ‘envir’
[17:36:34.727]   - Field: ‘packages’
[17:36:34.727]   - Field: ‘gc’
[17:36:34.727]   - Field: ‘conditions’
[17:36:34.727]   - Field: ‘expr’
[17:36:34.727]   - Field: ‘uuid’
[17:36:34.727]   - Field: ‘seed’
[17:36:34.727]   - Field: ‘version’
[17:36:34.728]   - Field: ‘result’
[17:36:34.728]   - Field: ‘asynchronous’
[17:36:34.728]   - Field: ‘calls’
[17:36:34.728]   - Field: ‘globals’
[17:36:34.728]   - Field: ‘stdout’
[17:36:34.728]   - Field: ‘earlySignal’
[17:36:34.728]   - Field: ‘lazy’
[17:36:34.728]   - Field: ‘state’
[17:36:34.728] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:34.728] - Launch lazy future ...
[17:36:34.729] Packages needed by the future expression (n = 0): <none>
[17:36:34.729] Packages needed by future strategies (n = 0): <none>
[17:36:34.729] {
[17:36:34.729]     {
[17:36:34.729]         {
[17:36:34.729]             ...future.startTime <- base::Sys.time()
[17:36:34.729]             {
[17:36:34.729]                 {
[17:36:34.729]                   {
[17:36:34.729]                     base::local({
[17:36:34.729]                       has_future <- base::requireNamespace("future", 
[17:36:34.729]                         quietly = TRUE)
[17:36:34.729]                       if (has_future) {
[17:36:34.729]                         ns <- base::getNamespace("future")
[17:36:34.729]                         version <- ns[[".package"]][["version"]]
[17:36:34.729]                         if (is.null(version)) 
[17:36:34.729]                           version <- utils::packageVersion("future")
[17:36:34.729]                       }
[17:36:34.729]                       else {
[17:36:34.729]                         version <- NULL
[17:36:34.729]                       }
[17:36:34.729]                       if (!has_future || version < "1.8.0") {
[17:36:34.729]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:34.729]                           "", base::R.version$version.string), 
[17:36:34.729]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:34.729]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:34.729]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:34.729]                             "release", "version")], collapse = " "), 
[17:36:34.729]                           hostname = base::Sys.info()[["nodename"]])
[17:36:34.729]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:34.729]                           info)
[17:36:34.729]                         info <- base::paste(info, collapse = "; ")
[17:36:34.729]                         if (!has_future) {
[17:36:34.729]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:34.729]                             info)
[17:36:34.729]                         }
[17:36:34.729]                         else {
[17:36:34.729]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:34.729]                             info, version)
[17:36:34.729]                         }
[17:36:34.729]                         base::stop(msg)
[17:36:34.729]                       }
[17:36:34.729]                     })
[17:36:34.729]                   }
[17:36:34.729]                   ...future.strategy.old <- future::plan("list")
[17:36:34.729]                   options(future.plan = NULL)
[17:36:34.729]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:34.729]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:34.729]                 }
[17:36:34.729]                 ...future.workdir <- getwd()
[17:36:34.729]             }
[17:36:34.729]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:34.729]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:34.729]         }
[17:36:34.729]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:34.729]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:34.729]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:34.729]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:34.729]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:34.729]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:34.729]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:34.729]             base::names(...future.oldOptions))
[17:36:34.729]     }
[17:36:34.729]     if (FALSE) {
[17:36:34.729]     }
[17:36:34.729]     else {
[17:36:34.729]         if (TRUE) {
[17:36:34.729]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:34.729]                 open = "w")
[17:36:34.729]         }
[17:36:34.729]         else {
[17:36:34.729]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:34.729]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:34.729]         }
[17:36:34.729]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:34.729]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:34.729]             base::sink(type = "output", split = FALSE)
[17:36:34.729]             base::close(...future.stdout)
[17:36:34.729]         }, add = TRUE)
[17:36:34.729]     }
[17:36:34.729]     ...future.frame <- base::sys.nframe()
[17:36:34.729]     ...future.conditions <- base::list()
[17:36:34.729]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:34.729]     if (FALSE) {
[17:36:34.729]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:34.729]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:34.729]     }
[17:36:34.729]     ...future.result <- base::tryCatch({
[17:36:34.729]         base::withCallingHandlers({
[17:36:34.729]             ...future.value <- base::withVisible(base::local({
[17:36:34.729]                 do.call(function(...) {
[17:36:34.729]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.729]                   if (!identical(...future.globals.maxSize.org, 
[17:36:34.729]                     ...future.globals.maxSize)) {
[17:36:34.729]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.729]                     on.exit(options(oopts), add = TRUE)
[17:36:34.729]                   }
[17:36:34.729]                   {
[17:36:34.729]                     lapply(seq_along(...future.elements_ii), 
[17:36:34.729]                       FUN = function(jj) {
[17:36:34.729]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.729]                         ...future.FUN(...future.X_jj, ...)
[17:36:34.729]                       })
[17:36:34.729]                   }
[17:36:34.729]                 }, args = future.call.arguments)
[17:36:34.729]             }))
[17:36:34.729]             future::FutureResult(value = ...future.value$value, 
[17:36:34.729]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:34.729]                   ...future.rng), globalenv = if (FALSE) 
[17:36:34.729]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:34.729]                     ...future.globalenv.names))
[17:36:34.729]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:34.729]         }, condition = base::local({
[17:36:34.729]             c <- base::c
[17:36:34.729]             inherits <- base::inherits
[17:36:34.729]             invokeRestart <- base::invokeRestart
[17:36:34.729]             length <- base::length
[17:36:34.729]             list <- base::list
[17:36:34.729]             seq.int <- base::seq.int
[17:36:34.729]             signalCondition <- base::signalCondition
[17:36:34.729]             sys.calls <- base::sys.calls
[17:36:34.729]             `[[` <- base::`[[`
[17:36:34.729]             `+` <- base::`+`
[17:36:34.729]             `<<-` <- base::`<<-`
[17:36:34.729]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:34.729]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:34.729]                   3L)]
[17:36:34.729]             }
[17:36:34.729]             function(cond) {
[17:36:34.729]                 is_error <- inherits(cond, "error")
[17:36:34.729]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:34.729]                   NULL)
[17:36:34.729]                 if (is_error) {
[17:36:34.729]                   sessionInformation <- function() {
[17:36:34.729]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:34.729]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:34.729]                       search = base::search(), system = base::Sys.info())
[17:36:34.729]                   }
[17:36:34.729]                   ...future.conditions[[length(...future.conditions) + 
[17:36:34.729]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:34.729]                     cond$call), session = sessionInformation(), 
[17:36:34.729]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:34.729]                   signalCondition(cond)
[17:36:34.729]                 }
[17:36:34.729]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:34.729]                 "immediateCondition"))) {
[17:36:34.729]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:34.729]                   ...future.conditions[[length(...future.conditions) + 
[17:36:34.729]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:34.729]                   if (TRUE && !signal) {
[17:36:34.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:34.729]                     {
[17:36:34.729]                       inherits <- base::inherits
[17:36:34.729]                       invokeRestart <- base::invokeRestart
[17:36:34.729]                       is.null <- base::is.null
[17:36:34.729]                       muffled <- FALSE
[17:36:34.729]                       if (inherits(cond, "message")) {
[17:36:34.729]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:34.729]                         if (muffled) 
[17:36:34.729]                           invokeRestart("muffleMessage")
[17:36:34.729]                       }
[17:36:34.729]                       else if (inherits(cond, "warning")) {
[17:36:34.729]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:34.729]                         if (muffled) 
[17:36:34.729]                           invokeRestart("muffleWarning")
[17:36:34.729]                       }
[17:36:34.729]                       else if (inherits(cond, "condition")) {
[17:36:34.729]                         if (!is.null(pattern)) {
[17:36:34.729]                           computeRestarts <- base::computeRestarts
[17:36:34.729]                           grepl <- base::grepl
[17:36:34.729]                           restarts <- computeRestarts(cond)
[17:36:34.729]                           for (restart in restarts) {
[17:36:34.729]                             name <- restart$name
[17:36:34.729]                             if (is.null(name)) 
[17:36:34.729]                               next
[17:36:34.729]                             if (!grepl(pattern, name)) 
[17:36:34.729]                               next
[17:36:34.729]                             invokeRestart(restart)
[17:36:34.729]                             muffled <- TRUE
[17:36:34.729]                             break
[17:36:34.729]                           }
[17:36:34.729]                         }
[17:36:34.729]                       }
[17:36:34.729]                       invisible(muffled)
[17:36:34.729]                     }
[17:36:34.729]                     muffleCondition(cond, pattern = "^muffle")
[17:36:34.729]                   }
[17:36:34.729]                 }
[17:36:34.729]                 else {
[17:36:34.729]                   if (TRUE) {
[17:36:34.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:34.729]                     {
[17:36:34.729]                       inherits <- base::inherits
[17:36:34.729]                       invokeRestart <- base::invokeRestart
[17:36:34.729]                       is.null <- base::is.null
[17:36:34.729]                       muffled <- FALSE
[17:36:34.729]                       if (inherits(cond, "message")) {
[17:36:34.729]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:34.729]                         if (muffled) 
[17:36:34.729]                           invokeRestart("muffleMessage")
[17:36:34.729]                       }
[17:36:34.729]                       else if (inherits(cond, "warning")) {
[17:36:34.729]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:34.729]                         if (muffled) 
[17:36:34.729]                           invokeRestart("muffleWarning")
[17:36:34.729]                       }
[17:36:34.729]                       else if (inherits(cond, "condition")) {
[17:36:34.729]                         if (!is.null(pattern)) {
[17:36:34.729]                           computeRestarts <- base::computeRestarts
[17:36:34.729]                           grepl <- base::grepl
[17:36:34.729]                           restarts <- computeRestarts(cond)
[17:36:34.729]                           for (restart in restarts) {
[17:36:34.729]                             name <- restart$name
[17:36:34.729]                             if (is.null(name)) 
[17:36:34.729]                               next
[17:36:34.729]                             if (!grepl(pattern, name)) 
[17:36:34.729]                               next
[17:36:34.729]                             invokeRestart(restart)
[17:36:34.729]                             muffled <- TRUE
[17:36:34.729]                             break
[17:36:34.729]                           }
[17:36:34.729]                         }
[17:36:34.729]                       }
[17:36:34.729]                       invisible(muffled)
[17:36:34.729]                     }
[17:36:34.729]                     muffleCondition(cond, pattern = "^muffle")
[17:36:34.729]                   }
[17:36:34.729]                 }
[17:36:34.729]             }
[17:36:34.729]         }))
[17:36:34.729]     }, error = function(ex) {
[17:36:34.729]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:34.729]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:34.729]                 ...future.rng), started = ...future.startTime, 
[17:36:34.729]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:34.729]             version = "1.8"), class = "FutureResult")
[17:36:34.729]     }, finally = {
[17:36:34.729]         if (!identical(...future.workdir, getwd())) 
[17:36:34.729]             setwd(...future.workdir)
[17:36:34.729]         {
[17:36:34.729]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:34.729]                 ...future.oldOptions$nwarnings <- NULL
[17:36:34.729]             }
[17:36:34.729]             base::options(...future.oldOptions)
[17:36:34.729]             if (.Platform$OS.type == "windows") {
[17:36:34.729]                 old_names <- names(...future.oldEnvVars)
[17:36:34.729]                 envs <- base::Sys.getenv()
[17:36:34.729]                 names <- names(envs)
[17:36:34.729]                 common <- intersect(names, old_names)
[17:36:34.729]                 added <- setdiff(names, old_names)
[17:36:34.729]                 removed <- setdiff(old_names, names)
[17:36:34.729]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:34.729]                   envs[common]]
[17:36:34.729]                 NAMES <- toupper(changed)
[17:36:34.729]                 args <- list()
[17:36:34.729]                 for (kk in seq_along(NAMES)) {
[17:36:34.729]                   name <- changed[[kk]]
[17:36:34.729]                   NAME <- NAMES[[kk]]
[17:36:34.729]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.729]                     next
[17:36:34.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:34.729]                 }
[17:36:34.729]                 NAMES <- toupper(added)
[17:36:34.729]                 for (kk in seq_along(NAMES)) {
[17:36:34.729]                   name <- added[[kk]]
[17:36:34.729]                   NAME <- NAMES[[kk]]
[17:36:34.729]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.729]                     next
[17:36:34.729]                   args[[name]] <- ""
[17:36:34.729]                 }
[17:36:34.729]                 NAMES <- toupper(removed)
[17:36:34.729]                 for (kk in seq_along(NAMES)) {
[17:36:34.729]                   name <- removed[[kk]]
[17:36:34.729]                   NAME <- NAMES[[kk]]
[17:36:34.729]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.729]                     next
[17:36:34.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:34.729]                 }
[17:36:34.729]                 if (length(args) > 0) 
[17:36:34.729]                   base::do.call(base::Sys.setenv, args = args)
[17:36:34.729]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:34.729]             }
[17:36:34.729]             else {
[17:36:34.729]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:34.729]             }
[17:36:34.729]             {
[17:36:34.729]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:34.729]                   0L) {
[17:36:34.729]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:34.729]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:34.729]                   base::options(opts)
[17:36:34.729]                 }
[17:36:34.729]                 {
[17:36:34.729]                   {
[17:36:34.729]                     NULL
[17:36:34.729]                     RNGkind("Mersenne-Twister")
[17:36:34.729]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:34.729]                       inherits = FALSE)
[17:36:34.729]                   }
[17:36:34.729]                   options(future.plan = NULL)
[17:36:34.729]                   if (is.na(NA_character_)) 
[17:36:34.729]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:34.729]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:34.729]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:34.729]                     .init = FALSE)
[17:36:34.729]                 }
[17:36:34.729]             }
[17:36:34.729]         }
[17:36:34.729]     })
[17:36:34.729]     if (TRUE) {
[17:36:34.729]         base::sink(type = "output", split = FALSE)
[17:36:34.729]         if (TRUE) {
[17:36:34.729]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:34.729]         }
[17:36:34.729]         else {
[17:36:34.729]             ...future.result["stdout"] <- base::list(NULL)
[17:36:34.729]         }
[17:36:34.729]         base::close(...future.stdout)
[17:36:34.729]         ...future.stdout <- NULL
[17:36:34.729]     }
[17:36:34.729]     ...future.result$conditions <- ...future.conditions
[17:36:34.729]     ...future.result$finished <- base::Sys.time()
[17:36:34.729]     ...future.result
[17:36:34.729] }
[17:36:34.731] assign_globals() ...
[17:36:34.731] List of 5
[17:36:34.731]  $ future.call.arguments    : list()
[17:36:34.731]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.731]  $ ...future.FUN            :function (x)  
[17:36:34.731]  $ ...future.elements_ii    :List of 2
[17:36:34.731]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:36:34.731]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:36:34.731]  $ ...future.seeds_ii       : NULL
[17:36:34.731]  $ ...future.globals.maxSize: num Inf
[17:36:34.731]  - attr(*, "resolved")= logi FALSE
[17:36:34.731]  - attr(*, "total_size")= num NA
[17:36:34.731]  - attr(*, "where")=List of 5
[17:36:34.731]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:34.731]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:34.731]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:34.731]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:34.731]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:34.731]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.731]  - attr(*, "already-done")= logi TRUE
[17:36:34.737] - copied ‘future.call.arguments’ to environment
[17:36:34.737] - copied ‘...future.FUN’ to environment
[17:36:34.737] - copied ‘...future.elements_ii’ to environment
[17:36:34.737] - copied ‘...future.seeds_ii’ to environment
[17:36:34.737] - copied ‘...future.globals.maxSize’ to environment
[17:36:34.737] assign_globals() ... done
[17:36:34.738] plan(): Setting new future strategy stack:
[17:36:34.738] List of future strategies:
[17:36:34.738] 1. sequential:
[17:36:34.738]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:34.738]    - tweaked: FALSE
[17:36:34.738]    - call: NULL
[17:36:34.738] plan(): nbrOfWorkers() = 1
[17:36:34.739] plan(): Setting new future strategy stack:
[17:36:34.739] List of future strategies:
[17:36:34.739] 1. sequential:
[17:36:34.739]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:34.739]    - tweaked: FALSE
[17:36:34.739]    - call: plan(strategy)
[17:36:34.739] plan(): nbrOfWorkers() = 1
[17:36:34.740] SequentialFuture started (and completed)
[17:36:34.740] - Launch lazy future ... done
[17:36:34.740] run() for ‘SequentialFuture’ ... done
[17:36:34.740] Created future:
[17:36:34.740] SequentialFuture:
[17:36:34.740] Label: ‘future_apply-1’
[17:36:34.740] Expression:
[17:36:34.740] {
[17:36:34.740]     do.call(function(...) {
[17:36:34.740]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.740]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:34.740]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.740]             on.exit(options(oopts), add = TRUE)
[17:36:34.740]         }
[17:36:34.740]         {
[17:36:34.740]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:34.740]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.740]                 ...future.FUN(...future.X_jj, ...)
[17:36:34.740]             })
[17:36:34.740]         }
[17:36:34.740]     }, args = future.call.arguments)
[17:36:34.740] }
[17:36:34.740] Lazy evaluation: FALSE
[17:36:34.740] Asynchronous evaluation: FALSE
[17:36:34.740] Local evaluation: TRUE
[17:36:34.740] Environment: R_GlobalEnv
[17:36:34.740] Capture standard output: TRUE
[17:36:34.740] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:34.740] Globals: 5 objects totaling 1.10 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:34.740] Packages: <none>
[17:36:34.740] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:34.740] Resolved: TRUE
[17:36:34.740] Value: 224 bytes of class ‘list’
[17:36:34.740] Early signaling: FALSE
[17:36:34.740] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:34.740] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:34.741] Chunk #1 of 1 ... DONE
[17:36:34.741] Launching 1 futures (chunks) ... DONE
[17:36:34.741] Resolving 1 futures (chunks) ...
[17:36:34.741] resolve() on list ...
[17:36:34.741]  recursive: 0
[17:36:34.741]  length: 1
[17:36:34.742] 
[17:36:34.742] resolved() for ‘SequentialFuture’ ...
[17:36:34.742] - state: ‘finished’
[17:36:34.742] - run: TRUE
[17:36:34.742] - result: ‘FutureResult’
[17:36:34.742] resolved() for ‘SequentialFuture’ ... done
[17:36:34.742] Future #1
[17:36:34.742] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:34.742] - nx: 1
[17:36:34.742] - relay: TRUE
[17:36:34.743] - stdout: TRUE
[17:36:34.743] - signal: TRUE
[17:36:34.743] - resignal: FALSE
[17:36:34.743] - force: TRUE
[17:36:34.743] - relayed: [n=1] FALSE
[17:36:34.743] - queued futures: [n=1] FALSE
[17:36:34.743]  - until=1
[17:36:34.743]  - relaying element #1
[17:36:34.743] - relayed: [n=1] TRUE
[17:36:34.743] - queued futures: [n=1] TRUE
[17:36:34.743] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:34.744]  length: 0 (resolved future 1)
[17:36:34.744] Relaying remaining futures
[17:36:34.744] signalConditionsASAP(NULL, pos=0) ...
[17:36:34.744] - nx: 1
[17:36:34.744] - relay: TRUE
[17:36:34.744] - stdout: TRUE
[17:36:34.744] - signal: TRUE
[17:36:34.744] - resignal: FALSE
[17:36:34.744] - force: TRUE
[17:36:34.744] - relayed: [n=1] TRUE
[17:36:34.744] - queued futures: [n=1] TRUE
 - flush all
[17:36:34.745] - relayed: [n=1] TRUE
[17:36:34.745] - queued futures: [n=1] TRUE
[17:36:34.745] signalConditionsASAP(NULL, pos=0) ... done
[17:36:34.745] resolve() on list ... DONE
[17:36:34.745]  - Number of value chunks collected: 1
[17:36:34.745] Resolving 1 futures (chunks) ... DONE
[17:36:34.745] Reducing values from 1 chunks ...
[17:36:34.745]  - Number of values collected after concatenation: 2
[17:36:34.745]  - Number of values expected: 2
[17:36:34.745] Reducing values from 1 chunks ... DONE
[17:36:34.745] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[17:36:34.746] getGlobalsAndPackagesXApply() ...
[17:36:34.746]  - future.globals: TRUE
[17:36:34.746] getGlobalsAndPackages() ...
[17:36:34.746] Searching for globals...
[17:36:34.747] - globals found: [1] ‘FUN’
[17:36:34.747] Searching for globals ... DONE
[17:36:34.747] Resolving globals: FALSE
[17:36:34.747] The total size of the 1 globals is 848 bytes (848 bytes)
[17:36:34.748] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:36:34.748] - globals: [1] ‘FUN’
[17:36:34.748] 
[17:36:34.748] getGlobalsAndPackages() ... DONE
[17:36:34.748]  - globals found/used: [n=1] ‘FUN’
[17:36:34.748]  - needed namespaces: [n=0] 
[17:36:34.748] Finding globals ... DONE
[17:36:34.749]  - use_args: TRUE
[17:36:34.749]  - Getting '...' globals ...
[17:36:34.749] resolve() on list ...
[17:36:34.749]  recursive: 0
[17:36:34.749]  length: 1
[17:36:34.749]  elements: ‘...’
[17:36:34.749]  length: 0 (resolved future 1)
[17:36:34.749] resolve() on list ... DONE
[17:36:34.750]    - '...' content: [n=0] 
[17:36:34.750] List of 1
[17:36:34.750]  $ ...: list()
[17:36:34.750]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.750]  - attr(*, "where")=List of 1
[17:36:34.750]   ..$ ...:<environment: 0x556d75a56ec8> 
[17:36:34.750]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.750]  - attr(*, "resolved")= logi TRUE
[17:36:34.750]  - attr(*, "total_size")= num NA
[17:36:34.752]  - Getting '...' globals ... DONE
[17:36:34.752] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:34.752] List of 2
[17:36:34.752]  $ ...future.FUN:function (x)  
[17:36:34.752]  $ ...          : list()
[17:36:34.752]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.752]  - attr(*, "where")=List of 2
[17:36:34.752]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:34.752]   ..$ ...          :<environment: 0x556d75a56ec8> 
[17:36:34.752]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.752]  - attr(*, "resolved")= logi FALSE
[17:36:34.752]  - attr(*, "total_size")= num 848
[17:36:34.756] Packages to be attached in all futures: [n=0] 
[17:36:34.756] getGlobalsAndPackagesXApply() ... DONE
[17:36:34.757] future_lapply() ...
[17:36:34.757] Number of chunks: 1
[17:36:34.757] getGlobalsAndPackagesXApply() ...
[17:36:34.757]  - future.globals: <name-value list> with names ‘list()’
[17:36:34.757]  - use_args: TRUE
[17:36:34.758] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:34.758] List of 2
[17:36:34.758]  $ ...          : list()
[17:36:34.758]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.758]  $ ...future.FUN:function (x)  
[17:36:34.758]  - attr(*, "where")=List of 2
[17:36:34.758]   ..$ ...          :<environment: 0x556d75a56ec8> 
[17:36:34.758]   ..$ ...future.FUN:<environment: namespace:base> 
[17:36:34.758]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.758]  - attr(*, "resolved")= logi FALSE
[17:36:34.758]  - attr(*, "total_size")= num NA
[17:36:34.761] Packages to be attached in all futures: [n=0] 
[17:36:34.761] getGlobalsAndPackagesXApply() ... DONE
[17:36:34.761] Number of futures (= number of chunks): 1
[17:36:34.761] Launching 1 futures (chunks) ...
[17:36:34.761] Chunk #1 of 1 ...
[17:36:34.761]  - seeds: <none>
[17:36:34.761]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.761] getGlobalsAndPackages() ...
[17:36:34.762] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.762] Resolving globals: FALSE
[17:36:34.762] Tweak future expression to call with '...' arguments ...
[17:36:34.762] {
[17:36:34.762]     do.call(function(...) {
[17:36:34.762]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.762]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:34.762]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.762]             on.exit(options(oopts), add = TRUE)
[17:36:34.762]         }
[17:36:34.762]         {
[17:36:34.762]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:34.762]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.762]                 ...future.FUN(...future.X_jj, ...)
[17:36:34.762]             })
[17:36:34.762]         }
[17:36:34.762]     }, args = future.call.arguments)
[17:36:34.762] }
[17:36:34.762] Tweak future expression to call with '...' arguments ... DONE
[17:36:34.762] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.763] 
[17:36:34.763] getGlobalsAndPackages() ... DONE
[17:36:34.763] run() for ‘Future’ ...
[17:36:34.763] - state: ‘created’
[17:36:34.763] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:34.764] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:34.764] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:34.764]   - Field: ‘label’
[17:36:34.764]   - Field: ‘local’
[17:36:34.764]   - Field: ‘owner’
[17:36:34.764]   - Field: ‘envir’
[17:36:34.765]   - Field: ‘packages’
[17:36:34.765]   - Field: ‘gc’
[17:36:34.765]   - Field: ‘conditions’
[17:36:34.765]   - Field: ‘expr’
[17:36:34.765]   - Field: ‘uuid’
[17:36:34.765]   - Field: ‘seed’
[17:36:34.766]   - Field: ‘version’
[17:36:34.766]   - Field: ‘result’
[17:36:34.766]   - Field: ‘asynchronous’
[17:36:34.766]   - Field: ‘calls’
[17:36:34.766]   - Field: ‘globals’
[17:36:34.766]   - Field: ‘stdout’
[17:36:34.766]   - Field: ‘earlySignal’
[17:36:34.767]   - Field: ‘lazy’
[17:36:34.767]   - Field: ‘state’
[17:36:34.767] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:34.767] - Launch lazy future ...
[17:36:34.767] Packages needed by the future expression (n = 0): <none>
[17:36:34.767] Packages needed by future strategies (n = 0): <none>
[17:36:34.768] {
[17:36:34.768]     {
[17:36:34.768]         {
[17:36:34.768]             ...future.startTime <- base::Sys.time()
[17:36:34.768]             {
[17:36:34.768]                 {
[17:36:34.768]                   {
[17:36:34.768]                     base::local({
[17:36:34.768]                       has_future <- base::requireNamespace("future", 
[17:36:34.768]                         quietly = TRUE)
[17:36:34.768]                       if (has_future) {
[17:36:34.768]                         ns <- base::getNamespace("future")
[17:36:34.768]                         version <- ns[[".package"]][["version"]]
[17:36:34.768]                         if (is.null(version)) 
[17:36:34.768]                           version <- utils::packageVersion("future")
[17:36:34.768]                       }
[17:36:34.768]                       else {
[17:36:34.768]                         version <- NULL
[17:36:34.768]                       }
[17:36:34.768]                       if (!has_future || version < "1.8.0") {
[17:36:34.768]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:34.768]                           "", base::R.version$version.string), 
[17:36:34.768]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:34.768]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:34.768]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:34.768]                             "release", "version")], collapse = " "), 
[17:36:34.768]                           hostname = base::Sys.info()[["nodename"]])
[17:36:34.768]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:34.768]                           info)
[17:36:34.768]                         info <- base::paste(info, collapse = "; ")
[17:36:34.768]                         if (!has_future) {
[17:36:34.768]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:34.768]                             info)
[17:36:34.768]                         }
[17:36:34.768]                         else {
[17:36:34.768]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:34.768]                             info, version)
[17:36:34.768]                         }
[17:36:34.768]                         base::stop(msg)
[17:36:34.768]                       }
[17:36:34.768]                     })
[17:36:34.768]                   }
[17:36:34.768]                   ...future.strategy.old <- future::plan("list")
[17:36:34.768]                   options(future.plan = NULL)
[17:36:34.768]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:34.768]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:34.768]                 }
[17:36:34.768]                 ...future.workdir <- getwd()
[17:36:34.768]             }
[17:36:34.768]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:34.768]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:34.768]         }
[17:36:34.768]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:34.768]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:34.768]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:34.768]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:34.768]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:34.768]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:34.768]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:34.768]             base::names(...future.oldOptions))
[17:36:34.768]     }
[17:36:34.768]     if (FALSE) {
[17:36:34.768]     }
[17:36:34.768]     else {
[17:36:34.768]         if (TRUE) {
[17:36:34.768]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:34.768]                 open = "w")
[17:36:34.768]         }
[17:36:34.768]         else {
[17:36:34.768]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:34.768]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:34.768]         }
[17:36:34.768]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:34.768]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:34.768]             base::sink(type = "output", split = FALSE)
[17:36:34.768]             base::close(...future.stdout)
[17:36:34.768]         }, add = TRUE)
[17:36:34.768]     }
[17:36:34.768]     ...future.frame <- base::sys.nframe()
[17:36:34.768]     ...future.conditions <- base::list()
[17:36:34.768]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:34.768]     if (FALSE) {
[17:36:34.768]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:34.768]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:34.768]     }
[17:36:34.768]     ...future.result <- base::tryCatch({
[17:36:34.768]         base::withCallingHandlers({
[17:36:34.768]             ...future.value <- base::withVisible(base::local({
[17:36:34.768]                 do.call(function(...) {
[17:36:34.768]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.768]                   if (!identical(...future.globals.maxSize.org, 
[17:36:34.768]                     ...future.globals.maxSize)) {
[17:36:34.768]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.768]                     on.exit(options(oopts), add = TRUE)
[17:36:34.768]                   }
[17:36:34.768]                   {
[17:36:34.768]                     lapply(seq_along(...future.elements_ii), 
[17:36:34.768]                       FUN = function(jj) {
[17:36:34.768]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.768]                         ...future.FUN(...future.X_jj, ...)
[17:36:34.768]                       })
[17:36:34.768]                   }
[17:36:34.768]                 }, args = future.call.arguments)
[17:36:34.768]             }))
[17:36:34.768]             future::FutureResult(value = ...future.value$value, 
[17:36:34.768]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:34.768]                   ...future.rng), globalenv = if (FALSE) 
[17:36:34.768]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:34.768]                     ...future.globalenv.names))
[17:36:34.768]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:34.768]         }, condition = base::local({
[17:36:34.768]             c <- base::c
[17:36:34.768]             inherits <- base::inherits
[17:36:34.768]             invokeRestart <- base::invokeRestart
[17:36:34.768]             length <- base::length
[17:36:34.768]             list <- base::list
[17:36:34.768]             seq.int <- base::seq.int
[17:36:34.768]             signalCondition <- base::signalCondition
[17:36:34.768]             sys.calls <- base::sys.calls
[17:36:34.768]             `[[` <- base::`[[`
[17:36:34.768]             `+` <- base::`+`
[17:36:34.768]             `<<-` <- base::`<<-`
[17:36:34.768]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:34.768]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:34.768]                   3L)]
[17:36:34.768]             }
[17:36:34.768]             function(cond) {
[17:36:34.768]                 is_error <- inherits(cond, "error")
[17:36:34.768]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:34.768]                   NULL)
[17:36:34.768]                 if (is_error) {
[17:36:34.768]                   sessionInformation <- function() {
[17:36:34.768]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:34.768]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:34.768]                       search = base::search(), system = base::Sys.info())
[17:36:34.768]                   }
[17:36:34.768]                   ...future.conditions[[length(...future.conditions) + 
[17:36:34.768]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:34.768]                     cond$call), session = sessionInformation(), 
[17:36:34.768]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:34.768]                   signalCondition(cond)
[17:36:34.768]                 }
[17:36:34.768]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:34.768]                 "immediateCondition"))) {
[17:36:34.768]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:34.768]                   ...future.conditions[[length(...future.conditions) + 
[17:36:34.768]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:34.768]                   if (TRUE && !signal) {
[17:36:34.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:34.768]                     {
[17:36:34.768]                       inherits <- base::inherits
[17:36:34.768]                       invokeRestart <- base::invokeRestart
[17:36:34.768]                       is.null <- base::is.null
[17:36:34.768]                       muffled <- FALSE
[17:36:34.768]                       if (inherits(cond, "message")) {
[17:36:34.768]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:34.768]                         if (muffled) 
[17:36:34.768]                           invokeRestart("muffleMessage")
[17:36:34.768]                       }
[17:36:34.768]                       else if (inherits(cond, "warning")) {
[17:36:34.768]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:34.768]                         if (muffled) 
[17:36:34.768]                           invokeRestart("muffleWarning")
[17:36:34.768]                       }
[17:36:34.768]                       else if (inherits(cond, "condition")) {
[17:36:34.768]                         if (!is.null(pattern)) {
[17:36:34.768]                           computeRestarts <- base::computeRestarts
[17:36:34.768]                           grepl <- base::grepl
[17:36:34.768]                           restarts <- computeRestarts(cond)
[17:36:34.768]                           for (restart in restarts) {
[17:36:34.768]                             name <- restart$name
[17:36:34.768]                             if (is.null(name)) 
[17:36:34.768]                               next
[17:36:34.768]                             if (!grepl(pattern, name)) 
[17:36:34.768]                               next
[17:36:34.768]                             invokeRestart(restart)
[17:36:34.768]                             muffled <- TRUE
[17:36:34.768]                             break
[17:36:34.768]                           }
[17:36:34.768]                         }
[17:36:34.768]                       }
[17:36:34.768]                       invisible(muffled)
[17:36:34.768]                     }
[17:36:34.768]                     muffleCondition(cond, pattern = "^muffle")
[17:36:34.768]                   }
[17:36:34.768]                 }
[17:36:34.768]                 else {
[17:36:34.768]                   if (TRUE) {
[17:36:34.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:34.768]                     {
[17:36:34.768]                       inherits <- base::inherits
[17:36:34.768]                       invokeRestart <- base::invokeRestart
[17:36:34.768]                       is.null <- base::is.null
[17:36:34.768]                       muffled <- FALSE
[17:36:34.768]                       if (inherits(cond, "message")) {
[17:36:34.768]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:34.768]                         if (muffled) 
[17:36:34.768]                           invokeRestart("muffleMessage")
[17:36:34.768]                       }
[17:36:34.768]                       else if (inherits(cond, "warning")) {
[17:36:34.768]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:34.768]                         if (muffled) 
[17:36:34.768]                           invokeRestart("muffleWarning")
[17:36:34.768]                       }
[17:36:34.768]                       else if (inherits(cond, "condition")) {
[17:36:34.768]                         if (!is.null(pattern)) {
[17:36:34.768]                           computeRestarts <- base::computeRestarts
[17:36:34.768]                           grepl <- base::grepl
[17:36:34.768]                           restarts <- computeRestarts(cond)
[17:36:34.768]                           for (restart in restarts) {
[17:36:34.768]                             name <- restart$name
[17:36:34.768]                             if (is.null(name)) 
[17:36:34.768]                               next
[17:36:34.768]                             if (!grepl(pattern, name)) 
[17:36:34.768]                               next
[17:36:34.768]                             invokeRestart(restart)
[17:36:34.768]                             muffled <- TRUE
[17:36:34.768]                             break
[17:36:34.768]                           }
[17:36:34.768]                         }
[17:36:34.768]                       }
[17:36:34.768]                       invisible(muffled)
[17:36:34.768]                     }
[17:36:34.768]                     muffleCondition(cond, pattern = "^muffle")
[17:36:34.768]                   }
[17:36:34.768]                 }
[17:36:34.768]             }
[17:36:34.768]         }))
[17:36:34.768]     }, error = function(ex) {
[17:36:34.768]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:34.768]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:34.768]                 ...future.rng), started = ...future.startTime, 
[17:36:34.768]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:34.768]             version = "1.8"), class = "FutureResult")
[17:36:34.768]     }, finally = {
[17:36:34.768]         if (!identical(...future.workdir, getwd())) 
[17:36:34.768]             setwd(...future.workdir)
[17:36:34.768]         {
[17:36:34.768]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:34.768]                 ...future.oldOptions$nwarnings <- NULL
[17:36:34.768]             }
[17:36:34.768]             base::options(...future.oldOptions)
[17:36:34.768]             if (.Platform$OS.type == "windows") {
[17:36:34.768]                 old_names <- names(...future.oldEnvVars)
[17:36:34.768]                 envs <- base::Sys.getenv()
[17:36:34.768]                 names <- names(envs)
[17:36:34.768]                 common <- intersect(names, old_names)
[17:36:34.768]                 added <- setdiff(names, old_names)
[17:36:34.768]                 removed <- setdiff(old_names, names)
[17:36:34.768]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:34.768]                   envs[common]]
[17:36:34.768]                 NAMES <- toupper(changed)
[17:36:34.768]                 args <- list()
[17:36:34.768]                 for (kk in seq_along(NAMES)) {
[17:36:34.768]                   name <- changed[[kk]]
[17:36:34.768]                   NAME <- NAMES[[kk]]
[17:36:34.768]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.768]                     next
[17:36:34.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:34.768]                 }
[17:36:34.768]                 NAMES <- toupper(added)
[17:36:34.768]                 for (kk in seq_along(NAMES)) {
[17:36:34.768]                   name <- added[[kk]]
[17:36:34.768]                   NAME <- NAMES[[kk]]
[17:36:34.768]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.768]                     next
[17:36:34.768]                   args[[name]] <- ""
[17:36:34.768]                 }
[17:36:34.768]                 NAMES <- toupper(removed)
[17:36:34.768]                 for (kk in seq_along(NAMES)) {
[17:36:34.768]                   name <- removed[[kk]]
[17:36:34.768]                   NAME <- NAMES[[kk]]
[17:36:34.768]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.768]                     next
[17:36:34.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:34.768]                 }
[17:36:34.768]                 if (length(args) > 0) 
[17:36:34.768]                   base::do.call(base::Sys.setenv, args = args)
[17:36:34.768]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:34.768]             }
[17:36:34.768]             else {
[17:36:34.768]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:34.768]             }
[17:36:34.768]             {
[17:36:34.768]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:34.768]                   0L) {
[17:36:34.768]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:34.768]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:34.768]                   base::options(opts)
[17:36:34.768]                 }
[17:36:34.768]                 {
[17:36:34.768]                   {
[17:36:34.768]                     NULL
[17:36:34.768]                     RNGkind("Mersenne-Twister")
[17:36:34.768]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:34.768]                       inherits = FALSE)
[17:36:34.768]                   }
[17:36:34.768]                   options(future.plan = NULL)
[17:36:34.768]                   if (is.na(NA_character_)) 
[17:36:34.768]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:34.768]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:34.768]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:34.768]                     .init = FALSE)
[17:36:34.768]                 }
[17:36:34.768]             }
[17:36:34.768]         }
[17:36:34.768]     })
[17:36:34.768]     if (TRUE) {
[17:36:34.768]         base::sink(type = "output", split = FALSE)
[17:36:34.768]         if (TRUE) {
[17:36:34.768]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:34.768]         }
[17:36:34.768]         else {
[17:36:34.768]             ...future.result["stdout"] <- base::list(NULL)
[17:36:34.768]         }
[17:36:34.768]         base::close(...future.stdout)
[17:36:34.768]         ...future.stdout <- NULL
[17:36:34.768]     }
[17:36:34.768]     ...future.result$conditions <- ...future.conditions
[17:36:34.768]     ...future.result$finished <- base::Sys.time()
[17:36:34.768]     ...future.result
[17:36:34.768] }
[17:36:34.771] assign_globals() ...
[17:36:34.771] List of 5
[17:36:34.771]  $ future.call.arguments    : list()
[17:36:34.771]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.771]  $ ...future.FUN            :function (x)  
[17:36:34.771]  $ ...future.elements_ii    :List of 6
[17:36:34.771]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:36:34.771]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:36:34.771]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:36:34.771]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:36:34.771]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:36:34.771]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:36:34.771]  $ ...future.seeds_ii       : NULL
[17:36:34.771]  $ ...future.globals.maxSize: num Inf
[17:36:34.771]  - attr(*, "resolved")= logi FALSE
[17:36:34.771]  - attr(*, "total_size")= num NA
[17:36:34.771]  - attr(*, "where")=List of 5
[17:36:34.771]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:34.771]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:34.771]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:34.771]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:34.771]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:34.771]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.771]  - attr(*, "already-done")= logi TRUE
[17:36:34.777] - copied ‘future.call.arguments’ to environment
[17:36:34.777] - copied ‘...future.FUN’ to environment
[17:36:34.778] - copied ‘...future.elements_ii’ to environment
[17:36:34.778] - copied ‘...future.seeds_ii’ to environment
[17:36:34.778] - copied ‘...future.globals.maxSize’ to environment
[17:36:34.778] assign_globals() ... done
[17:36:34.778] plan(): Setting new future strategy stack:
[17:36:34.778] List of future strategies:
[17:36:34.778] 1. sequential:
[17:36:34.778]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:34.778]    - tweaked: FALSE
[17:36:34.778]    - call: NULL
[17:36:34.779] plan(): nbrOfWorkers() = 1
[17:36:34.779] plan(): Setting new future strategy stack:
[17:36:34.780] List of future strategies:
[17:36:34.780] 1. sequential:
[17:36:34.780]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:34.780]    - tweaked: FALSE
[17:36:34.780]    - call: plan(strategy)
[17:36:34.780] plan(): nbrOfWorkers() = 1
[17:36:34.780] SequentialFuture started (and completed)
[17:36:34.780] - Launch lazy future ... done
[17:36:34.780] run() for ‘SequentialFuture’ ... done
[17:36:34.781] Created future:
[17:36:34.781] SequentialFuture:
[17:36:34.781] Label: ‘future_apply-1’
[17:36:34.781] Expression:
[17:36:34.781] {
[17:36:34.781]     do.call(function(...) {
[17:36:34.781]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.781]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:34.781]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.781]             on.exit(options(oopts), add = TRUE)
[17:36:34.781]         }
[17:36:34.781]         {
[17:36:34.781]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:34.781]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.781]                 ...future.FUN(...future.X_jj, ...)
[17:36:34.781]             })
[17:36:34.781]         }
[17:36:34.781]     }, args = future.call.arguments)
[17:36:34.781] }
[17:36:34.781] Lazy evaluation: FALSE
[17:36:34.781] Asynchronous evaluation: FALSE
[17:36:34.781] Local evaluation: TRUE
[17:36:34.781] Environment: R_GlobalEnv
[17:36:34.781] Capture standard output: TRUE
[17:36:34.781] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:34.781] Globals: 5 objects totaling 1.54 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 672 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:34.781] Packages: <none>
[17:36:34.781] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:34.781] Resolved: TRUE
[17:36:34.781] Value: 672 bytes of class ‘list’
[17:36:34.781] Early signaling: FALSE
[17:36:34.781] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:34.781] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:34.782] Chunk #1 of 1 ... DONE
[17:36:34.782] Launching 1 futures (chunks) ... DONE
[17:36:34.782] Resolving 1 futures (chunks) ...
[17:36:34.782] resolve() on list ...
[17:36:34.782]  recursive: 0
[17:36:34.782]  length: 1
[17:36:34.782] 
[17:36:34.784] resolved() for ‘SequentialFuture’ ...
[17:36:34.784] - state: ‘finished’
[17:36:34.784] - run: TRUE
[17:36:34.784] - result: ‘FutureResult’
[17:36:34.784] resolved() for ‘SequentialFuture’ ... done
[17:36:34.784] Future #1
[17:36:34.785] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:34.785] - nx: 1
[17:36:34.785] - relay: TRUE
[17:36:34.785] - stdout: TRUE
[17:36:34.785] - signal: TRUE
[17:36:34.785] - resignal: FALSE
[17:36:34.785] - force: TRUE
[17:36:34.785] - relayed: [n=1] FALSE
[17:36:34.785] - queued futures: [n=1] FALSE
[17:36:34.785]  - until=1
[17:36:34.785]  - relaying element #1
[17:36:34.786] - relayed: [n=1] TRUE
[17:36:34.786] - queued futures: [n=1] TRUE
[17:36:34.786] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:34.786]  length: 0 (resolved future 1)
[17:36:34.786] Relaying remaining futures
[17:36:34.786] signalConditionsASAP(NULL, pos=0) ...
[17:36:34.786] - nx: 1
[17:36:34.786] - relay: TRUE
[17:36:34.786] - stdout: TRUE
[17:36:34.786] - signal: TRUE
[17:36:34.787] - resignal: FALSE
[17:36:34.787] - force: TRUE
[17:36:34.787] - relayed: [n=1] TRUE
[17:36:34.787] - queued futures: [n=1] TRUE
 - flush all
[17:36:34.787] - relayed: [n=1] TRUE
[17:36:34.787] - queued futures: [n=1] TRUE
[17:36:34.787] signalConditionsASAP(NULL, pos=0) ... done
[17:36:34.787] resolve() on list ... DONE
[17:36:34.787]  - Number of value chunks collected: 1
[17:36:34.787] Resolving 1 futures (chunks) ... DONE
[17:36:34.788] Reducing values from 1 chunks ...
[17:36:34.788]  - Number of values collected after concatenation: 6
[17:36:34.788]  - Number of values expected: 6
[17:36:34.788] Reducing values from 1 chunks ... DONE
[17:36:34.788] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[17:36:34.788] getGlobalsAndPackagesXApply() ...
[17:36:34.789]  - future.globals: TRUE
[17:36:34.789] getGlobalsAndPackages() ...
[17:36:34.789] Searching for globals...
[17:36:34.790] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[17:36:34.790] Searching for globals ... DONE
[17:36:34.790] Resolving globals: FALSE
[17:36:34.791] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[17:36:34.791] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[17:36:34.791] - globals: [1] ‘FUN’
[17:36:34.791] 
[17:36:34.791] getGlobalsAndPackages() ... DONE
[17:36:34.791]  - globals found/used: [n=1] ‘FUN’
[17:36:34.791]  - needed namespaces: [n=0] 
[17:36:34.792] Finding globals ... DONE
[17:36:34.792]  - use_args: TRUE
[17:36:34.792]  - Getting '...' globals ...
[17:36:34.792] resolve() on list ...
[17:36:34.792]  recursive: 0
[17:36:34.792]  length: 1
[17:36:34.792]  elements: ‘...’
[17:36:34.792]  length: 0 (resolved future 1)
[17:36:34.793] resolve() on list ... DONE
[17:36:34.793]    - '...' content: [n=0] 
[17:36:34.793] List of 1
[17:36:34.793]  $ ...: list()
[17:36:34.793]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.793]  - attr(*, "where")=List of 1
[17:36:34.793]   ..$ ...:<environment: 0x556d73712d68> 
[17:36:34.793]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.793]  - attr(*, "resolved")= logi TRUE
[17:36:34.793]  - attr(*, "total_size")= num NA
[17:36:34.795]  - Getting '...' globals ... DONE
[17:36:34.795] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:34.795] List of 2
[17:36:34.795]  $ ...future.FUN:function (x)  
[17:36:34.795]  $ ...          : list()
[17:36:34.795]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.795]  - attr(*, "where")=List of 2
[17:36:34.795]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:34.795]   ..$ ...          :<environment: 0x556d73712d68> 
[17:36:34.795]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.795]  - attr(*, "resolved")= logi FALSE
[17:36:34.795]  - attr(*, "total_size")= num 1768
[17:36:34.798] Packages to be attached in all futures: [n=0] 
[17:36:34.798] getGlobalsAndPackagesXApply() ... DONE
[17:36:34.798] future_lapply() ...
[17:36:34.799] Number of chunks: 1
[17:36:34.799] getGlobalsAndPackagesXApply() ...
[17:36:34.799]  - future.globals: <name-value list> with names ‘list()’
[17:36:34.799]  - use_args: TRUE
[17:36:34.799] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:34.799] List of 2
[17:36:34.799]  $ ...          : list()
[17:36:34.799]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.799]  $ ...future.FUN:function (x)  
[17:36:34.799]  - attr(*, "where")=List of 2
[17:36:34.799]   ..$ ...          :<environment: 0x556d73712d68> 
[17:36:34.799]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:36:34.799]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.799]  - attr(*, "resolved")= logi FALSE
[17:36:34.799]  - attr(*, "total_size")= num NA
[17:36:34.802] Packages to be attached in all futures: [n=0] 
[17:36:34.802] getGlobalsAndPackagesXApply() ... DONE
[17:36:34.802] Number of futures (= number of chunks): 1
[17:36:34.802] Launching 1 futures (chunks) ...
[17:36:34.803] Chunk #1 of 1 ...
[17:36:34.803]  - seeds: <none>
[17:36:34.803]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.803] getGlobalsAndPackages() ...
[17:36:34.803] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.803] Resolving globals: FALSE
[17:36:34.803] Tweak future expression to call with '...' arguments ...
[17:36:34.803] {
[17:36:34.803]     do.call(function(...) {
[17:36:34.803]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.803]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:34.803]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.803]             on.exit(options(oopts), add = TRUE)
[17:36:34.803]         }
[17:36:34.803]         {
[17:36:34.803]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:34.803]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.803]                 ...future.FUN(...future.X_jj, ...)
[17:36:34.803]             })
[17:36:34.803]         }
[17:36:34.803]     }, args = future.call.arguments)
[17:36:34.803] }
[17:36:34.803] Tweak future expression to call with '...' arguments ... DONE
[17:36:34.804] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.804] 
[17:36:34.804] getGlobalsAndPackages() ... DONE
[17:36:34.804] run() for ‘Future’ ...
[17:36:34.804] - state: ‘created’
[17:36:34.805] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:34.805] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:34.805] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:34.805]   - Field: ‘label’
[17:36:34.805]   - Field: ‘local’
[17:36:34.805]   - Field: ‘owner’
[17:36:34.805]   - Field: ‘envir’
[17:36:34.805]   - Field: ‘packages’
[17:36:34.806]   - Field: ‘gc’
[17:36:34.807]   - Field: ‘conditions’
[17:36:34.807]   - Field: ‘expr’
[17:36:34.807]   - Field: ‘uuid’
[17:36:34.807]   - Field: ‘seed’
[17:36:34.807]   - Field: ‘version’
[17:36:34.807]   - Field: ‘result’
[17:36:34.808]   - Field: ‘asynchronous’
[17:36:34.808]   - Field: ‘calls’
[17:36:34.808]   - Field: ‘globals’
[17:36:34.808]   - Field: ‘stdout’
[17:36:34.808]   - Field: ‘earlySignal’
[17:36:34.808]   - Field: ‘lazy’
[17:36:34.808]   - Field: ‘state’
[17:36:34.808] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:34.808] - Launch lazy future ...
[17:36:34.809] Packages needed by the future expression (n = 0): <none>
[17:36:34.809] Packages needed by future strategies (n = 0): <none>
[17:36:34.809] {
[17:36:34.809]     {
[17:36:34.809]         {
[17:36:34.809]             ...future.startTime <- base::Sys.time()
[17:36:34.809]             {
[17:36:34.809]                 {
[17:36:34.809]                   {
[17:36:34.809]                     base::local({
[17:36:34.809]                       has_future <- base::requireNamespace("future", 
[17:36:34.809]                         quietly = TRUE)
[17:36:34.809]                       if (has_future) {
[17:36:34.809]                         ns <- base::getNamespace("future")
[17:36:34.809]                         version <- ns[[".package"]][["version"]]
[17:36:34.809]                         if (is.null(version)) 
[17:36:34.809]                           version <- utils::packageVersion("future")
[17:36:34.809]                       }
[17:36:34.809]                       else {
[17:36:34.809]                         version <- NULL
[17:36:34.809]                       }
[17:36:34.809]                       if (!has_future || version < "1.8.0") {
[17:36:34.809]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:34.809]                           "", base::R.version$version.string), 
[17:36:34.809]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:34.809]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:34.809]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:34.809]                             "release", "version")], collapse = " "), 
[17:36:34.809]                           hostname = base::Sys.info()[["nodename"]])
[17:36:34.809]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:34.809]                           info)
[17:36:34.809]                         info <- base::paste(info, collapse = "; ")
[17:36:34.809]                         if (!has_future) {
[17:36:34.809]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:34.809]                             info)
[17:36:34.809]                         }
[17:36:34.809]                         else {
[17:36:34.809]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:34.809]                             info, version)
[17:36:34.809]                         }
[17:36:34.809]                         base::stop(msg)
[17:36:34.809]                       }
[17:36:34.809]                     })
[17:36:34.809]                   }
[17:36:34.809]                   ...future.strategy.old <- future::plan("list")
[17:36:34.809]                   options(future.plan = NULL)
[17:36:34.809]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:34.809]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:34.809]                 }
[17:36:34.809]                 ...future.workdir <- getwd()
[17:36:34.809]             }
[17:36:34.809]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:34.809]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:34.809]         }
[17:36:34.809]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:34.809]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:34.809]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:34.809]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:34.809]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:34.809]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:34.809]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:34.809]             base::names(...future.oldOptions))
[17:36:34.809]     }
[17:36:34.809]     if (FALSE) {
[17:36:34.809]     }
[17:36:34.809]     else {
[17:36:34.809]         if (TRUE) {
[17:36:34.809]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:34.809]                 open = "w")
[17:36:34.809]         }
[17:36:34.809]         else {
[17:36:34.809]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:34.809]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:34.809]         }
[17:36:34.809]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:34.809]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:34.809]             base::sink(type = "output", split = FALSE)
[17:36:34.809]             base::close(...future.stdout)
[17:36:34.809]         }, add = TRUE)
[17:36:34.809]     }
[17:36:34.809]     ...future.frame <- base::sys.nframe()
[17:36:34.809]     ...future.conditions <- base::list()
[17:36:34.809]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:34.809]     if (FALSE) {
[17:36:34.809]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:34.809]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:34.809]     }
[17:36:34.809]     ...future.result <- base::tryCatch({
[17:36:34.809]         base::withCallingHandlers({
[17:36:34.809]             ...future.value <- base::withVisible(base::local({
[17:36:34.809]                 do.call(function(...) {
[17:36:34.809]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.809]                   if (!identical(...future.globals.maxSize.org, 
[17:36:34.809]                     ...future.globals.maxSize)) {
[17:36:34.809]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.809]                     on.exit(options(oopts), add = TRUE)
[17:36:34.809]                   }
[17:36:34.809]                   {
[17:36:34.809]                     lapply(seq_along(...future.elements_ii), 
[17:36:34.809]                       FUN = function(jj) {
[17:36:34.809]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.809]                         ...future.FUN(...future.X_jj, ...)
[17:36:34.809]                       })
[17:36:34.809]                   }
[17:36:34.809]                 }, args = future.call.arguments)
[17:36:34.809]             }))
[17:36:34.809]             future::FutureResult(value = ...future.value$value, 
[17:36:34.809]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:34.809]                   ...future.rng), globalenv = if (FALSE) 
[17:36:34.809]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:34.809]                     ...future.globalenv.names))
[17:36:34.809]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:34.809]         }, condition = base::local({
[17:36:34.809]             c <- base::c
[17:36:34.809]             inherits <- base::inherits
[17:36:34.809]             invokeRestart <- base::invokeRestart
[17:36:34.809]             length <- base::length
[17:36:34.809]             list <- base::list
[17:36:34.809]             seq.int <- base::seq.int
[17:36:34.809]             signalCondition <- base::signalCondition
[17:36:34.809]             sys.calls <- base::sys.calls
[17:36:34.809]             `[[` <- base::`[[`
[17:36:34.809]             `+` <- base::`+`
[17:36:34.809]             `<<-` <- base::`<<-`
[17:36:34.809]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:34.809]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:34.809]                   3L)]
[17:36:34.809]             }
[17:36:34.809]             function(cond) {
[17:36:34.809]                 is_error <- inherits(cond, "error")
[17:36:34.809]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:34.809]                   NULL)
[17:36:34.809]                 if (is_error) {
[17:36:34.809]                   sessionInformation <- function() {
[17:36:34.809]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:34.809]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:34.809]                       search = base::search(), system = base::Sys.info())
[17:36:34.809]                   }
[17:36:34.809]                   ...future.conditions[[length(...future.conditions) + 
[17:36:34.809]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:34.809]                     cond$call), session = sessionInformation(), 
[17:36:34.809]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:34.809]                   signalCondition(cond)
[17:36:34.809]                 }
[17:36:34.809]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:34.809]                 "immediateCondition"))) {
[17:36:34.809]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:34.809]                   ...future.conditions[[length(...future.conditions) + 
[17:36:34.809]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:34.809]                   if (TRUE && !signal) {
[17:36:34.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:34.809]                     {
[17:36:34.809]                       inherits <- base::inherits
[17:36:34.809]                       invokeRestart <- base::invokeRestart
[17:36:34.809]                       is.null <- base::is.null
[17:36:34.809]                       muffled <- FALSE
[17:36:34.809]                       if (inherits(cond, "message")) {
[17:36:34.809]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:34.809]                         if (muffled) 
[17:36:34.809]                           invokeRestart("muffleMessage")
[17:36:34.809]                       }
[17:36:34.809]                       else if (inherits(cond, "warning")) {
[17:36:34.809]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:34.809]                         if (muffled) 
[17:36:34.809]                           invokeRestart("muffleWarning")
[17:36:34.809]                       }
[17:36:34.809]                       else if (inherits(cond, "condition")) {
[17:36:34.809]                         if (!is.null(pattern)) {
[17:36:34.809]                           computeRestarts <- base::computeRestarts
[17:36:34.809]                           grepl <- base::grepl
[17:36:34.809]                           restarts <- computeRestarts(cond)
[17:36:34.809]                           for (restart in restarts) {
[17:36:34.809]                             name <- restart$name
[17:36:34.809]                             if (is.null(name)) 
[17:36:34.809]                               next
[17:36:34.809]                             if (!grepl(pattern, name)) 
[17:36:34.809]                               next
[17:36:34.809]                             invokeRestart(restart)
[17:36:34.809]                             muffled <- TRUE
[17:36:34.809]                             break
[17:36:34.809]                           }
[17:36:34.809]                         }
[17:36:34.809]                       }
[17:36:34.809]                       invisible(muffled)
[17:36:34.809]                     }
[17:36:34.809]                     muffleCondition(cond, pattern = "^muffle")
[17:36:34.809]                   }
[17:36:34.809]                 }
[17:36:34.809]                 else {
[17:36:34.809]                   if (TRUE) {
[17:36:34.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:34.809]                     {
[17:36:34.809]                       inherits <- base::inherits
[17:36:34.809]                       invokeRestart <- base::invokeRestart
[17:36:34.809]                       is.null <- base::is.null
[17:36:34.809]                       muffled <- FALSE
[17:36:34.809]                       if (inherits(cond, "message")) {
[17:36:34.809]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:34.809]                         if (muffled) 
[17:36:34.809]                           invokeRestart("muffleMessage")
[17:36:34.809]                       }
[17:36:34.809]                       else if (inherits(cond, "warning")) {
[17:36:34.809]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:34.809]                         if (muffled) 
[17:36:34.809]                           invokeRestart("muffleWarning")
[17:36:34.809]                       }
[17:36:34.809]                       else if (inherits(cond, "condition")) {
[17:36:34.809]                         if (!is.null(pattern)) {
[17:36:34.809]                           computeRestarts <- base::computeRestarts
[17:36:34.809]                           grepl <- base::grepl
[17:36:34.809]                           restarts <- computeRestarts(cond)
[17:36:34.809]                           for (restart in restarts) {
[17:36:34.809]                             name <- restart$name
[17:36:34.809]                             if (is.null(name)) 
[17:36:34.809]                               next
[17:36:34.809]                             if (!grepl(pattern, name)) 
[17:36:34.809]                               next
[17:36:34.809]                             invokeRestart(restart)
[17:36:34.809]                             muffled <- TRUE
[17:36:34.809]                             break
[17:36:34.809]                           }
[17:36:34.809]                         }
[17:36:34.809]                       }
[17:36:34.809]                       invisible(muffled)
[17:36:34.809]                     }
[17:36:34.809]                     muffleCondition(cond, pattern = "^muffle")
[17:36:34.809]                   }
[17:36:34.809]                 }
[17:36:34.809]             }
[17:36:34.809]         }))
[17:36:34.809]     }, error = function(ex) {
[17:36:34.809]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:34.809]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:34.809]                 ...future.rng), started = ...future.startTime, 
[17:36:34.809]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:34.809]             version = "1.8"), class = "FutureResult")
[17:36:34.809]     }, finally = {
[17:36:34.809]         if (!identical(...future.workdir, getwd())) 
[17:36:34.809]             setwd(...future.workdir)
[17:36:34.809]         {
[17:36:34.809]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:34.809]                 ...future.oldOptions$nwarnings <- NULL
[17:36:34.809]             }
[17:36:34.809]             base::options(...future.oldOptions)
[17:36:34.809]             if (.Platform$OS.type == "windows") {
[17:36:34.809]                 old_names <- names(...future.oldEnvVars)
[17:36:34.809]                 envs <- base::Sys.getenv()
[17:36:34.809]                 names <- names(envs)
[17:36:34.809]                 common <- intersect(names, old_names)
[17:36:34.809]                 added <- setdiff(names, old_names)
[17:36:34.809]                 removed <- setdiff(old_names, names)
[17:36:34.809]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:34.809]                   envs[common]]
[17:36:34.809]                 NAMES <- toupper(changed)
[17:36:34.809]                 args <- list()
[17:36:34.809]                 for (kk in seq_along(NAMES)) {
[17:36:34.809]                   name <- changed[[kk]]
[17:36:34.809]                   NAME <- NAMES[[kk]]
[17:36:34.809]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.809]                     next
[17:36:34.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:34.809]                 }
[17:36:34.809]                 NAMES <- toupper(added)
[17:36:34.809]                 for (kk in seq_along(NAMES)) {
[17:36:34.809]                   name <- added[[kk]]
[17:36:34.809]                   NAME <- NAMES[[kk]]
[17:36:34.809]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.809]                     next
[17:36:34.809]                   args[[name]] <- ""
[17:36:34.809]                 }
[17:36:34.809]                 NAMES <- toupper(removed)
[17:36:34.809]                 for (kk in seq_along(NAMES)) {
[17:36:34.809]                   name <- removed[[kk]]
[17:36:34.809]                   NAME <- NAMES[[kk]]
[17:36:34.809]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.809]                     next
[17:36:34.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:34.809]                 }
[17:36:34.809]                 if (length(args) > 0) 
[17:36:34.809]                   base::do.call(base::Sys.setenv, args = args)
[17:36:34.809]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:34.809]             }
[17:36:34.809]             else {
[17:36:34.809]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:34.809]             }
[17:36:34.809]             {
[17:36:34.809]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:34.809]                   0L) {
[17:36:34.809]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:34.809]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:34.809]                   base::options(opts)
[17:36:34.809]                 }
[17:36:34.809]                 {
[17:36:34.809]                   {
[17:36:34.809]                     NULL
[17:36:34.809]                     RNGkind("Mersenne-Twister")
[17:36:34.809]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:34.809]                       inherits = FALSE)
[17:36:34.809]                   }
[17:36:34.809]                   options(future.plan = NULL)
[17:36:34.809]                   if (is.na(NA_character_)) 
[17:36:34.809]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:34.809]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:34.809]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:34.809]                     .init = FALSE)
[17:36:34.809]                 }
[17:36:34.809]             }
[17:36:34.809]         }
[17:36:34.809]     })
[17:36:34.809]     if (TRUE) {
[17:36:34.809]         base::sink(type = "output", split = FALSE)
[17:36:34.809]         if (TRUE) {
[17:36:34.809]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:34.809]         }
[17:36:34.809]         else {
[17:36:34.809]             ...future.result["stdout"] <- base::list(NULL)
[17:36:34.809]         }
[17:36:34.809]         base::close(...future.stdout)
[17:36:34.809]         ...future.stdout <- NULL
[17:36:34.809]     }
[17:36:34.809]     ...future.result$conditions <- ...future.conditions
[17:36:34.809]     ...future.result$finished <- base::Sys.time()
[17:36:34.809]     ...future.result
[17:36:34.809] }
[17:36:34.811] assign_globals() ...
[17:36:34.811] List of 5
[17:36:34.811]  $ future.call.arguments    : list()
[17:36:34.811]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.811]  $ ...future.FUN            :function (x)  
[17:36:34.811]  $ ...future.elements_ii    :List of 6
[17:36:34.811]   ..$ : int [1:4] 1 7 13 19
[17:36:34.811]   ..$ : int [1:4] 2 8 14 20
[17:36:34.811]   ..$ : int [1:4] 3 9 15 21
[17:36:34.811]   ..$ : int [1:4] 4 10 16 22
[17:36:34.811]   ..$ : int [1:4] 5 11 17 23
[17:36:34.811]   ..$ : int [1:4] 6 12 18 24
[17:36:34.811]  $ ...future.seeds_ii       : NULL
[17:36:34.811]  $ ...future.globals.maxSize: num Inf
[17:36:34.811]  - attr(*, "resolved")= logi FALSE
[17:36:34.811]  - attr(*, "total_size")= num NA
[17:36:34.811]  - attr(*, "where")=List of 5
[17:36:34.811]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:34.811]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:34.811]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:34.811]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:34.811]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:34.811]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.811]  - attr(*, "already-done")= logi TRUE
[17:36:34.817] - copied ‘future.call.arguments’ to environment
[17:36:34.817] - reassign environment for ‘...future.FUN’
[17:36:34.817] - copied ‘...future.FUN’ to environment
[17:36:34.817] - copied ‘...future.elements_ii’ to environment
[17:36:34.817] - copied ‘...future.seeds_ii’ to environment
[17:36:34.817] - copied ‘...future.globals.maxSize’ to environment
[17:36:34.817] assign_globals() ... done
[17:36:34.817] plan(): Setting new future strategy stack:
[17:36:34.818] List of future strategies:
[17:36:34.818] 1. sequential:
[17:36:34.818]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:34.818]    - tweaked: FALSE
[17:36:34.818]    - call: NULL
[17:36:34.818] plan(): nbrOfWorkers() = 1
[17:36:34.819] plan(): Setting new future strategy stack:
[17:36:34.819] List of future strategies:
[17:36:34.819] 1. sequential:
[17:36:34.819]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:34.819]    - tweaked: FALSE
[17:36:34.819]    - call: plan(strategy)
[17:36:34.819] plan(): nbrOfWorkers() = 1
[17:36:34.819] SequentialFuture started (and completed)
[17:36:34.819] - Launch lazy future ... done
[17:36:34.820] run() for ‘SequentialFuture’ ... done
[17:36:34.820] Created future:
[17:36:34.820] SequentialFuture:
[17:36:34.820] Label: ‘future_apply-1’
[17:36:34.820] Expression:
[17:36:34.820] {
[17:36:34.820]     do.call(function(...) {
[17:36:34.820]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.820]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:34.820]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.820]             on.exit(options(oopts), add = TRUE)
[17:36:34.820]         }
[17:36:34.820]         {
[17:36:34.820]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:34.820]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.820]                 ...future.FUN(...future.X_jj, ...)
[17:36:34.820]             })
[17:36:34.820]         }
[17:36:34.820]     }, args = future.call.arguments)
[17:36:34.820] }
[17:36:34.820] Lazy evaluation: FALSE
[17:36:34.820] Asynchronous evaluation: FALSE
[17:36:34.820] Local evaluation: TRUE
[17:36:34.820] Environment: R_GlobalEnv
[17:36:34.820] Capture standard output: TRUE
[17:36:34.820] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:34.820] Globals: 5 objects totaling 2.16 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 384 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:34.820] Packages: <none>
[17:36:34.820] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:34.820] Resolved: TRUE
[17:36:34.820] Value: 1.03 KiB of class ‘list’
[17:36:34.820] Early signaling: FALSE
[17:36:34.820] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:34.820] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:34.821] Chunk #1 of 1 ... DONE
[17:36:34.821] Launching 1 futures (chunks) ... DONE
[17:36:34.821] Resolving 1 futures (chunks) ...
[17:36:34.821] resolve() on list ...
[17:36:34.821]  recursive: 0
[17:36:34.821]  length: 1
[17:36:34.821] 
[17:36:34.821] resolved() for ‘SequentialFuture’ ...
[17:36:34.822] - state: ‘finished’
[17:36:34.822] - run: TRUE
[17:36:34.822] - result: ‘FutureResult’
[17:36:34.822] resolved() for ‘SequentialFuture’ ... done
[17:36:34.822] Future #1
[17:36:34.822] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:34.822] - nx: 1
[17:36:34.822] - relay: TRUE
[17:36:34.822] - stdout: TRUE
[17:36:34.822] - signal: TRUE
[17:36:34.822] - resignal: FALSE
[17:36:34.823] - force: TRUE
[17:36:34.823] - relayed: [n=1] FALSE
[17:36:34.823] - queued futures: [n=1] FALSE
[17:36:34.823]  - until=1
[17:36:34.823]  - relaying element #1
[17:36:34.823] - relayed: [n=1] TRUE
[17:36:34.823] - queued futures: [n=1] TRUE
[17:36:34.823] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:34.823]  length: 0 (resolved future 1)
[17:36:34.823] Relaying remaining futures
[17:36:34.823] signalConditionsASAP(NULL, pos=0) ...
[17:36:34.824] - nx: 1
[17:36:34.824] - relay: TRUE
[17:36:34.824] - stdout: TRUE
[17:36:34.824] - signal: TRUE
[17:36:34.824] - resignal: FALSE
[17:36:34.824] - force: TRUE
[17:36:34.824] - relayed: [n=1] TRUE
[17:36:34.824] - queued futures: [n=1] TRUE
 - flush all
[17:36:34.824] - relayed: [n=1] TRUE
[17:36:34.824] - queued futures: [n=1] TRUE
[17:36:34.824] signalConditionsASAP(NULL, pos=0) ... done
[17:36:34.825] resolve() on list ... DONE
[17:36:34.825]  - Number of value chunks collected: 1
[17:36:34.825] Resolving 1 futures (chunks) ... DONE
[17:36:34.825] Reducing values from 1 chunks ...
[17:36:34.825]  - Number of values collected after concatenation: 6
[17:36:34.825]  - Number of values expected: 6
[17:36:34.825] Reducing values from 1 chunks ... DONE
[17:36:34.825] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[17:36:34.826] getGlobalsAndPackagesXApply() ...
[17:36:34.826]  - future.globals: TRUE
[17:36:34.826] getGlobalsAndPackages() ...
[17:36:34.826] Searching for globals...
[17:36:34.827] - globals found: [1] ‘FUN’
[17:36:34.827] Searching for globals ... DONE
[17:36:34.827] Resolving globals: FALSE
[17:36:34.827] The total size of the 1 globals is 848 bytes (848 bytes)
[17:36:34.828] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:36:34.828] - globals: [1] ‘FUN’
[17:36:34.828] 
[17:36:34.828] getGlobalsAndPackages() ... DONE
[17:36:34.828]  - globals found/used: [n=1] ‘FUN’
[17:36:34.828]  - needed namespaces: [n=0] 
[17:36:34.828] Finding globals ... DONE
[17:36:34.828]  - use_args: TRUE
[17:36:34.828]  - Getting '...' globals ...
[17:36:34.829] resolve() on list ...
[17:36:34.829]  recursive: 0
[17:36:34.829]  length: 1
[17:36:34.829]  elements: ‘...’
[17:36:34.829]  length: 0 (resolved future 1)
[17:36:34.829] resolve() on list ... DONE
[17:36:34.831]    - '...' content: [n=0] 
[17:36:34.831] List of 1
[17:36:34.831]  $ ...: list()
[17:36:34.831]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.831]  - attr(*, "where")=List of 1
[17:36:34.831]   ..$ ...:<environment: 0x556d75d93ea8> 
[17:36:34.831]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.831]  - attr(*, "resolved")= logi TRUE
[17:36:34.831]  - attr(*, "total_size")= num NA
[17:36:34.833]  - Getting '...' globals ... DONE
[17:36:34.833] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:34.834] List of 2
[17:36:34.834]  $ ...future.FUN:function (x)  
[17:36:34.834]  $ ...          : list()
[17:36:34.834]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.834]  - attr(*, "where")=List of 2
[17:36:34.834]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:34.834]   ..$ ...          :<environment: 0x556d75d93ea8> 
[17:36:34.834]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.834]  - attr(*, "resolved")= logi FALSE
[17:36:34.834]  - attr(*, "total_size")= num 848
[17:36:34.836] Packages to be attached in all futures: [n=0] 
[17:36:34.836] getGlobalsAndPackagesXApply() ... DONE
[17:36:34.836] future_lapply() ...
[17:36:34.837] Number of chunks: 1
[17:36:34.837] getGlobalsAndPackagesXApply() ...
[17:36:34.837]  - future.globals: <name-value list> with names ‘list()’
[17:36:34.837]  - use_args: TRUE
[17:36:34.837] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:34.837] List of 2
[17:36:34.837]  $ ...          : list()
[17:36:34.837]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.837]  $ ...future.FUN:function (x)  
[17:36:34.837]  - attr(*, "where")=List of 2
[17:36:34.837]   ..$ ...          :<environment: 0x556d75d93ea8> 
[17:36:34.837]   ..$ ...future.FUN:<environment: namespace:base> 
[17:36:34.837]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.837]  - attr(*, "resolved")= logi FALSE
[17:36:34.837]  - attr(*, "total_size")= num NA
[17:36:34.841] Packages to be attached in all futures: [n=0] 
[17:36:34.841] getGlobalsAndPackagesXApply() ... DONE
[17:36:34.841] Number of futures (= number of chunks): 1
[17:36:34.841] Launching 1 futures (chunks) ...
[17:36:34.841] Chunk #1 of 1 ...
[17:36:34.841]  - seeds: <none>
[17:36:34.841]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.841] getGlobalsAndPackages() ...
[17:36:34.842] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.842] Resolving globals: FALSE
[17:36:34.842] Tweak future expression to call with '...' arguments ...
[17:36:34.842] {
[17:36:34.842]     do.call(function(...) {
[17:36:34.842]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.842]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:34.842]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.842]             on.exit(options(oopts), add = TRUE)
[17:36:34.842]         }
[17:36:34.842]         {
[17:36:34.842]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:34.842]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.842]                 ...future.FUN(...future.X_jj, ...)
[17:36:34.842]             })
[17:36:34.842]         }
[17:36:34.842]     }, args = future.call.arguments)
[17:36:34.842] }
[17:36:34.842] Tweak future expression to call with '...' arguments ... DONE
[17:36:34.842] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.843] 
[17:36:34.843] getGlobalsAndPackages() ... DONE
[17:36:34.843] run() for ‘Future’ ...
[17:36:34.843] - state: ‘created’
[17:36:34.843] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:34.843] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:34.844] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:34.844]   - Field: ‘label’
[17:36:34.844]   - Field: ‘local’
[17:36:34.844]   - Field: ‘owner’
[17:36:34.844]   - Field: ‘envir’
[17:36:34.844]   - Field: ‘packages’
[17:36:34.844]   - Field: ‘gc’
[17:36:34.844]   - Field: ‘conditions’
[17:36:34.844]   - Field: ‘expr’
[17:36:34.844]   - Field: ‘uuid’
[17:36:34.844]   - Field: ‘seed’
[17:36:34.845]   - Field: ‘version’
[17:36:34.845]   - Field: ‘result’
[17:36:34.845]   - Field: ‘asynchronous’
[17:36:34.845]   - Field: ‘calls’
[17:36:34.845]   - Field: ‘globals’
[17:36:34.845]   - Field: ‘stdout’
[17:36:34.845]   - Field: ‘earlySignal’
[17:36:34.845]   - Field: ‘lazy’
[17:36:34.845]   - Field: ‘state’
[17:36:34.845] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:34.845] - Launch lazy future ...
[17:36:34.846] Packages needed by the future expression (n = 0): <none>
[17:36:34.846] Packages needed by future strategies (n = 0): <none>
[17:36:34.846] {
[17:36:34.846]     {
[17:36:34.846]         {
[17:36:34.846]             ...future.startTime <- base::Sys.time()
[17:36:34.846]             {
[17:36:34.846]                 {
[17:36:34.846]                   {
[17:36:34.846]                     base::local({
[17:36:34.846]                       has_future <- base::requireNamespace("future", 
[17:36:34.846]                         quietly = TRUE)
[17:36:34.846]                       if (has_future) {
[17:36:34.846]                         ns <- base::getNamespace("future")
[17:36:34.846]                         version <- ns[[".package"]][["version"]]
[17:36:34.846]                         if (is.null(version)) 
[17:36:34.846]                           version <- utils::packageVersion("future")
[17:36:34.846]                       }
[17:36:34.846]                       else {
[17:36:34.846]                         version <- NULL
[17:36:34.846]                       }
[17:36:34.846]                       if (!has_future || version < "1.8.0") {
[17:36:34.846]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:34.846]                           "", base::R.version$version.string), 
[17:36:34.846]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:34.846]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:34.846]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:34.846]                             "release", "version")], collapse = " "), 
[17:36:34.846]                           hostname = base::Sys.info()[["nodename"]])
[17:36:34.846]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:34.846]                           info)
[17:36:34.846]                         info <- base::paste(info, collapse = "; ")
[17:36:34.846]                         if (!has_future) {
[17:36:34.846]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:34.846]                             info)
[17:36:34.846]                         }
[17:36:34.846]                         else {
[17:36:34.846]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:34.846]                             info, version)
[17:36:34.846]                         }
[17:36:34.846]                         base::stop(msg)
[17:36:34.846]                       }
[17:36:34.846]                     })
[17:36:34.846]                   }
[17:36:34.846]                   ...future.strategy.old <- future::plan("list")
[17:36:34.846]                   options(future.plan = NULL)
[17:36:34.846]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:34.846]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:34.846]                 }
[17:36:34.846]                 ...future.workdir <- getwd()
[17:36:34.846]             }
[17:36:34.846]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:34.846]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:34.846]         }
[17:36:34.846]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:34.846]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:34.846]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:34.846]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:34.846]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:34.846]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:34.846]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:34.846]             base::names(...future.oldOptions))
[17:36:34.846]     }
[17:36:34.846]     if (FALSE) {
[17:36:34.846]     }
[17:36:34.846]     else {
[17:36:34.846]         if (TRUE) {
[17:36:34.846]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:34.846]                 open = "w")
[17:36:34.846]         }
[17:36:34.846]         else {
[17:36:34.846]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:34.846]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:34.846]         }
[17:36:34.846]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:34.846]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:34.846]             base::sink(type = "output", split = FALSE)
[17:36:34.846]             base::close(...future.stdout)
[17:36:34.846]         }, add = TRUE)
[17:36:34.846]     }
[17:36:34.846]     ...future.frame <- base::sys.nframe()
[17:36:34.846]     ...future.conditions <- base::list()
[17:36:34.846]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:34.846]     if (FALSE) {
[17:36:34.846]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:34.846]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:34.846]     }
[17:36:34.846]     ...future.result <- base::tryCatch({
[17:36:34.846]         base::withCallingHandlers({
[17:36:34.846]             ...future.value <- base::withVisible(base::local({
[17:36:34.846]                 do.call(function(...) {
[17:36:34.846]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.846]                   if (!identical(...future.globals.maxSize.org, 
[17:36:34.846]                     ...future.globals.maxSize)) {
[17:36:34.846]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.846]                     on.exit(options(oopts), add = TRUE)
[17:36:34.846]                   }
[17:36:34.846]                   {
[17:36:34.846]                     lapply(seq_along(...future.elements_ii), 
[17:36:34.846]                       FUN = function(jj) {
[17:36:34.846]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.846]                         ...future.FUN(...future.X_jj, ...)
[17:36:34.846]                       })
[17:36:34.846]                   }
[17:36:34.846]                 }, args = future.call.arguments)
[17:36:34.846]             }))
[17:36:34.846]             future::FutureResult(value = ...future.value$value, 
[17:36:34.846]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:34.846]                   ...future.rng), globalenv = if (FALSE) 
[17:36:34.846]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:34.846]                     ...future.globalenv.names))
[17:36:34.846]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:34.846]         }, condition = base::local({
[17:36:34.846]             c <- base::c
[17:36:34.846]             inherits <- base::inherits
[17:36:34.846]             invokeRestart <- base::invokeRestart
[17:36:34.846]             length <- base::length
[17:36:34.846]             list <- base::list
[17:36:34.846]             seq.int <- base::seq.int
[17:36:34.846]             signalCondition <- base::signalCondition
[17:36:34.846]             sys.calls <- base::sys.calls
[17:36:34.846]             `[[` <- base::`[[`
[17:36:34.846]             `+` <- base::`+`
[17:36:34.846]             `<<-` <- base::`<<-`
[17:36:34.846]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:34.846]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:34.846]                   3L)]
[17:36:34.846]             }
[17:36:34.846]             function(cond) {
[17:36:34.846]                 is_error <- inherits(cond, "error")
[17:36:34.846]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:34.846]                   NULL)
[17:36:34.846]                 if (is_error) {
[17:36:34.846]                   sessionInformation <- function() {
[17:36:34.846]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:34.846]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:34.846]                       search = base::search(), system = base::Sys.info())
[17:36:34.846]                   }
[17:36:34.846]                   ...future.conditions[[length(...future.conditions) + 
[17:36:34.846]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:34.846]                     cond$call), session = sessionInformation(), 
[17:36:34.846]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:34.846]                   signalCondition(cond)
[17:36:34.846]                 }
[17:36:34.846]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:34.846]                 "immediateCondition"))) {
[17:36:34.846]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:34.846]                   ...future.conditions[[length(...future.conditions) + 
[17:36:34.846]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:34.846]                   if (TRUE && !signal) {
[17:36:34.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:34.846]                     {
[17:36:34.846]                       inherits <- base::inherits
[17:36:34.846]                       invokeRestart <- base::invokeRestart
[17:36:34.846]                       is.null <- base::is.null
[17:36:34.846]                       muffled <- FALSE
[17:36:34.846]                       if (inherits(cond, "message")) {
[17:36:34.846]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:34.846]                         if (muffled) 
[17:36:34.846]                           invokeRestart("muffleMessage")
[17:36:34.846]                       }
[17:36:34.846]                       else if (inherits(cond, "warning")) {
[17:36:34.846]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:34.846]                         if (muffled) 
[17:36:34.846]                           invokeRestart("muffleWarning")
[17:36:34.846]                       }
[17:36:34.846]                       else if (inherits(cond, "condition")) {
[17:36:34.846]                         if (!is.null(pattern)) {
[17:36:34.846]                           computeRestarts <- base::computeRestarts
[17:36:34.846]                           grepl <- base::grepl
[17:36:34.846]                           restarts <- computeRestarts(cond)
[17:36:34.846]                           for (restart in restarts) {
[17:36:34.846]                             name <- restart$name
[17:36:34.846]                             if (is.null(name)) 
[17:36:34.846]                               next
[17:36:34.846]                             if (!grepl(pattern, name)) 
[17:36:34.846]                               next
[17:36:34.846]                             invokeRestart(restart)
[17:36:34.846]                             muffled <- TRUE
[17:36:34.846]                             break
[17:36:34.846]                           }
[17:36:34.846]                         }
[17:36:34.846]                       }
[17:36:34.846]                       invisible(muffled)
[17:36:34.846]                     }
[17:36:34.846]                     muffleCondition(cond, pattern = "^muffle")
[17:36:34.846]                   }
[17:36:34.846]                 }
[17:36:34.846]                 else {
[17:36:34.846]                   if (TRUE) {
[17:36:34.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:34.846]                     {
[17:36:34.846]                       inherits <- base::inherits
[17:36:34.846]                       invokeRestart <- base::invokeRestart
[17:36:34.846]                       is.null <- base::is.null
[17:36:34.846]                       muffled <- FALSE
[17:36:34.846]                       if (inherits(cond, "message")) {
[17:36:34.846]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:34.846]                         if (muffled) 
[17:36:34.846]                           invokeRestart("muffleMessage")
[17:36:34.846]                       }
[17:36:34.846]                       else if (inherits(cond, "warning")) {
[17:36:34.846]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:34.846]                         if (muffled) 
[17:36:34.846]                           invokeRestart("muffleWarning")
[17:36:34.846]                       }
[17:36:34.846]                       else if (inherits(cond, "condition")) {
[17:36:34.846]                         if (!is.null(pattern)) {
[17:36:34.846]                           computeRestarts <- base::computeRestarts
[17:36:34.846]                           grepl <- base::grepl
[17:36:34.846]                           restarts <- computeRestarts(cond)
[17:36:34.846]                           for (restart in restarts) {
[17:36:34.846]                             name <- restart$name
[17:36:34.846]                             if (is.null(name)) 
[17:36:34.846]                               next
[17:36:34.846]                             if (!grepl(pattern, name)) 
[17:36:34.846]                               next
[17:36:34.846]                             invokeRestart(restart)
[17:36:34.846]                             muffled <- TRUE
[17:36:34.846]                             break
[17:36:34.846]                           }
[17:36:34.846]                         }
[17:36:34.846]                       }
[17:36:34.846]                       invisible(muffled)
[17:36:34.846]                     }
[17:36:34.846]                     muffleCondition(cond, pattern = "^muffle")
[17:36:34.846]                   }
[17:36:34.846]                 }
[17:36:34.846]             }
[17:36:34.846]         }))
[17:36:34.846]     }, error = function(ex) {
[17:36:34.846]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:34.846]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:34.846]                 ...future.rng), started = ...future.startTime, 
[17:36:34.846]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:34.846]             version = "1.8"), class = "FutureResult")
[17:36:34.846]     }, finally = {
[17:36:34.846]         if (!identical(...future.workdir, getwd())) 
[17:36:34.846]             setwd(...future.workdir)
[17:36:34.846]         {
[17:36:34.846]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:34.846]                 ...future.oldOptions$nwarnings <- NULL
[17:36:34.846]             }
[17:36:34.846]             base::options(...future.oldOptions)
[17:36:34.846]             if (.Platform$OS.type == "windows") {
[17:36:34.846]                 old_names <- names(...future.oldEnvVars)
[17:36:34.846]                 envs <- base::Sys.getenv()
[17:36:34.846]                 names <- names(envs)
[17:36:34.846]                 common <- intersect(names, old_names)
[17:36:34.846]                 added <- setdiff(names, old_names)
[17:36:34.846]                 removed <- setdiff(old_names, names)
[17:36:34.846]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:34.846]                   envs[common]]
[17:36:34.846]                 NAMES <- toupper(changed)
[17:36:34.846]                 args <- list()
[17:36:34.846]                 for (kk in seq_along(NAMES)) {
[17:36:34.846]                   name <- changed[[kk]]
[17:36:34.846]                   NAME <- NAMES[[kk]]
[17:36:34.846]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.846]                     next
[17:36:34.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:34.846]                 }
[17:36:34.846]                 NAMES <- toupper(added)
[17:36:34.846]                 for (kk in seq_along(NAMES)) {
[17:36:34.846]                   name <- added[[kk]]
[17:36:34.846]                   NAME <- NAMES[[kk]]
[17:36:34.846]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.846]                     next
[17:36:34.846]                   args[[name]] <- ""
[17:36:34.846]                 }
[17:36:34.846]                 NAMES <- toupper(removed)
[17:36:34.846]                 for (kk in seq_along(NAMES)) {
[17:36:34.846]                   name <- removed[[kk]]
[17:36:34.846]                   NAME <- NAMES[[kk]]
[17:36:34.846]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.846]                     next
[17:36:34.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:34.846]                 }
[17:36:34.846]                 if (length(args) > 0) 
[17:36:34.846]                   base::do.call(base::Sys.setenv, args = args)
[17:36:34.846]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:34.846]             }
[17:36:34.846]             else {
[17:36:34.846]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:34.846]             }
[17:36:34.846]             {
[17:36:34.846]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:34.846]                   0L) {
[17:36:34.846]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:34.846]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:34.846]                   base::options(opts)
[17:36:34.846]                 }
[17:36:34.846]                 {
[17:36:34.846]                   {
[17:36:34.846]                     NULL
[17:36:34.846]                     RNGkind("Mersenne-Twister")
[17:36:34.846]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:34.846]                       inherits = FALSE)
[17:36:34.846]                   }
[17:36:34.846]                   options(future.plan = NULL)
[17:36:34.846]                   if (is.na(NA_character_)) 
[17:36:34.846]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:34.846]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:34.846]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:34.846]                     .init = FALSE)
[17:36:34.846]                 }
[17:36:34.846]             }
[17:36:34.846]         }
[17:36:34.846]     })
[17:36:34.846]     if (TRUE) {
[17:36:34.846]         base::sink(type = "output", split = FALSE)
[17:36:34.846]         if (TRUE) {
[17:36:34.846]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:34.846]         }
[17:36:34.846]         else {
[17:36:34.846]             ...future.result["stdout"] <- base::list(NULL)
[17:36:34.846]         }
[17:36:34.846]         base::close(...future.stdout)
[17:36:34.846]         ...future.stdout <- NULL
[17:36:34.846]     }
[17:36:34.846]     ...future.result$conditions <- ...future.conditions
[17:36:34.846]     ...future.result$finished <- base::Sys.time()
[17:36:34.846]     ...future.result
[17:36:34.846] }
[17:36:34.848] assign_globals() ...
[17:36:34.848] List of 5
[17:36:34.848]  $ future.call.arguments    : list()
[17:36:34.848]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.848]  $ ...future.FUN            :function (x)  
[17:36:34.848]  $ ...future.elements_ii    :List of 2
[17:36:34.848]   ..$ : int 1
[17:36:34.848]   ..$ : int 2
[17:36:34.848]  $ ...future.seeds_ii       : NULL
[17:36:34.848]  $ ...future.globals.maxSize: num Inf
[17:36:34.848]  - attr(*, "resolved")= logi FALSE
[17:36:34.848]  - attr(*, "total_size")= num NA
[17:36:34.848]  - attr(*, "where")=List of 5
[17:36:34.848]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:34.848]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:34.848]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:34.848]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:34.848]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:34.848]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.848]  - attr(*, "already-done")= logi TRUE
[17:36:34.853] - copied ‘future.call.arguments’ to environment
[17:36:34.853] - copied ‘...future.FUN’ to environment
[17:36:34.881] - copied ‘...future.elements_ii’ to environment
[17:36:34.882] - copied ‘...future.seeds_ii’ to environment
[17:36:34.882] - copied ‘...future.globals.maxSize’ to environment
[17:36:34.882] assign_globals() ... done
[17:36:34.882] plan(): Setting new future strategy stack:
[17:36:34.882] List of future strategies:
[17:36:34.882] 1. sequential:
[17:36:34.882]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:34.882]    - tweaked: FALSE
[17:36:34.882]    - call: NULL
[17:36:34.883] plan(): nbrOfWorkers() = 1
[17:36:34.884] plan(): Setting new future strategy stack:
[17:36:34.884] List of future strategies:
[17:36:34.884] 1. sequential:
[17:36:34.884]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:34.884]    - tweaked: FALSE
[17:36:34.884]    - call: plan(strategy)
[17:36:34.884] plan(): nbrOfWorkers() = 1
[17:36:34.884] SequentialFuture started (and completed)
[17:36:34.884] - Launch lazy future ... done
[17:36:34.885] run() for ‘SequentialFuture’ ... done
[17:36:34.885] Created future:
[17:36:34.885] SequentialFuture:
[17:36:34.885] Label: ‘future_apply-1’
[17:36:34.885] Expression:
[17:36:34.885] {
[17:36:34.885]     do.call(function(...) {
[17:36:34.885]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.885]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:34.885]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.885]             on.exit(options(oopts), add = TRUE)
[17:36:34.885]         }
[17:36:34.885]         {
[17:36:34.885]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:34.885]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.885]                 ...future.FUN(...future.X_jj, ...)
[17:36:34.885]             })
[17:36:34.885]         }
[17:36:34.885]     }, args = future.call.arguments)
[17:36:34.885] }
[17:36:34.885] Lazy evaluation: FALSE
[17:36:34.885] Asynchronous evaluation: FALSE
[17:36:34.885] Local evaluation: TRUE
[17:36:34.885] Environment: R_GlobalEnv
[17:36:34.885] Capture standard output: TRUE
[17:36:34.885] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:34.885] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:34.885] Packages: <none>
[17:36:34.885] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:34.885] Resolved: TRUE
[17:36:34.885] Value: 112 bytes of class ‘list’
[17:36:34.885] Early signaling: FALSE
[17:36:34.885] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:34.885] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:34.886] Chunk #1 of 1 ... DONE
[17:36:34.886] Launching 1 futures (chunks) ... DONE
[17:36:34.886] Resolving 1 futures (chunks) ...
[17:36:34.886] resolve() on list ...
[17:36:34.886]  recursive: 0
[17:36:34.886]  length: 1
[17:36:34.886] 
[17:36:34.886] resolved() for ‘SequentialFuture’ ...
[17:36:34.886] - state: ‘finished’
[17:36:34.887] - run: TRUE
[17:36:34.887] - result: ‘FutureResult’
[17:36:34.887] resolved() for ‘SequentialFuture’ ... done
[17:36:34.887] Future #1
[17:36:34.887] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:34.887] - nx: 1
[17:36:34.887] - relay: TRUE
[17:36:34.887] - stdout: TRUE
[17:36:34.887] - signal: TRUE
[17:36:34.887] - resignal: FALSE
[17:36:34.888] - force: TRUE
[17:36:34.888] - relayed: [n=1] FALSE
[17:36:34.888] - queued futures: [n=1] FALSE
[17:36:34.888]  - until=1
[17:36:34.888]  - relaying element #1
[17:36:34.888] - relayed: [n=1] TRUE
[17:36:34.888] - queued futures: [n=1] TRUE
[17:36:34.888] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:34.888]  length: 0 (resolved future 1)
[17:36:34.888] Relaying remaining futures
[17:36:34.889] signalConditionsASAP(NULL, pos=0) ...
[17:36:34.889] - nx: 1
[17:36:34.889] - relay: TRUE
[17:36:34.889] - stdout: TRUE
[17:36:34.889] - signal: TRUE
[17:36:34.889] - resignal: FALSE
[17:36:34.889] - force: TRUE
[17:36:34.889] - relayed: [n=1] TRUE
[17:36:34.889] - queued futures: [n=1] TRUE
 - flush all
[17:36:34.889] - relayed: [n=1] TRUE
[17:36:34.889] - queued futures: [n=1] TRUE
[17:36:34.889] signalConditionsASAP(NULL, pos=0) ... done
[17:36:34.890] resolve() on list ... DONE
[17:36:34.890]  - Number of value chunks collected: 1
[17:36:34.890] Resolving 1 futures (chunks) ... DONE
[17:36:34.890] Reducing values from 1 chunks ...
[17:36:34.890]  - Number of values collected after concatenation: 2
[17:36:34.890]  - Number of values expected: 2
[17:36:34.890] Reducing values from 1 chunks ... DONE
[17:36:34.890] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[17:36:34.890] getGlobalsAndPackagesXApply() ...
[17:36:34.891]  - future.globals: TRUE
[17:36:34.891] getGlobalsAndPackages() ...
[17:36:34.891] Searching for globals...
[17:36:34.892] - globals found: [1] ‘FUN’
[17:36:34.892] Searching for globals ... DONE
[17:36:34.892] Resolving globals: FALSE
[17:36:34.892] The total size of the 1 globals is 848 bytes (848 bytes)
[17:36:34.893] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:36:34.893] - globals: [1] ‘FUN’
[17:36:34.893] 
[17:36:34.893] getGlobalsAndPackages() ... DONE
[17:36:34.893]  - globals found/used: [n=1] ‘FUN’
[17:36:34.893]  - needed namespaces: [n=0] 
[17:36:34.893] Finding globals ... DONE
[17:36:34.893]  - use_args: TRUE
[17:36:34.893]  - Getting '...' globals ...
[17:36:34.894] resolve() on list ...
[17:36:34.894]  recursive: 0
[17:36:34.894]  length: 1
[17:36:34.894]  elements: ‘...’
[17:36:34.894]  length: 0 (resolved future 1)
[17:36:34.894] resolve() on list ... DONE
[17:36:34.894]    - '...' content: [n=0] 
[17:36:34.894] List of 1
[17:36:34.894]  $ ...: list()
[17:36:34.894]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.894]  - attr(*, "where")=List of 1
[17:36:34.894]   ..$ ...:<environment: 0x556d747254c0> 
[17:36:34.894]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.894]  - attr(*, "resolved")= logi TRUE
[17:36:34.894]  - attr(*, "total_size")= num NA
[17:36:34.897]  - Getting '...' globals ... DONE
[17:36:34.897] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:34.897] List of 2
[17:36:34.897]  $ ...future.FUN:function (x)  
[17:36:34.897]  $ ...          : list()
[17:36:34.897]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.897]  - attr(*, "where")=List of 2
[17:36:34.897]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:34.897]   ..$ ...          :<environment: 0x556d747254c0> 
[17:36:34.897]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.897]  - attr(*, "resolved")= logi FALSE
[17:36:34.897]  - attr(*, "total_size")= num 848
[17:36:34.900] Packages to be attached in all futures: [n=0] 
[17:36:34.900] getGlobalsAndPackagesXApply() ... DONE
[17:36:34.900] future_lapply() ...
[17:36:34.900] Number of chunks: 1
[17:36:34.900] getGlobalsAndPackagesXApply() ...
[17:36:34.901]  - future.globals: <name-value list> with names ‘list()’
[17:36:34.901]  - use_args: TRUE
[17:36:34.901] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:34.901] List of 2
[17:36:34.901]  $ ...          : list()
[17:36:34.901]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.901]  $ ...future.FUN:function (x)  
[17:36:34.901]  - attr(*, "where")=List of 2
[17:36:34.901]   ..$ ...          :<environment: 0x556d747254c0> 
[17:36:34.901]   ..$ ...future.FUN:<environment: namespace:base> 
[17:36:34.901]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.901]  - attr(*, "resolved")= logi FALSE
[17:36:34.901]  - attr(*, "total_size")= num NA
[17:36:34.904] Packages to be attached in all futures: [n=0] 
[17:36:34.904] getGlobalsAndPackagesXApply() ... DONE
[17:36:34.904] Number of futures (= number of chunks): 1
[17:36:34.904] Launching 1 futures (chunks) ...
[17:36:34.904] Chunk #1 of 1 ...
[17:36:34.905]  - seeds: <none>
[17:36:34.905]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.905] getGlobalsAndPackages() ...
[17:36:34.905] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.905] Resolving globals: FALSE
[17:36:34.905] Tweak future expression to call with '...' arguments ...
[17:36:34.905] {
[17:36:34.905]     do.call(function(...) {
[17:36:34.905]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.905]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:34.905]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.905]             on.exit(options(oopts), add = TRUE)
[17:36:34.905]         }
[17:36:34.905]         {
[17:36:34.905]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:34.905]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.905]                 ...future.FUN(...future.X_jj, ...)
[17:36:34.905]             })
[17:36:34.905]         }
[17:36:34.905]     }, args = future.call.arguments)
[17:36:34.905] }
[17:36:34.906] Tweak future expression to call with '...' arguments ... DONE
[17:36:34.907] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.907] 
[17:36:34.907] getGlobalsAndPackages() ... DONE
[17:36:34.907] run() for ‘Future’ ...
[17:36:34.907] - state: ‘created’
[17:36:34.908] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:34.908] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:34.908] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:34.908]   - Field: ‘label’
[17:36:34.908]   - Field: ‘local’
[17:36:34.908]   - Field: ‘owner’
[17:36:34.909]   - Field: ‘envir’
[17:36:34.909]   - Field: ‘packages’
[17:36:34.909]   - Field: ‘gc’
[17:36:34.909]   - Field: ‘conditions’
[17:36:34.909]   - Field: ‘expr’
[17:36:34.909]   - Field: ‘uuid’
[17:36:34.909]   - Field: ‘seed’
[17:36:34.909]   - Field: ‘version’
[17:36:34.909]   - Field: ‘result’
[17:36:34.909]   - Field: ‘asynchronous’
[17:36:34.909]   - Field: ‘calls’
[17:36:34.910]   - Field: ‘globals’
[17:36:34.910]   - Field: ‘stdout’
[17:36:34.910]   - Field: ‘earlySignal’
[17:36:34.910]   - Field: ‘lazy’
[17:36:34.910]   - Field: ‘state’
[17:36:34.910] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:34.910] - Launch lazy future ...
[17:36:34.910] Packages needed by the future expression (n = 0): <none>
[17:36:34.910] Packages needed by future strategies (n = 0): <none>
[17:36:34.911] {
[17:36:34.911]     {
[17:36:34.911]         {
[17:36:34.911]             ...future.startTime <- base::Sys.time()
[17:36:34.911]             {
[17:36:34.911]                 {
[17:36:34.911]                   {
[17:36:34.911]                     base::local({
[17:36:34.911]                       has_future <- base::requireNamespace("future", 
[17:36:34.911]                         quietly = TRUE)
[17:36:34.911]                       if (has_future) {
[17:36:34.911]                         ns <- base::getNamespace("future")
[17:36:34.911]                         version <- ns[[".package"]][["version"]]
[17:36:34.911]                         if (is.null(version)) 
[17:36:34.911]                           version <- utils::packageVersion("future")
[17:36:34.911]                       }
[17:36:34.911]                       else {
[17:36:34.911]                         version <- NULL
[17:36:34.911]                       }
[17:36:34.911]                       if (!has_future || version < "1.8.0") {
[17:36:34.911]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:34.911]                           "", base::R.version$version.string), 
[17:36:34.911]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:34.911]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:34.911]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:34.911]                             "release", "version")], collapse = " "), 
[17:36:34.911]                           hostname = base::Sys.info()[["nodename"]])
[17:36:34.911]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:34.911]                           info)
[17:36:34.911]                         info <- base::paste(info, collapse = "; ")
[17:36:34.911]                         if (!has_future) {
[17:36:34.911]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:34.911]                             info)
[17:36:34.911]                         }
[17:36:34.911]                         else {
[17:36:34.911]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:34.911]                             info, version)
[17:36:34.911]                         }
[17:36:34.911]                         base::stop(msg)
[17:36:34.911]                       }
[17:36:34.911]                     })
[17:36:34.911]                   }
[17:36:34.911]                   ...future.strategy.old <- future::plan("list")
[17:36:34.911]                   options(future.plan = NULL)
[17:36:34.911]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:34.911]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:34.911]                 }
[17:36:34.911]                 ...future.workdir <- getwd()
[17:36:34.911]             }
[17:36:34.911]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:34.911]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:34.911]         }
[17:36:34.911]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:34.911]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:34.911]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:34.911]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:34.911]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:34.911]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:34.911]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:34.911]             base::names(...future.oldOptions))
[17:36:34.911]     }
[17:36:34.911]     if (FALSE) {
[17:36:34.911]     }
[17:36:34.911]     else {
[17:36:34.911]         if (TRUE) {
[17:36:34.911]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:34.911]                 open = "w")
[17:36:34.911]         }
[17:36:34.911]         else {
[17:36:34.911]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:34.911]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:34.911]         }
[17:36:34.911]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:34.911]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:34.911]             base::sink(type = "output", split = FALSE)
[17:36:34.911]             base::close(...future.stdout)
[17:36:34.911]         }, add = TRUE)
[17:36:34.911]     }
[17:36:34.911]     ...future.frame <- base::sys.nframe()
[17:36:34.911]     ...future.conditions <- base::list()
[17:36:34.911]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:34.911]     if (FALSE) {
[17:36:34.911]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:34.911]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:34.911]     }
[17:36:34.911]     ...future.result <- base::tryCatch({
[17:36:34.911]         base::withCallingHandlers({
[17:36:34.911]             ...future.value <- base::withVisible(base::local({
[17:36:34.911]                 do.call(function(...) {
[17:36:34.911]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.911]                   if (!identical(...future.globals.maxSize.org, 
[17:36:34.911]                     ...future.globals.maxSize)) {
[17:36:34.911]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.911]                     on.exit(options(oopts), add = TRUE)
[17:36:34.911]                   }
[17:36:34.911]                   {
[17:36:34.911]                     lapply(seq_along(...future.elements_ii), 
[17:36:34.911]                       FUN = function(jj) {
[17:36:34.911]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.911]                         ...future.FUN(...future.X_jj, ...)
[17:36:34.911]                       })
[17:36:34.911]                   }
[17:36:34.911]                 }, args = future.call.arguments)
[17:36:34.911]             }))
[17:36:34.911]             future::FutureResult(value = ...future.value$value, 
[17:36:34.911]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:34.911]                   ...future.rng), globalenv = if (FALSE) 
[17:36:34.911]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:34.911]                     ...future.globalenv.names))
[17:36:34.911]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:34.911]         }, condition = base::local({
[17:36:34.911]             c <- base::c
[17:36:34.911]             inherits <- base::inherits
[17:36:34.911]             invokeRestart <- base::invokeRestart
[17:36:34.911]             length <- base::length
[17:36:34.911]             list <- base::list
[17:36:34.911]             seq.int <- base::seq.int
[17:36:34.911]             signalCondition <- base::signalCondition
[17:36:34.911]             sys.calls <- base::sys.calls
[17:36:34.911]             `[[` <- base::`[[`
[17:36:34.911]             `+` <- base::`+`
[17:36:34.911]             `<<-` <- base::`<<-`
[17:36:34.911]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:34.911]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:34.911]                   3L)]
[17:36:34.911]             }
[17:36:34.911]             function(cond) {
[17:36:34.911]                 is_error <- inherits(cond, "error")
[17:36:34.911]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:34.911]                   NULL)
[17:36:34.911]                 if (is_error) {
[17:36:34.911]                   sessionInformation <- function() {
[17:36:34.911]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:34.911]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:34.911]                       search = base::search(), system = base::Sys.info())
[17:36:34.911]                   }
[17:36:34.911]                   ...future.conditions[[length(...future.conditions) + 
[17:36:34.911]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:34.911]                     cond$call), session = sessionInformation(), 
[17:36:34.911]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:34.911]                   signalCondition(cond)
[17:36:34.911]                 }
[17:36:34.911]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:34.911]                 "immediateCondition"))) {
[17:36:34.911]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:34.911]                   ...future.conditions[[length(...future.conditions) + 
[17:36:34.911]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:34.911]                   if (TRUE && !signal) {
[17:36:34.911]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:34.911]                     {
[17:36:34.911]                       inherits <- base::inherits
[17:36:34.911]                       invokeRestart <- base::invokeRestart
[17:36:34.911]                       is.null <- base::is.null
[17:36:34.911]                       muffled <- FALSE
[17:36:34.911]                       if (inherits(cond, "message")) {
[17:36:34.911]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:34.911]                         if (muffled) 
[17:36:34.911]                           invokeRestart("muffleMessage")
[17:36:34.911]                       }
[17:36:34.911]                       else if (inherits(cond, "warning")) {
[17:36:34.911]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:34.911]                         if (muffled) 
[17:36:34.911]                           invokeRestart("muffleWarning")
[17:36:34.911]                       }
[17:36:34.911]                       else if (inherits(cond, "condition")) {
[17:36:34.911]                         if (!is.null(pattern)) {
[17:36:34.911]                           computeRestarts <- base::computeRestarts
[17:36:34.911]                           grepl <- base::grepl
[17:36:34.911]                           restarts <- computeRestarts(cond)
[17:36:34.911]                           for (restart in restarts) {
[17:36:34.911]                             name <- restart$name
[17:36:34.911]                             if (is.null(name)) 
[17:36:34.911]                               next
[17:36:34.911]                             if (!grepl(pattern, name)) 
[17:36:34.911]                               next
[17:36:34.911]                             invokeRestart(restart)
[17:36:34.911]                             muffled <- TRUE
[17:36:34.911]                             break
[17:36:34.911]                           }
[17:36:34.911]                         }
[17:36:34.911]                       }
[17:36:34.911]                       invisible(muffled)
[17:36:34.911]                     }
[17:36:34.911]                     muffleCondition(cond, pattern = "^muffle")
[17:36:34.911]                   }
[17:36:34.911]                 }
[17:36:34.911]                 else {
[17:36:34.911]                   if (TRUE) {
[17:36:34.911]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:34.911]                     {
[17:36:34.911]                       inherits <- base::inherits
[17:36:34.911]                       invokeRestart <- base::invokeRestart
[17:36:34.911]                       is.null <- base::is.null
[17:36:34.911]                       muffled <- FALSE
[17:36:34.911]                       if (inherits(cond, "message")) {
[17:36:34.911]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:34.911]                         if (muffled) 
[17:36:34.911]                           invokeRestart("muffleMessage")
[17:36:34.911]                       }
[17:36:34.911]                       else if (inherits(cond, "warning")) {
[17:36:34.911]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:34.911]                         if (muffled) 
[17:36:34.911]                           invokeRestart("muffleWarning")
[17:36:34.911]                       }
[17:36:34.911]                       else if (inherits(cond, "condition")) {
[17:36:34.911]                         if (!is.null(pattern)) {
[17:36:34.911]                           computeRestarts <- base::computeRestarts
[17:36:34.911]                           grepl <- base::grepl
[17:36:34.911]                           restarts <- computeRestarts(cond)
[17:36:34.911]                           for (restart in restarts) {
[17:36:34.911]                             name <- restart$name
[17:36:34.911]                             if (is.null(name)) 
[17:36:34.911]                               next
[17:36:34.911]                             if (!grepl(pattern, name)) 
[17:36:34.911]                               next
[17:36:34.911]                             invokeRestart(restart)
[17:36:34.911]                             muffled <- TRUE
[17:36:34.911]                             break
[17:36:34.911]                           }
[17:36:34.911]                         }
[17:36:34.911]                       }
[17:36:34.911]                       invisible(muffled)
[17:36:34.911]                     }
[17:36:34.911]                     muffleCondition(cond, pattern = "^muffle")
[17:36:34.911]                   }
[17:36:34.911]                 }
[17:36:34.911]             }
[17:36:34.911]         }))
[17:36:34.911]     }, error = function(ex) {
[17:36:34.911]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:34.911]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:34.911]                 ...future.rng), started = ...future.startTime, 
[17:36:34.911]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:34.911]             version = "1.8"), class = "FutureResult")
[17:36:34.911]     }, finally = {
[17:36:34.911]         if (!identical(...future.workdir, getwd())) 
[17:36:34.911]             setwd(...future.workdir)
[17:36:34.911]         {
[17:36:34.911]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:34.911]                 ...future.oldOptions$nwarnings <- NULL
[17:36:34.911]             }
[17:36:34.911]             base::options(...future.oldOptions)
[17:36:34.911]             if (.Platform$OS.type == "windows") {
[17:36:34.911]                 old_names <- names(...future.oldEnvVars)
[17:36:34.911]                 envs <- base::Sys.getenv()
[17:36:34.911]                 names <- names(envs)
[17:36:34.911]                 common <- intersect(names, old_names)
[17:36:34.911]                 added <- setdiff(names, old_names)
[17:36:34.911]                 removed <- setdiff(old_names, names)
[17:36:34.911]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:34.911]                   envs[common]]
[17:36:34.911]                 NAMES <- toupper(changed)
[17:36:34.911]                 args <- list()
[17:36:34.911]                 for (kk in seq_along(NAMES)) {
[17:36:34.911]                   name <- changed[[kk]]
[17:36:34.911]                   NAME <- NAMES[[kk]]
[17:36:34.911]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.911]                     next
[17:36:34.911]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:34.911]                 }
[17:36:34.911]                 NAMES <- toupper(added)
[17:36:34.911]                 for (kk in seq_along(NAMES)) {
[17:36:34.911]                   name <- added[[kk]]
[17:36:34.911]                   NAME <- NAMES[[kk]]
[17:36:34.911]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.911]                     next
[17:36:34.911]                   args[[name]] <- ""
[17:36:34.911]                 }
[17:36:34.911]                 NAMES <- toupper(removed)
[17:36:34.911]                 for (kk in seq_along(NAMES)) {
[17:36:34.911]                   name <- removed[[kk]]
[17:36:34.911]                   NAME <- NAMES[[kk]]
[17:36:34.911]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.911]                     next
[17:36:34.911]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:34.911]                 }
[17:36:34.911]                 if (length(args) > 0) 
[17:36:34.911]                   base::do.call(base::Sys.setenv, args = args)
[17:36:34.911]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:34.911]             }
[17:36:34.911]             else {
[17:36:34.911]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:34.911]             }
[17:36:34.911]             {
[17:36:34.911]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:34.911]                   0L) {
[17:36:34.911]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:34.911]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:34.911]                   base::options(opts)
[17:36:34.911]                 }
[17:36:34.911]                 {
[17:36:34.911]                   {
[17:36:34.911]                     NULL
[17:36:34.911]                     RNGkind("Mersenne-Twister")
[17:36:34.911]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:34.911]                       inherits = FALSE)
[17:36:34.911]                   }
[17:36:34.911]                   options(future.plan = NULL)
[17:36:34.911]                   if (is.na(NA_character_)) 
[17:36:34.911]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:34.911]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:34.911]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:34.911]                     .init = FALSE)
[17:36:34.911]                 }
[17:36:34.911]             }
[17:36:34.911]         }
[17:36:34.911]     })
[17:36:34.911]     if (TRUE) {
[17:36:34.911]         base::sink(type = "output", split = FALSE)
[17:36:34.911]         if (TRUE) {
[17:36:34.911]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:34.911]         }
[17:36:34.911]         else {
[17:36:34.911]             ...future.result["stdout"] <- base::list(NULL)
[17:36:34.911]         }
[17:36:34.911]         base::close(...future.stdout)
[17:36:34.911]         ...future.stdout <- NULL
[17:36:34.911]     }
[17:36:34.911]     ...future.result$conditions <- ...future.conditions
[17:36:34.911]     ...future.result$finished <- base::Sys.time()
[17:36:34.911]     ...future.result
[17:36:34.911] }
[17:36:34.912] assign_globals() ...
[17:36:34.913] List of 5
[17:36:34.913]  $ future.call.arguments    : list()
[17:36:34.913]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.913]  $ ...future.FUN            :function (x)  
[17:36:34.913]  $ ...future.elements_ii    :List of 2
[17:36:34.913]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[17:36:34.913]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[17:36:34.913]  $ ...future.seeds_ii       : NULL
[17:36:34.913]  $ ...future.globals.maxSize: num Inf
[17:36:34.913]  - attr(*, "resolved")= logi FALSE
[17:36:34.913]  - attr(*, "total_size")= num NA
[17:36:34.913]  - attr(*, "where")=List of 5
[17:36:34.913]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:34.913]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:34.913]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:34.913]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:34.913]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:34.913]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.913]  - attr(*, "already-done")= logi TRUE
[17:36:34.917] - copied ‘future.call.arguments’ to environment
[17:36:34.918] - copied ‘...future.FUN’ to environment
[17:36:34.918] - copied ‘...future.elements_ii’ to environment
[17:36:34.918] - copied ‘...future.seeds_ii’ to environment
[17:36:34.918] - copied ‘...future.globals.maxSize’ to environment
[17:36:34.918] assign_globals() ... done
[17:36:34.918] plan(): Setting new future strategy stack:
[17:36:34.918] List of future strategies:
[17:36:34.918] 1. sequential:
[17:36:34.918]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:34.918]    - tweaked: FALSE
[17:36:34.918]    - call: NULL
[17:36:34.919] plan(): nbrOfWorkers() = 1
[17:36:34.919] plan(): Setting new future strategy stack:
[17:36:34.920] List of future strategies:
[17:36:34.920] 1. sequential:
[17:36:34.920]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:34.920]    - tweaked: FALSE
[17:36:34.920]    - call: plan(strategy)
[17:36:34.920] plan(): nbrOfWorkers() = 1
[17:36:34.920] SequentialFuture started (and completed)
[17:36:34.920] - Launch lazy future ... done
[17:36:34.920] run() for ‘SequentialFuture’ ... done
[17:36:34.921] Created future:
[17:36:34.921] SequentialFuture:
[17:36:34.921] Label: ‘future_apply-1’
[17:36:34.921] Expression:
[17:36:34.921] {
[17:36:34.921]     do.call(function(...) {
[17:36:34.921]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.921]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:34.921]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.921]             on.exit(options(oopts), add = TRUE)
[17:36:34.921]         }
[17:36:34.921]         {
[17:36:34.921]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:34.921]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.921]                 ...future.FUN(...future.X_jj, ...)
[17:36:34.921]             })
[17:36:34.921]         }
[17:36:34.921]     }, args = future.call.arguments)
[17:36:34.921] }
[17:36:34.921] Lazy evaluation: FALSE
[17:36:34.921] Asynchronous evaluation: FALSE
[17:36:34.921] Local evaluation: TRUE
[17:36:34.921] Environment: R_GlobalEnv
[17:36:34.921] Capture standard output: TRUE
[17:36:34.921] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:34.921] Globals: 5 objects totaling 1.37 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 496 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:34.921] Packages: <none>
[17:36:34.921] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:34.921] Resolved: TRUE
[17:36:34.921] Value: 496 bytes of class ‘list’
[17:36:34.921] Early signaling: FALSE
[17:36:34.921] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:34.921] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:34.922] Chunk #1 of 1 ... DONE
[17:36:34.922] Launching 1 futures (chunks) ... DONE
[17:36:34.922] Resolving 1 futures (chunks) ...
[17:36:34.922] resolve() on list ...
[17:36:34.922]  recursive: 0
[17:36:34.922]  length: 1
[17:36:34.922] 
[17:36:34.922] resolved() for ‘SequentialFuture’ ...
[17:36:34.922] - state: ‘finished’
[17:36:34.922] - run: TRUE
[17:36:34.923] - result: ‘FutureResult’
[17:36:34.923] resolved() for ‘SequentialFuture’ ... done
[17:36:34.923] Future #1
[17:36:34.923] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:34.923] - nx: 1
[17:36:34.923] - relay: TRUE
[17:36:34.923] - stdout: TRUE
[17:36:34.923] - signal: TRUE
[17:36:34.923] - resignal: FALSE
[17:36:34.923] - force: TRUE
[17:36:34.923] - relayed: [n=1] FALSE
[17:36:34.924] - queued futures: [n=1] FALSE
[17:36:34.924]  - until=1
[17:36:34.924]  - relaying element #1
[17:36:34.924] - relayed: [n=1] TRUE
[17:36:34.924] - queued futures: [n=1] TRUE
[17:36:34.924] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:34.924]  length: 0 (resolved future 1)
[17:36:34.924] Relaying remaining futures
[17:36:34.924] signalConditionsASAP(NULL, pos=0) ...
[17:36:34.924] - nx: 1
[17:36:34.925] - relay: TRUE
[17:36:34.925] - stdout: TRUE
[17:36:34.925] - signal: TRUE
[17:36:34.925] - resignal: FALSE
[17:36:34.925] - force: TRUE
[17:36:34.925] - relayed: [n=1] TRUE
[17:36:34.925] - queued futures: [n=1] TRUE
 - flush all
[17:36:34.925] - relayed: [n=1] TRUE
[17:36:34.925] - queued futures: [n=1] TRUE
[17:36:34.925] signalConditionsASAP(NULL, pos=0) ... done
[17:36:34.925] resolve() on list ... DONE
[17:36:34.926]  - Number of value chunks collected: 1
[17:36:34.926] Resolving 1 futures (chunks) ... DONE
[17:36:34.926] Reducing values from 1 chunks ...
[17:36:34.926]  - Number of values collected after concatenation: 2
[17:36:34.926]  - Number of values expected: 2
[17:36:34.926] Reducing values from 1 chunks ... DONE
[17:36:34.926] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[17:36:34.926] getGlobalsAndPackagesXApply() ...
[17:36:34.927]  - future.globals: TRUE
[17:36:34.927] getGlobalsAndPackages() ...
[17:36:34.927] Searching for globals...
[17:36:34.929] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[17:36:34.929] Searching for globals ... DONE
[17:36:34.929] Resolving globals: FALSE
[17:36:34.930] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[17:36:34.930] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[17:36:34.930] - globals: [1] ‘FUN’
[17:36:34.930] 
[17:36:34.930] getGlobalsAndPackages() ... DONE
[17:36:34.931]  - globals found/used: [n=1] ‘FUN’
[17:36:34.931]  - needed namespaces: [n=0] 
[17:36:34.931] Finding globals ... DONE
[17:36:34.931]  - use_args: TRUE
[17:36:34.931]  - Getting '...' globals ...
[17:36:34.933] resolve() on list ...
[17:36:34.933]  recursive: 0
[17:36:34.933]  length: 1
[17:36:34.933]  elements: ‘...’
[17:36:34.933]  length: 0 (resolved future 1)
[17:36:34.933] resolve() on list ... DONE
[17:36:34.933]    - '...' content: [n=0] 
[17:36:34.933] List of 1
[17:36:34.933]  $ ...: list()
[17:36:34.933]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.933]  - attr(*, "where")=List of 1
[17:36:34.933]   ..$ ...:<environment: 0x556d75cdfc98> 
[17:36:34.933]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.933]  - attr(*, "resolved")= logi TRUE
[17:36:34.933]  - attr(*, "total_size")= num NA
[17:36:34.936]  - Getting '...' globals ... DONE
[17:36:34.936] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:34.936] List of 2
[17:36:34.936]  $ ...future.FUN:function (x)  
[17:36:34.936]  $ ...          : list()
[17:36:34.936]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.936]  - attr(*, "where")=List of 2
[17:36:34.936]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:34.936]   ..$ ...          :<environment: 0x556d75cdfc98> 
[17:36:34.936]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.936]  - attr(*, "resolved")= logi FALSE
[17:36:34.936]  - attr(*, "total_size")= num 9888
[17:36:34.939] Packages to be attached in all futures: [n=0] 
[17:36:34.939] getGlobalsAndPackagesXApply() ... DONE
[17:36:34.939] future_lapply() ...
[17:36:34.940] Number of chunks: 1
[17:36:34.940] getGlobalsAndPackagesXApply() ...
[17:36:34.940]  - future.globals: <name-value list> with names ‘list()’
[17:36:34.941]  - use_args: TRUE
[17:36:34.941] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:34.941] List of 2
[17:36:34.941]  $ ...          : list()
[17:36:34.941]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.941]  $ ...future.FUN:function (x)  
[17:36:34.941]  - attr(*, "where")=List of 2
[17:36:34.941]   ..$ ...          :<environment: 0x556d75cdfc98> 
[17:36:34.941]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:36:34.941]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.941]  - attr(*, "resolved")= logi FALSE
[17:36:34.941]  - attr(*, "total_size")= num NA
[17:36:34.943] Packages to be attached in all futures: [n=0] 
[17:36:34.944] getGlobalsAndPackagesXApply() ... DONE
[17:36:34.944] Number of futures (= number of chunks): 1
[17:36:34.944] Launching 1 futures (chunks) ...
[17:36:34.944] Chunk #1 of 1 ...
[17:36:34.944]  - seeds: <none>
[17:36:34.944]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.944] getGlobalsAndPackages() ...
[17:36:34.944] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.945] Resolving globals: FALSE
[17:36:34.945] Tweak future expression to call with '...' arguments ...
[17:36:34.945] {
[17:36:34.945]     do.call(function(...) {
[17:36:34.945]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.945]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:34.945]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.945]             on.exit(options(oopts), add = TRUE)
[17:36:34.945]         }
[17:36:34.945]         {
[17:36:34.945]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:34.945]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.945]                 ...future.FUN(...future.X_jj, ...)
[17:36:34.945]             })
[17:36:34.945]         }
[17:36:34.945]     }, args = future.call.arguments)
[17:36:34.945] }
[17:36:34.945] Tweak future expression to call with '...' arguments ... DONE
[17:36:34.945] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.945] 
[17:36:34.946] getGlobalsAndPackages() ... DONE
[17:36:34.946] run() for ‘Future’ ...
[17:36:34.946] - state: ‘created’
[17:36:34.946] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:34.946] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:34.946] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:34.946]   - Field: ‘label’
[17:36:34.947]   - Field: ‘local’
[17:36:34.947]   - Field: ‘owner’
[17:36:34.947]   - Field: ‘envir’
[17:36:34.947]   - Field: ‘packages’
[17:36:34.947]   - Field: ‘gc’
[17:36:34.947]   - Field: ‘conditions’
[17:36:34.947]   - Field: ‘expr’
[17:36:34.947]   - Field: ‘uuid’
[17:36:34.947]   - Field: ‘seed’
[17:36:34.947]   - Field: ‘version’
[17:36:34.948]   - Field: ‘result’
[17:36:34.948]   - Field: ‘asynchronous’
[17:36:34.948]   - Field: ‘calls’
[17:36:34.948]   - Field: ‘globals’
[17:36:34.948]   - Field: ‘stdout’
[17:36:34.948]   - Field: ‘earlySignal’
[17:36:34.948]   - Field: ‘lazy’
[17:36:34.948]   - Field: ‘state’
[17:36:34.948] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:34.948] - Launch lazy future ...
[17:36:34.949] Packages needed by the future expression (n = 0): <none>
[17:36:34.949] Packages needed by future strategies (n = 0): <none>
[17:36:34.949] {
[17:36:34.949]     {
[17:36:34.949]         {
[17:36:34.949]             ...future.startTime <- base::Sys.time()
[17:36:34.949]             {
[17:36:34.949]                 {
[17:36:34.949]                   {
[17:36:34.949]                     base::local({
[17:36:34.949]                       has_future <- base::requireNamespace("future", 
[17:36:34.949]                         quietly = TRUE)
[17:36:34.949]                       if (has_future) {
[17:36:34.949]                         ns <- base::getNamespace("future")
[17:36:34.949]                         version <- ns[[".package"]][["version"]]
[17:36:34.949]                         if (is.null(version)) 
[17:36:34.949]                           version <- utils::packageVersion("future")
[17:36:34.949]                       }
[17:36:34.949]                       else {
[17:36:34.949]                         version <- NULL
[17:36:34.949]                       }
[17:36:34.949]                       if (!has_future || version < "1.8.0") {
[17:36:34.949]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:34.949]                           "", base::R.version$version.string), 
[17:36:34.949]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:34.949]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:34.949]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:34.949]                             "release", "version")], collapse = " "), 
[17:36:34.949]                           hostname = base::Sys.info()[["nodename"]])
[17:36:34.949]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:34.949]                           info)
[17:36:34.949]                         info <- base::paste(info, collapse = "; ")
[17:36:34.949]                         if (!has_future) {
[17:36:34.949]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:34.949]                             info)
[17:36:34.949]                         }
[17:36:34.949]                         else {
[17:36:34.949]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:34.949]                             info, version)
[17:36:34.949]                         }
[17:36:34.949]                         base::stop(msg)
[17:36:34.949]                       }
[17:36:34.949]                     })
[17:36:34.949]                   }
[17:36:34.949]                   ...future.strategy.old <- future::plan("list")
[17:36:34.949]                   options(future.plan = NULL)
[17:36:34.949]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:34.949]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:34.949]                 }
[17:36:34.949]                 ...future.workdir <- getwd()
[17:36:34.949]             }
[17:36:34.949]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:34.949]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:34.949]         }
[17:36:34.949]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:34.949]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:34.949]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:34.949]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:34.949]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:34.949]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:34.949]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:34.949]             base::names(...future.oldOptions))
[17:36:34.949]     }
[17:36:34.949]     if (FALSE) {
[17:36:34.949]     }
[17:36:34.949]     else {
[17:36:34.949]         if (TRUE) {
[17:36:34.949]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:34.949]                 open = "w")
[17:36:34.949]         }
[17:36:34.949]         else {
[17:36:34.949]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:34.949]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:34.949]         }
[17:36:34.949]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:34.949]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:34.949]             base::sink(type = "output", split = FALSE)
[17:36:34.949]             base::close(...future.stdout)
[17:36:34.949]         }, add = TRUE)
[17:36:34.949]     }
[17:36:34.949]     ...future.frame <- base::sys.nframe()
[17:36:34.949]     ...future.conditions <- base::list()
[17:36:34.949]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:34.949]     if (FALSE) {
[17:36:34.949]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:34.949]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:34.949]     }
[17:36:34.949]     ...future.result <- base::tryCatch({
[17:36:34.949]         base::withCallingHandlers({
[17:36:34.949]             ...future.value <- base::withVisible(base::local({
[17:36:34.949]                 do.call(function(...) {
[17:36:34.949]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.949]                   if (!identical(...future.globals.maxSize.org, 
[17:36:34.949]                     ...future.globals.maxSize)) {
[17:36:34.949]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.949]                     on.exit(options(oopts), add = TRUE)
[17:36:34.949]                   }
[17:36:34.949]                   {
[17:36:34.949]                     lapply(seq_along(...future.elements_ii), 
[17:36:34.949]                       FUN = function(jj) {
[17:36:34.949]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.949]                         ...future.FUN(...future.X_jj, ...)
[17:36:34.949]                       })
[17:36:34.949]                   }
[17:36:34.949]                 }, args = future.call.arguments)
[17:36:34.949]             }))
[17:36:34.949]             future::FutureResult(value = ...future.value$value, 
[17:36:34.949]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:34.949]                   ...future.rng), globalenv = if (FALSE) 
[17:36:34.949]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:34.949]                     ...future.globalenv.names))
[17:36:34.949]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:34.949]         }, condition = base::local({
[17:36:34.949]             c <- base::c
[17:36:34.949]             inherits <- base::inherits
[17:36:34.949]             invokeRestart <- base::invokeRestart
[17:36:34.949]             length <- base::length
[17:36:34.949]             list <- base::list
[17:36:34.949]             seq.int <- base::seq.int
[17:36:34.949]             signalCondition <- base::signalCondition
[17:36:34.949]             sys.calls <- base::sys.calls
[17:36:34.949]             `[[` <- base::`[[`
[17:36:34.949]             `+` <- base::`+`
[17:36:34.949]             `<<-` <- base::`<<-`
[17:36:34.949]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:34.949]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:34.949]                   3L)]
[17:36:34.949]             }
[17:36:34.949]             function(cond) {
[17:36:34.949]                 is_error <- inherits(cond, "error")
[17:36:34.949]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:34.949]                   NULL)
[17:36:34.949]                 if (is_error) {
[17:36:34.949]                   sessionInformation <- function() {
[17:36:34.949]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:34.949]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:34.949]                       search = base::search(), system = base::Sys.info())
[17:36:34.949]                   }
[17:36:34.949]                   ...future.conditions[[length(...future.conditions) + 
[17:36:34.949]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:34.949]                     cond$call), session = sessionInformation(), 
[17:36:34.949]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:34.949]                   signalCondition(cond)
[17:36:34.949]                 }
[17:36:34.949]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:34.949]                 "immediateCondition"))) {
[17:36:34.949]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:34.949]                   ...future.conditions[[length(...future.conditions) + 
[17:36:34.949]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:34.949]                   if (TRUE && !signal) {
[17:36:34.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:34.949]                     {
[17:36:34.949]                       inherits <- base::inherits
[17:36:34.949]                       invokeRestart <- base::invokeRestart
[17:36:34.949]                       is.null <- base::is.null
[17:36:34.949]                       muffled <- FALSE
[17:36:34.949]                       if (inherits(cond, "message")) {
[17:36:34.949]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:34.949]                         if (muffled) 
[17:36:34.949]                           invokeRestart("muffleMessage")
[17:36:34.949]                       }
[17:36:34.949]                       else if (inherits(cond, "warning")) {
[17:36:34.949]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:34.949]                         if (muffled) 
[17:36:34.949]                           invokeRestart("muffleWarning")
[17:36:34.949]                       }
[17:36:34.949]                       else if (inherits(cond, "condition")) {
[17:36:34.949]                         if (!is.null(pattern)) {
[17:36:34.949]                           computeRestarts <- base::computeRestarts
[17:36:34.949]                           grepl <- base::grepl
[17:36:34.949]                           restarts <- computeRestarts(cond)
[17:36:34.949]                           for (restart in restarts) {
[17:36:34.949]                             name <- restart$name
[17:36:34.949]                             if (is.null(name)) 
[17:36:34.949]                               next
[17:36:34.949]                             if (!grepl(pattern, name)) 
[17:36:34.949]                               next
[17:36:34.949]                             invokeRestart(restart)
[17:36:34.949]                             muffled <- TRUE
[17:36:34.949]                             break
[17:36:34.949]                           }
[17:36:34.949]                         }
[17:36:34.949]                       }
[17:36:34.949]                       invisible(muffled)
[17:36:34.949]                     }
[17:36:34.949]                     muffleCondition(cond, pattern = "^muffle")
[17:36:34.949]                   }
[17:36:34.949]                 }
[17:36:34.949]                 else {
[17:36:34.949]                   if (TRUE) {
[17:36:34.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:34.949]                     {
[17:36:34.949]                       inherits <- base::inherits
[17:36:34.949]                       invokeRestart <- base::invokeRestart
[17:36:34.949]                       is.null <- base::is.null
[17:36:34.949]                       muffled <- FALSE
[17:36:34.949]                       if (inherits(cond, "message")) {
[17:36:34.949]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:34.949]                         if (muffled) 
[17:36:34.949]                           invokeRestart("muffleMessage")
[17:36:34.949]                       }
[17:36:34.949]                       else if (inherits(cond, "warning")) {
[17:36:34.949]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:34.949]                         if (muffled) 
[17:36:34.949]                           invokeRestart("muffleWarning")
[17:36:34.949]                       }
[17:36:34.949]                       else if (inherits(cond, "condition")) {
[17:36:34.949]                         if (!is.null(pattern)) {
[17:36:34.949]                           computeRestarts <- base::computeRestarts
[17:36:34.949]                           grepl <- base::grepl
[17:36:34.949]                           restarts <- computeRestarts(cond)
[17:36:34.949]                           for (restart in restarts) {
[17:36:34.949]                             name <- restart$name
[17:36:34.949]                             if (is.null(name)) 
[17:36:34.949]                               next
[17:36:34.949]                             if (!grepl(pattern, name)) 
[17:36:34.949]                               next
[17:36:34.949]                             invokeRestart(restart)
[17:36:34.949]                             muffled <- TRUE
[17:36:34.949]                             break
[17:36:34.949]                           }
[17:36:34.949]                         }
[17:36:34.949]                       }
[17:36:34.949]                       invisible(muffled)
[17:36:34.949]                     }
[17:36:34.949]                     muffleCondition(cond, pattern = "^muffle")
[17:36:34.949]                   }
[17:36:34.949]                 }
[17:36:34.949]             }
[17:36:34.949]         }))
[17:36:34.949]     }, error = function(ex) {
[17:36:34.949]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:34.949]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:34.949]                 ...future.rng), started = ...future.startTime, 
[17:36:34.949]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:34.949]             version = "1.8"), class = "FutureResult")
[17:36:34.949]     }, finally = {
[17:36:34.949]         if (!identical(...future.workdir, getwd())) 
[17:36:34.949]             setwd(...future.workdir)
[17:36:34.949]         {
[17:36:34.949]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:34.949]                 ...future.oldOptions$nwarnings <- NULL
[17:36:34.949]             }
[17:36:34.949]             base::options(...future.oldOptions)
[17:36:34.949]             if (.Platform$OS.type == "windows") {
[17:36:34.949]                 old_names <- names(...future.oldEnvVars)
[17:36:34.949]                 envs <- base::Sys.getenv()
[17:36:34.949]                 names <- names(envs)
[17:36:34.949]                 common <- intersect(names, old_names)
[17:36:34.949]                 added <- setdiff(names, old_names)
[17:36:34.949]                 removed <- setdiff(old_names, names)
[17:36:34.949]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:34.949]                   envs[common]]
[17:36:34.949]                 NAMES <- toupper(changed)
[17:36:34.949]                 args <- list()
[17:36:34.949]                 for (kk in seq_along(NAMES)) {
[17:36:34.949]                   name <- changed[[kk]]
[17:36:34.949]                   NAME <- NAMES[[kk]]
[17:36:34.949]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.949]                     next
[17:36:34.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:34.949]                 }
[17:36:34.949]                 NAMES <- toupper(added)
[17:36:34.949]                 for (kk in seq_along(NAMES)) {
[17:36:34.949]                   name <- added[[kk]]
[17:36:34.949]                   NAME <- NAMES[[kk]]
[17:36:34.949]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.949]                     next
[17:36:34.949]                   args[[name]] <- ""
[17:36:34.949]                 }
[17:36:34.949]                 NAMES <- toupper(removed)
[17:36:34.949]                 for (kk in seq_along(NAMES)) {
[17:36:34.949]                   name <- removed[[kk]]
[17:36:34.949]                   NAME <- NAMES[[kk]]
[17:36:34.949]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.949]                     next
[17:36:34.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:34.949]                 }
[17:36:34.949]                 if (length(args) > 0) 
[17:36:34.949]                   base::do.call(base::Sys.setenv, args = args)
[17:36:34.949]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:34.949]             }
[17:36:34.949]             else {
[17:36:34.949]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:34.949]             }
[17:36:34.949]             {
[17:36:34.949]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:34.949]                   0L) {
[17:36:34.949]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:34.949]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:34.949]                   base::options(opts)
[17:36:34.949]                 }
[17:36:34.949]                 {
[17:36:34.949]                   {
[17:36:34.949]                     NULL
[17:36:34.949]                     RNGkind("Mersenne-Twister")
[17:36:34.949]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:34.949]                       inherits = FALSE)
[17:36:34.949]                   }
[17:36:34.949]                   options(future.plan = NULL)
[17:36:34.949]                   if (is.na(NA_character_)) 
[17:36:34.949]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:34.949]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:34.949]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:34.949]                     .init = FALSE)
[17:36:34.949]                 }
[17:36:34.949]             }
[17:36:34.949]         }
[17:36:34.949]     })
[17:36:34.949]     if (TRUE) {
[17:36:34.949]         base::sink(type = "output", split = FALSE)
[17:36:34.949]         if (TRUE) {
[17:36:34.949]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:34.949]         }
[17:36:34.949]         else {
[17:36:34.949]             ...future.result["stdout"] <- base::list(NULL)
[17:36:34.949]         }
[17:36:34.949]         base::close(...future.stdout)
[17:36:34.949]         ...future.stdout <- NULL
[17:36:34.949]     }
[17:36:34.949]     ...future.result$conditions <- ...future.conditions
[17:36:34.949]     ...future.result$finished <- base::Sys.time()
[17:36:34.949]     ...future.result
[17:36:34.949] }
[17:36:34.951] assign_globals() ...
[17:36:34.951] List of 5
[17:36:34.951]  $ future.call.arguments    : list()
[17:36:34.951]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.951]  $ ...future.FUN            :function (x)  
[17:36:34.951]  $ ...future.elements_ii    :List of 2
[17:36:34.951]   ..$ : int [1:2] 1 3
[17:36:34.951]   ..$ : int [1:2] 2 4
[17:36:34.951]  $ ...future.seeds_ii       : NULL
[17:36:34.951]  $ ...future.globals.maxSize: num Inf
[17:36:34.951]  - attr(*, "resolved")= logi FALSE
[17:36:34.951]  - attr(*, "total_size")= num NA
[17:36:34.951]  - attr(*, "where")=List of 5
[17:36:34.951]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:34.951]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:34.951]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:34.951]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:34.951]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:34.951]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.951]  - attr(*, "already-done")= logi TRUE
[17:36:34.956] - copied ‘future.call.arguments’ to environment
[17:36:34.956] - reassign environment for ‘...future.FUN’
[17:36:34.956] - copied ‘...future.FUN’ to environment
[17:36:34.957] - copied ‘...future.elements_ii’ to environment
[17:36:34.957] - copied ‘...future.seeds_ii’ to environment
[17:36:34.958] - copied ‘...future.globals.maxSize’ to environment
[17:36:34.958] assign_globals() ... done
[17:36:34.958] plan(): Setting new future strategy stack:
[17:36:34.958] List of future strategies:
[17:36:34.958] 1. sequential:
[17:36:34.958]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:34.958]    - tweaked: FALSE
[17:36:34.958]    - call: NULL
[17:36:34.959] plan(): nbrOfWorkers() = 1
[17:36:34.959] plan(): Setting new future strategy stack:
[17:36:34.959] List of future strategies:
[17:36:34.959] 1. sequential:
[17:36:34.959]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:34.959]    - tweaked: FALSE
[17:36:34.959]    - call: plan(strategy)
[17:36:34.960] plan(): nbrOfWorkers() = 1
[17:36:34.960] SequentialFuture started (and completed)
[17:36:34.960] - Launch lazy future ... done
[17:36:34.960] run() for ‘SequentialFuture’ ... done
[17:36:34.960] Created future:
[17:36:34.961] SequentialFuture:
[17:36:34.961] Label: ‘future_apply-1’
[17:36:34.961] Expression:
[17:36:34.961] {
[17:36:34.961]     do.call(function(...) {
[17:36:34.961]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.961]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:34.961]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.961]             on.exit(options(oopts), add = TRUE)
[17:36:34.961]         }
[17:36:34.961]         {
[17:36:34.961]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:34.961]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.961]                 ...future.FUN(...future.X_jj, ...)
[17:36:34.961]             })
[17:36:34.961]         }
[17:36:34.961]     }, args = future.call.arguments)
[17:36:34.961] }
[17:36:34.961] Lazy evaluation: FALSE
[17:36:34.961] Asynchronous evaluation: FALSE
[17:36:34.961] Local evaluation: TRUE
[17:36:34.961] Environment: R_GlobalEnv
[17:36:34.961] Capture standard output: TRUE
[17:36:34.961] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:34.961] Globals: 5 objects totaling 9.82 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:34.961] Packages: <none>
[17:36:34.961] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:34.961] Resolved: TRUE
[17:36:34.961] Value: 400 bytes of class ‘list’
[17:36:34.961] Early signaling: FALSE
[17:36:34.961] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:34.961] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:34.962] Chunk #1 of 1 ... DONE
[17:36:34.962] Launching 1 futures (chunks) ... DONE
[17:36:34.962] Resolving 1 futures (chunks) ...
[17:36:34.962] resolve() on list ...
[17:36:34.962]  recursive: 0
[17:36:34.962]  length: 1
[17:36:34.962] 
[17:36:34.962] resolved() for ‘SequentialFuture’ ...
[17:36:34.962] - state: ‘finished’
[17:36:34.962] - run: TRUE
[17:36:34.962] - result: ‘FutureResult’
[17:36:34.963] resolved() for ‘SequentialFuture’ ... done
[17:36:34.963] Future #1
[17:36:34.963] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:34.963] - nx: 1
[17:36:34.963] - relay: TRUE
[17:36:34.963] - stdout: TRUE
[17:36:34.963] - signal: TRUE
[17:36:34.963] - resignal: FALSE
[17:36:34.963] - force: TRUE
[17:36:34.963] - relayed: [n=1] FALSE
[17:36:34.963] - queued futures: [n=1] FALSE
[17:36:34.964]  - until=1
[17:36:34.964]  - relaying element #1
[17:36:34.964] - relayed: [n=1] TRUE
[17:36:34.964] - queued futures: [n=1] TRUE
[17:36:34.964] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:34.964]  length: 0 (resolved future 1)
[17:36:34.964] Relaying remaining futures
[17:36:34.964] signalConditionsASAP(NULL, pos=0) ...
[17:36:34.964] - nx: 1
[17:36:34.964] - relay: TRUE
[17:36:34.965] - stdout: TRUE
[17:36:34.965] - signal: TRUE
[17:36:34.965] - resignal: FALSE
[17:36:34.965] - force: TRUE
[17:36:34.965] - relayed: [n=1] TRUE
[17:36:34.965] - queued futures: [n=1] TRUE
 - flush all
[17:36:34.965] - relayed: [n=1] TRUE
[17:36:34.965] - queued futures: [n=1] TRUE
[17:36:34.965] signalConditionsASAP(NULL, pos=0) ... done
[17:36:34.965] resolve() on list ... DONE
[17:36:34.965]  - Number of value chunks collected: 1
[17:36:34.966] Resolving 1 futures (chunks) ... DONE
[17:36:34.966] Reducing values from 1 chunks ...
[17:36:34.966]  - Number of values collected after concatenation: 2
[17:36:34.966]  - Number of values expected: 2
[17:36:34.966] Reducing values from 1 chunks ... DONE
[17:36:34.966] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[17:36:34.966] getGlobalsAndPackagesXApply() ...
[17:36:34.966]  - future.globals: TRUE
[17:36:34.966] getGlobalsAndPackages() ...
[17:36:34.967] Searching for globals...
[17:36:34.969] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[17:36:34.969] Searching for globals ... DONE
[17:36:34.970] Resolving globals: FALSE
[17:36:34.970] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[17:36:34.970] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[17:36:34.971] - globals: [1] ‘FUN’
[17:36:34.971] 
[17:36:34.971] getGlobalsAndPackages() ... DONE
[17:36:34.971]  - globals found/used: [n=1] ‘FUN’
[17:36:34.971]  - needed namespaces: [n=0] 
[17:36:34.971] Finding globals ... DONE
[17:36:34.971]  - use_args: TRUE
[17:36:34.971]  - Getting '...' globals ...
[17:36:34.972] resolve() on list ...
[17:36:34.972]  recursive: 0
[17:36:34.972]  length: 1
[17:36:34.972]  elements: ‘...’
[17:36:34.972]  length: 0 (resolved future 1)
[17:36:34.972] resolve() on list ... DONE
[17:36:34.972]    - '...' content: [n=0] 
[17:36:34.972] List of 1
[17:36:34.972]  $ ...: list()
[17:36:34.972]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.972]  - attr(*, "where")=List of 1
[17:36:34.972]   ..$ ...:<environment: 0x556d74724180> 
[17:36:34.972]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.972]  - attr(*, "resolved")= logi TRUE
[17:36:34.972]  - attr(*, "total_size")= num NA
[17:36:34.975]  - Getting '...' globals ... DONE
[17:36:34.975] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:34.975] List of 2
[17:36:34.975]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:36:34.975]  $ ...          : list()
[17:36:34.975]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.975]  - attr(*, "where")=List of 2
[17:36:34.975]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:34.975]   ..$ ...          :<environment: 0x556d74724180> 
[17:36:34.975]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.975]  - attr(*, "resolved")= logi FALSE
[17:36:34.975]  - attr(*, "total_size")= num 36296
[17:36:34.977] Packages to be attached in all futures: [n=0] 
[17:36:34.977] getGlobalsAndPackagesXApply() ... DONE
[17:36:34.978] future_lapply() ...
[17:36:34.979] Generating random seeds ...
[17:36:34.980] Generating random seed streams for 2 elements ...
[17:36:34.981] Generating random seed streams for 2 elements ... DONE
[17:36:34.981] Generating random seeds ... DONE
[17:36:34.981] Will set RNG state on exit: 10407, -2104155129, -1647535974, 280570553, 2006606538, 725693014, -553310456
[17:36:34.982] Number of chunks: 1
[17:36:34.982] getGlobalsAndPackagesXApply() ...
[17:36:34.982]  - future.globals: <name-value list> with names ‘list()’
[17:36:34.982]  - use_args: TRUE
[17:36:34.982] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:34.982] List of 2
[17:36:34.982]  $ ...          : list()
[17:36:34.982]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.982]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:36:34.982]  - attr(*, "where")=List of 2
[17:36:34.982]   ..$ ...          :<environment: 0x556d74724180> 
[17:36:34.982]   ..$ ...future.FUN:<environment: namespace:base> 
[17:36:34.982]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.982]  - attr(*, "resolved")= logi FALSE
[17:36:34.982]  - attr(*, "total_size")= num NA
[17:36:34.985] Packages to be attached in all futures: [n=0] 
[17:36:34.985] getGlobalsAndPackagesXApply() ... DONE
[17:36:34.986] Number of futures (= number of chunks): 1
[17:36:34.986] Launching 1 futures (chunks) ...
[17:36:34.986] Chunk #1 of 1 ...
[17:36:34.986]  - seeds: [2] <seeds>
[17:36:34.986]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.986] getGlobalsAndPackages() ...
[17:36:34.986] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.986] Resolving globals: FALSE
[17:36:34.986] Tweak future expression to call with '...' arguments ...
[17:36:34.987] {
[17:36:34.987]     do.call(function(...) {
[17:36:34.987]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.987]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:34.987]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.987]             on.exit(options(oopts), add = TRUE)
[17:36:34.987]         }
[17:36:34.987]         {
[17:36:34.987]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:34.987]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.987]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:36:34.987]                   envir = globalenv(), inherits = FALSE)
[17:36:34.987]                 ...future.FUN(...future.X_jj, ...)
[17:36:34.987]             })
[17:36:34.987]         }
[17:36:34.987]     }, args = future.call.arguments)
[17:36:34.987] }
[17:36:34.987] Tweak future expression to call with '...' arguments ... DONE
[17:36:34.987] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:34.987] 
[17:36:34.987] getGlobalsAndPackages() ... DONE
[17:36:34.988] run() for ‘Future’ ...
[17:36:34.988] - state: ‘created’
[17:36:34.988] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:34.988] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:34.988] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:34.988]   - Field: ‘label’
[17:36:34.989]   - Field: ‘local’
[17:36:34.989]   - Field: ‘owner’
[17:36:34.989]   - Field: ‘envir’
[17:36:34.989]   - Field: ‘packages’
[17:36:34.989]   - Field: ‘gc’
[17:36:34.989]   - Field: ‘conditions’
[17:36:34.989]   - Field: ‘expr’
[17:36:34.989]   - Field: ‘uuid’
[17:36:34.989]   - Field: ‘seed’
[17:36:34.989]   - Field: ‘version’
[17:36:34.989]   - Field: ‘result’
[17:36:34.989]   - Field: ‘asynchronous’
[17:36:34.990]   - Field: ‘calls’
[17:36:34.990]   - Field: ‘globals’
[17:36:34.990]   - Field: ‘stdout’
[17:36:34.990]   - Field: ‘earlySignal’
[17:36:34.990]   - Field: ‘lazy’
[17:36:34.990]   - Field: ‘state’
[17:36:34.990] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:34.990] - Launch lazy future ...
[17:36:34.990] Packages needed by the future expression (n = 0): <none>
[17:36:34.990] Packages needed by future strategies (n = 0): <none>
[17:36:34.991] {
[17:36:34.991]     {
[17:36:34.991]         {
[17:36:34.991]             ...future.startTime <- base::Sys.time()
[17:36:34.991]             {
[17:36:34.991]                 {
[17:36:34.991]                   {
[17:36:34.991]                     base::local({
[17:36:34.991]                       has_future <- base::requireNamespace("future", 
[17:36:34.991]                         quietly = TRUE)
[17:36:34.991]                       if (has_future) {
[17:36:34.991]                         ns <- base::getNamespace("future")
[17:36:34.991]                         version <- ns[[".package"]][["version"]]
[17:36:34.991]                         if (is.null(version)) 
[17:36:34.991]                           version <- utils::packageVersion("future")
[17:36:34.991]                       }
[17:36:34.991]                       else {
[17:36:34.991]                         version <- NULL
[17:36:34.991]                       }
[17:36:34.991]                       if (!has_future || version < "1.8.0") {
[17:36:34.991]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:34.991]                           "", base::R.version$version.string), 
[17:36:34.991]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:34.991]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:34.991]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:34.991]                             "release", "version")], collapse = " "), 
[17:36:34.991]                           hostname = base::Sys.info()[["nodename"]])
[17:36:34.991]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:34.991]                           info)
[17:36:34.991]                         info <- base::paste(info, collapse = "; ")
[17:36:34.991]                         if (!has_future) {
[17:36:34.991]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:34.991]                             info)
[17:36:34.991]                         }
[17:36:34.991]                         else {
[17:36:34.991]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:34.991]                             info, version)
[17:36:34.991]                         }
[17:36:34.991]                         base::stop(msg)
[17:36:34.991]                       }
[17:36:34.991]                     })
[17:36:34.991]                   }
[17:36:34.991]                   ...future.strategy.old <- future::plan("list")
[17:36:34.991]                   options(future.plan = NULL)
[17:36:34.991]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:34.991]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:34.991]                 }
[17:36:34.991]                 ...future.workdir <- getwd()
[17:36:34.991]             }
[17:36:34.991]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:34.991]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:34.991]         }
[17:36:34.991]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:34.991]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:34.991]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:34.991]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:34.991]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:34.991]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:34.991]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:34.991]             base::names(...future.oldOptions))
[17:36:34.991]     }
[17:36:34.991]     if (FALSE) {
[17:36:34.991]     }
[17:36:34.991]     else {
[17:36:34.991]         if (TRUE) {
[17:36:34.991]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:34.991]                 open = "w")
[17:36:34.991]         }
[17:36:34.991]         else {
[17:36:34.991]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:34.991]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:34.991]         }
[17:36:34.991]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:34.991]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:34.991]             base::sink(type = "output", split = FALSE)
[17:36:34.991]             base::close(...future.stdout)
[17:36:34.991]         }, add = TRUE)
[17:36:34.991]     }
[17:36:34.991]     ...future.frame <- base::sys.nframe()
[17:36:34.991]     ...future.conditions <- base::list()
[17:36:34.991]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:34.991]     if (FALSE) {
[17:36:34.991]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:34.991]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:34.991]     }
[17:36:34.991]     ...future.result <- base::tryCatch({
[17:36:34.991]         base::withCallingHandlers({
[17:36:34.991]             ...future.value <- base::withVisible(base::local({
[17:36:34.991]                 do.call(function(...) {
[17:36:34.991]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:34.991]                   if (!identical(...future.globals.maxSize.org, 
[17:36:34.991]                     ...future.globals.maxSize)) {
[17:36:34.991]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:34.991]                     on.exit(options(oopts), add = TRUE)
[17:36:34.991]                   }
[17:36:34.991]                   {
[17:36:34.991]                     lapply(seq_along(...future.elements_ii), 
[17:36:34.991]                       FUN = function(jj) {
[17:36:34.991]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:34.991]                         assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:36:34.991]                           envir = globalenv(), inherits = FALSE)
[17:36:34.991]                         ...future.FUN(...future.X_jj, ...)
[17:36:34.991]                       })
[17:36:34.991]                   }
[17:36:34.991]                 }, args = future.call.arguments)
[17:36:34.991]             }))
[17:36:34.991]             future::FutureResult(value = ...future.value$value, 
[17:36:34.991]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:34.991]                   ...future.rng), globalenv = if (FALSE) 
[17:36:34.991]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:34.991]                     ...future.globalenv.names))
[17:36:34.991]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:34.991]         }, condition = base::local({
[17:36:34.991]             c <- base::c
[17:36:34.991]             inherits <- base::inherits
[17:36:34.991]             invokeRestart <- base::invokeRestart
[17:36:34.991]             length <- base::length
[17:36:34.991]             list <- base::list
[17:36:34.991]             seq.int <- base::seq.int
[17:36:34.991]             signalCondition <- base::signalCondition
[17:36:34.991]             sys.calls <- base::sys.calls
[17:36:34.991]             `[[` <- base::`[[`
[17:36:34.991]             `+` <- base::`+`
[17:36:34.991]             `<<-` <- base::`<<-`
[17:36:34.991]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:34.991]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:34.991]                   3L)]
[17:36:34.991]             }
[17:36:34.991]             function(cond) {
[17:36:34.991]                 is_error <- inherits(cond, "error")
[17:36:34.991]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:34.991]                   NULL)
[17:36:34.991]                 if (is_error) {
[17:36:34.991]                   sessionInformation <- function() {
[17:36:34.991]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:34.991]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:34.991]                       search = base::search(), system = base::Sys.info())
[17:36:34.991]                   }
[17:36:34.991]                   ...future.conditions[[length(...future.conditions) + 
[17:36:34.991]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:34.991]                     cond$call), session = sessionInformation(), 
[17:36:34.991]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:34.991]                   signalCondition(cond)
[17:36:34.991]                 }
[17:36:34.991]                 else if (!ignore && FALSE && inherits(cond, NULL)) {
[17:36:34.991]                   signal <- TRUE && inherits(cond, character(0))
[17:36:34.991]                   ...future.conditions[[length(...future.conditions) + 
[17:36:34.991]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:34.991]                   if (TRUE && !signal) {
[17:36:34.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:34.991]                     {
[17:36:34.991]                       inherits <- base::inherits
[17:36:34.991]                       invokeRestart <- base::invokeRestart
[17:36:34.991]                       is.null <- base::is.null
[17:36:34.991]                       muffled <- FALSE
[17:36:34.991]                       if (inherits(cond, "message")) {
[17:36:34.991]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:34.991]                         if (muffled) 
[17:36:34.991]                           invokeRestart("muffleMessage")
[17:36:34.991]                       }
[17:36:34.991]                       else if (inherits(cond, "warning")) {
[17:36:34.991]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:34.991]                         if (muffled) 
[17:36:34.991]                           invokeRestart("muffleWarning")
[17:36:34.991]                       }
[17:36:34.991]                       else if (inherits(cond, "condition")) {
[17:36:34.991]                         if (!is.null(pattern)) {
[17:36:34.991]                           computeRestarts <- base::computeRestarts
[17:36:34.991]                           grepl <- base::grepl
[17:36:34.991]                           restarts <- computeRestarts(cond)
[17:36:34.991]                           for (restart in restarts) {
[17:36:34.991]                             name <- restart$name
[17:36:34.991]                             if (is.null(name)) 
[17:36:34.991]                               next
[17:36:34.991]                             if (!grepl(pattern, name)) 
[17:36:34.991]                               next
[17:36:34.991]                             invokeRestart(restart)
[17:36:34.991]                             muffled <- TRUE
[17:36:34.991]                             break
[17:36:34.991]                           }
[17:36:34.991]                         }
[17:36:34.991]                       }
[17:36:34.991]                       invisible(muffled)
[17:36:34.991]                     }
[17:36:34.991]                     muffleCondition(cond, pattern = "^muffle")
[17:36:34.991]                   }
[17:36:34.991]                 }
[17:36:34.991]                 else {
[17:36:34.991]                   if (FALSE) {
[17:36:34.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:34.991]                     {
[17:36:34.991]                       inherits <- base::inherits
[17:36:34.991]                       invokeRestart <- base::invokeRestart
[17:36:34.991]                       is.null <- base::is.null
[17:36:34.991]                       muffled <- FALSE
[17:36:34.991]                       if (inherits(cond, "message")) {
[17:36:34.991]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:34.991]                         if (muffled) 
[17:36:34.991]                           invokeRestart("muffleMessage")
[17:36:34.991]                       }
[17:36:34.991]                       else if (inherits(cond, "warning")) {
[17:36:34.991]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:34.991]                         if (muffled) 
[17:36:34.991]                           invokeRestart("muffleWarning")
[17:36:34.991]                       }
[17:36:34.991]                       else if (inherits(cond, "condition")) {
[17:36:34.991]                         if (!is.null(pattern)) {
[17:36:34.991]                           computeRestarts <- base::computeRestarts
[17:36:34.991]                           grepl <- base::grepl
[17:36:34.991]                           restarts <- computeRestarts(cond)
[17:36:34.991]                           for (restart in restarts) {
[17:36:34.991]                             name <- restart$name
[17:36:34.991]                             if (is.null(name)) 
[17:36:34.991]                               next
[17:36:34.991]                             if (!grepl(pattern, name)) 
[17:36:34.991]                               next
[17:36:34.991]                             invokeRestart(restart)
[17:36:34.991]                             muffled <- TRUE
[17:36:34.991]                             break
[17:36:34.991]                           }
[17:36:34.991]                         }
[17:36:34.991]                       }
[17:36:34.991]                       invisible(muffled)
[17:36:34.991]                     }
[17:36:34.991]                     muffleCondition(cond, pattern = "^muffle")
[17:36:34.991]                   }
[17:36:34.991]                 }
[17:36:34.991]             }
[17:36:34.991]         }))
[17:36:34.991]     }, error = function(ex) {
[17:36:34.991]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:34.991]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:34.991]                 ...future.rng), started = ...future.startTime, 
[17:36:34.991]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:34.991]             version = "1.8"), class = "FutureResult")
[17:36:34.991]     }, finally = {
[17:36:34.991]         if (!identical(...future.workdir, getwd())) 
[17:36:34.991]             setwd(...future.workdir)
[17:36:34.991]         {
[17:36:34.991]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:34.991]                 ...future.oldOptions$nwarnings <- NULL
[17:36:34.991]             }
[17:36:34.991]             base::options(...future.oldOptions)
[17:36:34.991]             if (.Platform$OS.type == "windows") {
[17:36:34.991]                 old_names <- names(...future.oldEnvVars)
[17:36:34.991]                 envs <- base::Sys.getenv()
[17:36:34.991]                 names <- names(envs)
[17:36:34.991]                 common <- intersect(names, old_names)
[17:36:34.991]                 added <- setdiff(names, old_names)
[17:36:34.991]                 removed <- setdiff(old_names, names)
[17:36:34.991]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:34.991]                   envs[common]]
[17:36:34.991]                 NAMES <- toupper(changed)
[17:36:34.991]                 args <- list()
[17:36:34.991]                 for (kk in seq_along(NAMES)) {
[17:36:34.991]                   name <- changed[[kk]]
[17:36:34.991]                   NAME <- NAMES[[kk]]
[17:36:34.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.991]                     next
[17:36:34.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:34.991]                 }
[17:36:34.991]                 NAMES <- toupper(added)
[17:36:34.991]                 for (kk in seq_along(NAMES)) {
[17:36:34.991]                   name <- added[[kk]]
[17:36:34.991]                   NAME <- NAMES[[kk]]
[17:36:34.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.991]                     next
[17:36:34.991]                   args[[name]] <- ""
[17:36:34.991]                 }
[17:36:34.991]                 NAMES <- toupper(removed)
[17:36:34.991]                 for (kk in seq_along(NAMES)) {
[17:36:34.991]                   name <- removed[[kk]]
[17:36:34.991]                   NAME <- NAMES[[kk]]
[17:36:34.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:34.991]                     next
[17:36:34.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:34.991]                 }
[17:36:34.991]                 if (length(args) > 0) 
[17:36:34.991]                   base::do.call(base::Sys.setenv, args = args)
[17:36:34.991]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:34.991]             }
[17:36:34.991]             else {
[17:36:34.991]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:34.991]             }
[17:36:34.991]             {
[17:36:34.991]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:34.991]                   0L) {
[17:36:34.991]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:34.991]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:34.991]                   base::options(opts)
[17:36:34.991]                 }
[17:36:34.991]                 {
[17:36:34.991]                   {
[17:36:34.991]                     base::assign(".Random.seed", c(10407L, -2104155129L, 
[17:36:34.991]                     -1647535974L, 280570553L, 2006606538L, 725693014L, 
[17:36:34.991]                     -553310456L), envir = base::globalenv(), 
[17:36:34.991]                       inherits = FALSE)
[17:36:34.991]                     NULL
[17:36:34.991]                   }
[17:36:34.991]                   options(future.plan = NULL)
[17:36:34.991]                   if (is.na(NA_character_)) 
[17:36:34.991]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:34.991]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:34.991]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:34.991]                     .init = FALSE)
[17:36:34.991]                 }
[17:36:34.991]             }
[17:36:34.991]         }
[17:36:34.991]     })
[17:36:34.991]     if (TRUE) {
[17:36:34.991]         base::sink(type = "output", split = FALSE)
[17:36:34.991]         if (TRUE) {
[17:36:34.991]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:34.991]         }
[17:36:34.991]         else {
[17:36:34.991]             ...future.result["stdout"] <- base::list(NULL)
[17:36:34.991]         }
[17:36:34.991]         base::close(...future.stdout)
[17:36:34.991]         ...future.stdout <- NULL
[17:36:34.991]     }
[17:36:34.991]     ...future.result$conditions <- ...future.conditions
[17:36:34.991]     ...future.result$finished <- base::Sys.time()
[17:36:34.991]     ...future.result
[17:36:34.991] }
[17:36:34.993] assign_globals() ...
[17:36:34.993] List of 5
[17:36:34.993]  $ future.call.arguments    : list()
[17:36:34.993]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:34.993]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[17:36:34.993]  $ ...future.elements_ii    :List of 2
[17:36:34.993]   ..$ : int [1:2] 1 3
[17:36:34.993]   ..$ : int [1:2] 2 4
[17:36:34.993]  $ ...future.seeds_ii       :List of 2
[17:36:34.993]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[17:36:34.993]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[17:36:34.993]  $ ...future.globals.maxSize: num Inf
[17:36:34.993]  - attr(*, "resolved")= logi FALSE
[17:36:34.993]  - attr(*, "total_size")= num NA
[17:36:34.993]  - attr(*, "where")=List of 5
[17:36:34.993]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:34.993]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:34.993]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:34.993]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:34.993]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:34.993]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:34.993]  - attr(*, "already-done")= logi TRUE
[17:36:34.998] - copied ‘future.call.arguments’ to environment
[17:36:34.998] - copied ‘...future.FUN’ to environment
[17:36:34.998] - copied ‘...future.elements_ii’ to environment
[17:36:34.998] - copied ‘...future.seeds_ii’ to environment
[17:36:34.999] - copied ‘...future.globals.maxSize’ to environment
[17:36:34.999] assign_globals() ... done
[17:36:34.999] plan(): Setting new future strategy stack:
[17:36:34.999] List of future strategies:
[17:36:34.999] 1. sequential:
[17:36:34.999]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:34.999]    - tweaked: FALSE
[17:36:34.999]    - call: NULL
[17:36:34.999] plan(): nbrOfWorkers() = 1
[17:36:35.000] plan(): Setting new future strategy stack:
[17:36:35.000] List of future strategies:
[17:36:35.000] 1. sequential:
[17:36:35.000]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:35.000]    - tweaked: FALSE
[17:36:35.000]    - call: plan(strategy)
[17:36:35.001] plan(): nbrOfWorkers() = 1
[17:36:35.001] SequentialFuture started (and completed)
[17:36:35.001] - Launch lazy future ... done
[17:36:35.001] run() for ‘SequentialFuture’ ... done
[17:36:35.001] Created future:
[17:36:35.002] SequentialFuture:
[17:36:35.002] Label: ‘future_apply-1’
[17:36:35.002] Expression:
[17:36:35.002] {
[17:36:35.002]     do.call(function(...) {
[17:36:35.002]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.002]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.002]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.002]             on.exit(options(oopts), add = TRUE)
[17:36:35.002]         }
[17:36:35.002]         {
[17:36:35.002]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.002]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.002]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:36:35.002]                   envir = globalenv(), inherits = FALSE)
[17:36:35.002]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.002]             })
[17:36:35.002]         }
[17:36:35.002]     }, args = future.call.arguments)
[17:36:35.002] }
[17:36:35.002] Lazy evaluation: FALSE
[17:36:35.002] Asynchronous evaluation: FALSE
[17:36:35.002] Local evaluation: TRUE
[17:36:35.002] Environment: R_GlobalEnv
[17:36:35.002] Capture standard output: TRUE
[17:36:35.002] Capture condition classes: <none>
[17:36:35.002] Globals: 5 objects totaling 35.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 112 bytes, list ‘...future.seeds_ii’ of 160 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:35.002] Packages: <none>
[17:36:35.002] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:36:35.002] Resolved: TRUE
[17:36:35.002] Value: 112 bytes of class ‘list’
[17:36:35.002] Early signaling: FALSE
[17:36:35.002] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:35.002] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:35.003] Chunk #1 of 1 ... DONE
[17:36:35.003] Launching 1 futures (chunks) ... DONE
[17:36:35.003] Resolving 1 futures (chunks) ...
[17:36:35.003] resolve() on list ...
[17:36:35.003]  recursive: 0
[17:36:35.003]  length: 1
[17:36:35.003] 
[17:36:35.003] resolved() for ‘SequentialFuture’ ...
[17:36:35.003] - state: ‘finished’
[17:36:35.003] - run: TRUE
[17:36:35.004] - result: ‘FutureResult’
[17:36:35.004] resolved() for ‘SequentialFuture’ ... done
[17:36:35.004] Future #1
[17:36:35.004] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:35.004] - nx: 1
[17:36:35.004] - relay: TRUE
[17:36:35.004] - stdout: TRUE
[17:36:35.004] - signal: TRUE
[17:36:35.004] - resignal: FALSE
[17:36:35.005] - force: TRUE
[17:36:35.005] - relayed: [n=1] FALSE
[17:36:35.005] - queued futures: [n=1] FALSE
[17:36:35.005]  - until=1
[17:36:35.005]  - relaying element #1
[17:36:35.005] - relayed: [n=1] TRUE
[17:36:35.005] - queued futures: [n=1] TRUE
[17:36:35.005] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:35.005]  length: 0 (resolved future 1)
[17:36:35.006] Relaying remaining futures
[17:36:35.006] signalConditionsASAP(NULL, pos=0) ...
[17:36:35.006] - nx: 1
[17:36:35.006] - relay: TRUE
[17:36:35.006] - stdout: TRUE
[17:36:35.006] - signal: TRUE
[17:36:35.006] - resignal: FALSE
[17:36:35.006] - force: TRUE
[17:36:35.006] - relayed: [n=1] TRUE
[17:36:35.008] - queued futures: [n=1] TRUE
 - flush all
[17:36:35.009] - relayed: [n=1] TRUE
[17:36:35.009] - queued futures: [n=1] TRUE
[17:36:35.009] signalConditionsASAP(NULL, pos=0) ... done
[17:36:35.009] resolve() on list ... DONE
[17:36:35.009]  - Number of value chunks collected: 1
[17:36:35.009] Resolving 1 futures (chunks) ... DONE
[17:36:35.009] Reducing values from 1 chunks ...
[17:36:35.010]  - Number of values collected after concatenation: 2
[17:36:35.010]  - Number of values expected: 2
[17:36:35.010] Reducing values from 1 chunks ... DONE
[17:36:35.010] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[17:36:35.010] plan(): Setting new future strategy stack:
[17:36:35.010] List of future strategies:
[17:36:35.010] 1. sequential:
[17:36:35.010]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:35.010]    - tweaked: FALSE
[17:36:35.010]    - call: plan(sequential)
[17:36:35.011] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[17:36:35.011] plan(): Setting new future strategy stack:
[17:36:35.011] List of future strategies:
[17:36:35.011] 1. multicore:
[17:36:35.011]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:35.011]    - tweaked: FALSE
[17:36:35.011]    - call: plan(strategy)
[17:36:35.016] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[17:36:35.016] getGlobalsAndPackagesXApply() ...
[17:36:35.016]  - future.globals: TRUE
[17:36:35.016] getGlobalsAndPackages() ...
[17:36:35.016] Searching for globals...
[17:36:35.050] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:36:35.051] Searching for globals ... DONE
[17:36:35.051] Resolving globals: FALSE
[17:36:35.054] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:36:35.055] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:36:35.055] - globals: [1] ‘FUN’
[17:36:35.055] 
[17:36:35.055] getGlobalsAndPackages() ... DONE
[17:36:35.055]  - globals found/used: [n=1] ‘FUN’
[17:36:35.055]  - needed namespaces: [n=0] 
[17:36:35.055] Finding globals ... DONE
[17:36:35.055]  - use_args: TRUE
[17:36:35.055]  - Getting '...' globals ...
[17:36:35.056] resolve() on list ...
[17:36:35.056]  recursive: 0
[17:36:35.056]  length: 1
[17:36:35.056]  elements: ‘...’
[17:36:35.056]  length: 0 (resolved future 1)
[17:36:35.056] resolve() on list ... DONE
[17:36:35.056]    - '...' content: [n=0] 
[17:36:35.056] List of 1
[17:36:35.056]  $ ...: list()
[17:36:35.056]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.056]  - attr(*, "where")=List of 1
[17:36:35.056]   ..$ ...:<environment: 0x556d73c28338> 
[17:36:35.056]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.056]  - attr(*, "resolved")= logi TRUE
[17:36:35.056]  - attr(*, "total_size")= num NA
[17:36:35.059]  - Getting '...' globals ... DONE
[17:36:35.059] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:35.059] List of 2
[17:36:35.059]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:36:35.059]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:36:35.059]  $ ...          : list()
[17:36:35.059]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.059]  - attr(*, "where")=List of 2
[17:36:35.059]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:35.059]   ..$ ...          :<environment: 0x556d73c28338> 
[17:36:35.059]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.059]  - attr(*, "resolved")= logi FALSE
[17:36:35.059]  - attr(*, "total_size")= num 354224
[17:36:35.062] Packages to be attached in all futures: [n=0] 
[17:36:35.062] getGlobalsAndPackagesXApply() ... DONE
[17:36:35.065] future_lapply() ...
[17:36:35.102] Number of chunks: 2
[17:36:35.102] getGlobalsAndPackagesXApply() ...
[17:36:35.102]  - future.globals: <name-value list> with names ‘list()’
[17:36:35.102]  - use_args: TRUE
[17:36:35.102] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:35.102] List of 2
[17:36:35.102]  $ ...          : list()
[17:36:35.102]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.102]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:36:35.102]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:36:35.102]  - attr(*, "where")=List of 2
[17:36:35.102]   ..$ ...          :<environment: 0x556d73c28338> 
[17:36:35.102]   ..$ ...future.FUN:<environment: namespace:base> 
[17:36:35.102]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.102]  - attr(*, "resolved")= logi FALSE
[17:36:35.102]  - attr(*, "total_size")= num NA
[17:36:35.106] Packages to be attached in all futures: [n=0] 
[17:36:35.106] getGlobalsAndPackagesXApply() ... DONE
[17:36:35.106] Number of futures (= number of chunks): 2
[17:36:35.106] Launching 2 futures (chunks) ...
[17:36:35.106] Chunk #1 of 2 ...
[17:36:35.106]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:35.106]  - seeds: <none>
[17:36:35.106]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.107] getGlobalsAndPackages() ...
[17:36:35.107] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.107] Resolving globals: FALSE
[17:36:35.107] Tweak future expression to call with '...' arguments ...
[17:36:35.107] {
[17:36:35.107]     do.call(function(...) {
[17:36:35.107]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.107]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.107]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.107]             on.exit(options(oopts), add = TRUE)
[17:36:35.107]         }
[17:36:35.107]         {
[17:36:35.107]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.107]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.107]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.107]             })
[17:36:35.107]         }
[17:36:35.107]     }, args = future.call.arguments)
[17:36:35.107] }
[17:36:35.107] Tweak future expression to call with '...' arguments ... DONE
[17:36:35.108] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.108] 
[17:36:35.108] getGlobalsAndPackages() ... DONE
[17:36:35.108] run() for ‘Future’ ...
[17:36:35.108] - state: ‘created’
[17:36:35.108] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:35.112] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.112] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:35.112]   - Field: ‘label’
[17:36:35.112]   - Field: ‘local’
[17:36:35.112]   - Field: ‘owner’
[17:36:35.112]   - Field: ‘envir’
[17:36:35.113]   - Field: ‘workers’
[17:36:35.113]   - Field: ‘packages’
[17:36:35.113]   - Field: ‘gc’
[17:36:35.113]   - Field: ‘job’
[17:36:35.113]   - Field: ‘conditions’
[17:36:35.113]   - Field: ‘expr’
[17:36:35.113]   - Field: ‘uuid’
[17:36:35.113]   - Field: ‘seed’
[17:36:35.113]   - Field: ‘version’
[17:36:35.113]   - Field: ‘result’
[17:36:35.113]   - Field: ‘asynchronous’
[17:36:35.114]   - Field: ‘calls’
[17:36:35.114]   - Field: ‘globals’
[17:36:35.114]   - Field: ‘stdout’
[17:36:35.114]   - Field: ‘earlySignal’
[17:36:35.114]   - Field: ‘lazy’
[17:36:35.114]   - Field: ‘state’
[17:36:35.114] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:35.114] - Launch lazy future ...
[17:36:35.115] Packages needed by the future expression (n = 0): <none>
[17:36:35.115] Packages needed by future strategies (n = 0): <none>
[17:36:35.116] {
[17:36:35.116]     {
[17:36:35.116]         {
[17:36:35.116]             ...future.startTime <- base::Sys.time()
[17:36:35.116]             {
[17:36:35.116]                 {
[17:36:35.116]                   {
[17:36:35.116]                     {
[17:36:35.116]                       base::local({
[17:36:35.116]                         has_future <- base::requireNamespace("future", 
[17:36:35.116]                           quietly = TRUE)
[17:36:35.116]                         if (has_future) {
[17:36:35.116]                           ns <- base::getNamespace("future")
[17:36:35.116]                           version <- ns[[".package"]][["version"]]
[17:36:35.116]                           if (is.null(version)) 
[17:36:35.116]                             version <- utils::packageVersion("future")
[17:36:35.116]                         }
[17:36:35.116]                         else {
[17:36:35.116]                           version <- NULL
[17:36:35.116]                         }
[17:36:35.116]                         if (!has_future || version < "1.8.0") {
[17:36:35.116]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:35.116]                             "", base::R.version$version.string), 
[17:36:35.116]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:35.116]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:35.116]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:35.116]                               "release", "version")], collapse = " "), 
[17:36:35.116]                             hostname = base::Sys.info()[["nodename"]])
[17:36:35.116]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:35.116]                             info)
[17:36:35.116]                           info <- base::paste(info, collapse = "; ")
[17:36:35.116]                           if (!has_future) {
[17:36:35.116]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:35.116]                               info)
[17:36:35.116]                           }
[17:36:35.116]                           else {
[17:36:35.116]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:35.116]                               info, version)
[17:36:35.116]                           }
[17:36:35.116]                           base::stop(msg)
[17:36:35.116]                         }
[17:36:35.116]                       })
[17:36:35.116]                     }
[17:36:35.116]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:35.116]                     base::options(mc.cores = 1L)
[17:36:35.116]                   }
[17:36:35.116]                   ...future.strategy.old <- future::plan("list")
[17:36:35.116]                   options(future.plan = NULL)
[17:36:35.116]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.116]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:35.116]                 }
[17:36:35.116]                 ...future.workdir <- getwd()
[17:36:35.116]             }
[17:36:35.116]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:35.116]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:35.116]         }
[17:36:35.116]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:35.116]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:35.116]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:35.116]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:35.116]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:35.116]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:35.116]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:35.116]             base::names(...future.oldOptions))
[17:36:35.116]     }
[17:36:35.116]     if (FALSE) {
[17:36:35.116]     }
[17:36:35.116]     else {
[17:36:35.116]         if (TRUE) {
[17:36:35.116]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:35.116]                 open = "w")
[17:36:35.116]         }
[17:36:35.116]         else {
[17:36:35.116]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:35.116]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:35.116]         }
[17:36:35.116]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:35.116]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:35.116]             base::sink(type = "output", split = FALSE)
[17:36:35.116]             base::close(...future.stdout)
[17:36:35.116]         }, add = TRUE)
[17:36:35.116]     }
[17:36:35.116]     ...future.frame <- base::sys.nframe()
[17:36:35.116]     ...future.conditions <- base::list()
[17:36:35.116]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:35.116]     if (FALSE) {
[17:36:35.116]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:35.116]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:35.116]     }
[17:36:35.116]     ...future.result <- base::tryCatch({
[17:36:35.116]         base::withCallingHandlers({
[17:36:35.116]             ...future.value <- base::withVisible(base::local({
[17:36:35.116]                 withCallingHandlers({
[17:36:35.116]                   {
[17:36:35.116]                     do.call(function(...) {
[17:36:35.116]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.116]                       if (!identical(...future.globals.maxSize.org, 
[17:36:35.116]                         ...future.globals.maxSize)) {
[17:36:35.116]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.116]                         on.exit(options(oopts), add = TRUE)
[17:36:35.116]                       }
[17:36:35.116]                       {
[17:36:35.116]                         lapply(seq_along(...future.elements_ii), 
[17:36:35.116]                           FUN = function(jj) {
[17:36:35.116]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.116]                             ...future.FUN(...future.X_jj, ...)
[17:36:35.116]                           })
[17:36:35.116]                       }
[17:36:35.116]                     }, args = future.call.arguments)
[17:36:35.116]                   }
[17:36:35.116]                 }, immediateCondition = function(cond) {
[17:36:35.116]                   save_rds <- function (object, pathname, ...) 
[17:36:35.116]                   {
[17:36:35.116]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:35.116]                     if (file_test("-f", pathname_tmp)) {
[17:36:35.116]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.116]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:35.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.116]                         fi_tmp[["mtime"]])
[17:36:35.116]                     }
[17:36:35.116]                     tryCatch({
[17:36:35.116]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:35.116]                     }, error = function(ex) {
[17:36:35.116]                       msg <- conditionMessage(ex)
[17:36:35.116]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.116]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:35.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.116]                         fi_tmp[["mtime"]], msg)
[17:36:35.116]                       ex$message <- msg
[17:36:35.116]                       stop(ex)
[17:36:35.116]                     })
[17:36:35.116]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:35.116]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:35.116]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:35.116]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.116]                       fi <- file.info(pathname)
[17:36:35.116]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:35.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.116]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:35.116]                         fi[["size"]], fi[["mtime"]])
[17:36:35.116]                       stop(msg)
[17:36:35.116]                     }
[17:36:35.116]                     invisible(pathname)
[17:36:35.116]                   }
[17:36:35.116]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:35.116]                     rootPath = tempdir()) 
[17:36:35.116]                   {
[17:36:35.116]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:35.116]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:35.116]                       tmpdir = path, fileext = ".rds")
[17:36:35.116]                     save_rds(obj, file)
[17:36:35.116]                   }
[17:36:35.116]                   saveImmediateCondition(cond, path = "/tmp/RtmpABg8SG/.future/immediateConditions")
[17:36:35.116]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.116]                   {
[17:36:35.116]                     inherits <- base::inherits
[17:36:35.116]                     invokeRestart <- base::invokeRestart
[17:36:35.116]                     is.null <- base::is.null
[17:36:35.116]                     muffled <- FALSE
[17:36:35.116]                     if (inherits(cond, "message")) {
[17:36:35.116]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:35.116]                       if (muffled) 
[17:36:35.116]                         invokeRestart("muffleMessage")
[17:36:35.116]                     }
[17:36:35.116]                     else if (inherits(cond, "warning")) {
[17:36:35.116]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:35.116]                       if (muffled) 
[17:36:35.116]                         invokeRestart("muffleWarning")
[17:36:35.116]                     }
[17:36:35.116]                     else if (inherits(cond, "condition")) {
[17:36:35.116]                       if (!is.null(pattern)) {
[17:36:35.116]                         computeRestarts <- base::computeRestarts
[17:36:35.116]                         grepl <- base::grepl
[17:36:35.116]                         restarts <- computeRestarts(cond)
[17:36:35.116]                         for (restart in restarts) {
[17:36:35.116]                           name <- restart$name
[17:36:35.116]                           if (is.null(name)) 
[17:36:35.116]                             next
[17:36:35.116]                           if (!grepl(pattern, name)) 
[17:36:35.116]                             next
[17:36:35.116]                           invokeRestart(restart)
[17:36:35.116]                           muffled <- TRUE
[17:36:35.116]                           break
[17:36:35.116]                         }
[17:36:35.116]                       }
[17:36:35.116]                     }
[17:36:35.116]                     invisible(muffled)
[17:36:35.116]                   }
[17:36:35.116]                   muffleCondition(cond)
[17:36:35.116]                 })
[17:36:35.116]             }))
[17:36:35.116]             future::FutureResult(value = ...future.value$value, 
[17:36:35.116]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.116]                   ...future.rng), globalenv = if (FALSE) 
[17:36:35.116]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:35.116]                     ...future.globalenv.names))
[17:36:35.116]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:35.116]         }, condition = base::local({
[17:36:35.116]             c <- base::c
[17:36:35.116]             inherits <- base::inherits
[17:36:35.116]             invokeRestart <- base::invokeRestart
[17:36:35.116]             length <- base::length
[17:36:35.116]             list <- base::list
[17:36:35.116]             seq.int <- base::seq.int
[17:36:35.116]             signalCondition <- base::signalCondition
[17:36:35.116]             sys.calls <- base::sys.calls
[17:36:35.116]             `[[` <- base::`[[`
[17:36:35.116]             `+` <- base::`+`
[17:36:35.116]             `<<-` <- base::`<<-`
[17:36:35.116]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:35.116]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:35.116]                   3L)]
[17:36:35.116]             }
[17:36:35.116]             function(cond) {
[17:36:35.116]                 is_error <- inherits(cond, "error")
[17:36:35.116]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:35.116]                   NULL)
[17:36:35.116]                 if (is_error) {
[17:36:35.116]                   sessionInformation <- function() {
[17:36:35.116]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:35.116]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:35.116]                       search = base::search(), system = base::Sys.info())
[17:36:35.116]                   }
[17:36:35.116]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.116]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:35.116]                     cond$call), session = sessionInformation(), 
[17:36:35.116]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:35.116]                   signalCondition(cond)
[17:36:35.116]                 }
[17:36:35.116]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:35.116]                 "immediateCondition"))) {
[17:36:35.116]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:35.116]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.116]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:35.116]                   if (TRUE && !signal) {
[17:36:35.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.116]                     {
[17:36:35.116]                       inherits <- base::inherits
[17:36:35.116]                       invokeRestart <- base::invokeRestart
[17:36:35.116]                       is.null <- base::is.null
[17:36:35.116]                       muffled <- FALSE
[17:36:35.116]                       if (inherits(cond, "message")) {
[17:36:35.116]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.116]                         if (muffled) 
[17:36:35.116]                           invokeRestart("muffleMessage")
[17:36:35.116]                       }
[17:36:35.116]                       else if (inherits(cond, "warning")) {
[17:36:35.116]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.116]                         if (muffled) 
[17:36:35.116]                           invokeRestart("muffleWarning")
[17:36:35.116]                       }
[17:36:35.116]                       else if (inherits(cond, "condition")) {
[17:36:35.116]                         if (!is.null(pattern)) {
[17:36:35.116]                           computeRestarts <- base::computeRestarts
[17:36:35.116]                           grepl <- base::grepl
[17:36:35.116]                           restarts <- computeRestarts(cond)
[17:36:35.116]                           for (restart in restarts) {
[17:36:35.116]                             name <- restart$name
[17:36:35.116]                             if (is.null(name)) 
[17:36:35.116]                               next
[17:36:35.116]                             if (!grepl(pattern, name)) 
[17:36:35.116]                               next
[17:36:35.116]                             invokeRestart(restart)
[17:36:35.116]                             muffled <- TRUE
[17:36:35.116]                             break
[17:36:35.116]                           }
[17:36:35.116]                         }
[17:36:35.116]                       }
[17:36:35.116]                       invisible(muffled)
[17:36:35.116]                     }
[17:36:35.116]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.116]                   }
[17:36:35.116]                 }
[17:36:35.116]                 else {
[17:36:35.116]                   if (TRUE) {
[17:36:35.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.116]                     {
[17:36:35.116]                       inherits <- base::inherits
[17:36:35.116]                       invokeRestart <- base::invokeRestart
[17:36:35.116]                       is.null <- base::is.null
[17:36:35.116]                       muffled <- FALSE
[17:36:35.116]                       if (inherits(cond, "message")) {
[17:36:35.116]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.116]                         if (muffled) 
[17:36:35.116]                           invokeRestart("muffleMessage")
[17:36:35.116]                       }
[17:36:35.116]                       else if (inherits(cond, "warning")) {
[17:36:35.116]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.116]                         if (muffled) 
[17:36:35.116]                           invokeRestart("muffleWarning")
[17:36:35.116]                       }
[17:36:35.116]                       else if (inherits(cond, "condition")) {
[17:36:35.116]                         if (!is.null(pattern)) {
[17:36:35.116]                           computeRestarts <- base::computeRestarts
[17:36:35.116]                           grepl <- base::grepl
[17:36:35.116]                           restarts <- computeRestarts(cond)
[17:36:35.116]                           for (restart in restarts) {
[17:36:35.116]                             name <- restart$name
[17:36:35.116]                             if (is.null(name)) 
[17:36:35.116]                               next
[17:36:35.116]                             if (!grepl(pattern, name)) 
[17:36:35.116]                               next
[17:36:35.116]                             invokeRestart(restart)
[17:36:35.116]                             muffled <- TRUE
[17:36:35.116]                             break
[17:36:35.116]                           }
[17:36:35.116]                         }
[17:36:35.116]                       }
[17:36:35.116]                       invisible(muffled)
[17:36:35.116]                     }
[17:36:35.116]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.116]                   }
[17:36:35.116]                 }
[17:36:35.116]             }
[17:36:35.116]         }))
[17:36:35.116]     }, error = function(ex) {
[17:36:35.116]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:35.116]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.116]                 ...future.rng), started = ...future.startTime, 
[17:36:35.116]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:35.116]             version = "1.8"), class = "FutureResult")
[17:36:35.116]     }, finally = {
[17:36:35.116]         if (!identical(...future.workdir, getwd())) 
[17:36:35.116]             setwd(...future.workdir)
[17:36:35.116]         {
[17:36:35.116]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:35.116]                 ...future.oldOptions$nwarnings <- NULL
[17:36:35.116]             }
[17:36:35.116]             base::options(...future.oldOptions)
[17:36:35.116]             if (.Platform$OS.type == "windows") {
[17:36:35.116]                 old_names <- names(...future.oldEnvVars)
[17:36:35.116]                 envs <- base::Sys.getenv()
[17:36:35.116]                 names <- names(envs)
[17:36:35.116]                 common <- intersect(names, old_names)
[17:36:35.116]                 added <- setdiff(names, old_names)
[17:36:35.116]                 removed <- setdiff(old_names, names)
[17:36:35.116]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:35.116]                   envs[common]]
[17:36:35.116]                 NAMES <- toupper(changed)
[17:36:35.116]                 args <- list()
[17:36:35.116]                 for (kk in seq_along(NAMES)) {
[17:36:35.116]                   name <- changed[[kk]]
[17:36:35.116]                   NAME <- NAMES[[kk]]
[17:36:35.116]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.116]                     next
[17:36:35.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.116]                 }
[17:36:35.116]                 NAMES <- toupper(added)
[17:36:35.116]                 for (kk in seq_along(NAMES)) {
[17:36:35.116]                   name <- added[[kk]]
[17:36:35.116]                   NAME <- NAMES[[kk]]
[17:36:35.116]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.116]                     next
[17:36:35.116]                   args[[name]] <- ""
[17:36:35.116]                 }
[17:36:35.116]                 NAMES <- toupper(removed)
[17:36:35.116]                 for (kk in seq_along(NAMES)) {
[17:36:35.116]                   name <- removed[[kk]]
[17:36:35.116]                   NAME <- NAMES[[kk]]
[17:36:35.116]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.116]                     next
[17:36:35.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.116]                 }
[17:36:35.116]                 if (length(args) > 0) 
[17:36:35.116]                   base::do.call(base::Sys.setenv, args = args)
[17:36:35.116]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:35.116]             }
[17:36:35.116]             else {
[17:36:35.116]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:35.116]             }
[17:36:35.116]             {
[17:36:35.116]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:35.116]                   0L) {
[17:36:35.116]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:35.116]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:35.116]                   base::options(opts)
[17:36:35.116]                 }
[17:36:35.116]                 {
[17:36:35.116]                   {
[17:36:35.116]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:35.116]                     NULL
[17:36:35.116]                   }
[17:36:35.116]                   options(future.plan = NULL)
[17:36:35.116]                   if (is.na(NA_character_)) 
[17:36:35.116]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.116]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:35.116]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:35.116]                     .init = FALSE)
[17:36:35.116]                 }
[17:36:35.116]             }
[17:36:35.116]         }
[17:36:35.116]     })
[17:36:35.116]     if (TRUE) {
[17:36:35.116]         base::sink(type = "output", split = FALSE)
[17:36:35.116]         if (TRUE) {
[17:36:35.116]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:35.116]         }
[17:36:35.116]         else {
[17:36:35.116]             ...future.result["stdout"] <- base::list(NULL)
[17:36:35.116]         }
[17:36:35.116]         base::close(...future.stdout)
[17:36:35.116]         ...future.stdout <- NULL
[17:36:35.116]     }
[17:36:35.116]     ...future.result$conditions <- ...future.conditions
[17:36:35.116]     ...future.result$finished <- base::Sys.time()
[17:36:35.116]     ...future.result
[17:36:35.116] }
[17:36:35.118] assign_globals() ...
[17:36:35.118] List of 5
[17:36:35.118]  $ future.call.arguments    : list()
[17:36:35.118]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.118]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:36:35.118]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:36:35.118]  $ ...future.elements_ii    :List of 1
[17:36:35.118]   ..$ : num [1:4] 1 3 1 7
[17:36:35.118]  $ ...future.seeds_ii       : NULL
[17:36:35.118]  $ ...future.globals.maxSize: num Inf
[17:36:35.118]  - attr(*, "resolved")= logi FALSE
[17:36:35.118]  - attr(*, "total_size")= num NA
[17:36:35.118]  - attr(*, "where")=List of 5
[17:36:35.118]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:35.118]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:35.118]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:35.118]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:35.118]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:35.118]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.118]  - attr(*, "already-done")= logi TRUE
[17:36:35.123] - copied ‘future.call.arguments’ to environment
[17:36:35.123] - copied ‘...future.FUN’ to environment
[17:36:35.123] - copied ‘...future.elements_ii’ to environment
[17:36:35.123] - copied ‘...future.seeds_ii’ to environment
[17:36:35.123] - copied ‘...future.globals.maxSize’ to environment
[17:36:35.123] assign_globals() ... done
[17:36:35.124] requestCore(): workers = 2
[17:36:35.127] MulticoreFuture started
[17:36:35.127] - Launch lazy future ... done
[17:36:35.127] plan(): Setting new future strategy stack:
[17:36:35.127] run() for ‘MulticoreFuture’ ... done
[17:36:35.128] Created future:
[17:36:35.127] List of future strategies:
[17:36:35.127] 1. sequential:
[17:36:35.127]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:35.127]    - tweaked: FALSE
[17:36:35.127]    - call: NULL
[17:36:35.128] plan(): nbrOfWorkers() = 1
[17:36:35.137] plan(): Setting new future strategy stack:
[17:36:35.137] List of future strategies:
[17:36:35.137] 1. multicore:
[17:36:35.137]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:35.137]    - tweaked: FALSE
[17:36:35.137]    - call: plan(strategy)
[17:36:35.143] plan(): nbrOfWorkers() = 2
[17:36:35.128] MulticoreFuture:
[17:36:35.128] Label: ‘future_apply-1’
[17:36:35.128] Expression:
[17:36:35.128] {
[17:36:35.128]     do.call(function(...) {
[17:36:35.128]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.128]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.128]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.128]             on.exit(options(oopts), add = TRUE)
[17:36:35.128]         }
[17:36:35.128]         {
[17:36:35.128]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.128]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.128]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.128]             })
[17:36:35.128]         }
[17:36:35.128]     }, args = future.call.arguments)
[17:36:35.128] }
[17:36:35.128] Lazy evaluation: FALSE
[17:36:35.128] Asynchronous evaluation: TRUE
[17:36:35.128] Local evaluation: TRUE
[17:36:35.128] Environment: R_GlobalEnv
[17:36:35.128] Capture standard output: TRUE
[17:36:35.128] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:35.128] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:35.128] Packages: <none>
[17:36:35.128] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:35.128] Resolved: TRUE
[17:36:35.128] Value: <not collected>
[17:36:35.128] Conditions captured: <none>
[17:36:35.128] Early signaling: FALSE
[17:36:35.128] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:35.128] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.145] Chunk #1 of 2 ... DONE
[17:36:35.145] Chunk #2 of 2 ...
[17:36:35.145]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:35.146]  - seeds: <none>
[17:36:35.146]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.146] getGlobalsAndPackages() ...
[17:36:35.146] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.146] Resolving globals: FALSE
[17:36:35.147] Tweak future expression to call with '...' arguments ...
[17:36:35.147] {
[17:36:35.147]     do.call(function(...) {
[17:36:35.147]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.147]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.147]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.147]             on.exit(options(oopts), add = TRUE)
[17:36:35.147]         }
[17:36:35.147]         {
[17:36:35.147]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.147]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.147]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.147]             })
[17:36:35.147]         }
[17:36:35.147]     }, args = future.call.arguments)
[17:36:35.147] }
[17:36:35.147] Tweak future expression to call with '...' arguments ... DONE
[17:36:35.148] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.148] 
[17:36:35.148] getGlobalsAndPackages() ... DONE
[17:36:35.148] run() for ‘Future’ ...
[17:36:35.149] - state: ‘created’
[17:36:35.149] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:35.154] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.154] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:35.154]   - Field: ‘label’
[17:36:35.154]   - Field: ‘local’
[17:36:35.155]   - Field: ‘owner’
[17:36:35.155]   - Field: ‘envir’
[17:36:35.155]   - Field: ‘workers’
[17:36:35.155]   - Field: ‘packages’
[17:36:35.155]   - Field: ‘gc’
[17:36:35.155]   - Field: ‘job’
[17:36:35.155]   - Field: ‘conditions’
[17:36:35.155]   - Field: ‘expr’
[17:36:35.156]   - Field: ‘uuid’
[17:36:35.156]   - Field: ‘seed’
[17:36:35.156]   - Field: ‘version’
[17:36:35.156]   - Field: ‘result’
[17:36:35.156]   - Field: ‘asynchronous’
[17:36:35.156]   - Field: ‘calls’
[17:36:35.156]   - Field: ‘globals’
[17:36:35.157]   - Field: ‘stdout’
[17:36:35.157]   - Field: ‘earlySignal’
[17:36:35.157]   - Field: ‘lazy’
[17:36:35.157]   - Field: ‘state’
[17:36:35.157] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:35.157] - Launch lazy future ...
[17:36:35.158] Packages needed by the future expression (n = 0): <none>
[17:36:35.158] Packages needed by future strategies (n = 0): <none>
[17:36:35.158] {
[17:36:35.158]     {
[17:36:35.158]         {
[17:36:35.158]             ...future.startTime <- base::Sys.time()
[17:36:35.158]             {
[17:36:35.158]                 {
[17:36:35.158]                   {
[17:36:35.158]                     {
[17:36:35.158]                       base::local({
[17:36:35.158]                         has_future <- base::requireNamespace("future", 
[17:36:35.158]                           quietly = TRUE)
[17:36:35.158]                         if (has_future) {
[17:36:35.158]                           ns <- base::getNamespace("future")
[17:36:35.158]                           version <- ns[[".package"]][["version"]]
[17:36:35.158]                           if (is.null(version)) 
[17:36:35.158]                             version <- utils::packageVersion("future")
[17:36:35.158]                         }
[17:36:35.158]                         else {
[17:36:35.158]                           version <- NULL
[17:36:35.158]                         }
[17:36:35.158]                         if (!has_future || version < "1.8.0") {
[17:36:35.158]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:35.158]                             "", base::R.version$version.string), 
[17:36:35.158]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:35.158]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:35.158]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:35.158]                               "release", "version")], collapse = " "), 
[17:36:35.158]                             hostname = base::Sys.info()[["nodename"]])
[17:36:35.158]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:35.158]                             info)
[17:36:35.158]                           info <- base::paste(info, collapse = "; ")
[17:36:35.158]                           if (!has_future) {
[17:36:35.158]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:35.158]                               info)
[17:36:35.158]                           }
[17:36:35.158]                           else {
[17:36:35.158]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:35.158]                               info, version)
[17:36:35.158]                           }
[17:36:35.158]                           base::stop(msg)
[17:36:35.158]                         }
[17:36:35.158]                       })
[17:36:35.158]                     }
[17:36:35.158]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:35.158]                     base::options(mc.cores = 1L)
[17:36:35.158]                   }
[17:36:35.158]                   ...future.strategy.old <- future::plan("list")
[17:36:35.158]                   options(future.plan = NULL)
[17:36:35.158]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.158]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:35.158]                 }
[17:36:35.158]                 ...future.workdir <- getwd()
[17:36:35.158]             }
[17:36:35.158]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:35.158]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:35.158]         }
[17:36:35.158]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:35.158]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:35.158]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:35.158]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:35.158]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:35.158]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:35.158]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:35.158]             base::names(...future.oldOptions))
[17:36:35.158]     }
[17:36:35.158]     if (FALSE) {
[17:36:35.158]     }
[17:36:35.158]     else {
[17:36:35.158]         if (TRUE) {
[17:36:35.158]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:35.158]                 open = "w")
[17:36:35.158]         }
[17:36:35.158]         else {
[17:36:35.158]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:35.158]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:35.158]         }
[17:36:35.158]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:35.158]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:35.158]             base::sink(type = "output", split = FALSE)
[17:36:35.158]             base::close(...future.stdout)
[17:36:35.158]         }, add = TRUE)
[17:36:35.158]     }
[17:36:35.158]     ...future.frame <- base::sys.nframe()
[17:36:35.158]     ...future.conditions <- base::list()
[17:36:35.158]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:35.158]     if (FALSE) {
[17:36:35.158]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:35.158]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:35.158]     }
[17:36:35.158]     ...future.result <- base::tryCatch({
[17:36:35.158]         base::withCallingHandlers({
[17:36:35.158]             ...future.value <- base::withVisible(base::local({
[17:36:35.158]                 withCallingHandlers({
[17:36:35.158]                   {
[17:36:35.158]                     do.call(function(...) {
[17:36:35.158]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.158]                       if (!identical(...future.globals.maxSize.org, 
[17:36:35.158]                         ...future.globals.maxSize)) {
[17:36:35.158]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.158]                         on.exit(options(oopts), add = TRUE)
[17:36:35.158]                       }
[17:36:35.158]                       {
[17:36:35.158]                         lapply(seq_along(...future.elements_ii), 
[17:36:35.158]                           FUN = function(jj) {
[17:36:35.158]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.158]                             ...future.FUN(...future.X_jj, ...)
[17:36:35.158]                           })
[17:36:35.158]                       }
[17:36:35.158]                     }, args = future.call.arguments)
[17:36:35.158]                   }
[17:36:35.158]                 }, immediateCondition = function(cond) {
[17:36:35.158]                   save_rds <- function (object, pathname, ...) 
[17:36:35.158]                   {
[17:36:35.158]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:35.158]                     if (file_test("-f", pathname_tmp)) {
[17:36:35.158]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.158]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:35.158]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.158]                         fi_tmp[["mtime"]])
[17:36:35.158]                     }
[17:36:35.158]                     tryCatch({
[17:36:35.158]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:35.158]                     }, error = function(ex) {
[17:36:35.158]                       msg <- conditionMessage(ex)
[17:36:35.158]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.158]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:35.158]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.158]                         fi_tmp[["mtime"]], msg)
[17:36:35.158]                       ex$message <- msg
[17:36:35.158]                       stop(ex)
[17:36:35.158]                     })
[17:36:35.158]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:35.158]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:35.158]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:35.158]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.158]                       fi <- file.info(pathname)
[17:36:35.158]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:35.158]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.158]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:35.158]                         fi[["size"]], fi[["mtime"]])
[17:36:35.158]                       stop(msg)
[17:36:35.158]                     }
[17:36:35.158]                     invisible(pathname)
[17:36:35.158]                   }
[17:36:35.158]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:35.158]                     rootPath = tempdir()) 
[17:36:35.158]                   {
[17:36:35.158]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:35.158]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:35.158]                       tmpdir = path, fileext = ".rds")
[17:36:35.158]                     save_rds(obj, file)
[17:36:35.158]                   }
[17:36:35.158]                   saveImmediateCondition(cond, path = "/tmp/RtmpABg8SG/.future/immediateConditions")
[17:36:35.158]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.158]                   {
[17:36:35.158]                     inherits <- base::inherits
[17:36:35.158]                     invokeRestart <- base::invokeRestart
[17:36:35.158]                     is.null <- base::is.null
[17:36:35.158]                     muffled <- FALSE
[17:36:35.158]                     if (inherits(cond, "message")) {
[17:36:35.158]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:35.158]                       if (muffled) 
[17:36:35.158]                         invokeRestart("muffleMessage")
[17:36:35.158]                     }
[17:36:35.158]                     else if (inherits(cond, "warning")) {
[17:36:35.158]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:35.158]                       if (muffled) 
[17:36:35.158]                         invokeRestart("muffleWarning")
[17:36:35.158]                     }
[17:36:35.158]                     else if (inherits(cond, "condition")) {
[17:36:35.158]                       if (!is.null(pattern)) {
[17:36:35.158]                         computeRestarts <- base::computeRestarts
[17:36:35.158]                         grepl <- base::grepl
[17:36:35.158]                         restarts <- computeRestarts(cond)
[17:36:35.158]                         for (restart in restarts) {
[17:36:35.158]                           name <- restart$name
[17:36:35.158]                           if (is.null(name)) 
[17:36:35.158]                             next
[17:36:35.158]                           if (!grepl(pattern, name)) 
[17:36:35.158]                             next
[17:36:35.158]                           invokeRestart(restart)
[17:36:35.158]                           muffled <- TRUE
[17:36:35.158]                           break
[17:36:35.158]                         }
[17:36:35.158]                       }
[17:36:35.158]                     }
[17:36:35.158]                     invisible(muffled)
[17:36:35.158]                   }
[17:36:35.158]                   muffleCondition(cond)
[17:36:35.158]                 })
[17:36:35.158]             }))
[17:36:35.158]             future::FutureResult(value = ...future.value$value, 
[17:36:35.158]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.158]                   ...future.rng), globalenv = if (FALSE) 
[17:36:35.158]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:35.158]                     ...future.globalenv.names))
[17:36:35.158]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:35.158]         }, condition = base::local({
[17:36:35.158]             c <- base::c
[17:36:35.158]             inherits <- base::inherits
[17:36:35.158]             invokeRestart <- base::invokeRestart
[17:36:35.158]             length <- base::length
[17:36:35.158]             list <- base::list
[17:36:35.158]             seq.int <- base::seq.int
[17:36:35.158]             signalCondition <- base::signalCondition
[17:36:35.158]             sys.calls <- base::sys.calls
[17:36:35.158]             `[[` <- base::`[[`
[17:36:35.158]             `+` <- base::`+`
[17:36:35.158]             `<<-` <- base::`<<-`
[17:36:35.158]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:35.158]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:35.158]                   3L)]
[17:36:35.158]             }
[17:36:35.158]             function(cond) {
[17:36:35.158]                 is_error <- inherits(cond, "error")
[17:36:35.158]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:35.158]                   NULL)
[17:36:35.158]                 if (is_error) {
[17:36:35.158]                   sessionInformation <- function() {
[17:36:35.158]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:35.158]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:35.158]                       search = base::search(), system = base::Sys.info())
[17:36:35.158]                   }
[17:36:35.158]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.158]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:35.158]                     cond$call), session = sessionInformation(), 
[17:36:35.158]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:35.158]                   signalCondition(cond)
[17:36:35.158]                 }
[17:36:35.158]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:35.158]                 "immediateCondition"))) {
[17:36:35.158]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:35.158]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.158]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:35.158]                   if (TRUE && !signal) {
[17:36:35.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.158]                     {
[17:36:35.158]                       inherits <- base::inherits
[17:36:35.158]                       invokeRestart <- base::invokeRestart
[17:36:35.158]                       is.null <- base::is.null
[17:36:35.158]                       muffled <- FALSE
[17:36:35.158]                       if (inherits(cond, "message")) {
[17:36:35.158]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.158]                         if (muffled) 
[17:36:35.158]                           invokeRestart("muffleMessage")
[17:36:35.158]                       }
[17:36:35.158]                       else if (inherits(cond, "warning")) {
[17:36:35.158]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.158]                         if (muffled) 
[17:36:35.158]                           invokeRestart("muffleWarning")
[17:36:35.158]                       }
[17:36:35.158]                       else if (inherits(cond, "condition")) {
[17:36:35.158]                         if (!is.null(pattern)) {
[17:36:35.158]                           computeRestarts <- base::computeRestarts
[17:36:35.158]                           grepl <- base::grepl
[17:36:35.158]                           restarts <- computeRestarts(cond)
[17:36:35.158]                           for (restart in restarts) {
[17:36:35.158]                             name <- restart$name
[17:36:35.158]                             if (is.null(name)) 
[17:36:35.158]                               next
[17:36:35.158]                             if (!grepl(pattern, name)) 
[17:36:35.158]                               next
[17:36:35.158]                             invokeRestart(restart)
[17:36:35.158]                             muffled <- TRUE
[17:36:35.158]                             break
[17:36:35.158]                           }
[17:36:35.158]                         }
[17:36:35.158]                       }
[17:36:35.158]                       invisible(muffled)
[17:36:35.158]                     }
[17:36:35.158]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.158]                   }
[17:36:35.158]                 }
[17:36:35.158]                 else {
[17:36:35.158]                   if (TRUE) {
[17:36:35.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.158]                     {
[17:36:35.158]                       inherits <- base::inherits
[17:36:35.158]                       invokeRestart <- base::invokeRestart
[17:36:35.158]                       is.null <- base::is.null
[17:36:35.158]                       muffled <- FALSE
[17:36:35.158]                       if (inherits(cond, "message")) {
[17:36:35.158]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.158]                         if (muffled) 
[17:36:35.158]                           invokeRestart("muffleMessage")
[17:36:35.158]                       }
[17:36:35.158]                       else if (inherits(cond, "warning")) {
[17:36:35.158]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.158]                         if (muffled) 
[17:36:35.158]                           invokeRestart("muffleWarning")
[17:36:35.158]                       }
[17:36:35.158]                       else if (inherits(cond, "condition")) {
[17:36:35.158]                         if (!is.null(pattern)) {
[17:36:35.158]                           computeRestarts <- base::computeRestarts
[17:36:35.158]                           grepl <- base::grepl
[17:36:35.158]                           restarts <- computeRestarts(cond)
[17:36:35.158]                           for (restart in restarts) {
[17:36:35.158]                             name <- restart$name
[17:36:35.158]                             if (is.null(name)) 
[17:36:35.158]                               next
[17:36:35.158]                             if (!grepl(pattern, name)) 
[17:36:35.158]                               next
[17:36:35.158]                             invokeRestart(restart)
[17:36:35.158]                             muffled <- TRUE
[17:36:35.158]                             break
[17:36:35.158]                           }
[17:36:35.158]                         }
[17:36:35.158]                       }
[17:36:35.158]                       invisible(muffled)
[17:36:35.158]                     }
[17:36:35.158]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.158]                   }
[17:36:35.158]                 }
[17:36:35.158]             }
[17:36:35.158]         }))
[17:36:35.158]     }, error = function(ex) {
[17:36:35.158]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:35.158]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.158]                 ...future.rng), started = ...future.startTime, 
[17:36:35.158]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:35.158]             version = "1.8"), class = "FutureResult")
[17:36:35.158]     }, finally = {
[17:36:35.158]         if (!identical(...future.workdir, getwd())) 
[17:36:35.158]             setwd(...future.workdir)
[17:36:35.158]         {
[17:36:35.158]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:35.158]                 ...future.oldOptions$nwarnings <- NULL
[17:36:35.158]             }
[17:36:35.158]             base::options(...future.oldOptions)
[17:36:35.158]             if (.Platform$OS.type == "windows") {
[17:36:35.158]                 old_names <- names(...future.oldEnvVars)
[17:36:35.158]                 envs <- base::Sys.getenv()
[17:36:35.158]                 names <- names(envs)
[17:36:35.158]                 common <- intersect(names, old_names)
[17:36:35.158]                 added <- setdiff(names, old_names)
[17:36:35.158]                 removed <- setdiff(old_names, names)
[17:36:35.158]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:35.158]                   envs[common]]
[17:36:35.158]                 NAMES <- toupper(changed)
[17:36:35.158]                 args <- list()
[17:36:35.158]                 for (kk in seq_along(NAMES)) {
[17:36:35.158]                   name <- changed[[kk]]
[17:36:35.158]                   NAME <- NAMES[[kk]]
[17:36:35.158]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.158]                     next
[17:36:35.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.158]                 }
[17:36:35.158]                 NAMES <- toupper(added)
[17:36:35.158]                 for (kk in seq_along(NAMES)) {
[17:36:35.158]                   name <- added[[kk]]
[17:36:35.158]                   NAME <- NAMES[[kk]]
[17:36:35.158]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.158]                     next
[17:36:35.158]                   args[[name]] <- ""
[17:36:35.158]                 }
[17:36:35.158]                 NAMES <- toupper(removed)
[17:36:35.158]                 for (kk in seq_along(NAMES)) {
[17:36:35.158]                   name <- removed[[kk]]
[17:36:35.158]                   NAME <- NAMES[[kk]]
[17:36:35.158]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.158]                     next
[17:36:35.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.158]                 }
[17:36:35.158]                 if (length(args) > 0) 
[17:36:35.158]                   base::do.call(base::Sys.setenv, args = args)
[17:36:35.158]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:35.158]             }
[17:36:35.158]             else {
[17:36:35.158]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:35.158]             }
[17:36:35.158]             {
[17:36:35.158]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:35.158]                   0L) {
[17:36:35.158]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:35.158]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:35.158]                   base::options(opts)
[17:36:35.158]                 }
[17:36:35.158]                 {
[17:36:35.158]                   {
[17:36:35.158]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:35.158]                     NULL
[17:36:35.158]                   }
[17:36:35.158]                   options(future.plan = NULL)
[17:36:35.158]                   if (is.na(NA_character_)) 
[17:36:35.158]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.158]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:35.158]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:35.158]                     .init = FALSE)
[17:36:35.158]                 }
[17:36:35.158]             }
[17:36:35.158]         }
[17:36:35.158]     })
[17:36:35.158]     if (TRUE) {
[17:36:35.158]         base::sink(type = "output", split = FALSE)
[17:36:35.158]         if (TRUE) {
[17:36:35.158]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:35.158]         }
[17:36:35.158]         else {
[17:36:35.158]             ...future.result["stdout"] <- base::list(NULL)
[17:36:35.158]         }
[17:36:35.158]         base::close(...future.stdout)
[17:36:35.158]         ...future.stdout <- NULL
[17:36:35.158]     }
[17:36:35.158]     ...future.result$conditions <- ...future.conditions
[17:36:35.158]     ...future.result$finished <- base::Sys.time()
[17:36:35.158]     ...future.result
[17:36:35.158] }
[17:36:35.161] assign_globals() ...
[17:36:35.161] List of 5
[17:36:35.161]  $ future.call.arguments    : list()
[17:36:35.161]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.161]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:36:35.161]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:36:35.161]  $ ...future.elements_ii    :List of 1
[17:36:35.161]   ..$ : num [1:4] 2 4 6 8
[17:36:35.161]  $ ...future.seeds_ii       : NULL
[17:36:35.161]  $ ...future.globals.maxSize: num Inf
[17:36:35.161]  - attr(*, "resolved")= logi FALSE
[17:36:35.161]  - attr(*, "total_size")= num NA
[17:36:35.161]  - attr(*, "where")=List of 5
[17:36:35.161]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:35.161]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:35.161]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:35.161]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:35.161]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:35.161]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.161]  - attr(*, "already-done")= logi TRUE
[17:36:35.168] - copied ‘future.call.arguments’ to environment
[17:36:35.168] - copied ‘...future.FUN’ to environment
[17:36:35.168] - copied ‘...future.elements_ii’ to environment
[17:36:35.168] - copied ‘...future.seeds_ii’ to environment
[17:36:35.168] - copied ‘...future.globals.maxSize’ to environment
[17:36:35.168] assign_globals() ... done
[17:36:35.169] requestCore(): workers = 2
[17:36:35.174] MulticoreFuture started
[17:36:35.174] - Launch lazy future ... done
[17:36:35.175] run() for ‘MulticoreFuture’ ... done
[17:36:35.175] Created future:
[17:36:35.175] plan(): Setting new future strategy stack:
[17:36:35.175] List of future strategies:
[17:36:35.175] 1. sequential:
[17:36:35.175]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:35.175]    - tweaked: FALSE
[17:36:35.175]    - call: NULL
[17:36:35.176] plan(): nbrOfWorkers() = 1
[17:36:35.179] plan(): Setting new future strategy stack:
[17:36:35.179] List of future strategies:
[17:36:35.179] 1. multicore:
[17:36:35.179]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:35.179]    - tweaked: FALSE
[17:36:35.179]    - call: plan(strategy)
[17:36:35.184] plan(): nbrOfWorkers() = 2
[17:36:35.175] MulticoreFuture:
[17:36:35.175] Label: ‘future_apply-2’
[17:36:35.175] Expression:
[17:36:35.175] {
[17:36:35.175]     do.call(function(...) {
[17:36:35.175]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.175]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.175]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.175]             on.exit(options(oopts), add = TRUE)
[17:36:35.175]         }
[17:36:35.175]         {
[17:36:35.175]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.175]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.175]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.175]             })
[17:36:35.175]         }
[17:36:35.175]     }, args = future.call.arguments)
[17:36:35.175] }
[17:36:35.175] Lazy evaluation: FALSE
[17:36:35.175] Asynchronous evaluation: TRUE
[17:36:35.175] Local evaluation: TRUE
[17:36:35.175] Environment: R_GlobalEnv
[17:36:35.175] Capture standard output: TRUE
[17:36:35.175] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:35.175] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:35.175] Packages: <none>
[17:36:35.175] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:35.175] Resolved: TRUE
[17:36:35.175] Value: <not collected>
[17:36:35.175] Conditions captured: <none>
[17:36:35.175] Early signaling: FALSE
[17:36:35.175] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:35.175] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.185] Chunk #2 of 2 ... DONE
[17:36:35.186] Launching 2 futures (chunks) ... DONE
[17:36:35.186] Resolving 2 futures (chunks) ...
[17:36:35.186] resolve() on list ...
[17:36:35.186]  recursive: 0
[17:36:35.186]  length: 2
[17:36:35.186] 
[17:36:35.187] Future #1
[17:36:35.187] result() for MulticoreFuture ...
[17:36:35.189] result() for MulticoreFuture ...
[17:36:35.189] result() for MulticoreFuture ... done
[17:36:35.189] result() for MulticoreFuture ... done
[17:36:35.189] result() for MulticoreFuture ...
[17:36:35.190] result() for MulticoreFuture ... done
[17:36:35.190] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:36:35.190] - nx: 2
[17:36:35.190] - relay: TRUE
[17:36:35.190] - stdout: TRUE
[17:36:35.190] - signal: TRUE
[17:36:35.190] - resignal: FALSE
[17:36:35.190] - force: TRUE
[17:36:35.191] - relayed: [n=2] FALSE, FALSE
[17:36:35.191] - queued futures: [n=2] FALSE, FALSE
[17:36:35.191]  - until=1
[17:36:35.191]  - relaying element #1
[17:36:35.191] result() for MulticoreFuture ...
[17:36:35.191] result() for MulticoreFuture ... done
[17:36:35.191] result() for MulticoreFuture ...
[17:36:35.192] result() for MulticoreFuture ... done
[17:36:35.192] result() for MulticoreFuture ...
[17:36:35.192] result() for MulticoreFuture ... done
[17:36:35.192] result() for MulticoreFuture ...
[17:36:35.192] result() for MulticoreFuture ... done
[17:36:35.192] - relayed: [n=2] TRUE, FALSE
[17:36:35.193] - queued futures: [n=2] TRUE, FALSE
[17:36:35.193] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:36:35.193]  length: 1 (resolved future 1)
[17:36:35.193] Future #2
[17:36:35.197] result() for MulticoreFuture ...
[17:36:35.199] result() for MulticoreFuture ...
[17:36:35.199] result() for MulticoreFuture ... done
[17:36:35.199] result() for MulticoreFuture ... done
[17:36:35.200] result() for MulticoreFuture ...
[17:36:35.200] result() for MulticoreFuture ... done
[17:36:35.200] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:36:35.200] - nx: 2
[17:36:35.200] - relay: TRUE
[17:36:35.201] - stdout: TRUE
[17:36:35.201] - signal: TRUE
[17:36:35.201] - resignal: FALSE
[17:36:35.201] - force: TRUE
[17:36:35.201] - relayed: [n=2] TRUE, FALSE
[17:36:35.201] - queued futures: [n=2] TRUE, FALSE
[17:36:35.201]  - until=2
[17:36:35.201]  - relaying element #2
[17:36:35.201] result() for MulticoreFuture ...
[17:36:35.202] result() for MulticoreFuture ... done
[17:36:35.202] result() for MulticoreFuture ...
[17:36:35.202] result() for MulticoreFuture ... done
[17:36:35.202] result() for MulticoreFuture ...
[17:36:35.202] result() for MulticoreFuture ... done
[17:36:35.202] result() for MulticoreFuture ...
[17:36:35.202] result() for MulticoreFuture ... done
[17:36:35.202] - relayed: [n=2] TRUE, TRUE
[17:36:35.203] - queued futures: [n=2] TRUE, TRUE
[17:36:35.203] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:36:35.203]  length: 0 (resolved future 2)
[17:36:35.203] Relaying remaining futures
[17:36:35.203] signalConditionsASAP(NULL, pos=0) ...
[17:36:35.203] - nx: 2
[17:36:35.203] - relay: TRUE
[17:36:35.203] - stdout: TRUE
[17:36:35.203] - signal: TRUE
[17:36:35.204] - resignal: FALSE
[17:36:35.204] - force: TRUE
[17:36:35.204] - relayed: [n=2] TRUE, TRUE
[17:36:35.204] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:35.204] - relayed: [n=2] TRUE, TRUE
[17:36:35.204] - queued futures: [n=2] TRUE, TRUE
[17:36:35.204] signalConditionsASAP(NULL, pos=0) ... done
[17:36:35.204] resolve() on list ... DONE
[17:36:35.205] result() for MulticoreFuture ...
[17:36:35.205] result() for MulticoreFuture ... done
[17:36:35.205] result() for MulticoreFuture ...
[17:36:35.205] result() for MulticoreFuture ... done
[17:36:35.205] result() for MulticoreFuture ...
[17:36:35.205] result() for MulticoreFuture ... done
[17:36:35.205] result() for MulticoreFuture ...
[17:36:35.205] result() for MulticoreFuture ... done
[17:36:35.205]  - Number of value chunks collected: 2
[17:36:35.206] Resolving 2 futures (chunks) ... DONE
[17:36:35.206] Reducing values from 2 chunks ...
[17:36:35.206]  - Number of values collected after concatenation: 2
[17:36:35.206]  - Number of values expected: 2
[17:36:35.206] Reducing values from 2 chunks ... DONE
[17:36:35.206] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:36:35.207] getGlobalsAndPackagesXApply() ...
[17:36:35.207]  - future.globals: TRUE
[17:36:35.207] getGlobalsAndPackages() ...
[17:36:35.207] Searching for globals...
[17:36:35.243] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:36:35.243] Searching for globals ... DONE
[17:36:35.243] Resolving globals: FALSE
[17:36:35.245] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:36:35.245] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:36:35.245] - globals: [1] ‘FUN’
[17:36:35.245] 
[17:36:35.245] getGlobalsAndPackages() ... DONE
[17:36:35.245]  - globals found/used: [n=1] ‘FUN’
[17:36:35.246]  - needed namespaces: [n=0] 
[17:36:35.246] Finding globals ... DONE
[17:36:35.246]  - use_args: TRUE
[17:36:35.246]  - Getting '...' globals ...
[17:36:35.246] resolve() on list ...
[17:36:35.246]  recursive: 0
[17:36:35.246]  length: 1
[17:36:35.246]  elements: ‘...’
[17:36:35.247]  length: 0 (resolved future 1)
[17:36:35.247] resolve() on list ... DONE
[17:36:35.247]    - '...' content: [n=0] 
[17:36:35.247] List of 1
[17:36:35.247]  $ ...: list()
[17:36:35.247]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.247]  - attr(*, "where")=List of 1
[17:36:35.247]   ..$ ...:<environment: 0x556d736767f8> 
[17:36:35.247]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.247]  - attr(*, "resolved")= logi TRUE
[17:36:35.247]  - attr(*, "total_size")= num NA
[17:36:35.249]  - Getting '...' globals ... DONE
[17:36:35.250] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:35.250] List of 2
[17:36:35.250]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:36:35.250]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:36:35.250]  $ ...          : list()
[17:36:35.250]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.250]  - attr(*, "where")=List of 2
[17:36:35.250]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:35.250]   ..$ ...          :<environment: 0x556d736767f8> 
[17:36:35.250]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.250]  - attr(*, "resolved")= logi FALSE
[17:36:35.250]  - attr(*, "total_size")= num 354224
[17:36:35.252] Packages to be attached in all futures: [n=0] 
[17:36:35.252] getGlobalsAndPackagesXApply() ... DONE
[17:36:35.256] future_lapply() ...
[17:36:35.292] Number of chunks: 2
[17:36:35.293] getGlobalsAndPackagesXApply() ...
[17:36:35.293]  - future.globals: <name-value list> with names ‘list()’
[17:36:35.293]  - use_args: TRUE
[17:36:35.293] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:35.293] List of 2
[17:36:35.293]  $ ...          : list()
[17:36:35.293]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.293]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:36:35.293]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:36:35.293]  - attr(*, "where")=List of 2
[17:36:35.293]   ..$ ...          :<environment: 0x556d736767f8> 
[17:36:35.293]   ..$ ...future.FUN:<environment: namespace:base> 
[17:36:35.293]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.293]  - attr(*, "resolved")= logi FALSE
[17:36:35.293]  - attr(*, "total_size")= num NA
[17:36:35.297] Packages to be attached in all futures: [n=0] 
[17:36:35.297] getGlobalsAndPackagesXApply() ... DONE
[17:36:35.297] Number of futures (= number of chunks): 2
[17:36:35.297] Launching 2 futures (chunks) ...
[17:36:35.297] Chunk #1 of 2 ...
[17:36:35.298]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:35.298]  - seeds: <none>
[17:36:35.298]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.298] getGlobalsAndPackages() ...
[17:36:35.298] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.298] Resolving globals: FALSE
[17:36:35.298] Tweak future expression to call with '...' arguments ...
[17:36:35.298] {
[17:36:35.298]     do.call(function(...) {
[17:36:35.298]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.298]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.298]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.298]             on.exit(options(oopts), add = TRUE)
[17:36:35.298]         }
[17:36:35.298]         {
[17:36:35.298]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.298]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.298]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.298]             })
[17:36:35.298]         }
[17:36:35.298]     }, args = future.call.arguments)
[17:36:35.298] }
[17:36:35.299] Tweak future expression to call with '...' arguments ... DONE
[17:36:35.299] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.299] 
[17:36:35.299] getGlobalsAndPackages() ... DONE
[17:36:35.300] run() for ‘Future’ ...
[17:36:35.300] - state: ‘created’
[17:36:35.300] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:35.303] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.303] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:35.304]   - Field: ‘label’
[17:36:35.304]   - Field: ‘local’
[17:36:35.304]   - Field: ‘owner’
[17:36:35.304]   - Field: ‘envir’
[17:36:35.304]   - Field: ‘workers’
[17:36:35.304]   - Field: ‘packages’
[17:36:35.304]   - Field: ‘gc’
[17:36:35.304]   - Field: ‘job’
[17:36:35.304]   - Field: ‘conditions’
[17:36:35.305]   - Field: ‘expr’
[17:36:35.305]   - Field: ‘uuid’
[17:36:35.305]   - Field: ‘seed’
[17:36:35.305]   - Field: ‘version’
[17:36:35.306]   - Field: ‘result’
[17:36:35.306]   - Field: ‘asynchronous’
[17:36:35.307]   - Field: ‘calls’
[17:36:35.307]   - Field: ‘globals’
[17:36:35.307]   - Field: ‘stdout’
[17:36:35.307]   - Field: ‘earlySignal’
[17:36:35.307]   - Field: ‘lazy’
[17:36:35.307]   - Field: ‘state’
[17:36:35.307] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:35.307] - Launch lazy future ...
[17:36:35.308] Packages needed by the future expression (n = 0): <none>
[17:36:35.308] Packages needed by future strategies (n = 0): <none>
[17:36:35.308] {
[17:36:35.308]     {
[17:36:35.308]         {
[17:36:35.308]             ...future.startTime <- base::Sys.time()
[17:36:35.308]             {
[17:36:35.308]                 {
[17:36:35.308]                   {
[17:36:35.308]                     {
[17:36:35.308]                       base::local({
[17:36:35.308]                         has_future <- base::requireNamespace("future", 
[17:36:35.308]                           quietly = TRUE)
[17:36:35.308]                         if (has_future) {
[17:36:35.308]                           ns <- base::getNamespace("future")
[17:36:35.308]                           version <- ns[[".package"]][["version"]]
[17:36:35.308]                           if (is.null(version)) 
[17:36:35.308]                             version <- utils::packageVersion("future")
[17:36:35.308]                         }
[17:36:35.308]                         else {
[17:36:35.308]                           version <- NULL
[17:36:35.308]                         }
[17:36:35.308]                         if (!has_future || version < "1.8.0") {
[17:36:35.308]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:35.308]                             "", base::R.version$version.string), 
[17:36:35.308]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:35.308]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:35.308]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:35.308]                               "release", "version")], collapse = " "), 
[17:36:35.308]                             hostname = base::Sys.info()[["nodename"]])
[17:36:35.308]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:35.308]                             info)
[17:36:35.308]                           info <- base::paste(info, collapse = "; ")
[17:36:35.308]                           if (!has_future) {
[17:36:35.308]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:35.308]                               info)
[17:36:35.308]                           }
[17:36:35.308]                           else {
[17:36:35.308]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:35.308]                               info, version)
[17:36:35.308]                           }
[17:36:35.308]                           base::stop(msg)
[17:36:35.308]                         }
[17:36:35.308]                       })
[17:36:35.308]                     }
[17:36:35.308]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:35.308]                     base::options(mc.cores = 1L)
[17:36:35.308]                   }
[17:36:35.308]                   ...future.strategy.old <- future::plan("list")
[17:36:35.308]                   options(future.plan = NULL)
[17:36:35.308]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.308]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:35.308]                 }
[17:36:35.308]                 ...future.workdir <- getwd()
[17:36:35.308]             }
[17:36:35.308]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:35.308]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:35.308]         }
[17:36:35.308]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:35.308]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:35.308]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:35.308]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:35.308]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:35.308]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:35.308]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:35.308]             base::names(...future.oldOptions))
[17:36:35.308]     }
[17:36:35.308]     if (FALSE) {
[17:36:35.308]     }
[17:36:35.308]     else {
[17:36:35.308]         if (TRUE) {
[17:36:35.308]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:35.308]                 open = "w")
[17:36:35.308]         }
[17:36:35.308]         else {
[17:36:35.308]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:35.308]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:35.308]         }
[17:36:35.308]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:35.308]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:35.308]             base::sink(type = "output", split = FALSE)
[17:36:35.308]             base::close(...future.stdout)
[17:36:35.308]         }, add = TRUE)
[17:36:35.308]     }
[17:36:35.308]     ...future.frame <- base::sys.nframe()
[17:36:35.308]     ...future.conditions <- base::list()
[17:36:35.308]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:35.308]     if (FALSE) {
[17:36:35.308]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:35.308]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:35.308]     }
[17:36:35.308]     ...future.result <- base::tryCatch({
[17:36:35.308]         base::withCallingHandlers({
[17:36:35.308]             ...future.value <- base::withVisible(base::local({
[17:36:35.308]                 withCallingHandlers({
[17:36:35.308]                   {
[17:36:35.308]                     do.call(function(...) {
[17:36:35.308]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.308]                       if (!identical(...future.globals.maxSize.org, 
[17:36:35.308]                         ...future.globals.maxSize)) {
[17:36:35.308]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.308]                         on.exit(options(oopts), add = TRUE)
[17:36:35.308]                       }
[17:36:35.308]                       {
[17:36:35.308]                         lapply(seq_along(...future.elements_ii), 
[17:36:35.308]                           FUN = function(jj) {
[17:36:35.308]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.308]                             ...future.FUN(...future.X_jj, ...)
[17:36:35.308]                           })
[17:36:35.308]                       }
[17:36:35.308]                     }, args = future.call.arguments)
[17:36:35.308]                   }
[17:36:35.308]                 }, immediateCondition = function(cond) {
[17:36:35.308]                   save_rds <- function (object, pathname, ...) 
[17:36:35.308]                   {
[17:36:35.308]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:35.308]                     if (file_test("-f", pathname_tmp)) {
[17:36:35.308]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.308]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:35.308]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.308]                         fi_tmp[["mtime"]])
[17:36:35.308]                     }
[17:36:35.308]                     tryCatch({
[17:36:35.308]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:35.308]                     }, error = function(ex) {
[17:36:35.308]                       msg <- conditionMessage(ex)
[17:36:35.308]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.308]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:35.308]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.308]                         fi_tmp[["mtime"]], msg)
[17:36:35.308]                       ex$message <- msg
[17:36:35.308]                       stop(ex)
[17:36:35.308]                     })
[17:36:35.308]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:35.308]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:35.308]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:35.308]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.308]                       fi <- file.info(pathname)
[17:36:35.308]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:35.308]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.308]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:35.308]                         fi[["size"]], fi[["mtime"]])
[17:36:35.308]                       stop(msg)
[17:36:35.308]                     }
[17:36:35.308]                     invisible(pathname)
[17:36:35.308]                   }
[17:36:35.308]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:35.308]                     rootPath = tempdir()) 
[17:36:35.308]                   {
[17:36:35.308]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:35.308]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:35.308]                       tmpdir = path, fileext = ".rds")
[17:36:35.308]                     save_rds(obj, file)
[17:36:35.308]                   }
[17:36:35.308]                   saveImmediateCondition(cond, path = "/tmp/RtmpABg8SG/.future/immediateConditions")
[17:36:35.308]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.308]                   {
[17:36:35.308]                     inherits <- base::inherits
[17:36:35.308]                     invokeRestart <- base::invokeRestart
[17:36:35.308]                     is.null <- base::is.null
[17:36:35.308]                     muffled <- FALSE
[17:36:35.308]                     if (inherits(cond, "message")) {
[17:36:35.308]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:35.308]                       if (muffled) 
[17:36:35.308]                         invokeRestart("muffleMessage")
[17:36:35.308]                     }
[17:36:35.308]                     else if (inherits(cond, "warning")) {
[17:36:35.308]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:35.308]                       if (muffled) 
[17:36:35.308]                         invokeRestart("muffleWarning")
[17:36:35.308]                     }
[17:36:35.308]                     else if (inherits(cond, "condition")) {
[17:36:35.308]                       if (!is.null(pattern)) {
[17:36:35.308]                         computeRestarts <- base::computeRestarts
[17:36:35.308]                         grepl <- base::grepl
[17:36:35.308]                         restarts <- computeRestarts(cond)
[17:36:35.308]                         for (restart in restarts) {
[17:36:35.308]                           name <- restart$name
[17:36:35.308]                           if (is.null(name)) 
[17:36:35.308]                             next
[17:36:35.308]                           if (!grepl(pattern, name)) 
[17:36:35.308]                             next
[17:36:35.308]                           invokeRestart(restart)
[17:36:35.308]                           muffled <- TRUE
[17:36:35.308]                           break
[17:36:35.308]                         }
[17:36:35.308]                       }
[17:36:35.308]                     }
[17:36:35.308]                     invisible(muffled)
[17:36:35.308]                   }
[17:36:35.308]                   muffleCondition(cond)
[17:36:35.308]                 })
[17:36:35.308]             }))
[17:36:35.308]             future::FutureResult(value = ...future.value$value, 
[17:36:35.308]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.308]                   ...future.rng), globalenv = if (FALSE) 
[17:36:35.308]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:35.308]                     ...future.globalenv.names))
[17:36:35.308]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:35.308]         }, condition = base::local({
[17:36:35.308]             c <- base::c
[17:36:35.308]             inherits <- base::inherits
[17:36:35.308]             invokeRestart <- base::invokeRestart
[17:36:35.308]             length <- base::length
[17:36:35.308]             list <- base::list
[17:36:35.308]             seq.int <- base::seq.int
[17:36:35.308]             signalCondition <- base::signalCondition
[17:36:35.308]             sys.calls <- base::sys.calls
[17:36:35.308]             `[[` <- base::`[[`
[17:36:35.308]             `+` <- base::`+`
[17:36:35.308]             `<<-` <- base::`<<-`
[17:36:35.308]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:35.308]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:35.308]                   3L)]
[17:36:35.308]             }
[17:36:35.308]             function(cond) {
[17:36:35.308]                 is_error <- inherits(cond, "error")
[17:36:35.308]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:35.308]                   NULL)
[17:36:35.308]                 if (is_error) {
[17:36:35.308]                   sessionInformation <- function() {
[17:36:35.308]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:35.308]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:35.308]                       search = base::search(), system = base::Sys.info())
[17:36:35.308]                   }
[17:36:35.308]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.308]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:35.308]                     cond$call), session = sessionInformation(), 
[17:36:35.308]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:35.308]                   signalCondition(cond)
[17:36:35.308]                 }
[17:36:35.308]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:35.308]                 "immediateCondition"))) {
[17:36:35.308]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:35.308]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.308]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:35.308]                   if (TRUE && !signal) {
[17:36:35.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.308]                     {
[17:36:35.308]                       inherits <- base::inherits
[17:36:35.308]                       invokeRestart <- base::invokeRestart
[17:36:35.308]                       is.null <- base::is.null
[17:36:35.308]                       muffled <- FALSE
[17:36:35.308]                       if (inherits(cond, "message")) {
[17:36:35.308]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.308]                         if (muffled) 
[17:36:35.308]                           invokeRestart("muffleMessage")
[17:36:35.308]                       }
[17:36:35.308]                       else if (inherits(cond, "warning")) {
[17:36:35.308]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.308]                         if (muffled) 
[17:36:35.308]                           invokeRestart("muffleWarning")
[17:36:35.308]                       }
[17:36:35.308]                       else if (inherits(cond, "condition")) {
[17:36:35.308]                         if (!is.null(pattern)) {
[17:36:35.308]                           computeRestarts <- base::computeRestarts
[17:36:35.308]                           grepl <- base::grepl
[17:36:35.308]                           restarts <- computeRestarts(cond)
[17:36:35.308]                           for (restart in restarts) {
[17:36:35.308]                             name <- restart$name
[17:36:35.308]                             if (is.null(name)) 
[17:36:35.308]                               next
[17:36:35.308]                             if (!grepl(pattern, name)) 
[17:36:35.308]                               next
[17:36:35.308]                             invokeRestart(restart)
[17:36:35.308]                             muffled <- TRUE
[17:36:35.308]                             break
[17:36:35.308]                           }
[17:36:35.308]                         }
[17:36:35.308]                       }
[17:36:35.308]                       invisible(muffled)
[17:36:35.308]                     }
[17:36:35.308]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.308]                   }
[17:36:35.308]                 }
[17:36:35.308]                 else {
[17:36:35.308]                   if (TRUE) {
[17:36:35.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.308]                     {
[17:36:35.308]                       inherits <- base::inherits
[17:36:35.308]                       invokeRestart <- base::invokeRestart
[17:36:35.308]                       is.null <- base::is.null
[17:36:35.308]                       muffled <- FALSE
[17:36:35.308]                       if (inherits(cond, "message")) {
[17:36:35.308]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.308]                         if (muffled) 
[17:36:35.308]                           invokeRestart("muffleMessage")
[17:36:35.308]                       }
[17:36:35.308]                       else if (inherits(cond, "warning")) {
[17:36:35.308]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.308]                         if (muffled) 
[17:36:35.308]                           invokeRestart("muffleWarning")
[17:36:35.308]                       }
[17:36:35.308]                       else if (inherits(cond, "condition")) {
[17:36:35.308]                         if (!is.null(pattern)) {
[17:36:35.308]                           computeRestarts <- base::computeRestarts
[17:36:35.308]                           grepl <- base::grepl
[17:36:35.308]                           restarts <- computeRestarts(cond)
[17:36:35.308]                           for (restart in restarts) {
[17:36:35.308]                             name <- restart$name
[17:36:35.308]                             if (is.null(name)) 
[17:36:35.308]                               next
[17:36:35.308]                             if (!grepl(pattern, name)) 
[17:36:35.308]                               next
[17:36:35.308]                             invokeRestart(restart)
[17:36:35.308]                             muffled <- TRUE
[17:36:35.308]                             break
[17:36:35.308]                           }
[17:36:35.308]                         }
[17:36:35.308]                       }
[17:36:35.308]                       invisible(muffled)
[17:36:35.308]                     }
[17:36:35.308]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.308]                   }
[17:36:35.308]                 }
[17:36:35.308]             }
[17:36:35.308]         }))
[17:36:35.308]     }, error = function(ex) {
[17:36:35.308]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:35.308]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.308]                 ...future.rng), started = ...future.startTime, 
[17:36:35.308]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:35.308]             version = "1.8"), class = "FutureResult")
[17:36:35.308]     }, finally = {
[17:36:35.308]         if (!identical(...future.workdir, getwd())) 
[17:36:35.308]             setwd(...future.workdir)
[17:36:35.308]         {
[17:36:35.308]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:35.308]                 ...future.oldOptions$nwarnings <- NULL
[17:36:35.308]             }
[17:36:35.308]             base::options(...future.oldOptions)
[17:36:35.308]             if (.Platform$OS.type == "windows") {
[17:36:35.308]                 old_names <- names(...future.oldEnvVars)
[17:36:35.308]                 envs <- base::Sys.getenv()
[17:36:35.308]                 names <- names(envs)
[17:36:35.308]                 common <- intersect(names, old_names)
[17:36:35.308]                 added <- setdiff(names, old_names)
[17:36:35.308]                 removed <- setdiff(old_names, names)
[17:36:35.308]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:35.308]                   envs[common]]
[17:36:35.308]                 NAMES <- toupper(changed)
[17:36:35.308]                 args <- list()
[17:36:35.308]                 for (kk in seq_along(NAMES)) {
[17:36:35.308]                   name <- changed[[kk]]
[17:36:35.308]                   NAME <- NAMES[[kk]]
[17:36:35.308]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.308]                     next
[17:36:35.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.308]                 }
[17:36:35.308]                 NAMES <- toupper(added)
[17:36:35.308]                 for (kk in seq_along(NAMES)) {
[17:36:35.308]                   name <- added[[kk]]
[17:36:35.308]                   NAME <- NAMES[[kk]]
[17:36:35.308]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.308]                     next
[17:36:35.308]                   args[[name]] <- ""
[17:36:35.308]                 }
[17:36:35.308]                 NAMES <- toupper(removed)
[17:36:35.308]                 for (kk in seq_along(NAMES)) {
[17:36:35.308]                   name <- removed[[kk]]
[17:36:35.308]                   NAME <- NAMES[[kk]]
[17:36:35.308]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.308]                     next
[17:36:35.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.308]                 }
[17:36:35.308]                 if (length(args) > 0) 
[17:36:35.308]                   base::do.call(base::Sys.setenv, args = args)
[17:36:35.308]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:35.308]             }
[17:36:35.308]             else {
[17:36:35.308]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:35.308]             }
[17:36:35.308]             {
[17:36:35.308]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:35.308]                   0L) {
[17:36:35.308]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:35.308]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:35.308]                   base::options(opts)
[17:36:35.308]                 }
[17:36:35.308]                 {
[17:36:35.308]                   {
[17:36:35.308]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:35.308]                     NULL
[17:36:35.308]                   }
[17:36:35.308]                   options(future.plan = NULL)
[17:36:35.308]                   if (is.na(NA_character_)) 
[17:36:35.308]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.308]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:35.308]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:35.308]                     .init = FALSE)
[17:36:35.308]                 }
[17:36:35.308]             }
[17:36:35.308]         }
[17:36:35.308]     })
[17:36:35.308]     if (TRUE) {
[17:36:35.308]         base::sink(type = "output", split = FALSE)
[17:36:35.308]         if (TRUE) {
[17:36:35.308]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:35.308]         }
[17:36:35.308]         else {
[17:36:35.308]             ...future.result["stdout"] <- base::list(NULL)
[17:36:35.308]         }
[17:36:35.308]         base::close(...future.stdout)
[17:36:35.308]         ...future.stdout <- NULL
[17:36:35.308]     }
[17:36:35.308]     ...future.result$conditions <- ...future.conditions
[17:36:35.308]     ...future.result$finished <- base::Sys.time()
[17:36:35.308]     ...future.result
[17:36:35.308] }
[17:36:35.310] assign_globals() ...
[17:36:35.311] List of 5
[17:36:35.311]  $ future.call.arguments    : list()
[17:36:35.311]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.311]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:36:35.311]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:36:35.311]  $ ...future.elements_ii    :List of 1
[17:36:35.311]   ..$ : num [1:4] 1 3 1 7
[17:36:35.311]  $ ...future.seeds_ii       : NULL
[17:36:35.311]  $ ...future.globals.maxSize: num Inf
[17:36:35.311]  - attr(*, "resolved")= logi FALSE
[17:36:35.311]  - attr(*, "total_size")= num NA
[17:36:35.311]  - attr(*, "where")=List of 5
[17:36:35.311]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:35.311]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:35.311]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:35.311]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:35.311]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:35.311]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.311]  - attr(*, "already-done")= logi TRUE
[17:36:35.315] - copied ‘future.call.arguments’ to environment
[17:36:35.315] - copied ‘...future.FUN’ to environment
[17:36:35.315] - copied ‘...future.elements_ii’ to environment
[17:36:35.316] - copied ‘...future.seeds_ii’ to environment
[17:36:35.316] - copied ‘...future.globals.maxSize’ to environment
[17:36:35.316] assign_globals() ... done
[17:36:35.316] requestCore(): workers = 2
[17:36:35.318] MulticoreFuture started
[17:36:35.318] - Launch lazy future ... done
[17:36:35.319] run() for ‘MulticoreFuture’ ... done
[17:36:35.319] Created future:
[17:36:35.319] plan(): Setting new future strategy stack:
[17:36:35.319] List of future strategies:
[17:36:35.319] 1. sequential:
[17:36:35.319]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:35.319]    - tweaked: FALSE
[17:36:35.319]    - call: NULL
[17:36:35.320] plan(): nbrOfWorkers() = 1
[17:36:35.323] plan(): Setting new future strategy stack:
[17:36:35.323] List of future strategies:
[17:36:35.323] 1. multicore:
[17:36:35.323]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:35.323]    - tweaked: FALSE
[17:36:35.323]    - call: plan(strategy)
[17:36:35.328] plan(): nbrOfWorkers() = 2
[17:36:35.319] MulticoreFuture:
[17:36:35.319] Label: ‘future_apply-1’
[17:36:35.319] Expression:
[17:36:35.319] {
[17:36:35.319]     do.call(function(...) {
[17:36:35.319]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.319]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.319]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.319]             on.exit(options(oopts), add = TRUE)
[17:36:35.319]         }
[17:36:35.319]         {
[17:36:35.319]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.319]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.319]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.319]             })
[17:36:35.319]         }
[17:36:35.319]     }, args = future.call.arguments)
[17:36:35.319] }
[17:36:35.319] Lazy evaluation: FALSE
[17:36:35.319] Asynchronous evaluation: TRUE
[17:36:35.319] Local evaluation: TRUE
[17:36:35.319] Environment: R_GlobalEnv
[17:36:35.319] Capture standard output: TRUE
[17:36:35.319] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:35.319] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:35.319] Packages: <none>
[17:36:35.319] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:35.319] Resolved: TRUE
[17:36:35.319] Value: <not collected>
[17:36:35.319] Conditions captured: <none>
[17:36:35.319] Early signaling: FALSE
[17:36:35.319] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:35.319] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.329] Chunk #1 of 2 ... DONE
[17:36:35.329] Chunk #2 of 2 ...
[17:36:35.330]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:35.330]  - seeds: <none>
[17:36:35.330]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.330] getGlobalsAndPackages() ...
[17:36:35.330] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.331] Resolving globals: FALSE
[17:36:35.331] Tweak future expression to call with '...' arguments ...
[17:36:35.331] {
[17:36:35.331]     do.call(function(...) {
[17:36:35.331]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.331]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.331]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.331]             on.exit(options(oopts), add = TRUE)
[17:36:35.331]         }
[17:36:35.331]         {
[17:36:35.331]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.331]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.331]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.331]             })
[17:36:35.331]         }
[17:36:35.331]     }, args = future.call.arguments)
[17:36:35.331] }
[17:36:35.331] Tweak future expression to call with '...' arguments ... DONE
[17:36:35.332] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.332] 
[17:36:35.332] getGlobalsAndPackages() ... DONE
[17:36:35.333] run() for ‘Future’ ...
[17:36:35.333] - state: ‘created’
[17:36:35.333] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:35.338] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.338] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:35.338]   - Field: ‘label’
[17:36:35.338]   - Field: ‘local’
[17:36:35.338]   - Field: ‘owner’
[17:36:35.338]   - Field: ‘envir’
[17:36:35.339]   - Field: ‘workers’
[17:36:35.339]   - Field: ‘packages’
[17:36:35.339]   - Field: ‘gc’
[17:36:35.339]   - Field: ‘job’
[17:36:35.339]   - Field: ‘conditions’
[17:36:35.339]   - Field: ‘expr’
[17:36:35.340]   - Field: ‘uuid’
[17:36:35.340]   - Field: ‘seed’
[17:36:35.340]   - Field: ‘version’
[17:36:35.340]   - Field: ‘result’
[17:36:35.340]   - Field: ‘asynchronous’
[17:36:35.340]   - Field: ‘calls’
[17:36:35.340]   - Field: ‘globals’
[17:36:35.341]   - Field: ‘stdout’
[17:36:35.341]   - Field: ‘earlySignal’
[17:36:35.341]   - Field: ‘lazy’
[17:36:35.341]   - Field: ‘state’
[17:36:35.341] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:35.341] - Launch lazy future ...
[17:36:35.342] Packages needed by the future expression (n = 0): <none>
[17:36:35.342] Packages needed by future strategies (n = 0): <none>
[17:36:35.343] {
[17:36:35.343]     {
[17:36:35.343]         {
[17:36:35.343]             ...future.startTime <- base::Sys.time()
[17:36:35.343]             {
[17:36:35.343]                 {
[17:36:35.343]                   {
[17:36:35.343]                     {
[17:36:35.343]                       base::local({
[17:36:35.343]                         has_future <- base::requireNamespace("future", 
[17:36:35.343]                           quietly = TRUE)
[17:36:35.343]                         if (has_future) {
[17:36:35.343]                           ns <- base::getNamespace("future")
[17:36:35.343]                           version <- ns[[".package"]][["version"]]
[17:36:35.343]                           if (is.null(version)) 
[17:36:35.343]                             version <- utils::packageVersion("future")
[17:36:35.343]                         }
[17:36:35.343]                         else {
[17:36:35.343]                           version <- NULL
[17:36:35.343]                         }
[17:36:35.343]                         if (!has_future || version < "1.8.0") {
[17:36:35.343]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:35.343]                             "", base::R.version$version.string), 
[17:36:35.343]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:35.343]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:35.343]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:35.343]                               "release", "version")], collapse = " "), 
[17:36:35.343]                             hostname = base::Sys.info()[["nodename"]])
[17:36:35.343]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:35.343]                             info)
[17:36:35.343]                           info <- base::paste(info, collapse = "; ")
[17:36:35.343]                           if (!has_future) {
[17:36:35.343]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:35.343]                               info)
[17:36:35.343]                           }
[17:36:35.343]                           else {
[17:36:35.343]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:35.343]                               info, version)
[17:36:35.343]                           }
[17:36:35.343]                           base::stop(msg)
[17:36:35.343]                         }
[17:36:35.343]                       })
[17:36:35.343]                     }
[17:36:35.343]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:35.343]                     base::options(mc.cores = 1L)
[17:36:35.343]                   }
[17:36:35.343]                   ...future.strategy.old <- future::plan("list")
[17:36:35.343]                   options(future.plan = NULL)
[17:36:35.343]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.343]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:35.343]                 }
[17:36:35.343]                 ...future.workdir <- getwd()
[17:36:35.343]             }
[17:36:35.343]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:35.343]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:35.343]         }
[17:36:35.343]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:35.343]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:35.343]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:35.343]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:35.343]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:35.343]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:35.343]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:35.343]             base::names(...future.oldOptions))
[17:36:35.343]     }
[17:36:35.343]     if (FALSE) {
[17:36:35.343]     }
[17:36:35.343]     else {
[17:36:35.343]         if (TRUE) {
[17:36:35.343]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:35.343]                 open = "w")
[17:36:35.343]         }
[17:36:35.343]         else {
[17:36:35.343]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:35.343]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:35.343]         }
[17:36:35.343]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:35.343]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:35.343]             base::sink(type = "output", split = FALSE)
[17:36:35.343]             base::close(...future.stdout)
[17:36:35.343]         }, add = TRUE)
[17:36:35.343]     }
[17:36:35.343]     ...future.frame <- base::sys.nframe()
[17:36:35.343]     ...future.conditions <- base::list()
[17:36:35.343]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:35.343]     if (FALSE) {
[17:36:35.343]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:35.343]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:35.343]     }
[17:36:35.343]     ...future.result <- base::tryCatch({
[17:36:35.343]         base::withCallingHandlers({
[17:36:35.343]             ...future.value <- base::withVisible(base::local({
[17:36:35.343]                 withCallingHandlers({
[17:36:35.343]                   {
[17:36:35.343]                     do.call(function(...) {
[17:36:35.343]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.343]                       if (!identical(...future.globals.maxSize.org, 
[17:36:35.343]                         ...future.globals.maxSize)) {
[17:36:35.343]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.343]                         on.exit(options(oopts), add = TRUE)
[17:36:35.343]                       }
[17:36:35.343]                       {
[17:36:35.343]                         lapply(seq_along(...future.elements_ii), 
[17:36:35.343]                           FUN = function(jj) {
[17:36:35.343]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.343]                             ...future.FUN(...future.X_jj, ...)
[17:36:35.343]                           })
[17:36:35.343]                       }
[17:36:35.343]                     }, args = future.call.arguments)
[17:36:35.343]                   }
[17:36:35.343]                 }, immediateCondition = function(cond) {
[17:36:35.343]                   save_rds <- function (object, pathname, ...) 
[17:36:35.343]                   {
[17:36:35.343]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:35.343]                     if (file_test("-f", pathname_tmp)) {
[17:36:35.343]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.343]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:35.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.343]                         fi_tmp[["mtime"]])
[17:36:35.343]                     }
[17:36:35.343]                     tryCatch({
[17:36:35.343]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:35.343]                     }, error = function(ex) {
[17:36:35.343]                       msg <- conditionMessage(ex)
[17:36:35.343]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.343]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:35.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.343]                         fi_tmp[["mtime"]], msg)
[17:36:35.343]                       ex$message <- msg
[17:36:35.343]                       stop(ex)
[17:36:35.343]                     })
[17:36:35.343]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:35.343]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:35.343]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:35.343]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.343]                       fi <- file.info(pathname)
[17:36:35.343]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:35.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.343]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:35.343]                         fi[["size"]], fi[["mtime"]])
[17:36:35.343]                       stop(msg)
[17:36:35.343]                     }
[17:36:35.343]                     invisible(pathname)
[17:36:35.343]                   }
[17:36:35.343]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:35.343]                     rootPath = tempdir()) 
[17:36:35.343]                   {
[17:36:35.343]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:35.343]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:35.343]                       tmpdir = path, fileext = ".rds")
[17:36:35.343]                     save_rds(obj, file)
[17:36:35.343]                   }
[17:36:35.343]                   saveImmediateCondition(cond, path = "/tmp/RtmpABg8SG/.future/immediateConditions")
[17:36:35.343]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.343]                   {
[17:36:35.343]                     inherits <- base::inherits
[17:36:35.343]                     invokeRestart <- base::invokeRestart
[17:36:35.343]                     is.null <- base::is.null
[17:36:35.343]                     muffled <- FALSE
[17:36:35.343]                     if (inherits(cond, "message")) {
[17:36:35.343]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:35.343]                       if (muffled) 
[17:36:35.343]                         invokeRestart("muffleMessage")
[17:36:35.343]                     }
[17:36:35.343]                     else if (inherits(cond, "warning")) {
[17:36:35.343]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:35.343]                       if (muffled) 
[17:36:35.343]                         invokeRestart("muffleWarning")
[17:36:35.343]                     }
[17:36:35.343]                     else if (inherits(cond, "condition")) {
[17:36:35.343]                       if (!is.null(pattern)) {
[17:36:35.343]                         computeRestarts <- base::computeRestarts
[17:36:35.343]                         grepl <- base::grepl
[17:36:35.343]                         restarts <- computeRestarts(cond)
[17:36:35.343]                         for (restart in restarts) {
[17:36:35.343]                           name <- restart$name
[17:36:35.343]                           if (is.null(name)) 
[17:36:35.343]                             next
[17:36:35.343]                           if (!grepl(pattern, name)) 
[17:36:35.343]                             next
[17:36:35.343]                           invokeRestart(restart)
[17:36:35.343]                           muffled <- TRUE
[17:36:35.343]                           break
[17:36:35.343]                         }
[17:36:35.343]                       }
[17:36:35.343]                     }
[17:36:35.343]                     invisible(muffled)
[17:36:35.343]                   }
[17:36:35.343]                   muffleCondition(cond)
[17:36:35.343]                 })
[17:36:35.343]             }))
[17:36:35.343]             future::FutureResult(value = ...future.value$value, 
[17:36:35.343]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.343]                   ...future.rng), globalenv = if (FALSE) 
[17:36:35.343]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:35.343]                     ...future.globalenv.names))
[17:36:35.343]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:35.343]         }, condition = base::local({
[17:36:35.343]             c <- base::c
[17:36:35.343]             inherits <- base::inherits
[17:36:35.343]             invokeRestart <- base::invokeRestart
[17:36:35.343]             length <- base::length
[17:36:35.343]             list <- base::list
[17:36:35.343]             seq.int <- base::seq.int
[17:36:35.343]             signalCondition <- base::signalCondition
[17:36:35.343]             sys.calls <- base::sys.calls
[17:36:35.343]             `[[` <- base::`[[`
[17:36:35.343]             `+` <- base::`+`
[17:36:35.343]             `<<-` <- base::`<<-`
[17:36:35.343]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:35.343]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:35.343]                   3L)]
[17:36:35.343]             }
[17:36:35.343]             function(cond) {
[17:36:35.343]                 is_error <- inherits(cond, "error")
[17:36:35.343]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:35.343]                   NULL)
[17:36:35.343]                 if (is_error) {
[17:36:35.343]                   sessionInformation <- function() {
[17:36:35.343]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:35.343]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:35.343]                       search = base::search(), system = base::Sys.info())
[17:36:35.343]                   }
[17:36:35.343]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.343]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:35.343]                     cond$call), session = sessionInformation(), 
[17:36:35.343]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:35.343]                   signalCondition(cond)
[17:36:35.343]                 }
[17:36:35.343]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:35.343]                 "immediateCondition"))) {
[17:36:35.343]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:35.343]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.343]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:35.343]                   if (TRUE && !signal) {
[17:36:35.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.343]                     {
[17:36:35.343]                       inherits <- base::inherits
[17:36:35.343]                       invokeRestart <- base::invokeRestart
[17:36:35.343]                       is.null <- base::is.null
[17:36:35.343]                       muffled <- FALSE
[17:36:35.343]                       if (inherits(cond, "message")) {
[17:36:35.343]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.343]                         if (muffled) 
[17:36:35.343]                           invokeRestart("muffleMessage")
[17:36:35.343]                       }
[17:36:35.343]                       else if (inherits(cond, "warning")) {
[17:36:35.343]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.343]                         if (muffled) 
[17:36:35.343]                           invokeRestart("muffleWarning")
[17:36:35.343]                       }
[17:36:35.343]                       else if (inherits(cond, "condition")) {
[17:36:35.343]                         if (!is.null(pattern)) {
[17:36:35.343]                           computeRestarts <- base::computeRestarts
[17:36:35.343]                           grepl <- base::grepl
[17:36:35.343]                           restarts <- computeRestarts(cond)
[17:36:35.343]                           for (restart in restarts) {
[17:36:35.343]                             name <- restart$name
[17:36:35.343]                             if (is.null(name)) 
[17:36:35.343]                               next
[17:36:35.343]                             if (!grepl(pattern, name)) 
[17:36:35.343]                               next
[17:36:35.343]                             invokeRestart(restart)
[17:36:35.343]                             muffled <- TRUE
[17:36:35.343]                             break
[17:36:35.343]                           }
[17:36:35.343]                         }
[17:36:35.343]                       }
[17:36:35.343]                       invisible(muffled)
[17:36:35.343]                     }
[17:36:35.343]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.343]                   }
[17:36:35.343]                 }
[17:36:35.343]                 else {
[17:36:35.343]                   if (TRUE) {
[17:36:35.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.343]                     {
[17:36:35.343]                       inherits <- base::inherits
[17:36:35.343]                       invokeRestart <- base::invokeRestart
[17:36:35.343]                       is.null <- base::is.null
[17:36:35.343]                       muffled <- FALSE
[17:36:35.343]                       if (inherits(cond, "message")) {
[17:36:35.343]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.343]                         if (muffled) 
[17:36:35.343]                           invokeRestart("muffleMessage")
[17:36:35.343]                       }
[17:36:35.343]                       else if (inherits(cond, "warning")) {
[17:36:35.343]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.343]                         if (muffled) 
[17:36:35.343]                           invokeRestart("muffleWarning")
[17:36:35.343]                       }
[17:36:35.343]                       else if (inherits(cond, "condition")) {
[17:36:35.343]                         if (!is.null(pattern)) {
[17:36:35.343]                           computeRestarts <- base::computeRestarts
[17:36:35.343]                           grepl <- base::grepl
[17:36:35.343]                           restarts <- computeRestarts(cond)
[17:36:35.343]                           for (restart in restarts) {
[17:36:35.343]                             name <- restart$name
[17:36:35.343]                             if (is.null(name)) 
[17:36:35.343]                               next
[17:36:35.343]                             if (!grepl(pattern, name)) 
[17:36:35.343]                               next
[17:36:35.343]                             invokeRestart(restart)
[17:36:35.343]                             muffled <- TRUE
[17:36:35.343]                             break
[17:36:35.343]                           }
[17:36:35.343]                         }
[17:36:35.343]                       }
[17:36:35.343]                       invisible(muffled)
[17:36:35.343]                     }
[17:36:35.343]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.343]                   }
[17:36:35.343]                 }
[17:36:35.343]             }
[17:36:35.343]         }))
[17:36:35.343]     }, error = function(ex) {
[17:36:35.343]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:35.343]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.343]                 ...future.rng), started = ...future.startTime, 
[17:36:35.343]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:35.343]             version = "1.8"), class = "FutureResult")
[17:36:35.343]     }, finally = {
[17:36:35.343]         if (!identical(...future.workdir, getwd())) 
[17:36:35.343]             setwd(...future.workdir)
[17:36:35.343]         {
[17:36:35.343]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:35.343]                 ...future.oldOptions$nwarnings <- NULL
[17:36:35.343]             }
[17:36:35.343]             base::options(...future.oldOptions)
[17:36:35.343]             if (.Platform$OS.type == "windows") {
[17:36:35.343]                 old_names <- names(...future.oldEnvVars)
[17:36:35.343]                 envs <- base::Sys.getenv()
[17:36:35.343]                 names <- names(envs)
[17:36:35.343]                 common <- intersect(names, old_names)
[17:36:35.343]                 added <- setdiff(names, old_names)
[17:36:35.343]                 removed <- setdiff(old_names, names)
[17:36:35.343]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:35.343]                   envs[common]]
[17:36:35.343]                 NAMES <- toupper(changed)
[17:36:35.343]                 args <- list()
[17:36:35.343]                 for (kk in seq_along(NAMES)) {
[17:36:35.343]                   name <- changed[[kk]]
[17:36:35.343]                   NAME <- NAMES[[kk]]
[17:36:35.343]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.343]                     next
[17:36:35.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.343]                 }
[17:36:35.343]                 NAMES <- toupper(added)
[17:36:35.343]                 for (kk in seq_along(NAMES)) {
[17:36:35.343]                   name <- added[[kk]]
[17:36:35.343]                   NAME <- NAMES[[kk]]
[17:36:35.343]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.343]                     next
[17:36:35.343]                   args[[name]] <- ""
[17:36:35.343]                 }
[17:36:35.343]                 NAMES <- toupper(removed)
[17:36:35.343]                 for (kk in seq_along(NAMES)) {
[17:36:35.343]                   name <- removed[[kk]]
[17:36:35.343]                   NAME <- NAMES[[kk]]
[17:36:35.343]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.343]                     next
[17:36:35.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.343]                 }
[17:36:35.343]                 if (length(args) > 0) 
[17:36:35.343]                   base::do.call(base::Sys.setenv, args = args)
[17:36:35.343]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:35.343]             }
[17:36:35.343]             else {
[17:36:35.343]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:35.343]             }
[17:36:35.343]             {
[17:36:35.343]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:35.343]                   0L) {
[17:36:35.343]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:35.343]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:35.343]                   base::options(opts)
[17:36:35.343]                 }
[17:36:35.343]                 {
[17:36:35.343]                   {
[17:36:35.343]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:35.343]                     NULL
[17:36:35.343]                   }
[17:36:35.343]                   options(future.plan = NULL)
[17:36:35.343]                   if (is.na(NA_character_)) 
[17:36:35.343]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.343]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:35.343]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:35.343]                     .init = FALSE)
[17:36:35.343]                 }
[17:36:35.343]             }
[17:36:35.343]         }
[17:36:35.343]     })
[17:36:35.343]     if (TRUE) {
[17:36:35.343]         base::sink(type = "output", split = FALSE)
[17:36:35.343]         if (TRUE) {
[17:36:35.343]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:35.343]         }
[17:36:35.343]         else {
[17:36:35.343]             ...future.result["stdout"] <- base::list(NULL)
[17:36:35.343]         }
[17:36:35.343]         base::close(...future.stdout)
[17:36:35.343]         ...future.stdout <- NULL
[17:36:35.343]     }
[17:36:35.343]     ...future.result$conditions <- ...future.conditions
[17:36:35.343]     ...future.result$finished <- base::Sys.time()
[17:36:35.343]     ...future.result
[17:36:35.343] }
[17:36:35.346] assign_globals() ...
[17:36:35.346] List of 5
[17:36:35.346]  $ future.call.arguments    : list()
[17:36:35.346]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.346]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:36:35.346]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:36:35.346]  $ ...future.elements_ii    :List of 1
[17:36:35.346]   ..$ : num [1:4] 2 4 6 8
[17:36:35.346]  $ ...future.seeds_ii       : NULL
[17:36:35.346]  $ ...future.globals.maxSize: num Inf
[17:36:35.346]  - attr(*, "resolved")= logi FALSE
[17:36:35.346]  - attr(*, "total_size")= num NA
[17:36:35.346]  - attr(*, "where")=List of 5
[17:36:35.346]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:35.346]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:35.346]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:35.346]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:35.346]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:35.346]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.346]  - attr(*, "already-done")= logi TRUE
[17:36:35.356] - copied ‘future.call.arguments’ to environment
[17:36:35.356] - copied ‘...future.FUN’ to environment
[17:36:35.357] - copied ‘...future.elements_ii’ to environment
[17:36:35.357] - copied ‘...future.seeds_ii’ to environment
[17:36:35.357] - copied ‘...future.globals.maxSize’ to environment
[17:36:35.357] assign_globals() ... done
[17:36:35.358] requestCore(): workers = 2
[17:36:35.361] MulticoreFuture started
[17:36:35.361] - Launch lazy future ... done
[17:36:35.362] run() for ‘MulticoreFuture’ ... done
[17:36:35.362] plan(): Setting new future strategy stack:
[17:36:35.362] Created future:
[17:36:35.362] List of future strategies:
[17:36:35.362] 1. sequential:
[17:36:35.362]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:35.362]    - tweaked: FALSE
[17:36:35.362]    - call: NULL
[17:36:35.363] plan(): nbrOfWorkers() = 1
[17:36:35.366] plan(): Setting new future strategy stack:
[17:36:35.366] List of future strategies:
[17:36:35.366] 1. multicore:
[17:36:35.366]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:35.366]    - tweaked: FALSE
[17:36:35.366]    - call: plan(strategy)
[17:36:35.372] plan(): nbrOfWorkers() = 2
[17:36:35.362] MulticoreFuture:
[17:36:35.362] Label: ‘future_apply-2’
[17:36:35.362] Expression:
[17:36:35.362] {
[17:36:35.362]     do.call(function(...) {
[17:36:35.362]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.362]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.362]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.362]             on.exit(options(oopts), add = TRUE)
[17:36:35.362]         }
[17:36:35.362]         {
[17:36:35.362]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.362]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.362]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.362]             })
[17:36:35.362]         }
[17:36:35.362]     }, args = future.call.arguments)
[17:36:35.362] }
[17:36:35.362] Lazy evaluation: FALSE
[17:36:35.362] Asynchronous evaluation: TRUE
[17:36:35.362] Local evaluation: TRUE
[17:36:35.362] Environment: R_GlobalEnv
[17:36:35.362] Capture standard output: TRUE
[17:36:35.362] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:35.362] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:35.362] Packages: <none>
[17:36:35.362] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:35.362] Resolved: TRUE
[17:36:35.362] Value: <not collected>
[17:36:35.362] Conditions captured: <none>
[17:36:35.362] Early signaling: FALSE
[17:36:35.362] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:35.362] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.373] Chunk #2 of 2 ... DONE
[17:36:35.373] Launching 2 futures (chunks) ... DONE
[17:36:35.373] Resolving 2 futures (chunks) ...
[17:36:35.374] resolve() on list ...
[17:36:35.374]  recursive: 0
[17:36:35.374]  length: 2
[17:36:35.374] 
[17:36:35.375] Future #1
[17:36:35.375] result() for MulticoreFuture ...
[17:36:35.376] result() for MulticoreFuture ...
[17:36:35.376] result() for MulticoreFuture ... done
[17:36:35.376] result() for MulticoreFuture ... done
[17:36:35.376] result() for MulticoreFuture ...
[17:36:35.377] result() for MulticoreFuture ... done
[17:36:35.377] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:36:35.377] - nx: 2
[17:36:35.377] - relay: TRUE
[17:36:35.377] - stdout: TRUE
[17:36:35.377] - signal: TRUE
[17:36:35.378] - resignal: FALSE
[17:36:35.378] - force: TRUE
[17:36:35.378] - relayed: [n=2] FALSE, FALSE
[17:36:35.378] - queued futures: [n=2] FALSE, FALSE
[17:36:35.378]  - until=1
[17:36:35.378]  - relaying element #1
[17:36:35.378] result() for MulticoreFuture ...
[17:36:35.379] result() for MulticoreFuture ... done
[17:36:35.379] result() for MulticoreFuture ...
[17:36:35.379] result() for MulticoreFuture ... done
[17:36:35.379] result() for MulticoreFuture ...
[17:36:35.379] result() for MulticoreFuture ... done
[17:36:35.379] result() for MulticoreFuture ...
[17:36:35.380] result() for MulticoreFuture ... done
[17:36:35.380] - relayed: [n=2] TRUE, FALSE
[17:36:35.380] - queued futures: [n=2] TRUE, FALSE
[17:36:35.380] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:36:35.380]  length: 1 (resolved future 1)
[17:36:35.380] Future #2
[17:36:35.381] result() for MulticoreFuture ...
[17:36:35.381] result() for MulticoreFuture ...
[17:36:35.381] result() for MulticoreFuture ... done
[17:36:35.382] result() for MulticoreFuture ... done
[17:36:35.382] result() for MulticoreFuture ...
[17:36:35.382] result() for MulticoreFuture ... done
[17:36:35.382] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:36:35.382] - nx: 2
[17:36:35.382] - relay: TRUE
[17:36:35.382] - stdout: TRUE
[17:36:35.382] - signal: TRUE
[17:36:35.382] - resignal: FALSE
[17:36:35.383] - force: TRUE
[17:36:35.383] - relayed: [n=2] TRUE, FALSE
[17:36:35.383] - queued futures: [n=2] TRUE, FALSE
[17:36:35.383]  - until=2
[17:36:35.383]  - relaying element #2
[17:36:35.383] result() for MulticoreFuture ...
[17:36:35.383] result() for MulticoreFuture ... done
[17:36:35.383] result() for MulticoreFuture ...
[17:36:35.384] result() for MulticoreFuture ... done
[17:36:35.384] result() for MulticoreFuture ...
[17:36:35.384] result() for MulticoreFuture ... done
[17:36:35.384] result() for MulticoreFuture ...
[17:36:35.384] result() for MulticoreFuture ... done
[17:36:35.384] - relayed: [n=2] TRUE, TRUE
[17:36:35.384] - queued futures: [n=2] TRUE, TRUE
[17:36:35.384] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:36:35.384]  length: 0 (resolved future 2)
[17:36:35.385] Relaying remaining futures
[17:36:35.385] signalConditionsASAP(NULL, pos=0) ...
[17:36:35.385] - nx: 2
[17:36:35.385] - relay: TRUE
[17:36:35.385] - stdout: TRUE
[17:36:35.385] - signal: TRUE
[17:36:35.385] - resignal: FALSE
[17:36:35.385] - force: TRUE
[17:36:35.385] - relayed: [n=2] TRUE, TRUE
[17:36:35.386] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:35.386] - relayed: [n=2] TRUE, TRUE
[17:36:35.386] - queued futures: [n=2] TRUE, TRUE
[17:36:35.386] signalConditionsASAP(NULL, pos=0) ... done
[17:36:35.386] resolve() on list ... DONE
[17:36:35.386] result() for MulticoreFuture ...
[17:36:35.386] result() for MulticoreFuture ... done
[17:36:35.386] result() for MulticoreFuture ...
[17:36:35.387] result() for MulticoreFuture ... done
[17:36:35.387] result() for MulticoreFuture ...
[17:36:35.387] result() for MulticoreFuture ... done
[17:36:35.387] result() for MulticoreFuture ...
[17:36:35.387] result() for MulticoreFuture ... done
[17:36:35.387]  - Number of value chunks collected: 2
[17:36:35.387] Resolving 2 futures (chunks) ... DONE
[17:36:35.387] Reducing values from 2 chunks ...
[17:36:35.387]  - Number of values collected after concatenation: 2
[17:36:35.388]  - Number of values expected: 2
[17:36:35.388] Reducing values from 2 chunks ... DONE
[17:36:35.388] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:36:35.389] getGlobalsAndPackagesXApply() ...
[17:36:35.389]  - future.globals: TRUE
[17:36:35.389] getGlobalsAndPackages() ...
[17:36:35.389] Searching for globals...
[17:36:35.391] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:35.391] Searching for globals ... DONE
[17:36:35.391] Resolving globals: FALSE
[17:36:35.391] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:36:35.392] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:36:35.392] - globals: [1] ‘FUN’
[17:36:35.392] - packages: [1] ‘stats’
[17:36:35.392] getGlobalsAndPackages() ... DONE
[17:36:35.392]  - globals found/used: [n=1] ‘FUN’
[17:36:35.393]  - needed namespaces: [n=1] ‘stats’
[17:36:35.393] Finding globals ... DONE
[17:36:35.393]  - use_args: TRUE
[17:36:35.393]  - Getting '...' globals ...
[17:36:35.393] resolve() on list ...
[17:36:35.393]  recursive: 0
[17:36:35.393]  length: 1
[17:36:35.394]  elements: ‘...’
[17:36:35.394]  length: 0 (resolved future 1)
[17:36:35.394] resolve() on list ... DONE
[17:36:35.394]    - '...' content: [n=0] 
[17:36:35.394] List of 1
[17:36:35.394]  $ ...: list()
[17:36:35.394]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.394]  - attr(*, "where")=List of 1
[17:36:35.394]   ..$ ...:<environment: 0x556d75984db8> 
[17:36:35.394]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.394]  - attr(*, "resolved")= logi TRUE
[17:36:35.394]  - attr(*, "total_size")= num NA
[17:36:35.397]  - Getting '...' globals ... DONE
[17:36:35.397] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:35.397] List of 2
[17:36:35.397]  $ ...future.FUN:function (x, ...)  
[17:36:35.397]  $ ...          : list()
[17:36:35.397]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.397]  - attr(*, "where")=List of 2
[17:36:35.397]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:35.397]   ..$ ...          :<environment: 0x556d75984db8> 
[17:36:35.397]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.397]  - attr(*, "resolved")= logi FALSE
[17:36:35.397]  - attr(*, "total_size")= num 1248
[17:36:35.402] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:35.403] getGlobalsAndPackagesXApply() ... DONE
[17:36:35.407] future_lapply() ...
[17:36:35.410] Number of chunks: 2
[17:36:35.410] getGlobalsAndPackagesXApply() ...
[17:36:35.411]  - future.globals: <name-value list> with names ‘list()’
[17:36:35.411]  - use_args: TRUE
[17:36:35.411] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:35.411] List of 2
[17:36:35.411]  $ ...          : list()
[17:36:35.411]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.411]  $ ...future.FUN:function (x, ...)  
[17:36:35.411]  - attr(*, "where")=List of 2
[17:36:35.411]   ..$ ...          :<environment: 0x556d75984db8> 
[17:36:35.411]   ..$ ...future.FUN:<environment: namespace:stats> 
[17:36:35.411]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.411]  - attr(*, "resolved")= logi FALSE
[17:36:35.411]  - attr(*, "total_size")= num NA
[17:36:35.414] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:35.414] getGlobalsAndPackagesXApply() ... DONE
[17:36:35.414] Number of futures (= number of chunks): 2
[17:36:35.414] Launching 2 futures (chunks) ...
[17:36:35.414] Chunk #1 of 2 ...
[17:36:35.414]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:35.415]  - seeds: <none>
[17:36:35.415]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.415] getGlobalsAndPackages() ...
[17:36:35.415] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.415] Resolving globals: FALSE
[17:36:35.415] Tweak future expression to call with '...' arguments ...
[17:36:35.415] {
[17:36:35.415]     do.call(function(...) {
[17:36:35.415]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.415]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.415]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.415]             on.exit(options(oopts), add = TRUE)
[17:36:35.415]         }
[17:36:35.415]         {
[17:36:35.415]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.415]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.415]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.415]             })
[17:36:35.415]         }
[17:36:35.415]     }, args = future.call.arguments)
[17:36:35.415] }
[17:36:35.416] Tweak future expression to call with '...' arguments ... DONE
[17:36:35.416] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.416] - packages: [1] ‘stats’
[17:36:35.416] getGlobalsAndPackages() ... DONE
[17:36:35.417] run() for ‘Future’ ...
[17:36:35.417] - state: ‘created’
[17:36:35.417] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:35.420] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.420] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:35.421]   - Field: ‘label’
[17:36:35.421]   - Field: ‘local’
[17:36:35.421]   - Field: ‘owner’
[17:36:35.421]   - Field: ‘envir’
[17:36:35.421]   - Field: ‘workers’
[17:36:35.421]   - Field: ‘packages’
[17:36:35.421]   - Field: ‘gc’
[17:36:35.421]   - Field: ‘job’
[17:36:35.421]   - Field: ‘conditions’
[17:36:35.421]   - Field: ‘expr’
[17:36:35.422]   - Field: ‘uuid’
[17:36:35.422]   - Field: ‘seed’
[17:36:35.422]   - Field: ‘version’
[17:36:35.422]   - Field: ‘result’
[17:36:35.422]   - Field: ‘asynchronous’
[17:36:35.422]   - Field: ‘calls’
[17:36:35.422]   - Field: ‘globals’
[17:36:35.422]   - Field: ‘stdout’
[17:36:35.422]   - Field: ‘earlySignal’
[17:36:35.422]   - Field: ‘lazy’
[17:36:35.422]   - Field: ‘state’
[17:36:35.423] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:35.423] - Launch lazy future ...
[17:36:35.423] Packages needed by the future expression (n = 1): ‘stats’
[17:36:35.423] Packages needed by future strategies (n = 0): <none>
[17:36:35.424] {
[17:36:35.424]     {
[17:36:35.424]         {
[17:36:35.424]             ...future.startTime <- base::Sys.time()
[17:36:35.424]             {
[17:36:35.424]                 {
[17:36:35.424]                   {
[17:36:35.424]                     {
[17:36:35.424]                       {
[17:36:35.424]                         base::local({
[17:36:35.424]                           has_future <- base::requireNamespace("future", 
[17:36:35.424]                             quietly = TRUE)
[17:36:35.424]                           if (has_future) {
[17:36:35.424]                             ns <- base::getNamespace("future")
[17:36:35.424]                             version <- ns[[".package"]][["version"]]
[17:36:35.424]                             if (is.null(version)) 
[17:36:35.424]                               version <- utils::packageVersion("future")
[17:36:35.424]                           }
[17:36:35.424]                           else {
[17:36:35.424]                             version <- NULL
[17:36:35.424]                           }
[17:36:35.424]                           if (!has_future || version < "1.8.0") {
[17:36:35.424]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:35.424]                               "", base::R.version$version.string), 
[17:36:35.424]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:35.424]                                 base::R.version$platform, 8 * 
[17:36:35.424]                                   base::.Machine$sizeof.pointer), 
[17:36:35.424]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:35.424]                                 "release", "version")], collapse = " "), 
[17:36:35.424]                               hostname = base::Sys.info()[["nodename"]])
[17:36:35.424]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:35.424]                               info)
[17:36:35.424]                             info <- base::paste(info, collapse = "; ")
[17:36:35.424]                             if (!has_future) {
[17:36:35.424]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:35.424]                                 info)
[17:36:35.424]                             }
[17:36:35.424]                             else {
[17:36:35.424]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:35.424]                                 info, version)
[17:36:35.424]                             }
[17:36:35.424]                             base::stop(msg)
[17:36:35.424]                           }
[17:36:35.424]                         })
[17:36:35.424]                       }
[17:36:35.424]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:35.424]                       base::options(mc.cores = 1L)
[17:36:35.424]                     }
[17:36:35.424]                     base::local({
[17:36:35.424]                       for (pkg in "stats") {
[17:36:35.424]                         base::loadNamespace(pkg)
[17:36:35.424]                         base::library(pkg, character.only = TRUE)
[17:36:35.424]                       }
[17:36:35.424]                     })
[17:36:35.424]                   }
[17:36:35.424]                   ...future.strategy.old <- future::plan("list")
[17:36:35.424]                   options(future.plan = NULL)
[17:36:35.424]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.424]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:35.424]                 }
[17:36:35.424]                 ...future.workdir <- getwd()
[17:36:35.424]             }
[17:36:35.424]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:35.424]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:35.424]         }
[17:36:35.424]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:35.424]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:35.424]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:35.424]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:35.424]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:35.424]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:35.424]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:35.424]             base::names(...future.oldOptions))
[17:36:35.424]     }
[17:36:35.424]     if (FALSE) {
[17:36:35.424]     }
[17:36:35.424]     else {
[17:36:35.424]         if (TRUE) {
[17:36:35.424]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:35.424]                 open = "w")
[17:36:35.424]         }
[17:36:35.424]         else {
[17:36:35.424]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:35.424]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:35.424]         }
[17:36:35.424]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:35.424]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:35.424]             base::sink(type = "output", split = FALSE)
[17:36:35.424]             base::close(...future.stdout)
[17:36:35.424]         }, add = TRUE)
[17:36:35.424]     }
[17:36:35.424]     ...future.frame <- base::sys.nframe()
[17:36:35.424]     ...future.conditions <- base::list()
[17:36:35.424]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:35.424]     if (FALSE) {
[17:36:35.424]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:35.424]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:35.424]     }
[17:36:35.424]     ...future.result <- base::tryCatch({
[17:36:35.424]         base::withCallingHandlers({
[17:36:35.424]             ...future.value <- base::withVisible(base::local({
[17:36:35.424]                 withCallingHandlers({
[17:36:35.424]                   {
[17:36:35.424]                     do.call(function(...) {
[17:36:35.424]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.424]                       if (!identical(...future.globals.maxSize.org, 
[17:36:35.424]                         ...future.globals.maxSize)) {
[17:36:35.424]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.424]                         on.exit(options(oopts), add = TRUE)
[17:36:35.424]                       }
[17:36:35.424]                       {
[17:36:35.424]                         lapply(seq_along(...future.elements_ii), 
[17:36:35.424]                           FUN = function(jj) {
[17:36:35.424]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.424]                             ...future.FUN(...future.X_jj, ...)
[17:36:35.424]                           })
[17:36:35.424]                       }
[17:36:35.424]                     }, args = future.call.arguments)
[17:36:35.424]                   }
[17:36:35.424]                 }, immediateCondition = function(cond) {
[17:36:35.424]                   save_rds <- function (object, pathname, ...) 
[17:36:35.424]                   {
[17:36:35.424]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:35.424]                     if (file_test("-f", pathname_tmp)) {
[17:36:35.424]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.424]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:35.424]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.424]                         fi_tmp[["mtime"]])
[17:36:35.424]                     }
[17:36:35.424]                     tryCatch({
[17:36:35.424]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:35.424]                     }, error = function(ex) {
[17:36:35.424]                       msg <- conditionMessage(ex)
[17:36:35.424]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.424]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:35.424]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.424]                         fi_tmp[["mtime"]], msg)
[17:36:35.424]                       ex$message <- msg
[17:36:35.424]                       stop(ex)
[17:36:35.424]                     })
[17:36:35.424]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:35.424]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:35.424]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:35.424]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.424]                       fi <- file.info(pathname)
[17:36:35.424]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:35.424]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.424]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:35.424]                         fi[["size"]], fi[["mtime"]])
[17:36:35.424]                       stop(msg)
[17:36:35.424]                     }
[17:36:35.424]                     invisible(pathname)
[17:36:35.424]                   }
[17:36:35.424]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:35.424]                     rootPath = tempdir()) 
[17:36:35.424]                   {
[17:36:35.424]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:35.424]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:35.424]                       tmpdir = path, fileext = ".rds")
[17:36:35.424]                     save_rds(obj, file)
[17:36:35.424]                   }
[17:36:35.424]                   saveImmediateCondition(cond, path = "/tmp/RtmpABg8SG/.future/immediateConditions")
[17:36:35.424]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.424]                   {
[17:36:35.424]                     inherits <- base::inherits
[17:36:35.424]                     invokeRestart <- base::invokeRestart
[17:36:35.424]                     is.null <- base::is.null
[17:36:35.424]                     muffled <- FALSE
[17:36:35.424]                     if (inherits(cond, "message")) {
[17:36:35.424]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:35.424]                       if (muffled) 
[17:36:35.424]                         invokeRestart("muffleMessage")
[17:36:35.424]                     }
[17:36:35.424]                     else if (inherits(cond, "warning")) {
[17:36:35.424]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:35.424]                       if (muffled) 
[17:36:35.424]                         invokeRestart("muffleWarning")
[17:36:35.424]                     }
[17:36:35.424]                     else if (inherits(cond, "condition")) {
[17:36:35.424]                       if (!is.null(pattern)) {
[17:36:35.424]                         computeRestarts <- base::computeRestarts
[17:36:35.424]                         grepl <- base::grepl
[17:36:35.424]                         restarts <- computeRestarts(cond)
[17:36:35.424]                         for (restart in restarts) {
[17:36:35.424]                           name <- restart$name
[17:36:35.424]                           if (is.null(name)) 
[17:36:35.424]                             next
[17:36:35.424]                           if (!grepl(pattern, name)) 
[17:36:35.424]                             next
[17:36:35.424]                           invokeRestart(restart)
[17:36:35.424]                           muffled <- TRUE
[17:36:35.424]                           break
[17:36:35.424]                         }
[17:36:35.424]                       }
[17:36:35.424]                     }
[17:36:35.424]                     invisible(muffled)
[17:36:35.424]                   }
[17:36:35.424]                   muffleCondition(cond)
[17:36:35.424]                 })
[17:36:35.424]             }))
[17:36:35.424]             future::FutureResult(value = ...future.value$value, 
[17:36:35.424]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.424]                   ...future.rng), globalenv = if (FALSE) 
[17:36:35.424]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:35.424]                     ...future.globalenv.names))
[17:36:35.424]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:35.424]         }, condition = base::local({
[17:36:35.424]             c <- base::c
[17:36:35.424]             inherits <- base::inherits
[17:36:35.424]             invokeRestart <- base::invokeRestart
[17:36:35.424]             length <- base::length
[17:36:35.424]             list <- base::list
[17:36:35.424]             seq.int <- base::seq.int
[17:36:35.424]             signalCondition <- base::signalCondition
[17:36:35.424]             sys.calls <- base::sys.calls
[17:36:35.424]             `[[` <- base::`[[`
[17:36:35.424]             `+` <- base::`+`
[17:36:35.424]             `<<-` <- base::`<<-`
[17:36:35.424]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:35.424]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:35.424]                   3L)]
[17:36:35.424]             }
[17:36:35.424]             function(cond) {
[17:36:35.424]                 is_error <- inherits(cond, "error")
[17:36:35.424]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:35.424]                   NULL)
[17:36:35.424]                 if (is_error) {
[17:36:35.424]                   sessionInformation <- function() {
[17:36:35.424]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:35.424]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:35.424]                       search = base::search(), system = base::Sys.info())
[17:36:35.424]                   }
[17:36:35.424]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.424]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:35.424]                     cond$call), session = sessionInformation(), 
[17:36:35.424]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:35.424]                   signalCondition(cond)
[17:36:35.424]                 }
[17:36:35.424]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:35.424]                 "immediateCondition"))) {
[17:36:35.424]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:35.424]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.424]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:35.424]                   if (TRUE && !signal) {
[17:36:35.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.424]                     {
[17:36:35.424]                       inherits <- base::inherits
[17:36:35.424]                       invokeRestart <- base::invokeRestart
[17:36:35.424]                       is.null <- base::is.null
[17:36:35.424]                       muffled <- FALSE
[17:36:35.424]                       if (inherits(cond, "message")) {
[17:36:35.424]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.424]                         if (muffled) 
[17:36:35.424]                           invokeRestart("muffleMessage")
[17:36:35.424]                       }
[17:36:35.424]                       else if (inherits(cond, "warning")) {
[17:36:35.424]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.424]                         if (muffled) 
[17:36:35.424]                           invokeRestart("muffleWarning")
[17:36:35.424]                       }
[17:36:35.424]                       else if (inherits(cond, "condition")) {
[17:36:35.424]                         if (!is.null(pattern)) {
[17:36:35.424]                           computeRestarts <- base::computeRestarts
[17:36:35.424]                           grepl <- base::grepl
[17:36:35.424]                           restarts <- computeRestarts(cond)
[17:36:35.424]                           for (restart in restarts) {
[17:36:35.424]                             name <- restart$name
[17:36:35.424]                             if (is.null(name)) 
[17:36:35.424]                               next
[17:36:35.424]                             if (!grepl(pattern, name)) 
[17:36:35.424]                               next
[17:36:35.424]                             invokeRestart(restart)
[17:36:35.424]                             muffled <- TRUE
[17:36:35.424]                             break
[17:36:35.424]                           }
[17:36:35.424]                         }
[17:36:35.424]                       }
[17:36:35.424]                       invisible(muffled)
[17:36:35.424]                     }
[17:36:35.424]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.424]                   }
[17:36:35.424]                 }
[17:36:35.424]                 else {
[17:36:35.424]                   if (TRUE) {
[17:36:35.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.424]                     {
[17:36:35.424]                       inherits <- base::inherits
[17:36:35.424]                       invokeRestart <- base::invokeRestart
[17:36:35.424]                       is.null <- base::is.null
[17:36:35.424]                       muffled <- FALSE
[17:36:35.424]                       if (inherits(cond, "message")) {
[17:36:35.424]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.424]                         if (muffled) 
[17:36:35.424]                           invokeRestart("muffleMessage")
[17:36:35.424]                       }
[17:36:35.424]                       else if (inherits(cond, "warning")) {
[17:36:35.424]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.424]                         if (muffled) 
[17:36:35.424]                           invokeRestart("muffleWarning")
[17:36:35.424]                       }
[17:36:35.424]                       else if (inherits(cond, "condition")) {
[17:36:35.424]                         if (!is.null(pattern)) {
[17:36:35.424]                           computeRestarts <- base::computeRestarts
[17:36:35.424]                           grepl <- base::grepl
[17:36:35.424]                           restarts <- computeRestarts(cond)
[17:36:35.424]                           for (restart in restarts) {
[17:36:35.424]                             name <- restart$name
[17:36:35.424]                             if (is.null(name)) 
[17:36:35.424]                               next
[17:36:35.424]                             if (!grepl(pattern, name)) 
[17:36:35.424]                               next
[17:36:35.424]                             invokeRestart(restart)
[17:36:35.424]                             muffled <- TRUE
[17:36:35.424]                             break
[17:36:35.424]                           }
[17:36:35.424]                         }
[17:36:35.424]                       }
[17:36:35.424]                       invisible(muffled)
[17:36:35.424]                     }
[17:36:35.424]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.424]                   }
[17:36:35.424]                 }
[17:36:35.424]             }
[17:36:35.424]         }))
[17:36:35.424]     }, error = function(ex) {
[17:36:35.424]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:35.424]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.424]                 ...future.rng), started = ...future.startTime, 
[17:36:35.424]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:35.424]             version = "1.8"), class = "FutureResult")
[17:36:35.424]     }, finally = {
[17:36:35.424]         if (!identical(...future.workdir, getwd())) 
[17:36:35.424]             setwd(...future.workdir)
[17:36:35.424]         {
[17:36:35.424]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:35.424]                 ...future.oldOptions$nwarnings <- NULL
[17:36:35.424]             }
[17:36:35.424]             base::options(...future.oldOptions)
[17:36:35.424]             if (.Platform$OS.type == "windows") {
[17:36:35.424]                 old_names <- names(...future.oldEnvVars)
[17:36:35.424]                 envs <- base::Sys.getenv()
[17:36:35.424]                 names <- names(envs)
[17:36:35.424]                 common <- intersect(names, old_names)
[17:36:35.424]                 added <- setdiff(names, old_names)
[17:36:35.424]                 removed <- setdiff(old_names, names)
[17:36:35.424]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:35.424]                   envs[common]]
[17:36:35.424]                 NAMES <- toupper(changed)
[17:36:35.424]                 args <- list()
[17:36:35.424]                 for (kk in seq_along(NAMES)) {
[17:36:35.424]                   name <- changed[[kk]]
[17:36:35.424]                   NAME <- NAMES[[kk]]
[17:36:35.424]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.424]                     next
[17:36:35.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.424]                 }
[17:36:35.424]                 NAMES <- toupper(added)
[17:36:35.424]                 for (kk in seq_along(NAMES)) {
[17:36:35.424]                   name <- added[[kk]]
[17:36:35.424]                   NAME <- NAMES[[kk]]
[17:36:35.424]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.424]                     next
[17:36:35.424]                   args[[name]] <- ""
[17:36:35.424]                 }
[17:36:35.424]                 NAMES <- toupper(removed)
[17:36:35.424]                 for (kk in seq_along(NAMES)) {
[17:36:35.424]                   name <- removed[[kk]]
[17:36:35.424]                   NAME <- NAMES[[kk]]
[17:36:35.424]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.424]                     next
[17:36:35.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.424]                 }
[17:36:35.424]                 if (length(args) > 0) 
[17:36:35.424]                   base::do.call(base::Sys.setenv, args = args)
[17:36:35.424]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:35.424]             }
[17:36:35.424]             else {
[17:36:35.424]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:35.424]             }
[17:36:35.424]             {
[17:36:35.424]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:35.424]                   0L) {
[17:36:35.424]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:35.424]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:35.424]                   base::options(opts)
[17:36:35.424]                 }
[17:36:35.424]                 {
[17:36:35.424]                   {
[17:36:35.424]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:35.424]                     NULL
[17:36:35.424]                   }
[17:36:35.424]                   options(future.plan = NULL)
[17:36:35.424]                   if (is.na(NA_character_)) 
[17:36:35.424]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.424]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:35.424]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:35.424]                     .init = FALSE)
[17:36:35.424]                 }
[17:36:35.424]             }
[17:36:35.424]         }
[17:36:35.424]     })
[17:36:35.424]     if (TRUE) {
[17:36:35.424]         base::sink(type = "output", split = FALSE)
[17:36:35.424]         if (TRUE) {
[17:36:35.424]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:35.424]         }
[17:36:35.424]         else {
[17:36:35.424]             ...future.result["stdout"] <- base::list(NULL)
[17:36:35.424]         }
[17:36:35.424]         base::close(...future.stdout)
[17:36:35.424]         ...future.stdout <- NULL
[17:36:35.424]     }
[17:36:35.424]     ...future.result$conditions <- ...future.conditions
[17:36:35.424]     ...future.result$finished <- base::Sys.time()
[17:36:35.424]     ...future.result
[17:36:35.424] }
[17:36:35.426] assign_globals() ...
[17:36:35.426] List of 5
[17:36:35.426]  $ future.call.arguments    : list()
[17:36:35.426]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.426]  $ ...future.FUN            :function (x, ...)  
[17:36:35.426]  $ ...future.elements_ii    :List of 1
[17:36:35.426]   ..$ : num [1:4] 1 3 1 7
[17:36:35.426]  $ ...future.seeds_ii       : NULL
[17:36:35.426]  $ ...future.globals.maxSize: num Inf
[17:36:35.426]  - attr(*, "resolved")= logi FALSE
[17:36:35.426]  - attr(*, "total_size")= num NA
[17:36:35.426]  - attr(*, "where")=List of 5
[17:36:35.426]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:35.426]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:35.426]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:35.426]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:35.426]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:35.426]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.426]  - attr(*, "already-done")= logi TRUE
[17:36:35.431] - copied ‘future.call.arguments’ to environment
[17:36:35.431] - copied ‘...future.FUN’ to environment
[17:36:35.431] - copied ‘...future.elements_ii’ to environment
[17:36:35.431] - copied ‘...future.seeds_ii’ to environment
[17:36:35.433] - copied ‘...future.globals.maxSize’ to environment
[17:36:35.433] assign_globals() ... done
[17:36:35.433] requestCore(): workers = 2
[17:36:35.436] MulticoreFuture started
[17:36:35.437] - Launch lazy future ... done
[17:36:35.437] run() for ‘MulticoreFuture’ ... done
[17:36:35.438] Created future:
[17:36:35.438] plan(): Setting new future strategy stack:
[17:36:35.438] List of future strategies:
[17:36:35.438] 1. sequential:
[17:36:35.438]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:35.438]    - tweaked: FALSE
[17:36:35.438]    - call: NULL
[17:36:35.440] plan(): nbrOfWorkers() = 1
[17:36:35.443] plan(): Setting new future strategy stack:
[17:36:35.443] List of future strategies:
[17:36:35.443] 1. multicore:
[17:36:35.443]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:35.443]    - tweaked: FALSE
[17:36:35.443]    - call: plan(strategy)
[17:36:35.449] plan(): nbrOfWorkers() = 2
[17:36:35.438] MulticoreFuture:
[17:36:35.438] Label: ‘future_apply-1’
[17:36:35.438] Expression:
[17:36:35.438] {
[17:36:35.438]     do.call(function(...) {
[17:36:35.438]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.438]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.438]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.438]             on.exit(options(oopts), add = TRUE)
[17:36:35.438]         }
[17:36:35.438]         {
[17:36:35.438]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.438]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.438]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.438]             })
[17:36:35.438]         }
[17:36:35.438]     }, args = future.call.arguments)
[17:36:35.438] }
[17:36:35.438] Lazy evaluation: FALSE
[17:36:35.438] Asynchronous evaluation: TRUE
[17:36:35.438] Local evaluation: TRUE
[17:36:35.438] Environment: R_GlobalEnv
[17:36:35.438] Capture standard output: TRUE
[17:36:35.438] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:35.438] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:35.438] Packages: 1 packages (‘stats’)
[17:36:35.438] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:35.438] Resolved: TRUE
[17:36:35.438] Value: <not collected>
[17:36:35.438] Conditions captured: <none>
[17:36:35.438] Early signaling: FALSE
[17:36:35.438] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:35.438] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.450] Chunk #1 of 2 ... DONE
[17:36:35.450] Chunk #2 of 2 ...
[17:36:35.451]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:35.451]  - seeds: <none>
[17:36:35.451]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.451] getGlobalsAndPackages() ...
[17:36:35.451] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.451] Resolving globals: FALSE
[17:36:35.452] Tweak future expression to call with '...' arguments ...
[17:36:35.452] {
[17:36:35.452]     do.call(function(...) {
[17:36:35.452]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.452]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.452]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.452]             on.exit(options(oopts), add = TRUE)
[17:36:35.452]         }
[17:36:35.452]         {
[17:36:35.452]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.452]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.452]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.452]             })
[17:36:35.452]         }
[17:36:35.452]     }, args = future.call.arguments)
[17:36:35.452] }
[17:36:35.452] Tweak future expression to call with '...' arguments ... DONE
[17:36:35.453] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.453] - packages: [1] ‘stats’
[17:36:35.453] getGlobalsAndPackages() ... DONE
[17:36:35.454] run() for ‘Future’ ...
[17:36:35.454] - state: ‘created’
[17:36:35.454] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:35.459] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.459] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:35.459]   - Field: ‘label’
[17:36:35.459]   - Field: ‘local’
[17:36:35.460]   - Field: ‘owner’
[17:36:35.460]   - Field: ‘envir’
[17:36:35.460]   - Field: ‘workers’
[17:36:35.460]   - Field: ‘packages’
[17:36:35.460]   - Field: ‘gc’
[17:36:35.460]   - Field: ‘job’
[17:36:35.460]   - Field: ‘conditions’
[17:36:35.461]   - Field: ‘expr’
[17:36:35.461]   - Field: ‘uuid’
[17:36:35.461]   - Field: ‘seed’
[17:36:35.461]   - Field: ‘version’
[17:36:35.461]   - Field: ‘result’
[17:36:35.461]   - Field: ‘asynchronous’
[17:36:35.461]   - Field: ‘calls’
[17:36:35.461]   - Field: ‘globals’
[17:36:35.462]   - Field: ‘stdout’
[17:36:35.462]   - Field: ‘earlySignal’
[17:36:35.462]   - Field: ‘lazy’
[17:36:35.462]   - Field: ‘state’
[17:36:35.462] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:35.462] - Launch lazy future ...
[17:36:35.463] Packages needed by the future expression (n = 1): ‘stats’
[17:36:35.463] Packages needed by future strategies (n = 0): <none>
[17:36:35.464] {
[17:36:35.464]     {
[17:36:35.464]         {
[17:36:35.464]             ...future.startTime <- base::Sys.time()
[17:36:35.464]             {
[17:36:35.464]                 {
[17:36:35.464]                   {
[17:36:35.464]                     {
[17:36:35.464]                       {
[17:36:35.464]                         base::local({
[17:36:35.464]                           has_future <- base::requireNamespace("future", 
[17:36:35.464]                             quietly = TRUE)
[17:36:35.464]                           if (has_future) {
[17:36:35.464]                             ns <- base::getNamespace("future")
[17:36:35.464]                             version <- ns[[".package"]][["version"]]
[17:36:35.464]                             if (is.null(version)) 
[17:36:35.464]                               version <- utils::packageVersion("future")
[17:36:35.464]                           }
[17:36:35.464]                           else {
[17:36:35.464]                             version <- NULL
[17:36:35.464]                           }
[17:36:35.464]                           if (!has_future || version < "1.8.0") {
[17:36:35.464]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:35.464]                               "", base::R.version$version.string), 
[17:36:35.464]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:35.464]                                 base::R.version$platform, 8 * 
[17:36:35.464]                                   base::.Machine$sizeof.pointer), 
[17:36:35.464]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:35.464]                                 "release", "version")], collapse = " "), 
[17:36:35.464]                               hostname = base::Sys.info()[["nodename"]])
[17:36:35.464]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:35.464]                               info)
[17:36:35.464]                             info <- base::paste(info, collapse = "; ")
[17:36:35.464]                             if (!has_future) {
[17:36:35.464]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:35.464]                                 info)
[17:36:35.464]                             }
[17:36:35.464]                             else {
[17:36:35.464]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:35.464]                                 info, version)
[17:36:35.464]                             }
[17:36:35.464]                             base::stop(msg)
[17:36:35.464]                           }
[17:36:35.464]                         })
[17:36:35.464]                       }
[17:36:35.464]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:35.464]                       base::options(mc.cores = 1L)
[17:36:35.464]                     }
[17:36:35.464]                     base::local({
[17:36:35.464]                       for (pkg in "stats") {
[17:36:35.464]                         base::loadNamespace(pkg)
[17:36:35.464]                         base::library(pkg, character.only = TRUE)
[17:36:35.464]                       }
[17:36:35.464]                     })
[17:36:35.464]                   }
[17:36:35.464]                   ...future.strategy.old <- future::plan("list")
[17:36:35.464]                   options(future.plan = NULL)
[17:36:35.464]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.464]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:35.464]                 }
[17:36:35.464]                 ...future.workdir <- getwd()
[17:36:35.464]             }
[17:36:35.464]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:35.464]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:35.464]         }
[17:36:35.464]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:35.464]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:35.464]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:35.464]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:35.464]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:35.464]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:35.464]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:35.464]             base::names(...future.oldOptions))
[17:36:35.464]     }
[17:36:35.464]     if (FALSE) {
[17:36:35.464]     }
[17:36:35.464]     else {
[17:36:35.464]         if (TRUE) {
[17:36:35.464]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:35.464]                 open = "w")
[17:36:35.464]         }
[17:36:35.464]         else {
[17:36:35.464]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:35.464]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:35.464]         }
[17:36:35.464]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:35.464]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:35.464]             base::sink(type = "output", split = FALSE)
[17:36:35.464]             base::close(...future.stdout)
[17:36:35.464]         }, add = TRUE)
[17:36:35.464]     }
[17:36:35.464]     ...future.frame <- base::sys.nframe()
[17:36:35.464]     ...future.conditions <- base::list()
[17:36:35.464]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:35.464]     if (FALSE) {
[17:36:35.464]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:35.464]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:35.464]     }
[17:36:35.464]     ...future.result <- base::tryCatch({
[17:36:35.464]         base::withCallingHandlers({
[17:36:35.464]             ...future.value <- base::withVisible(base::local({
[17:36:35.464]                 withCallingHandlers({
[17:36:35.464]                   {
[17:36:35.464]                     do.call(function(...) {
[17:36:35.464]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.464]                       if (!identical(...future.globals.maxSize.org, 
[17:36:35.464]                         ...future.globals.maxSize)) {
[17:36:35.464]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.464]                         on.exit(options(oopts), add = TRUE)
[17:36:35.464]                       }
[17:36:35.464]                       {
[17:36:35.464]                         lapply(seq_along(...future.elements_ii), 
[17:36:35.464]                           FUN = function(jj) {
[17:36:35.464]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.464]                             ...future.FUN(...future.X_jj, ...)
[17:36:35.464]                           })
[17:36:35.464]                       }
[17:36:35.464]                     }, args = future.call.arguments)
[17:36:35.464]                   }
[17:36:35.464]                 }, immediateCondition = function(cond) {
[17:36:35.464]                   save_rds <- function (object, pathname, ...) 
[17:36:35.464]                   {
[17:36:35.464]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:35.464]                     if (file_test("-f", pathname_tmp)) {
[17:36:35.464]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.464]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:35.464]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.464]                         fi_tmp[["mtime"]])
[17:36:35.464]                     }
[17:36:35.464]                     tryCatch({
[17:36:35.464]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:35.464]                     }, error = function(ex) {
[17:36:35.464]                       msg <- conditionMessage(ex)
[17:36:35.464]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.464]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:35.464]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.464]                         fi_tmp[["mtime"]], msg)
[17:36:35.464]                       ex$message <- msg
[17:36:35.464]                       stop(ex)
[17:36:35.464]                     })
[17:36:35.464]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:35.464]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:35.464]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:35.464]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.464]                       fi <- file.info(pathname)
[17:36:35.464]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:35.464]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.464]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:35.464]                         fi[["size"]], fi[["mtime"]])
[17:36:35.464]                       stop(msg)
[17:36:35.464]                     }
[17:36:35.464]                     invisible(pathname)
[17:36:35.464]                   }
[17:36:35.464]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:35.464]                     rootPath = tempdir()) 
[17:36:35.464]                   {
[17:36:35.464]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:35.464]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:35.464]                       tmpdir = path, fileext = ".rds")
[17:36:35.464]                     save_rds(obj, file)
[17:36:35.464]                   }
[17:36:35.464]                   saveImmediateCondition(cond, path = "/tmp/RtmpABg8SG/.future/immediateConditions")
[17:36:35.464]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.464]                   {
[17:36:35.464]                     inherits <- base::inherits
[17:36:35.464]                     invokeRestart <- base::invokeRestart
[17:36:35.464]                     is.null <- base::is.null
[17:36:35.464]                     muffled <- FALSE
[17:36:35.464]                     if (inherits(cond, "message")) {
[17:36:35.464]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:35.464]                       if (muffled) 
[17:36:35.464]                         invokeRestart("muffleMessage")
[17:36:35.464]                     }
[17:36:35.464]                     else if (inherits(cond, "warning")) {
[17:36:35.464]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:35.464]                       if (muffled) 
[17:36:35.464]                         invokeRestart("muffleWarning")
[17:36:35.464]                     }
[17:36:35.464]                     else if (inherits(cond, "condition")) {
[17:36:35.464]                       if (!is.null(pattern)) {
[17:36:35.464]                         computeRestarts <- base::computeRestarts
[17:36:35.464]                         grepl <- base::grepl
[17:36:35.464]                         restarts <- computeRestarts(cond)
[17:36:35.464]                         for (restart in restarts) {
[17:36:35.464]                           name <- restart$name
[17:36:35.464]                           if (is.null(name)) 
[17:36:35.464]                             next
[17:36:35.464]                           if (!grepl(pattern, name)) 
[17:36:35.464]                             next
[17:36:35.464]                           invokeRestart(restart)
[17:36:35.464]                           muffled <- TRUE
[17:36:35.464]                           break
[17:36:35.464]                         }
[17:36:35.464]                       }
[17:36:35.464]                     }
[17:36:35.464]                     invisible(muffled)
[17:36:35.464]                   }
[17:36:35.464]                   muffleCondition(cond)
[17:36:35.464]                 })
[17:36:35.464]             }))
[17:36:35.464]             future::FutureResult(value = ...future.value$value, 
[17:36:35.464]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.464]                   ...future.rng), globalenv = if (FALSE) 
[17:36:35.464]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:35.464]                     ...future.globalenv.names))
[17:36:35.464]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:35.464]         }, condition = base::local({
[17:36:35.464]             c <- base::c
[17:36:35.464]             inherits <- base::inherits
[17:36:35.464]             invokeRestart <- base::invokeRestart
[17:36:35.464]             length <- base::length
[17:36:35.464]             list <- base::list
[17:36:35.464]             seq.int <- base::seq.int
[17:36:35.464]             signalCondition <- base::signalCondition
[17:36:35.464]             sys.calls <- base::sys.calls
[17:36:35.464]             `[[` <- base::`[[`
[17:36:35.464]             `+` <- base::`+`
[17:36:35.464]             `<<-` <- base::`<<-`
[17:36:35.464]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:35.464]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:35.464]                   3L)]
[17:36:35.464]             }
[17:36:35.464]             function(cond) {
[17:36:35.464]                 is_error <- inherits(cond, "error")
[17:36:35.464]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:35.464]                   NULL)
[17:36:35.464]                 if (is_error) {
[17:36:35.464]                   sessionInformation <- function() {
[17:36:35.464]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:35.464]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:35.464]                       search = base::search(), system = base::Sys.info())
[17:36:35.464]                   }
[17:36:35.464]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.464]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:35.464]                     cond$call), session = sessionInformation(), 
[17:36:35.464]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:35.464]                   signalCondition(cond)
[17:36:35.464]                 }
[17:36:35.464]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:35.464]                 "immediateCondition"))) {
[17:36:35.464]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:35.464]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.464]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:35.464]                   if (TRUE && !signal) {
[17:36:35.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.464]                     {
[17:36:35.464]                       inherits <- base::inherits
[17:36:35.464]                       invokeRestart <- base::invokeRestart
[17:36:35.464]                       is.null <- base::is.null
[17:36:35.464]                       muffled <- FALSE
[17:36:35.464]                       if (inherits(cond, "message")) {
[17:36:35.464]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.464]                         if (muffled) 
[17:36:35.464]                           invokeRestart("muffleMessage")
[17:36:35.464]                       }
[17:36:35.464]                       else if (inherits(cond, "warning")) {
[17:36:35.464]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.464]                         if (muffled) 
[17:36:35.464]                           invokeRestart("muffleWarning")
[17:36:35.464]                       }
[17:36:35.464]                       else if (inherits(cond, "condition")) {
[17:36:35.464]                         if (!is.null(pattern)) {
[17:36:35.464]                           computeRestarts <- base::computeRestarts
[17:36:35.464]                           grepl <- base::grepl
[17:36:35.464]                           restarts <- computeRestarts(cond)
[17:36:35.464]                           for (restart in restarts) {
[17:36:35.464]                             name <- restart$name
[17:36:35.464]                             if (is.null(name)) 
[17:36:35.464]                               next
[17:36:35.464]                             if (!grepl(pattern, name)) 
[17:36:35.464]                               next
[17:36:35.464]                             invokeRestart(restart)
[17:36:35.464]                             muffled <- TRUE
[17:36:35.464]                             break
[17:36:35.464]                           }
[17:36:35.464]                         }
[17:36:35.464]                       }
[17:36:35.464]                       invisible(muffled)
[17:36:35.464]                     }
[17:36:35.464]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.464]                   }
[17:36:35.464]                 }
[17:36:35.464]                 else {
[17:36:35.464]                   if (TRUE) {
[17:36:35.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.464]                     {
[17:36:35.464]                       inherits <- base::inherits
[17:36:35.464]                       invokeRestart <- base::invokeRestart
[17:36:35.464]                       is.null <- base::is.null
[17:36:35.464]                       muffled <- FALSE
[17:36:35.464]                       if (inherits(cond, "message")) {
[17:36:35.464]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.464]                         if (muffled) 
[17:36:35.464]                           invokeRestart("muffleMessage")
[17:36:35.464]                       }
[17:36:35.464]                       else if (inherits(cond, "warning")) {
[17:36:35.464]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.464]                         if (muffled) 
[17:36:35.464]                           invokeRestart("muffleWarning")
[17:36:35.464]                       }
[17:36:35.464]                       else if (inherits(cond, "condition")) {
[17:36:35.464]                         if (!is.null(pattern)) {
[17:36:35.464]                           computeRestarts <- base::computeRestarts
[17:36:35.464]                           grepl <- base::grepl
[17:36:35.464]                           restarts <- computeRestarts(cond)
[17:36:35.464]                           for (restart in restarts) {
[17:36:35.464]                             name <- restart$name
[17:36:35.464]                             if (is.null(name)) 
[17:36:35.464]                               next
[17:36:35.464]                             if (!grepl(pattern, name)) 
[17:36:35.464]                               next
[17:36:35.464]                             invokeRestart(restart)
[17:36:35.464]                             muffled <- TRUE
[17:36:35.464]                             break
[17:36:35.464]                           }
[17:36:35.464]                         }
[17:36:35.464]                       }
[17:36:35.464]                       invisible(muffled)
[17:36:35.464]                     }
[17:36:35.464]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.464]                   }
[17:36:35.464]                 }
[17:36:35.464]             }
[17:36:35.464]         }))
[17:36:35.464]     }, error = function(ex) {
[17:36:35.464]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:35.464]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.464]                 ...future.rng), started = ...future.startTime, 
[17:36:35.464]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:35.464]             version = "1.8"), class = "FutureResult")
[17:36:35.464]     }, finally = {
[17:36:35.464]         if (!identical(...future.workdir, getwd())) 
[17:36:35.464]             setwd(...future.workdir)
[17:36:35.464]         {
[17:36:35.464]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:35.464]                 ...future.oldOptions$nwarnings <- NULL
[17:36:35.464]             }
[17:36:35.464]             base::options(...future.oldOptions)
[17:36:35.464]             if (.Platform$OS.type == "windows") {
[17:36:35.464]                 old_names <- names(...future.oldEnvVars)
[17:36:35.464]                 envs <- base::Sys.getenv()
[17:36:35.464]                 names <- names(envs)
[17:36:35.464]                 common <- intersect(names, old_names)
[17:36:35.464]                 added <- setdiff(names, old_names)
[17:36:35.464]                 removed <- setdiff(old_names, names)
[17:36:35.464]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:35.464]                   envs[common]]
[17:36:35.464]                 NAMES <- toupper(changed)
[17:36:35.464]                 args <- list()
[17:36:35.464]                 for (kk in seq_along(NAMES)) {
[17:36:35.464]                   name <- changed[[kk]]
[17:36:35.464]                   NAME <- NAMES[[kk]]
[17:36:35.464]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.464]                     next
[17:36:35.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.464]                 }
[17:36:35.464]                 NAMES <- toupper(added)
[17:36:35.464]                 for (kk in seq_along(NAMES)) {
[17:36:35.464]                   name <- added[[kk]]
[17:36:35.464]                   NAME <- NAMES[[kk]]
[17:36:35.464]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.464]                     next
[17:36:35.464]                   args[[name]] <- ""
[17:36:35.464]                 }
[17:36:35.464]                 NAMES <- toupper(removed)
[17:36:35.464]                 for (kk in seq_along(NAMES)) {
[17:36:35.464]                   name <- removed[[kk]]
[17:36:35.464]                   NAME <- NAMES[[kk]]
[17:36:35.464]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.464]                     next
[17:36:35.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.464]                 }
[17:36:35.464]                 if (length(args) > 0) 
[17:36:35.464]                   base::do.call(base::Sys.setenv, args = args)
[17:36:35.464]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:35.464]             }
[17:36:35.464]             else {
[17:36:35.464]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:35.464]             }
[17:36:35.464]             {
[17:36:35.464]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:35.464]                   0L) {
[17:36:35.464]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:35.464]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:35.464]                   base::options(opts)
[17:36:35.464]                 }
[17:36:35.464]                 {
[17:36:35.464]                   {
[17:36:35.464]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:35.464]                     NULL
[17:36:35.464]                   }
[17:36:35.464]                   options(future.plan = NULL)
[17:36:35.464]                   if (is.na(NA_character_)) 
[17:36:35.464]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.464]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:35.464]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:35.464]                     .init = FALSE)
[17:36:35.464]                 }
[17:36:35.464]             }
[17:36:35.464]         }
[17:36:35.464]     })
[17:36:35.464]     if (TRUE) {
[17:36:35.464]         base::sink(type = "output", split = FALSE)
[17:36:35.464]         if (TRUE) {
[17:36:35.464]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:35.464]         }
[17:36:35.464]         else {
[17:36:35.464]             ...future.result["stdout"] <- base::list(NULL)
[17:36:35.464]         }
[17:36:35.464]         base::close(...future.stdout)
[17:36:35.464]         ...future.stdout <- NULL
[17:36:35.464]     }
[17:36:35.464]     ...future.result$conditions <- ...future.conditions
[17:36:35.464]     ...future.result$finished <- base::Sys.time()
[17:36:35.464]     ...future.result
[17:36:35.464] }
[17:36:35.467] assign_globals() ...
[17:36:35.467] List of 5
[17:36:35.467]  $ future.call.arguments    : list()
[17:36:35.467]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.467]  $ ...future.FUN            :function (x, ...)  
[17:36:35.467]  $ ...future.elements_ii    :List of 1
[17:36:35.467]   ..$ : num [1:4] 2 4 6 8
[17:36:35.467]  $ ...future.seeds_ii       : NULL
[17:36:35.467]  $ ...future.globals.maxSize: num Inf
[17:36:35.467]  - attr(*, "resolved")= logi FALSE
[17:36:35.467]  - attr(*, "total_size")= num NA
[17:36:35.467]  - attr(*, "where")=List of 5
[17:36:35.467]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:35.467]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:35.467]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:35.467]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:35.467]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:35.467]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.467]  - attr(*, "already-done")= logi TRUE
[17:36:35.474] - copied ‘future.call.arguments’ to environment
[17:36:35.474] - copied ‘...future.FUN’ to environment
[17:36:35.474] - copied ‘...future.elements_ii’ to environment
[17:36:35.474] - copied ‘...future.seeds_ii’ to environment
[17:36:35.475] - copied ‘...future.globals.maxSize’ to environment
[17:36:35.475] assign_globals() ... done
[17:36:35.475] requestCore(): workers = 2
[17:36:35.477] MulticoreFuture started
[17:36:35.478] - Launch lazy future ... done
[17:36:35.478] run() for ‘MulticoreFuture’ ... done
[17:36:35.478] Created future:
[17:36:35.479] plan(): Setting new future strategy stack:
[17:36:35.479] List of future strategies:
[17:36:35.479] 1. sequential:
[17:36:35.479]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:35.479]    - tweaked: FALSE
[17:36:35.479]    - call: NULL
[17:36:35.480] plan(): nbrOfWorkers() = 1
[17:36:35.482] plan(): Setting new future strategy stack:
[17:36:35.482] List of future strategies:
[17:36:35.482] 1. multicore:
[17:36:35.482]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:35.482]    - tweaked: FALSE
[17:36:35.482]    - call: plan(strategy)
[17:36:35.487] plan(): nbrOfWorkers() = 2
[17:36:35.478] MulticoreFuture:
[17:36:35.478] Label: ‘future_apply-2’
[17:36:35.478] Expression:
[17:36:35.478] {
[17:36:35.478]     do.call(function(...) {
[17:36:35.478]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.478]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.478]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.478]             on.exit(options(oopts), add = TRUE)
[17:36:35.478]         }
[17:36:35.478]         {
[17:36:35.478]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.478]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.478]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.478]             })
[17:36:35.478]         }
[17:36:35.478]     }, args = future.call.arguments)
[17:36:35.478] }
[17:36:35.478] Lazy evaluation: FALSE
[17:36:35.478] Asynchronous evaluation: TRUE
[17:36:35.478] Local evaluation: TRUE
[17:36:35.478] Environment: R_GlobalEnv
[17:36:35.478] Capture standard output: TRUE
[17:36:35.478] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:35.478] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:35.478] Packages: 1 packages (‘stats’)
[17:36:35.478] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:35.478] Resolved: TRUE
[17:36:35.478] Value: <not collected>
[17:36:35.478] Conditions captured: <none>
[17:36:35.478] Early signaling: FALSE
[17:36:35.478] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:35.478] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.489] Chunk #2 of 2 ... DONE
[17:36:35.489] Launching 2 futures (chunks) ... DONE
[17:36:35.489] Resolving 2 futures (chunks) ...
[17:36:35.489] resolve() on list ...
[17:36:35.489]  recursive: 0
[17:36:35.489]  length: 2
[17:36:35.490] 
[17:36:35.490] Future #1
[17:36:35.490] result() for MulticoreFuture ...
[17:36:35.491] result() for MulticoreFuture ...
[17:36:35.491] result() for MulticoreFuture ... done
[17:36:35.491] result() for MulticoreFuture ... done
[17:36:35.491] result() for MulticoreFuture ...
[17:36:35.492] result() for MulticoreFuture ... done
[17:36:35.492] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:36:35.492] - nx: 2
[17:36:35.492] - relay: TRUE
[17:36:35.492] - stdout: TRUE
[17:36:35.492] - signal: TRUE
[17:36:35.492] - resignal: FALSE
[17:36:35.492] - force: TRUE
[17:36:35.493] - relayed: [n=2] FALSE, FALSE
[17:36:35.493] - queued futures: [n=2] FALSE, FALSE
[17:36:35.493]  - until=1
[17:36:35.493]  - relaying element #1
[17:36:35.493] result() for MulticoreFuture ...
[17:36:35.493] result() for MulticoreFuture ... done
[17:36:35.493] result() for MulticoreFuture ...
[17:36:35.494] result() for MulticoreFuture ... done
[17:36:35.494] result() for MulticoreFuture ...
[17:36:35.494] result() for MulticoreFuture ... done
[17:36:35.494] result() for MulticoreFuture ...
[17:36:35.494] result() for MulticoreFuture ... done
[17:36:35.494] - relayed: [n=2] TRUE, FALSE
[17:36:35.494] - queued futures: [n=2] TRUE, FALSE
[17:36:35.495] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:36:35.495]  length: 1 (resolved future 1)
[17:36:35.495] Future #2
[17:36:35.495] result() for MulticoreFuture ...
[17:36:35.496] result() for MulticoreFuture ...
[17:36:35.496] result() for MulticoreFuture ... done
[17:36:35.496] result() for MulticoreFuture ... done
[17:36:35.499] result() for MulticoreFuture ...
[17:36:35.499] result() for MulticoreFuture ... done
[17:36:35.500] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:36:35.500] - nx: 2
[17:36:35.500] - relay: TRUE
[17:36:35.500] - stdout: TRUE
[17:36:35.500] - signal: TRUE
[17:36:35.501] - resignal: FALSE
[17:36:35.501] - force: TRUE
[17:36:35.501] - relayed: [n=2] TRUE, FALSE
[17:36:35.501] - queued futures: [n=2] TRUE, FALSE
[17:36:35.501]  - until=2
[17:36:35.501]  - relaying element #2
[17:36:35.502] result() for MulticoreFuture ...
[17:36:35.502] result() for MulticoreFuture ... done
[17:36:35.502] result() for MulticoreFuture ...
[17:36:35.502] result() for MulticoreFuture ... done
[17:36:35.502] result() for MulticoreFuture ...
[17:36:35.502] result() for MulticoreFuture ... done
[17:36:35.502] result() for MulticoreFuture ...
[17:36:35.502] result() for MulticoreFuture ... done
[17:36:35.502] - relayed: [n=2] TRUE, TRUE
[17:36:35.503] - queued futures: [n=2] TRUE, TRUE
[17:36:35.503] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:36:35.503]  length: 0 (resolved future 2)
[17:36:35.503] Relaying remaining futures
[17:36:35.503] signalConditionsASAP(NULL, pos=0) ...
[17:36:35.503] - nx: 2
[17:36:35.503] - relay: TRUE
[17:36:35.503] - stdout: TRUE
[17:36:35.504] - signal: TRUE
[17:36:35.504] - resignal: FALSE
[17:36:35.504] - force: TRUE
[17:36:35.504] - relayed: [n=2] TRUE, TRUE
[17:36:35.504] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:35.504] - relayed: [n=2] TRUE, TRUE
[17:36:35.504] - queued futures: [n=2] TRUE, TRUE
[17:36:35.505] signalConditionsASAP(NULL, pos=0) ... done
[17:36:35.505] resolve() on list ... DONE
[17:36:35.505] result() for MulticoreFuture ...
[17:36:35.505] result() for MulticoreFuture ... done
[17:36:35.505] result() for MulticoreFuture ...
[17:36:35.505] result() for MulticoreFuture ... done
[17:36:35.505] result() for MulticoreFuture ...
[17:36:35.505] result() for MulticoreFuture ... done
[17:36:35.505] result() for MulticoreFuture ...
[17:36:35.506] result() for MulticoreFuture ... done
[17:36:35.506]  - Number of value chunks collected: 2
[17:36:35.506] Resolving 2 futures (chunks) ... DONE
[17:36:35.506] Reducing values from 2 chunks ...
[17:36:35.506]  - Number of values collected after concatenation: 2
[17:36:35.506]  - Number of values expected: 2
[17:36:35.506] Reducing values from 2 chunks ... DONE
[17:36:35.506] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[17:36:35.507] getGlobalsAndPackagesXApply() ...
[17:36:35.507]  - future.globals: TRUE
[17:36:35.507] getGlobalsAndPackages() ...
[17:36:35.507] Searching for globals...
[17:36:35.509] - globals found: [1] ‘FUN’
[17:36:35.509] Searching for globals ... DONE
[17:36:35.509] Resolving globals: FALSE
[17:36:35.509] The total size of the 1 globals is 848 bytes (848 bytes)
[17:36:35.510] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:36:35.510] - globals: [1] ‘FUN’
[17:36:35.510] 
[17:36:35.510] getGlobalsAndPackages() ... DONE
[17:36:35.510]  - globals found/used: [n=1] ‘FUN’
[17:36:35.510]  - needed namespaces: [n=0] 
[17:36:35.510] Finding globals ... DONE
[17:36:35.510]  - use_args: TRUE
[17:36:35.511]  - Getting '...' globals ...
[17:36:35.511] resolve() on list ...
[17:36:35.511]  recursive: 0
[17:36:35.511]  length: 1
[17:36:35.511]  elements: ‘...’
[17:36:35.511]  length: 0 (resolved future 1)
[17:36:35.511] resolve() on list ... DONE
[17:36:35.512]    - '...' content: [n=0] 
[17:36:35.512] List of 1
[17:36:35.512]  $ ...: list()
[17:36:35.512]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.512]  - attr(*, "where")=List of 1
[17:36:35.512]   ..$ ...:<environment: 0x556d736cebc8> 
[17:36:35.512]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.512]  - attr(*, "resolved")= logi TRUE
[17:36:35.512]  - attr(*, "total_size")= num NA
[17:36:35.515]  - Getting '...' globals ... DONE
[17:36:35.515] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:35.515] List of 2
[17:36:35.515]  $ ...future.FUN:function (x)  
[17:36:35.515]  $ ...          : list()
[17:36:35.515]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.515]  - attr(*, "where")=List of 2
[17:36:35.515]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:35.515]   ..$ ...          :<environment: 0x556d736cebc8> 
[17:36:35.515]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.515]  - attr(*, "resolved")= logi FALSE
[17:36:35.515]  - attr(*, "total_size")= num 848
[17:36:35.518] Packages to be attached in all futures: [n=0] 
[17:36:35.518] getGlobalsAndPackagesXApply() ... DONE
[17:36:35.522] future_lapply() ...
[17:36:35.526] Number of chunks: 2
[17:36:35.526] getGlobalsAndPackagesXApply() ...
[17:36:35.527]  - future.globals: <name-value list> with names ‘list()’
[17:36:35.527]  - use_args: TRUE
[17:36:35.527] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:35.527] List of 2
[17:36:35.527]  $ ...          : list()
[17:36:35.527]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.527]  $ ...future.FUN:function (x)  
[17:36:35.527]  - attr(*, "where")=List of 2
[17:36:35.527]   ..$ ...          :<environment: 0x556d736cebc8> 
[17:36:35.527]   ..$ ...future.FUN:<environment: namespace:base> 
[17:36:35.527]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.527]  - attr(*, "resolved")= logi FALSE
[17:36:35.527]  - attr(*, "total_size")= num NA
[17:36:35.534] Packages to be attached in all futures: [n=0] 
[17:36:35.534] getGlobalsAndPackagesXApply() ... DONE
[17:36:35.534] Number of futures (= number of chunks): 2
[17:36:35.534] Launching 2 futures (chunks) ...
[17:36:35.535] Chunk #1 of 2 ...
[17:36:35.535]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:35.535]  - seeds: <none>
[17:36:35.535]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.535] getGlobalsAndPackages() ...
[17:36:35.535] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.535] Resolving globals: FALSE
[17:36:35.535] Tweak future expression to call with '...' arguments ...
[17:36:35.536] {
[17:36:35.536]     do.call(function(...) {
[17:36:35.536]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.536]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.536]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.536]             on.exit(options(oopts), add = TRUE)
[17:36:35.536]         }
[17:36:35.536]         {
[17:36:35.536]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.536]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.536]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.536]             })
[17:36:35.536]         }
[17:36:35.536]     }, args = future.call.arguments)
[17:36:35.536] }
[17:36:35.536] Tweak future expression to call with '...' arguments ... DONE
[17:36:35.536] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.536] 
[17:36:35.537] getGlobalsAndPackages() ... DONE
[17:36:35.537] run() for ‘Future’ ...
[17:36:35.537] - state: ‘created’
[17:36:35.537] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:35.541] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.541] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:35.541]   - Field: ‘label’
[17:36:35.541]   - Field: ‘local’
[17:36:35.541]   - Field: ‘owner’
[17:36:35.541]   - Field: ‘envir’
[17:36:35.541]   - Field: ‘workers’
[17:36:35.541]   - Field: ‘packages’
[17:36:35.542]   - Field: ‘gc’
[17:36:35.542]   - Field: ‘job’
[17:36:35.542]   - Field: ‘conditions’
[17:36:35.542]   - Field: ‘expr’
[17:36:35.542]   - Field: ‘uuid’
[17:36:35.542]   - Field: ‘seed’
[17:36:35.542]   - Field: ‘version’
[17:36:35.542]   - Field: ‘result’
[17:36:35.542]   - Field: ‘asynchronous’
[17:36:35.542]   - Field: ‘calls’
[17:36:35.542]   - Field: ‘globals’
[17:36:35.543]   - Field: ‘stdout’
[17:36:35.543]   - Field: ‘earlySignal’
[17:36:35.543]   - Field: ‘lazy’
[17:36:35.543]   - Field: ‘state’
[17:36:35.543] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:35.543] - Launch lazy future ...
[17:36:35.543] Packages needed by the future expression (n = 0): <none>
[17:36:35.543] Packages needed by future strategies (n = 0): <none>
[17:36:35.544] {
[17:36:35.544]     {
[17:36:35.544]         {
[17:36:35.544]             ...future.startTime <- base::Sys.time()
[17:36:35.544]             {
[17:36:35.544]                 {
[17:36:35.544]                   {
[17:36:35.544]                     {
[17:36:35.544]                       base::local({
[17:36:35.544]                         has_future <- base::requireNamespace("future", 
[17:36:35.544]                           quietly = TRUE)
[17:36:35.544]                         if (has_future) {
[17:36:35.544]                           ns <- base::getNamespace("future")
[17:36:35.544]                           version <- ns[[".package"]][["version"]]
[17:36:35.544]                           if (is.null(version)) 
[17:36:35.544]                             version <- utils::packageVersion("future")
[17:36:35.544]                         }
[17:36:35.544]                         else {
[17:36:35.544]                           version <- NULL
[17:36:35.544]                         }
[17:36:35.544]                         if (!has_future || version < "1.8.0") {
[17:36:35.544]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:35.544]                             "", base::R.version$version.string), 
[17:36:35.544]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:35.544]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:35.544]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:35.544]                               "release", "version")], collapse = " "), 
[17:36:35.544]                             hostname = base::Sys.info()[["nodename"]])
[17:36:35.544]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:35.544]                             info)
[17:36:35.544]                           info <- base::paste(info, collapse = "; ")
[17:36:35.544]                           if (!has_future) {
[17:36:35.544]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:35.544]                               info)
[17:36:35.544]                           }
[17:36:35.544]                           else {
[17:36:35.544]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:35.544]                               info, version)
[17:36:35.544]                           }
[17:36:35.544]                           base::stop(msg)
[17:36:35.544]                         }
[17:36:35.544]                       })
[17:36:35.544]                     }
[17:36:35.544]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:35.544]                     base::options(mc.cores = 1L)
[17:36:35.544]                   }
[17:36:35.544]                   ...future.strategy.old <- future::plan("list")
[17:36:35.544]                   options(future.plan = NULL)
[17:36:35.544]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.544]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:35.544]                 }
[17:36:35.544]                 ...future.workdir <- getwd()
[17:36:35.544]             }
[17:36:35.544]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:35.544]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:35.544]         }
[17:36:35.544]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:35.544]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:35.544]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:35.544]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:35.544]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:35.544]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:35.544]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:35.544]             base::names(...future.oldOptions))
[17:36:35.544]     }
[17:36:35.544]     if (FALSE) {
[17:36:35.544]     }
[17:36:35.544]     else {
[17:36:35.544]         if (TRUE) {
[17:36:35.544]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:35.544]                 open = "w")
[17:36:35.544]         }
[17:36:35.544]         else {
[17:36:35.544]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:35.544]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:35.544]         }
[17:36:35.544]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:35.544]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:35.544]             base::sink(type = "output", split = FALSE)
[17:36:35.544]             base::close(...future.stdout)
[17:36:35.544]         }, add = TRUE)
[17:36:35.544]     }
[17:36:35.544]     ...future.frame <- base::sys.nframe()
[17:36:35.544]     ...future.conditions <- base::list()
[17:36:35.544]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:35.544]     if (FALSE) {
[17:36:35.544]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:35.544]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:35.544]     }
[17:36:35.544]     ...future.result <- base::tryCatch({
[17:36:35.544]         base::withCallingHandlers({
[17:36:35.544]             ...future.value <- base::withVisible(base::local({
[17:36:35.544]                 withCallingHandlers({
[17:36:35.544]                   {
[17:36:35.544]                     do.call(function(...) {
[17:36:35.544]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.544]                       if (!identical(...future.globals.maxSize.org, 
[17:36:35.544]                         ...future.globals.maxSize)) {
[17:36:35.544]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.544]                         on.exit(options(oopts), add = TRUE)
[17:36:35.544]                       }
[17:36:35.544]                       {
[17:36:35.544]                         lapply(seq_along(...future.elements_ii), 
[17:36:35.544]                           FUN = function(jj) {
[17:36:35.544]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.544]                             ...future.FUN(...future.X_jj, ...)
[17:36:35.544]                           })
[17:36:35.544]                       }
[17:36:35.544]                     }, args = future.call.arguments)
[17:36:35.544]                   }
[17:36:35.544]                 }, immediateCondition = function(cond) {
[17:36:35.544]                   save_rds <- function (object, pathname, ...) 
[17:36:35.544]                   {
[17:36:35.544]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:35.544]                     if (file_test("-f", pathname_tmp)) {
[17:36:35.544]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.544]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:35.544]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.544]                         fi_tmp[["mtime"]])
[17:36:35.544]                     }
[17:36:35.544]                     tryCatch({
[17:36:35.544]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:35.544]                     }, error = function(ex) {
[17:36:35.544]                       msg <- conditionMessage(ex)
[17:36:35.544]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.544]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:35.544]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.544]                         fi_tmp[["mtime"]], msg)
[17:36:35.544]                       ex$message <- msg
[17:36:35.544]                       stop(ex)
[17:36:35.544]                     })
[17:36:35.544]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:35.544]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:35.544]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:35.544]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.544]                       fi <- file.info(pathname)
[17:36:35.544]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:35.544]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.544]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:35.544]                         fi[["size"]], fi[["mtime"]])
[17:36:35.544]                       stop(msg)
[17:36:35.544]                     }
[17:36:35.544]                     invisible(pathname)
[17:36:35.544]                   }
[17:36:35.544]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:35.544]                     rootPath = tempdir()) 
[17:36:35.544]                   {
[17:36:35.544]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:35.544]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:35.544]                       tmpdir = path, fileext = ".rds")
[17:36:35.544]                     save_rds(obj, file)
[17:36:35.544]                   }
[17:36:35.544]                   saveImmediateCondition(cond, path = "/tmp/RtmpABg8SG/.future/immediateConditions")
[17:36:35.544]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.544]                   {
[17:36:35.544]                     inherits <- base::inherits
[17:36:35.544]                     invokeRestart <- base::invokeRestart
[17:36:35.544]                     is.null <- base::is.null
[17:36:35.544]                     muffled <- FALSE
[17:36:35.544]                     if (inherits(cond, "message")) {
[17:36:35.544]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:35.544]                       if (muffled) 
[17:36:35.544]                         invokeRestart("muffleMessage")
[17:36:35.544]                     }
[17:36:35.544]                     else if (inherits(cond, "warning")) {
[17:36:35.544]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:35.544]                       if (muffled) 
[17:36:35.544]                         invokeRestart("muffleWarning")
[17:36:35.544]                     }
[17:36:35.544]                     else if (inherits(cond, "condition")) {
[17:36:35.544]                       if (!is.null(pattern)) {
[17:36:35.544]                         computeRestarts <- base::computeRestarts
[17:36:35.544]                         grepl <- base::grepl
[17:36:35.544]                         restarts <- computeRestarts(cond)
[17:36:35.544]                         for (restart in restarts) {
[17:36:35.544]                           name <- restart$name
[17:36:35.544]                           if (is.null(name)) 
[17:36:35.544]                             next
[17:36:35.544]                           if (!grepl(pattern, name)) 
[17:36:35.544]                             next
[17:36:35.544]                           invokeRestart(restart)
[17:36:35.544]                           muffled <- TRUE
[17:36:35.544]                           break
[17:36:35.544]                         }
[17:36:35.544]                       }
[17:36:35.544]                     }
[17:36:35.544]                     invisible(muffled)
[17:36:35.544]                   }
[17:36:35.544]                   muffleCondition(cond)
[17:36:35.544]                 })
[17:36:35.544]             }))
[17:36:35.544]             future::FutureResult(value = ...future.value$value, 
[17:36:35.544]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.544]                   ...future.rng), globalenv = if (FALSE) 
[17:36:35.544]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:35.544]                     ...future.globalenv.names))
[17:36:35.544]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:35.544]         }, condition = base::local({
[17:36:35.544]             c <- base::c
[17:36:35.544]             inherits <- base::inherits
[17:36:35.544]             invokeRestart <- base::invokeRestart
[17:36:35.544]             length <- base::length
[17:36:35.544]             list <- base::list
[17:36:35.544]             seq.int <- base::seq.int
[17:36:35.544]             signalCondition <- base::signalCondition
[17:36:35.544]             sys.calls <- base::sys.calls
[17:36:35.544]             `[[` <- base::`[[`
[17:36:35.544]             `+` <- base::`+`
[17:36:35.544]             `<<-` <- base::`<<-`
[17:36:35.544]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:35.544]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:35.544]                   3L)]
[17:36:35.544]             }
[17:36:35.544]             function(cond) {
[17:36:35.544]                 is_error <- inherits(cond, "error")
[17:36:35.544]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:35.544]                   NULL)
[17:36:35.544]                 if (is_error) {
[17:36:35.544]                   sessionInformation <- function() {
[17:36:35.544]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:35.544]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:35.544]                       search = base::search(), system = base::Sys.info())
[17:36:35.544]                   }
[17:36:35.544]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.544]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:35.544]                     cond$call), session = sessionInformation(), 
[17:36:35.544]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:35.544]                   signalCondition(cond)
[17:36:35.544]                 }
[17:36:35.544]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:35.544]                 "immediateCondition"))) {
[17:36:35.544]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:35.544]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.544]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:35.544]                   if (TRUE && !signal) {
[17:36:35.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.544]                     {
[17:36:35.544]                       inherits <- base::inherits
[17:36:35.544]                       invokeRestart <- base::invokeRestart
[17:36:35.544]                       is.null <- base::is.null
[17:36:35.544]                       muffled <- FALSE
[17:36:35.544]                       if (inherits(cond, "message")) {
[17:36:35.544]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.544]                         if (muffled) 
[17:36:35.544]                           invokeRestart("muffleMessage")
[17:36:35.544]                       }
[17:36:35.544]                       else if (inherits(cond, "warning")) {
[17:36:35.544]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.544]                         if (muffled) 
[17:36:35.544]                           invokeRestart("muffleWarning")
[17:36:35.544]                       }
[17:36:35.544]                       else if (inherits(cond, "condition")) {
[17:36:35.544]                         if (!is.null(pattern)) {
[17:36:35.544]                           computeRestarts <- base::computeRestarts
[17:36:35.544]                           grepl <- base::grepl
[17:36:35.544]                           restarts <- computeRestarts(cond)
[17:36:35.544]                           for (restart in restarts) {
[17:36:35.544]                             name <- restart$name
[17:36:35.544]                             if (is.null(name)) 
[17:36:35.544]                               next
[17:36:35.544]                             if (!grepl(pattern, name)) 
[17:36:35.544]                               next
[17:36:35.544]                             invokeRestart(restart)
[17:36:35.544]                             muffled <- TRUE
[17:36:35.544]                             break
[17:36:35.544]                           }
[17:36:35.544]                         }
[17:36:35.544]                       }
[17:36:35.544]                       invisible(muffled)
[17:36:35.544]                     }
[17:36:35.544]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.544]                   }
[17:36:35.544]                 }
[17:36:35.544]                 else {
[17:36:35.544]                   if (TRUE) {
[17:36:35.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.544]                     {
[17:36:35.544]                       inherits <- base::inherits
[17:36:35.544]                       invokeRestart <- base::invokeRestart
[17:36:35.544]                       is.null <- base::is.null
[17:36:35.544]                       muffled <- FALSE
[17:36:35.544]                       if (inherits(cond, "message")) {
[17:36:35.544]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.544]                         if (muffled) 
[17:36:35.544]                           invokeRestart("muffleMessage")
[17:36:35.544]                       }
[17:36:35.544]                       else if (inherits(cond, "warning")) {
[17:36:35.544]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.544]                         if (muffled) 
[17:36:35.544]                           invokeRestart("muffleWarning")
[17:36:35.544]                       }
[17:36:35.544]                       else if (inherits(cond, "condition")) {
[17:36:35.544]                         if (!is.null(pattern)) {
[17:36:35.544]                           computeRestarts <- base::computeRestarts
[17:36:35.544]                           grepl <- base::grepl
[17:36:35.544]                           restarts <- computeRestarts(cond)
[17:36:35.544]                           for (restart in restarts) {
[17:36:35.544]                             name <- restart$name
[17:36:35.544]                             if (is.null(name)) 
[17:36:35.544]                               next
[17:36:35.544]                             if (!grepl(pattern, name)) 
[17:36:35.544]                               next
[17:36:35.544]                             invokeRestart(restart)
[17:36:35.544]                             muffled <- TRUE
[17:36:35.544]                             break
[17:36:35.544]                           }
[17:36:35.544]                         }
[17:36:35.544]                       }
[17:36:35.544]                       invisible(muffled)
[17:36:35.544]                     }
[17:36:35.544]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.544]                   }
[17:36:35.544]                 }
[17:36:35.544]             }
[17:36:35.544]         }))
[17:36:35.544]     }, error = function(ex) {
[17:36:35.544]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:35.544]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.544]                 ...future.rng), started = ...future.startTime, 
[17:36:35.544]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:35.544]             version = "1.8"), class = "FutureResult")
[17:36:35.544]     }, finally = {
[17:36:35.544]         if (!identical(...future.workdir, getwd())) 
[17:36:35.544]             setwd(...future.workdir)
[17:36:35.544]         {
[17:36:35.544]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:35.544]                 ...future.oldOptions$nwarnings <- NULL
[17:36:35.544]             }
[17:36:35.544]             base::options(...future.oldOptions)
[17:36:35.544]             if (.Platform$OS.type == "windows") {
[17:36:35.544]                 old_names <- names(...future.oldEnvVars)
[17:36:35.544]                 envs <- base::Sys.getenv()
[17:36:35.544]                 names <- names(envs)
[17:36:35.544]                 common <- intersect(names, old_names)
[17:36:35.544]                 added <- setdiff(names, old_names)
[17:36:35.544]                 removed <- setdiff(old_names, names)
[17:36:35.544]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:35.544]                   envs[common]]
[17:36:35.544]                 NAMES <- toupper(changed)
[17:36:35.544]                 args <- list()
[17:36:35.544]                 for (kk in seq_along(NAMES)) {
[17:36:35.544]                   name <- changed[[kk]]
[17:36:35.544]                   NAME <- NAMES[[kk]]
[17:36:35.544]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.544]                     next
[17:36:35.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.544]                 }
[17:36:35.544]                 NAMES <- toupper(added)
[17:36:35.544]                 for (kk in seq_along(NAMES)) {
[17:36:35.544]                   name <- added[[kk]]
[17:36:35.544]                   NAME <- NAMES[[kk]]
[17:36:35.544]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.544]                     next
[17:36:35.544]                   args[[name]] <- ""
[17:36:35.544]                 }
[17:36:35.544]                 NAMES <- toupper(removed)
[17:36:35.544]                 for (kk in seq_along(NAMES)) {
[17:36:35.544]                   name <- removed[[kk]]
[17:36:35.544]                   NAME <- NAMES[[kk]]
[17:36:35.544]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.544]                     next
[17:36:35.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.544]                 }
[17:36:35.544]                 if (length(args) > 0) 
[17:36:35.544]                   base::do.call(base::Sys.setenv, args = args)
[17:36:35.544]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:35.544]             }
[17:36:35.544]             else {
[17:36:35.544]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:35.544]             }
[17:36:35.544]             {
[17:36:35.544]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:35.544]                   0L) {
[17:36:35.544]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:35.544]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:35.544]                   base::options(opts)
[17:36:35.544]                 }
[17:36:35.544]                 {
[17:36:35.544]                   {
[17:36:35.544]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:35.544]                     NULL
[17:36:35.544]                   }
[17:36:35.544]                   options(future.plan = NULL)
[17:36:35.544]                   if (is.na(NA_character_)) 
[17:36:35.544]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.544]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:35.544]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:35.544]                     .init = FALSE)
[17:36:35.544]                 }
[17:36:35.544]             }
[17:36:35.544]         }
[17:36:35.544]     })
[17:36:35.544]     if (TRUE) {
[17:36:35.544]         base::sink(type = "output", split = FALSE)
[17:36:35.544]         if (TRUE) {
[17:36:35.544]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:35.544]         }
[17:36:35.544]         else {
[17:36:35.544]             ...future.result["stdout"] <- base::list(NULL)
[17:36:35.544]         }
[17:36:35.544]         base::close(...future.stdout)
[17:36:35.544]         ...future.stdout <- NULL
[17:36:35.544]     }
[17:36:35.544]     ...future.result$conditions <- ...future.conditions
[17:36:35.544]     ...future.result$finished <- base::Sys.time()
[17:36:35.544]     ...future.result
[17:36:35.544] }
[17:36:35.546] assign_globals() ...
[17:36:35.546] List of 5
[17:36:35.546]  $ future.call.arguments    : list()
[17:36:35.546]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.546]  $ ...future.FUN            :function (x)  
[17:36:35.546]  $ ...future.elements_ii    :List of 1
[17:36:35.546]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:36:35.546]  $ ...future.seeds_ii       : NULL
[17:36:35.546]  $ ...future.globals.maxSize: num Inf
[17:36:35.546]  - attr(*, "resolved")= logi FALSE
[17:36:35.546]  - attr(*, "total_size")= num NA
[17:36:35.546]  - attr(*, "where")=List of 5
[17:36:35.546]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:35.546]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:35.546]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:35.546]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:35.546]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:35.546]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.546]  - attr(*, "already-done")= logi TRUE
[17:36:35.551] - copied ‘future.call.arguments’ to environment
[17:36:35.551] - copied ‘...future.FUN’ to environment
[17:36:35.551] - copied ‘...future.elements_ii’ to environment
[17:36:35.551] - copied ‘...future.seeds_ii’ to environment
[17:36:35.551] - copied ‘...future.globals.maxSize’ to environment
[17:36:35.551] assign_globals() ... done
[17:36:35.552] requestCore(): workers = 2
[17:36:35.554] MulticoreFuture started
[17:36:35.554] - Launch lazy future ... done
[17:36:35.554] run() for ‘MulticoreFuture’ ... done
[17:36:35.555] Created future:
[17:36:35.555] plan(): Setting new future strategy stack:
[17:36:35.555] List of future strategies:
[17:36:35.555] 1. sequential:
[17:36:35.555]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:35.555]    - tweaked: FALSE
[17:36:35.555]    - call: NULL
[17:36:35.556] plan(): nbrOfWorkers() = 1
[17:36:35.558] plan(): Setting new future strategy stack:
[17:36:35.558] List of future strategies:
[17:36:35.558] 1. multicore:
[17:36:35.558]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:35.558]    - tweaked: FALSE
[17:36:35.558]    - call: plan(strategy)
[17:36:35.564] plan(): nbrOfWorkers() = 2
[17:36:35.555] MulticoreFuture:
[17:36:35.555] Label: ‘future_apply-1’
[17:36:35.555] Expression:
[17:36:35.555] {
[17:36:35.555]     do.call(function(...) {
[17:36:35.555]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.555]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.555]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.555]             on.exit(options(oopts), add = TRUE)
[17:36:35.555]         }
[17:36:35.555]         {
[17:36:35.555]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.555]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.555]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.555]             })
[17:36:35.555]         }
[17:36:35.555]     }, args = future.call.arguments)
[17:36:35.555] }
[17:36:35.555] Lazy evaluation: FALSE
[17:36:35.555] Asynchronous evaluation: TRUE
[17:36:35.555] Local evaluation: TRUE
[17:36:35.555] Environment: R_GlobalEnv
[17:36:35.555] Capture standard output: TRUE
[17:36:35.555] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:35.555] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:35.555] Packages: <none>
[17:36:35.555] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:35.555] Resolved: TRUE
[17:36:35.555] Value: <not collected>
[17:36:35.555] Conditions captured: <none>
[17:36:35.555] Early signaling: FALSE
[17:36:35.555] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:35.555] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.565] Chunk #1 of 2 ... DONE
[17:36:35.565] Chunk #2 of 2 ...
[17:36:35.565]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:35.565]  - seeds: <none>
[17:36:35.565]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.566] getGlobalsAndPackages() ...
[17:36:35.566] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.566] Resolving globals: FALSE
[17:36:35.566] Tweak future expression to call with '...' arguments ...
[17:36:35.566] {
[17:36:35.566]     do.call(function(...) {
[17:36:35.566]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.566]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.566]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.566]             on.exit(options(oopts), add = TRUE)
[17:36:35.566]         }
[17:36:35.566]         {
[17:36:35.566]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.566]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.566]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.566]             })
[17:36:35.566]         }
[17:36:35.566]     }, args = future.call.arguments)
[17:36:35.566] }
[17:36:35.567] Tweak future expression to call with '...' arguments ... DONE
[17:36:35.567] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.567] 
[17:36:35.567] getGlobalsAndPackages() ... DONE
[17:36:35.568] run() for ‘Future’ ...
[17:36:35.568] - state: ‘created’
[17:36:35.568] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:35.573] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.573] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:35.573]   - Field: ‘label’
[17:36:35.573]   - Field: ‘local’
[17:36:35.574]   - Field: ‘owner’
[17:36:35.574]   - Field: ‘envir’
[17:36:35.574]   - Field: ‘workers’
[17:36:35.574]   - Field: ‘packages’
[17:36:35.574]   - Field: ‘gc’
[17:36:35.574]   - Field: ‘job’
[17:36:35.575]   - Field: ‘conditions’
[17:36:35.575]   - Field: ‘expr’
[17:36:35.575]   - Field: ‘uuid’
[17:36:35.575]   - Field: ‘seed’
[17:36:35.575]   - Field: ‘version’
[17:36:35.575]   - Field: ‘result’
[17:36:35.575]   - Field: ‘asynchronous’
[17:36:35.575]   - Field: ‘calls’
[17:36:35.576]   - Field: ‘globals’
[17:36:35.576]   - Field: ‘stdout’
[17:36:35.576]   - Field: ‘earlySignal’
[17:36:35.576]   - Field: ‘lazy’
[17:36:35.576]   - Field: ‘state’
[17:36:35.576] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:35.577] - Launch lazy future ...
[17:36:35.577] Packages needed by the future expression (n = 0): <none>
[17:36:35.577] Packages needed by future strategies (n = 0): <none>
[17:36:35.581] {
[17:36:35.581]     {
[17:36:35.581]         {
[17:36:35.581]             ...future.startTime <- base::Sys.time()
[17:36:35.581]             {
[17:36:35.581]                 {
[17:36:35.581]                   {
[17:36:35.581]                     {
[17:36:35.581]                       base::local({
[17:36:35.581]                         has_future <- base::requireNamespace("future", 
[17:36:35.581]                           quietly = TRUE)
[17:36:35.581]                         if (has_future) {
[17:36:35.581]                           ns <- base::getNamespace("future")
[17:36:35.581]                           version <- ns[[".package"]][["version"]]
[17:36:35.581]                           if (is.null(version)) 
[17:36:35.581]                             version <- utils::packageVersion("future")
[17:36:35.581]                         }
[17:36:35.581]                         else {
[17:36:35.581]                           version <- NULL
[17:36:35.581]                         }
[17:36:35.581]                         if (!has_future || version < "1.8.0") {
[17:36:35.581]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:35.581]                             "", base::R.version$version.string), 
[17:36:35.581]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:35.581]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:35.581]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:35.581]                               "release", "version")], collapse = " "), 
[17:36:35.581]                             hostname = base::Sys.info()[["nodename"]])
[17:36:35.581]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:35.581]                             info)
[17:36:35.581]                           info <- base::paste(info, collapse = "; ")
[17:36:35.581]                           if (!has_future) {
[17:36:35.581]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:35.581]                               info)
[17:36:35.581]                           }
[17:36:35.581]                           else {
[17:36:35.581]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:35.581]                               info, version)
[17:36:35.581]                           }
[17:36:35.581]                           base::stop(msg)
[17:36:35.581]                         }
[17:36:35.581]                       })
[17:36:35.581]                     }
[17:36:35.581]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:35.581]                     base::options(mc.cores = 1L)
[17:36:35.581]                   }
[17:36:35.581]                   ...future.strategy.old <- future::plan("list")
[17:36:35.581]                   options(future.plan = NULL)
[17:36:35.581]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.581]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:35.581]                 }
[17:36:35.581]                 ...future.workdir <- getwd()
[17:36:35.581]             }
[17:36:35.581]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:35.581]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:35.581]         }
[17:36:35.581]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:35.581]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:35.581]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:35.581]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:35.581]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:35.581]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:35.581]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:35.581]             base::names(...future.oldOptions))
[17:36:35.581]     }
[17:36:35.581]     if (FALSE) {
[17:36:35.581]     }
[17:36:35.581]     else {
[17:36:35.581]         if (TRUE) {
[17:36:35.581]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:35.581]                 open = "w")
[17:36:35.581]         }
[17:36:35.581]         else {
[17:36:35.581]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:35.581]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:35.581]         }
[17:36:35.581]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:35.581]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:35.581]             base::sink(type = "output", split = FALSE)
[17:36:35.581]             base::close(...future.stdout)
[17:36:35.581]         }, add = TRUE)
[17:36:35.581]     }
[17:36:35.581]     ...future.frame <- base::sys.nframe()
[17:36:35.581]     ...future.conditions <- base::list()
[17:36:35.581]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:35.581]     if (FALSE) {
[17:36:35.581]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:35.581]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:35.581]     }
[17:36:35.581]     ...future.result <- base::tryCatch({
[17:36:35.581]         base::withCallingHandlers({
[17:36:35.581]             ...future.value <- base::withVisible(base::local({
[17:36:35.581]                 withCallingHandlers({
[17:36:35.581]                   {
[17:36:35.581]                     do.call(function(...) {
[17:36:35.581]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.581]                       if (!identical(...future.globals.maxSize.org, 
[17:36:35.581]                         ...future.globals.maxSize)) {
[17:36:35.581]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.581]                         on.exit(options(oopts), add = TRUE)
[17:36:35.581]                       }
[17:36:35.581]                       {
[17:36:35.581]                         lapply(seq_along(...future.elements_ii), 
[17:36:35.581]                           FUN = function(jj) {
[17:36:35.581]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.581]                             ...future.FUN(...future.X_jj, ...)
[17:36:35.581]                           })
[17:36:35.581]                       }
[17:36:35.581]                     }, args = future.call.arguments)
[17:36:35.581]                   }
[17:36:35.581]                 }, immediateCondition = function(cond) {
[17:36:35.581]                   save_rds <- function (object, pathname, ...) 
[17:36:35.581]                   {
[17:36:35.581]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:35.581]                     if (file_test("-f", pathname_tmp)) {
[17:36:35.581]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.581]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:35.581]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.581]                         fi_tmp[["mtime"]])
[17:36:35.581]                     }
[17:36:35.581]                     tryCatch({
[17:36:35.581]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:35.581]                     }, error = function(ex) {
[17:36:35.581]                       msg <- conditionMessage(ex)
[17:36:35.581]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.581]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:35.581]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.581]                         fi_tmp[["mtime"]], msg)
[17:36:35.581]                       ex$message <- msg
[17:36:35.581]                       stop(ex)
[17:36:35.581]                     })
[17:36:35.581]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:35.581]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:35.581]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:35.581]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.581]                       fi <- file.info(pathname)
[17:36:35.581]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:35.581]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.581]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:35.581]                         fi[["size"]], fi[["mtime"]])
[17:36:35.581]                       stop(msg)
[17:36:35.581]                     }
[17:36:35.581]                     invisible(pathname)
[17:36:35.581]                   }
[17:36:35.581]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:35.581]                     rootPath = tempdir()) 
[17:36:35.581]                   {
[17:36:35.581]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:35.581]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:35.581]                       tmpdir = path, fileext = ".rds")
[17:36:35.581]                     save_rds(obj, file)
[17:36:35.581]                   }
[17:36:35.581]                   saveImmediateCondition(cond, path = "/tmp/RtmpABg8SG/.future/immediateConditions")
[17:36:35.581]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.581]                   {
[17:36:35.581]                     inherits <- base::inherits
[17:36:35.581]                     invokeRestart <- base::invokeRestart
[17:36:35.581]                     is.null <- base::is.null
[17:36:35.581]                     muffled <- FALSE
[17:36:35.581]                     if (inherits(cond, "message")) {
[17:36:35.581]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:35.581]                       if (muffled) 
[17:36:35.581]                         invokeRestart("muffleMessage")
[17:36:35.581]                     }
[17:36:35.581]                     else if (inherits(cond, "warning")) {
[17:36:35.581]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:35.581]                       if (muffled) 
[17:36:35.581]                         invokeRestart("muffleWarning")
[17:36:35.581]                     }
[17:36:35.581]                     else if (inherits(cond, "condition")) {
[17:36:35.581]                       if (!is.null(pattern)) {
[17:36:35.581]                         computeRestarts <- base::computeRestarts
[17:36:35.581]                         grepl <- base::grepl
[17:36:35.581]                         restarts <- computeRestarts(cond)
[17:36:35.581]                         for (restart in restarts) {
[17:36:35.581]                           name <- restart$name
[17:36:35.581]                           if (is.null(name)) 
[17:36:35.581]                             next
[17:36:35.581]                           if (!grepl(pattern, name)) 
[17:36:35.581]                             next
[17:36:35.581]                           invokeRestart(restart)
[17:36:35.581]                           muffled <- TRUE
[17:36:35.581]                           break
[17:36:35.581]                         }
[17:36:35.581]                       }
[17:36:35.581]                     }
[17:36:35.581]                     invisible(muffled)
[17:36:35.581]                   }
[17:36:35.581]                   muffleCondition(cond)
[17:36:35.581]                 })
[17:36:35.581]             }))
[17:36:35.581]             future::FutureResult(value = ...future.value$value, 
[17:36:35.581]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.581]                   ...future.rng), globalenv = if (FALSE) 
[17:36:35.581]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:35.581]                     ...future.globalenv.names))
[17:36:35.581]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:35.581]         }, condition = base::local({
[17:36:35.581]             c <- base::c
[17:36:35.581]             inherits <- base::inherits
[17:36:35.581]             invokeRestart <- base::invokeRestart
[17:36:35.581]             length <- base::length
[17:36:35.581]             list <- base::list
[17:36:35.581]             seq.int <- base::seq.int
[17:36:35.581]             signalCondition <- base::signalCondition
[17:36:35.581]             sys.calls <- base::sys.calls
[17:36:35.581]             `[[` <- base::`[[`
[17:36:35.581]             `+` <- base::`+`
[17:36:35.581]             `<<-` <- base::`<<-`
[17:36:35.581]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:35.581]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:35.581]                   3L)]
[17:36:35.581]             }
[17:36:35.581]             function(cond) {
[17:36:35.581]                 is_error <- inherits(cond, "error")
[17:36:35.581]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:35.581]                   NULL)
[17:36:35.581]                 if (is_error) {
[17:36:35.581]                   sessionInformation <- function() {
[17:36:35.581]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:35.581]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:35.581]                       search = base::search(), system = base::Sys.info())
[17:36:35.581]                   }
[17:36:35.581]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.581]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:35.581]                     cond$call), session = sessionInformation(), 
[17:36:35.581]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:35.581]                   signalCondition(cond)
[17:36:35.581]                 }
[17:36:35.581]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:35.581]                 "immediateCondition"))) {
[17:36:35.581]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:35.581]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.581]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:35.581]                   if (TRUE && !signal) {
[17:36:35.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.581]                     {
[17:36:35.581]                       inherits <- base::inherits
[17:36:35.581]                       invokeRestart <- base::invokeRestart
[17:36:35.581]                       is.null <- base::is.null
[17:36:35.581]                       muffled <- FALSE
[17:36:35.581]                       if (inherits(cond, "message")) {
[17:36:35.581]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.581]                         if (muffled) 
[17:36:35.581]                           invokeRestart("muffleMessage")
[17:36:35.581]                       }
[17:36:35.581]                       else if (inherits(cond, "warning")) {
[17:36:35.581]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.581]                         if (muffled) 
[17:36:35.581]                           invokeRestart("muffleWarning")
[17:36:35.581]                       }
[17:36:35.581]                       else if (inherits(cond, "condition")) {
[17:36:35.581]                         if (!is.null(pattern)) {
[17:36:35.581]                           computeRestarts <- base::computeRestarts
[17:36:35.581]                           grepl <- base::grepl
[17:36:35.581]                           restarts <- computeRestarts(cond)
[17:36:35.581]                           for (restart in restarts) {
[17:36:35.581]                             name <- restart$name
[17:36:35.581]                             if (is.null(name)) 
[17:36:35.581]                               next
[17:36:35.581]                             if (!grepl(pattern, name)) 
[17:36:35.581]                               next
[17:36:35.581]                             invokeRestart(restart)
[17:36:35.581]                             muffled <- TRUE
[17:36:35.581]                             break
[17:36:35.581]                           }
[17:36:35.581]                         }
[17:36:35.581]                       }
[17:36:35.581]                       invisible(muffled)
[17:36:35.581]                     }
[17:36:35.581]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.581]                   }
[17:36:35.581]                 }
[17:36:35.581]                 else {
[17:36:35.581]                   if (TRUE) {
[17:36:35.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.581]                     {
[17:36:35.581]                       inherits <- base::inherits
[17:36:35.581]                       invokeRestart <- base::invokeRestart
[17:36:35.581]                       is.null <- base::is.null
[17:36:35.581]                       muffled <- FALSE
[17:36:35.581]                       if (inherits(cond, "message")) {
[17:36:35.581]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.581]                         if (muffled) 
[17:36:35.581]                           invokeRestart("muffleMessage")
[17:36:35.581]                       }
[17:36:35.581]                       else if (inherits(cond, "warning")) {
[17:36:35.581]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.581]                         if (muffled) 
[17:36:35.581]                           invokeRestart("muffleWarning")
[17:36:35.581]                       }
[17:36:35.581]                       else if (inherits(cond, "condition")) {
[17:36:35.581]                         if (!is.null(pattern)) {
[17:36:35.581]                           computeRestarts <- base::computeRestarts
[17:36:35.581]                           grepl <- base::grepl
[17:36:35.581]                           restarts <- computeRestarts(cond)
[17:36:35.581]                           for (restart in restarts) {
[17:36:35.581]                             name <- restart$name
[17:36:35.581]                             if (is.null(name)) 
[17:36:35.581]                               next
[17:36:35.581]                             if (!grepl(pattern, name)) 
[17:36:35.581]                               next
[17:36:35.581]                             invokeRestart(restart)
[17:36:35.581]                             muffled <- TRUE
[17:36:35.581]                             break
[17:36:35.581]                           }
[17:36:35.581]                         }
[17:36:35.581]                       }
[17:36:35.581]                       invisible(muffled)
[17:36:35.581]                     }
[17:36:35.581]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.581]                   }
[17:36:35.581]                 }
[17:36:35.581]             }
[17:36:35.581]         }))
[17:36:35.581]     }, error = function(ex) {
[17:36:35.581]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:35.581]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.581]                 ...future.rng), started = ...future.startTime, 
[17:36:35.581]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:35.581]             version = "1.8"), class = "FutureResult")
[17:36:35.581]     }, finally = {
[17:36:35.581]         if (!identical(...future.workdir, getwd())) 
[17:36:35.581]             setwd(...future.workdir)
[17:36:35.581]         {
[17:36:35.581]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:35.581]                 ...future.oldOptions$nwarnings <- NULL
[17:36:35.581]             }
[17:36:35.581]             base::options(...future.oldOptions)
[17:36:35.581]             if (.Platform$OS.type == "windows") {
[17:36:35.581]                 old_names <- names(...future.oldEnvVars)
[17:36:35.581]                 envs <- base::Sys.getenv()
[17:36:35.581]                 names <- names(envs)
[17:36:35.581]                 common <- intersect(names, old_names)
[17:36:35.581]                 added <- setdiff(names, old_names)
[17:36:35.581]                 removed <- setdiff(old_names, names)
[17:36:35.581]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:35.581]                   envs[common]]
[17:36:35.581]                 NAMES <- toupper(changed)
[17:36:35.581]                 args <- list()
[17:36:35.581]                 for (kk in seq_along(NAMES)) {
[17:36:35.581]                   name <- changed[[kk]]
[17:36:35.581]                   NAME <- NAMES[[kk]]
[17:36:35.581]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.581]                     next
[17:36:35.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.581]                 }
[17:36:35.581]                 NAMES <- toupper(added)
[17:36:35.581]                 for (kk in seq_along(NAMES)) {
[17:36:35.581]                   name <- added[[kk]]
[17:36:35.581]                   NAME <- NAMES[[kk]]
[17:36:35.581]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.581]                     next
[17:36:35.581]                   args[[name]] <- ""
[17:36:35.581]                 }
[17:36:35.581]                 NAMES <- toupper(removed)
[17:36:35.581]                 for (kk in seq_along(NAMES)) {
[17:36:35.581]                   name <- removed[[kk]]
[17:36:35.581]                   NAME <- NAMES[[kk]]
[17:36:35.581]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.581]                     next
[17:36:35.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.581]                 }
[17:36:35.581]                 if (length(args) > 0) 
[17:36:35.581]                   base::do.call(base::Sys.setenv, args = args)
[17:36:35.581]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:35.581]             }
[17:36:35.581]             else {
[17:36:35.581]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:35.581]             }
[17:36:35.581]             {
[17:36:35.581]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:35.581]                   0L) {
[17:36:35.581]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:35.581]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:35.581]                   base::options(opts)
[17:36:35.581]                 }
[17:36:35.581]                 {
[17:36:35.581]                   {
[17:36:35.581]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:35.581]                     NULL
[17:36:35.581]                   }
[17:36:35.581]                   options(future.plan = NULL)
[17:36:35.581]                   if (is.na(NA_character_)) 
[17:36:35.581]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.581]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:35.581]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:35.581]                     .init = FALSE)
[17:36:35.581]                 }
[17:36:35.581]             }
[17:36:35.581]         }
[17:36:35.581]     })
[17:36:35.581]     if (TRUE) {
[17:36:35.581]         base::sink(type = "output", split = FALSE)
[17:36:35.581]         if (TRUE) {
[17:36:35.581]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:35.581]         }
[17:36:35.581]         else {
[17:36:35.581]             ...future.result["stdout"] <- base::list(NULL)
[17:36:35.581]         }
[17:36:35.581]         base::close(...future.stdout)
[17:36:35.581]         ...future.stdout <- NULL
[17:36:35.581]     }
[17:36:35.581]     ...future.result$conditions <- ...future.conditions
[17:36:35.581]     ...future.result$finished <- base::Sys.time()
[17:36:35.581]     ...future.result
[17:36:35.581] }
[17:36:35.584] assign_globals() ...
[17:36:35.585] List of 5
[17:36:35.585]  $ future.call.arguments    : list()
[17:36:35.585]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.585]  $ ...future.FUN            :function (x)  
[17:36:35.585]  $ ...future.elements_ii    :List of 1
[17:36:35.585]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:36:35.585]  $ ...future.seeds_ii       : NULL
[17:36:35.585]  $ ...future.globals.maxSize: num Inf
[17:36:35.585]  - attr(*, "resolved")= logi FALSE
[17:36:35.585]  - attr(*, "total_size")= num NA
[17:36:35.585]  - attr(*, "where")=List of 5
[17:36:35.585]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:35.585]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:35.585]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:35.585]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:35.585]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:35.585]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.585]  - attr(*, "already-done")= logi TRUE
[17:36:35.594] - copied ‘future.call.arguments’ to environment
[17:36:35.594] - copied ‘...future.FUN’ to environment
[17:36:35.594] - copied ‘...future.elements_ii’ to environment
[17:36:35.594] - copied ‘...future.seeds_ii’ to environment
[17:36:35.595] - copied ‘...future.globals.maxSize’ to environment
[17:36:35.595] assign_globals() ... done
[17:36:35.595] requestCore(): workers = 2
[17:36:35.597] MulticoreFuture started
[17:36:35.598] - Launch lazy future ... done
[17:36:35.598] run() for ‘MulticoreFuture’ ... done
[17:36:35.598] Created future:
[17:36:35.598] plan(): Setting new future strategy stack:
[17:36:35.599] List of future strategies:
[17:36:35.599] 1. sequential:
[17:36:35.599]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:35.599]    - tweaked: FALSE
[17:36:35.599]    - call: NULL
[17:36:35.600] plan(): nbrOfWorkers() = 1
[17:36:35.602] plan(): Setting new future strategy stack:
[17:36:35.602] List of future strategies:
[17:36:35.602] 1. multicore:
[17:36:35.602]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:35.602]    - tweaked: FALSE
[17:36:35.602]    - call: plan(strategy)
[17:36:35.607] plan(): nbrOfWorkers() = 2
[17:36:35.598] MulticoreFuture:
[17:36:35.598] Label: ‘future_apply-2’
[17:36:35.598] Expression:
[17:36:35.598] {
[17:36:35.598]     do.call(function(...) {
[17:36:35.598]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.598]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.598]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.598]             on.exit(options(oopts), add = TRUE)
[17:36:35.598]         }
[17:36:35.598]         {
[17:36:35.598]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.598]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.598]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.598]             })
[17:36:35.598]         }
[17:36:35.598]     }, args = future.call.arguments)
[17:36:35.598] }
[17:36:35.598] Lazy evaluation: FALSE
[17:36:35.598] Asynchronous evaluation: TRUE
[17:36:35.598] Local evaluation: TRUE
[17:36:35.598] Environment: R_GlobalEnv
[17:36:35.598] Capture standard output: TRUE
[17:36:35.598] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:35.598] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:35.598] Packages: <none>
[17:36:35.598] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:35.598] Resolved: TRUE
[17:36:35.598] Value: <not collected>
[17:36:35.598] Conditions captured: <none>
[17:36:35.598] Early signaling: FALSE
[17:36:35.598] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:35.598] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.608] Chunk #2 of 2 ... DONE
[17:36:35.608] Launching 2 futures (chunks) ... DONE
[17:36:35.608] Resolving 2 futures (chunks) ...
[17:36:35.609] resolve() on list ...
[17:36:35.609]  recursive: 0
[17:36:35.609]  length: 2
[17:36:35.609] 
[17:36:35.609] Future #1
[17:36:35.610] result() for MulticoreFuture ...
[17:36:35.610] result() for MulticoreFuture ...
[17:36:35.611] result() for MulticoreFuture ... done
[17:36:35.611] result() for MulticoreFuture ... done
[17:36:35.611] result() for MulticoreFuture ...
[17:36:35.611] result() for MulticoreFuture ... done
[17:36:35.611] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:36:35.611] - nx: 2
[17:36:35.611] - relay: TRUE
[17:36:35.612] - stdout: TRUE
[17:36:35.612] - signal: TRUE
[17:36:35.612] - resignal: FALSE
[17:36:35.612] - force: TRUE
[17:36:35.612] - relayed: [n=2] FALSE, FALSE
[17:36:35.612] - queued futures: [n=2] FALSE, FALSE
[17:36:35.613]  - until=1
[17:36:35.613]  - relaying element #1
[17:36:35.613] result() for MulticoreFuture ...
[17:36:35.613] result() for MulticoreFuture ... done
[17:36:35.613] result() for MulticoreFuture ...
[17:36:35.613] result() for MulticoreFuture ... done
[17:36:35.613] result() for MulticoreFuture ...
[17:36:35.614] result() for MulticoreFuture ... done
[17:36:35.614] result() for MulticoreFuture ...
[17:36:35.614] result() for MulticoreFuture ... done
[17:36:35.614] - relayed: [n=2] TRUE, FALSE
[17:36:35.614] - queued futures: [n=2] TRUE, FALSE
[17:36:35.614] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:36:35.615]  length: 1 (resolved future 1)
[17:36:35.615] Future #2
[17:36:35.615] result() for MulticoreFuture ...
[17:36:35.616] result() for MulticoreFuture ...
[17:36:35.616] result() for MulticoreFuture ... done
[17:36:35.616] result() for MulticoreFuture ... done
[17:36:35.616] result() for MulticoreFuture ...
[17:36:35.616] result() for MulticoreFuture ... done
[17:36:35.617] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:36:35.617] - nx: 2
[17:36:35.617] - relay: TRUE
[17:36:35.617] - stdout: TRUE
[17:36:35.617] - signal: TRUE
[17:36:35.617] - resignal: FALSE
[17:36:35.617] - force: TRUE
[17:36:35.617] - relayed: [n=2] TRUE, FALSE
[17:36:35.618] - queued futures: [n=2] TRUE, FALSE
[17:36:35.618]  - until=2
[17:36:35.618]  - relaying element #2
[17:36:35.618] result() for MulticoreFuture ...
[17:36:35.618] result() for MulticoreFuture ... done
[17:36:35.618] result() for MulticoreFuture ...
[17:36:35.618] result() for MulticoreFuture ... done
[17:36:35.618] result() for MulticoreFuture ...
[17:36:35.619] result() for MulticoreFuture ... done
[17:36:35.619] result() for MulticoreFuture ...
[17:36:35.619] result() for MulticoreFuture ... done
[17:36:35.619] - relayed: [n=2] TRUE, TRUE
[17:36:35.619] - queued futures: [n=2] TRUE, TRUE
[17:36:35.619] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:36:35.619]  length: 0 (resolved future 2)
[17:36:35.619] Relaying remaining futures
[17:36:35.619] signalConditionsASAP(NULL, pos=0) ...
[17:36:35.620] - nx: 2
[17:36:35.620] - relay: TRUE
[17:36:35.620] - stdout: TRUE
[17:36:35.620] - signal: TRUE
[17:36:35.620] - resignal: FALSE
[17:36:35.620] - force: TRUE
[17:36:35.620] - relayed: [n=2] TRUE, TRUE
[17:36:35.620] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:35.620] - relayed: [n=2] TRUE, TRUE
[17:36:35.621] - queued futures: [n=2] TRUE, TRUE
[17:36:35.621] signalConditionsASAP(NULL, pos=0) ... done
[17:36:35.621] resolve() on list ... DONE
[17:36:35.621] result() for MulticoreFuture ...
[17:36:35.621] result() for MulticoreFuture ... done
[17:36:35.621] result() for MulticoreFuture ...
[17:36:35.621] result() for MulticoreFuture ... done
[17:36:35.621] result() for MulticoreFuture ...
[17:36:35.622] result() for MulticoreFuture ... done
[17:36:35.622] result() for MulticoreFuture ...
[17:36:35.622] result() for MulticoreFuture ... done
[17:36:35.622]  - Number of value chunks collected: 2
[17:36:35.622] Resolving 2 futures (chunks) ... DONE
[17:36:35.622] Reducing values from 2 chunks ...
[17:36:35.622]  - Number of values collected after concatenation: 2
[17:36:35.622]  - Number of values expected: 2
[17:36:35.622] Reducing values from 2 chunks ... DONE
[17:36:35.623] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[17:36:35.623] getGlobalsAndPackagesXApply() ...
[17:36:35.623]  - future.globals: TRUE
[17:36:35.623] getGlobalsAndPackages() ...
[17:36:35.623] Searching for globals...
[17:36:35.625] - globals found: [1] ‘FUN’
[17:36:35.625] Searching for globals ... DONE
[17:36:35.625] Resolving globals: FALSE
[17:36:35.625] The total size of the 1 globals is 848 bytes (848 bytes)
[17:36:35.626] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:36:35.626] - globals: [1] ‘FUN’
[17:36:35.626] 
[17:36:35.626] getGlobalsAndPackages() ... DONE
[17:36:35.626]  - globals found/used: [n=1] ‘FUN’
[17:36:35.626]  - needed namespaces: [n=0] 
[17:36:35.627] Finding globals ... DONE
[17:36:35.627]  - use_args: TRUE
[17:36:35.627]  - Getting '...' globals ...
[17:36:35.627] resolve() on list ...
[17:36:35.627]  recursive: 0
[17:36:35.627]  length: 1
[17:36:35.628]  elements: ‘...’
[17:36:35.628]  length: 0 (resolved future 1)
[17:36:35.628] resolve() on list ... DONE
[17:36:35.628]    - '...' content: [n=0] 
[17:36:35.628] List of 1
[17:36:35.628]  $ ...: list()
[17:36:35.628]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.628]  - attr(*, "where")=List of 1
[17:36:35.628]   ..$ ...:<environment: 0x556d75c58908> 
[17:36:35.628]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.628]  - attr(*, "resolved")= logi TRUE
[17:36:35.628]  - attr(*, "total_size")= num NA
[17:36:35.635]  - Getting '...' globals ... DONE
[17:36:35.635] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:35.635] List of 2
[17:36:35.635]  $ ...future.FUN:function (x)  
[17:36:35.635]  $ ...          : list()
[17:36:35.635]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.635]  - attr(*, "where")=List of 2
[17:36:35.635]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:35.635]   ..$ ...          :<environment: 0x556d75c58908> 
[17:36:35.635]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.635]  - attr(*, "resolved")= logi FALSE
[17:36:35.635]  - attr(*, "total_size")= num 848
[17:36:35.638] Packages to be attached in all futures: [n=0] 
[17:36:35.638] getGlobalsAndPackagesXApply() ... DONE
[17:36:35.642] future_lapply() ...
[17:36:35.646] Number of chunks: 2
[17:36:35.646] getGlobalsAndPackagesXApply() ...
[17:36:35.646]  - future.globals: <name-value list> with names ‘list()’
[17:36:35.647]  - use_args: TRUE
[17:36:35.647] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:35.647] List of 2
[17:36:35.647]  $ ...          : list()
[17:36:35.647]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.647]  $ ...future.FUN:function (x)  
[17:36:35.647]  - attr(*, "where")=List of 2
[17:36:35.647]   ..$ ...          :<environment: 0x556d75c58908> 
[17:36:35.647]   ..$ ...future.FUN:<environment: namespace:base> 
[17:36:35.647]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.647]  - attr(*, "resolved")= logi FALSE
[17:36:35.647]  - attr(*, "total_size")= num NA
[17:36:35.650] Packages to be attached in all futures: [n=0] 
[17:36:35.650] getGlobalsAndPackagesXApply() ... DONE
[17:36:35.650] Number of futures (= number of chunks): 2
[17:36:35.651] Launching 2 futures (chunks) ...
[17:36:35.651] Chunk #1 of 2 ...
[17:36:35.651]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:35.651]  - seeds: <none>
[17:36:35.651]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.651] getGlobalsAndPackages() ...
[17:36:35.651] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.651] Resolving globals: FALSE
[17:36:35.652] Tweak future expression to call with '...' arguments ...
[17:36:35.652] {
[17:36:35.652]     do.call(function(...) {
[17:36:35.652]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.652]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.652]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.652]             on.exit(options(oopts), add = TRUE)
[17:36:35.652]         }
[17:36:35.652]         {
[17:36:35.652]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.652]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.652]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.652]             })
[17:36:35.652]         }
[17:36:35.652]     }, args = future.call.arguments)
[17:36:35.652] }
[17:36:35.652] Tweak future expression to call with '...' arguments ... DONE
[17:36:35.652] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.652] 
[17:36:35.653] getGlobalsAndPackages() ... DONE
[17:36:35.653] run() for ‘Future’ ...
[17:36:35.653] - state: ‘created’
[17:36:35.653] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:35.657] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.657] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:35.657]   - Field: ‘label’
[17:36:35.657]   - Field: ‘local’
[17:36:35.657]   - Field: ‘owner’
[17:36:35.658]   - Field: ‘envir’
[17:36:35.658]   - Field: ‘workers’
[17:36:35.658]   - Field: ‘packages’
[17:36:35.658]   - Field: ‘gc’
[17:36:35.658]   - Field: ‘job’
[17:36:35.658]   - Field: ‘conditions’
[17:36:35.658]   - Field: ‘expr’
[17:36:35.658]   - Field: ‘uuid’
[17:36:35.658]   - Field: ‘seed’
[17:36:35.658]   - Field: ‘version’
[17:36:35.659]   - Field: ‘result’
[17:36:35.659]   - Field: ‘asynchronous’
[17:36:35.659]   - Field: ‘calls’
[17:36:35.659]   - Field: ‘globals’
[17:36:35.659]   - Field: ‘stdout’
[17:36:35.659]   - Field: ‘earlySignal’
[17:36:35.659]   - Field: ‘lazy’
[17:36:35.659]   - Field: ‘state’
[17:36:35.659] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:35.659] - Launch lazy future ...
[17:36:35.660] Packages needed by the future expression (n = 0): <none>
[17:36:35.660] Packages needed by future strategies (n = 0): <none>
[17:36:35.660] {
[17:36:35.660]     {
[17:36:35.660]         {
[17:36:35.660]             ...future.startTime <- base::Sys.time()
[17:36:35.660]             {
[17:36:35.660]                 {
[17:36:35.660]                   {
[17:36:35.660]                     {
[17:36:35.660]                       base::local({
[17:36:35.660]                         has_future <- base::requireNamespace("future", 
[17:36:35.660]                           quietly = TRUE)
[17:36:35.660]                         if (has_future) {
[17:36:35.660]                           ns <- base::getNamespace("future")
[17:36:35.660]                           version <- ns[[".package"]][["version"]]
[17:36:35.660]                           if (is.null(version)) 
[17:36:35.660]                             version <- utils::packageVersion("future")
[17:36:35.660]                         }
[17:36:35.660]                         else {
[17:36:35.660]                           version <- NULL
[17:36:35.660]                         }
[17:36:35.660]                         if (!has_future || version < "1.8.0") {
[17:36:35.660]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:35.660]                             "", base::R.version$version.string), 
[17:36:35.660]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:35.660]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:35.660]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:35.660]                               "release", "version")], collapse = " "), 
[17:36:35.660]                             hostname = base::Sys.info()[["nodename"]])
[17:36:35.660]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:35.660]                             info)
[17:36:35.660]                           info <- base::paste(info, collapse = "; ")
[17:36:35.660]                           if (!has_future) {
[17:36:35.660]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:35.660]                               info)
[17:36:35.660]                           }
[17:36:35.660]                           else {
[17:36:35.660]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:35.660]                               info, version)
[17:36:35.660]                           }
[17:36:35.660]                           base::stop(msg)
[17:36:35.660]                         }
[17:36:35.660]                       })
[17:36:35.660]                     }
[17:36:35.660]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:35.660]                     base::options(mc.cores = 1L)
[17:36:35.660]                   }
[17:36:35.660]                   ...future.strategy.old <- future::plan("list")
[17:36:35.660]                   options(future.plan = NULL)
[17:36:35.660]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.660]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:35.660]                 }
[17:36:35.660]                 ...future.workdir <- getwd()
[17:36:35.660]             }
[17:36:35.660]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:35.660]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:35.660]         }
[17:36:35.660]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:35.660]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:35.660]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:35.660]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:35.660]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:35.660]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:35.660]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:35.660]             base::names(...future.oldOptions))
[17:36:35.660]     }
[17:36:35.660]     if (FALSE) {
[17:36:35.660]     }
[17:36:35.660]     else {
[17:36:35.660]         if (TRUE) {
[17:36:35.660]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:35.660]                 open = "w")
[17:36:35.660]         }
[17:36:35.660]         else {
[17:36:35.660]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:35.660]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:35.660]         }
[17:36:35.660]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:35.660]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:35.660]             base::sink(type = "output", split = FALSE)
[17:36:35.660]             base::close(...future.stdout)
[17:36:35.660]         }, add = TRUE)
[17:36:35.660]     }
[17:36:35.660]     ...future.frame <- base::sys.nframe()
[17:36:35.660]     ...future.conditions <- base::list()
[17:36:35.660]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:35.660]     if (FALSE) {
[17:36:35.660]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:35.660]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:35.660]     }
[17:36:35.660]     ...future.result <- base::tryCatch({
[17:36:35.660]         base::withCallingHandlers({
[17:36:35.660]             ...future.value <- base::withVisible(base::local({
[17:36:35.660]                 withCallingHandlers({
[17:36:35.660]                   {
[17:36:35.660]                     do.call(function(...) {
[17:36:35.660]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.660]                       if (!identical(...future.globals.maxSize.org, 
[17:36:35.660]                         ...future.globals.maxSize)) {
[17:36:35.660]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.660]                         on.exit(options(oopts), add = TRUE)
[17:36:35.660]                       }
[17:36:35.660]                       {
[17:36:35.660]                         lapply(seq_along(...future.elements_ii), 
[17:36:35.660]                           FUN = function(jj) {
[17:36:35.660]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.660]                             ...future.FUN(...future.X_jj, ...)
[17:36:35.660]                           })
[17:36:35.660]                       }
[17:36:35.660]                     }, args = future.call.arguments)
[17:36:35.660]                   }
[17:36:35.660]                 }, immediateCondition = function(cond) {
[17:36:35.660]                   save_rds <- function (object, pathname, ...) 
[17:36:35.660]                   {
[17:36:35.660]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:35.660]                     if (file_test("-f", pathname_tmp)) {
[17:36:35.660]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.660]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:35.660]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.660]                         fi_tmp[["mtime"]])
[17:36:35.660]                     }
[17:36:35.660]                     tryCatch({
[17:36:35.660]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:35.660]                     }, error = function(ex) {
[17:36:35.660]                       msg <- conditionMessage(ex)
[17:36:35.660]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.660]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:35.660]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.660]                         fi_tmp[["mtime"]], msg)
[17:36:35.660]                       ex$message <- msg
[17:36:35.660]                       stop(ex)
[17:36:35.660]                     })
[17:36:35.660]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:35.660]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:35.660]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:35.660]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.660]                       fi <- file.info(pathname)
[17:36:35.660]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:35.660]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.660]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:35.660]                         fi[["size"]], fi[["mtime"]])
[17:36:35.660]                       stop(msg)
[17:36:35.660]                     }
[17:36:35.660]                     invisible(pathname)
[17:36:35.660]                   }
[17:36:35.660]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:35.660]                     rootPath = tempdir()) 
[17:36:35.660]                   {
[17:36:35.660]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:35.660]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:35.660]                       tmpdir = path, fileext = ".rds")
[17:36:35.660]                     save_rds(obj, file)
[17:36:35.660]                   }
[17:36:35.660]                   saveImmediateCondition(cond, path = "/tmp/RtmpABg8SG/.future/immediateConditions")
[17:36:35.660]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.660]                   {
[17:36:35.660]                     inherits <- base::inherits
[17:36:35.660]                     invokeRestart <- base::invokeRestart
[17:36:35.660]                     is.null <- base::is.null
[17:36:35.660]                     muffled <- FALSE
[17:36:35.660]                     if (inherits(cond, "message")) {
[17:36:35.660]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:35.660]                       if (muffled) 
[17:36:35.660]                         invokeRestart("muffleMessage")
[17:36:35.660]                     }
[17:36:35.660]                     else if (inherits(cond, "warning")) {
[17:36:35.660]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:35.660]                       if (muffled) 
[17:36:35.660]                         invokeRestart("muffleWarning")
[17:36:35.660]                     }
[17:36:35.660]                     else if (inherits(cond, "condition")) {
[17:36:35.660]                       if (!is.null(pattern)) {
[17:36:35.660]                         computeRestarts <- base::computeRestarts
[17:36:35.660]                         grepl <- base::grepl
[17:36:35.660]                         restarts <- computeRestarts(cond)
[17:36:35.660]                         for (restart in restarts) {
[17:36:35.660]                           name <- restart$name
[17:36:35.660]                           if (is.null(name)) 
[17:36:35.660]                             next
[17:36:35.660]                           if (!grepl(pattern, name)) 
[17:36:35.660]                             next
[17:36:35.660]                           invokeRestart(restart)
[17:36:35.660]                           muffled <- TRUE
[17:36:35.660]                           break
[17:36:35.660]                         }
[17:36:35.660]                       }
[17:36:35.660]                     }
[17:36:35.660]                     invisible(muffled)
[17:36:35.660]                   }
[17:36:35.660]                   muffleCondition(cond)
[17:36:35.660]                 })
[17:36:35.660]             }))
[17:36:35.660]             future::FutureResult(value = ...future.value$value, 
[17:36:35.660]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.660]                   ...future.rng), globalenv = if (FALSE) 
[17:36:35.660]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:35.660]                     ...future.globalenv.names))
[17:36:35.660]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:35.660]         }, condition = base::local({
[17:36:35.660]             c <- base::c
[17:36:35.660]             inherits <- base::inherits
[17:36:35.660]             invokeRestart <- base::invokeRestart
[17:36:35.660]             length <- base::length
[17:36:35.660]             list <- base::list
[17:36:35.660]             seq.int <- base::seq.int
[17:36:35.660]             signalCondition <- base::signalCondition
[17:36:35.660]             sys.calls <- base::sys.calls
[17:36:35.660]             `[[` <- base::`[[`
[17:36:35.660]             `+` <- base::`+`
[17:36:35.660]             `<<-` <- base::`<<-`
[17:36:35.660]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:35.660]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:35.660]                   3L)]
[17:36:35.660]             }
[17:36:35.660]             function(cond) {
[17:36:35.660]                 is_error <- inherits(cond, "error")
[17:36:35.660]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:35.660]                   NULL)
[17:36:35.660]                 if (is_error) {
[17:36:35.660]                   sessionInformation <- function() {
[17:36:35.660]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:35.660]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:35.660]                       search = base::search(), system = base::Sys.info())
[17:36:35.660]                   }
[17:36:35.660]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.660]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:35.660]                     cond$call), session = sessionInformation(), 
[17:36:35.660]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:35.660]                   signalCondition(cond)
[17:36:35.660]                 }
[17:36:35.660]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:35.660]                 "immediateCondition"))) {
[17:36:35.660]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:35.660]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.660]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:35.660]                   if (TRUE && !signal) {
[17:36:35.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.660]                     {
[17:36:35.660]                       inherits <- base::inherits
[17:36:35.660]                       invokeRestart <- base::invokeRestart
[17:36:35.660]                       is.null <- base::is.null
[17:36:35.660]                       muffled <- FALSE
[17:36:35.660]                       if (inherits(cond, "message")) {
[17:36:35.660]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.660]                         if (muffled) 
[17:36:35.660]                           invokeRestart("muffleMessage")
[17:36:35.660]                       }
[17:36:35.660]                       else if (inherits(cond, "warning")) {
[17:36:35.660]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.660]                         if (muffled) 
[17:36:35.660]                           invokeRestart("muffleWarning")
[17:36:35.660]                       }
[17:36:35.660]                       else if (inherits(cond, "condition")) {
[17:36:35.660]                         if (!is.null(pattern)) {
[17:36:35.660]                           computeRestarts <- base::computeRestarts
[17:36:35.660]                           grepl <- base::grepl
[17:36:35.660]                           restarts <- computeRestarts(cond)
[17:36:35.660]                           for (restart in restarts) {
[17:36:35.660]                             name <- restart$name
[17:36:35.660]                             if (is.null(name)) 
[17:36:35.660]                               next
[17:36:35.660]                             if (!grepl(pattern, name)) 
[17:36:35.660]                               next
[17:36:35.660]                             invokeRestart(restart)
[17:36:35.660]                             muffled <- TRUE
[17:36:35.660]                             break
[17:36:35.660]                           }
[17:36:35.660]                         }
[17:36:35.660]                       }
[17:36:35.660]                       invisible(muffled)
[17:36:35.660]                     }
[17:36:35.660]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.660]                   }
[17:36:35.660]                 }
[17:36:35.660]                 else {
[17:36:35.660]                   if (TRUE) {
[17:36:35.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.660]                     {
[17:36:35.660]                       inherits <- base::inherits
[17:36:35.660]                       invokeRestart <- base::invokeRestart
[17:36:35.660]                       is.null <- base::is.null
[17:36:35.660]                       muffled <- FALSE
[17:36:35.660]                       if (inherits(cond, "message")) {
[17:36:35.660]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.660]                         if (muffled) 
[17:36:35.660]                           invokeRestart("muffleMessage")
[17:36:35.660]                       }
[17:36:35.660]                       else if (inherits(cond, "warning")) {
[17:36:35.660]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.660]                         if (muffled) 
[17:36:35.660]                           invokeRestart("muffleWarning")
[17:36:35.660]                       }
[17:36:35.660]                       else if (inherits(cond, "condition")) {
[17:36:35.660]                         if (!is.null(pattern)) {
[17:36:35.660]                           computeRestarts <- base::computeRestarts
[17:36:35.660]                           grepl <- base::grepl
[17:36:35.660]                           restarts <- computeRestarts(cond)
[17:36:35.660]                           for (restart in restarts) {
[17:36:35.660]                             name <- restart$name
[17:36:35.660]                             if (is.null(name)) 
[17:36:35.660]                               next
[17:36:35.660]                             if (!grepl(pattern, name)) 
[17:36:35.660]                               next
[17:36:35.660]                             invokeRestart(restart)
[17:36:35.660]                             muffled <- TRUE
[17:36:35.660]                             break
[17:36:35.660]                           }
[17:36:35.660]                         }
[17:36:35.660]                       }
[17:36:35.660]                       invisible(muffled)
[17:36:35.660]                     }
[17:36:35.660]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.660]                   }
[17:36:35.660]                 }
[17:36:35.660]             }
[17:36:35.660]         }))
[17:36:35.660]     }, error = function(ex) {
[17:36:35.660]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:35.660]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.660]                 ...future.rng), started = ...future.startTime, 
[17:36:35.660]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:35.660]             version = "1.8"), class = "FutureResult")
[17:36:35.660]     }, finally = {
[17:36:35.660]         if (!identical(...future.workdir, getwd())) 
[17:36:35.660]             setwd(...future.workdir)
[17:36:35.660]         {
[17:36:35.660]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:35.660]                 ...future.oldOptions$nwarnings <- NULL
[17:36:35.660]             }
[17:36:35.660]             base::options(...future.oldOptions)
[17:36:35.660]             if (.Platform$OS.type == "windows") {
[17:36:35.660]                 old_names <- names(...future.oldEnvVars)
[17:36:35.660]                 envs <- base::Sys.getenv()
[17:36:35.660]                 names <- names(envs)
[17:36:35.660]                 common <- intersect(names, old_names)
[17:36:35.660]                 added <- setdiff(names, old_names)
[17:36:35.660]                 removed <- setdiff(old_names, names)
[17:36:35.660]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:35.660]                   envs[common]]
[17:36:35.660]                 NAMES <- toupper(changed)
[17:36:35.660]                 args <- list()
[17:36:35.660]                 for (kk in seq_along(NAMES)) {
[17:36:35.660]                   name <- changed[[kk]]
[17:36:35.660]                   NAME <- NAMES[[kk]]
[17:36:35.660]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.660]                     next
[17:36:35.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.660]                 }
[17:36:35.660]                 NAMES <- toupper(added)
[17:36:35.660]                 for (kk in seq_along(NAMES)) {
[17:36:35.660]                   name <- added[[kk]]
[17:36:35.660]                   NAME <- NAMES[[kk]]
[17:36:35.660]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.660]                     next
[17:36:35.660]                   args[[name]] <- ""
[17:36:35.660]                 }
[17:36:35.660]                 NAMES <- toupper(removed)
[17:36:35.660]                 for (kk in seq_along(NAMES)) {
[17:36:35.660]                   name <- removed[[kk]]
[17:36:35.660]                   NAME <- NAMES[[kk]]
[17:36:35.660]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.660]                     next
[17:36:35.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.660]                 }
[17:36:35.660]                 if (length(args) > 0) 
[17:36:35.660]                   base::do.call(base::Sys.setenv, args = args)
[17:36:35.660]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:35.660]             }
[17:36:35.660]             else {
[17:36:35.660]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:35.660]             }
[17:36:35.660]             {
[17:36:35.660]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:35.660]                   0L) {
[17:36:35.660]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:35.660]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:35.660]                   base::options(opts)
[17:36:35.660]                 }
[17:36:35.660]                 {
[17:36:35.660]                   {
[17:36:35.660]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:35.660]                     NULL
[17:36:35.660]                   }
[17:36:35.660]                   options(future.plan = NULL)
[17:36:35.660]                   if (is.na(NA_character_)) 
[17:36:35.660]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.660]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:35.660]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:35.660]                     .init = FALSE)
[17:36:35.660]                 }
[17:36:35.660]             }
[17:36:35.660]         }
[17:36:35.660]     })
[17:36:35.660]     if (TRUE) {
[17:36:35.660]         base::sink(type = "output", split = FALSE)
[17:36:35.660]         if (TRUE) {
[17:36:35.660]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:35.660]         }
[17:36:35.660]         else {
[17:36:35.660]             ...future.result["stdout"] <- base::list(NULL)
[17:36:35.660]         }
[17:36:35.660]         base::close(...future.stdout)
[17:36:35.660]         ...future.stdout <- NULL
[17:36:35.660]     }
[17:36:35.660]     ...future.result$conditions <- ...future.conditions
[17:36:35.660]     ...future.result$finished <- base::Sys.time()
[17:36:35.660]     ...future.result
[17:36:35.660] }
[17:36:35.663] assign_globals() ...
[17:36:35.663] List of 5
[17:36:35.663]  $ future.call.arguments    : list()
[17:36:35.663]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.663]  $ ...future.FUN            :function (x)  
[17:36:35.663]  $ ...future.elements_ii    :List of 3
[17:36:35.663]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:36:35.663]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:36:35.663]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:36:35.663]  $ ...future.seeds_ii       : NULL
[17:36:35.663]  $ ...future.globals.maxSize: num Inf
[17:36:35.663]  - attr(*, "resolved")= logi FALSE
[17:36:35.663]  - attr(*, "total_size")= num NA
[17:36:35.663]  - attr(*, "where")=List of 5
[17:36:35.663]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:35.663]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:35.663]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:35.663]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:35.663]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:35.663]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.663]  - attr(*, "already-done")= logi TRUE
[17:36:35.671] - copied ‘future.call.arguments’ to environment
[17:36:35.671] - copied ‘...future.FUN’ to environment
[17:36:35.671] - copied ‘...future.elements_ii’ to environment
[17:36:35.671] - copied ‘...future.seeds_ii’ to environment
[17:36:35.671] - copied ‘...future.globals.maxSize’ to environment
[17:36:35.671] assign_globals() ... done
[17:36:35.671] requestCore(): workers = 2
[17:36:35.674] MulticoreFuture started
[17:36:35.674] - Launch lazy future ... done
[17:36:35.674] run() for ‘MulticoreFuture’ ... done
[17:36:35.675] Created future:
[17:36:35.675] plan(): Setting new future strategy stack:
[17:36:35.675] List of future strategies:
[17:36:35.675] 1. sequential:
[17:36:35.675]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:35.675]    - tweaked: FALSE
[17:36:35.675]    - call: NULL
[17:36:35.676] plan(): nbrOfWorkers() = 1
[17:36:35.678] plan(): Setting new future strategy stack:
[17:36:35.678] List of future strategies:
[17:36:35.678] 1. multicore:
[17:36:35.678]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:35.678]    - tweaked: FALSE
[17:36:35.678]    - call: plan(strategy)
[17:36:35.684] plan(): nbrOfWorkers() = 2
[17:36:35.675] MulticoreFuture:
[17:36:35.675] Label: ‘future_apply-1’
[17:36:35.675] Expression:
[17:36:35.675] {
[17:36:35.675]     do.call(function(...) {
[17:36:35.675]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.675]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.675]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.675]             on.exit(options(oopts), add = TRUE)
[17:36:35.675]         }
[17:36:35.675]         {
[17:36:35.675]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.675]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.675]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.675]             })
[17:36:35.675]         }
[17:36:35.675]     }, args = future.call.arguments)
[17:36:35.675] }
[17:36:35.675] Lazy evaluation: FALSE
[17:36:35.675] Asynchronous evaluation: TRUE
[17:36:35.675] Local evaluation: TRUE
[17:36:35.675] Environment: R_GlobalEnv
[17:36:35.675] Capture standard output: TRUE
[17:36:35.675] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:35.675] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:35.675] Packages: <none>
[17:36:35.675] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:35.675] Resolved: TRUE
[17:36:35.675] Value: <not collected>
[17:36:35.675] Conditions captured: <none>
[17:36:35.675] Early signaling: FALSE
[17:36:35.675] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:35.675] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.685] Chunk #1 of 2 ... DONE
[17:36:35.685] Chunk #2 of 2 ...
[17:36:35.685]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:35.686]  - seeds: <none>
[17:36:35.686]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.686] getGlobalsAndPackages() ...
[17:36:35.686] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.686] Resolving globals: FALSE
[17:36:35.686] Tweak future expression to call with '...' arguments ...
[17:36:35.687] {
[17:36:35.687]     do.call(function(...) {
[17:36:35.687]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.687]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.687]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.687]             on.exit(options(oopts), add = TRUE)
[17:36:35.687]         }
[17:36:35.687]         {
[17:36:35.687]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.687]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.687]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.687]             })
[17:36:35.687]         }
[17:36:35.687]     }, args = future.call.arguments)
[17:36:35.687] }
[17:36:35.687] Tweak future expression to call with '...' arguments ... DONE
[17:36:35.688] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.688] 
[17:36:35.688] getGlobalsAndPackages() ... DONE
[17:36:35.688] run() for ‘Future’ ...
[17:36:35.689] - state: ‘created’
[17:36:35.689] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:35.693] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.693] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:35.694]   - Field: ‘label’
[17:36:35.694]   - Field: ‘local’
[17:36:35.694]   - Field: ‘owner’
[17:36:35.694]   - Field: ‘envir’
[17:36:35.694]   - Field: ‘workers’
[17:36:35.694]   - Field: ‘packages’
[17:36:35.694]   - Field: ‘gc’
[17:36:35.695]   - Field: ‘job’
[17:36:35.695]   - Field: ‘conditions’
[17:36:35.695]   - Field: ‘expr’
[17:36:35.695]   - Field: ‘uuid’
[17:36:35.695]   - Field: ‘seed’
[17:36:35.695]   - Field: ‘version’
[17:36:35.696]   - Field: ‘result’
[17:36:35.696]   - Field: ‘asynchronous’
[17:36:35.696]   - Field: ‘calls’
[17:36:35.696]   - Field: ‘globals’
[17:36:35.696]   - Field: ‘stdout’
[17:36:35.696]   - Field: ‘earlySignal’
[17:36:35.696]   - Field: ‘lazy’
[17:36:35.697]   - Field: ‘state’
[17:36:35.697] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:35.697] - Launch lazy future ...
[17:36:35.697] Packages needed by the future expression (n = 0): <none>
[17:36:35.698] Packages needed by future strategies (n = 0): <none>
[17:36:35.698] {
[17:36:35.698]     {
[17:36:35.698]         {
[17:36:35.698]             ...future.startTime <- base::Sys.time()
[17:36:35.698]             {
[17:36:35.698]                 {
[17:36:35.698]                   {
[17:36:35.698]                     {
[17:36:35.698]                       base::local({
[17:36:35.698]                         has_future <- base::requireNamespace("future", 
[17:36:35.698]                           quietly = TRUE)
[17:36:35.698]                         if (has_future) {
[17:36:35.698]                           ns <- base::getNamespace("future")
[17:36:35.698]                           version <- ns[[".package"]][["version"]]
[17:36:35.698]                           if (is.null(version)) 
[17:36:35.698]                             version <- utils::packageVersion("future")
[17:36:35.698]                         }
[17:36:35.698]                         else {
[17:36:35.698]                           version <- NULL
[17:36:35.698]                         }
[17:36:35.698]                         if (!has_future || version < "1.8.0") {
[17:36:35.698]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:35.698]                             "", base::R.version$version.string), 
[17:36:35.698]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:35.698]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:35.698]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:35.698]                               "release", "version")], collapse = " "), 
[17:36:35.698]                             hostname = base::Sys.info()[["nodename"]])
[17:36:35.698]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:35.698]                             info)
[17:36:35.698]                           info <- base::paste(info, collapse = "; ")
[17:36:35.698]                           if (!has_future) {
[17:36:35.698]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:35.698]                               info)
[17:36:35.698]                           }
[17:36:35.698]                           else {
[17:36:35.698]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:35.698]                               info, version)
[17:36:35.698]                           }
[17:36:35.698]                           base::stop(msg)
[17:36:35.698]                         }
[17:36:35.698]                       })
[17:36:35.698]                     }
[17:36:35.698]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:35.698]                     base::options(mc.cores = 1L)
[17:36:35.698]                   }
[17:36:35.698]                   ...future.strategy.old <- future::plan("list")
[17:36:35.698]                   options(future.plan = NULL)
[17:36:35.698]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.698]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:35.698]                 }
[17:36:35.698]                 ...future.workdir <- getwd()
[17:36:35.698]             }
[17:36:35.698]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:35.698]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:35.698]         }
[17:36:35.698]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:35.698]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:35.698]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:35.698]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:35.698]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:35.698]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:35.698]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:35.698]             base::names(...future.oldOptions))
[17:36:35.698]     }
[17:36:35.698]     if (FALSE) {
[17:36:35.698]     }
[17:36:35.698]     else {
[17:36:35.698]         if (TRUE) {
[17:36:35.698]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:35.698]                 open = "w")
[17:36:35.698]         }
[17:36:35.698]         else {
[17:36:35.698]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:35.698]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:35.698]         }
[17:36:35.698]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:35.698]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:35.698]             base::sink(type = "output", split = FALSE)
[17:36:35.698]             base::close(...future.stdout)
[17:36:35.698]         }, add = TRUE)
[17:36:35.698]     }
[17:36:35.698]     ...future.frame <- base::sys.nframe()
[17:36:35.698]     ...future.conditions <- base::list()
[17:36:35.698]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:35.698]     if (FALSE) {
[17:36:35.698]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:35.698]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:35.698]     }
[17:36:35.698]     ...future.result <- base::tryCatch({
[17:36:35.698]         base::withCallingHandlers({
[17:36:35.698]             ...future.value <- base::withVisible(base::local({
[17:36:35.698]                 withCallingHandlers({
[17:36:35.698]                   {
[17:36:35.698]                     do.call(function(...) {
[17:36:35.698]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.698]                       if (!identical(...future.globals.maxSize.org, 
[17:36:35.698]                         ...future.globals.maxSize)) {
[17:36:35.698]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.698]                         on.exit(options(oopts), add = TRUE)
[17:36:35.698]                       }
[17:36:35.698]                       {
[17:36:35.698]                         lapply(seq_along(...future.elements_ii), 
[17:36:35.698]                           FUN = function(jj) {
[17:36:35.698]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.698]                             ...future.FUN(...future.X_jj, ...)
[17:36:35.698]                           })
[17:36:35.698]                       }
[17:36:35.698]                     }, args = future.call.arguments)
[17:36:35.698]                   }
[17:36:35.698]                 }, immediateCondition = function(cond) {
[17:36:35.698]                   save_rds <- function (object, pathname, ...) 
[17:36:35.698]                   {
[17:36:35.698]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:35.698]                     if (file_test("-f", pathname_tmp)) {
[17:36:35.698]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.698]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:35.698]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.698]                         fi_tmp[["mtime"]])
[17:36:35.698]                     }
[17:36:35.698]                     tryCatch({
[17:36:35.698]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:35.698]                     }, error = function(ex) {
[17:36:35.698]                       msg <- conditionMessage(ex)
[17:36:35.698]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.698]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:35.698]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.698]                         fi_tmp[["mtime"]], msg)
[17:36:35.698]                       ex$message <- msg
[17:36:35.698]                       stop(ex)
[17:36:35.698]                     })
[17:36:35.698]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:35.698]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:35.698]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:35.698]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.698]                       fi <- file.info(pathname)
[17:36:35.698]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:35.698]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.698]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:35.698]                         fi[["size"]], fi[["mtime"]])
[17:36:35.698]                       stop(msg)
[17:36:35.698]                     }
[17:36:35.698]                     invisible(pathname)
[17:36:35.698]                   }
[17:36:35.698]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:35.698]                     rootPath = tempdir()) 
[17:36:35.698]                   {
[17:36:35.698]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:35.698]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:35.698]                       tmpdir = path, fileext = ".rds")
[17:36:35.698]                     save_rds(obj, file)
[17:36:35.698]                   }
[17:36:35.698]                   saveImmediateCondition(cond, path = "/tmp/RtmpABg8SG/.future/immediateConditions")
[17:36:35.698]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.698]                   {
[17:36:35.698]                     inherits <- base::inherits
[17:36:35.698]                     invokeRestart <- base::invokeRestart
[17:36:35.698]                     is.null <- base::is.null
[17:36:35.698]                     muffled <- FALSE
[17:36:35.698]                     if (inherits(cond, "message")) {
[17:36:35.698]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:35.698]                       if (muffled) 
[17:36:35.698]                         invokeRestart("muffleMessage")
[17:36:35.698]                     }
[17:36:35.698]                     else if (inherits(cond, "warning")) {
[17:36:35.698]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:35.698]                       if (muffled) 
[17:36:35.698]                         invokeRestart("muffleWarning")
[17:36:35.698]                     }
[17:36:35.698]                     else if (inherits(cond, "condition")) {
[17:36:35.698]                       if (!is.null(pattern)) {
[17:36:35.698]                         computeRestarts <- base::computeRestarts
[17:36:35.698]                         grepl <- base::grepl
[17:36:35.698]                         restarts <- computeRestarts(cond)
[17:36:35.698]                         for (restart in restarts) {
[17:36:35.698]                           name <- restart$name
[17:36:35.698]                           if (is.null(name)) 
[17:36:35.698]                             next
[17:36:35.698]                           if (!grepl(pattern, name)) 
[17:36:35.698]                             next
[17:36:35.698]                           invokeRestart(restart)
[17:36:35.698]                           muffled <- TRUE
[17:36:35.698]                           break
[17:36:35.698]                         }
[17:36:35.698]                       }
[17:36:35.698]                     }
[17:36:35.698]                     invisible(muffled)
[17:36:35.698]                   }
[17:36:35.698]                   muffleCondition(cond)
[17:36:35.698]                 })
[17:36:35.698]             }))
[17:36:35.698]             future::FutureResult(value = ...future.value$value, 
[17:36:35.698]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.698]                   ...future.rng), globalenv = if (FALSE) 
[17:36:35.698]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:35.698]                     ...future.globalenv.names))
[17:36:35.698]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:35.698]         }, condition = base::local({
[17:36:35.698]             c <- base::c
[17:36:35.698]             inherits <- base::inherits
[17:36:35.698]             invokeRestart <- base::invokeRestart
[17:36:35.698]             length <- base::length
[17:36:35.698]             list <- base::list
[17:36:35.698]             seq.int <- base::seq.int
[17:36:35.698]             signalCondition <- base::signalCondition
[17:36:35.698]             sys.calls <- base::sys.calls
[17:36:35.698]             `[[` <- base::`[[`
[17:36:35.698]             `+` <- base::`+`
[17:36:35.698]             `<<-` <- base::`<<-`
[17:36:35.698]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:35.698]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:35.698]                   3L)]
[17:36:35.698]             }
[17:36:35.698]             function(cond) {
[17:36:35.698]                 is_error <- inherits(cond, "error")
[17:36:35.698]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:35.698]                   NULL)
[17:36:35.698]                 if (is_error) {
[17:36:35.698]                   sessionInformation <- function() {
[17:36:35.698]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:35.698]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:35.698]                       search = base::search(), system = base::Sys.info())
[17:36:35.698]                   }
[17:36:35.698]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.698]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:35.698]                     cond$call), session = sessionInformation(), 
[17:36:35.698]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:35.698]                   signalCondition(cond)
[17:36:35.698]                 }
[17:36:35.698]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:35.698]                 "immediateCondition"))) {
[17:36:35.698]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:35.698]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.698]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:35.698]                   if (TRUE && !signal) {
[17:36:35.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.698]                     {
[17:36:35.698]                       inherits <- base::inherits
[17:36:35.698]                       invokeRestart <- base::invokeRestart
[17:36:35.698]                       is.null <- base::is.null
[17:36:35.698]                       muffled <- FALSE
[17:36:35.698]                       if (inherits(cond, "message")) {
[17:36:35.698]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.698]                         if (muffled) 
[17:36:35.698]                           invokeRestart("muffleMessage")
[17:36:35.698]                       }
[17:36:35.698]                       else if (inherits(cond, "warning")) {
[17:36:35.698]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.698]                         if (muffled) 
[17:36:35.698]                           invokeRestart("muffleWarning")
[17:36:35.698]                       }
[17:36:35.698]                       else if (inherits(cond, "condition")) {
[17:36:35.698]                         if (!is.null(pattern)) {
[17:36:35.698]                           computeRestarts <- base::computeRestarts
[17:36:35.698]                           grepl <- base::grepl
[17:36:35.698]                           restarts <- computeRestarts(cond)
[17:36:35.698]                           for (restart in restarts) {
[17:36:35.698]                             name <- restart$name
[17:36:35.698]                             if (is.null(name)) 
[17:36:35.698]                               next
[17:36:35.698]                             if (!grepl(pattern, name)) 
[17:36:35.698]                               next
[17:36:35.698]                             invokeRestart(restart)
[17:36:35.698]                             muffled <- TRUE
[17:36:35.698]                             break
[17:36:35.698]                           }
[17:36:35.698]                         }
[17:36:35.698]                       }
[17:36:35.698]                       invisible(muffled)
[17:36:35.698]                     }
[17:36:35.698]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.698]                   }
[17:36:35.698]                 }
[17:36:35.698]                 else {
[17:36:35.698]                   if (TRUE) {
[17:36:35.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.698]                     {
[17:36:35.698]                       inherits <- base::inherits
[17:36:35.698]                       invokeRestart <- base::invokeRestart
[17:36:35.698]                       is.null <- base::is.null
[17:36:35.698]                       muffled <- FALSE
[17:36:35.698]                       if (inherits(cond, "message")) {
[17:36:35.698]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.698]                         if (muffled) 
[17:36:35.698]                           invokeRestart("muffleMessage")
[17:36:35.698]                       }
[17:36:35.698]                       else if (inherits(cond, "warning")) {
[17:36:35.698]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.698]                         if (muffled) 
[17:36:35.698]                           invokeRestart("muffleWarning")
[17:36:35.698]                       }
[17:36:35.698]                       else if (inherits(cond, "condition")) {
[17:36:35.698]                         if (!is.null(pattern)) {
[17:36:35.698]                           computeRestarts <- base::computeRestarts
[17:36:35.698]                           grepl <- base::grepl
[17:36:35.698]                           restarts <- computeRestarts(cond)
[17:36:35.698]                           for (restart in restarts) {
[17:36:35.698]                             name <- restart$name
[17:36:35.698]                             if (is.null(name)) 
[17:36:35.698]                               next
[17:36:35.698]                             if (!grepl(pattern, name)) 
[17:36:35.698]                               next
[17:36:35.698]                             invokeRestart(restart)
[17:36:35.698]                             muffled <- TRUE
[17:36:35.698]                             break
[17:36:35.698]                           }
[17:36:35.698]                         }
[17:36:35.698]                       }
[17:36:35.698]                       invisible(muffled)
[17:36:35.698]                     }
[17:36:35.698]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.698]                   }
[17:36:35.698]                 }
[17:36:35.698]             }
[17:36:35.698]         }))
[17:36:35.698]     }, error = function(ex) {
[17:36:35.698]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:35.698]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.698]                 ...future.rng), started = ...future.startTime, 
[17:36:35.698]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:35.698]             version = "1.8"), class = "FutureResult")
[17:36:35.698]     }, finally = {
[17:36:35.698]         if (!identical(...future.workdir, getwd())) 
[17:36:35.698]             setwd(...future.workdir)
[17:36:35.698]         {
[17:36:35.698]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:35.698]                 ...future.oldOptions$nwarnings <- NULL
[17:36:35.698]             }
[17:36:35.698]             base::options(...future.oldOptions)
[17:36:35.698]             if (.Platform$OS.type == "windows") {
[17:36:35.698]                 old_names <- names(...future.oldEnvVars)
[17:36:35.698]                 envs <- base::Sys.getenv()
[17:36:35.698]                 names <- names(envs)
[17:36:35.698]                 common <- intersect(names, old_names)
[17:36:35.698]                 added <- setdiff(names, old_names)
[17:36:35.698]                 removed <- setdiff(old_names, names)
[17:36:35.698]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:35.698]                   envs[common]]
[17:36:35.698]                 NAMES <- toupper(changed)
[17:36:35.698]                 args <- list()
[17:36:35.698]                 for (kk in seq_along(NAMES)) {
[17:36:35.698]                   name <- changed[[kk]]
[17:36:35.698]                   NAME <- NAMES[[kk]]
[17:36:35.698]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.698]                     next
[17:36:35.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.698]                 }
[17:36:35.698]                 NAMES <- toupper(added)
[17:36:35.698]                 for (kk in seq_along(NAMES)) {
[17:36:35.698]                   name <- added[[kk]]
[17:36:35.698]                   NAME <- NAMES[[kk]]
[17:36:35.698]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.698]                     next
[17:36:35.698]                   args[[name]] <- ""
[17:36:35.698]                 }
[17:36:35.698]                 NAMES <- toupper(removed)
[17:36:35.698]                 for (kk in seq_along(NAMES)) {
[17:36:35.698]                   name <- removed[[kk]]
[17:36:35.698]                   NAME <- NAMES[[kk]]
[17:36:35.698]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.698]                     next
[17:36:35.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.698]                 }
[17:36:35.698]                 if (length(args) > 0) 
[17:36:35.698]                   base::do.call(base::Sys.setenv, args = args)
[17:36:35.698]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:35.698]             }
[17:36:35.698]             else {
[17:36:35.698]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:35.698]             }
[17:36:35.698]             {
[17:36:35.698]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:35.698]                   0L) {
[17:36:35.698]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:35.698]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:35.698]                   base::options(opts)
[17:36:35.698]                 }
[17:36:35.698]                 {
[17:36:35.698]                   {
[17:36:35.698]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:35.698]                     NULL
[17:36:35.698]                   }
[17:36:35.698]                   options(future.plan = NULL)
[17:36:35.698]                   if (is.na(NA_character_)) 
[17:36:35.698]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.698]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:35.698]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:35.698]                     .init = FALSE)
[17:36:35.698]                 }
[17:36:35.698]             }
[17:36:35.698]         }
[17:36:35.698]     })
[17:36:35.698]     if (TRUE) {
[17:36:35.698]         base::sink(type = "output", split = FALSE)
[17:36:35.698]         if (TRUE) {
[17:36:35.698]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:35.698]         }
[17:36:35.698]         else {
[17:36:35.698]             ...future.result["stdout"] <- base::list(NULL)
[17:36:35.698]         }
[17:36:35.698]         base::close(...future.stdout)
[17:36:35.698]         ...future.stdout <- NULL
[17:36:35.698]     }
[17:36:35.698]     ...future.result$conditions <- ...future.conditions
[17:36:35.698]     ...future.result$finished <- base::Sys.time()
[17:36:35.698]     ...future.result
[17:36:35.698] }
[17:36:35.702] assign_globals() ...
[17:36:35.702] List of 5
[17:36:35.702]  $ future.call.arguments    : list()
[17:36:35.702]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.702]  $ ...future.FUN            :function (x)  
[17:36:35.702]  $ ...future.elements_ii    :List of 3
[17:36:35.702]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:36:35.702]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:36:35.702]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:36:35.702]  $ ...future.seeds_ii       : NULL
[17:36:35.702]  $ ...future.globals.maxSize: num Inf
[17:36:35.702]  - attr(*, "resolved")= logi FALSE
[17:36:35.702]  - attr(*, "total_size")= num NA
[17:36:35.702]  - attr(*, "where")=List of 5
[17:36:35.702]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:35.702]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:35.702]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:35.702]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:35.702]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:35.702]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.702]  - attr(*, "already-done")= logi TRUE
[17:36:35.711] - copied ‘future.call.arguments’ to environment
[17:36:35.711] - copied ‘...future.FUN’ to environment
[17:36:35.711] - copied ‘...future.elements_ii’ to environment
[17:36:35.711] - copied ‘...future.seeds_ii’ to environment
[17:36:35.711] - copied ‘...future.globals.maxSize’ to environment
[17:36:35.711] assign_globals() ... done
[17:36:35.712] requestCore(): workers = 2
[17:36:35.714] MulticoreFuture started
[17:36:35.714] - Launch lazy future ... done
[17:36:35.715] run() for ‘MulticoreFuture’ ... done
[17:36:35.715] Created future:
[17:36:35.715] plan(): Setting new future strategy stack:
[17:36:35.715] List of future strategies:
[17:36:35.715] 1. sequential:
[17:36:35.715]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:35.715]    - tweaked: FALSE
[17:36:35.715]    - call: NULL
[17:36:35.716] plan(): nbrOfWorkers() = 1
[17:36:35.718] plan(): Setting new future strategy stack:
[17:36:35.719] List of future strategies:
[17:36:35.719] 1. multicore:
[17:36:35.719]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:35.719]    - tweaked: FALSE
[17:36:35.719]    - call: plan(strategy)
[17:36:35.715] MulticoreFuture:
[17:36:35.715] Label: ‘future_apply-2’
[17:36:35.715] Expression:
[17:36:35.715] {
[17:36:35.715]     do.call(function(...) {
[17:36:35.715]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.715]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.715]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.715]             on.exit(options(oopts), add = TRUE)
[17:36:35.715]         }
[17:36:35.715]         {
[17:36:35.715]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.715]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.715]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.715]             })
[17:36:35.715]         }
[17:36:35.715]     }, args = future.call.arguments)
[17:36:35.715] }
[17:36:35.715] Lazy evaluation: FALSE
[17:36:35.715] Asynchronous evaluation: TRUE
[17:36:35.715] Local evaluation: TRUE
[17:36:35.715] Environment: R_GlobalEnv
[17:36:35.715] Capture standard output: TRUE
[17:36:35.715] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:35.715] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:35.715] Packages: <none>
[17:36:35.715] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:35.715] Resolved: FALSE
[17:36:35.715] Value: <not collected>
[17:36:35.715] Conditions captured: <none>
[17:36:35.715] Early signaling: FALSE
[17:36:35.715] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:35.715] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.728] Chunk #2 of 2 ... DONE
[17:36:35.728] Launching 2 futures (chunks) ... DONE
[17:36:35.728] Resolving 2 futures (chunks) ...
[17:36:35.729] resolve() on list ...
[17:36:35.729]  recursive: 0
[17:36:35.729]  length: 2
[17:36:35.729] 
[17:36:35.729] plan(): nbrOfWorkers() = 2
[17:36:35.730] Future #1
[17:36:35.730] result() for MulticoreFuture ...
[17:36:35.734] result() for MulticoreFuture ...
[17:36:35.734] result() for MulticoreFuture ... done
[17:36:35.734] result() for MulticoreFuture ... done
[17:36:35.735] result() for MulticoreFuture ...
[17:36:35.735] result() for MulticoreFuture ... done
[17:36:35.736] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:36:35.736] - nx: 2
[17:36:35.736] - relay: TRUE
[17:36:35.737] - stdout: TRUE
[17:36:35.737] - signal: TRUE
[17:36:35.737] - resignal: FALSE
[17:36:35.737] - force: TRUE
[17:36:35.738] - relayed: [n=2] FALSE, FALSE
[17:36:35.738] - queued futures: [n=2] FALSE, FALSE
[17:36:35.738]  - until=1
[17:36:35.739]  - relaying element #1
[17:36:35.739] result() for MulticoreFuture ...
[17:36:35.739] result() for MulticoreFuture ... done
[17:36:35.740] result() for MulticoreFuture ...
[17:36:35.740] result() for MulticoreFuture ... done
[17:36:35.740] result() for MulticoreFuture ...
[17:36:35.740] result() for MulticoreFuture ... done
[17:36:35.741] result() for MulticoreFuture ...
[17:36:35.741] result() for MulticoreFuture ... done
[17:36:35.741] - relayed: [n=2] TRUE, FALSE
[17:36:35.741] - queued futures: [n=2] TRUE, FALSE
[17:36:35.741] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:36:35.741]  length: 1 (resolved future 1)
[17:36:35.742] Future #2
[17:36:35.742] result() for MulticoreFuture ...
[17:36:35.743] result() for MulticoreFuture ...
[17:36:35.743] result() for MulticoreFuture ... done
[17:36:35.743] result() for MulticoreFuture ... done
[17:36:35.743] result() for MulticoreFuture ...
[17:36:35.743] result() for MulticoreFuture ... done
[17:36:35.744] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:36:35.744] - nx: 2
[17:36:35.744] - relay: TRUE
[17:36:35.744] - stdout: TRUE
[17:36:35.744] - signal: TRUE
[17:36:35.744] - resignal: FALSE
[17:36:35.744] - force: TRUE
[17:36:35.745] - relayed: [n=2] TRUE, FALSE
[17:36:35.745] - queued futures: [n=2] TRUE, FALSE
[17:36:35.745]  - until=2
[17:36:35.745]  - relaying element #2
[17:36:35.745] result() for MulticoreFuture ...
[17:36:35.745] result() for MulticoreFuture ... done
[17:36:35.745] result() for MulticoreFuture ...
[17:36:35.745] result() for MulticoreFuture ... done
[17:36:35.746] result() for MulticoreFuture ...
[17:36:35.746] result() for MulticoreFuture ... done
[17:36:35.746] result() for MulticoreFuture ...
[17:36:35.746] result() for MulticoreFuture ... done
[17:36:35.746] - relayed: [n=2] TRUE, TRUE
[17:36:35.746] - queued futures: [n=2] TRUE, TRUE
[17:36:35.746] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:36:35.746]  length: 0 (resolved future 2)
[17:36:35.746] Relaying remaining futures
[17:36:35.747] signalConditionsASAP(NULL, pos=0) ...
[17:36:35.747] - nx: 2
[17:36:35.747] - relay: TRUE
[17:36:35.747] - stdout: TRUE
[17:36:35.747] - signal: TRUE
[17:36:35.747] - resignal: FALSE
[17:36:35.747] - force: TRUE
[17:36:35.747] - relayed: [n=2] TRUE, TRUE
[17:36:35.747] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:35.748] - relayed: [n=2] TRUE, TRUE
[17:36:35.748] - queued futures: [n=2] TRUE, TRUE
[17:36:35.748] signalConditionsASAP(NULL, pos=0) ... done
[17:36:35.748] resolve() on list ... DONE
[17:36:35.748] result() for MulticoreFuture ...
[17:36:35.748] result() for MulticoreFuture ... done
[17:36:35.748] result() for MulticoreFuture ...
[17:36:35.748] result() for MulticoreFuture ... done
[17:36:35.749] result() for MulticoreFuture ...
[17:36:35.749] result() for MulticoreFuture ... done
[17:36:35.749] result() for MulticoreFuture ...
[17:36:35.749] result() for MulticoreFuture ... done
[17:36:35.749]  - Number of value chunks collected: 2
[17:36:35.749] Resolving 2 futures (chunks) ... DONE
[17:36:35.749] Reducing values from 2 chunks ...
[17:36:35.749]  - Number of values collected after concatenation: 6
[17:36:35.749]  - Number of values expected: 6
[17:36:35.750] Reducing values from 2 chunks ... DONE
[17:36:35.750] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[17:36:35.750] getGlobalsAndPackagesXApply() ...
[17:36:35.750]  - future.globals: TRUE
[17:36:35.751] getGlobalsAndPackages() ...
[17:36:35.751] Searching for globals...
[17:36:35.752] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[17:36:35.753] Searching for globals ... DONE
[17:36:35.753] Resolving globals: FALSE
[17:36:35.753] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[17:36:35.754] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[17:36:35.754] - globals: [1] ‘FUN’
[17:36:35.754] 
[17:36:35.754] getGlobalsAndPackages() ... DONE
[17:36:35.754]  - globals found/used: [n=1] ‘FUN’
[17:36:35.754]  - needed namespaces: [n=0] 
[17:36:35.755] Finding globals ... DONE
[17:36:35.755]  - use_args: TRUE
[17:36:35.755]  - Getting '...' globals ...
[17:36:35.755] resolve() on list ...
[17:36:35.755]  recursive: 0
[17:36:35.755]  length: 1
[17:36:35.756]  elements: ‘...’
[17:36:35.756]  length: 0 (resolved future 1)
[17:36:35.756] resolve() on list ... DONE
[17:36:35.756]    - '...' content: [n=0] 
[17:36:35.756] List of 1
[17:36:35.756]  $ ...: list()
[17:36:35.756]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.756]  - attr(*, "where")=List of 1
[17:36:35.756]   ..$ ...:<environment: 0x556d7472adf8> 
[17:36:35.756]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.756]  - attr(*, "resolved")= logi TRUE
[17:36:35.756]  - attr(*, "total_size")= num NA
[17:36:35.759]  - Getting '...' globals ... DONE
[17:36:35.759] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:35.759] List of 2
[17:36:35.759]  $ ...future.FUN:function (x)  
[17:36:35.759]  $ ...          : list()
[17:36:35.759]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.759]  - attr(*, "where")=List of 2
[17:36:35.759]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:35.759]   ..$ ...          :<environment: 0x556d7472adf8> 
[17:36:35.759]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.759]  - attr(*, "resolved")= logi FALSE
[17:36:35.759]  - attr(*, "total_size")= num 1768
[17:36:35.762] Packages to be attached in all futures: [n=0] 
[17:36:35.762] getGlobalsAndPackagesXApply() ... DONE
[17:36:35.766] future_lapply() ...
[17:36:35.773] Number of chunks: 2
[17:36:35.773] getGlobalsAndPackagesXApply() ...
[17:36:35.773]  - future.globals: <name-value list> with names ‘list()’
[17:36:35.774]  - use_args: TRUE
[17:36:35.774] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:35.774] List of 2
[17:36:35.774]  $ ...          : list()
[17:36:35.774]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.774]  $ ...future.FUN:function (x)  
[17:36:35.774]  - attr(*, "where")=List of 2
[17:36:35.774]   ..$ ...          :<environment: 0x556d7472adf8> 
[17:36:35.774]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:36:35.774]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.774]  - attr(*, "resolved")= logi FALSE
[17:36:35.774]  - attr(*, "total_size")= num NA
[17:36:35.777] Packages to be attached in all futures: [n=0] 
[17:36:35.777] getGlobalsAndPackagesXApply() ... DONE
[17:36:35.777] Number of futures (= number of chunks): 2
[17:36:35.778] Launching 2 futures (chunks) ...
[17:36:35.778] Chunk #1 of 2 ...
[17:36:35.778]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:35.778]  - seeds: <none>
[17:36:35.778]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.778] getGlobalsAndPackages() ...
[17:36:35.778] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.778] Resolving globals: FALSE
[17:36:35.778] Tweak future expression to call with '...' arguments ...
[17:36:35.779] {
[17:36:35.779]     do.call(function(...) {
[17:36:35.779]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.779]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.779]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.779]             on.exit(options(oopts), add = TRUE)
[17:36:35.779]         }
[17:36:35.779]         {
[17:36:35.779]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.779]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.779]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.779]             })
[17:36:35.779]         }
[17:36:35.779]     }, args = future.call.arguments)
[17:36:35.779] }
[17:36:35.779] Tweak future expression to call with '...' arguments ... DONE
[17:36:35.779] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.779] 
[17:36:35.779] getGlobalsAndPackages() ... DONE
[17:36:35.780] run() for ‘Future’ ...
[17:36:35.780] - state: ‘created’
[17:36:35.780] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:35.784] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.784] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:35.784]   - Field: ‘label’
[17:36:35.784]   - Field: ‘local’
[17:36:35.784]   - Field: ‘owner’
[17:36:35.784]   - Field: ‘envir’
[17:36:35.784]   - Field: ‘workers’
[17:36:35.784]   - Field: ‘packages’
[17:36:35.784]   - Field: ‘gc’
[17:36:35.785]   - Field: ‘job’
[17:36:35.785]   - Field: ‘conditions’
[17:36:35.785]   - Field: ‘expr’
[17:36:35.785]   - Field: ‘uuid’
[17:36:35.785]   - Field: ‘seed’
[17:36:35.785]   - Field: ‘version’
[17:36:35.785]   - Field: ‘result’
[17:36:35.785]   - Field: ‘asynchronous’
[17:36:35.785]   - Field: ‘calls’
[17:36:35.785]   - Field: ‘globals’
[17:36:35.785]   - Field: ‘stdout’
[17:36:35.786]   - Field: ‘earlySignal’
[17:36:35.786]   - Field: ‘lazy’
[17:36:35.786]   - Field: ‘state’
[17:36:35.786] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:35.786] - Launch lazy future ...
[17:36:35.786] Packages needed by the future expression (n = 0): <none>
[17:36:35.786] Packages needed by future strategies (n = 0): <none>
[17:36:35.787] {
[17:36:35.787]     {
[17:36:35.787]         {
[17:36:35.787]             ...future.startTime <- base::Sys.time()
[17:36:35.787]             {
[17:36:35.787]                 {
[17:36:35.787]                   {
[17:36:35.787]                     {
[17:36:35.787]                       base::local({
[17:36:35.787]                         has_future <- base::requireNamespace("future", 
[17:36:35.787]                           quietly = TRUE)
[17:36:35.787]                         if (has_future) {
[17:36:35.787]                           ns <- base::getNamespace("future")
[17:36:35.787]                           version <- ns[[".package"]][["version"]]
[17:36:35.787]                           if (is.null(version)) 
[17:36:35.787]                             version <- utils::packageVersion("future")
[17:36:35.787]                         }
[17:36:35.787]                         else {
[17:36:35.787]                           version <- NULL
[17:36:35.787]                         }
[17:36:35.787]                         if (!has_future || version < "1.8.0") {
[17:36:35.787]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:35.787]                             "", base::R.version$version.string), 
[17:36:35.787]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:35.787]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:35.787]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:35.787]                               "release", "version")], collapse = " "), 
[17:36:35.787]                             hostname = base::Sys.info()[["nodename"]])
[17:36:35.787]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:35.787]                             info)
[17:36:35.787]                           info <- base::paste(info, collapse = "; ")
[17:36:35.787]                           if (!has_future) {
[17:36:35.787]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:35.787]                               info)
[17:36:35.787]                           }
[17:36:35.787]                           else {
[17:36:35.787]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:35.787]                               info, version)
[17:36:35.787]                           }
[17:36:35.787]                           base::stop(msg)
[17:36:35.787]                         }
[17:36:35.787]                       })
[17:36:35.787]                     }
[17:36:35.787]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:35.787]                     base::options(mc.cores = 1L)
[17:36:35.787]                   }
[17:36:35.787]                   ...future.strategy.old <- future::plan("list")
[17:36:35.787]                   options(future.plan = NULL)
[17:36:35.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:35.787]                 }
[17:36:35.787]                 ...future.workdir <- getwd()
[17:36:35.787]             }
[17:36:35.787]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:35.787]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:35.787]         }
[17:36:35.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:35.787]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:35.787]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:35.787]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:35.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:35.787]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:35.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:35.787]             base::names(...future.oldOptions))
[17:36:35.787]     }
[17:36:35.787]     if (FALSE) {
[17:36:35.787]     }
[17:36:35.787]     else {
[17:36:35.787]         if (TRUE) {
[17:36:35.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:35.787]                 open = "w")
[17:36:35.787]         }
[17:36:35.787]         else {
[17:36:35.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:35.787]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:35.787]         }
[17:36:35.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:35.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:35.787]             base::sink(type = "output", split = FALSE)
[17:36:35.787]             base::close(...future.stdout)
[17:36:35.787]         }, add = TRUE)
[17:36:35.787]     }
[17:36:35.787]     ...future.frame <- base::sys.nframe()
[17:36:35.787]     ...future.conditions <- base::list()
[17:36:35.787]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:35.787]     if (FALSE) {
[17:36:35.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:35.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:35.787]     }
[17:36:35.787]     ...future.result <- base::tryCatch({
[17:36:35.787]         base::withCallingHandlers({
[17:36:35.787]             ...future.value <- base::withVisible(base::local({
[17:36:35.787]                 withCallingHandlers({
[17:36:35.787]                   {
[17:36:35.787]                     do.call(function(...) {
[17:36:35.787]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.787]                       if (!identical(...future.globals.maxSize.org, 
[17:36:35.787]                         ...future.globals.maxSize)) {
[17:36:35.787]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.787]                         on.exit(options(oopts), add = TRUE)
[17:36:35.787]                       }
[17:36:35.787]                       {
[17:36:35.787]                         lapply(seq_along(...future.elements_ii), 
[17:36:35.787]                           FUN = function(jj) {
[17:36:35.787]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.787]                             ...future.FUN(...future.X_jj, ...)
[17:36:35.787]                           })
[17:36:35.787]                       }
[17:36:35.787]                     }, args = future.call.arguments)
[17:36:35.787]                   }
[17:36:35.787]                 }, immediateCondition = function(cond) {
[17:36:35.787]                   save_rds <- function (object, pathname, ...) 
[17:36:35.787]                   {
[17:36:35.787]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:35.787]                     if (file_test("-f", pathname_tmp)) {
[17:36:35.787]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.787]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:35.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.787]                         fi_tmp[["mtime"]])
[17:36:35.787]                     }
[17:36:35.787]                     tryCatch({
[17:36:35.787]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:35.787]                     }, error = function(ex) {
[17:36:35.787]                       msg <- conditionMessage(ex)
[17:36:35.787]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.787]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:35.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.787]                         fi_tmp[["mtime"]], msg)
[17:36:35.787]                       ex$message <- msg
[17:36:35.787]                       stop(ex)
[17:36:35.787]                     })
[17:36:35.787]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:35.787]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:35.787]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:35.787]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.787]                       fi <- file.info(pathname)
[17:36:35.787]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:35.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.787]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:35.787]                         fi[["size"]], fi[["mtime"]])
[17:36:35.787]                       stop(msg)
[17:36:35.787]                     }
[17:36:35.787]                     invisible(pathname)
[17:36:35.787]                   }
[17:36:35.787]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:35.787]                     rootPath = tempdir()) 
[17:36:35.787]                   {
[17:36:35.787]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:35.787]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:35.787]                       tmpdir = path, fileext = ".rds")
[17:36:35.787]                     save_rds(obj, file)
[17:36:35.787]                   }
[17:36:35.787]                   saveImmediateCondition(cond, path = "/tmp/RtmpABg8SG/.future/immediateConditions")
[17:36:35.787]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.787]                   {
[17:36:35.787]                     inherits <- base::inherits
[17:36:35.787]                     invokeRestart <- base::invokeRestart
[17:36:35.787]                     is.null <- base::is.null
[17:36:35.787]                     muffled <- FALSE
[17:36:35.787]                     if (inherits(cond, "message")) {
[17:36:35.787]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:35.787]                       if (muffled) 
[17:36:35.787]                         invokeRestart("muffleMessage")
[17:36:35.787]                     }
[17:36:35.787]                     else if (inherits(cond, "warning")) {
[17:36:35.787]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:35.787]                       if (muffled) 
[17:36:35.787]                         invokeRestart("muffleWarning")
[17:36:35.787]                     }
[17:36:35.787]                     else if (inherits(cond, "condition")) {
[17:36:35.787]                       if (!is.null(pattern)) {
[17:36:35.787]                         computeRestarts <- base::computeRestarts
[17:36:35.787]                         grepl <- base::grepl
[17:36:35.787]                         restarts <- computeRestarts(cond)
[17:36:35.787]                         for (restart in restarts) {
[17:36:35.787]                           name <- restart$name
[17:36:35.787]                           if (is.null(name)) 
[17:36:35.787]                             next
[17:36:35.787]                           if (!grepl(pattern, name)) 
[17:36:35.787]                             next
[17:36:35.787]                           invokeRestart(restart)
[17:36:35.787]                           muffled <- TRUE
[17:36:35.787]                           break
[17:36:35.787]                         }
[17:36:35.787]                       }
[17:36:35.787]                     }
[17:36:35.787]                     invisible(muffled)
[17:36:35.787]                   }
[17:36:35.787]                   muffleCondition(cond)
[17:36:35.787]                 })
[17:36:35.787]             }))
[17:36:35.787]             future::FutureResult(value = ...future.value$value, 
[17:36:35.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.787]                   ...future.rng), globalenv = if (FALSE) 
[17:36:35.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:35.787]                     ...future.globalenv.names))
[17:36:35.787]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:35.787]         }, condition = base::local({
[17:36:35.787]             c <- base::c
[17:36:35.787]             inherits <- base::inherits
[17:36:35.787]             invokeRestart <- base::invokeRestart
[17:36:35.787]             length <- base::length
[17:36:35.787]             list <- base::list
[17:36:35.787]             seq.int <- base::seq.int
[17:36:35.787]             signalCondition <- base::signalCondition
[17:36:35.787]             sys.calls <- base::sys.calls
[17:36:35.787]             `[[` <- base::`[[`
[17:36:35.787]             `+` <- base::`+`
[17:36:35.787]             `<<-` <- base::`<<-`
[17:36:35.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:35.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:35.787]                   3L)]
[17:36:35.787]             }
[17:36:35.787]             function(cond) {
[17:36:35.787]                 is_error <- inherits(cond, "error")
[17:36:35.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:35.787]                   NULL)
[17:36:35.787]                 if (is_error) {
[17:36:35.787]                   sessionInformation <- function() {
[17:36:35.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:35.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:35.787]                       search = base::search(), system = base::Sys.info())
[17:36:35.787]                   }
[17:36:35.787]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:35.787]                     cond$call), session = sessionInformation(), 
[17:36:35.787]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:35.787]                   signalCondition(cond)
[17:36:35.787]                 }
[17:36:35.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:35.787]                 "immediateCondition"))) {
[17:36:35.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:35.787]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:35.787]                   if (TRUE && !signal) {
[17:36:35.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.787]                     {
[17:36:35.787]                       inherits <- base::inherits
[17:36:35.787]                       invokeRestart <- base::invokeRestart
[17:36:35.787]                       is.null <- base::is.null
[17:36:35.787]                       muffled <- FALSE
[17:36:35.787]                       if (inherits(cond, "message")) {
[17:36:35.787]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.787]                         if (muffled) 
[17:36:35.787]                           invokeRestart("muffleMessage")
[17:36:35.787]                       }
[17:36:35.787]                       else if (inherits(cond, "warning")) {
[17:36:35.787]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.787]                         if (muffled) 
[17:36:35.787]                           invokeRestart("muffleWarning")
[17:36:35.787]                       }
[17:36:35.787]                       else if (inherits(cond, "condition")) {
[17:36:35.787]                         if (!is.null(pattern)) {
[17:36:35.787]                           computeRestarts <- base::computeRestarts
[17:36:35.787]                           grepl <- base::grepl
[17:36:35.787]                           restarts <- computeRestarts(cond)
[17:36:35.787]                           for (restart in restarts) {
[17:36:35.787]                             name <- restart$name
[17:36:35.787]                             if (is.null(name)) 
[17:36:35.787]                               next
[17:36:35.787]                             if (!grepl(pattern, name)) 
[17:36:35.787]                               next
[17:36:35.787]                             invokeRestart(restart)
[17:36:35.787]                             muffled <- TRUE
[17:36:35.787]                             break
[17:36:35.787]                           }
[17:36:35.787]                         }
[17:36:35.787]                       }
[17:36:35.787]                       invisible(muffled)
[17:36:35.787]                     }
[17:36:35.787]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.787]                   }
[17:36:35.787]                 }
[17:36:35.787]                 else {
[17:36:35.787]                   if (TRUE) {
[17:36:35.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.787]                     {
[17:36:35.787]                       inherits <- base::inherits
[17:36:35.787]                       invokeRestart <- base::invokeRestart
[17:36:35.787]                       is.null <- base::is.null
[17:36:35.787]                       muffled <- FALSE
[17:36:35.787]                       if (inherits(cond, "message")) {
[17:36:35.787]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.787]                         if (muffled) 
[17:36:35.787]                           invokeRestart("muffleMessage")
[17:36:35.787]                       }
[17:36:35.787]                       else if (inherits(cond, "warning")) {
[17:36:35.787]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.787]                         if (muffled) 
[17:36:35.787]                           invokeRestart("muffleWarning")
[17:36:35.787]                       }
[17:36:35.787]                       else if (inherits(cond, "condition")) {
[17:36:35.787]                         if (!is.null(pattern)) {
[17:36:35.787]                           computeRestarts <- base::computeRestarts
[17:36:35.787]                           grepl <- base::grepl
[17:36:35.787]                           restarts <- computeRestarts(cond)
[17:36:35.787]                           for (restart in restarts) {
[17:36:35.787]                             name <- restart$name
[17:36:35.787]                             if (is.null(name)) 
[17:36:35.787]                               next
[17:36:35.787]                             if (!grepl(pattern, name)) 
[17:36:35.787]                               next
[17:36:35.787]                             invokeRestart(restart)
[17:36:35.787]                             muffled <- TRUE
[17:36:35.787]                             break
[17:36:35.787]                           }
[17:36:35.787]                         }
[17:36:35.787]                       }
[17:36:35.787]                       invisible(muffled)
[17:36:35.787]                     }
[17:36:35.787]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.787]                   }
[17:36:35.787]                 }
[17:36:35.787]             }
[17:36:35.787]         }))
[17:36:35.787]     }, error = function(ex) {
[17:36:35.787]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:35.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.787]                 ...future.rng), started = ...future.startTime, 
[17:36:35.787]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:35.787]             version = "1.8"), class = "FutureResult")
[17:36:35.787]     }, finally = {
[17:36:35.787]         if (!identical(...future.workdir, getwd())) 
[17:36:35.787]             setwd(...future.workdir)
[17:36:35.787]         {
[17:36:35.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:35.787]                 ...future.oldOptions$nwarnings <- NULL
[17:36:35.787]             }
[17:36:35.787]             base::options(...future.oldOptions)
[17:36:35.787]             if (.Platform$OS.type == "windows") {
[17:36:35.787]                 old_names <- names(...future.oldEnvVars)
[17:36:35.787]                 envs <- base::Sys.getenv()
[17:36:35.787]                 names <- names(envs)
[17:36:35.787]                 common <- intersect(names, old_names)
[17:36:35.787]                 added <- setdiff(names, old_names)
[17:36:35.787]                 removed <- setdiff(old_names, names)
[17:36:35.787]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:35.787]                   envs[common]]
[17:36:35.787]                 NAMES <- toupper(changed)
[17:36:35.787]                 args <- list()
[17:36:35.787]                 for (kk in seq_along(NAMES)) {
[17:36:35.787]                   name <- changed[[kk]]
[17:36:35.787]                   NAME <- NAMES[[kk]]
[17:36:35.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.787]                     next
[17:36:35.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.787]                 }
[17:36:35.787]                 NAMES <- toupper(added)
[17:36:35.787]                 for (kk in seq_along(NAMES)) {
[17:36:35.787]                   name <- added[[kk]]
[17:36:35.787]                   NAME <- NAMES[[kk]]
[17:36:35.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.787]                     next
[17:36:35.787]                   args[[name]] <- ""
[17:36:35.787]                 }
[17:36:35.787]                 NAMES <- toupper(removed)
[17:36:35.787]                 for (kk in seq_along(NAMES)) {
[17:36:35.787]                   name <- removed[[kk]]
[17:36:35.787]                   NAME <- NAMES[[kk]]
[17:36:35.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.787]                     next
[17:36:35.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.787]                 }
[17:36:35.787]                 if (length(args) > 0) 
[17:36:35.787]                   base::do.call(base::Sys.setenv, args = args)
[17:36:35.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:35.787]             }
[17:36:35.787]             else {
[17:36:35.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:35.787]             }
[17:36:35.787]             {
[17:36:35.787]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:35.787]                   0L) {
[17:36:35.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:35.787]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:35.787]                   base::options(opts)
[17:36:35.787]                 }
[17:36:35.787]                 {
[17:36:35.787]                   {
[17:36:35.787]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:35.787]                     NULL
[17:36:35.787]                   }
[17:36:35.787]                   options(future.plan = NULL)
[17:36:35.787]                   if (is.na(NA_character_)) 
[17:36:35.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:35.787]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:35.787]                     .init = FALSE)
[17:36:35.787]                 }
[17:36:35.787]             }
[17:36:35.787]         }
[17:36:35.787]     })
[17:36:35.787]     if (TRUE) {
[17:36:35.787]         base::sink(type = "output", split = FALSE)
[17:36:35.787]         if (TRUE) {
[17:36:35.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:35.787]         }
[17:36:35.787]         else {
[17:36:35.787]             ...future.result["stdout"] <- base::list(NULL)
[17:36:35.787]         }
[17:36:35.787]         base::close(...future.stdout)
[17:36:35.787]         ...future.stdout <- NULL
[17:36:35.787]     }
[17:36:35.787]     ...future.result$conditions <- ...future.conditions
[17:36:35.787]     ...future.result$finished <- base::Sys.time()
[17:36:35.787]     ...future.result
[17:36:35.787] }
[17:36:35.789] assign_globals() ...
[17:36:35.789] List of 5
[17:36:35.789]  $ future.call.arguments    : list()
[17:36:35.789]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.789]  $ ...future.FUN            :function (x)  
[17:36:35.789]  $ ...future.elements_ii    :List of 3
[17:36:35.789]   ..$ : int [1:4] 1 7 13 19
[17:36:35.789]   ..$ : int [1:4] 2 8 14 20
[17:36:35.789]   ..$ : int [1:4] 3 9 15 21
[17:36:35.789]  $ ...future.seeds_ii       : NULL
[17:36:35.789]  $ ...future.globals.maxSize: num Inf
[17:36:35.789]  - attr(*, "resolved")= logi FALSE
[17:36:35.789]  - attr(*, "total_size")= num NA
[17:36:35.789]  - attr(*, "where")=List of 5
[17:36:35.789]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:35.789]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:35.789]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:35.789]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:35.789]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:35.789]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.789]  - attr(*, "already-done")= logi TRUE
[17:36:35.795] - copied ‘future.call.arguments’ to environment
[17:36:35.795] - reassign environment for ‘...future.FUN’
[17:36:35.795] - copied ‘...future.FUN’ to environment
[17:36:35.795] - copied ‘...future.elements_ii’ to environment
[17:36:35.795] - copied ‘...future.seeds_ii’ to environment
[17:36:35.795] - copied ‘...future.globals.maxSize’ to environment
[17:36:35.795] assign_globals() ... done
[17:36:35.795] requestCore(): workers = 2
[17:36:35.798] MulticoreFuture started
[17:36:35.798] - Launch lazy future ... done
[17:36:35.798] run() for ‘MulticoreFuture’ ... done
[17:36:35.798] Created future:
[17:36:35.799] plan(): Setting new future strategy stack:
[17:36:35.799] List of future strategies:
[17:36:35.799] 1. sequential:
[17:36:35.799]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:35.799]    - tweaked: FALSE
[17:36:35.799]    - call: NULL
[17:36:35.800] plan(): nbrOfWorkers() = 1
[17:36:35.802] plan(): Setting new future strategy stack:
[17:36:35.802] List of future strategies:
[17:36:35.802] 1. multicore:
[17:36:35.802]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:35.802]    - tweaked: FALSE
[17:36:35.802]    - call: plan(strategy)
[17:36:35.807] plan(): nbrOfWorkers() = 2
[17:36:35.799] MulticoreFuture:
[17:36:35.799] Label: ‘future_apply-1’
[17:36:35.799] Expression:
[17:36:35.799] {
[17:36:35.799]     do.call(function(...) {
[17:36:35.799]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.799]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.799]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.799]             on.exit(options(oopts), add = TRUE)
[17:36:35.799]         }
[17:36:35.799]         {
[17:36:35.799]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.799]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.799]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.799]             })
[17:36:35.799]         }
[17:36:35.799]     }, args = future.call.arguments)
[17:36:35.799] }
[17:36:35.799] Lazy evaluation: FALSE
[17:36:35.799] Asynchronous evaluation: TRUE
[17:36:35.799] Local evaluation: TRUE
[17:36:35.799] Environment: R_GlobalEnv
[17:36:35.799] Capture standard output: TRUE
[17:36:35.799] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:35.799] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:35.799] Packages: <none>
[17:36:35.799] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:35.799] Resolved: TRUE
[17:36:35.799] Value: <not collected>
[17:36:35.799] Conditions captured: <none>
[17:36:35.799] Early signaling: FALSE
[17:36:35.799] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:35.799] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.808] Chunk #1 of 2 ... DONE
[17:36:35.809] Chunk #2 of 2 ...
[17:36:35.809]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:35.809]  - seeds: <none>
[17:36:35.809]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.809] getGlobalsAndPackages() ...
[17:36:35.809] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.810] Resolving globals: FALSE
[17:36:35.810] Tweak future expression to call with '...' arguments ...
[17:36:35.810] {
[17:36:35.810]     do.call(function(...) {
[17:36:35.810]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.810]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.810]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.810]             on.exit(options(oopts), add = TRUE)
[17:36:35.810]         }
[17:36:35.810]         {
[17:36:35.810]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.810]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.810]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.810]             })
[17:36:35.810]         }
[17:36:35.810]     }, args = future.call.arguments)
[17:36:35.810] }
[17:36:35.810] Tweak future expression to call with '...' arguments ... DONE
[17:36:35.811] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.811] 
[17:36:35.814] getGlobalsAndPackages() ... DONE
[17:36:35.816] run() for ‘Future’ ...
[17:36:35.816] - state: ‘created’
[17:36:35.817] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:35.823] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.824] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:35.824]   - Field: ‘label’
[17:36:35.824]   - Field: ‘local’
[17:36:35.825]   - Field: ‘owner’
[17:36:35.825]   - Field: ‘envir’
[17:36:35.825]   - Field: ‘workers’
[17:36:35.825]   - Field: ‘packages’
[17:36:35.826]   - Field: ‘gc’
[17:36:35.826]   - Field: ‘job’
[17:36:35.826]   - Field: ‘conditions’
[17:36:35.826]   - Field: ‘expr’
[17:36:35.826]   - Field: ‘uuid’
[17:36:35.826]   - Field: ‘seed’
[17:36:35.826]   - Field: ‘version’
[17:36:35.827]   - Field: ‘result’
[17:36:35.827]   - Field: ‘asynchronous’
[17:36:35.827]   - Field: ‘calls’
[17:36:35.827]   - Field: ‘globals’
[17:36:35.827]   - Field: ‘stdout’
[17:36:35.827]   - Field: ‘earlySignal’
[17:36:35.827]   - Field: ‘lazy’
[17:36:35.828]   - Field: ‘state’
[17:36:35.828] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:35.828] - Launch lazy future ...
[17:36:35.829] Packages needed by the future expression (n = 0): <none>
[17:36:35.829] Packages needed by future strategies (n = 0): <none>
[17:36:35.830] {
[17:36:35.830]     {
[17:36:35.830]         {
[17:36:35.830]             ...future.startTime <- base::Sys.time()
[17:36:35.830]             {
[17:36:35.830]                 {
[17:36:35.830]                   {
[17:36:35.830]                     {
[17:36:35.830]                       base::local({
[17:36:35.830]                         has_future <- base::requireNamespace("future", 
[17:36:35.830]                           quietly = TRUE)
[17:36:35.830]                         if (has_future) {
[17:36:35.830]                           ns <- base::getNamespace("future")
[17:36:35.830]                           version <- ns[[".package"]][["version"]]
[17:36:35.830]                           if (is.null(version)) 
[17:36:35.830]                             version <- utils::packageVersion("future")
[17:36:35.830]                         }
[17:36:35.830]                         else {
[17:36:35.830]                           version <- NULL
[17:36:35.830]                         }
[17:36:35.830]                         if (!has_future || version < "1.8.0") {
[17:36:35.830]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:35.830]                             "", base::R.version$version.string), 
[17:36:35.830]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:35.830]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:35.830]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:35.830]                               "release", "version")], collapse = " "), 
[17:36:35.830]                             hostname = base::Sys.info()[["nodename"]])
[17:36:35.830]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:35.830]                             info)
[17:36:35.830]                           info <- base::paste(info, collapse = "; ")
[17:36:35.830]                           if (!has_future) {
[17:36:35.830]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:35.830]                               info)
[17:36:35.830]                           }
[17:36:35.830]                           else {
[17:36:35.830]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:35.830]                               info, version)
[17:36:35.830]                           }
[17:36:35.830]                           base::stop(msg)
[17:36:35.830]                         }
[17:36:35.830]                       })
[17:36:35.830]                     }
[17:36:35.830]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:35.830]                     base::options(mc.cores = 1L)
[17:36:35.830]                   }
[17:36:35.830]                   ...future.strategy.old <- future::plan("list")
[17:36:35.830]                   options(future.plan = NULL)
[17:36:35.830]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.830]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:35.830]                 }
[17:36:35.830]                 ...future.workdir <- getwd()
[17:36:35.830]             }
[17:36:35.830]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:35.830]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:35.830]         }
[17:36:35.830]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:35.830]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:35.830]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:35.830]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:35.830]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:35.830]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:35.830]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:35.830]             base::names(...future.oldOptions))
[17:36:35.830]     }
[17:36:35.830]     if (FALSE) {
[17:36:35.830]     }
[17:36:35.830]     else {
[17:36:35.830]         if (TRUE) {
[17:36:35.830]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:35.830]                 open = "w")
[17:36:35.830]         }
[17:36:35.830]         else {
[17:36:35.830]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:35.830]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:35.830]         }
[17:36:35.830]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:35.830]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:35.830]             base::sink(type = "output", split = FALSE)
[17:36:35.830]             base::close(...future.stdout)
[17:36:35.830]         }, add = TRUE)
[17:36:35.830]     }
[17:36:35.830]     ...future.frame <- base::sys.nframe()
[17:36:35.830]     ...future.conditions <- base::list()
[17:36:35.830]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:35.830]     if (FALSE) {
[17:36:35.830]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:35.830]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:35.830]     }
[17:36:35.830]     ...future.result <- base::tryCatch({
[17:36:35.830]         base::withCallingHandlers({
[17:36:35.830]             ...future.value <- base::withVisible(base::local({
[17:36:35.830]                 withCallingHandlers({
[17:36:35.830]                   {
[17:36:35.830]                     do.call(function(...) {
[17:36:35.830]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.830]                       if (!identical(...future.globals.maxSize.org, 
[17:36:35.830]                         ...future.globals.maxSize)) {
[17:36:35.830]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.830]                         on.exit(options(oopts), add = TRUE)
[17:36:35.830]                       }
[17:36:35.830]                       {
[17:36:35.830]                         lapply(seq_along(...future.elements_ii), 
[17:36:35.830]                           FUN = function(jj) {
[17:36:35.830]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.830]                             ...future.FUN(...future.X_jj, ...)
[17:36:35.830]                           })
[17:36:35.830]                       }
[17:36:35.830]                     }, args = future.call.arguments)
[17:36:35.830]                   }
[17:36:35.830]                 }, immediateCondition = function(cond) {
[17:36:35.830]                   save_rds <- function (object, pathname, ...) 
[17:36:35.830]                   {
[17:36:35.830]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:35.830]                     if (file_test("-f", pathname_tmp)) {
[17:36:35.830]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.830]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:35.830]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.830]                         fi_tmp[["mtime"]])
[17:36:35.830]                     }
[17:36:35.830]                     tryCatch({
[17:36:35.830]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:35.830]                     }, error = function(ex) {
[17:36:35.830]                       msg <- conditionMessage(ex)
[17:36:35.830]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.830]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:35.830]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.830]                         fi_tmp[["mtime"]], msg)
[17:36:35.830]                       ex$message <- msg
[17:36:35.830]                       stop(ex)
[17:36:35.830]                     })
[17:36:35.830]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:35.830]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:35.830]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:35.830]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.830]                       fi <- file.info(pathname)
[17:36:35.830]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:35.830]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.830]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:35.830]                         fi[["size"]], fi[["mtime"]])
[17:36:35.830]                       stop(msg)
[17:36:35.830]                     }
[17:36:35.830]                     invisible(pathname)
[17:36:35.830]                   }
[17:36:35.830]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:35.830]                     rootPath = tempdir()) 
[17:36:35.830]                   {
[17:36:35.830]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:35.830]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:35.830]                       tmpdir = path, fileext = ".rds")
[17:36:35.830]                     save_rds(obj, file)
[17:36:35.830]                   }
[17:36:35.830]                   saveImmediateCondition(cond, path = "/tmp/RtmpABg8SG/.future/immediateConditions")
[17:36:35.830]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.830]                   {
[17:36:35.830]                     inherits <- base::inherits
[17:36:35.830]                     invokeRestart <- base::invokeRestart
[17:36:35.830]                     is.null <- base::is.null
[17:36:35.830]                     muffled <- FALSE
[17:36:35.830]                     if (inherits(cond, "message")) {
[17:36:35.830]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:35.830]                       if (muffled) 
[17:36:35.830]                         invokeRestart("muffleMessage")
[17:36:35.830]                     }
[17:36:35.830]                     else if (inherits(cond, "warning")) {
[17:36:35.830]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:35.830]                       if (muffled) 
[17:36:35.830]                         invokeRestart("muffleWarning")
[17:36:35.830]                     }
[17:36:35.830]                     else if (inherits(cond, "condition")) {
[17:36:35.830]                       if (!is.null(pattern)) {
[17:36:35.830]                         computeRestarts <- base::computeRestarts
[17:36:35.830]                         grepl <- base::grepl
[17:36:35.830]                         restarts <- computeRestarts(cond)
[17:36:35.830]                         for (restart in restarts) {
[17:36:35.830]                           name <- restart$name
[17:36:35.830]                           if (is.null(name)) 
[17:36:35.830]                             next
[17:36:35.830]                           if (!grepl(pattern, name)) 
[17:36:35.830]                             next
[17:36:35.830]                           invokeRestart(restart)
[17:36:35.830]                           muffled <- TRUE
[17:36:35.830]                           break
[17:36:35.830]                         }
[17:36:35.830]                       }
[17:36:35.830]                     }
[17:36:35.830]                     invisible(muffled)
[17:36:35.830]                   }
[17:36:35.830]                   muffleCondition(cond)
[17:36:35.830]                 })
[17:36:35.830]             }))
[17:36:35.830]             future::FutureResult(value = ...future.value$value, 
[17:36:35.830]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.830]                   ...future.rng), globalenv = if (FALSE) 
[17:36:35.830]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:35.830]                     ...future.globalenv.names))
[17:36:35.830]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:35.830]         }, condition = base::local({
[17:36:35.830]             c <- base::c
[17:36:35.830]             inherits <- base::inherits
[17:36:35.830]             invokeRestart <- base::invokeRestart
[17:36:35.830]             length <- base::length
[17:36:35.830]             list <- base::list
[17:36:35.830]             seq.int <- base::seq.int
[17:36:35.830]             signalCondition <- base::signalCondition
[17:36:35.830]             sys.calls <- base::sys.calls
[17:36:35.830]             `[[` <- base::`[[`
[17:36:35.830]             `+` <- base::`+`
[17:36:35.830]             `<<-` <- base::`<<-`
[17:36:35.830]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:35.830]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:35.830]                   3L)]
[17:36:35.830]             }
[17:36:35.830]             function(cond) {
[17:36:35.830]                 is_error <- inherits(cond, "error")
[17:36:35.830]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:35.830]                   NULL)
[17:36:35.830]                 if (is_error) {
[17:36:35.830]                   sessionInformation <- function() {
[17:36:35.830]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:35.830]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:35.830]                       search = base::search(), system = base::Sys.info())
[17:36:35.830]                   }
[17:36:35.830]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.830]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:35.830]                     cond$call), session = sessionInformation(), 
[17:36:35.830]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:35.830]                   signalCondition(cond)
[17:36:35.830]                 }
[17:36:35.830]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:35.830]                 "immediateCondition"))) {
[17:36:35.830]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:35.830]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.830]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:35.830]                   if (TRUE && !signal) {
[17:36:35.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.830]                     {
[17:36:35.830]                       inherits <- base::inherits
[17:36:35.830]                       invokeRestart <- base::invokeRestart
[17:36:35.830]                       is.null <- base::is.null
[17:36:35.830]                       muffled <- FALSE
[17:36:35.830]                       if (inherits(cond, "message")) {
[17:36:35.830]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.830]                         if (muffled) 
[17:36:35.830]                           invokeRestart("muffleMessage")
[17:36:35.830]                       }
[17:36:35.830]                       else if (inherits(cond, "warning")) {
[17:36:35.830]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.830]                         if (muffled) 
[17:36:35.830]                           invokeRestart("muffleWarning")
[17:36:35.830]                       }
[17:36:35.830]                       else if (inherits(cond, "condition")) {
[17:36:35.830]                         if (!is.null(pattern)) {
[17:36:35.830]                           computeRestarts <- base::computeRestarts
[17:36:35.830]                           grepl <- base::grepl
[17:36:35.830]                           restarts <- computeRestarts(cond)
[17:36:35.830]                           for (restart in restarts) {
[17:36:35.830]                             name <- restart$name
[17:36:35.830]                             if (is.null(name)) 
[17:36:35.830]                               next
[17:36:35.830]                             if (!grepl(pattern, name)) 
[17:36:35.830]                               next
[17:36:35.830]                             invokeRestart(restart)
[17:36:35.830]                             muffled <- TRUE
[17:36:35.830]                             break
[17:36:35.830]                           }
[17:36:35.830]                         }
[17:36:35.830]                       }
[17:36:35.830]                       invisible(muffled)
[17:36:35.830]                     }
[17:36:35.830]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.830]                   }
[17:36:35.830]                 }
[17:36:35.830]                 else {
[17:36:35.830]                   if (TRUE) {
[17:36:35.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.830]                     {
[17:36:35.830]                       inherits <- base::inherits
[17:36:35.830]                       invokeRestart <- base::invokeRestart
[17:36:35.830]                       is.null <- base::is.null
[17:36:35.830]                       muffled <- FALSE
[17:36:35.830]                       if (inherits(cond, "message")) {
[17:36:35.830]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.830]                         if (muffled) 
[17:36:35.830]                           invokeRestart("muffleMessage")
[17:36:35.830]                       }
[17:36:35.830]                       else if (inherits(cond, "warning")) {
[17:36:35.830]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.830]                         if (muffled) 
[17:36:35.830]                           invokeRestart("muffleWarning")
[17:36:35.830]                       }
[17:36:35.830]                       else if (inherits(cond, "condition")) {
[17:36:35.830]                         if (!is.null(pattern)) {
[17:36:35.830]                           computeRestarts <- base::computeRestarts
[17:36:35.830]                           grepl <- base::grepl
[17:36:35.830]                           restarts <- computeRestarts(cond)
[17:36:35.830]                           for (restart in restarts) {
[17:36:35.830]                             name <- restart$name
[17:36:35.830]                             if (is.null(name)) 
[17:36:35.830]                               next
[17:36:35.830]                             if (!grepl(pattern, name)) 
[17:36:35.830]                               next
[17:36:35.830]                             invokeRestart(restart)
[17:36:35.830]                             muffled <- TRUE
[17:36:35.830]                             break
[17:36:35.830]                           }
[17:36:35.830]                         }
[17:36:35.830]                       }
[17:36:35.830]                       invisible(muffled)
[17:36:35.830]                     }
[17:36:35.830]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.830]                   }
[17:36:35.830]                 }
[17:36:35.830]             }
[17:36:35.830]         }))
[17:36:35.830]     }, error = function(ex) {
[17:36:35.830]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:35.830]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.830]                 ...future.rng), started = ...future.startTime, 
[17:36:35.830]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:35.830]             version = "1.8"), class = "FutureResult")
[17:36:35.830]     }, finally = {
[17:36:35.830]         if (!identical(...future.workdir, getwd())) 
[17:36:35.830]             setwd(...future.workdir)
[17:36:35.830]         {
[17:36:35.830]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:35.830]                 ...future.oldOptions$nwarnings <- NULL
[17:36:35.830]             }
[17:36:35.830]             base::options(...future.oldOptions)
[17:36:35.830]             if (.Platform$OS.type == "windows") {
[17:36:35.830]                 old_names <- names(...future.oldEnvVars)
[17:36:35.830]                 envs <- base::Sys.getenv()
[17:36:35.830]                 names <- names(envs)
[17:36:35.830]                 common <- intersect(names, old_names)
[17:36:35.830]                 added <- setdiff(names, old_names)
[17:36:35.830]                 removed <- setdiff(old_names, names)
[17:36:35.830]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:35.830]                   envs[common]]
[17:36:35.830]                 NAMES <- toupper(changed)
[17:36:35.830]                 args <- list()
[17:36:35.830]                 for (kk in seq_along(NAMES)) {
[17:36:35.830]                   name <- changed[[kk]]
[17:36:35.830]                   NAME <- NAMES[[kk]]
[17:36:35.830]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.830]                     next
[17:36:35.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.830]                 }
[17:36:35.830]                 NAMES <- toupper(added)
[17:36:35.830]                 for (kk in seq_along(NAMES)) {
[17:36:35.830]                   name <- added[[kk]]
[17:36:35.830]                   NAME <- NAMES[[kk]]
[17:36:35.830]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.830]                     next
[17:36:35.830]                   args[[name]] <- ""
[17:36:35.830]                 }
[17:36:35.830]                 NAMES <- toupper(removed)
[17:36:35.830]                 for (kk in seq_along(NAMES)) {
[17:36:35.830]                   name <- removed[[kk]]
[17:36:35.830]                   NAME <- NAMES[[kk]]
[17:36:35.830]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.830]                     next
[17:36:35.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.830]                 }
[17:36:35.830]                 if (length(args) > 0) 
[17:36:35.830]                   base::do.call(base::Sys.setenv, args = args)
[17:36:35.830]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:35.830]             }
[17:36:35.830]             else {
[17:36:35.830]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:35.830]             }
[17:36:35.830]             {
[17:36:35.830]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:35.830]                   0L) {
[17:36:35.830]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:35.830]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:35.830]                   base::options(opts)
[17:36:35.830]                 }
[17:36:35.830]                 {
[17:36:35.830]                   {
[17:36:35.830]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:35.830]                     NULL
[17:36:35.830]                   }
[17:36:35.830]                   options(future.plan = NULL)
[17:36:35.830]                   if (is.na(NA_character_)) 
[17:36:35.830]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.830]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:35.830]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:35.830]                     .init = FALSE)
[17:36:35.830]                 }
[17:36:35.830]             }
[17:36:35.830]         }
[17:36:35.830]     })
[17:36:35.830]     if (TRUE) {
[17:36:35.830]         base::sink(type = "output", split = FALSE)
[17:36:35.830]         if (TRUE) {
[17:36:35.830]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:35.830]         }
[17:36:35.830]         else {
[17:36:35.830]             ...future.result["stdout"] <- base::list(NULL)
[17:36:35.830]         }
[17:36:35.830]         base::close(...future.stdout)
[17:36:35.830]         ...future.stdout <- NULL
[17:36:35.830]     }
[17:36:35.830]     ...future.result$conditions <- ...future.conditions
[17:36:35.830]     ...future.result$finished <- base::Sys.time()
[17:36:35.830]     ...future.result
[17:36:35.830] }
[17:36:35.832] assign_globals() ...
[17:36:35.832] List of 5
[17:36:35.832]  $ future.call.arguments    : list()
[17:36:35.832]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.832]  $ ...future.FUN            :function (x)  
[17:36:35.832]  $ ...future.elements_ii    :List of 3
[17:36:35.832]   ..$ : int [1:4] 4 10 16 22
[17:36:35.832]   ..$ : int [1:4] 5 11 17 23
[17:36:35.832]   ..$ : int [1:4] 6 12 18 24
[17:36:35.832]  $ ...future.seeds_ii       : NULL
[17:36:35.832]  $ ...future.globals.maxSize: num Inf
[17:36:35.832]  - attr(*, "resolved")= logi FALSE
[17:36:35.832]  - attr(*, "total_size")= num NA
[17:36:35.832]  - attr(*, "where")=List of 5
[17:36:35.832]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:35.832]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:35.832]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:35.832]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:35.832]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:35.832]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.832]  - attr(*, "already-done")= logi TRUE
[17:36:35.839] - copied ‘future.call.arguments’ to environment
[17:36:35.840] - reassign environment for ‘...future.FUN’
[17:36:35.840] - copied ‘...future.FUN’ to environment
[17:36:35.840] - copied ‘...future.elements_ii’ to environment
[17:36:35.840] - copied ‘...future.seeds_ii’ to environment
[17:36:35.840] - copied ‘...future.globals.maxSize’ to environment
[17:36:35.840] assign_globals() ... done
[17:36:35.840] requestCore(): workers = 2
[17:36:35.843] MulticoreFuture started
[17:36:35.843] - Launch lazy future ... done
[17:36:35.843] run() for ‘MulticoreFuture’ ... done
[17:36:35.844] Created future:
[17:36:35.844] plan(): Setting new future strategy stack:
[17:36:35.844] List of future strategies:
[17:36:35.844] 1. sequential:
[17:36:35.844]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:35.844]    - tweaked: FALSE
[17:36:35.844]    - call: NULL
[17:36:35.845] plan(): nbrOfWorkers() = 1
[17:36:35.847] plan(): Setting new future strategy stack:
[17:36:35.847] List of future strategies:
[17:36:35.847] 1. multicore:
[17:36:35.847]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:35.847]    - tweaked: FALSE
[17:36:35.847]    - call: plan(strategy)
[17:36:35.852] plan(): nbrOfWorkers() = 2
[17:36:35.844] MulticoreFuture:
[17:36:35.844] Label: ‘future_apply-2’
[17:36:35.844] Expression:
[17:36:35.844] {
[17:36:35.844]     do.call(function(...) {
[17:36:35.844]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.844]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.844]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.844]             on.exit(options(oopts), add = TRUE)
[17:36:35.844]         }
[17:36:35.844]         {
[17:36:35.844]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.844]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.844]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.844]             })
[17:36:35.844]         }
[17:36:35.844]     }, args = future.call.arguments)
[17:36:35.844] }
[17:36:35.844] Lazy evaluation: FALSE
[17:36:35.844] Asynchronous evaluation: TRUE
[17:36:35.844] Local evaluation: TRUE
[17:36:35.844] Environment: R_GlobalEnv
[17:36:35.844] Capture standard output: TRUE
[17:36:35.844] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:35.844] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:35.844] Packages: <none>
[17:36:35.844] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:35.844] Resolved: TRUE
[17:36:35.844] Value: <not collected>
[17:36:35.844] Conditions captured: <none>
[17:36:35.844] Early signaling: FALSE
[17:36:35.844] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:35.844] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.853] Chunk #2 of 2 ... DONE
[17:36:35.854] Launching 2 futures (chunks) ... DONE
[17:36:35.854] Resolving 2 futures (chunks) ...
[17:36:35.854] resolve() on list ...
[17:36:35.854]  recursive: 0
[17:36:35.854]  length: 2
[17:36:35.854] 
[17:36:35.855] Future #1
[17:36:35.855] result() for MulticoreFuture ...
[17:36:35.856] result() for MulticoreFuture ...
[17:36:35.856] result() for MulticoreFuture ... done
[17:36:35.856] result() for MulticoreFuture ... done
[17:36:35.856] result() for MulticoreFuture ...
[17:36:35.856] result() for MulticoreFuture ... done
[17:36:35.856] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:36:35.857] - nx: 2
[17:36:35.857] - relay: TRUE
[17:36:35.857] - stdout: TRUE
[17:36:35.857] - signal: TRUE
[17:36:35.857] - resignal: FALSE
[17:36:35.857] - force: TRUE
[17:36:35.857] - relayed: [n=2] FALSE, FALSE
[17:36:35.858] - queued futures: [n=2] FALSE, FALSE
[17:36:35.858]  - until=1
[17:36:35.858]  - relaying element #1
[17:36:35.858] result() for MulticoreFuture ...
[17:36:35.858] result() for MulticoreFuture ... done
[17:36:35.858] result() for MulticoreFuture ...
[17:36:35.858] result() for MulticoreFuture ... done
[17:36:35.859] result() for MulticoreFuture ...
[17:36:35.859] result() for MulticoreFuture ... done
[17:36:35.859] result() for MulticoreFuture ...
[17:36:35.859] result() for MulticoreFuture ... done
[17:36:35.859] - relayed: [n=2] TRUE, FALSE
[17:36:35.859] - queued futures: [n=2] TRUE, FALSE
[17:36:35.860] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:36:35.860]  length: 1 (resolved future 1)
[17:36:35.860] Future #2
[17:36:35.860] result() for MulticoreFuture ...
[17:36:35.861] result() for MulticoreFuture ...
[17:36:35.861] result() for MulticoreFuture ... done
[17:36:35.861] result() for MulticoreFuture ... done
[17:36:35.861] result() for MulticoreFuture ...
[17:36:35.861] result() for MulticoreFuture ... done
[17:36:35.862] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:36:35.862] - nx: 2
[17:36:35.862] - relay: TRUE
[17:36:35.862] - stdout: TRUE
[17:36:35.862] - signal: TRUE
[17:36:35.862] - resignal: FALSE
[17:36:35.862] - force: TRUE
[17:36:35.862] - relayed: [n=2] TRUE, FALSE
[17:36:35.863] - queued futures: [n=2] TRUE, FALSE
[17:36:35.863]  - until=2
[17:36:35.863]  - relaying element #2
[17:36:35.863] result() for MulticoreFuture ...
[17:36:35.863] result() for MulticoreFuture ... done
[17:36:35.863] result() for MulticoreFuture ...
[17:36:35.863] result() for MulticoreFuture ... done
[17:36:35.863] result() for MulticoreFuture ...
[17:36:35.864] result() for MulticoreFuture ... done
[17:36:35.864] result() for MulticoreFuture ...
[17:36:35.864] result() for MulticoreFuture ... done
[17:36:35.864] - relayed: [n=2] TRUE, TRUE
[17:36:35.864] - queued futures: [n=2] TRUE, TRUE
[17:36:35.864] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:36:35.864]  length: 0 (resolved future 2)
[17:36:35.864] Relaying remaining futures
[17:36:35.864] signalConditionsASAP(NULL, pos=0) ...
[17:36:35.865] - nx: 2
[17:36:35.865] - relay: TRUE
[17:36:35.865] - stdout: TRUE
[17:36:35.865] - signal: TRUE
[17:36:35.865] - resignal: FALSE
[17:36:35.867] - force: TRUE
[17:36:35.868] - relayed: [n=2] TRUE, TRUE
[17:36:35.868] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:35.868] - relayed: [n=2] TRUE, TRUE
[17:36:35.868] - queued futures: [n=2] TRUE, TRUE
[17:36:35.869] signalConditionsASAP(NULL, pos=0) ... done
[17:36:35.869] resolve() on list ... DONE
[17:36:35.869] result() for MulticoreFuture ...
[17:36:35.869] result() for MulticoreFuture ... done
[17:36:35.869] result() for MulticoreFuture ...
[17:36:35.869] result() for MulticoreFuture ... done
[17:36:35.870] result() for MulticoreFuture ...
[17:36:35.870] result() for MulticoreFuture ... done
[17:36:35.870] result() for MulticoreFuture ...
[17:36:35.870] result() for MulticoreFuture ... done
[17:36:35.870]  - Number of value chunks collected: 2
[17:36:35.870] Resolving 2 futures (chunks) ... DONE
[17:36:35.871] Reducing values from 2 chunks ...
[17:36:35.871]  - Number of values collected after concatenation: 6
[17:36:35.871]  - Number of values expected: 6
[17:36:35.871] Reducing values from 2 chunks ... DONE
[17:36:35.871] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[17:36:35.872] getGlobalsAndPackagesXApply() ...
[17:36:35.872]  - future.globals: TRUE
[17:36:35.872] getGlobalsAndPackages() ...
[17:36:35.872] Searching for globals...
[17:36:35.873] - globals found: [1] ‘FUN’
[17:36:35.874] Searching for globals ... DONE
[17:36:35.874] Resolving globals: FALSE
[17:36:35.874] The total size of the 1 globals is 848 bytes (848 bytes)
[17:36:35.875] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:36:35.875] - globals: [1] ‘FUN’
[17:36:35.875] 
[17:36:35.875] getGlobalsAndPackages() ... DONE
[17:36:35.875]  - globals found/used: [n=1] ‘FUN’
[17:36:35.875]  - needed namespaces: [n=0] 
[17:36:35.875] Finding globals ... DONE
[17:36:35.875]  - use_args: TRUE
[17:36:35.876]  - Getting '...' globals ...
[17:36:35.876] resolve() on list ...
[17:36:35.876]  recursive: 0
[17:36:35.876]  length: 1
[17:36:35.876]  elements: ‘...’
[17:36:35.876]  length: 0 (resolved future 1)
[17:36:35.876] resolve() on list ... DONE
[17:36:35.877]    - '...' content: [n=0] 
[17:36:35.877] List of 1
[17:36:35.877]  $ ...: list()
[17:36:35.877]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.877]  - attr(*, "where")=List of 1
[17:36:35.877]   ..$ ...:<environment: 0x556d75a570f8> 
[17:36:35.877]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.877]  - attr(*, "resolved")= logi TRUE
[17:36:35.877]  - attr(*, "total_size")= num NA
[17:36:35.880]  - Getting '...' globals ... DONE
[17:36:35.880] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:35.880] List of 2
[17:36:35.880]  $ ...future.FUN:function (x)  
[17:36:35.880]  $ ...          : list()
[17:36:35.880]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.880]  - attr(*, "where")=List of 2
[17:36:35.880]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:35.880]   ..$ ...          :<environment: 0x556d75a570f8> 
[17:36:35.880]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.880]  - attr(*, "resolved")= logi FALSE
[17:36:35.880]  - attr(*, "total_size")= num 848
[17:36:35.883] Packages to be attached in all futures: [n=0] 
[17:36:35.883] getGlobalsAndPackagesXApply() ... DONE
[17:36:35.887] future_lapply() ...
[17:36:35.890] Number of chunks: 2
[17:36:35.891] getGlobalsAndPackagesXApply() ...
[17:36:35.891]  - future.globals: <name-value list> with names ‘list()’
[17:36:35.891]  - use_args: TRUE
[17:36:35.891] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:35.891] List of 2
[17:36:35.891]  $ ...          : list()
[17:36:35.891]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.891]  $ ...future.FUN:function (x)  
[17:36:35.891]  - attr(*, "where")=List of 2
[17:36:35.891]   ..$ ...          :<environment: 0x556d75a570f8> 
[17:36:35.891]   ..$ ...future.FUN:<environment: namespace:base> 
[17:36:35.891]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.891]  - attr(*, "resolved")= logi FALSE
[17:36:35.891]  - attr(*, "total_size")= num NA
[17:36:35.894] Packages to be attached in all futures: [n=0] 
[17:36:35.894] getGlobalsAndPackagesXApply() ... DONE
[17:36:35.895] Number of futures (= number of chunks): 2
[17:36:35.895] Launching 2 futures (chunks) ...
[17:36:35.895] Chunk #1 of 2 ...
[17:36:35.895]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:35.895]  - seeds: <none>
[17:36:35.895]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.895] getGlobalsAndPackages() ...
[17:36:35.895] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.896] Resolving globals: FALSE
[17:36:35.896] Tweak future expression to call with '...' arguments ...
[17:36:35.896] {
[17:36:35.896]     do.call(function(...) {
[17:36:35.896]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.896]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.896]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.896]             on.exit(options(oopts), add = TRUE)
[17:36:35.896]         }
[17:36:35.896]         {
[17:36:35.896]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.896]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.896]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.896]             })
[17:36:35.896]         }
[17:36:35.896]     }, args = future.call.arguments)
[17:36:35.896] }
[17:36:35.896] Tweak future expression to call with '...' arguments ... DONE
[17:36:35.896] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.897] 
[17:36:35.897] getGlobalsAndPackages() ... DONE
[17:36:35.897] run() for ‘Future’ ...
[17:36:35.897] - state: ‘created’
[17:36:35.897] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:35.903] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.903] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:35.903]   - Field: ‘label’
[17:36:35.903]   - Field: ‘local’
[17:36:35.903]   - Field: ‘owner’
[17:36:35.903]   - Field: ‘envir’
[17:36:35.903]   - Field: ‘workers’
[17:36:35.904]   - Field: ‘packages’
[17:36:35.904]   - Field: ‘gc’
[17:36:35.904]   - Field: ‘job’
[17:36:35.904]   - Field: ‘conditions’
[17:36:35.904]   - Field: ‘expr’
[17:36:35.904]   - Field: ‘uuid’
[17:36:35.904]   - Field: ‘seed’
[17:36:35.904]   - Field: ‘version’
[17:36:35.904]   - Field: ‘result’
[17:36:35.905]   - Field: ‘asynchronous’
[17:36:35.905]   - Field: ‘calls’
[17:36:35.905]   - Field: ‘globals’
[17:36:35.905]   - Field: ‘stdout’
[17:36:35.905]   - Field: ‘earlySignal’
[17:36:35.905]   - Field: ‘lazy’
[17:36:35.905]   - Field: ‘state’
[17:36:35.905] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:35.905] - Launch lazy future ...
[17:36:35.906] Packages needed by the future expression (n = 0): <none>
[17:36:35.906] Packages needed by future strategies (n = 0): <none>
[17:36:35.906] {
[17:36:35.906]     {
[17:36:35.906]         {
[17:36:35.906]             ...future.startTime <- base::Sys.time()
[17:36:35.906]             {
[17:36:35.906]                 {
[17:36:35.906]                   {
[17:36:35.906]                     {
[17:36:35.906]                       base::local({
[17:36:35.906]                         has_future <- base::requireNamespace("future", 
[17:36:35.906]                           quietly = TRUE)
[17:36:35.906]                         if (has_future) {
[17:36:35.906]                           ns <- base::getNamespace("future")
[17:36:35.906]                           version <- ns[[".package"]][["version"]]
[17:36:35.906]                           if (is.null(version)) 
[17:36:35.906]                             version <- utils::packageVersion("future")
[17:36:35.906]                         }
[17:36:35.906]                         else {
[17:36:35.906]                           version <- NULL
[17:36:35.906]                         }
[17:36:35.906]                         if (!has_future || version < "1.8.0") {
[17:36:35.906]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:35.906]                             "", base::R.version$version.string), 
[17:36:35.906]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:35.906]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:35.906]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:35.906]                               "release", "version")], collapse = " "), 
[17:36:35.906]                             hostname = base::Sys.info()[["nodename"]])
[17:36:35.906]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:35.906]                             info)
[17:36:35.906]                           info <- base::paste(info, collapse = "; ")
[17:36:35.906]                           if (!has_future) {
[17:36:35.906]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:35.906]                               info)
[17:36:35.906]                           }
[17:36:35.906]                           else {
[17:36:35.906]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:35.906]                               info, version)
[17:36:35.906]                           }
[17:36:35.906]                           base::stop(msg)
[17:36:35.906]                         }
[17:36:35.906]                       })
[17:36:35.906]                     }
[17:36:35.906]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:35.906]                     base::options(mc.cores = 1L)
[17:36:35.906]                   }
[17:36:35.906]                   ...future.strategy.old <- future::plan("list")
[17:36:35.906]                   options(future.plan = NULL)
[17:36:35.906]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.906]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:35.906]                 }
[17:36:35.906]                 ...future.workdir <- getwd()
[17:36:35.906]             }
[17:36:35.906]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:35.906]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:35.906]         }
[17:36:35.906]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:35.906]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:35.906]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:35.906]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:35.906]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:35.906]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:35.906]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:35.906]             base::names(...future.oldOptions))
[17:36:35.906]     }
[17:36:35.906]     if (FALSE) {
[17:36:35.906]     }
[17:36:35.906]     else {
[17:36:35.906]         if (TRUE) {
[17:36:35.906]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:35.906]                 open = "w")
[17:36:35.906]         }
[17:36:35.906]         else {
[17:36:35.906]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:35.906]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:35.906]         }
[17:36:35.906]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:35.906]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:35.906]             base::sink(type = "output", split = FALSE)
[17:36:35.906]             base::close(...future.stdout)
[17:36:35.906]         }, add = TRUE)
[17:36:35.906]     }
[17:36:35.906]     ...future.frame <- base::sys.nframe()
[17:36:35.906]     ...future.conditions <- base::list()
[17:36:35.906]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:35.906]     if (FALSE) {
[17:36:35.906]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:35.906]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:35.906]     }
[17:36:35.906]     ...future.result <- base::tryCatch({
[17:36:35.906]         base::withCallingHandlers({
[17:36:35.906]             ...future.value <- base::withVisible(base::local({
[17:36:35.906]                 withCallingHandlers({
[17:36:35.906]                   {
[17:36:35.906]                     do.call(function(...) {
[17:36:35.906]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.906]                       if (!identical(...future.globals.maxSize.org, 
[17:36:35.906]                         ...future.globals.maxSize)) {
[17:36:35.906]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.906]                         on.exit(options(oopts), add = TRUE)
[17:36:35.906]                       }
[17:36:35.906]                       {
[17:36:35.906]                         lapply(seq_along(...future.elements_ii), 
[17:36:35.906]                           FUN = function(jj) {
[17:36:35.906]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.906]                             ...future.FUN(...future.X_jj, ...)
[17:36:35.906]                           })
[17:36:35.906]                       }
[17:36:35.906]                     }, args = future.call.arguments)
[17:36:35.906]                   }
[17:36:35.906]                 }, immediateCondition = function(cond) {
[17:36:35.906]                   save_rds <- function (object, pathname, ...) 
[17:36:35.906]                   {
[17:36:35.906]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:35.906]                     if (file_test("-f", pathname_tmp)) {
[17:36:35.906]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.906]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:35.906]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.906]                         fi_tmp[["mtime"]])
[17:36:35.906]                     }
[17:36:35.906]                     tryCatch({
[17:36:35.906]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:35.906]                     }, error = function(ex) {
[17:36:35.906]                       msg <- conditionMessage(ex)
[17:36:35.906]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.906]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:35.906]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.906]                         fi_tmp[["mtime"]], msg)
[17:36:35.906]                       ex$message <- msg
[17:36:35.906]                       stop(ex)
[17:36:35.906]                     })
[17:36:35.906]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:35.906]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:35.906]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:35.906]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.906]                       fi <- file.info(pathname)
[17:36:35.906]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:35.906]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.906]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:35.906]                         fi[["size"]], fi[["mtime"]])
[17:36:35.906]                       stop(msg)
[17:36:35.906]                     }
[17:36:35.906]                     invisible(pathname)
[17:36:35.906]                   }
[17:36:35.906]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:35.906]                     rootPath = tempdir()) 
[17:36:35.906]                   {
[17:36:35.906]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:35.906]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:35.906]                       tmpdir = path, fileext = ".rds")
[17:36:35.906]                     save_rds(obj, file)
[17:36:35.906]                   }
[17:36:35.906]                   saveImmediateCondition(cond, path = "/tmp/RtmpABg8SG/.future/immediateConditions")
[17:36:35.906]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.906]                   {
[17:36:35.906]                     inherits <- base::inherits
[17:36:35.906]                     invokeRestart <- base::invokeRestart
[17:36:35.906]                     is.null <- base::is.null
[17:36:35.906]                     muffled <- FALSE
[17:36:35.906]                     if (inherits(cond, "message")) {
[17:36:35.906]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:35.906]                       if (muffled) 
[17:36:35.906]                         invokeRestart("muffleMessage")
[17:36:35.906]                     }
[17:36:35.906]                     else if (inherits(cond, "warning")) {
[17:36:35.906]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:35.906]                       if (muffled) 
[17:36:35.906]                         invokeRestart("muffleWarning")
[17:36:35.906]                     }
[17:36:35.906]                     else if (inherits(cond, "condition")) {
[17:36:35.906]                       if (!is.null(pattern)) {
[17:36:35.906]                         computeRestarts <- base::computeRestarts
[17:36:35.906]                         grepl <- base::grepl
[17:36:35.906]                         restarts <- computeRestarts(cond)
[17:36:35.906]                         for (restart in restarts) {
[17:36:35.906]                           name <- restart$name
[17:36:35.906]                           if (is.null(name)) 
[17:36:35.906]                             next
[17:36:35.906]                           if (!grepl(pattern, name)) 
[17:36:35.906]                             next
[17:36:35.906]                           invokeRestart(restart)
[17:36:35.906]                           muffled <- TRUE
[17:36:35.906]                           break
[17:36:35.906]                         }
[17:36:35.906]                       }
[17:36:35.906]                     }
[17:36:35.906]                     invisible(muffled)
[17:36:35.906]                   }
[17:36:35.906]                   muffleCondition(cond)
[17:36:35.906]                 })
[17:36:35.906]             }))
[17:36:35.906]             future::FutureResult(value = ...future.value$value, 
[17:36:35.906]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.906]                   ...future.rng), globalenv = if (FALSE) 
[17:36:35.906]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:35.906]                     ...future.globalenv.names))
[17:36:35.906]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:35.906]         }, condition = base::local({
[17:36:35.906]             c <- base::c
[17:36:35.906]             inherits <- base::inherits
[17:36:35.906]             invokeRestart <- base::invokeRestart
[17:36:35.906]             length <- base::length
[17:36:35.906]             list <- base::list
[17:36:35.906]             seq.int <- base::seq.int
[17:36:35.906]             signalCondition <- base::signalCondition
[17:36:35.906]             sys.calls <- base::sys.calls
[17:36:35.906]             `[[` <- base::`[[`
[17:36:35.906]             `+` <- base::`+`
[17:36:35.906]             `<<-` <- base::`<<-`
[17:36:35.906]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:35.906]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:35.906]                   3L)]
[17:36:35.906]             }
[17:36:35.906]             function(cond) {
[17:36:35.906]                 is_error <- inherits(cond, "error")
[17:36:35.906]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:35.906]                   NULL)
[17:36:35.906]                 if (is_error) {
[17:36:35.906]                   sessionInformation <- function() {
[17:36:35.906]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:35.906]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:35.906]                       search = base::search(), system = base::Sys.info())
[17:36:35.906]                   }
[17:36:35.906]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.906]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:35.906]                     cond$call), session = sessionInformation(), 
[17:36:35.906]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:35.906]                   signalCondition(cond)
[17:36:35.906]                 }
[17:36:35.906]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:35.906]                 "immediateCondition"))) {
[17:36:35.906]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:35.906]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.906]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:35.906]                   if (TRUE && !signal) {
[17:36:35.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.906]                     {
[17:36:35.906]                       inherits <- base::inherits
[17:36:35.906]                       invokeRestart <- base::invokeRestart
[17:36:35.906]                       is.null <- base::is.null
[17:36:35.906]                       muffled <- FALSE
[17:36:35.906]                       if (inherits(cond, "message")) {
[17:36:35.906]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.906]                         if (muffled) 
[17:36:35.906]                           invokeRestart("muffleMessage")
[17:36:35.906]                       }
[17:36:35.906]                       else if (inherits(cond, "warning")) {
[17:36:35.906]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.906]                         if (muffled) 
[17:36:35.906]                           invokeRestart("muffleWarning")
[17:36:35.906]                       }
[17:36:35.906]                       else if (inherits(cond, "condition")) {
[17:36:35.906]                         if (!is.null(pattern)) {
[17:36:35.906]                           computeRestarts <- base::computeRestarts
[17:36:35.906]                           grepl <- base::grepl
[17:36:35.906]                           restarts <- computeRestarts(cond)
[17:36:35.906]                           for (restart in restarts) {
[17:36:35.906]                             name <- restart$name
[17:36:35.906]                             if (is.null(name)) 
[17:36:35.906]                               next
[17:36:35.906]                             if (!grepl(pattern, name)) 
[17:36:35.906]                               next
[17:36:35.906]                             invokeRestart(restart)
[17:36:35.906]                             muffled <- TRUE
[17:36:35.906]                             break
[17:36:35.906]                           }
[17:36:35.906]                         }
[17:36:35.906]                       }
[17:36:35.906]                       invisible(muffled)
[17:36:35.906]                     }
[17:36:35.906]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.906]                   }
[17:36:35.906]                 }
[17:36:35.906]                 else {
[17:36:35.906]                   if (TRUE) {
[17:36:35.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.906]                     {
[17:36:35.906]                       inherits <- base::inherits
[17:36:35.906]                       invokeRestart <- base::invokeRestart
[17:36:35.906]                       is.null <- base::is.null
[17:36:35.906]                       muffled <- FALSE
[17:36:35.906]                       if (inherits(cond, "message")) {
[17:36:35.906]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.906]                         if (muffled) 
[17:36:35.906]                           invokeRestart("muffleMessage")
[17:36:35.906]                       }
[17:36:35.906]                       else if (inherits(cond, "warning")) {
[17:36:35.906]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.906]                         if (muffled) 
[17:36:35.906]                           invokeRestart("muffleWarning")
[17:36:35.906]                       }
[17:36:35.906]                       else if (inherits(cond, "condition")) {
[17:36:35.906]                         if (!is.null(pattern)) {
[17:36:35.906]                           computeRestarts <- base::computeRestarts
[17:36:35.906]                           grepl <- base::grepl
[17:36:35.906]                           restarts <- computeRestarts(cond)
[17:36:35.906]                           for (restart in restarts) {
[17:36:35.906]                             name <- restart$name
[17:36:35.906]                             if (is.null(name)) 
[17:36:35.906]                               next
[17:36:35.906]                             if (!grepl(pattern, name)) 
[17:36:35.906]                               next
[17:36:35.906]                             invokeRestart(restart)
[17:36:35.906]                             muffled <- TRUE
[17:36:35.906]                             break
[17:36:35.906]                           }
[17:36:35.906]                         }
[17:36:35.906]                       }
[17:36:35.906]                       invisible(muffled)
[17:36:35.906]                     }
[17:36:35.906]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.906]                   }
[17:36:35.906]                 }
[17:36:35.906]             }
[17:36:35.906]         }))
[17:36:35.906]     }, error = function(ex) {
[17:36:35.906]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:35.906]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.906]                 ...future.rng), started = ...future.startTime, 
[17:36:35.906]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:35.906]             version = "1.8"), class = "FutureResult")
[17:36:35.906]     }, finally = {
[17:36:35.906]         if (!identical(...future.workdir, getwd())) 
[17:36:35.906]             setwd(...future.workdir)
[17:36:35.906]         {
[17:36:35.906]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:35.906]                 ...future.oldOptions$nwarnings <- NULL
[17:36:35.906]             }
[17:36:35.906]             base::options(...future.oldOptions)
[17:36:35.906]             if (.Platform$OS.type == "windows") {
[17:36:35.906]                 old_names <- names(...future.oldEnvVars)
[17:36:35.906]                 envs <- base::Sys.getenv()
[17:36:35.906]                 names <- names(envs)
[17:36:35.906]                 common <- intersect(names, old_names)
[17:36:35.906]                 added <- setdiff(names, old_names)
[17:36:35.906]                 removed <- setdiff(old_names, names)
[17:36:35.906]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:35.906]                   envs[common]]
[17:36:35.906]                 NAMES <- toupper(changed)
[17:36:35.906]                 args <- list()
[17:36:35.906]                 for (kk in seq_along(NAMES)) {
[17:36:35.906]                   name <- changed[[kk]]
[17:36:35.906]                   NAME <- NAMES[[kk]]
[17:36:35.906]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.906]                     next
[17:36:35.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.906]                 }
[17:36:35.906]                 NAMES <- toupper(added)
[17:36:35.906]                 for (kk in seq_along(NAMES)) {
[17:36:35.906]                   name <- added[[kk]]
[17:36:35.906]                   NAME <- NAMES[[kk]]
[17:36:35.906]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.906]                     next
[17:36:35.906]                   args[[name]] <- ""
[17:36:35.906]                 }
[17:36:35.906]                 NAMES <- toupper(removed)
[17:36:35.906]                 for (kk in seq_along(NAMES)) {
[17:36:35.906]                   name <- removed[[kk]]
[17:36:35.906]                   NAME <- NAMES[[kk]]
[17:36:35.906]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.906]                     next
[17:36:35.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.906]                 }
[17:36:35.906]                 if (length(args) > 0) 
[17:36:35.906]                   base::do.call(base::Sys.setenv, args = args)
[17:36:35.906]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:35.906]             }
[17:36:35.906]             else {
[17:36:35.906]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:35.906]             }
[17:36:35.906]             {
[17:36:35.906]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:35.906]                   0L) {
[17:36:35.906]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:35.906]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:35.906]                   base::options(opts)
[17:36:35.906]                 }
[17:36:35.906]                 {
[17:36:35.906]                   {
[17:36:35.906]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:35.906]                     NULL
[17:36:35.906]                   }
[17:36:35.906]                   options(future.plan = NULL)
[17:36:35.906]                   if (is.na(NA_character_)) 
[17:36:35.906]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.906]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:35.906]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:35.906]                     .init = FALSE)
[17:36:35.906]                 }
[17:36:35.906]             }
[17:36:35.906]         }
[17:36:35.906]     })
[17:36:35.906]     if (TRUE) {
[17:36:35.906]         base::sink(type = "output", split = FALSE)
[17:36:35.906]         if (TRUE) {
[17:36:35.906]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:35.906]         }
[17:36:35.906]         else {
[17:36:35.906]             ...future.result["stdout"] <- base::list(NULL)
[17:36:35.906]         }
[17:36:35.906]         base::close(...future.stdout)
[17:36:35.906]         ...future.stdout <- NULL
[17:36:35.906]     }
[17:36:35.906]     ...future.result$conditions <- ...future.conditions
[17:36:35.906]     ...future.result$finished <- base::Sys.time()
[17:36:35.906]     ...future.result
[17:36:35.906] }
[17:36:35.908] assign_globals() ...
[17:36:35.909] List of 5
[17:36:35.909]  $ future.call.arguments    : list()
[17:36:35.909]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.909]  $ ...future.FUN            :function (x)  
[17:36:35.909]  $ ...future.elements_ii    :List of 1
[17:36:35.909]   ..$ : int 1
[17:36:35.909]  $ ...future.seeds_ii       : NULL
[17:36:35.909]  $ ...future.globals.maxSize: num Inf
[17:36:35.909]  - attr(*, "resolved")= logi FALSE
[17:36:35.909]  - attr(*, "total_size")= num NA
[17:36:35.909]  - attr(*, "where")=List of 5
[17:36:35.909]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:35.909]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:35.909]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:35.909]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:35.909]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:35.909]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.909]  - attr(*, "already-done")= logi TRUE
[17:36:35.913] - copied ‘future.call.arguments’ to environment
[17:36:35.913] - copied ‘...future.FUN’ to environment
[17:36:35.913] - copied ‘...future.elements_ii’ to environment
[17:36:35.914] - copied ‘...future.seeds_ii’ to environment
[17:36:35.914] - copied ‘...future.globals.maxSize’ to environment
[17:36:35.914] assign_globals() ... done
[17:36:35.914] requestCore(): workers = 2
[17:36:35.916] MulticoreFuture started
[17:36:35.916] - Launch lazy future ... done
[17:36:35.917] run() for ‘MulticoreFuture’ ... done
[17:36:35.917] Created future:
[17:36:35.917] plan(): Setting new future strategy stack:
[17:36:35.917] List of future strategies:
[17:36:35.917] 1. sequential:
[17:36:35.917]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:35.917]    - tweaked: FALSE
[17:36:35.917]    - call: NULL
[17:36:35.918] plan(): nbrOfWorkers() = 1
[17:36:35.920] plan(): Setting new future strategy stack:
[17:36:35.921] List of future strategies:
[17:36:35.921] 1. multicore:
[17:36:35.921]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:35.921]    - tweaked: FALSE
[17:36:35.921]    - call: plan(strategy)
[17:36:35.926] plan(): nbrOfWorkers() = 2
[17:36:35.917] MulticoreFuture:
[17:36:35.917] Label: ‘future_apply-1’
[17:36:35.917] Expression:
[17:36:35.917] {
[17:36:35.917]     do.call(function(...) {
[17:36:35.917]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.917]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.917]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.917]             on.exit(options(oopts), add = TRUE)
[17:36:35.917]         }
[17:36:35.917]         {
[17:36:35.917]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.917]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.917]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.917]             })
[17:36:35.917]         }
[17:36:35.917]     }, args = future.call.arguments)
[17:36:35.917] }
[17:36:35.917] Lazy evaluation: FALSE
[17:36:35.917] Asynchronous evaluation: TRUE
[17:36:35.917] Local evaluation: TRUE
[17:36:35.917] Environment: R_GlobalEnv
[17:36:35.917] Capture standard output: TRUE
[17:36:35.917] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:35.917] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:35.917] Packages: <none>
[17:36:35.917] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:35.917] Resolved: TRUE
[17:36:35.917] Value: <not collected>
[17:36:35.917] Conditions captured: <none>
[17:36:35.917] Early signaling: FALSE
[17:36:35.917] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:35.917] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.927] Chunk #1 of 2 ... DONE
[17:36:35.927] Chunk #2 of 2 ...
[17:36:35.927]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:35.927]  - seeds: <none>
[17:36:35.927]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.928] getGlobalsAndPackages() ...
[17:36:35.928] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.928] Resolving globals: FALSE
[17:36:35.928] Tweak future expression to call with '...' arguments ...
[17:36:35.928] {
[17:36:35.928]     do.call(function(...) {
[17:36:35.928]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.928]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.928]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.928]             on.exit(options(oopts), add = TRUE)
[17:36:35.928]         }
[17:36:35.928]         {
[17:36:35.928]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.928]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.928]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.928]             })
[17:36:35.928]         }
[17:36:35.928]     }, args = future.call.arguments)
[17:36:35.928] }
[17:36:35.929] Tweak future expression to call with '...' arguments ... DONE
[17:36:35.929] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:35.929] 
[17:36:35.930] getGlobalsAndPackages() ... DONE
[17:36:35.930] run() for ‘Future’ ...
[17:36:35.930] - state: ‘created’
[17:36:35.931] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:35.935] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.935] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:35.935]   - Field: ‘label’
[17:36:35.936]   - Field: ‘local’
[17:36:35.936]   - Field: ‘owner’
[17:36:35.936]   - Field: ‘envir’
[17:36:35.936]   - Field: ‘workers’
[17:36:35.936]   - Field: ‘packages’
[17:36:35.936]   - Field: ‘gc’
[17:36:35.937]   - Field: ‘job’
[17:36:35.937]   - Field: ‘conditions’
[17:36:35.937]   - Field: ‘expr’
[17:36:35.937]   - Field: ‘uuid’
[17:36:35.937]   - Field: ‘seed’
[17:36:35.937]   - Field: ‘version’
[17:36:35.937]   - Field: ‘result’
[17:36:35.937]   - Field: ‘asynchronous’
[17:36:35.938]   - Field: ‘calls’
[17:36:35.938]   - Field: ‘globals’
[17:36:35.938]   - Field: ‘stdout’
[17:36:35.938]   - Field: ‘earlySignal’
[17:36:35.938]   - Field: ‘lazy’
[17:36:35.938]   - Field: ‘state’
[17:36:35.939] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:35.939] - Launch lazy future ...
[17:36:35.939] Packages needed by the future expression (n = 0): <none>
[17:36:35.939] Packages needed by future strategies (n = 0): <none>
[17:36:35.940] {
[17:36:35.940]     {
[17:36:35.940]         {
[17:36:35.940]             ...future.startTime <- base::Sys.time()
[17:36:35.940]             {
[17:36:35.940]                 {
[17:36:35.940]                   {
[17:36:35.940]                     {
[17:36:35.940]                       base::local({
[17:36:35.940]                         has_future <- base::requireNamespace("future", 
[17:36:35.940]                           quietly = TRUE)
[17:36:35.940]                         if (has_future) {
[17:36:35.940]                           ns <- base::getNamespace("future")
[17:36:35.940]                           version <- ns[[".package"]][["version"]]
[17:36:35.940]                           if (is.null(version)) 
[17:36:35.940]                             version <- utils::packageVersion("future")
[17:36:35.940]                         }
[17:36:35.940]                         else {
[17:36:35.940]                           version <- NULL
[17:36:35.940]                         }
[17:36:35.940]                         if (!has_future || version < "1.8.0") {
[17:36:35.940]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:35.940]                             "", base::R.version$version.string), 
[17:36:35.940]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:35.940]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:35.940]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:35.940]                               "release", "version")], collapse = " "), 
[17:36:35.940]                             hostname = base::Sys.info()[["nodename"]])
[17:36:35.940]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:35.940]                             info)
[17:36:35.940]                           info <- base::paste(info, collapse = "; ")
[17:36:35.940]                           if (!has_future) {
[17:36:35.940]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:35.940]                               info)
[17:36:35.940]                           }
[17:36:35.940]                           else {
[17:36:35.940]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:35.940]                               info, version)
[17:36:35.940]                           }
[17:36:35.940]                           base::stop(msg)
[17:36:35.940]                         }
[17:36:35.940]                       })
[17:36:35.940]                     }
[17:36:35.940]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:35.940]                     base::options(mc.cores = 1L)
[17:36:35.940]                   }
[17:36:35.940]                   ...future.strategy.old <- future::plan("list")
[17:36:35.940]                   options(future.plan = NULL)
[17:36:35.940]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.940]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:35.940]                 }
[17:36:35.940]                 ...future.workdir <- getwd()
[17:36:35.940]             }
[17:36:35.940]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:35.940]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:35.940]         }
[17:36:35.940]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:35.940]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:35.940]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:35.940]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:35.940]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:35.940]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:35.940]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:35.940]             base::names(...future.oldOptions))
[17:36:35.940]     }
[17:36:35.940]     if (FALSE) {
[17:36:35.940]     }
[17:36:35.940]     else {
[17:36:35.940]         if (TRUE) {
[17:36:35.940]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:35.940]                 open = "w")
[17:36:35.940]         }
[17:36:35.940]         else {
[17:36:35.940]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:35.940]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:35.940]         }
[17:36:35.940]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:35.940]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:35.940]             base::sink(type = "output", split = FALSE)
[17:36:35.940]             base::close(...future.stdout)
[17:36:35.940]         }, add = TRUE)
[17:36:35.940]     }
[17:36:35.940]     ...future.frame <- base::sys.nframe()
[17:36:35.940]     ...future.conditions <- base::list()
[17:36:35.940]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:35.940]     if (FALSE) {
[17:36:35.940]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:35.940]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:35.940]     }
[17:36:35.940]     ...future.result <- base::tryCatch({
[17:36:35.940]         base::withCallingHandlers({
[17:36:35.940]             ...future.value <- base::withVisible(base::local({
[17:36:35.940]                 withCallingHandlers({
[17:36:35.940]                   {
[17:36:35.940]                     do.call(function(...) {
[17:36:35.940]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.940]                       if (!identical(...future.globals.maxSize.org, 
[17:36:35.940]                         ...future.globals.maxSize)) {
[17:36:35.940]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.940]                         on.exit(options(oopts), add = TRUE)
[17:36:35.940]                       }
[17:36:35.940]                       {
[17:36:35.940]                         lapply(seq_along(...future.elements_ii), 
[17:36:35.940]                           FUN = function(jj) {
[17:36:35.940]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.940]                             ...future.FUN(...future.X_jj, ...)
[17:36:35.940]                           })
[17:36:35.940]                       }
[17:36:35.940]                     }, args = future.call.arguments)
[17:36:35.940]                   }
[17:36:35.940]                 }, immediateCondition = function(cond) {
[17:36:35.940]                   save_rds <- function (object, pathname, ...) 
[17:36:35.940]                   {
[17:36:35.940]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:35.940]                     if (file_test("-f", pathname_tmp)) {
[17:36:35.940]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.940]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:35.940]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.940]                         fi_tmp[["mtime"]])
[17:36:35.940]                     }
[17:36:35.940]                     tryCatch({
[17:36:35.940]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:35.940]                     }, error = function(ex) {
[17:36:35.940]                       msg <- conditionMessage(ex)
[17:36:35.940]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.940]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:35.940]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.940]                         fi_tmp[["mtime"]], msg)
[17:36:35.940]                       ex$message <- msg
[17:36:35.940]                       stop(ex)
[17:36:35.940]                     })
[17:36:35.940]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:35.940]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:35.940]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:35.940]                       fi_tmp <- file.info(pathname_tmp)
[17:36:35.940]                       fi <- file.info(pathname)
[17:36:35.940]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:35.940]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:35.940]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:35.940]                         fi[["size"]], fi[["mtime"]])
[17:36:35.940]                       stop(msg)
[17:36:35.940]                     }
[17:36:35.940]                     invisible(pathname)
[17:36:35.940]                   }
[17:36:35.940]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:35.940]                     rootPath = tempdir()) 
[17:36:35.940]                   {
[17:36:35.940]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:35.940]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:35.940]                       tmpdir = path, fileext = ".rds")
[17:36:35.940]                     save_rds(obj, file)
[17:36:35.940]                   }
[17:36:35.940]                   saveImmediateCondition(cond, path = "/tmp/RtmpABg8SG/.future/immediateConditions")
[17:36:35.940]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.940]                   {
[17:36:35.940]                     inherits <- base::inherits
[17:36:35.940]                     invokeRestart <- base::invokeRestart
[17:36:35.940]                     is.null <- base::is.null
[17:36:35.940]                     muffled <- FALSE
[17:36:35.940]                     if (inherits(cond, "message")) {
[17:36:35.940]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:35.940]                       if (muffled) 
[17:36:35.940]                         invokeRestart("muffleMessage")
[17:36:35.940]                     }
[17:36:35.940]                     else if (inherits(cond, "warning")) {
[17:36:35.940]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:35.940]                       if (muffled) 
[17:36:35.940]                         invokeRestart("muffleWarning")
[17:36:35.940]                     }
[17:36:35.940]                     else if (inherits(cond, "condition")) {
[17:36:35.940]                       if (!is.null(pattern)) {
[17:36:35.940]                         computeRestarts <- base::computeRestarts
[17:36:35.940]                         grepl <- base::grepl
[17:36:35.940]                         restarts <- computeRestarts(cond)
[17:36:35.940]                         for (restart in restarts) {
[17:36:35.940]                           name <- restart$name
[17:36:35.940]                           if (is.null(name)) 
[17:36:35.940]                             next
[17:36:35.940]                           if (!grepl(pattern, name)) 
[17:36:35.940]                             next
[17:36:35.940]                           invokeRestart(restart)
[17:36:35.940]                           muffled <- TRUE
[17:36:35.940]                           break
[17:36:35.940]                         }
[17:36:35.940]                       }
[17:36:35.940]                     }
[17:36:35.940]                     invisible(muffled)
[17:36:35.940]                   }
[17:36:35.940]                   muffleCondition(cond)
[17:36:35.940]                 })
[17:36:35.940]             }))
[17:36:35.940]             future::FutureResult(value = ...future.value$value, 
[17:36:35.940]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.940]                   ...future.rng), globalenv = if (FALSE) 
[17:36:35.940]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:35.940]                     ...future.globalenv.names))
[17:36:35.940]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:35.940]         }, condition = base::local({
[17:36:35.940]             c <- base::c
[17:36:35.940]             inherits <- base::inherits
[17:36:35.940]             invokeRestart <- base::invokeRestart
[17:36:35.940]             length <- base::length
[17:36:35.940]             list <- base::list
[17:36:35.940]             seq.int <- base::seq.int
[17:36:35.940]             signalCondition <- base::signalCondition
[17:36:35.940]             sys.calls <- base::sys.calls
[17:36:35.940]             `[[` <- base::`[[`
[17:36:35.940]             `+` <- base::`+`
[17:36:35.940]             `<<-` <- base::`<<-`
[17:36:35.940]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:35.940]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:35.940]                   3L)]
[17:36:35.940]             }
[17:36:35.940]             function(cond) {
[17:36:35.940]                 is_error <- inherits(cond, "error")
[17:36:35.940]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:35.940]                   NULL)
[17:36:35.940]                 if (is_error) {
[17:36:35.940]                   sessionInformation <- function() {
[17:36:35.940]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:35.940]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:35.940]                       search = base::search(), system = base::Sys.info())
[17:36:35.940]                   }
[17:36:35.940]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.940]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:35.940]                     cond$call), session = sessionInformation(), 
[17:36:35.940]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:35.940]                   signalCondition(cond)
[17:36:35.940]                 }
[17:36:35.940]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:35.940]                 "immediateCondition"))) {
[17:36:35.940]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:35.940]                   ...future.conditions[[length(...future.conditions) + 
[17:36:35.940]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:35.940]                   if (TRUE && !signal) {
[17:36:35.940]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.940]                     {
[17:36:35.940]                       inherits <- base::inherits
[17:36:35.940]                       invokeRestart <- base::invokeRestart
[17:36:35.940]                       is.null <- base::is.null
[17:36:35.940]                       muffled <- FALSE
[17:36:35.940]                       if (inherits(cond, "message")) {
[17:36:35.940]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.940]                         if (muffled) 
[17:36:35.940]                           invokeRestart("muffleMessage")
[17:36:35.940]                       }
[17:36:35.940]                       else if (inherits(cond, "warning")) {
[17:36:35.940]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.940]                         if (muffled) 
[17:36:35.940]                           invokeRestart("muffleWarning")
[17:36:35.940]                       }
[17:36:35.940]                       else if (inherits(cond, "condition")) {
[17:36:35.940]                         if (!is.null(pattern)) {
[17:36:35.940]                           computeRestarts <- base::computeRestarts
[17:36:35.940]                           grepl <- base::grepl
[17:36:35.940]                           restarts <- computeRestarts(cond)
[17:36:35.940]                           for (restart in restarts) {
[17:36:35.940]                             name <- restart$name
[17:36:35.940]                             if (is.null(name)) 
[17:36:35.940]                               next
[17:36:35.940]                             if (!grepl(pattern, name)) 
[17:36:35.940]                               next
[17:36:35.940]                             invokeRestart(restart)
[17:36:35.940]                             muffled <- TRUE
[17:36:35.940]                             break
[17:36:35.940]                           }
[17:36:35.940]                         }
[17:36:35.940]                       }
[17:36:35.940]                       invisible(muffled)
[17:36:35.940]                     }
[17:36:35.940]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.940]                   }
[17:36:35.940]                 }
[17:36:35.940]                 else {
[17:36:35.940]                   if (TRUE) {
[17:36:35.940]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:35.940]                     {
[17:36:35.940]                       inherits <- base::inherits
[17:36:35.940]                       invokeRestart <- base::invokeRestart
[17:36:35.940]                       is.null <- base::is.null
[17:36:35.940]                       muffled <- FALSE
[17:36:35.940]                       if (inherits(cond, "message")) {
[17:36:35.940]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:35.940]                         if (muffled) 
[17:36:35.940]                           invokeRestart("muffleMessage")
[17:36:35.940]                       }
[17:36:35.940]                       else if (inherits(cond, "warning")) {
[17:36:35.940]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:35.940]                         if (muffled) 
[17:36:35.940]                           invokeRestart("muffleWarning")
[17:36:35.940]                       }
[17:36:35.940]                       else if (inherits(cond, "condition")) {
[17:36:35.940]                         if (!is.null(pattern)) {
[17:36:35.940]                           computeRestarts <- base::computeRestarts
[17:36:35.940]                           grepl <- base::grepl
[17:36:35.940]                           restarts <- computeRestarts(cond)
[17:36:35.940]                           for (restart in restarts) {
[17:36:35.940]                             name <- restart$name
[17:36:35.940]                             if (is.null(name)) 
[17:36:35.940]                               next
[17:36:35.940]                             if (!grepl(pattern, name)) 
[17:36:35.940]                               next
[17:36:35.940]                             invokeRestart(restart)
[17:36:35.940]                             muffled <- TRUE
[17:36:35.940]                             break
[17:36:35.940]                           }
[17:36:35.940]                         }
[17:36:35.940]                       }
[17:36:35.940]                       invisible(muffled)
[17:36:35.940]                     }
[17:36:35.940]                     muffleCondition(cond, pattern = "^muffle")
[17:36:35.940]                   }
[17:36:35.940]                 }
[17:36:35.940]             }
[17:36:35.940]         }))
[17:36:35.940]     }, error = function(ex) {
[17:36:35.940]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:35.940]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:35.940]                 ...future.rng), started = ...future.startTime, 
[17:36:35.940]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:35.940]             version = "1.8"), class = "FutureResult")
[17:36:35.940]     }, finally = {
[17:36:35.940]         if (!identical(...future.workdir, getwd())) 
[17:36:35.940]             setwd(...future.workdir)
[17:36:35.940]         {
[17:36:35.940]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:35.940]                 ...future.oldOptions$nwarnings <- NULL
[17:36:35.940]             }
[17:36:35.940]             base::options(...future.oldOptions)
[17:36:35.940]             if (.Platform$OS.type == "windows") {
[17:36:35.940]                 old_names <- names(...future.oldEnvVars)
[17:36:35.940]                 envs <- base::Sys.getenv()
[17:36:35.940]                 names <- names(envs)
[17:36:35.940]                 common <- intersect(names, old_names)
[17:36:35.940]                 added <- setdiff(names, old_names)
[17:36:35.940]                 removed <- setdiff(old_names, names)
[17:36:35.940]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:35.940]                   envs[common]]
[17:36:35.940]                 NAMES <- toupper(changed)
[17:36:35.940]                 args <- list()
[17:36:35.940]                 for (kk in seq_along(NAMES)) {
[17:36:35.940]                   name <- changed[[kk]]
[17:36:35.940]                   NAME <- NAMES[[kk]]
[17:36:35.940]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.940]                     next
[17:36:35.940]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.940]                 }
[17:36:35.940]                 NAMES <- toupper(added)
[17:36:35.940]                 for (kk in seq_along(NAMES)) {
[17:36:35.940]                   name <- added[[kk]]
[17:36:35.940]                   NAME <- NAMES[[kk]]
[17:36:35.940]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.940]                     next
[17:36:35.940]                   args[[name]] <- ""
[17:36:35.940]                 }
[17:36:35.940]                 NAMES <- toupper(removed)
[17:36:35.940]                 for (kk in seq_along(NAMES)) {
[17:36:35.940]                   name <- removed[[kk]]
[17:36:35.940]                   NAME <- NAMES[[kk]]
[17:36:35.940]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:35.940]                     next
[17:36:35.940]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:35.940]                 }
[17:36:35.940]                 if (length(args) > 0) 
[17:36:35.940]                   base::do.call(base::Sys.setenv, args = args)
[17:36:35.940]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:35.940]             }
[17:36:35.940]             else {
[17:36:35.940]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:35.940]             }
[17:36:35.940]             {
[17:36:35.940]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:35.940]                   0L) {
[17:36:35.940]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:35.940]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:35.940]                   base::options(opts)
[17:36:35.940]                 }
[17:36:35.940]                 {
[17:36:35.940]                   {
[17:36:35.940]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:35.940]                     NULL
[17:36:35.940]                   }
[17:36:35.940]                   options(future.plan = NULL)
[17:36:35.940]                   if (is.na(NA_character_)) 
[17:36:35.940]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:35.940]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:35.940]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:35.940]                     .init = FALSE)
[17:36:35.940]                 }
[17:36:35.940]             }
[17:36:35.940]         }
[17:36:35.940]     })
[17:36:35.940]     if (TRUE) {
[17:36:35.940]         base::sink(type = "output", split = FALSE)
[17:36:35.940]         if (TRUE) {
[17:36:35.940]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:35.940]         }
[17:36:35.940]         else {
[17:36:35.940]             ...future.result["stdout"] <- base::list(NULL)
[17:36:35.940]         }
[17:36:35.940]         base::close(...future.stdout)
[17:36:35.940]         ...future.stdout <- NULL
[17:36:35.940]     }
[17:36:35.940]     ...future.result$conditions <- ...future.conditions
[17:36:35.940]     ...future.result$finished <- base::Sys.time()
[17:36:35.940]     ...future.result
[17:36:35.940] }
[17:36:35.943] assign_globals() ...
[17:36:35.943] List of 5
[17:36:35.943]  $ future.call.arguments    : list()
[17:36:35.943]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.943]  $ ...future.FUN            :function (x)  
[17:36:35.943]  $ ...future.elements_ii    :List of 1
[17:36:35.943]   ..$ : int 2
[17:36:35.943]  $ ...future.seeds_ii       : NULL
[17:36:35.943]  $ ...future.globals.maxSize: num Inf
[17:36:35.943]  - attr(*, "resolved")= logi FALSE
[17:36:35.943]  - attr(*, "total_size")= num NA
[17:36:35.943]  - attr(*, "where")=List of 5
[17:36:35.943]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:35.943]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:35.943]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:35.943]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:35.943]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:35.943]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.943]  - attr(*, "already-done")= logi TRUE
[17:36:35.956] - copied ‘future.call.arguments’ to environment
[17:36:35.956] - copied ‘...future.FUN’ to environment
[17:36:35.957] - copied ‘...future.elements_ii’ to environment
[17:36:35.957] - copied ‘...future.seeds_ii’ to environment
[17:36:35.957] - copied ‘...future.globals.maxSize’ to environment
[17:36:35.957] assign_globals() ... done
[17:36:35.957] requestCore(): workers = 2
[17:36:35.960] MulticoreFuture started
[17:36:35.960] - Launch lazy future ... done
[17:36:35.960] run() for ‘MulticoreFuture’ ... done
[17:36:35.961] Created future:
[17:36:35.961] plan(): Setting new future strategy stack:
[17:36:35.961] List of future strategies:
[17:36:35.961] 1. sequential:
[17:36:35.961]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:35.961]    - tweaked: FALSE
[17:36:35.961]    - call: NULL
[17:36:35.962] plan(): nbrOfWorkers() = 1
[17:36:35.965] plan(): Setting new future strategy stack:
[17:36:35.965] List of future strategies:
[17:36:35.965] 1. multicore:
[17:36:35.965]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:35.965]    - tweaked: FALSE
[17:36:35.965]    - call: plan(strategy)
[17:36:35.970] plan(): nbrOfWorkers() = 2
[17:36:35.961] MulticoreFuture:
[17:36:35.961] Label: ‘future_apply-2’
[17:36:35.961] Expression:
[17:36:35.961] {
[17:36:35.961]     do.call(function(...) {
[17:36:35.961]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:35.961]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:35.961]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:35.961]             on.exit(options(oopts), add = TRUE)
[17:36:35.961]         }
[17:36:35.961]         {
[17:36:35.961]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:35.961]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:35.961]                 ...future.FUN(...future.X_jj, ...)
[17:36:35.961]             })
[17:36:35.961]         }
[17:36:35.961]     }, args = future.call.arguments)
[17:36:35.961] }
[17:36:35.961] Lazy evaluation: FALSE
[17:36:35.961] Asynchronous evaluation: TRUE
[17:36:35.961] Local evaluation: TRUE
[17:36:35.961] Environment: R_GlobalEnv
[17:36:35.961] Capture standard output: TRUE
[17:36:35.961] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:35.961] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:35.961] Packages: <none>
[17:36:35.961] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:35.961] Resolved: TRUE
[17:36:35.961] Value: <not collected>
[17:36:35.961] Conditions captured: <none>
[17:36:35.961] Early signaling: FALSE
[17:36:35.961] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:35.961] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:35.972] Chunk #2 of 2 ... DONE
[17:36:35.972] Launching 2 futures (chunks) ... DONE
[17:36:35.972] Resolving 2 futures (chunks) ...
[17:36:35.972] resolve() on list ...
[17:36:35.972]  recursive: 0
[17:36:35.973]  length: 2
[17:36:35.973] 
[17:36:35.973] Future #1
[17:36:35.973] result() for MulticoreFuture ...
[17:36:35.974] result() for MulticoreFuture ...
[17:36:35.974] result() for MulticoreFuture ... done
[17:36:35.975] result() for MulticoreFuture ... done
[17:36:35.975] result() for MulticoreFuture ...
[17:36:35.975] result() for MulticoreFuture ... done
[17:36:35.975] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:36:35.975] - nx: 2
[17:36:35.976] - relay: TRUE
[17:36:35.976] - stdout: TRUE
[17:36:35.976] - signal: TRUE
[17:36:35.976] - resignal: FALSE
[17:36:35.976] - force: TRUE
[17:36:35.977] - relayed: [n=2] FALSE, FALSE
[17:36:35.977] - queued futures: [n=2] FALSE, FALSE
[17:36:35.977]  - until=1
[17:36:35.977]  - relaying element #1
[17:36:35.977] result() for MulticoreFuture ...
[17:36:35.977] result() for MulticoreFuture ... done
[17:36:35.978] result() for MulticoreFuture ...
[17:36:35.978] result() for MulticoreFuture ... done
[17:36:35.978] result() for MulticoreFuture ...
[17:36:35.978] result() for MulticoreFuture ... done
[17:36:35.979] result() for MulticoreFuture ...
[17:36:35.979] result() for MulticoreFuture ... done
[17:36:35.979] - relayed: [n=2] TRUE, FALSE
[17:36:35.979] - queued futures: [n=2] TRUE, FALSE
[17:36:35.979] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:36:35.979]  length: 1 (resolved future 1)
[17:36:35.980] Future #2
[17:36:35.980] result() for MulticoreFuture ...
[17:36:35.980] result() for MulticoreFuture ...
[17:36:35.981] result() for MulticoreFuture ... done
[17:36:35.981] result() for MulticoreFuture ... done
[17:36:35.981] result() for MulticoreFuture ...
[17:36:35.981] result() for MulticoreFuture ... done
[17:36:35.981] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:36:35.981] - nx: 2
[17:36:35.981] - relay: TRUE
[17:36:35.982] - stdout: TRUE
[17:36:35.982] - signal: TRUE
[17:36:35.982] - resignal: FALSE
[17:36:35.982] - force: TRUE
[17:36:35.982] - relayed: [n=2] TRUE, FALSE
[17:36:35.982] - queued futures: [n=2] TRUE, FALSE
[17:36:35.982]  - until=2
[17:36:35.982]  - relaying element #2
[17:36:35.983] result() for MulticoreFuture ...
[17:36:35.983] result() for MulticoreFuture ... done
[17:36:35.983] result() for MulticoreFuture ...
[17:36:35.983] result() for MulticoreFuture ... done
[17:36:35.983] result() for MulticoreFuture ...
[17:36:35.983] result() for MulticoreFuture ... done
[17:36:35.983] result() for MulticoreFuture ...
[17:36:35.983] result() for MulticoreFuture ... done
[17:36:35.984] - relayed: [n=2] TRUE, TRUE
[17:36:35.984] - queued futures: [n=2] TRUE, TRUE
[17:36:35.984] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:36:35.984]  length: 0 (resolved future 2)
[17:36:35.984] Relaying remaining futures
[17:36:35.984] signalConditionsASAP(NULL, pos=0) ...
[17:36:35.984] - nx: 2
[17:36:35.984] - relay: TRUE
[17:36:35.985] - stdout: TRUE
[17:36:35.985] - signal: TRUE
[17:36:35.985] - resignal: FALSE
[17:36:35.985] - force: TRUE
[17:36:35.985] - relayed: [n=2] TRUE, TRUE
[17:36:35.985] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:35.985] - relayed: [n=2] TRUE, TRUE
[17:36:35.985] - queued futures: [n=2] TRUE, TRUE
[17:36:35.985] signalConditionsASAP(NULL, pos=0) ... done
[17:36:35.986] resolve() on list ... DONE
[17:36:35.986] result() for MulticoreFuture ...
[17:36:35.986] result() for MulticoreFuture ... done
[17:36:35.986] result() for MulticoreFuture ...
[17:36:35.986] result() for MulticoreFuture ... done
[17:36:35.986] result() for MulticoreFuture ...
[17:36:35.986] result() for MulticoreFuture ... done
[17:36:35.986] result() for MulticoreFuture ...
[17:36:35.986] result() for MulticoreFuture ... done
[17:36:35.987]  - Number of value chunks collected: 2
[17:36:35.987] Resolving 2 futures (chunks) ... DONE
[17:36:35.987] Reducing values from 2 chunks ...
[17:36:35.987]  - Number of values collected after concatenation: 2
[17:36:35.987]  - Number of values expected: 2
[17:36:35.987] Reducing values from 2 chunks ... DONE
[17:36:35.987] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[17:36:35.988] getGlobalsAndPackagesXApply() ...
[17:36:35.988]  - future.globals: TRUE
[17:36:35.988] getGlobalsAndPackages() ...
[17:36:35.988] Searching for globals...
[17:36:35.989] - globals found: [1] ‘FUN’
[17:36:35.989] Searching for globals ... DONE
[17:36:35.990] Resolving globals: FALSE
[17:36:35.990] The total size of the 1 globals is 848 bytes (848 bytes)
[17:36:35.990] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:36:35.991] - globals: [1] ‘FUN’
[17:36:35.991] 
[17:36:35.991] getGlobalsAndPackages() ... DONE
[17:36:35.991]  - globals found/used: [n=1] ‘FUN’
[17:36:35.991]  - needed namespaces: [n=0] 
[17:36:35.991] Finding globals ... DONE
[17:36:35.991]  - use_args: TRUE
[17:36:35.991]  - Getting '...' globals ...
[17:36:35.992] resolve() on list ...
[17:36:35.992]  recursive: 0
[17:36:35.992]  length: 1
[17:36:35.992]  elements: ‘...’
[17:36:35.992]  length: 0 (resolved future 1)
[17:36:35.992] resolve() on list ... DONE
[17:36:35.992]    - '...' content: [n=0] 
[17:36:35.993] List of 1
[17:36:35.993]  $ ...: list()
[17:36:35.993]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.993]  - attr(*, "where")=List of 1
[17:36:35.993]   ..$ ...:<environment: 0x556d75ada918> 
[17:36:35.993]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.993]  - attr(*, "resolved")= logi TRUE
[17:36:35.993]  - attr(*, "total_size")= num NA
[17:36:35.998]  - Getting '...' globals ... DONE
[17:36:35.998] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:35.999] List of 2
[17:36:35.999]  $ ...future.FUN:function (x)  
[17:36:35.999]  $ ...          : list()
[17:36:35.999]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:35.999]  - attr(*, "where")=List of 2
[17:36:35.999]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:35.999]   ..$ ...          :<environment: 0x556d75ada918> 
[17:36:35.999]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:35.999]  - attr(*, "resolved")= logi FALSE
[17:36:35.999]  - attr(*, "total_size")= num 848
[17:36:36.002] Packages to be attached in all futures: [n=0] 
[17:36:36.002] getGlobalsAndPackagesXApply() ... DONE
[17:36:36.006] future_lapply() ...
[17:36:36.010] Number of chunks: 2
[17:36:36.010] getGlobalsAndPackagesXApply() ...
[17:36:36.010]  - future.globals: <name-value list> with names ‘list()’
[17:36:36.010]  - use_args: TRUE
[17:36:36.011] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:36.011] List of 2
[17:36:36.011]  $ ...          : list()
[17:36:36.011]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:36.011]  $ ...future.FUN:function (x)  
[17:36:36.011]  - attr(*, "where")=List of 2
[17:36:36.011]   ..$ ...          :<environment: 0x556d75ada918> 
[17:36:36.011]   ..$ ...future.FUN:<environment: namespace:base> 
[17:36:36.011]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:36.011]  - attr(*, "resolved")= logi FALSE
[17:36:36.011]  - attr(*, "total_size")= num NA
[17:36:36.014] Packages to be attached in all futures: [n=0] 
[17:36:36.014] getGlobalsAndPackagesXApply() ... DONE
[17:36:36.014] Number of futures (= number of chunks): 2
[17:36:36.014] Launching 2 futures (chunks) ...
[17:36:36.015] Chunk #1 of 2 ...
[17:36:36.015]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:36.015]  - seeds: <none>
[17:36:36.015]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:36.015] getGlobalsAndPackages() ...
[17:36:36.015] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:36.015] Resolving globals: FALSE
[17:36:36.015] Tweak future expression to call with '...' arguments ...
[17:36:36.016] {
[17:36:36.016]     do.call(function(...) {
[17:36:36.016]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:36.016]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:36.016]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:36.016]             on.exit(options(oopts), add = TRUE)
[17:36:36.016]         }
[17:36:36.016]         {
[17:36:36.016]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:36.016]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:36.016]                 ...future.FUN(...future.X_jj, ...)
[17:36:36.016]             })
[17:36:36.016]         }
[17:36:36.016]     }, args = future.call.arguments)
[17:36:36.016] }
[17:36:36.016] Tweak future expression to call with '...' arguments ... DONE
[17:36:36.016] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:36.016] 
[17:36:36.016] getGlobalsAndPackages() ... DONE
[17:36:36.017] run() for ‘Future’ ...
[17:36:36.017] - state: ‘created’
[17:36:36.017] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:36.020] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:36.021] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:36.021]   - Field: ‘label’
[17:36:36.021]   - Field: ‘local’
[17:36:36.021]   - Field: ‘owner’
[17:36:36.021]   - Field: ‘envir’
[17:36:36.021]   - Field: ‘workers’
[17:36:36.021]   - Field: ‘packages’
[17:36:36.021]   - Field: ‘gc’
[17:36:36.021]   - Field: ‘job’
[17:36:36.022]   - Field: ‘conditions’
[17:36:36.022]   - Field: ‘expr’
[17:36:36.022]   - Field: ‘uuid’
[17:36:36.022]   - Field: ‘seed’
[17:36:36.022]   - Field: ‘version’
[17:36:36.022]   - Field: ‘result’
[17:36:36.022]   - Field: ‘asynchronous’
[17:36:36.022]   - Field: ‘calls’
[17:36:36.022]   - Field: ‘globals’
[17:36:36.022]   - Field: ‘stdout’
[17:36:36.022]   - Field: ‘earlySignal’
[17:36:36.023]   - Field: ‘lazy’
[17:36:36.023]   - Field: ‘state’
[17:36:36.023] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:36.023] - Launch lazy future ...
[17:36:36.023] Packages needed by the future expression (n = 0): <none>
[17:36:36.023] Packages needed by future strategies (n = 0): <none>
[17:36:36.024] {
[17:36:36.024]     {
[17:36:36.024]         {
[17:36:36.024]             ...future.startTime <- base::Sys.time()
[17:36:36.024]             {
[17:36:36.024]                 {
[17:36:36.024]                   {
[17:36:36.024]                     {
[17:36:36.024]                       base::local({
[17:36:36.024]                         has_future <- base::requireNamespace("future", 
[17:36:36.024]                           quietly = TRUE)
[17:36:36.024]                         if (has_future) {
[17:36:36.024]                           ns <- base::getNamespace("future")
[17:36:36.024]                           version <- ns[[".package"]][["version"]]
[17:36:36.024]                           if (is.null(version)) 
[17:36:36.024]                             version <- utils::packageVersion("future")
[17:36:36.024]                         }
[17:36:36.024]                         else {
[17:36:36.024]                           version <- NULL
[17:36:36.024]                         }
[17:36:36.024]                         if (!has_future || version < "1.8.0") {
[17:36:36.024]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:36.024]                             "", base::R.version$version.string), 
[17:36:36.024]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:36.024]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:36.024]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:36.024]                               "release", "version")], collapse = " "), 
[17:36:36.024]                             hostname = base::Sys.info()[["nodename"]])
[17:36:36.024]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:36.024]                             info)
[17:36:36.024]                           info <- base::paste(info, collapse = "; ")
[17:36:36.024]                           if (!has_future) {
[17:36:36.024]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:36.024]                               info)
[17:36:36.024]                           }
[17:36:36.024]                           else {
[17:36:36.024]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:36.024]                               info, version)
[17:36:36.024]                           }
[17:36:36.024]                           base::stop(msg)
[17:36:36.024]                         }
[17:36:36.024]                       })
[17:36:36.024]                     }
[17:36:36.024]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:36.024]                     base::options(mc.cores = 1L)
[17:36:36.024]                   }
[17:36:36.024]                   ...future.strategy.old <- future::plan("list")
[17:36:36.024]                   options(future.plan = NULL)
[17:36:36.024]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:36.024]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:36.024]                 }
[17:36:36.024]                 ...future.workdir <- getwd()
[17:36:36.024]             }
[17:36:36.024]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:36.024]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:36.024]         }
[17:36:36.024]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:36.024]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:36.024]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:36.024]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:36.024]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:36.024]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:36.024]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:36.024]             base::names(...future.oldOptions))
[17:36:36.024]     }
[17:36:36.024]     if (FALSE) {
[17:36:36.024]     }
[17:36:36.024]     else {
[17:36:36.024]         if (TRUE) {
[17:36:36.024]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:36.024]                 open = "w")
[17:36:36.024]         }
[17:36:36.024]         else {
[17:36:36.024]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:36.024]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:36.024]         }
[17:36:36.024]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:36.024]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:36.024]             base::sink(type = "output", split = FALSE)
[17:36:36.024]             base::close(...future.stdout)
[17:36:36.024]         }, add = TRUE)
[17:36:36.024]     }
[17:36:36.024]     ...future.frame <- base::sys.nframe()
[17:36:36.024]     ...future.conditions <- base::list()
[17:36:36.024]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:36.024]     if (FALSE) {
[17:36:36.024]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:36.024]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:36.024]     }
[17:36:36.024]     ...future.result <- base::tryCatch({
[17:36:36.024]         base::withCallingHandlers({
[17:36:36.024]             ...future.value <- base::withVisible(base::local({
[17:36:36.024]                 withCallingHandlers({
[17:36:36.024]                   {
[17:36:36.024]                     do.call(function(...) {
[17:36:36.024]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:36.024]                       if (!identical(...future.globals.maxSize.org, 
[17:36:36.024]                         ...future.globals.maxSize)) {
[17:36:36.024]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:36.024]                         on.exit(options(oopts), add = TRUE)
[17:36:36.024]                       }
[17:36:36.024]                       {
[17:36:36.024]                         lapply(seq_along(...future.elements_ii), 
[17:36:36.024]                           FUN = function(jj) {
[17:36:36.024]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:36.024]                             ...future.FUN(...future.X_jj, ...)
[17:36:36.024]                           })
[17:36:36.024]                       }
[17:36:36.024]                     }, args = future.call.arguments)
[17:36:36.024]                   }
[17:36:36.024]                 }, immediateCondition = function(cond) {
[17:36:36.024]                   save_rds <- function (object, pathname, ...) 
[17:36:36.024]                   {
[17:36:36.024]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:36.024]                     if (file_test("-f", pathname_tmp)) {
[17:36:36.024]                       fi_tmp <- file.info(pathname_tmp)
[17:36:36.024]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:36.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:36.024]                         fi_tmp[["mtime"]])
[17:36:36.024]                     }
[17:36:36.024]                     tryCatch({
[17:36:36.024]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:36.024]                     }, error = function(ex) {
[17:36:36.024]                       msg <- conditionMessage(ex)
[17:36:36.024]                       fi_tmp <- file.info(pathname_tmp)
[17:36:36.024]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:36.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:36.024]                         fi_tmp[["mtime"]], msg)
[17:36:36.024]                       ex$message <- msg
[17:36:36.024]                       stop(ex)
[17:36:36.024]                     })
[17:36:36.024]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:36.024]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:36.024]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:36.024]                       fi_tmp <- file.info(pathname_tmp)
[17:36:36.024]                       fi <- file.info(pathname)
[17:36:36.024]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:36.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:36.024]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:36.024]                         fi[["size"]], fi[["mtime"]])
[17:36:36.024]                       stop(msg)
[17:36:36.024]                     }
[17:36:36.024]                     invisible(pathname)
[17:36:36.024]                   }
[17:36:36.024]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:36.024]                     rootPath = tempdir()) 
[17:36:36.024]                   {
[17:36:36.024]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:36.024]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:36.024]                       tmpdir = path, fileext = ".rds")
[17:36:36.024]                     save_rds(obj, file)
[17:36:36.024]                   }
[17:36:36.024]                   saveImmediateCondition(cond, path = "/tmp/RtmpABg8SG/.future/immediateConditions")
[17:36:36.024]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:36.024]                   {
[17:36:36.024]                     inherits <- base::inherits
[17:36:36.024]                     invokeRestart <- base::invokeRestart
[17:36:36.024]                     is.null <- base::is.null
[17:36:36.024]                     muffled <- FALSE
[17:36:36.024]                     if (inherits(cond, "message")) {
[17:36:36.024]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:36.024]                       if (muffled) 
[17:36:36.024]                         invokeRestart("muffleMessage")
[17:36:36.024]                     }
[17:36:36.024]                     else if (inherits(cond, "warning")) {
[17:36:36.024]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:36.024]                       if (muffled) 
[17:36:36.024]                         invokeRestart("muffleWarning")
[17:36:36.024]                     }
[17:36:36.024]                     else if (inherits(cond, "condition")) {
[17:36:36.024]                       if (!is.null(pattern)) {
[17:36:36.024]                         computeRestarts <- base::computeRestarts
[17:36:36.024]                         grepl <- base::grepl
[17:36:36.024]                         restarts <- computeRestarts(cond)
[17:36:36.024]                         for (restart in restarts) {
[17:36:36.024]                           name <- restart$name
[17:36:36.024]                           if (is.null(name)) 
[17:36:36.024]                             next
[17:36:36.024]                           if (!grepl(pattern, name)) 
[17:36:36.024]                             next
[17:36:36.024]                           invokeRestart(restart)
[17:36:36.024]                           muffled <- TRUE
[17:36:36.024]                           break
[17:36:36.024]                         }
[17:36:36.024]                       }
[17:36:36.024]                     }
[17:36:36.024]                     invisible(muffled)
[17:36:36.024]                   }
[17:36:36.024]                   muffleCondition(cond)
[17:36:36.024]                 })
[17:36:36.024]             }))
[17:36:36.024]             future::FutureResult(value = ...future.value$value, 
[17:36:36.024]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:36.024]                   ...future.rng), globalenv = if (FALSE) 
[17:36:36.024]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:36.024]                     ...future.globalenv.names))
[17:36:36.024]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:36.024]         }, condition = base::local({
[17:36:36.024]             c <- base::c
[17:36:36.024]             inherits <- base::inherits
[17:36:36.024]             invokeRestart <- base::invokeRestart
[17:36:36.024]             length <- base::length
[17:36:36.024]             list <- base::list
[17:36:36.024]             seq.int <- base::seq.int
[17:36:36.024]             signalCondition <- base::signalCondition
[17:36:36.024]             sys.calls <- base::sys.calls
[17:36:36.024]             `[[` <- base::`[[`
[17:36:36.024]             `+` <- base::`+`
[17:36:36.024]             `<<-` <- base::`<<-`
[17:36:36.024]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:36.024]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:36.024]                   3L)]
[17:36:36.024]             }
[17:36:36.024]             function(cond) {
[17:36:36.024]                 is_error <- inherits(cond, "error")
[17:36:36.024]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:36.024]                   NULL)
[17:36:36.024]                 if (is_error) {
[17:36:36.024]                   sessionInformation <- function() {
[17:36:36.024]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:36.024]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:36.024]                       search = base::search(), system = base::Sys.info())
[17:36:36.024]                   }
[17:36:36.024]                   ...future.conditions[[length(...future.conditions) + 
[17:36:36.024]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:36.024]                     cond$call), session = sessionInformation(), 
[17:36:36.024]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:36.024]                   signalCondition(cond)
[17:36:36.024]                 }
[17:36:36.024]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:36.024]                 "immediateCondition"))) {
[17:36:36.024]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:36.024]                   ...future.conditions[[length(...future.conditions) + 
[17:36:36.024]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:36.024]                   if (TRUE && !signal) {
[17:36:36.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:36.024]                     {
[17:36:36.024]                       inherits <- base::inherits
[17:36:36.024]                       invokeRestart <- base::invokeRestart
[17:36:36.024]                       is.null <- base::is.null
[17:36:36.024]                       muffled <- FALSE
[17:36:36.024]                       if (inherits(cond, "message")) {
[17:36:36.024]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:36.024]                         if (muffled) 
[17:36:36.024]                           invokeRestart("muffleMessage")
[17:36:36.024]                       }
[17:36:36.024]                       else if (inherits(cond, "warning")) {
[17:36:36.024]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:36.024]                         if (muffled) 
[17:36:36.024]                           invokeRestart("muffleWarning")
[17:36:36.024]                       }
[17:36:36.024]                       else if (inherits(cond, "condition")) {
[17:36:36.024]                         if (!is.null(pattern)) {
[17:36:36.024]                           computeRestarts <- base::computeRestarts
[17:36:36.024]                           grepl <- base::grepl
[17:36:36.024]                           restarts <- computeRestarts(cond)
[17:36:36.024]                           for (restart in restarts) {
[17:36:36.024]                             name <- restart$name
[17:36:36.024]                             if (is.null(name)) 
[17:36:36.024]                               next
[17:36:36.024]                             if (!grepl(pattern, name)) 
[17:36:36.024]                               next
[17:36:36.024]                             invokeRestart(restart)
[17:36:36.024]                             muffled <- TRUE
[17:36:36.024]                             break
[17:36:36.024]                           }
[17:36:36.024]                         }
[17:36:36.024]                       }
[17:36:36.024]                       invisible(muffled)
[17:36:36.024]                     }
[17:36:36.024]                     muffleCondition(cond, pattern = "^muffle")
[17:36:36.024]                   }
[17:36:36.024]                 }
[17:36:36.024]                 else {
[17:36:36.024]                   if (TRUE) {
[17:36:36.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:36.024]                     {
[17:36:36.024]                       inherits <- base::inherits
[17:36:36.024]                       invokeRestart <- base::invokeRestart
[17:36:36.024]                       is.null <- base::is.null
[17:36:36.024]                       muffled <- FALSE
[17:36:36.024]                       if (inherits(cond, "message")) {
[17:36:36.024]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:36.024]                         if (muffled) 
[17:36:36.024]                           invokeRestart("muffleMessage")
[17:36:36.024]                       }
[17:36:36.024]                       else if (inherits(cond, "warning")) {
[17:36:36.024]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:36.024]                         if (muffled) 
[17:36:36.024]                           invokeRestart("muffleWarning")
[17:36:36.024]                       }
[17:36:36.024]                       else if (inherits(cond, "condition")) {
[17:36:36.024]                         if (!is.null(pattern)) {
[17:36:36.024]                           computeRestarts <- base::computeRestarts
[17:36:36.024]                           grepl <- base::grepl
[17:36:36.024]                           restarts <- computeRestarts(cond)
[17:36:36.024]                           for (restart in restarts) {
[17:36:36.024]                             name <- restart$name
[17:36:36.024]                             if (is.null(name)) 
[17:36:36.024]                               next
[17:36:36.024]                             if (!grepl(pattern, name)) 
[17:36:36.024]                               next
[17:36:36.024]                             invokeRestart(restart)
[17:36:36.024]                             muffled <- TRUE
[17:36:36.024]                             break
[17:36:36.024]                           }
[17:36:36.024]                         }
[17:36:36.024]                       }
[17:36:36.024]                       invisible(muffled)
[17:36:36.024]                     }
[17:36:36.024]                     muffleCondition(cond, pattern = "^muffle")
[17:36:36.024]                   }
[17:36:36.024]                 }
[17:36:36.024]             }
[17:36:36.024]         }))
[17:36:36.024]     }, error = function(ex) {
[17:36:36.024]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:36.024]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:36.024]                 ...future.rng), started = ...future.startTime, 
[17:36:36.024]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:36.024]             version = "1.8"), class = "FutureResult")
[17:36:36.024]     }, finally = {
[17:36:36.024]         if (!identical(...future.workdir, getwd())) 
[17:36:36.024]             setwd(...future.workdir)
[17:36:36.024]         {
[17:36:36.024]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:36.024]                 ...future.oldOptions$nwarnings <- NULL
[17:36:36.024]             }
[17:36:36.024]             base::options(...future.oldOptions)
[17:36:36.024]             if (.Platform$OS.type == "windows") {
[17:36:36.024]                 old_names <- names(...future.oldEnvVars)
[17:36:36.024]                 envs <- base::Sys.getenv()
[17:36:36.024]                 names <- names(envs)
[17:36:36.024]                 common <- intersect(names, old_names)
[17:36:36.024]                 added <- setdiff(names, old_names)
[17:36:36.024]                 removed <- setdiff(old_names, names)
[17:36:36.024]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:36.024]                   envs[common]]
[17:36:36.024]                 NAMES <- toupper(changed)
[17:36:36.024]                 args <- list()
[17:36:36.024]                 for (kk in seq_along(NAMES)) {
[17:36:36.024]                   name <- changed[[kk]]
[17:36:36.024]                   NAME <- NAMES[[kk]]
[17:36:36.024]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:36.024]                     next
[17:36:36.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:36.024]                 }
[17:36:36.024]                 NAMES <- toupper(added)
[17:36:36.024]                 for (kk in seq_along(NAMES)) {
[17:36:36.024]                   name <- added[[kk]]
[17:36:36.024]                   NAME <- NAMES[[kk]]
[17:36:36.024]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:36.024]                     next
[17:36:36.024]                   args[[name]] <- ""
[17:36:36.024]                 }
[17:36:36.024]                 NAMES <- toupper(removed)
[17:36:36.024]                 for (kk in seq_along(NAMES)) {
[17:36:36.024]                   name <- removed[[kk]]
[17:36:36.024]                   NAME <- NAMES[[kk]]
[17:36:36.024]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:36.024]                     next
[17:36:36.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:36.024]                 }
[17:36:36.024]                 if (length(args) > 0) 
[17:36:36.024]                   base::do.call(base::Sys.setenv, args = args)
[17:36:36.024]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:36.024]             }
[17:36:36.024]             else {
[17:36:36.024]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:36.024]             }
[17:36:36.024]             {
[17:36:36.024]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:36.024]                   0L) {
[17:36:36.024]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:36.024]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:36.024]                   base::options(opts)
[17:36:36.024]                 }
[17:36:36.024]                 {
[17:36:36.024]                   {
[17:36:36.024]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:36.024]                     NULL
[17:36:36.024]                   }
[17:36:36.024]                   options(future.plan = NULL)
[17:36:36.024]                   if (is.na(NA_character_)) 
[17:36:36.024]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:36.024]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:36.024]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:36.024]                     .init = FALSE)
[17:36:36.024]                 }
[17:36:36.024]             }
[17:36:36.024]         }
[17:36:36.024]     })
[17:36:36.024]     if (TRUE) {
[17:36:36.024]         base::sink(type = "output", split = FALSE)
[17:36:36.024]         if (TRUE) {
[17:36:36.024]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:36.024]         }
[17:36:36.024]         else {
[17:36:36.024]             ...future.result["stdout"] <- base::list(NULL)
[17:36:36.024]         }
[17:36:36.024]         base::close(...future.stdout)
[17:36:36.024]         ...future.stdout <- NULL
[17:36:36.024]     }
[17:36:36.024]     ...future.result$conditions <- ...future.conditions
[17:36:36.024]     ...future.result$finished <- base::Sys.time()
[17:36:36.024]     ...future.result
[17:36:36.024] }
[17:36:36.026] assign_globals() ...
[17:36:36.026] List of 5
[17:36:36.026]  $ future.call.arguments    : list()
[17:36:36.026]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:36.026]  $ ...future.FUN            :function (x)  
[17:36:36.026]  $ ...future.elements_ii    :List of 1
[17:36:36.026]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[17:36:36.026]  $ ...future.seeds_ii       : NULL
[17:36:36.026]  $ ...future.globals.maxSize: num Inf
[17:36:36.026]  - attr(*, "resolved")= logi FALSE
[17:36:36.026]  - attr(*, "total_size")= num NA
[17:36:36.026]  - attr(*, "where")=List of 5
[17:36:36.026]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:36.026]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:36.026]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:36.026]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:36.026]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:36.026]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:36.026]  - attr(*, "already-done")= logi TRUE
[17:36:36.034] - copied ‘future.call.arguments’ to environment
[17:36:36.034] - copied ‘...future.FUN’ to environment
[17:36:36.034] - copied ‘...future.elements_ii’ to environment
[17:36:36.034] - copied ‘...future.seeds_ii’ to environment
[17:36:36.034] - copied ‘...future.globals.maxSize’ to environment
[17:36:36.034] assign_globals() ... done
[17:36:36.034] requestCore(): workers = 2
[17:36:36.037] MulticoreFuture started
[17:36:36.037] - Launch lazy future ... done
[17:36:36.038] run() for ‘MulticoreFuture’ ... done
[17:36:36.038] Created future:
[17:36:36.038] plan(): Setting new future strategy stack:
[17:36:36.038] List of future strategies:
[17:36:36.038] 1. sequential:
[17:36:36.038]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:36.038]    - tweaked: FALSE
[17:36:36.038]    - call: NULL
[17:36:36.039] plan(): nbrOfWorkers() = 1
[17:36:36.042] plan(): Setting new future strategy stack:
[17:36:36.042] List of future strategies:
[17:36:36.042] 1. multicore:
[17:36:36.042]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:36.042]    - tweaked: FALSE
[17:36:36.042]    - call: plan(strategy)
[17:36:36.047] plan(): nbrOfWorkers() = 2
[17:36:36.038] MulticoreFuture:
[17:36:36.038] Label: ‘future_apply-1’
[17:36:36.038] Expression:
[17:36:36.038] {
[17:36:36.038]     do.call(function(...) {
[17:36:36.038]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:36.038]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:36.038]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:36.038]             on.exit(options(oopts), add = TRUE)
[17:36:36.038]         }
[17:36:36.038]         {
[17:36:36.038]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:36.038]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:36.038]                 ...future.FUN(...future.X_jj, ...)
[17:36:36.038]             })
[17:36:36.038]         }
[17:36:36.038]     }, args = future.call.arguments)
[17:36:36.038] }
[17:36:36.038] Lazy evaluation: FALSE
[17:36:36.038] Asynchronous evaluation: TRUE
[17:36:36.038] Local evaluation: TRUE
[17:36:36.038] Environment: R_GlobalEnv
[17:36:36.038] Capture standard output: TRUE
[17:36:36.038] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:36.038] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:36.038] Packages: <none>
[17:36:36.038] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:36.038] Resolved: TRUE
[17:36:36.038] Value: <not collected>
[17:36:36.038] Conditions captured: <none>
[17:36:36.038] Early signaling: FALSE
[17:36:36.038] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:36.038] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:36.049] Chunk #1 of 2 ... DONE
[17:36:36.049] Chunk #2 of 2 ...
[17:36:36.049]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:36.049]  - seeds: <none>
[17:36:36.050]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:36.050] getGlobalsAndPackages() ...
[17:36:36.050] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:36.050] Resolving globals: FALSE
[17:36:36.050] Tweak future expression to call with '...' arguments ...
[17:36:36.050] {
[17:36:36.050]     do.call(function(...) {
[17:36:36.050]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:36.050]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:36.050]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:36.050]             on.exit(options(oopts), add = TRUE)
[17:36:36.050]         }
[17:36:36.050]         {
[17:36:36.050]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:36.050]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:36.050]                 ...future.FUN(...future.X_jj, ...)
[17:36:36.050]             })
[17:36:36.050]         }
[17:36:36.050]     }, args = future.call.arguments)
[17:36:36.050] }
[17:36:36.051] Tweak future expression to call with '...' arguments ... DONE
[17:36:36.051] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:36.052] 
[17:36:36.052] getGlobalsAndPackages() ... DONE
[17:36:36.052] run() for ‘Future’ ...
[17:36:36.053] - state: ‘created’
[17:36:36.053] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:36.057] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:36.057] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:36.058]   - Field: ‘label’
[17:36:36.058]   - Field: ‘local’
[17:36:36.058]   - Field: ‘owner’
[17:36:36.058]   - Field: ‘envir’
[17:36:36.058]   - Field: ‘workers’
[17:36:36.058]   - Field: ‘packages’
[17:36:36.058]   - Field: ‘gc’
[17:36:36.059]   - Field: ‘job’
[17:36:36.059]   - Field: ‘conditions’
[17:36:36.059]   - Field: ‘expr’
[17:36:36.059]   - Field: ‘uuid’
[17:36:36.059]   - Field: ‘seed’
[17:36:36.059]   - Field: ‘version’
[17:36:36.059]   - Field: ‘result’
[17:36:36.060]   - Field: ‘asynchronous’
[17:36:36.060]   - Field: ‘calls’
[17:36:36.060]   - Field: ‘globals’
[17:36:36.060]   - Field: ‘stdout’
[17:36:36.060]   - Field: ‘earlySignal’
[17:36:36.060]   - Field: ‘lazy’
[17:36:36.060]   - Field: ‘state’
[17:36:36.061] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:36.061] - Launch lazy future ...
[17:36:36.061] Packages needed by the future expression (n = 0): <none>
[17:36:36.061] Packages needed by future strategies (n = 0): <none>
[17:36:36.062] {
[17:36:36.062]     {
[17:36:36.062]         {
[17:36:36.062]             ...future.startTime <- base::Sys.time()
[17:36:36.062]             {
[17:36:36.062]                 {
[17:36:36.062]                   {
[17:36:36.062]                     {
[17:36:36.062]                       base::local({
[17:36:36.062]                         has_future <- base::requireNamespace("future", 
[17:36:36.062]                           quietly = TRUE)
[17:36:36.062]                         if (has_future) {
[17:36:36.062]                           ns <- base::getNamespace("future")
[17:36:36.062]                           version <- ns[[".package"]][["version"]]
[17:36:36.062]                           if (is.null(version)) 
[17:36:36.062]                             version <- utils::packageVersion("future")
[17:36:36.062]                         }
[17:36:36.062]                         else {
[17:36:36.062]                           version <- NULL
[17:36:36.062]                         }
[17:36:36.062]                         if (!has_future || version < "1.8.0") {
[17:36:36.062]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:36.062]                             "", base::R.version$version.string), 
[17:36:36.062]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:36.062]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:36.062]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:36.062]                               "release", "version")], collapse = " "), 
[17:36:36.062]                             hostname = base::Sys.info()[["nodename"]])
[17:36:36.062]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:36.062]                             info)
[17:36:36.062]                           info <- base::paste(info, collapse = "; ")
[17:36:36.062]                           if (!has_future) {
[17:36:36.062]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:36.062]                               info)
[17:36:36.062]                           }
[17:36:36.062]                           else {
[17:36:36.062]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:36.062]                               info, version)
[17:36:36.062]                           }
[17:36:36.062]                           base::stop(msg)
[17:36:36.062]                         }
[17:36:36.062]                       })
[17:36:36.062]                     }
[17:36:36.062]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:36.062]                     base::options(mc.cores = 1L)
[17:36:36.062]                   }
[17:36:36.062]                   ...future.strategy.old <- future::plan("list")
[17:36:36.062]                   options(future.plan = NULL)
[17:36:36.062]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:36.062]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:36.062]                 }
[17:36:36.062]                 ...future.workdir <- getwd()
[17:36:36.062]             }
[17:36:36.062]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:36.062]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:36.062]         }
[17:36:36.062]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:36.062]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:36.062]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:36.062]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:36.062]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:36.062]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:36.062]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:36.062]             base::names(...future.oldOptions))
[17:36:36.062]     }
[17:36:36.062]     if (FALSE) {
[17:36:36.062]     }
[17:36:36.062]     else {
[17:36:36.062]         if (TRUE) {
[17:36:36.062]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:36.062]                 open = "w")
[17:36:36.062]         }
[17:36:36.062]         else {
[17:36:36.062]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:36.062]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:36.062]         }
[17:36:36.062]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:36.062]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:36.062]             base::sink(type = "output", split = FALSE)
[17:36:36.062]             base::close(...future.stdout)
[17:36:36.062]         }, add = TRUE)
[17:36:36.062]     }
[17:36:36.062]     ...future.frame <- base::sys.nframe()
[17:36:36.062]     ...future.conditions <- base::list()
[17:36:36.062]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:36.062]     if (FALSE) {
[17:36:36.062]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:36.062]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:36.062]     }
[17:36:36.062]     ...future.result <- base::tryCatch({
[17:36:36.062]         base::withCallingHandlers({
[17:36:36.062]             ...future.value <- base::withVisible(base::local({
[17:36:36.062]                 withCallingHandlers({
[17:36:36.062]                   {
[17:36:36.062]                     do.call(function(...) {
[17:36:36.062]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:36.062]                       if (!identical(...future.globals.maxSize.org, 
[17:36:36.062]                         ...future.globals.maxSize)) {
[17:36:36.062]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:36.062]                         on.exit(options(oopts), add = TRUE)
[17:36:36.062]                       }
[17:36:36.062]                       {
[17:36:36.062]                         lapply(seq_along(...future.elements_ii), 
[17:36:36.062]                           FUN = function(jj) {
[17:36:36.062]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:36.062]                             ...future.FUN(...future.X_jj, ...)
[17:36:36.062]                           })
[17:36:36.062]                       }
[17:36:36.062]                     }, args = future.call.arguments)
[17:36:36.062]                   }
[17:36:36.062]                 }, immediateCondition = function(cond) {
[17:36:36.062]                   save_rds <- function (object, pathname, ...) 
[17:36:36.062]                   {
[17:36:36.062]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:36.062]                     if (file_test("-f", pathname_tmp)) {
[17:36:36.062]                       fi_tmp <- file.info(pathname_tmp)
[17:36:36.062]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:36.062]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:36.062]                         fi_tmp[["mtime"]])
[17:36:36.062]                     }
[17:36:36.062]                     tryCatch({
[17:36:36.062]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:36.062]                     }, error = function(ex) {
[17:36:36.062]                       msg <- conditionMessage(ex)
[17:36:36.062]                       fi_tmp <- file.info(pathname_tmp)
[17:36:36.062]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:36.062]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:36.062]                         fi_tmp[["mtime"]], msg)
[17:36:36.062]                       ex$message <- msg
[17:36:36.062]                       stop(ex)
[17:36:36.062]                     })
[17:36:36.062]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:36.062]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:36.062]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:36.062]                       fi_tmp <- file.info(pathname_tmp)
[17:36:36.062]                       fi <- file.info(pathname)
[17:36:36.062]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:36.062]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:36.062]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:36.062]                         fi[["size"]], fi[["mtime"]])
[17:36:36.062]                       stop(msg)
[17:36:36.062]                     }
[17:36:36.062]                     invisible(pathname)
[17:36:36.062]                   }
[17:36:36.062]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:36.062]                     rootPath = tempdir()) 
[17:36:36.062]                   {
[17:36:36.062]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:36.062]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:36.062]                       tmpdir = path, fileext = ".rds")
[17:36:36.062]                     save_rds(obj, file)
[17:36:36.062]                   }
[17:36:36.062]                   saveImmediateCondition(cond, path = "/tmp/RtmpABg8SG/.future/immediateConditions")
[17:36:36.062]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:36.062]                   {
[17:36:36.062]                     inherits <- base::inherits
[17:36:36.062]                     invokeRestart <- base::invokeRestart
[17:36:36.062]                     is.null <- base::is.null
[17:36:36.062]                     muffled <- FALSE
[17:36:36.062]                     if (inherits(cond, "message")) {
[17:36:36.062]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:36.062]                       if (muffled) 
[17:36:36.062]                         invokeRestart("muffleMessage")
[17:36:36.062]                     }
[17:36:36.062]                     else if (inherits(cond, "warning")) {
[17:36:36.062]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:36.062]                       if (muffled) 
[17:36:36.062]                         invokeRestart("muffleWarning")
[17:36:36.062]                     }
[17:36:36.062]                     else if (inherits(cond, "condition")) {
[17:36:36.062]                       if (!is.null(pattern)) {
[17:36:36.062]                         computeRestarts <- base::computeRestarts
[17:36:36.062]                         grepl <- base::grepl
[17:36:36.062]                         restarts <- computeRestarts(cond)
[17:36:36.062]                         for (restart in restarts) {
[17:36:36.062]                           name <- restart$name
[17:36:36.062]                           if (is.null(name)) 
[17:36:36.062]                             next
[17:36:36.062]                           if (!grepl(pattern, name)) 
[17:36:36.062]                             next
[17:36:36.062]                           invokeRestart(restart)
[17:36:36.062]                           muffled <- TRUE
[17:36:36.062]                           break
[17:36:36.062]                         }
[17:36:36.062]                       }
[17:36:36.062]                     }
[17:36:36.062]                     invisible(muffled)
[17:36:36.062]                   }
[17:36:36.062]                   muffleCondition(cond)
[17:36:36.062]                 })
[17:36:36.062]             }))
[17:36:36.062]             future::FutureResult(value = ...future.value$value, 
[17:36:36.062]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:36.062]                   ...future.rng), globalenv = if (FALSE) 
[17:36:36.062]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:36.062]                     ...future.globalenv.names))
[17:36:36.062]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:36.062]         }, condition = base::local({
[17:36:36.062]             c <- base::c
[17:36:36.062]             inherits <- base::inherits
[17:36:36.062]             invokeRestart <- base::invokeRestart
[17:36:36.062]             length <- base::length
[17:36:36.062]             list <- base::list
[17:36:36.062]             seq.int <- base::seq.int
[17:36:36.062]             signalCondition <- base::signalCondition
[17:36:36.062]             sys.calls <- base::sys.calls
[17:36:36.062]             `[[` <- base::`[[`
[17:36:36.062]             `+` <- base::`+`
[17:36:36.062]             `<<-` <- base::`<<-`
[17:36:36.062]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:36.062]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:36.062]                   3L)]
[17:36:36.062]             }
[17:36:36.062]             function(cond) {
[17:36:36.062]                 is_error <- inherits(cond, "error")
[17:36:36.062]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:36.062]                   NULL)
[17:36:36.062]                 if (is_error) {
[17:36:36.062]                   sessionInformation <- function() {
[17:36:36.062]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:36.062]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:36.062]                       search = base::search(), system = base::Sys.info())
[17:36:36.062]                   }
[17:36:36.062]                   ...future.conditions[[length(...future.conditions) + 
[17:36:36.062]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:36.062]                     cond$call), session = sessionInformation(), 
[17:36:36.062]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:36.062]                   signalCondition(cond)
[17:36:36.062]                 }
[17:36:36.062]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:36.062]                 "immediateCondition"))) {
[17:36:36.062]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:36.062]                   ...future.conditions[[length(...future.conditions) + 
[17:36:36.062]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:36.062]                   if (TRUE && !signal) {
[17:36:36.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:36.062]                     {
[17:36:36.062]                       inherits <- base::inherits
[17:36:36.062]                       invokeRestart <- base::invokeRestart
[17:36:36.062]                       is.null <- base::is.null
[17:36:36.062]                       muffled <- FALSE
[17:36:36.062]                       if (inherits(cond, "message")) {
[17:36:36.062]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:36.062]                         if (muffled) 
[17:36:36.062]                           invokeRestart("muffleMessage")
[17:36:36.062]                       }
[17:36:36.062]                       else if (inherits(cond, "warning")) {
[17:36:36.062]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:36.062]                         if (muffled) 
[17:36:36.062]                           invokeRestart("muffleWarning")
[17:36:36.062]                       }
[17:36:36.062]                       else if (inherits(cond, "condition")) {
[17:36:36.062]                         if (!is.null(pattern)) {
[17:36:36.062]                           computeRestarts <- base::computeRestarts
[17:36:36.062]                           grepl <- base::grepl
[17:36:36.062]                           restarts <- computeRestarts(cond)
[17:36:36.062]                           for (restart in restarts) {
[17:36:36.062]                             name <- restart$name
[17:36:36.062]                             if (is.null(name)) 
[17:36:36.062]                               next
[17:36:36.062]                             if (!grepl(pattern, name)) 
[17:36:36.062]                               next
[17:36:36.062]                             invokeRestart(restart)
[17:36:36.062]                             muffled <- TRUE
[17:36:36.062]                             break
[17:36:36.062]                           }
[17:36:36.062]                         }
[17:36:36.062]                       }
[17:36:36.062]                       invisible(muffled)
[17:36:36.062]                     }
[17:36:36.062]                     muffleCondition(cond, pattern = "^muffle")
[17:36:36.062]                   }
[17:36:36.062]                 }
[17:36:36.062]                 else {
[17:36:36.062]                   if (TRUE) {
[17:36:36.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:36.062]                     {
[17:36:36.062]                       inherits <- base::inherits
[17:36:36.062]                       invokeRestart <- base::invokeRestart
[17:36:36.062]                       is.null <- base::is.null
[17:36:36.062]                       muffled <- FALSE
[17:36:36.062]                       if (inherits(cond, "message")) {
[17:36:36.062]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:36.062]                         if (muffled) 
[17:36:36.062]                           invokeRestart("muffleMessage")
[17:36:36.062]                       }
[17:36:36.062]                       else if (inherits(cond, "warning")) {
[17:36:36.062]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:36.062]                         if (muffled) 
[17:36:36.062]                           invokeRestart("muffleWarning")
[17:36:36.062]                       }
[17:36:36.062]                       else if (inherits(cond, "condition")) {
[17:36:36.062]                         if (!is.null(pattern)) {
[17:36:36.062]                           computeRestarts <- base::computeRestarts
[17:36:36.062]                           grepl <- base::grepl
[17:36:36.062]                           restarts <- computeRestarts(cond)
[17:36:36.062]                           for (restart in restarts) {
[17:36:36.062]                             name <- restart$name
[17:36:36.062]                             if (is.null(name)) 
[17:36:36.062]                               next
[17:36:36.062]                             if (!grepl(pattern, name)) 
[17:36:36.062]                               next
[17:36:36.062]                             invokeRestart(restart)
[17:36:36.062]                             muffled <- TRUE
[17:36:36.062]                             break
[17:36:36.062]                           }
[17:36:36.062]                         }
[17:36:36.062]                       }
[17:36:36.062]                       invisible(muffled)
[17:36:36.062]                     }
[17:36:36.062]                     muffleCondition(cond, pattern = "^muffle")
[17:36:36.062]                   }
[17:36:36.062]                 }
[17:36:36.062]             }
[17:36:36.062]         }))
[17:36:36.062]     }, error = function(ex) {
[17:36:36.062]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:36.062]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:36.062]                 ...future.rng), started = ...future.startTime, 
[17:36:36.062]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:36.062]             version = "1.8"), class = "FutureResult")
[17:36:36.062]     }, finally = {
[17:36:36.062]         if (!identical(...future.workdir, getwd())) 
[17:36:36.062]             setwd(...future.workdir)
[17:36:36.062]         {
[17:36:36.062]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:36.062]                 ...future.oldOptions$nwarnings <- NULL
[17:36:36.062]             }
[17:36:36.062]             base::options(...future.oldOptions)
[17:36:36.062]             if (.Platform$OS.type == "windows") {
[17:36:36.062]                 old_names <- names(...future.oldEnvVars)
[17:36:36.062]                 envs <- base::Sys.getenv()
[17:36:36.062]                 names <- names(envs)
[17:36:36.062]                 common <- intersect(names, old_names)
[17:36:36.062]                 added <- setdiff(names, old_names)
[17:36:36.062]                 removed <- setdiff(old_names, names)
[17:36:36.062]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:36.062]                   envs[common]]
[17:36:36.062]                 NAMES <- toupper(changed)
[17:36:36.062]                 args <- list()
[17:36:36.062]                 for (kk in seq_along(NAMES)) {
[17:36:36.062]                   name <- changed[[kk]]
[17:36:36.062]                   NAME <- NAMES[[kk]]
[17:36:36.062]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:36.062]                     next
[17:36:36.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:36.062]                 }
[17:36:36.062]                 NAMES <- toupper(added)
[17:36:36.062]                 for (kk in seq_along(NAMES)) {
[17:36:36.062]                   name <- added[[kk]]
[17:36:36.062]                   NAME <- NAMES[[kk]]
[17:36:36.062]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:36.062]                     next
[17:36:36.062]                   args[[name]] <- ""
[17:36:36.062]                 }
[17:36:36.062]                 NAMES <- toupper(removed)
[17:36:36.062]                 for (kk in seq_along(NAMES)) {
[17:36:36.062]                   name <- removed[[kk]]
[17:36:36.062]                   NAME <- NAMES[[kk]]
[17:36:36.062]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:36.062]                     next
[17:36:36.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:36.062]                 }
[17:36:36.062]                 if (length(args) > 0) 
[17:36:36.062]                   base::do.call(base::Sys.setenv, args = args)
[17:36:36.062]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:36.062]             }
[17:36:36.062]             else {
[17:36:36.062]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:36.062]             }
[17:36:36.062]             {
[17:36:36.062]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:36.062]                   0L) {
[17:36:36.062]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:36.062]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:36.062]                   base::options(opts)
[17:36:36.062]                 }
[17:36:36.062]                 {
[17:36:36.062]                   {
[17:36:36.062]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:36.062]                     NULL
[17:36:36.062]                   }
[17:36:36.062]                   options(future.plan = NULL)
[17:36:36.062]                   if (is.na(NA_character_)) 
[17:36:36.062]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:36.062]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:36.062]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:36.062]                     .init = FALSE)
[17:36:36.062]                 }
[17:36:36.062]             }
[17:36:36.062]         }
[17:36:36.062]     })
[17:36:36.062]     if (TRUE) {
[17:36:36.062]         base::sink(type = "output", split = FALSE)
[17:36:36.062]         if (TRUE) {
[17:36:36.062]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:36.062]         }
[17:36:36.062]         else {
[17:36:36.062]             ...future.result["stdout"] <- base::list(NULL)
[17:36:36.062]         }
[17:36:36.062]         base::close(...future.stdout)
[17:36:36.062]         ...future.stdout <- NULL
[17:36:36.062]     }
[17:36:36.062]     ...future.result$conditions <- ...future.conditions
[17:36:36.062]     ...future.result$finished <- base::Sys.time()
[17:36:36.062]     ...future.result
[17:36:36.062] }
[17:36:36.066] assign_globals() ...
[17:36:36.066] List of 5
[17:36:36.066]  $ future.call.arguments    : list()
[17:36:36.066]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:36.066]  $ ...future.FUN            :function (x)  
[17:36:36.066]  $ ...future.elements_ii    :List of 1
[17:36:36.066]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[17:36:36.066]  $ ...future.seeds_ii       : NULL
[17:36:36.066]  $ ...future.globals.maxSize: num Inf
[17:36:36.066]  - attr(*, "resolved")= logi FALSE
[17:36:36.066]  - attr(*, "total_size")= num NA
[17:36:36.066]  - attr(*, "where")=List of 5
[17:36:36.066]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:36.066]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:36.066]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:36.066]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:36.066]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:36.066]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:36.066]  - attr(*, "already-done")= logi TRUE
[17:36:36.073] - copied ‘future.call.arguments’ to environment
[17:36:36.074] - copied ‘...future.FUN’ to environment
[17:36:36.074] - copied ‘...future.elements_ii’ to environment
[17:36:36.074] - copied ‘...future.seeds_ii’ to environment
[17:36:36.074] - copied ‘...future.globals.maxSize’ to environment
[17:36:36.074] assign_globals() ... done
[17:36:36.074] requestCore(): workers = 2
[17:36:36.077] MulticoreFuture started
[17:36:36.077] - Launch lazy future ... done
[17:36:36.077] run() for ‘MulticoreFuture’ ... done
[17:36:36.078] Created future:
[17:36:36.078] plan(): Setting new future strategy stack:
[17:36:36.078] List of future strategies:
[17:36:36.078] 1. sequential:
[17:36:36.078]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:36.078]    - tweaked: FALSE
[17:36:36.078]    - call: NULL
[17:36:36.079] plan(): nbrOfWorkers() = 1
[17:36:36.081] plan(): Setting new future strategy stack:
[17:36:36.081] List of future strategies:
[17:36:36.081] 1. multicore:
[17:36:36.081]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:36.081]    - tweaked: FALSE
[17:36:36.081]    - call: plan(strategy)
[17:36:36.078] MulticoreFuture:
[17:36:36.078] Label: ‘future_apply-2’
[17:36:36.078] Expression:
[17:36:36.078] {
[17:36:36.078]     do.call(function(...) {
[17:36:36.078]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:36.078]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:36.078]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:36.078]             on.exit(options(oopts), add = TRUE)
[17:36:36.078]         }
[17:36:36.078]         {
[17:36:36.078]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:36.078]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:36.078]                 ...future.FUN(...future.X_jj, ...)
[17:36:36.078]             })
[17:36:36.078]         }
[17:36:36.078]     }, args = future.call.arguments)
[17:36:36.078] }
[17:36:36.078] Lazy evaluation: FALSE
[17:36:36.078] Asynchronous evaluation: TRUE
[17:36:36.078] Local evaluation: TRUE
[17:36:36.078] Environment: R_GlobalEnv
[17:36:36.078] Capture standard output: TRUE
[17:36:36.078] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:36.078] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:36.078] Packages: <none>
[17:36:36.078] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:36.078] Resolved: FALSE
[17:36:36.078] Value: <not collected>
[17:36:36.078] Conditions captured: <none>
[17:36:36.078] Early signaling: FALSE
[17:36:36.078] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:36.078] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:36.091] Chunk #2 of 2 ... DONE
[17:36:36.091] Launching 2 futures (chunks) ... DONE
[17:36:36.091] plan(): nbrOfWorkers() = 2
[17:36:36.091] Resolving 2 futures (chunks) ...
[17:36:36.091] resolve() on list ...
[17:36:36.091]  recursive: 0
[17:36:36.092]  length: 2
[17:36:36.092] 
[17:36:36.092] Future #1
[17:36:36.092] result() for MulticoreFuture ...
[17:36:36.093] result() for MulticoreFuture ...
[17:36:36.093] result() for MulticoreFuture ... done
[17:36:36.096] result() for MulticoreFuture ... done
[17:36:36.096] result() for MulticoreFuture ...
[17:36:36.097] result() for MulticoreFuture ... done
[17:36:36.097] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:36:36.098] - nx: 2
[17:36:36.098] - relay: TRUE
[17:36:36.098] - stdout: TRUE
[17:36:36.099] - signal: TRUE
[17:36:36.099] - resignal: FALSE
[17:36:36.099] - force: TRUE
[17:36:36.099] - relayed: [n=2] FALSE, FALSE
[17:36:36.100] - queued futures: [n=2] FALSE, FALSE
[17:36:36.100]  - until=1
[17:36:36.100]  - relaying element #1
[17:36:36.101] result() for MulticoreFuture ...
[17:36:36.101] result() for MulticoreFuture ... done
[17:36:36.101] result() for MulticoreFuture ...
[17:36:36.102] result() for MulticoreFuture ... done
[17:36:36.102] result() for MulticoreFuture ...
[17:36:36.102] result() for MulticoreFuture ... done
[17:36:36.103] result() for MulticoreFuture ...
[17:36:36.103] result() for MulticoreFuture ... done
[17:36:36.103] - relayed: [n=2] TRUE, FALSE
[17:36:36.103] - queued futures: [n=2] TRUE, FALSE
[17:36:36.103] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:36:36.104]  length: 1 (resolved future 1)
[17:36:36.104] Future #2
[17:36:36.104] result() for MulticoreFuture ...
[17:36:36.105] result() for MulticoreFuture ...
[17:36:36.105] result() for MulticoreFuture ... done
[17:36:36.105] result() for MulticoreFuture ... done
[17:36:36.105] result() for MulticoreFuture ...
[17:36:36.105] result() for MulticoreFuture ... done
[17:36:36.106] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:36:36.106] - nx: 2
[17:36:36.106] - relay: TRUE
[17:36:36.106] - stdout: TRUE
[17:36:36.106] - signal: TRUE
[17:36:36.106] - resignal: FALSE
[17:36:36.107] - force: TRUE
[17:36:36.107] - relayed: [n=2] TRUE, FALSE
[17:36:36.107] - queued futures: [n=2] TRUE, FALSE
[17:36:36.107]  - until=2
[17:36:36.107]  - relaying element #2
[17:36:36.107] result() for MulticoreFuture ...
[17:36:36.107] result() for MulticoreFuture ... done
[17:36:36.107] result() for MulticoreFuture ...
[17:36:36.107] result() for MulticoreFuture ... done
[17:36:36.108] result() for MulticoreFuture ...
[17:36:36.108] result() for MulticoreFuture ... done
[17:36:36.108] result() for MulticoreFuture ...
[17:36:36.108] result() for MulticoreFuture ... done
[17:36:36.108] - relayed: [n=2] TRUE, TRUE
[17:36:36.108] - queued futures: [n=2] TRUE, TRUE
[17:36:36.108] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:36:36.108]  length: 0 (resolved future 2)
[17:36:36.109] Relaying remaining futures
[17:36:36.109] signalConditionsASAP(NULL, pos=0) ...
[17:36:36.109] - nx: 2
[17:36:36.109] - relay: TRUE
[17:36:36.109] - stdout: TRUE
[17:36:36.109] - signal: TRUE
[17:36:36.109] - resignal: FALSE
[17:36:36.109] - force: TRUE
[17:36:36.109] - relayed: [n=2] TRUE, TRUE
[17:36:36.109] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:36.110] - relayed: [n=2] TRUE, TRUE
[17:36:36.110] - queued futures: [n=2] TRUE, TRUE
[17:36:36.110] signalConditionsASAP(NULL, pos=0) ... done
[17:36:36.110] resolve() on list ... DONE
[17:36:36.110] result() for MulticoreFuture ...
[17:36:36.110] result() for MulticoreFuture ... done
[17:36:36.110] result() for MulticoreFuture ...
[17:36:36.110] result() for MulticoreFuture ... done
[17:36:36.110] result() for MulticoreFuture ...
[17:36:36.111] result() for MulticoreFuture ... done
[17:36:36.111] result() for MulticoreFuture ...
[17:36:36.111] result() for MulticoreFuture ... done
[17:36:36.111]  - Number of value chunks collected: 2
[17:36:36.111] Resolving 2 futures (chunks) ... DONE
[17:36:36.111] Reducing values from 2 chunks ...
[17:36:36.111]  - Number of values collected after concatenation: 2
[17:36:36.111]  - Number of values expected: 2
[17:36:36.111] Reducing values from 2 chunks ... DONE
[17:36:36.112] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[17:36:36.112] getGlobalsAndPackagesXApply() ...
[17:36:36.112]  - future.globals: TRUE
[17:36:36.112] getGlobalsAndPackages() ...
[17:36:36.112] Searching for globals...
[17:36:36.115] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[17:36:36.115] Searching for globals ... DONE
[17:36:36.116] Resolving globals: FALSE
[17:36:36.116] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[17:36:36.117] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[17:36:36.117] - globals: [1] ‘FUN’
[17:36:36.117] 
[17:36:36.117] getGlobalsAndPackages() ... DONE
[17:36:36.117]  - globals found/used: [n=1] ‘FUN’
[17:36:36.117]  - needed namespaces: [n=0] 
[17:36:36.117] Finding globals ... DONE
[17:36:36.117]  - use_args: TRUE
[17:36:36.118]  - Getting '...' globals ...
[17:36:36.118] resolve() on list ...
[17:36:36.118]  recursive: 0
[17:36:36.118]  length: 1
[17:36:36.118]  elements: ‘...’
[17:36:36.118]  length: 0 (resolved future 1)
[17:36:36.118] resolve() on list ... DONE
[17:36:36.118]    - '...' content: [n=0] 
[17:36:36.119] List of 1
[17:36:36.119]  $ ...: list()
[17:36:36.119]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:36.119]  - attr(*, "where")=List of 1
[17:36:36.119]   ..$ ...:<environment: 0x556d740f8b90> 
[17:36:36.119]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:36.119]  - attr(*, "resolved")= logi TRUE
[17:36:36.119]  - attr(*, "total_size")= num NA
[17:36:36.121]  - Getting '...' globals ... DONE
[17:36:36.122] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:36.122] List of 2
[17:36:36.122]  $ ...future.FUN:function (x)  
[17:36:36.122]  $ ...          : list()
[17:36:36.122]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:36.122]  - attr(*, "where")=List of 2
[17:36:36.122]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:36.122]   ..$ ...          :<environment: 0x556d740f8b90> 
[17:36:36.122]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:36.122]  - attr(*, "resolved")= logi FALSE
[17:36:36.122]  - attr(*, "total_size")= num 9888
[17:36:36.127] Packages to be attached in all futures: [n=0] 
[17:36:36.127] getGlobalsAndPackagesXApply() ... DONE
[17:36:36.131] future_lapply() ...
[17:36:36.136] Number of chunks: 2
[17:36:36.136] getGlobalsAndPackagesXApply() ...
[17:36:36.136]  - future.globals: <name-value list> with names ‘list()’
[17:36:36.137]  - use_args: TRUE
[17:36:36.137] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:36.137] List of 2
[17:36:36.137]  $ ...          : list()
[17:36:36.137]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:36.137]  $ ...future.FUN:function (x)  
[17:36:36.137]  - attr(*, "where")=List of 2
[17:36:36.137]   ..$ ...          :<environment: 0x556d740f8b90> 
[17:36:36.137]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:36:36.137]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:36.137]  - attr(*, "resolved")= logi FALSE
[17:36:36.137]  - attr(*, "total_size")= num NA
[17:36:36.140] Packages to be attached in all futures: [n=0] 
[17:36:36.140] getGlobalsAndPackagesXApply() ... DONE
[17:36:36.140] Number of futures (= number of chunks): 2
[17:36:36.140] Launching 2 futures (chunks) ...
[17:36:36.140] Chunk #1 of 2 ...
[17:36:36.140]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:36.141]  - seeds: <none>
[17:36:36.141]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:36.141] getGlobalsAndPackages() ...
[17:36:36.141] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:36.141] Resolving globals: FALSE
[17:36:36.141] Tweak future expression to call with '...' arguments ...
[17:36:36.141] {
[17:36:36.141]     do.call(function(...) {
[17:36:36.141]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:36.141]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:36.141]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:36.141]             on.exit(options(oopts), add = TRUE)
[17:36:36.141]         }
[17:36:36.141]         {
[17:36:36.141]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:36.141]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:36.141]                 ...future.FUN(...future.X_jj, ...)
[17:36:36.141]             })
[17:36:36.141]         }
[17:36:36.141]     }, args = future.call.arguments)
[17:36:36.141] }
[17:36:36.141] Tweak future expression to call with '...' arguments ... DONE
[17:36:36.142] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:36.142] 
[17:36:36.142] getGlobalsAndPackages() ... DONE
[17:36:36.142] run() for ‘Future’ ...
[17:36:36.142] - state: ‘created’
[17:36:36.143] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:36.146] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:36.146] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:36.146]   - Field: ‘label’
[17:36:36.146]   - Field: ‘local’
[17:36:36.147]   - Field: ‘owner’
[17:36:36.147]   - Field: ‘envir’
[17:36:36.147]   - Field: ‘workers’
[17:36:36.147]   - Field: ‘packages’
[17:36:36.147]   - Field: ‘gc’
[17:36:36.147]   - Field: ‘job’
[17:36:36.147]   - Field: ‘conditions’
[17:36:36.147]   - Field: ‘expr’
[17:36:36.147]   - Field: ‘uuid’
[17:36:36.147]   - Field: ‘seed’
[17:36:36.148]   - Field: ‘version’
[17:36:36.148]   - Field: ‘result’
[17:36:36.148]   - Field: ‘asynchronous’
[17:36:36.148]   - Field: ‘calls’
[17:36:36.148]   - Field: ‘globals’
[17:36:36.148]   - Field: ‘stdout’
[17:36:36.148]   - Field: ‘earlySignal’
[17:36:36.148]   - Field: ‘lazy’
[17:36:36.148]   - Field: ‘state’
[17:36:36.148] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:36.149] - Launch lazy future ...
[17:36:36.149] Packages needed by the future expression (n = 0): <none>
[17:36:36.149] Packages needed by future strategies (n = 0): <none>
[17:36:36.149] {
[17:36:36.149]     {
[17:36:36.149]         {
[17:36:36.149]             ...future.startTime <- base::Sys.time()
[17:36:36.149]             {
[17:36:36.149]                 {
[17:36:36.149]                   {
[17:36:36.149]                     {
[17:36:36.149]                       base::local({
[17:36:36.149]                         has_future <- base::requireNamespace("future", 
[17:36:36.149]                           quietly = TRUE)
[17:36:36.149]                         if (has_future) {
[17:36:36.149]                           ns <- base::getNamespace("future")
[17:36:36.149]                           version <- ns[[".package"]][["version"]]
[17:36:36.149]                           if (is.null(version)) 
[17:36:36.149]                             version <- utils::packageVersion("future")
[17:36:36.149]                         }
[17:36:36.149]                         else {
[17:36:36.149]                           version <- NULL
[17:36:36.149]                         }
[17:36:36.149]                         if (!has_future || version < "1.8.0") {
[17:36:36.149]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:36.149]                             "", base::R.version$version.string), 
[17:36:36.149]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:36.149]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:36.149]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:36.149]                               "release", "version")], collapse = " "), 
[17:36:36.149]                             hostname = base::Sys.info()[["nodename"]])
[17:36:36.149]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:36.149]                             info)
[17:36:36.149]                           info <- base::paste(info, collapse = "; ")
[17:36:36.149]                           if (!has_future) {
[17:36:36.149]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:36.149]                               info)
[17:36:36.149]                           }
[17:36:36.149]                           else {
[17:36:36.149]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:36.149]                               info, version)
[17:36:36.149]                           }
[17:36:36.149]                           base::stop(msg)
[17:36:36.149]                         }
[17:36:36.149]                       })
[17:36:36.149]                     }
[17:36:36.149]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:36.149]                     base::options(mc.cores = 1L)
[17:36:36.149]                   }
[17:36:36.149]                   ...future.strategy.old <- future::plan("list")
[17:36:36.149]                   options(future.plan = NULL)
[17:36:36.149]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:36.149]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:36.149]                 }
[17:36:36.149]                 ...future.workdir <- getwd()
[17:36:36.149]             }
[17:36:36.149]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:36.149]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:36.149]         }
[17:36:36.149]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:36.149]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:36.149]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:36.149]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:36.149]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:36.149]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:36.149]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:36.149]             base::names(...future.oldOptions))
[17:36:36.149]     }
[17:36:36.149]     if (FALSE) {
[17:36:36.149]     }
[17:36:36.149]     else {
[17:36:36.149]         if (TRUE) {
[17:36:36.149]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:36.149]                 open = "w")
[17:36:36.149]         }
[17:36:36.149]         else {
[17:36:36.149]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:36.149]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:36.149]         }
[17:36:36.149]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:36.149]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:36.149]             base::sink(type = "output", split = FALSE)
[17:36:36.149]             base::close(...future.stdout)
[17:36:36.149]         }, add = TRUE)
[17:36:36.149]     }
[17:36:36.149]     ...future.frame <- base::sys.nframe()
[17:36:36.149]     ...future.conditions <- base::list()
[17:36:36.149]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:36.149]     if (FALSE) {
[17:36:36.149]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:36.149]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:36.149]     }
[17:36:36.149]     ...future.result <- base::tryCatch({
[17:36:36.149]         base::withCallingHandlers({
[17:36:36.149]             ...future.value <- base::withVisible(base::local({
[17:36:36.149]                 withCallingHandlers({
[17:36:36.149]                   {
[17:36:36.149]                     do.call(function(...) {
[17:36:36.149]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:36.149]                       if (!identical(...future.globals.maxSize.org, 
[17:36:36.149]                         ...future.globals.maxSize)) {
[17:36:36.149]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:36.149]                         on.exit(options(oopts), add = TRUE)
[17:36:36.149]                       }
[17:36:36.149]                       {
[17:36:36.149]                         lapply(seq_along(...future.elements_ii), 
[17:36:36.149]                           FUN = function(jj) {
[17:36:36.149]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:36.149]                             ...future.FUN(...future.X_jj, ...)
[17:36:36.149]                           })
[17:36:36.149]                       }
[17:36:36.149]                     }, args = future.call.arguments)
[17:36:36.149]                   }
[17:36:36.149]                 }, immediateCondition = function(cond) {
[17:36:36.149]                   save_rds <- function (object, pathname, ...) 
[17:36:36.149]                   {
[17:36:36.149]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:36.149]                     if (file_test("-f", pathname_tmp)) {
[17:36:36.149]                       fi_tmp <- file.info(pathname_tmp)
[17:36:36.149]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:36.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:36.149]                         fi_tmp[["mtime"]])
[17:36:36.149]                     }
[17:36:36.149]                     tryCatch({
[17:36:36.149]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:36.149]                     }, error = function(ex) {
[17:36:36.149]                       msg <- conditionMessage(ex)
[17:36:36.149]                       fi_tmp <- file.info(pathname_tmp)
[17:36:36.149]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:36.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:36.149]                         fi_tmp[["mtime"]], msg)
[17:36:36.149]                       ex$message <- msg
[17:36:36.149]                       stop(ex)
[17:36:36.149]                     })
[17:36:36.149]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:36.149]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:36.149]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:36.149]                       fi_tmp <- file.info(pathname_tmp)
[17:36:36.149]                       fi <- file.info(pathname)
[17:36:36.149]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:36.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:36.149]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:36.149]                         fi[["size"]], fi[["mtime"]])
[17:36:36.149]                       stop(msg)
[17:36:36.149]                     }
[17:36:36.149]                     invisible(pathname)
[17:36:36.149]                   }
[17:36:36.149]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:36.149]                     rootPath = tempdir()) 
[17:36:36.149]                   {
[17:36:36.149]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:36.149]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:36.149]                       tmpdir = path, fileext = ".rds")
[17:36:36.149]                     save_rds(obj, file)
[17:36:36.149]                   }
[17:36:36.149]                   saveImmediateCondition(cond, path = "/tmp/RtmpABg8SG/.future/immediateConditions")
[17:36:36.149]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:36.149]                   {
[17:36:36.149]                     inherits <- base::inherits
[17:36:36.149]                     invokeRestart <- base::invokeRestart
[17:36:36.149]                     is.null <- base::is.null
[17:36:36.149]                     muffled <- FALSE
[17:36:36.149]                     if (inherits(cond, "message")) {
[17:36:36.149]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:36.149]                       if (muffled) 
[17:36:36.149]                         invokeRestart("muffleMessage")
[17:36:36.149]                     }
[17:36:36.149]                     else if (inherits(cond, "warning")) {
[17:36:36.149]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:36.149]                       if (muffled) 
[17:36:36.149]                         invokeRestart("muffleWarning")
[17:36:36.149]                     }
[17:36:36.149]                     else if (inherits(cond, "condition")) {
[17:36:36.149]                       if (!is.null(pattern)) {
[17:36:36.149]                         computeRestarts <- base::computeRestarts
[17:36:36.149]                         grepl <- base::grepl
[17:36:36.149]                         restarts <- computeRestarts(cond)
[17:36:36.149]                         for (restart in restarts) {
[17:36:36.149]                           name <- restart$name
[17:36:36.149]                           if (is.null(name)) 
[17:36:36.149]                             next
[17:36:36.149]                           if (!grepl(pattern, name)) 
[17:36:36.149]                             next
[17:36:36.149]                           invokeRestart(restart)
[17:36:36.149]                           muffled <- TRUE
[17:36:36.149]                           break
[17:36:36.149]                         }
[17:36:36.149]                       }
[17:36:36.149]                     }
[17:36:36.149]                     invisible(muffled)
[17:36:36.149]                   }
[17:36:36.149]                   muffleCondition(cond)
[17:36:36.149]                 })
[17:36:36.149]             }))
[17:36:36.149]             future::FutureResult(value = ...future.value$value, 
[17:36:36.149]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:36.149]                   ...future.rng), globalenv = if (FALSE) 
[17:36:36.149]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:36.149]                     ...future.globalenv.names))
[17:36:36.149]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:36.149]         }, condition = base::local({
[17:36:36.149]             c <- base::c
[17:36:36.149]             inherits <- base::inherits
[17:36:36.149]             invokeRestart <- base::invokeRestart
[17:36:36.149]             length <- base::length
[17:36:36.149]             list <- base::list
[17:36:36.149]             seq.int <- base::seq.int
[17:36:36.149]             signalCondition <- base::signalCondition
[17:36:36.149]             sys.calls <- base::sys.calls
[17:36:36.149]             `[[` <- base::`[[`
[17:36:36.149]             `+` <- base::`+`
[17:36:36.149]             `<<-` <- base::`<<-`
[17:36:36.149]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:36.149]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:36.149]                   3L)]
[17:36:36.149]             }
[17:36:36.149]             function(cond) {
[17:36:36.149]                 is_error <- inherits(cond, "error")
[17:36:36.149]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:36.149]                   NULL)
[17:36:36.149]                 if (is_error) {
[17:36:36.149]                   sessionInformation <- function() {
[17:36:36.149]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:36.149]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:36.149]                       search = base::search(), system = base::Sys.info())
[17:36:36.149]                   }
[17:36:36.149]                   ...future.conditions[[length(...future.conditions) + 
[17:36:36.149]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:36.149]                     cond$call), session = sessionInformation(), 
[17:36:36.149]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:36.149]                   signalCondition(cond)
[17:36:36.149]                 }
[17:36:36.149]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:36.149]                 "immediateCondition"))) {
[17:36:36.149]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:36.149]                   ...future.conditions[[length(...future.conditions) + 
[17:36:36.149]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:36.149]                   if (TRUE && !signal) {
[17:36:36.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:36.149]                     {
[17:36:36.149]                       inherits <- base::inherits
[17:36:36.149]                       invokeRestart <- base::invokeRestart
[17:36:36.149]                       is.null <- base::is.null
[17:36:36.149]                       muffled <- FALSE
[17:36:36.149]                       if (inherits(cond, "message")) {
[17:36:36.149]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:36.149]                         if (muffled) 
[17:36:36.149]                           invokeRestart("muffleMessage")
[17:36:36.149]                       }
[17:36:36.149]                       else if (inherits(cond, "warning")) {
[17:36:36.149]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:36.149]                         if (muffled) 
[17:36:36.149]                           invokeRestart("muffleWarning")
[17:36:36.149]                       }
[17:36:36.149]                       else if (inherits(cond, "condition")) {
[17:36:36.149]                         if (!is.null(pattern)) {
[17:36:36.149]                           computeRestarts <- base::computeRestarts
[17:36:36.149]                           grepl <- base::grepl
[17:36:36.149]                           restarts <- computeRestarts(cond)
[17:36:36.149]                           for (restart in restarts) {
[17:36:36.149]                             name <- restart$name
[17:36:36.149]                             if (is.null(name)) 
[17:36:36.149]                               next
[17:36:36.149]                             if (!grepl(pattern, name)) 
[17:36:36.149]                               next
[17:36:36.149]                             invokeRestart(restart)
[17:36:36.149]                             muffled <- TRUE
[17:36:36.149]                             break
[17:36:36.149]                           }
[17:36:36.149]                         }
[17:36:36.149]                       }
[17:36:36.149]                       invisible(muffled)
[17:36:36.149]                     }
[17:36:36.149]                     muffleCondition(cond, pattern = "^muffle")
[17:36:36.149]                   }
[17:36:36.149]                 }
[17:36:36.149]                 else {
[17:36:36.149]                   if (TRUE) {
[17:36:36.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:36.149]                     {
[17:36:36.149]                       inherits <- base::inherits
[17:36:36.149]                       invokeRestart <- base::invokeRestart
[17:36:36.149]                       is.null <- base::is.null
[17:36:36.149]                       muffled <- FALSE
[17:36:36.149]                       if (inherits(cond, "message")) {
[17:36:36.149]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:36.149]                         if (muffled) 
[17:36:36.149]                           invokeRestart("muffleMessage")
[17:36:36.149]                       }
[17:36:36.149]                       else if (inherits(cond, "warning")) {
[17:36:36.149]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:36.149]                         if (muffled) 
[17:36:36.149]                           invokeRestart("muffleWarning")
[17:36:36.149]                       }
[17:36:36.149]                       else if (inherits(cond, "condition")) {
[17:36:36.149]                         if (!is.null(pattern)) {
[17:36:36.149]                           computeRestarts <- base::computeRestarts
[17:36:36.149]                           grepl <- base::grepl
[17:36:36.149]                           restarts <- computeRestarts(cond)
[17:36:36.149]                           for (restart in restarts) {
[17:36:36.149]                             name <- restart$name
[17:36:36.149]                             if (is.null(name)) 
[17:36:36.149]                               next
[17:36:36.149]                             if (!grepl(pattern, name)) 
[17:36:36.149]                               next
[17:36:36.149]                             invokeRestart(restart)
[17:36:36.149]                             muffled <- TRUE
[17:36:36.149]                             break
[17:36:36.149]                           }
[17:36:36.149]                         }
[17:36:36.149]                       }
[17:36:36.149]                       invisible(muffled)
[17:36:36.149]                     }
[17:36:36.149]                     muffleCondition(cond, pattern = "^muffle")
[17:36:36.149]                   }
[17:36:36.149]                 }
[17:36:36.149]             }
[17:36:36.149]         }))
[17:36:36.149]     }, error = function(ex) {
[17:36:36.149]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:36.149]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:36.149]                 ...future.rng), started = ...future.startTime, 
[17:36:36.149]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:36.149]             version = "1.8"), class = "FutureResult")
[17:36:36.149]     }, finally = {
[17:36:36.149]         if (!identical(...future.workdir, getwd())) 
[17:36:36.149]             setwd(...future.workdir)
[17:36:36.149]         {
[17:36:36.149]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:36.149]                 ...future.oldOptions$nwarnings <- NULL
[17:36:36.149]             }
[17:36:36.149]             base::options(...future.oldOptions)
[17:36:36.149]             if (.Platform$OS.type == "windows") {
[17:36:36.149]                 old_names <- names(...future.oldEnvVars)
[17:36:36.149]                 envs <- base::Sys.getenv()
[17:36:36.149]                 names <- names(envs)
[17:36:36.149]                 common <- intersect(names, old_names)
[17:36:36.149]                 added <- setdiff(names, old_names)
[17:36:36.149]                 removed <- setdiff(old_names, names)
[17:36:36.149]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:36.149]                   envs[common]]
[17:36:36.149]                 NAMES <- toupper(changed)
[17:36:36.149]                 args <- list()
[17:36:36.149]                 for (kk in seq_along(NAMES)) {
[17:36:36.149]                   name <- changed[[kk]]
[17:36:36.149]                   NAME <- NAMES[[kk]]
[17:36:36.149]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:36.149]                     next
[17:36:36.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:36.149]                 }
[17:36:36.149]                 NAMES <- toupper(added)
[17:36:36.149]                 for (kk in seq_along(NAMES)) {
[17:36:36.149]                   name <- added[[kk]]
[17:36:36.149]                   NAME <- NAMES[[kk]]
[17:36:36.149]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:36.149]                     next
[17:36:36.149]                   args[[name]] <- ""
[17:36:36.149]                 }
[17:36:36.149]                 NAMES <- toupper(removed)
[17:36:36.149]                 for (kk in seq_along(NAMES)) {
[17:36:36.149]                   name <- removed[[kk]]
[17:36:36.149]                   NAME <- NAMES[[kk]]
[17:36:36.149]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:36.149]                     next
[17:36:36.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:36.149]                 }
[17:36:36.149]                 if (length(args) > 0) 
[17:36:36.149]                   base::do.call(base::Sys.setenv, args = args)
[17:36:36.149]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:36.149]             }
[17:36:36.149]             else {
[17:36:36.149]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:36.149]             }
[17:36:36.149]             {
[17:36:36.149]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:36.149]                   0L) {
[17:36:36.149]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:36.149]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:36.149]                   base::options(opts)
[17:36:36.149]                 }
[17:36:36.149]                 {
[17:36:36.149]                   {
[17:36:36.149]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:36.149]                     NULL
[17:36:36.149]                   }
[17:36:36.149]                   options(future.plan = NULL)
[17:36:36.149]                   if (is.na(NA_character_)) 
[17:36:36.149]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:36.149]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:36.149]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:36.149]                     .init = FALSE)
[17:36:36.149]                 }
[17:36:36.149]             }
[17:36:36.149]         }
[17:36:36.149]     })
[17:36:36.149]     if (TRUE) {
[17:36:36.149]         base::sink(type = "output", split = FALSE)
[17:36:36.149]         if (TRUE) {
[17:36:36.149]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:36.149]         }
[17:36:36.149]         else {
[17:36:36.149]             ...future.result["stdout"] <- base::list(NULL)
[17:36:36.149]         }
[17:36:36.149]         base::close(...future.stdout)
[17:36:36.149]         ...future.stdout <- NULL
[17:36:36.149]     }
[17:36:36.149]     ...future.result$conditions <- ...future.conditions
[17:36:36.149]     ...future.result$finished <- base::Sys.time()
[17:36:36.149]     ...future.result
[17:36:36.149] }
[17:36:36.152] assign_globals() ...
[17:36:36.152] List of 5
[17:36:36.152]  $ future.call.arguments    : list()
[17:36:36.152]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:36.152]  $ ...future.FUN            :function (x)  
[17:36:36.152]  $ ...future.elements_ii    :List of 1
[17:36:36.152]   ..$ : int [1:2] 1 3
[17:36:36.152]  $ ...future.seeds_ii       : NULL
[17:36:36.152]  $ ...future.globals.maxSize: num Inf
[17:36:36.152]  - attr(*, "resolved")= logi FALSE
[17:36:36.152]  - attr(*, "total_size")= num NA
[17:36:36.152]  - attr(*, "where")=List of 5
[17:36:36.152]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:36.152]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:36.152]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:36.152]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:36.152]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:36.152]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:36.152]  - attr(*, "already-done")= logi TRUE
[17:36:36.159] - copied ‘future.call.arguments’ to environment
[17:36:36.159] - reassign environment for ‘...future.FUN’
[17:36:36.159] - copied ‘...future.FUN’ to environment
[17:36:36.159] - copied ‘...future.elements_ii’ to environment
[17:36:36.159] - copied ‘...future.seeds_ii’ to environment
[17:36:36.159] - copied ‘...future.globals.maxSize’ to environment
[17:36:36.159] assign_globals() ... done
[17:36:36.159] requestCore(): workers = 2
[17:36:36.162] MulticoreFuture started
[17:36:36.163] - Launch lazy future ... done
[17:36:36.163] plan(): Setting new future strategy stack:
[17:36:36.163] run() for ‘MulticoreFuture’ ... done
[17:36:36.164] Created future:
[17:36:36.164] List of future strategies:
[17:36:36.164] 1. sequential:
[17:36:36.164]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:36.164]    - tweaked: FALSE
[17:36:36.164]    - call: NULL
[17:36:36.166] plan(): nbrOfWorkers() = 1
[17:36:36.169] plan(): Setting new future strategy stack:
[17:36:36.169] List of future strategies:
[17:36:36.169] 1. multicore:
[17:36:36.169]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:36.169]    - tweaked: FALSE
[17:36:36.169]    - call: plan(strategy)
[17:36:36.174] plan(): nbrOfWorkers() = 2
[17:36:36.165] MulticoreFuture:
[17:36:36.165] Label: ‘future_apply-1’
[17:36:36.165] Expression:
[17:36:36.165] {
[17:36:36.165]     do.call(function(...) {
[17:36:36.165]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:36.165]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:36.165]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:36.165]             on.exit(options(oopts), add = TRUE)
[17:36:36.165]         }
[17:36:36.165]         {
[17:36:36.165]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:36.165]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:36.165]                 ...future.FUN(...future.X_jj, ...)
[17:36:36.165]             })
[17:36:36.165]         }
[17:36:36.165]     }, args = future.call.arguments)
[17:36:36.165] }
[17:36:36.165] Lazy evaluation: FALSE
[17:36:36.165] Asynchronous evaluation: TRUE
[17:36:36.165] Local evaluation: TRUE
[17:36:36.165] Environment: R_GlobalEnv
[17:36:36.165] Capture standard output: TRUE
[17:36:36.165] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:36.165] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:36.165] Packages: <none>
[17:36:36.165] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:36.165] Resolved: TRUE
[17:36:36.165] Value: <not collected>
[17:36:36.165] Conditions captured: <none>
[17:36:36.165] Early signaling: FALSE
[17:36:36.165] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:36.165] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:36.176] Chunk #1 of 2 ... DONE
[17:36:36.176] Chunk #2 of 2 ...
[17:36:36.176]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:36.176]  - seeds: <none>
[17:36:36.176]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:36.177] getGlobalsAndPackages() ...
[17:36:36.177] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:36.177] Resolving globals: FALSE
[17:36:36.177] Tweak future expression to call with '...' arguments ...
[17:36:36.177] {
[17:36:36.177]     do.call(function(...) {
[17:36:36.177]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:36.177]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:36.177]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:36.177]             on.exit(options(oopts), add = TRUE)
[17:36:36.177]         }
[17:36:36.177]         {
[17:36:36.177]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:36.177]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:36.177]                 ...future.FUN(...future.X_jj, ...)
[17:36:36.177]             })
[17:36:36.177]         }
[17:36:36.177]     }, args = future.call.arguments)
[17:36:36.177] }
[17:36:36.178] Tweak future expression to call with '...' arguments ... DONE
[17:36:36.178] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:36.179] 
[17:36:36.179] getGlobalsAndPackages() ... DONE
[17:36:36.179] run() for ‘Future’ ...
[17:36:36.179] - state: ‘created’
[17:36:36.180] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:36.184] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:36.184] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:36.185]   - Field: ‘label’
[17:36:36.185]   - Field: ‘local’
[17:36:36.185]   - Field: ‘owner’
[17:36:36.185]   - Field: ‘envir’
[17:36:36.185]   - Field: ‘workers’
[17:36:36.185]   - Field: ‘packages’
[17:36:36.185]   - Field: ‘gc’
[17:36:36.186]   - Field: ‘job’
[17:36:36.186]   - Field: ‘conditions’
[17:36:36.186]   - Field: ‘expr’
[17:36:36.186]   - Field: ‘uuid’
[17:36:36.186]   - Field: ‘seed’
[17:36:36.186]   - Field: ‘version’
[17:36:36.186]   - Field: ‘result’
[17:36:36.187]   - Field: ‘asynchronous’
[17:36:36.187]   - Field: ‘calls’
[17:36:36.187]   - Field: ‘globals’
[17:36:36.187]   - Field: ‘stdout’
[17:36:36.187]   - Field: ‘earlySignal’
[17:36:36.187]   - Field: ‘lazy’
[17:36:36.187]   - Field: ‘state’
[17:36:36.187] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:36.188] - Launch lazy future ...
[17:36:36.188] Packages needed by the future expression (n = 0): <none>
[17:36:36.188] Packages needed by future strategies (n = 0): <none>
[17:36:36.189] {
[17:36:36.189]     {
[17:36:36.189]         {
[17:36:36.189]             ...future.startTime <- base::Sys.time()
[17:36:36.189]             {
[17:36:36.189]                 {
[17:36:36.189]                   {
[17:36:36.189]                     {
[17:36:36.189]                       base::local({
[17:36:36.189]                         has_future <- base::requireNamespace("future", 
[17:36:36.189]                           quietly = TRUE)
[17:36:36.189]                         if (has_future) {
[17:36:36.189]                           ns <- base::getNamespace("future")
[17:36:36.189]                           version <- ns[[".package"]][["version"]]
[17:36:36.189]                           if (is.null(version)) 
[17:36:36.189]                             version <- utils::packageVersion("future")
[17:36:36.189]                         }
[17:36:36.189]                         else {
[17:36:36.189]                           version <- NULL
[17:36:36.189]                         }
[17:36:36.189]                         if (!has_future || version < "1.8.0") {
[17:36:36.189]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:36.189]                             "", base::R.version$version.string), 
[17:36:36.189]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:36.189]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:36.189]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:36.189]                               "release", "version")], collapse = " "), 
[17:36:36.189]                             hostname = base::Sys.info()[["nodename"]])
[17:36:36.189]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:36.189]                             info)
[17:36:36.189]                           info <- base::paste(info, collapse = "; ")
[17:36:36.189]                           if (!has_future) {
[17:36:36.189]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:36.189]                               info)
[17:36:36.189]                           }
[17:36:36.189]                           else {
[17:36:36.189]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:36.189]                               info, version)
[17:36:36.189]                           }
[17:36:36.189]                           base::stop(msg)
[17:36:36.189]                         }
[17:36:36.189]                       })
[17:36:36.189]                     }
[17:36:36.189]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:36.189]                     base::options(mc.cores = 1L)
[17:36:36.189]                   }
[17:36:36.189]                   ...future.strategy.old <- future::plan("list")
[17:36:36.189]                   options(future.plan = NULL)
[17:36:36.189]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:36.189]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:36.189]                 }
[17:36:36.189]                 ...future.workdir <- getwd()
[17:36:36.189]             }
[17:36:36.189]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:36.189]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:36.189]         }
[17:36:36.189]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:36.189]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:36.189]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:36.189]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:36.189]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:36.189]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:36.189]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:36.189]             base::names(...future.oldOptions))
[17:36:36.189]     }
[17:36:36.189]     if (FALSE) {
[17:36:36.189]     }
[17:36:36.189]     else {
[17:36:36.189]         if (TRUE) {
[17:36:36.189]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:36.189]                 open = "w")
[17:36:36.189]         }
[17:36:36.189]         else {
[17:36:36.189]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:36.189]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:36.189]         }
[17:36:36.189]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:36.189]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:36.189]             base::sink(type = "output", split = FALSE)
[17:36:36.189]             base::close(...future.stdout)
[17:36:36.189]         }, add = TRUE)
[17:36:36.189]     }
[17:36:36.189]     ...future.frame <- base::sys.nframe()
[17:36:36.189]     ...future.conditions <- base::list()
[17:36:36.189]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:36.189]     if (FALSE) {
[17:36:36.189]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:36.189]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:36.189]     }
[17:36:36.189]     ...future.result <- base::tryCatch({
[17:36:36.189]         base::withCallingHandlers({
[17:36:36.189]             ...future.value <- base::withVisible(base::local({
[17:36:36.189]                 withCallingHandlers({
[17:36:36.189]                   {
[17:36:36.189]                     do.call(function(...) {
[17:36:36.189]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:36.189]                       if (!identical(...future.globals.maxSize.org, 
[17:36:36.189]                         ...future.globals.maxSize)) {
[17:36:36.189]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:36.189]                         on.exit(options(oopts), add = TRUE)
[17:36:36.189]                       }
[17:36:36.189]                       {
[17:36:36.189]                         lapply(seq_along(...future.elements_ii), 
[17:36:36.189]                           FUN = function(jj) {
[17:36:36.189]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:36.189]                             ...future.FUN(...future.X_jj, ...)
[17:36:36.189]                           })
[17:36:36.189]                       }
[17:36:36.189]                     }, args = future.call.arguments)
[17:36:36.189]                   }
[17:36:36.189]                 }, immediateCondition = function(cond) {
[17:36:36.189]                   save_rds <- function (object, pathname, ...) 
[17:36:36.189]                   {
[17:36:36.189]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:36.189]                     if (file_test("-f", pathname_tmp)) {
[17:36:36.189]                       fi_tmp <- file.info(pathname_tmp)
[17:36:36.189]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:36.189]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:36.189]                         fi_tmp[["mtime"]])
[17:36:36.189]                     }
[17:36:36.189]                     tryCatch({
[17:36:36.189]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:36.189]                     }, error = function(ex) {
[17:36:36.189]                       msg <- conditionMessage(ex)
[17:36:36.189]                       fi_tmp <- file.info(pathname_tmp)
[17:36:36.189]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:36.189]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:36.189]                         fi_tmp[["mtime"]], msg)
[17:36:36.189]                       ex$message <- msg
[17:36:36.189]                       stop(ex)
[17:36:36.189]                     })
[17:36:36.189]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:36.189]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:36.189]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:36.189]                       fi_tmp <- file.info(pathname_tmp)
[17:36:36.189]                       fi <- file.info(pathname)
[17:36:36.189]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:36.189]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:36.189]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:36.189]                         fi[["size"]], fi[["mtime"]])
[17:36:36.189]                       stop(msg)
[17:36:36.189]                     }
[17:36:36.189]                     invisible(pathname)
[17:36:36.189]                   }
[17:36:36.189]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:36.189]                     rootPath = tempdir()) 
[17:36:36.189]                   {
[17:36:36.189]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:36.189]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:36.189]                       tmpdir = path, fileext = ".rds")
[17:36:36.189]                     save_rds(obj, file)
[17:36:36.189]                   }
[17:36:36.189]                   saveImmediateCondition(cond, path = "/tmp/RtmpABg8SG/.future/immediateConditions")
[17:36:36.189]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:36.189]                   {
[17:36:36.189]                     inherits <- base::inherits
[17:36:36.189]                     invokeRestart <- base::invokeRestart
[17:36:36.189]                     is.null <- base::is.null
[17:36:36.189]                     muffled <- FALSE
[17:36:36.189]                     if (inherits(cond, "message")) {
[17:36:36.189]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:36.189]                       if (muffled) 
[17:36:36.189]                         invokeRestart("muffleMessage")
[17:36:36.189]                     }
[17:36:36.189]                     else if (inherits(cond, "warning")) {
[17:36:36.189]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:36.189]                       if (muffled) 
[17:36:36.189]                         invokeRestart("muffleWarning")
[17:36:36.189]                     }
[17:36:36.189]                     else if (inherits(cond, "condition")) {
[17:36:36.189]                       if (!is.null(pattern)) {
[17:36:36.189]                         computeRestarts <- base::computeRestarts
[17:36:36.189]                         grepl <- base::grepl
[17:36:36.189]                         restarts <- computeRestarts(cond)
[17:36:36.189]                         for (restart in restarts) {
[17:36:36.189]                           name <- restart$name
[17:36:36.189]                           if (is.null(name)) 
[17:36:36.189]                             next
[17:36:36.189]                           if (!grepl(pattern, name)) 
[17:36:36.189]                             next
[17:36:36.189]                           invokeRestart(restart)
[17:36:36.189]                           muffled <- TRUE
[17:36:36.189]                           break
[17:36:36.189]                         }
[17:36:36.189]                       }
[17:36:36.189]                     }
[17:36:36.189]                     invisible(muffled)
[17:36:36.189]                   }
[17:36:36.189]                   muffleCondition(cond)
[17:36:36.189]                 })
[17:36:36.189]             }))
[17:36:36.189]             future::FutureResult(value = ...future.value$value, 
[17:36:36.189]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:36.189]                   ...future.rng), globalenv = if (FALSE) 
[17:36:36.189]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:36.189]                     ...future.globalenv.names))
[17:36:36.189]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:36.189]         }, condition = base::local({
[17:36:36.189]             c <- base::c
[17:36:36.189]             inherits <- base::inherits
[17:36:36.189]             invokeRestart <- base::invokeRestart
[17:36:36.189]             length <- base::length
[17:36:36.189]             list <- base::list
[17:36:36.189]             seq.int <- base::seq.int
[17:36:36.189]             signalCondition <- base::signalCondition
[17:36:36.189]             sys.calls <- base::sys.calls
[17:36:36.189]             `[[` <- base::`[[`
[17:36:36.189]             `+` <- base::`+`
[17:36:36.189]             `<<-` <- base::`<<-`
[17:36:36.189]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:36.189]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:36.189]                   3L)]
[17:36:36.189]             }
[17:36:36.189]             function(cond) {
[17:36:36.189]                 is_error <- inherits(cond, "error")
[17:36:36.189]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:36.189]                   NULL)
[17:36:36.189]                 if (is_error) {
[17:36:36.189]                   sessionInformation <- function() {
[17:36:36.189]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:36.189]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:36.189]                       search = base::search(), system = base::Sys.info())
[17:36:36.189]                   }
[17:36:36.189]                   ...future.conditions[[length(...future.conditions) + 
[17:36:36.189]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:36.189]                     cond$call), session = sessionInformation(), 
[17:36:36.189]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:36.189]                   signalCondition(cond)
[17:36:36.189]                 }
[17:36:36.189]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:36.189]                 "immediateCondition"))) {
[17:36:36.189]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:36.189]                   ...future.conditions[[length(...future.conditions) + 
[17:36:36.189]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:36.189]                   if (TRUE && !signal) {
[17:36:36.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:36.189]                     {
[17:36:36.189]                       inherits <- base::inherits
[17:36:36.189]                       invokeRestart <- base::invokeRestart
[17:36:36.189]                       is.null <- base::is.null
[17:36:36.189]                       muffled <- FALSE
[17:36:36.189]                       if (inherits(cond, "message")) {
[17:36:36.189]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:36.189]                         if (muffled) 
[17:36:36.189]                           invokeRestart("muffleMessage")
[17:36:36.189]                       }
[17:36:36.189]                       else if (inherits(cond, "warning")) {
[17:36:36.189]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:36.189]                         if (muffled) 
[17:36:36.189]                           invokeRestart("muffleWarning")
[17:36:36.189]                       }
[17:36:36.189]                       else if (inherits(cond, "condition")) {
[17:36:36.189]                         if (!is.null(pattern)) {
[17:36:36.189]                           computeRestarts <- base::computeRestarts
[17:36:36.189]                           grepl <- base::grepl
[17:36:36.189]                           restarts <- computeRestarts(cond)
[17:36:36.189]                           for (restart in restarts) {
[17:36:36.189]                             name <- restart$name
[17:36:36.189]                             if (is.null(name)) 
[17:36:36.189]                               next
[17:36:36.189]                             if (!grepl(pattern, name)) 
[17:36:36.189]                               next
[17:36:36.189]                             invokeRestart(restart)
[17:36:36.189]                             muffled <- TRUE
[17:36:36.189]                             break
[17:36:36.189]                           }
[17:36:36.189]                         }
[17:36:36.189]                       }
[17:36:36.189]                       invisible(muffled)
[17:36:36.189]                     }
[17:36:36.189]                     muffleCondition(cond, pattern = "^muffle")
[17:36:36.189]                   }
[17:36:36.189]                 }
[17:36:36.189]                 else {
[17:36:36.189]                   if (TRUE) {
[17:36:36.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:36.189]                     {
[17:36:36.189]                       inherits <- base::inherits
[17:36:36.189]                       invokeRestart <- base::invokeRestart
[17:36:36.189]                       is.null <- base::is.null
[17:36:36.189]                       muffled <- FALSE
[17:36:36.189]                       if (inherits(cond, "message")) {
[17:36:36.189]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:36.189]                         if (muffled) 
[17:36:36.189]                           invokeRestart("muffleMessage")
[17:36:36.189]                       }
[17:36:36.189]                       else if (inherits(cond, "warning")) {
[17:36:36.189]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:36.189]                         if (muffled) 
[17:36:36.189]                           invokeRestart("muffleWarning")
[17:36:36.189]                       }
[17:36:36.189]                       else if (inherits(cond, "condition")) {
[17:36:36.189]                         if (!is.null(pattern)) {
[17:36:36.189]                           computeRestarts <- base::computeRestarts
[17:36:36.189]                           grepl <- base::grepl
[17:36:36.189]                           restarts <- computeRestarts(cond)
[17:36:36.189]                           for (restart in restarts) {
[17:36:36.189]                             name <- restart$name
[17:36:36.189]                             if (is.null(name)) 
[17:36:36.189]                               next
[17:36:36.189]                             if (!grepl(pattern, name)) 
[17:36:36.189]                               next
[17:36:36.189]                             invokeRestart(restart)
[17:36:36.189]                             muffled <- TRUE
[17:36:36.189]                             break
[17:36:36.189]                           }
[17:36:36.189]                         }
[17:36:36.189]                       }
[17:36:36.189]                       invisible(muffled)
[17:36:36.189]                     }
[17:36:36.189]                     muffleCondition(cond, pattern = "^muffle")
[17:36:36.189]                   }
[17:36:36.189]                 }
[17:36:36.189]             }
[17:36:36.189]         }))
[17:36:36.189]     }, error = function(ex) {
[17:36:36.189]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:36.189]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:36.189]                 ...future.rng), started = ...future.startTime, 
[17:36:36.189]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:36.189]             version = "1.8"), class = "FutureResult")
[17:36:36.189]     }, finally = {
[17:36:36.189]         if (!identical(...future.workdir, getwd())) 
[17:36:36.189]             setwd(...future.workdir)
[17:36:36.189]         {
[17:36:36.189]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:36.189]                 ...future.oldOptions$nwarnings <- NULL
[17:36:36.189]             }
[17:36:36.189]             base::options(...future.oldOptions)
[17:36:36.189]             if (.Platform$OS.type == "windows") {
[17:36:36.189]                 old_names <- names(...future.oldEnvVars)
[17:36:36.189]                 envs <- base::Sys.getenv()
[17:36:36.189]                 names <- names(envs)
[17:36:36.189]                 common <- intersect(names, old_names)
[17:36:36.189]                 added <- setdiff(names, old_names)
[17:36:36.189]                 removed <- setdiff(old_names, names)
[17:36:36.189]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:36.189]                   envs[common]]
[17:36:36.189]                 NAMES <- toupper(changed)
[17:36:36.189]                 args <- list()
[17:36:36.189]                 for (kk in seq_along(NAMES)) {
[17:36:36.189]                   name <- changed[[kk]]
[17:36:36.189]                   NAME <- NAMES[[kk]]
[17:36:36.189]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:36.189]                     next
[17:36:36.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:36.189]                 }
[17:36:36.189]                 NAMES <- toupper(added)
[17:36:36.189]                 for (kk in seq_along(NAMES)) {
[17:36:36.189]                   name <- added[[kk]]
[17:36:36.189]                   NAME <- NAMES[[kk]]
[17:36:36.189]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:36.189]                     next
[17:36:36.189]                   args[[name]] <- ""
[17:36:36.189]                 }
[17:36:36.189]                 NAMES <- toupper(removed)
[17:36:36.189]                 for (kk in seq_along(NAMES)) {
[17:36:36.189]                   name <- removed[[kk]]
[17:36:36.189]                   NAME <- NAMES[[kk]]
[17:36:36.189]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:36.189]                     next
[17:36:36.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:36.189]                 }
[17:36:36.189]                 if (length(args) > 0) 
[17:36:36.189]                   base::do.call(base::Sys.setenv, args = args)
[17:36:36.189]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:36.189]             }
[17:36:36.189]             else {
[17:36:36.189]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:36.189]             }
[17:36:36.189]             {
[17:36:36.189]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:36.189]                   0L) {
[17:36:36.189]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:36.189]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:36.189]                   base::options(opts)
[17:36:36.189]                 }
[17:36:36.189]                 {
[17:36:36.189]                   {
[17:36:36.189]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:36.189]                     NULL
[17:36:36.189]                   }
[17:36:36.189]                   options(future.plan = NULL)
[17:36:36.189]                   if (is.na(NA_character_)) 
[17:36:36.189]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:36.189]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:36.189]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:36.189]                     .init = FALSE)
[17:36:36.189]                 }
[17:36:36.189]             }
[17:36:36.189]         }
[17:36:36.189]     })
[17:36:36.189]     if (TRUE) {
[17:36:36.189]         base::sink(type = "output", split = FALSE)
[17:36:36.189]         if (TRUE) {
[17:36:36.189]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:36.189]         }
[17:36:36.189]         else {
[17:36:36.189]             ...future.result["stdout"] <- base::list(NULL)
[17:36:36.189]         }
[17:36:36.189]         base::close(...future.stdout)
[17:36:36.189]         ...future.stdout <- NULL
[17:36:36.189]     }
[17:36:36.189]     ...future.result$conditions <- ...future.conditions
[17:36:36.189]     ...future.result$finished <- base::Sys.time()
[17:36:36.189]     ...future.result
[17:36:36.189] }
[17:36:36.193] assign_globals() ...
[17:36:36.193] List of 5
[17:36:36.193]  $ future.call.arguments    : list()
[17:36:36.193]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:36.193]  $ ...future.FUN            :function (x)  
[17:36:36.193]  $ ...future.elements_ii    :List of 1
[17:36:36.193]   ..$ : int [1:2] 2 4
[17:36:36.193]  $ ...future.seeds_ii       : NULL
[17:36:36.193]  $ ...future.globals.maxSize: num Inf
[17:36:36.193]  - attr(*, "resolved")= logi FALSE
[17:36:36.193]  - attr(*, "total_size")= num NA
[17:36:36.193]  - attr(*, "where")=List of 5
[17:36:36.193]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:36.193]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:36.193]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:36.193]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:36.193]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:36.193]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:36.193]  - attr(*, "already-done")= logi TRUE
[17:36:36.200] - copied ‘future.call.arguments’ to environment
[17:36:36.200] - reassign environment for ‘...future.FUN’
[17:36:36.200] - copied ‘...future.FUN’ to environment
[17:36:36.200] - copied ‘...future.elements_ii’ to environment
[17:36:36.200] - copied ‘...future.seeds_ii’ to environment
[17:36:36.200] - copied ‘...future.globals.maxSize’ to environment
[17:36:36.201] assign_globals() ... done
[17:36:36.201] requestCore(): workers = 2
[17:36:36.203] MulticoreFuture started
[17:36:36.204] - Launch lazy future ... done
[17:36:36.204] run() for ‘MulticoreFuture’ ... done
[17:36:36.204] Created future:
[17:36:36.204] plan(): Setting new future strategy stack:
[17:36:36.205] List of future strategies:
[17:36:36.205] 1. sequential:
[17:36:36.205]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:36.205]    - tweaked: FALSE
[17:36:36.205]    - call: NULL
[17:36:36.205] plan(): nbrOfWorkers() = 1
[17:36:36.208] plan(): Setting new future strategy stack:
[17:36:36.208] List of future strategies:
[17:36:36.208] 1. multicore:
[17:36:36.208]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:36.208]    - tweaked: FALSE
[17:36:36.208]    - call: plan(strategy)
[17:36:36.213] plan(): nbrOfWorkers() = 2
[17:36:36.204] MulticoreFuture:
[17:36:36.204] Label: ‘future_apply-2’
[17:36:36.204] Expression:
[17:36:36.204] {
[17:36:36.204]     do.call(function(...) {
[17:36:36.204]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:36.204]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:36.204]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:36.204]             on.exit(options(oopts), add = TRUE)
[17:36:36.204]         }
[17:36:36.204]         {
[17:36:36.204]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:36.204]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:36.204]                 ...future.FUN(...future.X_jj, ...)
[17:36:36.204]             })
[17:36:36.204]         }
[17:36:36.204]     }, args = future.call.arguments)
[17:36:36.204] }
[17:36:36.204] Lazy evaluation: FALSE
[17:36:36.204] Asynchronous evaluation: TRUE
[17:36:36.204] Local evaluation: TRUE
[17:36:36.204] Environment: R_GlobalEnv
[17:36:36.204] Capture standard output: TRUE
[17:36:36.204] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:36.204] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:36.204] Packages: <none>
[17:36:36.204] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:36.204] Resolved: TRUE
[17:36:36.204] Value: <not collected>
[17:36:36.204] Conditions captured: <none>
[17:36:36.204] Early signaling: FALSE
[17:36:36.204] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:36.204] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:36.214] Chunk #2 of 2 ... DONE
[17:36:36.214] Launching 2 futures (chunks) ... DONE
[17:36:36.214] Resolving 2 futures (chunks) ...
[17:36:36.214] resolve() on list ...
[17:36:36.214]  recursive: 0
[17:36:36.215]  length: 2
[17:36:36.215] 
[17:36:36.215] Future #1
[17:36:36.215] result() for MulticoreFuture ...
[17:36:36.216] result() for MulticoreFuture ...
[17:36:36.216] result() for MulticoreFuture ... done
[17:36:36.216] result() for MulticoreFuture ... done
[17:36:36.217] result() for MulticoreFuture ...
[17:36:36.217] result() for MulticoreFuture ... done
[17:36:36.217] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:36:36.217] - nx: 2
[17:36:36.217] - relay: TRUE
[17:36:36.217] - stdout: TRUE
[17:36:36.217] - signal: TRUE
[17:36:36.218] - resignal: FALSE
[17:36:36.218] - force: TRUE
[17:36:36.218] - relayed: [n=2] FALSE, FALSE
[17:36:36.218] - queued futures: [n=2] FALSE, FALSE
[17:36:36.218]  - until=1
[17:36:36.218]  - relaying element #1
[17:36:36.218] result() for MulticoreFuture ...
[17:36:36.219] result() for MulticoreFuture ... done
[17:36:36.219] result() for MulticoreFuture ...
[17:36:36.222] result() for MulticoreFuture ... done
[17:36:36.223] result() for MulticoreFuture ...
[17:36:36.223] result() for MulticoreFuture ... done
[17:36:36.224] result() for MulticoreFuture ...
[17:36:36.224] result() for MulticoreFuture ... done
[17:36:36.224] - relayed: [n=2] TRUE, FALSE
[17:36:36.225] - queued futures: [n=2] TRUE, FALSE
[17:36:36.225] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:36:36.225]  length: 1 (resolved future 1)
[17:36:36.226] Future #2
[17:36:36.226] result() for MulticoreFuture ...
[17:36:36.228] result() for MulticoreFuture ...
[17:36:36.228] result() for MulticoreFuture ... done
[17:36:36.228] result() for MulticoreFuture ... done
[17:36:36.229] result() for MulticoreFuture ...
[17:36:36.229] result() for MulticoreFuture ... done
[17:36:36.229] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:36:36.229] - nx: 2
[17:36:36.230] - relay: TRUE
[17:36:36.230] - stdout: TRUE
[17:36:36.230] - signal: TRUE
[17:36:36.230] - resignal: FALSE
[17:36:36.230] - force: TRUE
[17:36:36.230] - relayed: [n=2] TRUE, FALSE
[17:36:36.230] - queued futures: [n=2] TRUE, FALSE
[17:36:36.231]  - until=2
[17:36:36.231]  - relaying element #2
[17:36:36.231] result() for MulticoreFuture ...
[17:36:36.231] result() for MulticoreFuture ... done
[17:36:36.231] result() for MulticoreFuture ...
[17:36:36.231] result() for MulticoreFuture ... done
[17:36:36.231] result() for MulticoreFuture ...
[17:36:36.231] result() for MulticoreFuture ... done
[17:36:36.231] result() for MulticoreFuture ...
[17:36:36.232] result() for MulticoreFuture ... done
[17:36:36.232] - relayed: [n=2] TRUE, TRUE
[17:36:36.232] - queued futures: [n=2] TRUE, TRUE
[17:36:36.232] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:36:36.232]  length: 0 (resolved future 2)
[17:36:36.232] Relaying remaining futures
[17:36:36.232] signalConditionsASAP(NULL, pos=0) ...
[17:36:36.232] - nx: 2
[17:36:36.233] - relay: TRUE
[17:36:36.233] - stdout: TRUE
[17:36:36.233] - signal: TRUE
[17:36:36.233] - resignal: FALSE
[17:36:36.233] - force: TRUE
[17:36:36.233] - relayed: [n=2] TRUE, TRUE
[17:36:36.233] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:36.233] - relayed: [n=2] TRUE, TRUE
[17:36:36.233] - queued futures: [n=2] TRUE, TRUE
[17:36:36.234] signalConditionsASAP(NULL, pos=0) ... done
[17:36:36.234] resolve() on list ... DONE
[17:36:36.234] result() for MulticoreFuture ...
[17:36:36.234] result() for MulticoreFuture ... done
[17:36:36.234] result() for MulticoreFuture ...
[17:36:36.234] result() for MulticoreFuture ... done
[17:36:36.234] result() for MulticoreFuture ...
[17:36:36.234] result() for MulticoreFuture ... done
[17:36:36.234] result() for MulticoreFuture ...
[17:36:36.234] result() for MulticoreFuture ... done
[17:36:36.235]  - Number of value chunks collected: 2
[17:36:36.235] Resolving 2 futures (chunks) ... DONE
[17:36:36.235] Reducing values from 2 chunks ...
[17:36:36.235]  - Number of values collected after concatenation: 2
[17:36:36.235]  - Number of values expected: 2
[17:36:36.235] Reducing values from 2 chunks ... DONE
[17:36:36.235] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[17:36:36.236] getGlobalsAndPackagesXApply() ...
[17:36:36.236]  - future.globals: TRUE
[17:36:36.236] getGlobalsAndPackages() ...
[17:36:36.236] Searching for globals...
[17:36:36.239] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[17:36:36.240] Searching for globals ... DONE
[17:36:36.240] Resolving globals: FALSE
[17:36:36.240] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[17:36:36.241] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[17:36:36.241] - globals: [1] ‘FUN’
[17:36:36.241] 
[17:36:36.241] getGlobalsAndPackages() ... DONE
[17:36:36.241]  - globals found/used: [n=1] ‘FUN’
[17:36:36.241]  - needed namespaces: [n=0] 
[17:36:36.241] Finding globals ... DONE
[17:36:36.242]  - use_args: TRUE
[17:36:36.242]  - Getting '...' globals ...
[17:36:36.242] resolve() on list ...
[17:36:36.242]  recursive: 0
[17:36:36.242]  length: 1
[17:36:36.242]  elements: ‘...’
[17:36:36.242]  length: 0 (resolved future 1)
[17:36:36.243] resolve() on list ... DONE
[17:36:36.243]    - '...' content: [n=0] 
[17:36:36.243] List of 1
[17:36:36.243]  $ ...: list()
[17:36:36.243]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:36.243]  - attr(*, "where")=List of 1
[17:36:36.243]   ..$ ...:<environment: 0x556d7368cc00> 
[17:36:36.243]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:36.243]  - attr(*, "resolved")= logi TRUE
[17:36:36.243]  - attr(*, "total_size")= num NA
[17:36:36.246]  - Getting '...' globals ... DONE
[17:36:36.246] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:36.246] List of 2
[17:36:36.246]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:36:36.246]  $ ...          : list()
[17:36:36.246]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:36.246]  - attr(*, "where")=List of 2
[17:36:36.246]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:36.246]   ..$ ...          :<environment: 0x556d7368cc00> 
[17:36:36.246]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:36.246]  - attr(*, "resolved")= logi FALSE
[17:36:36.246]  - attr(*, "total_size")= num 36296
[17:36:36.249] Packages to be attached in all futures: [n=0] 
[17:36:36.249] getGlobalsAndPackagesXApply() ... DONE
[17:36:36.255] future_lapply() ...
[17:36:36.257] Generating random seeds ...
[17:36:36.257] Generating random seed streams for 2 elements ...
[17:36:36.257] Generating random seed streams for 2 elements ... DONE
[17:36:36.257] Generating random seeds ... DONE
[17:36:36.257] Will set RNG state on exit: 10407, 280570553, 1492837548, 655939326, -553310456, -1928706441, 953392828
[17:36:36.261] Number of chunks: 2
[17:36:36.261] getGlobalsAndPackagesXApply() ...
[17:36:36.261]  - future.globals: <name-value list> with names ‘list()’
[17:36:36.261]  - use_args: TRUE
[17:36:36.262] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:36.262] List of 2
[17:36:36.262]  $ ...          : list()
[17:36:36.262]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:36.262]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:36:36.262]  - attr(*, "where")=List of 2
[17:36:36.262]   ..$ ...          :<environment: 0x556d7368cc00> 
[17:36:36.262]   ..$ ...future.FUN:<environment: namespace:base> 
[17:36:36.262]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:36.262]  - attr(*, "resolved")= logi FALSE
[17:36:36.262]  - attr(*, "total_size")= num NA
[17:36:36.265] Packages to be attached in all futures: [n=0] 
[17:36:36.265] getGlobalsAndPackagesXApply() ... DONE
[17:36:36.265] Number of futures (= number of chunks): 2
[17:36:36.266] Launching 2 futures (chunks) ...
[17:36:36.266] Chunk #1 of 2 ...
[17:36:36.266]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:36.266]  - seeds: [1] <seeds>
[17:36:36.266]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:36.266] getGlobalsAndPackages() ...
[17:36:36.266] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:36.266] Resolving globals: FALSE
[17:36:36.266] Tweak future expression to call with '...' arguments ...
[17:36:36.267] {
[17:36:36.267]     do.call(function(...) {
[17:36:36.267]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:36.267]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:36.267]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:36.267]             on.exit(options(oopts), add = TRUE)
[17:36:36.267]         }
[17:36:36.267]         {
[17:36:36.267]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:36.267]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:36.267]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:36:36.267]                   envir = globalenv(), inherits = FALSE)
[17:36:36.267]                 ...future.FUN(...future.X_jj, ...)
[17:36:36.267]             })
[17:36:36.267]         }
[17:36:36.267]     }, args = future.call.arguments)
[17:36:36.267] }
[17:36:36.267] Tweak future expression to call with '...' arguments ... DONE
[17:36:36.267] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:36.267] 
[17:36:36.267] getGlobalsAndPackages() ... DONE
[17:36:36.268] run() for ‘Future’ ...
[17:36:36.268] - state: ‘created’
[17:36:36.268] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:36.272] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:36.272] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:36.272]   - Field: ‘label’
[17:36:36.272]   - Field: ‘local’
[17:36:36.272]   - Field: ‘owner’
[17:36:36.272]   - Field: ‘envir’
[17:36:36.272]   - Field: ‘workers’
[17:36:36.273]   - Field: ‘packages’
[17:36:36.273]   - Field: ‘gc’
[17:36:36.273]   - Field: ‘job’
[17:36:36.273]   - Field: ‘conditions’
[17:36:36.273]   - Field: ‘expr’
[17:36:36.273]   - Field: ‘uuid’
[17:36:36.273]   - Field: ‘seed’
[17:36:36.273]   - Field: ‘version’
[17:36:36.273]   - Field: ‘result’
[17:36:36.273]   - Field: ‘asynchronous’
[17:36:36.273]   - Field: ‘calls’
[17:36:36.274]   - Field: ‘globals’
[17:36:36.274]   - Field: ‘stdout’
[17:36:36.274]   - Field: ‘earlySignal’
[17:36:36.274]   - Field: ‘lazy’
[17:36:36.274]   - Field: ‘state’
[17:36:36.274] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:36.274] - Launch lazy future ...
[17:36:36.274] Packages needed by the future expression (n = 0): <none>
[17:36:36.275] Packages needed by future strategies (n = 0): <none>
[17:36:36.275] {
[17:36:36.275]     {
[17:36:36.275]         {
[17:36:36.275]             ...future.startTime <- base::Sys.time()
[17:36:36.275]             {
[17:36:36.275]                 {
[17:36:36.275]                   {
[17:36:36.275]                     {
[17:36:36.275]                       base::local({
[17:36:36.275]                         has_future <- base::requireNamespace("future", 
[17:36:36.275]                           quietly = TRUE)
[17:36:36.275]                         if (has_future) {
[17:36:36.275]                           ns <- base::getNamespace("future")
[17:36:36.275]                           version <- ns[[".package"]][["version"]]
[17:36:36.275]                           if (is.null(version)) 
[17:36:36.275]                             version <- utils::packageVersion("future")
[17:36:36.275]                         }
[17:36:36.275]                         else {
[17:36:36.275]                           version <- NULL
[17:36:36.275]                         }
[17:36:36.275]                         if (!has_future || version < "1.8.0") {
[17:36:36.275]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:36.275]                             "", base::R.version$version.string), 
[17:36:36.275]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:36.275]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:36.275]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:36.275]                               "release", "version")], collapse = " "), 
[17:36:36.275]                             hostname = base::Sys.info()[["nodename"]])
[17:36:36.275]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:36.275]                             info)
[17:36:36.275]                           info <- base::paste(info, collapse = "; ")
[17:36:36.275]                           if (!has_future) {
[17:36:36.275]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:36.275]                               info)
[17:36:36.275]                           }
[17:36:36.275]                           else {
[17:36:36.275]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:36.275]                               info, version)
[17:36:36.275]                           }
[17:36:36.275]                           base::stop(msg)
[17:36:36.275]                         }
[17:36:36.275]                       })
[17:36:36.275]                     }
[17:36:36.275]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:36.275]                     base::options(mc.cores = 1L)
[17:36:36.275]                   }
[17:36:36.275]                   ...future.strategy.old <- future::plan("list")
[17:36:36.275]                   options(future.plan = NULL)
[17:36:36.275]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:36.275]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:36.275]                 }
[17:36:36.275]                 ...future.workdir <- getwd()
[17:36:36.275]             }
[17:36:36.275]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:36.275]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:36.275]         }
[17:36:36.275]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:36.275]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:36.275]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:36.275]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:36.275]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:36.275]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:36.275]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:36.275]             base::names(...future.oldOptions))
[17:36:36.275]     }
[17:36:36.275]     if (FALSE) {
[17:36:36.275]     }
[17:36:36.275]     else {
[17:36:36.275]         if (TRUE) {
[17:36:36.275]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:36.275]                 open = "w")
[17:36:36.275]         }
[17:36:36.275]         else {
[17:36:36.275]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:36.275]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:36.275]         }
[17:36:36.275]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:36.275]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:36.275]             base::sink(type = "output", split = FALSE)
[17:36:36.275]             base::close(...future.stdout)
[17:36:36.275]         }, add = TRUE)
[17:36:36.275]     }
[17:36:36.275]     ...future.frame <- base::sys.nframe()
[17:36:36.275]     ...future.conditions <- base::list()
[17:36:36.275]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:36.275]     if (FALSE) {
[17:36:36.275]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:36.275]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:36.275]     }
[17:36:36.275]     ...future.result <- base::tryCatch({
[17:36:36.275]         base::withCallingHandlers({
[17:36:36.275]             ...future.value <- base::withVisible(base::local({
[17:36:36.275]                 withCallingHandlers({
[17:36:36.275]                   {
[17:36:36.275]                     do.call(function(...) {
[17:36:36.275]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:36.275]                       if (!identical(...future.globals.maxSize.org, 
[17:36:36.275]                         ...future.globals.maxSize)) {
[17:36:36.275]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:36.275]                         on.exit(options(oopts), add = TRUE)
[17:36:36.275]                       }
[17:36:36.275]                       {
[17:36:36.275]                         lapply(seq_along(...future.elements_ii), 
[17:36:36.275]                           FUN = function(jj) {
[17:36:36.275]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:36.275]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:36:36.275]                               envir = globalenv(), inherits = FALSE)
[17:36:36.275]                             ...future.FUN(...future.X_jj, ...)
[17:36:36.275]                           })
[17:36:36.275]                       }
[17:36:36.275]                     }, args = future.call.arguments)
[17:36:36.275]                   }
[17:36:36.275]                 }, immediateCondition = function(cond) {
[17:36:36.275]                   save_rds <- function (object, pathname, ...) 
[17:36:36.275]                   {
[17:36:36.275]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:36.275]                     if (file_test("-f", pathname_tmp)) {
[17:36:36.275]                       fi_tmp <- file.info(pathname_tmp)
[17:36:36.275]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:36.275]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:36.275]                         fi_tmp[["mtime"]])
[17:36:36.275]                     }
[17:36:36.275]                     tryCatch({
[17:36:36.275]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:36.275]                     }, error = function(ex) {
[17:36:36.275]                       msg <- conditionMessage(ex)
[17:36:36.275]                       fi_tmp <- file.info(pathname_tmp)
[17:36:36.275]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:36.275]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:36.275]                         fi_tmp[["mtime"]], msg)
[17:36:36.275]                       ex$message <- msg
[17:36:36.275]                       stop(ex)
[17:36:36.275]                     })
[17:36:36.275]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:36.275]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:36.275]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:36.275]                       fi_tmp <- file.info(pathname_tmp)
[17:36:36.275]                       fi <- file.info(pathname)
[17:36:36.275]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:36.275]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:36.275]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:36.275]                         fi[["size"]], fi[["mtime"]])
[17:36:36.275]                       stop(msg)
[17:36:36.275]                     }
[17:36:36.275]                     invisible(pathname)
[17:36:36.275]                   }
[17:36:36.275]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:36.275]                     rootPath = tempdir()) 
[17:36:36.275]                   {
[17:36:36.275]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:36.275]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:36.275]                       tmpdir = path, fileext = ".rds")
[17:36:36.275]                     save_rds(obj, file)
[17:36:36.275]                   }
[17:36:36.275]                   saveImmediateCondition(cond, path = "/tmp/RtmpABg8SG/.future/immediateConditions")
[17:36:36.275]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:36.275]                   {
[17:36:36.275]                     inherits <- base::inherits
[17:36:36.275]                     invokeRestart <- base::invokeRestart
[17:36:36.275]                     is.null <- base::is.null
[17:36:36.275]                     muffled <- FALSE
[17:36:36.275]                     if (inherits(cond, "message")) {
[17:36:36.275]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:36.275]                       if (muffled) 
[17:36:36.275]                         invokeRestart("muffleMessage")
[17:36:36.275]                     }
[17:36:36.275]                     else if (inherits(cond, "warning")) {
[17:36:36.275]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:36.275]                       if (muffled) 
[17:36:36.275]                         invokeRestart("muffleWarning")
[17:36:36.275]                     }
[17:36:36.275]                     else if (inherits(cond, "condition")) {
[17:36:36.275]                       if (!is.null(pattern)) {
[17:36:36.275]                         computeRestarts <- base::computeRestarts
[17:36:36.275]                         grepl <- base::grepl
[17:36:36.275]                         restarts <- computeRestarts(cond)
[17:36:36.275]                         for (restart in restarts) {
[17:36:36.275]                           name <- restart$name
[17:36:36.275]                           if (is.null(name)) 
[17:36:36.275]                             next
[17:36:36.275]                           if (!grepl(pattern, name)) 
[17:36:36.275]                             next
[17:36:36.275]                           invokeRestart(restart)
[17:36:36.275]                           muffled <- TRUE
[17:36:36.275]                           break
[17:36:36.275]                         }
[17:36:36.275]                       }
[17:36:36.275]                     }
[17:36:36.275]                     invisible(muffled)
[17:36:36.275]                   }
[17:36:36.275]                   muffleCondition(cond)
[17:36:36.275]                 })
[17:36:36.275]             }))
[17:36:36.275]             future::FutureResult(value = ...future.value$value, 
[17:36:36.275]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:36.275]                   ...future.rng), globalenv = if (FALSE) 
[17:36:36.275]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:36.275]                     ...future.globalenv.names))
[17:36:36.275]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:36.275]         }, condition = base::local({
[17:36:36.275]             c <- base::c
[17:36:36.275]             inherits <- base::inherits
[17:36:36.275]             invokeRestart <- base::invokeRestart
[17:36:36.275]             length <- base::length
[17:36:36.275]             list <- base::list
[17:36:36.275]             seq.int <- base::seq.int
[17:36:36.275]             signalCondition <- base::signalCondition
[17:36:36.275]             sys.calls <- base::sys.calls
[17:36:36.275]             `[[` <- base::`[[`
[17:36:36.275]             `+` <- base::`+`
[17:36:36.275]             `<<-` <- base::`<<-`
[17:36:36.275]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:36.275]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:36.275]                   3L)]
[17:36:36.275]             }
[17:36:36.275]             function(cond) {
[17:36:36.275]                 is_error <- inherits(cond, "error")
[17:36:36.275]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:36.275]                   NULL)
[17:36:36.275]                 if (is_error) {
[17:36:36.275]                   sessionInformation <- function() {
[17:36:36.275]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:36.275]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:36.275]                       search = base::search(), system = base::Sys.info())
[17:36:36.275]                   }
[17:36:36.275]                   ...future.conditions[[length(...future.conditions) + 
[17:36:36.275]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:36.275]                     cond$call), session = sessionInformation(), 
[17:36:36.275]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:36.275]                   signalCondition(cond)
[17:36:36.275]                 }
[17:36:36.275]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[17:36:36.275]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:36.275]                   ...future.conditions[[length(...future.conditions) + 
[17:36:36.275]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:36.275]                   if (TRUE && !signal) {
[17:36:36.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:36.275]                     {
[17:36:36.275]                       inherits <- base::inherits
[17:36:36.275]                       invokeRestart <- base::invokeRestart
[17:36:36.275]                       is.null <- base::is.null
[17:36:36.275]                       muffled <- FALSE
[17:36:36.275]                       if (inherits(cond, "message")) {
[17:36:36.275]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:36.275]                         if (muffled) 
[17:36:36.275]                           invokeRestart("muffleMessage")
[17:36:36.275]                       }
[17:36:36.275]                       else if (inherits(cond, "warning")) {
[17:36:36.275]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:36.275]                         if (muffled) 
[17:36:36.275]                           invokeRestart("muffleWarning")
[17:36:36.275]                       }
[17:36:36.275]                       else if (inherits(cond, "condition")) {
[17:36:36.275]                         if (!is.null(pattern)) {
[17:36:36.275]                           computeRestarts <- base::computeRestarts
[17:36:36.275]                           grepl <- base::grepl
[17:36:36.275]                           restarts <- computeRestarts(cond)
[17:36:36.275]                           for (restart in restarts) {
[17:36:36.275]                             name <- restart$name
[17:36:36.275]                             if (is.null(name)) 
[17:36:36.275]                               next
[17:36:36.275]                             if (!grepl(pattern, name)) 
[17:36:36.275]                               next
[17:36:36.275]                             invokeRestart(restart)
[17:36:36.275]                             muffled <- TRUE
[17:36:36.275]                             break
[17:36:36.275]                           }
[17:36:36.275]                         }
[17:36:36.275]                       }
[17:36:36.275]                       invisible(muffled)
[17:36:36.275]                     }
[17:36:36.275]                     muffleCondition(cond, pattern = "^muffle")
[17:36:36.275]                   }
[17:36:36.275]                 }
[17:36:36.275]                 else {
[17:36:36.275]                   if (TRUE) {
[17:36:36.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:36.275]                     {
[17:36:36.275]                       inherits <- base::inherits
[17:36:36.275]                       invokeRestart <- base::invokeRestart
[17:36:36.275]                       is.null <- base::is.null
[17:36:36.275]                       muffled <- FALSE
[17:36:36.275]                       if (inherits(cond, "message")) {
[17:36:36.275]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:36.275]                         if (muffled) 
[17:36:36.275]                           invokeRestart("muffleMessage")
[17:36:36.275]                       }
[17:36:36.275]                       else if (inherits(cond, "warning")) {
[17:36:36.275]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:36.275]                         if (muffled) 
[17:36:36.275]                           invokeRestart("muffleWarning")
[17:36:36.275]                       }
[17:36:36.275]                       else if (inherits(cond, "condition")) {
[17:36:36.275]                         if (!is.null(pattern)) {
[17:36:36.275]                           computeRestarts <- base::computeRestarts
[17:36:36.275]                           grepl <- base::grepl
[17:36:36.275]                           restarts <- computeRestarts(cond)
[17:36:36.275]                           for (restart in restarts) {
[17:36:36.275]                             name <- restart$name
[17:36:36.275]                             if (is.null(name)) 
[17:36:36.275]                               next
[17:36:36.275]                             if (!grepl(pattern, name)) 
[17:36:36.275]                               next
[17:36:36.275]                             invokeRestart(restart)
[17:36:36.275]                             muffled <- TRUE
[17:36:36.275]                             break
[17:36:36.275]                           }
[17:36:36.275]                         }
[17:36:36.275]                       }
[17:36:36.275]                       invisible(muffled)
[17:36:36.275]                     }
[17:36:36.275]                     muffleCondition(cond, pattern = "^muffle")
[17:36:36.275]                   }
[17:36:36.275]                 }
[17:36:36.275]             }
[17:36:36.275]         }))
[17:36:36.275]     }, error = function(ex) {
[17:36:36.275]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:36.275]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:36.275]                 ...future.rng), started = ...future.startTime, 
[17:36:36.275]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:36.275]             version = "1.8"), class = "FutureResult")
[17:36:36.275]     }, finally = {
[17:36:36.275]         if (!identical(...future.workdir, getwd())) 
[17:36:36.275]             setwd(...future.workdir)
[17:36:36.275]         {
[17:36:36.275]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:36.275]                 ...future.oldOptions$nwarnings <- NULL
[17:36:36.275]             }
[17:36:36.275]             base::options(...future.oldOptions)
[17:36:36.275]             if (.Platform$OS.type == "windows") {
[17:36:36.275]                 old_names <- names(...future.oldEnvVars)
[17:36:36.275]                 envs <- base::Sys.getenv()
[17:36:36.275]                 names <- names(envs)
[17:36:36.275]                 common <- intersect(names, old_names)
[17:36:36.275]                 added <- setdiff(names, old_names)
[17:36:36.275]                 removed <- setdiff(old_names, names)
[17:36:36.275]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:36.275]                   envs[common]]
[17:36:36.275]                 NAMES <- toupper(changed)
[17:36:36.275]                 args <- list()
[17:36:36.275]                 for (kk in seq_along(NAMES)) {
[17:36:36.275]                   name <- changed[[kk]]
[17:36:36.275]                   NAME <- NAMES[[kk]]
[17:36:36.275]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:36.275]                     next
[17:36:36.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:36.275]                 }
[17:36:36.275]                 NAMES <- toupper(added)
[17:36:36.275]                 for (kk in seq_along(NAMES)) {
[17:36:36.275]                   name <- added[[kk]]
[17:36:36.275]                   NAME <- NAMES[[kk]]
[17:36:36.275]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:36.275]                     next
[17:36:36.275]                   args[[name]] <- ""
[17:36:36.275]                 }
[17:36:36.275]                 NAMES <- toupper(removed)
[17:36:36.275]                 for (kk in seq_along(NAMES)) {
[17:36:36.275]                   name <- removed[[kk]]
[17:36:36.275]                   NAME <- NAMES[[kk]]
[17:36:36.275]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:36.275]                     next
[17:36:36.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:36.275]                 }
[17:36:36.275]                 if (length(args) > 0) 
[17:36:36.275]                   base::do.call(base::Sys.setenv, args = args)
[17:36:36.275]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:36.275]             }
[17:36:36.275]             else {
[17:36:36.275]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:36.275]             }
[17:36:36.275]             {
[17:36:36.275]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:36.275]                   0L) {
[17:36:36.275]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:36.275]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:36.275]                   base::options(opts)
[17:36:36.275]                 }
[17:36:36.275]                 {
[17:36:36.275]                   {
[17:36:36.275]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:36.275]                     NULL
[17:36:36.275]                   }
[17:36:36.275]                   options(future.plan = NULL)
[17:36:36.275]                   if (is.na(NA_character_)) 
[17:36:36.275]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:36.275]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:36.275]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:36.275]                     .init = FALSE)
[17:36:36.275]                 }
[17:36:36.275]             }
[17:36:36.275]         }
[17:36:36.275]     })
[17:36:36.275]     if (TRUE) {
[17:36:36.275]         base::sink(type = "output", split = FALSE)
[17:36:36.275]         if (TRUE) {
[17:36:36.275]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:36.275]         }
[17:36:36.275]         else {
[17:36:36.275]             ...future.result["stdout"] <- base::list(NULL)
[17:36:36.275]         }
[17:36:36.275]         base::close(...future.stdout)
[17:36:36.275]         ...future.stdout <- NULL
[17:36:36.275]     }
[17:36:36.275]     ...future.result$conditions <- ...future.conditions
[17:36:36.275]     ...future.result$finished <- base::Sys.time()
[17:36:36.275]     ...future.result
[17:36:36.275] }
[17:36:36.277] assign_globals() ...
[17:36:36.278] List of 5
[17:36:36.278]  $ future.call.arguments    : list()
[17:36:36.278]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:36.278]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[17:36:36.278]  $ ...future.elements_ii    :List of 1
[17:36:36.278]   ..$ : int [1:2] 1 3
[17:36:36.278]  $ ...future.seeds_ii       :List of 1
[17:36:36.278]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[17:36:36.278]  $ ...future.globals.maxSize: num Inf
[17:36:36.278]  - attr(*, "resolved")= logi FALSE
[17:36:36.278]  - attr(*, "total_size")= num NA
[17:36:36.278]  - attr(*, "where")=List of 5
[17:36:36.278]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:36.278]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:36.278]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:36.278]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:36.278]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:36.278]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:36.278]  - attr(*, "already-done")= logi TRUE
[17:36:36.285] - copied ‘future.call.arguments’ to environment
[17:36:36.285] - copied ‘...future.FUN’ to environment
[17:36:36.285] - copied ‘...future.elements_ii’ to environment
[17:36:36.285] - copied ‘...future.seeds_ii’ to environment
[17:36:36.285] - copied ‘...future.globals.maxSize’ to environment
[17:36:36.286] assign_globals() ... done
[17:36:36.286] requestCore(): workers = 2
[17:36:36.288] MulticoreFuture started
[17:36:36.289] - Launch lazy future ... done
[17:36:36.289] run() for ‘MulticoreFuture’ ... done
[17:36:36.289] plan(): Setting new future strategy stack:
[17:36:36.289] Created future:
[17:36:36.290] List of future strategies:
[17:36:36.290] 1. sequential:
[17:36:36.290]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:36.290]    - tweaked: FALSE
[17:36:36.290]    - call: NULL
[17:36:36.291] plan(): nbrOfWorkers() = 1
[17:36:36.293] plan(): Setting new future strategy stack:
[17:36:36.293] List of future strategies:
[17:36:36.293] 1. multicore:
[17:36:36.293]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:36.293]    - tweaked: FALSE
[17:36:36.293]    - call: plan(strategy)
[17:36:36.299] plan(): nbrOfWorkers() = 2
[17:36:36.290] MulticoreFuture:
[17:36:36.290] Label: ‘future_apply-1’
[17:36:36.290] Expression:
[17:36:36.290] {
[17:36:36.290]     do.call(function(...) {
[17:36:36.290]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:36.290]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:36.290]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:36.290]             on.exit(options(oopts), add = TRUE)
[17:36:36.290]         }
[17:36:36.290]         {
[17:36:36.290]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:36.290]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:36.290]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:36:36.290]                   envir = globalenv(), inherits = FALSE)
[17:36:36.290]                 ...future.FUN(...future.X_jj, ...)
[17:36:36.290]             })
[17:36:36.290]         }
[17:36:36.290]     }, args = future.call.arguments)
[17:36:36.290] }
[17:36:36.290] Lazy evaluation: FALSE
[17:36:36.290] Asynchronous evaluation: TRUE
[17:36:36.290] Local evaluation: TRUE
[17:36:36.290] Environment: R_GlobalEnv
[17:36:36.290] Capture standard output: TRUE
[17:36:36.290] Capture condition classes: <none>
[17:36:36.290] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:36.290] Packages: <none>
[17:36:36.290] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:36:36.290] Resolved: TRUE
[17:36:36.290] Value: <not collected>
[17:36:36.290] Conditions captured: <none>
[17:36:36.290] Early signaling: FALSE
[17:36:36.290] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:36.290] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:36.301] Chunk #1 of 2 ... DONE
[17:36:36.301] Chunk #2 of 2 ...
[17:36:36.301]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:36.301]  - seeds: [1] <seeds>
[17:36:36.302]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:36.302] getGlobalsAndPackages() ...
[17:36:36.302] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:36.302] Resolving globals: FALSE
[17:36:36.302] Tweak future expression to call with '...' arguments ...
[17:36:36.302] {
[17:36:36.302]     do.call(function(...) {
[17:36:36.302]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:36.302]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:36.302]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:36.302]             on.exit(options(oopts), add = TRUE)
[17:36:36.302]         }
[17:36:36.302]         {
[17:36:36.302]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:36.302]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:36.302]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:36:36.302]                   envir = globalenv(), inherits = FALSE)
[17:36:36.302]                 ...future.FUN(...future.X_jj, ...)
[17:36:36.302]             })
[17:36:36.302]         }
[17:36:36.302]     }, args = future.call.arguments)
[17:36:36.302] }
[17:36:36.303] Tweak future expression to call with '...' arguments ... DONE
[17:36:36.304] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:36.304] 
[17:36:36.304] getGlobalsAndPackages() ... DONE
[17:36:36.304] run() for ‘Future’ ...
[17:36:36.305] - state: ‘created’
[17:36:36.305] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:36.309] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:36.310] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:36.310]   - Field: ‘label’
[17:36:36.310]   - Field: ‘local’
[17:36:36.310]   - Field: ‘owner’
[17:36:36.310]   - Field: ‘envir’
[17:36:36.310]   - Field: ‘workers’
[17:36:36.310]   - Field: ‘packages’
[17:36:36.311]   - Field: ‘gc’
[17:36:36.311]   - Field: ‘job’
[17:36:36.311]   - Field: ‘conditions’
[17:36:36.311]   - Field: ‘expr’
[17:36:36.311]   - Field: ‘uuid’
[17:36:36.311]   - Field: ‘seed’
[17:36:36.311]   - Field: ‘version’
[17:36:36.312]   - Field: ‘result’
[17:36:36.312]   - Field: ‘asynchronous’
[17:36:36.312]   - Field: ‘calls’
[17:36:36.312]   - Field: ‘globals’
[17:36:36.312]   - Field: ‘stdout’
[17:36:36.312]   - Field: ‘earlySignal’
[17:36:36.312]   - Field: ‘lazy’
[17:36:36.313]   - Field: ‘state’
[17:36:36.313] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:36.313] - Launch lazy future ...
[17:36:36.313] Packages needed by the future expression (n = 0): <none>
[17:36:36.313] Packages needed by future strategies (n = 0): <none>
[17:36:36.314] {
[17:36:36.314]     {
[17:36:36.314]         {
[17:36:36.314]             ...future.startTime <- base::Sys.time()
[17:36:36.314]             {
[17:36:36.314]                 {
[17:36:36.314]                   {
[17:36:36.314]                     {
[17:36:36.314]                       base::local({
[17:36:36.314]                         has_future <- base::requireNamespace("future", 
[17:36:36.314]                           quietly = TRUE)
[17:36:36.314]                         if (has_future) {
[17:36:36.314]                           ns <- base::getNamespace("future")
[17:36:36.314]                           version <- ns[[".package"]][["version"]]
[17:36:36.314]                           if (is.null(version)) 
[17:36:36.314]                             version <- utils::packageVersion("future")
[17:36:36.314]                         }
[17:36:36.314]                         else {
[17:36:36.314]                           version <- NULL
[17:36:36.314]                         }
[17:36:36.314]                         if (!has_future || version < "1.8.0") {
[17:36:36.314]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:36.314]                             "", base::R.version$version.string), 
[17:36:36.314]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:36.314]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:36.314]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:36.314]                               "release", "version")], collapse = " "), 
[17:36:36.314]                             hostname = base::Sys.info()[["nodename"]])
[17:36:36.314]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:36.314]                             info)
[17:36:36.314]                           info <- base::paste(info, collapse = "; ")
[17:36:36.314]                           if (!has_future) {
[17:36:36.314]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:36.314]                               info)
[17:36:36.314]                           }
[17:36:36.314]                           else {
[17:36:36.314]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:36.314]                               info, version)
[17:36:36.314]                           }
[17:36:36.314]                           base::stop(msg)
[17:36:36.314]                         }
[17:36:36.314]                       })
[17:36:36.314]                     }
[17:36:36.314]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:36.314]                     base::options(mc.cores = 1L)
[17:36:36.314]                   }
[17:36:36.314]                   ...future.strategy.old <- future::plan("list")
[17:36:36.314]                   options(future.plan = NULL)
[17:36:36.314]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:36.314]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:36.314]                 }
[17:36:36.314]                 ...future.workdir <- getwd()
[17:36:36.314]             }
[17:36:36.314]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:36.314]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:36.314]         }
[17:36:36.314]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:36.314]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:36.314]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:36.314]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:36.314]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:36.314]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:36.314]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:36.314]             base::names(...future.oldOptions))
[17:36:36.314]     }
[17:36:36.314]     if (FALSE) {
[17:36:36.314]     }
[17:36:36.314]     else {
[17:36:36.314]         if (TRUE) {
[17:36:36.314]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:36.314]                 open = "w")
[17:36:36.314]         }
[17:36:36.314]         else {
[17:36:36.314]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:36.314]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:36.314]         }
[17:36:36.314]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:36.314]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:36.314]             base::sink(type = "output", split = FALSE)
[17:36:36.314]             base::close(...future.stdout)
[17:36:36.314]         }, add = TRUE)
[17:36:36.314]     }
[17:36:36.314]     ...future.frame <- base::sys.nframe()
[17:36:36.314]     ...future.conditions <- base::list()
[17:36:36.314]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:36.314]     if (FALSE) {
[17:36:36.314]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:36.314]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:36.314]     }
[17:36:36.314]     ...future.result <- base::tryCatch({
[17:36:36.314]         base::withCallingHandlers({
[17:36:36.314]             ...future.value <- base::withVisible(base::local({
[17:36:36.314]                 withCallingHandlers({
[17:36:36.314]                   {
[17:36:36.314]                     do.call(function(...) {
[17:36:36.314]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:36.314]                       if (!identical(...future.globals.maxSize.org, 
[17:36:36.314]                         ...future.globals.maxSize)) {
[17:36:36.314]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:36.314]                         on.exit(options(oopts), add = TRUE)
[17:36:36.314]                       }
[17:36:36.314]                       {
[17:36:36.314]                         lapply(seq_along(...future.elements_ii), 
[17:36:36.314]                           FUN = function(jj) {
[17:36:36.314]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:36.314]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:36:36.314]                               envir = globalenv(), inherits = FALSE)
[17:36:36.314]                             ...future.FUN(...future.X_jj, ...)
[17:36:36.314]                           })
[17:36:36.314]                       }
[17:36:36.314]                     }, args = future.call.arguments)
[17:36:36.314]                   }
[17:36:36.314]                 }, immediateCondition = function(cond) {
[17:36:36.314]                   save_rds <- function (object, pathname, ...) 
[17:36:36.314]                   {
[17:36:36.314]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:36.314]                     if (file_test("-f", pathname_tmp)) {
[17:36:36.314]                       fi_tmp <- file.info(pathname_tmp)
[17:36:36.314]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:36.314]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:36.314]                         fi_tmp[["mtime"]])
[17:36:36.314]                     }
[17:36:36.314]                     tryCatch({
[17:36:36.314]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:36.314]                     }, error = function(ex) {
[17:36:36.314]                       msg <- conditionMessage(ex)
[17:36:36.314]                       fi_tmp <- file.info(pathname_tmp)
[17:36:36.314]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:36.314]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:36.314]                         fi_tmp[["mtime"]], msg)
[17:36:36.314]                       ex$message <- msg
[17:36:36.314]                       stop(ex)
[17:36:36.314]                     })
[17:36:36.314]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:36.314]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:36.314]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:36.314]                       fi_tmp <- file.info(pathname_tmp)
[17:36:36.314]                       fi <- file.info(pathname)
[17:36:36.314]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:36.314]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:36.314]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:36.314]                         fi[["size"]], fi[["mtime"]])
[17:36:36.314]                       stop(msg)
[17:36:36.314]                     }
[17:36:36.314]                     invisible(pathname)
[17:36:36.314]                   }
[17:36:36.314]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:36.314]                     rootPath = tempdir()) 
[17:36:36.314]                   {
[17:36:36.314]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:36.314]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:36.314]                       tmpdir = path, fileext = ".rds")
[17:36:36.314]                     save_rds(obj, file)
[17:36:36.314]                   }
[17:36:36.314]                   saveImmediateCondition(cond, path = "/tmp/RtmpABg8SG/.future/immediateConditions")
[17:36:36.314]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:36.314]                   {
[17:36:36.314]                     inherits <- base::inherits
[17:36:36.314]                     invokeRestart <- base::invokeRestart
[17:36:36.314]                     is.null <- base::is.null
[17:36:36.314]                     muffled <- FALSE
[17:36:36.314]                     if (inherits(cond, "message")) {
[17:36:36.314]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:36.314]                       if (muffled) 
[17:36:36.314]                         invokeRestart("muffleMessage")
[17:36:36.314]                     }
[17:36:36.314]                     else if (inherits(cond, "warning")) {
[17:36:36.314]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:36.314]                       if (muffled) 
[17:36:36.314]                         invokeRestart("muffleWarning")
[17:36:36.314]                     }
[17:36:36.314]                     else if (inherits(cond, "condition")) {
[17:36:36.314]                       if (!is.null(pattern)) {
[17:36:36.314]                         computeRestarts <- base::computeRestarts
[17:36:36.314]                         grepl <- base::grepl
[17:36:36.314]                         restarts <- computeRestarts(cond)
[17:36:36.314]                         for (restart in restarts) {
[17:36:36.314]                           name <- restart$name
[17:36:36.314]                           if (is.null(name)) 
[17:36:36.314]                             next
[17:36:36.314]                           if (!grepl(pattern, name)) 
[17:36:36.314]                             next
[17:36:36.314]                           invokeRestart(restart)
[17:36:36.314]                           muffled <- TRUE
[17:36:36.314]                           break
[17:36:36.314]                         }
[17:36:36.314]                       }
[17:36:36.314]                     }
[17:36:36.314]                     invisible(muffled)
[17:36:36.314]                   }
[17:36:36.314]                   muffleCondition(cond)
[17:36:36.314]                 })
[17:36:36.314]             }))
[17:36:36.314]             future::FutureResult(value = ...future.value$value, 
[17:36:36.314]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:36.314]                   ...future.rng), globalenv = if (FALSE) 
[17:36:36.314]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:36.314]                     ...future.globalenv.names))
[17:36:36.314]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:36.314]         }, condition = base::local({
[17:36:36.314]             c <- base::c
[17:36:36.314]             inherits <- base::inherits
[17:36:36.314]             invokeRestart <- base::invokeRestart
[17:36:36.314]             length <- base::length
[17:36:36.314]             list <- base::list
[17:36:36.314]             seq.int <- base::seq.int
[17:36:36.314]             signalCondition <- base::signalCondition
[17:36:36.314]             sys.calls <- base::sys.calls
[17:36:36.314]             `[[` <- base::`[[`
[17:36:36.314]             `+` <- base::`+`
[17:36:36.314]             `<<-` <- base::`<<-`
[17:36:36.314]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:36.314]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:36.314]                   3L)]
[17:36:36.314]             }
[17:36:36.314]             function(cond) {
[17:36:36.314]                 is_error <- inherits(cond, "error")
[17:36:36.314]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:36.314]                   NULL)
[17:36:36.314]                 if (is_error) {
[17:36:36.314]                   sessionInformation <- function() {
[17:36:36.314]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:36.314]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:36.314]                       search = base::search(), system = base::Sys.info())
[17:36:36.314]                   }
[17:36:36.314]                   ...future.conditions[[length(...future.conditions) + 
[17:36:36.314]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:36.314]                     cond$call), session = sessionInformation(), 
[17:36:36.314]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:36.314]                   signalCondition(cond)
[17:36:36.314]                 }
[17:36:36.314]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[17:36:36.314]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:36.314]                   ...future.conditions[[length(...future.conditions) + 
[17:36:36.314]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:36.314]                   if (TRUE && !signal) {
[17:36:36.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:36.314]                     {
[17:36:36.314]                       inherits <- base::inherits
[17:36:36.314]                       invokeRestart <- base::invokeRestart
[17:36:36.314]                       is.null <- base::is.null
[17:36:36.314]                       muffled <- FALSE
[17:36:36.314]                       if (inherits(cond, "message")) {
[17:36:36.314]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:36.314]                         if (muffled) 
[17:36:36.314]                           invokeRestart("muffleMessage")
[17:36:36.314]                       }
[17:36:36.314]                       else if (inherits(cond, "warning")) {
[17:36:36.314]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:36.314]                         if (muffled) 
[17:36:36.314]                           invokeRestart("muffleWarning")
[17:36:36.314]                       }
[17:36:36.314]                       else if (inherits(cond, "condition")) {
[17:36:36.314]                         if (!is.null(pattern)) {
[17:36:36.314]                           computeRestarts <- base::computeRestarts
[17:36:36.314]                           grepl <- base::grepl
[17:36:36.314]                           restarts <- computeRestarts(cond)
[17:36:36.314]                           for (restart in restarts) {
[17:36:36.314]                             name <- restart$name
[17:36:36.314]                             if (is.null(name)) 
[17:36:36.314]                               next
[17:36:36.314]                             if (!grepl(pattern, name)) 
[17:36:36.314]                               next
[17:36:36.314]                             invokeRestart(restart)
[17:36:36.314]                             muffled <- TRUE
[17:36:36.314]                             break
[17:36:36.314]                           }
[17:36:36.314]                         }
[17:36:36.314]                       }
[17:36:36.314]                       invisible(muffled)
[17:36:36.314]                     }
[17:36:36.314]                     muffleCondition(cond, pattern = "^muffle")
[17:36:36.314]                   }
[17:36:36.314]                 }
[17:36:36.314]                 else {
[17:36:36.314]                   if (TRUE) {
[17:36:36.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:36.314]                     {
[17:36:36.314]                       inherits <- base::inherits
[17:36:36.314]                       invokeRestart <- base::invokeRestart
[17:36:36.314]                       is.null <- base::is.null
[17:36:36.314]                       muffled <- FALSE
[17:36:36.314]                       if (inherits(cond, "message")) {
[17:36:36.314]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:36.314]                         if (muffled) 
[17:36:36.314]                           invokeRestart("muffleMessage")
[17:36:36.314]                       }
[17:36:36.314]                       else if (inherits(cond, "warning")) {
[17:36:36.314]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:36.314]                         if (muffled) 
[17:36:36.314]                           invokeRestart("muffleWarning")
[17:36:36.314]                       }
[17:36:36.314]                       else if (inherits(cond, "condition")) {
[17:36:36.314]                         if (!is.null(pattern)) {
[17:36:36.314]                           computeRestarts <- base::computeRestarts
[17:36:36.314]                           grepl <- base::grepl
[17:36:36.314]                           restarts <- computeRestarts(cond)
[17:36:36.314]                           for (restart in restarts) {
[17:36:36.314]                             name <- restart$name
[17:36:36.314]                             if (is.null(name)) 
[17:36:36.314]                               next
[17:36:36.314]                             if (!grepl(pattern, name)) 
[17:36:36.314]                               next
[17:36:36.314]                             invokeRestart(restart)
[17:36:36.314]                             muffled <- TRUE
[17:36:36.314]                             break
[17:36:36.314]                           }
[17:36:36.314]                         }
[17:36:36.314]                       }
[17:36:36.314]                       invisible(muffled)
[17:36:36.314]                     }
[17:36:36.314]                     muffleCondition(cond, pattern = "^muffle")
[17:36:36.314]                   }
[17:36:36.314]                 }
[17:36:36.314]             }
[17:36:36.314]         }))
[17:36:36.314]     }, error = function(ex) {
[17:36:36.314]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:36.314]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:36.314]                 ...future.rng), started = ...future.startTime, 
[17:36:36.314]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:36.314]             version = "1.8"), class = "FutureResult")
[17:36:36.314]     }, finally = {
[17:36:36.314]         if (!identical(...future.workdir, getwd())) 
[17:36:36.314]             setwd(...future.workdir)
[17:36:36.314]         {
[17:36:36.314]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:36.314]                 ...future.oldOptions$nwarnings <- NULL
[17:36:36.314]             }
[17:36:36.314]             base::options(...future.oldOptions)
[17:36:36.314]             if (.Platform$OS.type == "windows") {
[17:36:36.314]                 old_names <- names(...future.oldEnvVars)
[17:36:36.314]                 envs <- base::Sys.getenv()
[17:36:36.314]                 names <- names(envs)
[17:36:36.314]                 common <- intersect(names, old_names)
[17:36:36.314]                 added <- setdiff(names, old_names)
[17:36:36.314]                 removed <- setdiff(old_names, names)
[17:36:36.314]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:36.314]                   envs[common]]
[17:36:36.314]                 NAMES <- toupper(changed)
[17:36:36.314]                 args <- list()
[17:36:36.314]                 for (kk in seq_along(NAMES)) {
[17:36:36.314]                   name <- changed[[kk]]
[17:36:36.314]                   NAME <- NAMES[[kk]]
[17:36:36.314]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:36.314]                     next
[17:36:36.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:36.314]                 }
[17:36:36.314]                 NAMES <- toupper(added)
[17:36:36.314]                 for (kk in seq_along(NAMES)) {
[17:36:36.314]                   name <- added[[kk]]
[17:36:36.314]                   NAME <- NAMES[[kk]]
[17:36:36.314]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:36.314]                     next
[17:36:36.314]                   args[[name]] <- ""
[17:36:36.314]                 }
[17:36:36.314]                 NAMES <- toupper(removed)
[17:36:36.314]                 for (kk in seq_along(NAMES)) {
[17:36:36.314]                   name <- removed[[kk]]
[17:36:36.314]                   NAME <- NAMES[[kk]]
[17:36:36.314]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:36.314]                     next
[17:36:36.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:36.314]                 }
[17:36:36.314]                 if (length(args) > 0) 
[17:36:36.314]                   base::do.call(base::Sys.setenv, args = args)
[17:36:36.314]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:36.314]             }
[17:36:36.314]             else {
[17:36:36.314]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:36.314]             }
[17:36:36.314]             {
[17:36:36.314]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:36.314]                   0L) {
[17:36:36.314]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:36.314]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:36.314]                   base::options(opts)
[17:36:36.314]                 }
[17:36:36.314]                 {
[17:36:36.314]                   {
[17:36:36.314]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:36.314]                     NULL
[17:36:36.314]                   }
[17:36:36.314]                   options(future.plan = NULL)
[17:36:36.314]                   if (is.na(NA_character_)) 
[17:36:36.314]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:36.314]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:36.314]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:36.314]                     .init = FALSE)
[17:36:36.314]                 }
[17:36:36.314]             }
[17:36:36.314]         }
[17:36:36.314]     })
[17:36:36.314]     if (TRUE) {
[17:36:36.314]         base::sink(type = "output", split = FALSE)
[17:36:36.314]         if (TRUE) {
[17:36:36.314]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:36.314]         }
[17:36:36.314]         else {
[17:36:36.314]             ...future.result["stdout"] <- base::list(NULL)
[17:36:36.314]         }
[17:36:36.314]         base::close(...future.stdout)
[17:36:36.314]         ...future.stdout <- NULL
[17:36:36.314]     }
[17:36:36.314]     ...future.result$conditions <- ...future.conditions
[17:36:36.314]     ...future.result$finished <- base::Sys.time()
[17:36:36.314]     ...future.result
[17:36:36.314] }
[17:36:36.318] assign_globals() ...
[17:36:36.318] List of 5
[17:36:36.318]  $ future.call.arguments    : list()
[17:36:36.318]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:36.318]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[17:36:36.318]  $ ...future.elements_ii    :List of 1
[17:36:36.318]   ..$ : int [1:2] 2 4
[17:36:36.318]  $ ...future.seeds_ii       :List of 1
[17:36:36.318]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[17:36:36.318]  $ ...future.globals.maxSize: num Inf
[17:36:36.318]  - attr(*, "resolved")= logi FALSE
[17:36:36.318]  - attr(*, "total_size")= num NA
[17:36:36.318]  - attr(*, "where")=List of 5
[17:36:36.318]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:36.318]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:36.318]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:36.318]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:36.318]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:36.318]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:36.318]  - attr(*, "already-done")= logi TRUE
[17:36:36.325] - copied ‘future.call.arguments’ to environment
[17:36:36.326] - copied ‘...future.FUN’ to environment
[17:36:36.326] - copied ‘...future.elements_ii’ to environment
[17:36:36.326] - copied ‘...future.seeds_ii’ to environment
[17:36:36.326] - copied ‘...future.globals.maxSize’ to environment
[17:36:36.326] assign_globals() ... done
[17:36:36.326] requestCore(): workers = 2
[17:36:36.329] MulticoreFuture started
[17:36:36.329] - Launch lazy future ... done
[17:36:36.329] run() for ‘MulticoreFuture’ ... done
[17:36:36.330] Created future:
[17:36:36.330] plan(): Setting new future strategy stack:
[17:36:36.330] List of future strategies:
[17:36:36.330] 1. sequential:
[17:36:36.330]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:36.330]    - tweaked: FALSE
[17:36:36.330]    - call: NULL
[17:36:36.331] plan(): nbrOfWorkers() = 1
[17:36:36.333] plan(): Setting new future strategy stack:
[17:36:36.333] List of future strategies:
[17:36:36.333] 1. multicore:
[17:36:36.333]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:36.333]    - tweaked: FALSE
[17:36:36.333]    - call: plan(strategy)
[17:36:36.330] MulticoreFuture:
[17:36:36.330] Label: ‘future_apply-2’
[17:36:36.330] Expression:
[17:36:36.330] {
[17:36:36.330]     do.call(function(...) {
[17:36:36.330]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:36.330]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:36.330]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:36.330]             on.exit(options(oopts), add = TRUE)
[17:36:36.330]         }
[17:36:36.330]         {
[17:36:36.330]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:36.330]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:36.330]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:36:36.330]                   envir = globalenv(), inherits = FALSE)
[17:36:36.330]                 ...future.FUN(...future.X_jj, ...)
[17:36:36.330]             })
[17:36:36.330]         }
[17:36:36.330]     }, args = future.call.arguments)
[17:36:36.330] }
[17:36:36.330] Lazy evaluation: FALSE
[17:36:36.330] Asynchronous evaluation: TRUE
[17:36:36.330] Local evaluation: TRUE
[17:36:36.330] Environment: R_GlobalEnv
[17:36:36.330] Capture standard output: TRUE
[17:36:36.330] Capture condition classes: <none>
[17:36:36.330] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:36.330] Packages: <none>
[17:36:36.330] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:36:36.330] Resolved: FALSE
[17:36:36.330] Value: <not collected>
[17:36:36.330] Conditions captured: <none>
[17:36:36.330] Early signaling: FALSE
[17:36:36.330] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:36.330] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:36.343] Chunk #2 of 2 ... DONE
[17:36:36.343] Launching 2 futures (chunks) ... DONE
[17:36:36.343] Resolving 2 futures (chunks) ...
[17:36:36.343] resolve() on list ...
[17:36:36.343]  recursive: 0
[17:36:36.343]  length: 2
[17:36:36.344] 
[17:36:36.343] plan(): nbrOfWorkers() = 2
[17:36:36.344] Future #1
[17:36:36.344] result() for MulticoreFuture ...
[17:36:36.349] result() for MulticoreFuture ...
[17:36:36.349] result() for MulticoreFuture ... done
[17:36:36.349] result() for MulticoreFuture ... done
[17:36:36.350] result() for MulticoreFuture ...
[17:36:36.350] result() for MulticoreFuture ... done
[17:36:36.350] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:36:36.351] - nx: 2
[17:36:36.351] - relay: TRUE
[17:36:36.351] - stdout: TRUE
[17:36:36.352] - signal: TRUE
[17:36:36.352] - resignal: FALSE
[17:36:36.352] - force: TRUE
[17:36:36.352] - relayed: [n=2] FALSE, FALSE
[17:36:36.353] - queued futures: [n=2] FALSE, FALSE
[17:36:36.353]  - until=1
[17:36:36.353]  - relaying element #1
[17:36:36.354] result() for MulticoreFuture ...
[17:36:36.354] result() for MulticoreFuture ... done
[17:36:36.354] result() for MulticoreFuture ...
[17:36:36.355] result() for MulticoreFuture ... done
[17:36:36.355] result() for MulticoreFuture ...
[17:36:36.355] result() for MulticoreFuture ... done
[17:36:36.355] result() for MulticoreFuture ...
[17:36:36.356] result() for MulticoreFuture ... done
[17:36:36.356] - relayed: [n=2] TRUE, FALSE
[17:36:36.356] - queued futures: [n=2] TRUE, FALSE
[17:36:36.356] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:36:36.356]  length: 1 (resolved future 1)
[17:36:36.357] Future #2
[17:36:36.357] result() for MulticoreFuture ...
[17:36:36.357] result() for MulticoreFuture ...
[17:36:36.358] result() for MulticoreFuture ... done
[17:36:36.358] result() for MulticoreFuture ... done
[17:36:36.358] result() for MulticoreFuture ...
[17:36:36.358] result() for MulticoreFuture ... done
[17:36:36.359] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:36:36.359] - nx: 2
[17:36:36.359] - relay: TRUE
[17:36:36.359] - stdout: TRUE
[17:36:36.359] - signal: TRUE
[17:36:36.359] - resignal: FALSE
[17:36:36.359] - force: TRUE
[17:36:36.359] - relayed: [n=2] TRUE, FALSE
[17:36:36.359] - queued futures: [n=2] TRUE, FALSE
[17:36:36.360]  - until=2
[17:36:36.360]  - relaying element #2
[17:36:36.360] result() for MulticoreFuture ...
[17:36:36.360] result() for MulticoreFuture ... done
[17:36:36.360] result() for MulticoreFuture ...
[17:36:36.360] result() for MulticoreFuture ... done
[17:36:36.360] result() for MulticoreFuture ...
[17:36:36.360] result() for MulticoreFuture ... done
[17:36:36.361] result() for MulticoreFuture ...
[17:36:36.361] result() for MulticoreFuture ... done
[17:36:36.361] - relayed: [n=2] TRUE, TRUE
[17:36:36.361] - queued futures: [n=2] TRUE, TRUE
[17:36:36.361] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:36:36.361]  length: 0 (resolved future 2)
[17:36:36.361] Relaying remaining futures
[17:36:36.361] signalConditionsASAP(NULL, pos=0) ...
[17:36:36.361] - nx: 2
[17:36:36.362] - relay: TRUE
[17:36:36.362] - stdout: TRUE
[17:36:36.362] - signal: TRUE
[17:36:36.362] - resignal: FALSE
[17:36:36.362] - force: TRUE
[17:36:36.362] - relayed: [n=2] TRUE, TRUE
[17:36:36.362] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:36.362] - relayed: [n=2] TRUE, TRUE
[17:36:36.362] - queued futures: [n=2] TRUE, TRUE
[17:36:36.362] signalConditionsASAP(NULL, pos=0) ... done
[17:36:36.363] resolve() on list ... DONE
[17:36:36.363] result() for MulticoreFuture ...
[17:36:36.363] result() for MulticoreFuture ... done
[17:36:36.363] result() for MulticoreFuture ...
[17:36:36.363] result() for MulticoreFuture ... done
[17:36:36.363] result() for MulticoreFuture ...
[17:36:36.363] result() for MulticoreFuture ... done
[17:36:36.363] result() for MulticoreFuture ...
[17:36:36.363] result() for MulticoreFuture ... done
[17:36:36.364]  - Number of value chunks collected: 2
[17:36:36.364] Resolving 2 futures (chunks) ... DONE
[17:36:36.364] Reducing values from 2 chunks ...
[17:36:36.364]  - Number of values collected after concatenation: 2
[17:36:36.364]  - Number of values expected: 2
[17:36:36.364] Reducing values from 2 chunks ... DONE
[17:36:36.364] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[17:36:36.365] plan(): Setting new future strategy stack:
[17:36:36.365] List of future strategies:
[17:36:36.365] 1. sequential:
[17:36:36.365]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:36.365]    - tweaked: FALSE
[17:36:36.365]    - call: plan(sequential)
[17:36:36.365] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[17:36:36.366] plan(): Setting new future strategy stack:
[17:36:36.366] List of future strategies:
[17:36:36.366] 1. multisession:
[17:36:36.366]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:36:36.366]    - tweaked: FALSE
[17:36:36.366]    - call: plan(strategy)
[17:36:36.366] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:36:36.366] multisession:
[17:36:36.366] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:36:36.366] - tweaked: FALSE
[17:36:36.366] - call: plan(strategy)
[17:36:36.373] getGlobalsAndPackages() ...
[17:36:36.373] Not searching for globals
[17:36:36.373] - globals: [0] <none>
[17:36:36.374] getGlobalsAndPackages() ... DONE
[17:36:36.374] [local output] makeClusterPSOCK() ...
[17:36:36.422] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:36:36.423] [local output] Base port: 11885
[17:36:36.423] [local output] Getting setup options for 2 cluster nodes ...
[17:36:36.423] [local output]  - Node 1 of 2 ...
[17:36:36.423] [local output] localMachine=TRUE => revtunnel=FALSE

[17:36:36.424] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpABg8SG/worker.rank=1.parallelly.parent=28372.6ed47d4f433d.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpABg8SG/worker.rank=1.parallelly.parent=28372.6ed47d4f433d.pid")'’
[17:36:36.614] - Possible to infer worker's PID: TRUE
[17:36:36.614] [local output] Rscript port: 11885

[17:36:36.615] [local output]  - Node 2 of 2 ...
[17:36:36.615] [local output] localMachine=TRUE => revtunnel=FALSE

[17:36:36.616] [local output] Rscript port: 11885

[17:36:36.616] [local output] Getting setup options for 2 cluster nodes ... done
[17:36:36.616] [local output]  - Parallel setup requested for some PSOCK nodes
[17:36:36.617] [local output] Setting up PSOCK nodes in parallel
[17:36:36.617] List of 36
[17:36:36.617]  $ worker          : chr "localhost"
[17:36:36.617]   ..- attr(*, "localhost")= logi TRUE
[17:36:36.617]  $ master          : chr "localhost"
[17:36:36.617]  $ port            : int 11885
[17:36:36.617]  $ connectTimeout  : num 120
[17:36:36.617]  $ timeout         : num 2592000
[17:36:36.617]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:36:36.617]  $ homogeneous     : logi TRUE
[17:36:36.617]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:36:36.617]  $ rscript_envs    : NULL
[17:36:36.617]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:36:36.617]  $ rscript_startup : NULL
[17:36:36.617]  $ rscript_sh      : chr "sh"
[17:36:36.617]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:36:36.617]  $ methods         : logi TRUE
[17:36:36.617]  $ socketOptions   : chr "no-delay"
[17:36:36.617]  $ useXDR          : logi FALSE
[17:36:36.617]  $ outfile         : chr "/dev/null"
[17:36:36.617]  $ renice          : int NA
[17:36:36.617]  $ rshcmd          : NULL
[17:36:36.617]  $ user            : chr(0) 
[17:36:36.617]  $ revtunnel       : logi FALSE
[17:36:36.617]  $ rshlogfile      : NULL
[17:36:36.617]  $ rshopts         : chr(0) 
[17:36:36.617]  $ rank            : int 1
[17:36:36.617]  $ manual          : logi FALSE
[17:36:36.617]  $ dryrun          : logi FALSE
[17:36:36.617]  $ quiet           : logi FALSE
[17:36:36.617]  $ setup_strategy  : chr "parallel"
[17:36:36.617]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:36:36.617]  $ pidfile         : chr "/tmp/RtmpABg8SG/worker.rank=1.parallelly.parent=28372.6ed47d4f433d.pid"
[17:36:36.617]  $ rshcmd_label    : NULL
[17:36:36.617]  $ rsh_call        : NULL
[17:36:36.617]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:36:36.617]  $ localMachine    : logi TRUE
[17:36:36.617]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:36:36.617]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:36:36.617]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:36:36.617]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:36:36.617]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:36:36.617]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:36:36.617]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:36:36.617]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:36:36.617]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:36:36.617]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:36:36.617]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:36:36.617]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:36:36.617]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:36:36.617]  $ arguments       :List of 28
[17:36:36.617]   ..$ worker          : chr "localhost"
[17:36:36.617]   ..$ master          : NULL
[17:36:36.617]   ..$ port            : int 11885
[17:36:36.617]   ..$ connectTimeout  : num 120
[17:36:36.617]   ..$ timeout         : num 2592000
[17:36:36.617]   ..$ rscript         : NULL
[17:36:36.617]   ..$ homogeneous     : NULL
[17:36:36.617]   ..$ rscript_args    : NULL
[17:36:36.617]   ..$ rscript_envs    : NULL
[17:36:36.617]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:36:36.617]   ..$ rscript_startup : NULL
[17:36:36.617]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:36:36.617]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:36:36.617]   ..$ methods         : logi TRUE
[17:36:36.617]   ..$ socketOptions   : chr "no-delay"
[17:36:36.617]   ..$ useXDR          : logi FALSE
[17:36:36.617]   ..$ outfile         : chr "/dev/null"
[17:36:36.617]   ..$ renice          : int NA
[17:36:36.617]   ..$ rshcmd          : NULL
[17:36:36.617]   ..$ user            : NULL
[17:36:36.617]   ..$ revtunnel       : logi NA
[17:36:36.617]   ..$ rshlogfile      : NULL
[17:36:36.617]   ..$ rshopts         : NULL
[17:36:36.617]   ..$ rank            : int 1
[17:36:36.617]   ..$ manual          : logi FALSE
[17:36:36.617]   ..$ dryrun          : logi FALSE
[17:36:36.617]   ..$ quiet           : logi FALSE
[17:36:36.617]   ..$ setup_strategy  : chr "parallel"
[17:36:36.617]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:36:36.633] [local output] System call to launch all workers:
[17:36:36.634] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpABg8SG/worker.rank=1.parallelly.parent=28372.6ed47d4f433d.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11885 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:36:36.634] [local output] Starting PSOCK main server
[17:36:36.640] [local output] Workers launched
[17:36:36.640] [local output] Waiting for workers to connect back
[17:36:36.640]  - [local output] 0 workers out of 2 ready
[17:36:36.885]  - [local output] 0 workers out of 2 ready
[17:36:36.885]  - [local output] 1 workers out of 2 ready
[17:36:36.885]  - [local output] 2 workers out of 2 ready
[17:36:36.885] [local output] Launching of workers completed
[17:36:36.886] [local output] Collecting session information from workers
[17:36:36.886] [local output]  - Worker #1 of 2
[17:36:36.887] [local output]  - Worker #2 of 2
[17:36:36.887] [local output] makeClusterPSOCK() ... done
[17:36:36.899] Packages needed by the future expression (n = 0): <none>
[17:36:36.899] Packages needed by future strategies (n = 0): <none>
[17:36:36.899] {
[17:36:36.899]     {
[17:36:36.899]         {
[17:36:36.899]             ...future.startTime <- base::Sys.time()
[17:36:36.899]             {
[17:36:36.899]                 {
[17:36:36.899]                   {
[17:36:36.899]                     {
[17:36:36.899]                       base::local({
[17:36:36.899]                         has_future <- base::requireNamespace("future", 
[17:36:36.899]                           quietly = TRUE)
[17:36:36.899]                         if (has_future) {
[17:36:36.899]                           ns <- base::getNamespace("future")
[17:36:36.899]                           version <- ns[[".package"]][["version"]]
[17:36:36.899]                           if (is.null(version)) 
[17:36:36.899]                             version <- utils::packageVersion("future")
[17:36:36.899]                         }
[17:36:36.899]                         else {
[17:36:36.899]                           version <- NULL
[17:36:36.899]                         }
[17:36:36.899]                         if (!has_future || version < "1.8.0") {
[17:36:36.899]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:36.899]                             "", base::R.version$version.string), 
[17:36:36.899]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:36.899]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:36.899]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:36.899]                               "release", "version")], collapse = " "), 
[17:36:36.899]                             hostname = base::Sys.info()[["nodename"]])
[17:36:36.899]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:36.899]                             info)
[17:36:36.899]                           info <- base::paste(info, collapse = "; ")
[17:36:36.899]                           if (!has_future) {
[17:36:36.899]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:36.899]                               info)
[17:36:36.899]                           }
[17:36:36.899]                           else {
[17:36:36.899]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:36.899]                               info, version)
[17:36:36.899]                           }
[17:36:36.899]                           base::stop(msg)
[17:36:36.899]                         }
[17:36:36.899]                       })
[17:36:36.899]                     }
[17:36:36.899]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:36.899]                     base::options(mc.cores = 1L)
[17:36:36.899]                   }
[17:36:36.899]                   ...future.strategy.old <- future::plan("list")
[17:36:36.899]                   options(future.plan = NULL)
[17:36:36.899]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:36.899]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:36.899]                 }
[17:36:36.899]                 ...future.workdir <- getwd()
[17:36:36.899]             }
[17:36:36.899]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:36.899]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:36.899]         }
[17:36:36.899]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:36.899]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:36.899]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:36.899]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:36.899]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:36.899]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:36.899]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:36.899]             base::names(...future.oldOptions))
[17:36:36.899]     }
[17:36:36.899]     if (FALSE) {
[17:36:36.899]     }
[17:36:36.899]     else {
[17:36:36.899]         if (TRUE) {
[17:36:36.899]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:36.899]                 open = "w")
[17:36:36.899]         }
[17:36:36.899]         else {
[17:36:36.899]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:36.899]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:36.899]         }
[17:36:36.899]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:36.899]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:36.899]             base::sink(type = "output", split = FALSE)
[17:36:36.899]             base::close(...future.stdout)
[17:36:36.899]         }, add = TRUE)
[17:36:36.899]     }
[17:36:36.899]     ...future.frame <- base::sys.nframe()
[17:36:36.899]     ...future.conditions <- base::list()
[17:36:36.899]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:36.899]     if (FALSE) {
[17:36:36.899]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:36.899]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:36.899]     }
[17:36:36.899]     ...future.result <- base::tryCatch({
[17:36:36.899]         base::withCallingHandlers({
[17:36:36.899]             ...future.value <- base::withVisible(base::local({
[17:36:36.899]                 ...future.makeSendCondition <- base::local({
[17:36:36.899]                   sendCondition <- NULL
[17:36:36.899]                   function(frame = 1L) {
[17:36:36.899]                     if (is.function(sendCondition)) 
[17:36:36.899]                       return(sendCondition)
[17:36:36.899]                     ns <- getNamespace("parallel")
[17:36:36.899]                     if (exists("sendData", mode = "function", 
[17:36:36.899]                       envir = ns)) {
[17:36:36.899]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:36.899]                         envir = ns)
[17:36:36.899]                       envir <- sys.frame(frame)
[17:36:36.899]                       master <- NULL
[17:36:36.899]                       while (!identical(envir, .GlobalEnv) && 
[17:36:36.899]                         !identical(envir, emptyenv())) {
[17:36:36.899]                         if (exists("master", mode = "list", envir = envir, 
[17:36:36.899]                           inherits = FALSE)) {
[17:36:36.899]                           master <- get("master", mode = "list", 
[17:36:36.899]                             envir = envir, inherits = FALSE)
[17:36:36.899]                           if (inherits(master, c("SOCKnode", 
[17:36:36.899]                             "SOCK0node"))) {
[17:36:36.899]                             sendCondition <<- function(cond) {
[17:36:36.899]                               data <- list(type = "VALUE", value = cond, 
[17:36:36.899]                                 success = TRUE)
[17:36:36.899]                               parallel_sendData(master, data)
[17:36:36.899]                             }
[17:36:36.899]                             return(sendCondition)
[17:36:36.899]                           }
[17:36:36.899]                         }
[17:36:36.899]                         frame <- frame + 1L
[17:36:36.899]                         envir <- sys.frame(frame)
[17:36:36.899]                       }
[17:36:36.899]                     }
[17:36:36.899]                     sendCondition <<- function(cond) NULL
[17:36:36.899]                   }
[17:36:36.899]                 })
[17:36:36.899]                 withCallingHandlers({
[17:36:36.899]                   NA
[17:36:36.899]                 }, immediateCondition = function(cond) {
[17:36:36.899]                   sendCondition <- ...future.makeSendCondition()
[17:36:36.899]                   sendCondition(cond)
[17:36:36.899]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:36.899]                   {
[17:36:36.899]                     inherits <- base::inherits
[17:36:36.899]                     invokeRestart <- base::invokeRestart
[17:36:36.899]                     is.null <- base::is.null
[17:36:36.899]                     muffled <- FALSE
[17:36:36.899]                     if (inherits(cond, "message")) {
[17:36:36.899]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:36.899]                       if (muffled) 
[17:36:36.899]                         invokeRestart("muffleMessage")
[17:36:36.899]                     }
[17:36:36.899]                     else if (inherits(cond, "warning")) {
[17:36:36.899]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:36.899]                       if (muffled) 
[17:36:36.899]                         invokeRestart("muffleWarning")
[17:36:36.899]                     }
[17:36:36.899]                     else if (inherits(cond, "condition")) {
[17:36:36.899]                       if (!is.null(pattern)) {
[17:36:36.899]                         computeRestarts <- base::computeRestarts
[17:36:36.899]                         grepl <- base::grepl
[17:36:36.899]                         restarts <- computeRestarts(cond)
[17:36:36.899]                         for (restart in restarts) {
[17:36:36.899]                           name <- restart$name
[17:36:36.899]                           if (is.null(name)) 
[17:36:36.899]                             next
[17:36:36.899]                           if (!grepl(pattern, name)) 
[17:36:36.899]                             next
[17:36:36.899]                           invokeRestart(restart)
[17:36:36.899]                           muffled <- TRUE
[17:36:36.899]                           break
[17:36:36.899]                         }
[17:36:36.899]                       }
[17:36:36.899]                     }
[17:36:36.899]                     invisible(muffled)
[17:36:36.899]                   }
[17:36:36.899]                   muffleCondition(cond)
[17:36:36.899]                 })
[17:36:36.899]             }))
[17:36:36.899]             future::FutureResult(value = ...future.value$value, 
[17:36:36.899]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:36.899]                   ...future.rng), globalenv = if (FALSE) 
[17:36:36.899]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:36.899]                     ...future.globalenv.names))
[17:36:36.899]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:36.899]         }, condition = base::local({
[17:36:36.899]             c <- base::c
[17:36:36.899]             inherits <- base::inherits
[17:36:36.899]             invokeRestart <- base::invokeRestart
[17:36:36.899]             length <- base::length
[17:36:36.899]             list <- base::list
[17:36:36.899]             seq.int <- base::seq.int
[17:36:36.899]             signalCondition <- base::signalCondition
[17:36:36.899]             sys.calls <- base::sys.calls
[17:36:36.899]             `[[` <- base::`[[`
[17:36:36.899]             `+` <- base::`+`
[17:36:36.899]             `<<-` <- base::`<<-`
[17:36:36.899]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:36.899]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:36.899]                   3L)]
[17:36:36.899]             }
[17:36:36.899]             function(cond) {
[17:36:36.899]                 is_error <- inherits(cond, "error")
[17:36:36.899]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:36.899]                   NULL)
[17:36:36.899]                 if (is_error) {
[17:36:36.899]                   sessionInformation <- function() {
[17:36:36.899]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:36.899]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:36.899]                       search = base::search(), system = base::Sys.info())
[17:36:36.899]                   }
[17:36:36.899]                   ...future.conditions[[length(...future.conditions) + 
[17:36:36.899]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:36.899]                     cond$call), session = sessionInformation(), 
[17:36:36.899]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:36.899]                   signalCondition(cond)
[17:36:36.899]                 }
[17:36:36.899]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:36.899]                 "immediateCondition"))) {
[17:36:36.899]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:36.899]                   ...future.conditions[[length(...future.conditions) + 
[17:36:36.899]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:36.899]                   if (TRUE && !signal) {
[17:36:36.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:36.899]                     {
[17:36:36.899]                       inherits <- base::inherits
[17:36:36.899]                       invokeRestart <- base::invokeRestart
[17:36:36.899]                       is.null <- base::is.null
[17:36:36.899]                       muffled <- FALSE
[17:36:36.899]                       if (inherits(cond, "message")) {
[17:36:36.899]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:36.899]                         if (muffled) 
[17:36:36.899]                           invokeRestart("muffleMessage")
[17:36:36.899]                       }
[17:36:36.899]                       else if (inherits(cond, "warning")) {
[17:36:36.899]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:36.899]                         if (muffled) 
[17:36:36.899]                           invokeRestart("muffleWarning")
[17:36:36.899]                       }
[17:36:36.899]                       else if (inherits(cond, "condition")) {
[17:36:36.899]                         if (!is.null(pattern)) {
[17:36:36.899]                           computeRestarts <- base::computeRestarts
[17:36:36.899]                           grepl <- base::grepl
[17:36:36.899]                           restarts <- computeRestarts(cond)
[17:36:36.899]                           for (restart in restarts) {
[17:36:36.899]                             name <- restart$name
[17:36:36.899]                             if (is.null(name)) 
[17:36:36.899]                               next
[17:36:36.899]                             if (!grepl(pattern, name)) 
[17:36:36.899]                               next
[17:36:36.899]                             invokeRestart(restart)
[17:36:36.899]                             muffled <- TRUE
[17:36:36.899]                             break
[17:36:36.899]                           }
[17:36:36.899]                         }
[17:36:36.899]                       }
[17:36:36.899]                       invisible(muffled)
[17:36:36.899]                     }
[17:36:36.899]                     muffleCondition(cond, pattern = "^muffle")
[17:36:36.899]                   }
[17:36:36.899]                 }
[17:36:36.899]                 else {
[17:36:36.899]                   if (TRUE) {
[17:36:36.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:36.899]                     {
[17:36:36.899]                       inherits <- base::inherits
[17:36:36.899]                       invokeRestart <- base::invokeRestart
[17:36:36.899]                       is.null <- base::is.null
[17:36:36.899]                       muffled <- FALSE
[17:36:36.899]                       if (inherits(cond, "message")) {
[17:36:36.899]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:36.899]                         if (muffled) 
[17:36:36.899]                           invokeRestart("muffleMessage")
[17:36:36.899]                       }
[17:36:36.899]                       else if (inherits(cond, "warning")) {
[17:36:36.899]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:36.899]                         if (muffled) 
[17:36:36.899]                           invokeRestart("muffleWarning")
[17:36:36.899]                       }
[17:36:36.899]                       else if (inherits(cond, "condition")) {
[17:36:36.899]                         if (!is.null(pattern)) {
[17:36:36.899]                           computeRestarts <- base::computeRestarts
[17:36:36.899]                           grepl <- base::grepl
[17:36:36.899]                           restarts <- computeRestarts(cond)
[17:36:36.899]                           for (restart in restarts) {
[17:36:36.899]                             name <- restart$name
[17:36:36.899]                             if (is.null(name)) 
[17:36:36.899]                               next
[17:36:36.899]                             if (!grepl(pattern, name)) 
[17:36:36.899]                               next
[17:36:36.899]                             invokeRestart(restart)
[17:36:36.899]                             muffled <- TRUE
[17:36:36.899]                             break
[17:36:36.899]                           }
[17:36:36.899]                         }
[17:36:36.899]                       }
[17:36:36.899]                       invisible(muffled)
[17:36:36.899]                     }
[17:36:36.899]                     muffleCondition(cond, pattern = "^muffle")
[17:36:36.899]                   }
[17:36:36.899]                 }
[17:36:36.899]             }
[17:36:36.899]         }))
[17:36:36.899]     }, error = function(ex) {
[17:36:36.899]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:36.899]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:36.899]                 ...future.rng), started = ...future.startTime, 
[17:36:36.899]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:36.899]             version = "1.8"), class = "FutureResult")
[17:36:36.899]     }, finally = {
[17:36:36.899]         if (!identical(...future.workdir, getwd())) 
[17:36:36.899]             setwd(...future.workdir)
[17:36:36.899]         {
[17:36:36.899]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:36.899]                 ...future.oldOptions$nwarnings <- NULL
[17:36:36.899]             }
[17:36:36.899]             base::options(...future.oldOptions)
[17:36:36.899]             if (.Platform$OS.type == "windows") {
[17:36:36.899]                 old_names <- names(...future.oldEnvVars)
[17:36:36.899]                 envs <- base::Sys.getenv()
[17:36:36.899]                 names <- names(envs)
[17:36:36.899]                 common <- intersect(names, old_names)
[17:36:36.899]                 added <- setdiff(names, old_names)
[17:36:36.899]                 removed <- setdiff(old_names, names)
[17:36:36.899]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:36.899]                   envs[common]]
[17:36:36.899]                 NAMES <- toupper(changed)
[17:36:36.899]                 args <- list()
[17:36:36.899]                 for (kk in seq_along(NAMES)) {
[17:36:36.899]                   name <- changed[[kk]]
[17:36:36.899]                   NAME <- NAMES[[kk]]
[17:36:36.899]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:36.899]                     next
[17:36:36.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:36.899]                 }
[17:36:36.899]                 NAMES <- toupper(added)
[17:36:36.899]                 for (kk in seq_along(NAMES)) {
[17:36:36.899]                   name <- added[[kk]]
[17:36:36.899]                   NAME <- NAMES[[kk]]
[17:36:36.899]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:36.899]                     next
[17:36:36.899]                   args[[name]] <- ""
[17:36:36.899]                 }
[17:36:36.899]                 NAMES <- toupper(removed)
[17:36:36.899]                 for (kk in seq_along(NAMES)) {
[17:36:36.899]                   name <- removed[[kk]]
[17:36:36.899]                   NAME <- NAMES[[kk]]
[17:36:36.899]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:36.899]                     next
[17:36:36.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:36.899]                 }
[17:36:36.899]                 if (length(args) > 0) 
[17:36:36.899]                   base::do.call(base::Sys.setenv, args = args)
[17:36:36.899]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:36.899]             }
[17:36:36.899]             else {
[17:36:36.899]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:36.899]             }
[17:36:36.899]             {
[17:36:36.899]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:36.899]                   0L) {
[17:36:36.899]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:36.899]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:36.899]                   base::options(opts)
[17:36:36.899]                 }
[17:36:36.899]                 {
[17:36:36.899]                   {
[17:36:36.899]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:36.899]                     NULL
[17:36:36.899]                   }
[17:36:36.899]                   options(future.plan = NULL)
[17:36:36.899]                   if (is.na(NA_character_)) 
[17:36:36.899]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:36.899]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:36.899]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:36.899]                     .init = FALSE)
[17:36:36.899]                 }
[17:36:36.899]             }
[17:36:36.899]         }
[17:36:36.899]     })
[17:36:36.899]     if (TRUE) {
[17:36:36.899]         base::sink(type = "output", split = FALSE)
[17:36:36.899]         if (TRUE) {
[17:36:36.899]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:36.899]         }
[17:36:36.899]         else {
[17:36:36.899]             ...future.result["stdout"] <- base::list(NULL)
[17:36:36.899]         }
[17:36:36.899]         base::close(...future.stdout)
[17:36:36.899]         ...future.stdout <- NULL
[17:36:36.899]     }
[17:36:36.899]     ...future.result$conditions <- ...future.conditions
[17:36:36.899]     ...future.result$finished <- base::Sys.time()
[17:36:36.899]     ...future.result
[17:36:36.899] }
[17:36:36.952] MultisessionFuture started
[17:36:36.952] result() for ClusterFuture ...
[17:36:36.953] receiveMessageFromWorker() for ClusterFuture ...
[17:36:36.953] - Validating connection of MultisessionFuture
[17:36:36.985] - received message: FutureResult
[17:36:36.985] - Received FutureResult
[17:36:36.985] - Erased future from FutureRegistry
[17:36:36.985] result() for ClusterFuture ...
[17:36:36.986] - result already collected: FutureResult
[17:36:36.986] result() for ClusterFuture ... done
[17:36:36.986] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:36.986] result() for ClusterFuture ... done
[17:36:36.986] result() for ClusterFuture ...
[17:36:36.986] - result already collected: FutureResult
[17:36:36.986] result() for ClusterFuture ... done
[17:36:36.986] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:36:36.990] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[17:36:36.991] getGlobalsAndPackagesXApply() ...
[17:36:36.991]  - future.globals: TRUE
[17:36:36.991] getGlobalsAndPackages() ...
[17:36:36.991] Searching for globals...
[17:36:37.032] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:36:37.032] Searching for globals ... DONE
[17:36:37.032] Resolving globals: FALSE
[17:36:37.036] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:36:37.036] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:36:37.036] - globals: [1] ‘FUN’
[17:36:37.037] 
[17:36:37.037] getGlobalsAndPackages() ... DONE
[17:36:37.037]  - globals found/used: [n=1] ‘FUN’
[17:36:37.037]  - needed namespaces: [n=0] 
[17:36:37.037] Finding globals ... DONE
[17:36:37.037]  - use_args: TRUE
[17:36:37.037]  - Getting '...' globals ...
[17:36:37.037] resolve() on list ...
[17:36:37.037]  recursive: 0
[17:36:37.038]  length: 1
[17:36:37.038]  elements: ‘...’
[17:36:37.038]  length: 0 (resolved future 1)
[17:36:37.038] resolve() on list ... DONE
[17:36:37.038]    - '...' content: [n=0] 
[17:36:37.038] List of 1
[17:36:37.038]  $ ...: list()
[17:36:37.038]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:37.038]  - attr(*, "where")=List of 1
[17:36:37.038]   ..$ ...:<environment: 0x556d76f05738> 
[17:36:37.038]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:37.038]  - attr(*, "resolved")= logi TRUE
[17:36:37.038]  - attr(*, "total_size")= num NA
[17:36:37.040]  - Getting '...' globals ... DONE
[17:36:37.041] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:37.041] List of 2
[17:36:37.041]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:36:37.041]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:36:37.041]  $ ...          : list()
[17:36:37.041]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:37.041]  - attr(*, "where")=List of 2
[17:36:37.041]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:37.041]   ..$ ...          :<environment: 0x556d76f05738> 
[17:36:37.041]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:37.041]  - attr(*, "resolved")= logi FALSE
[17:36:37.041]  - attr(*, "total_size")= num 354224
[17:36:37.043] Packages to be attached in all futures: [n=0] 
[17:36:37.043] getGlobalsAndPackagesXApply() ... DONE
[17:36:37.047] future_lapply() ...
[17:36:37.079] Number of chunks: 2
[17:36:37.079] getGlobalsAndPackagesXApply() ...
[17:36:37.080]  - future.globals: <name-value list> with names ‘list()’
[17:36:37.080]  - use_args: TRUE
[17:36:37.080] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:37.080] List of 2
[17:36:37.080]  $ ...          : list()
[17:36:37.080]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:37.080]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:36:37.080]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:36:37.080]  - attr(*, "where")=List of 2
[17:36:37.080]   ..$ ...          :<environment: 0x556d76f05738> 
[17:36:37.080]   ..$ ...future.FUN:<environment: namespace:base> 
[17:36:37.080]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:37.080]  - attr(*, "resolved")= logi FALSE
[17:36:37.080]  - attr(*, "total_size")= num NA
[17:36:37.083] Packages to be attached in all futures: [n=0] 
[17:36:37.083] getGlobalsAndPackagesXApply() ... DONE
[17:36:37.084] Number of futures (= number of chunks): 2
[17:36:37.084] Launching 2 futures (chunks) ...
[17:36:37.084] Chunk #1 of 2 ...
[17:36:37.084]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:37.084]  - seeds: <none>
[17:36:37.084]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.084] getGlobalsAndPackages() ...
[17:36:37.084] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.085] Resolving globals: FALSE
[17:36:37.085] Tweak future expression to call with '...' arguments ...
[17:36:37.085] {
[17:36:37.085]     do.call(function(...) {
[17:36:37.085]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.085]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:37.085]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.085]             on.exit(options(oopts), add = TRUE)
[17:36:37.085]         }
[17:36:37.085]         {
[17:36:37.085]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:37.085]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.085]                 ...future.FUN(...future.X_jj, ...)
[17:36:37.085]             })
[17:36:37.085]         }
[17:36:37.085]     }, args = future.call.arguments)
[17:36:37.085] }
[17:36:37.085] Tweak future expression to call with '...' arguments ... DONE
[17:36:37.085] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.086] 
[17:36:37.086] getGlobalsAndPackages() ... DONE
[17:36:37.086] run() for ‘Future’ ...
[17:36:37.086] - state: ‘created’
[17:36:37.086] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:37.100] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:37.100] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:37.100]   - Field: ‘node’
[17:36:37.100]   - Field: ‘label’
[17:36:37.100]   - Field: ‘local’
[17:36:37.100]   - Field: ‘owner’
[17:36:37.100]   - Field: ‘envir’
[17:36:37.101]   - Field: ‘workers’
[17:36:37.101]   - Field: ‘packages’
[17:36:37.101]   - Field: ‘gc’
[17:36:37.101]   - Field: ‘conditions’
[17:36:37.101]   - Field: ‘persistent’
[17:36:37.101]   - Field: ‘expr’
[17:36:37.101]   - Field: ‘uuid’
[17:36:37.101]   - Field: ‘seed’
[17:36:37.101]   - Field: ‘version’
[17:36:37.101]   - Field: ‘result’
[17:36:37.101]   - Field: ‘asynchronous’
[17:36:37.101]   - Field: ‘calls’
[17:36:37.102]   - Field: ‘globals’
[17:36:37.102]   - Field: ‘stdout’
[17:36:37.102]   - Field: ‘earlySignal’
[17:36:37.102]   - Field: ‘lazy’
[17:36:37.102]   - Field: ‘state’
[17:36:37.102] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:37.102] - Launch lazy future ...
[17:36:37.102] Packages needed by the future expression (n = 0): <none>
[17:36:37.102] Packages needed by future strategies (n = 0): <none>
[17:36:37.103] {
[17:36:37.103]     {
[17:36:37.103]         {
[17:36:37.103]             ...future.startTime <- base::Sys.time()
[17:36:37.103]             {
[17:36:37.103]                 {
[17:36:37.103]                   {
[17:36:37.103]                     {
[17:36:37.103]                       base::local({
[17:36:37.103]                         has_future <- base::requireNamespace("future", 
[17:36:37.103]                           quietly = TRUE)
[17:36:37.103]                         if (has_future) {
[17:36:37.103]                           ns <- base::getNamespace("future")
[17:36:37.103]                           version <- ns[[".package"]][["version"]]
[17:36:37.103]                           if (is.null(version)) 
[17:36:37.103]                             version <- utils::packageVersion("future")
[17:36:37.103]                         }
[17:36:37.103]                         else {
[17:36:37.103]                           version <- NULL
[17:36:37.103]                         }
[17:36:37.103]                         if (!has_future || version < "1.8.0") {
[17:36:37.103]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:37.103]                             "", base::R.version$version.string), 
[17:36:37.103]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:37.103]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:37.103]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:37.103]                               "release", "version")], collapse = " "), 
[17:36:37.103]                             hostname = base::Sys.info()[["nodename"]])
[17:36:37.103]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:37.103]                             info)
[17:36:37.103]                           info <- base::paste(info, collapse = "; ")
[17:36:37.103]                           if (!has_future) {
[17:36:37.103]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:37.103]                               info)
[17:36:37.103]                           }
[17:36:37.103]                           else {
[17:36:37.103]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:37.103]                               info, version)
[17:36:37.103]                           }
[17:36:37.103]                           base::stop(msg)
[17:36:37.103]                         }
[17:36:37.103]                       })
[17:36:37.103]                     }
[17:36:37.103]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:37.103]                     base::options(mc.cores = 1L)
[17:36:37.103]                   }
[17:36:37.103]                   ...future.strategy.old <- future::plan("list")
[17:36:37.103]                   options(future.plan = NULL)
[17:36:37.103]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:37.103]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:37.103]                 }
[17:36:37.103]                 ...future.workdir <- getwd()
[17:36:37.103]             }
[17:36:37.103]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:37.103]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:37.103]         }
[17:36:37.103]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:37.103]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:37.103]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:37.103]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:37.103]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:37.103]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:37.103]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:37.103]             base::names(...future.oldOptions))
[17:36:37.103]     }
[17:36:37.103]     if (FALSE) {
[17:36:37.103]     }
[17:36:37.103]     else {
[17:36:37.103]         if (TRUE) {
[17:36:37.103]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:37.103]                 open = "w")
[17:36:37.103]         }
[17:36:37.103]         else {
[17:36:37.103]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:37.103]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:37.103]         }
[17:36:37.103]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:37.103]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:37.103]             base::sink(type = "output", split = FALSE)
[17:36:37.103]             base::close(...future.stdout)
[17:36:37.103]         }, add = TRUE)
[17:36:37.103]     }
[17:36:37.103]     ...future.frame <- base::sys.nframe()
[17:36:37.103]     ...future.conditions <- base::list()
[17:36:37.103]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:37.103]     if (FALSE) {
[17:36:37.103]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:37.103]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:37.103]     }
[17:36:37.103]     ...future.result <- base::tryCatch({
[17:36:37.103]         base::withCallingHandlers({
[17:36:37.103]             ...future.value <- base::withVisible(base::local({
[17:36:37.103]                 ...future.makeSendCondition <- base::local({
[17:36:37.103]                   sendCondition <- NULL
[17:36:37.103]                   function(frame = 1L) {
[17:36:37.103]                     if (is.function(sendCondition)) 
[17:36:37.103]                       return(sendCondition)
[17:36:37.103]                     ns <- getNamespace("parallel")
[17:36:37.103]                     if (exists("sendData", mode = "function", 
[17:36:37.103]                       envir = ns)) {
[17:36:37.103]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:37.103]                         envir = ns)
[17:36:37.103]                       envir <- sys.frame(frame)
[17:36:37.103]                       master <- NULL
[17:36:37.103]                       while (!identical(envir, .GlobalEnv) && 
[17:36:37.103]                         !identical(envir, emptyenv())) {
[17:36:37.103]                         if (exists("master", mode = "list", envir = envir, 
[17:36:37.103]                           inherits = FALSE)) {
[17:36:37.103]                           master <- get("master", mode = "list", 
[17:36:37.103]                             envir = envir, inherits = FALSE)
[17:36:37.103]                           if (inherits(master, c("SOCKnode", 
[17:36:37.103]                             "SOCK0node"))) {
[17:36:37.103]                             sendCondition <<- function(cond) {
[17:36:37.103]                               data <- list(type = "VALUE", value = cond, 
[17:36:37.103]                                 success = TRUE)
[17:36:37.103]                               parallel_sendData(master, data)
[17:36:37.103]                             }
[17:36:37.103]                             return(sendCondition)
[17:36:37.103]                           }
[17:36:37.103]                         }
[17:36:37.103]                         frame <- frame + 1L
[17:36:37.103]                         envir <- sys.frame(frame)
[17:36:37.103]                       }
[17:36:37.103]                     }
[17:36:37.103]                     sendCondition <<- function(cond) NULL
[17:36:37.103]                   }
[17:36:37.103]                 })
[17:36:37.103]                 withCallingHandlers({
[17:36:37.103]                   {
[17:36:37.103]                     do.call(function(...) {
[17:36:37.103]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.103]                       if (!identical(...future.globals.maxSize.org, 
[17:36:37.103]                         ...future.globals.maxSize)) {
[17:36:37.103]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.103]                         on.exit(options(oopts), add = TRUE)
[17:36:37.103]                       }
[17:36:37.103]                       {
[17:36:37.103]                         lapply(seq_along(...future.elements_ii), 
[17:36:37.103]                           FUN = function(jj) {
[17:36:37.103]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.103]                             ...future.FUN(...future.X_jj, ...)
[17:36:37.103]                           })
[17:36:37.103]                       }
[17:36:37.103]                     }, args = future.call.arguments)
[17:36:37.103]                   }
[17:36:37.103]                 }, immediateCondition = function(cond) {
[17:36:37.103]                   sendCondition <- ...future.makeSendCondition()
[17:36:37.103]                   sendCondition(cond)
[17:36:37.103]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.103]                   {
[17:36:37.103]                     inherits <- base::inherits
[17:36:37.103]                     invokeRestart <- base::invokeRestart
[17:36:37.103]                     is.null <- base::is.null
[17:36:37.103]                     muffled <- FALSE
[17:36:37.103]                     if (inherits(cond, "message")) {
[17:36:37.103]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:37.103]                       if (muffled) 
[17:36:37.103]                         invokeRestart("muffleMessage")
[17:36:37.103]                     }
[17:36:37.103]                     else if (inherits(cond, "warning")) {
[17:36:37.103]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:37.103]                       if (muffled) 
[17:36:37.103]                         invokeRestart("muffleWarning")
[17:36:37.103]                     }
[17:36:37.103]                     else if (inherits(cond, "condition")) {
[17:36:37.103]                       if (!is.null(pattern)) {
[17:36:37.103]                         computeRestarts <- base::computeRestarts
[17:36:37.103]                         grepl <- base::grepl
[17:36:37.103]                         restarts <- computeRestarts(cond)
[17:36:37.103]                         for (restart in restarts) {
[17:36:37.103]                           name <- restart$name
[17:36:37.103]                           if (is.null(name)) 
[17:36:37.103]                             next
[17:36:37.103]                           if (!grepl(pattern, name)) 
[17:36:37.103]                             next
[17:36:37.103]                           invokeRestart(restart)
[17:36:37.103]                           muffled <- TRUE
[17:36:37.103]                           break
[17:36:37.103]                         }
[17:36:37.103]                       }
[17:36:37.103]                     }
[17:36:37.103]                     invisible(muffled)
[17:36:37.103]                   }
[17:36:37.103]                   muffleCondition(cond)
[17:36:37.103]                 })
[17:36:37.103]             }))
[17:36:37.103]             future::FutureResult(value = ...future.value$value, 
[17:36:37.103]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:37.103]                   ...future.rng), globalenv = if (FALSE) 
[17:36:37.103]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:37.103]                     ...future.globalenv.names))
[17:36:37.103]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:37.103]         }, condition = base::local({
[17:36:37.103]             c <- base::c
[17:36:37.103]             inherits <- base::inherits
[17:36:37.103]             invokeRestart <- base::invokeRestart
[17:36:37.103]             length <- base::length
[17:36:37.103]             list <- base::list
[17:36:37.103]             seq.int <- base::seq.int
[17:36:37.103]             signalCondition <- base::signalCondition
[17:36:37.103]             sys.calls <- base::sys.calls
[17:36:37.103]             `[[` <- base::`[[`
[17:36:37.103]             `+` <- base::`+`
[17:36:37.103]             `<<-` <- base::`<<-`
[17:36:37.103]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:37.103]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:37.103]                   3L)]
[17:36:37.103]             }
[17:36:37.103]             function(cond) {
[17:36:37.103]                 is_error <- inherits(cond, "error")
[17:36:37.103]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:37.103]                   NULL)
[17:36:37.103]                 if (is_error) {
[17:36:37.103]                   sessionInformation <- function() {
[17:36:37.103]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:37.103]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:37.103]                       search = base::search(), system = base::Sys.info())
[17:36:37.103]                   }
[17:36:37.103]                   ...future.conditions[[length(...future.conditions) + 
[17:36:37.103]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:37.103]                     cond$call), session = sessionInformation(), 
[17:36:37.103]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:37.103]                   signalCondition(cond)
[17:36:37.103]                 }
[17:36:37.103]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:37.103]                 "immediateCondition"))) {
[17:36:37.103]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:37.103]                   ...future.conditions[[length(...future.conditions) + 
[17:36:37.103]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:37.103]                   if (TRUE && !signal) {
[17:36:37.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.103]                     {
[17:36:37.103]                       inherits <- base::inherits
[17:36:37.103]                       invokeRestart <- base::invokeRestart
[17:36:37.103]                       is.null <- base::is.null
[17:36:37.103]                       muffled <- FALSE
[17:36:37.103]                       if (inherits(cond, "message")) {
[17:36:37.103]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:37.103]                         if (muffled) 
[17:36:37.103]                           invokeRestart("muffleMessage")
[17:36:37.103]                       }
[17:36:37.103]                       else if (inherits(cond, "warning")) {
[17:36:37.103]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:37.103]                         if (muffled) 
[17:36:37.103]                           invokeRestart("muffleWarning")
[17:36:37.103]                       }
[17:36:37.103]                       else if (inherits(cond, "condition")) {
[17:36:37.103]                         if (!is.null(pattern)) {
[17:36:37.103]                           computeRestarts <- base::computeRestarts
[17:36:37.103]                           grepl <- base::grepl
[17:36:37.103]                           restarts <- computeRestarts(cond)
[17:36:37.103]                           for (restart in restarts) {
[17:36:37.103]                             name <- restart$name
[17:36:37.103]                             if (is.null(name)) 
[17:36:37.103]                               next
[17:36:37.103]                             if (!grepl(pattern, name)) 
[17:36:37.103]                               next
[17:36:37.103]                             invokeRestart(restart)
[17:36:37.103]                             muffled <- TRUE
[17:36:37.103]                             break
[17:36:37.103]                           }
[17:36:37.103]                         }
[17:36:37.103]                       }
[17:36:37.103]                       invisible(muffled)
[17:36:37.103]                     }
[17:36:37.103]                     muffleCondition(cond, pattern = "^muffle")
[17:36:37.103]                   }
[17:36:37.103]                 }
[17:36:37.103]                 else {
[17:36:37.103]                   if (TRUE) {
[17:36:37.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.103]                     {
[17:36:37.103]                       inherits <- base::inherits
[17:36:37.103]                       invokeRestart <- base::invokeRestart
[17:36:37.103]                       is.null <- base::is.null
[17:36:37.103]                       muffled <- FALSE
[17:36:37.103]                       if (inherits(cond, "message")) {
[17:36:37.103]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:37.103]                         if (muffled) 
[17:36:37.103]                           invokeRestart("muffleMessage")
[17:36:37.103]                       }
[17:36:37.103]                       else if (inherits(cond, "warning")) {
[17:36:37.103]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:37.103]                         if (muffled) 
[17:36:37.103]                           invokeRestart("muffleWarning")
[17:36:37.103]                       }
[17:36:37.103]                       else if (inherits(cond, "condition")) {
[17:36:37.103]                         if (!is.null(pattern)) {
[17:36:37.103]                           computeRestarts <- base::computeRestarts
[17:36:37.103]                           grepl <- base::grepl
[17:36:37.103]                           restarts <- computeRestarts(cond)
[17:36:37.103]                           for (restart in restarts) {
[17:36:37.103]                             name <- restart$name
[17:36:37.103]                             if (is.null(name)) 
[17:36:37.103]                               next
[17:36:37.103]                             if (!grepl(pattern, name)) 
[17:36:37.103]                               next
[17:36:37.103]                             invokeRestart(restart)
[17:36:37.103]                             muffled <- TRUE
[17:36:37.103]                             break
[17:36:37.103]                           }
[17:36:37.103]                         }
[17:36:37.103]                       }
[17:36:37.103]                       invisible(muffled)
[17:36:37.103]                     }
[17:36:37.103]                     muffleCondition(cond, pattern = "^muffle")
[17:36:37.103]                   }
[17:36:37.103]                 }
[17:36:37.103]             }
[17:36:37.103]         }))
[17:36:37.103]     }, error = function(ex) {
[17:36:37.103]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:37.103]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:37.103]                 ...future.rng), started = ...future.startTime, 
[17:36:37.103]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:37.103]             version = "1.8"), class = "FutureResult")
[17:36:37.103]     }, finally = {
[17:36:37.103]         if (!identical(...future.workdir, getwd())) 
[17:36:37.103]             setwd(...future.workdir)
[17:36:37.103]         {
[17:36:37.103]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:37.103]                 ...future.oldOptions$nwarnings <- NULL
[17:36:37.103]             }
[17:36:37.103]             base::options(...future.oldOptions)
[17:36:37.103]             if (.Platform$OS.type == "windows") {
[17:36:37.103]                 old_names <- names(...future.oldEnvVars)
[17:36:37.103]                 envs <- base::Sys.getenv()
[17:36:37.103]                 names <- names(envs)
[17:36:37.103]                 common <- intersect(names, old_names)
[17:36:37.103]                 added <- setdiff(names, old_names)
[17:36:37.103]                 removed <- setdiff(old_names, names)
[17:36:37.103]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:37.103]                   envs[common]]
[17:36:37.103]                 NAMES <- toupper(changed)
[17:36:37.103]                 args <- list()
[17:36:37.103]                 for (kk in seq_along(NAMES)) {
[17:36:37.103]                   name <- changed[[kk]]
[17:36:37.103]                   NAME <- NAMES[[kk]]
[17:36:37.103]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.103]                     next
[17:36:37.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:37.103]                 }
[17:36:37.103]                 NAMES <- toupper(added)
[17:36:37.103]                 for (kk in seq_along(NAMES)) {
[17:36:37.103]                   name <- added[[kk]]
[17:36:37.103]                   NAME <- NAMES[[kk]]
[17:36:37.103]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.103]                     next
[17:36:37.103]                   args[[name]] <- ""
[17:36:37.103]                 }
[17:36:37.103]                 NAMES <- toupper(removed)
[17:36:37.103]                 for (kk in seq_along(NAMES)) {
[17:36:37.103]                   name <- removed[[kk]]
[17:36:37.103]                   NAME <- NAMES[[kk]]
[17:36:37.103]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.103]                     next
[17:36:37.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:37.103]                 }
[17:36:37.103]                 if (length(args) > 0) 
[17:36:37.103]                   base::do.call(base::Sys.setenv, args = args)
[17:36:37.103]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:37.103]             }
[17:36:37.103]             else {
[17:36:37.103]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:37.103]             }
[17:36:37.103]             {
[17:36:37.103]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:37.103]                   0L) {
[17:36:37.103]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:37.103]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:37.103]                   base::options(opts)
[17:36:37.103]                 }
[17:36:37.103]                 {
[17:36:37.103]                   {
[17:36:37.103]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:37.103]                     NULL
[17:36:37.103]                   }
[17:36:37.103]                   options(future.plan = NULL)
[17:36:37.103]                   if (is.na(NA_character_)) 
[17:36:37.103]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:37.103]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:37.103]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:37.103]                     .init = FALSE)
[17:36:37.103]                 }
[17:36:37.103]             }
[17:36:37.103]         }
[17:36:37.103]     })
[17:36:37.103]     if (TRUE) {
[17:36:37.103]         base::sink(type = "output", split = FALSE)
[17:36:37.103]         if (TRUE) {
[17:36:37.103]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:37.103]         }
[17:36:37.103]         else {
[17:36:37.103]             ...future.result["stdout"] <- base::list(NULL)
[17:36:37.103]         }
[17:36:37.103]         base::close(...future.stdout)
[17:36:37.103]         ...future.stdout <- NULL
[17:36:37.103]     }
[17:36:37.103]     ...future.result$conditions <- ...future.conditions
[17:36:37.103]     ...future.result$finished <- base::Sys.time()
[17:36:37.103]     ...future.result
[17:36:37.103] }
[17:36:37.106] Exporting 5 global objects (346.05 KiB) to cluster node #1 ...
[17:36:37.106] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:36:37.107] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:36:37.107] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[17:36:37.149] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[17:36:37.149] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[17:36:37.150] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[17:36:37.150] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:36:37.150] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:36:37.150] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:36:37.151] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:36:37.151] Exporting 5 global objects (346.05 KiB) to cluster node #1 ... DONE
[17:36:37.152] MultisessionFuture started
[17:36:37.152] - Launch lazy future ... done
[17:36:37.152] run() for ‘MultisessionFuture’ ... done
[17:36:37.152] Created future:
[17:36:37.152] MultisessionFuture:
[17:36:37.152] Label: ‘future_apply-1’
[17:36:37.152] Expression:
[17:36:37.152] {
[17:36:37.152]     do.call(function(...) {
[17:36:37.152]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.152]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:37.152]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.152]             on.exit(options(oopts), add = TRUE)
[17:36:37.152]         }
[17:36:37.152]         {
[17:36:37.152]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:37.152]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.152]                 ...future.FUN(...future.X_jj, ...)
[17:36:37.152]             })
[17:36:37.152]         }
[17:36:37.152]     }, args = future.call.arguments)
[17:36:37.152] }
[17:36:37.152] Lazy evaluation: FALSE
[17:36:37.152] Asynchronous evaluation: TRUE
[17:36:37.152] Local evaluation: TRUE
[17:36:37.152] Environment: R_GlobalEnv
[17:36:37.152] Capture standard output: TRUE
[17:36:37.152] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:37.152] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:37.152] Packages: <none>
[17:36:37.152] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:37.152] Resolved: FALSE
[17:36:37.152] Value: <not collected>
[17:36:37.152] Conditions captured: <none>
[17:36:37.152] Early signaling: FALSE
[17:36:37.152] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:37.152] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:37.164] Chunk #1 of 2 ... DONE
[17:36:37.164] Chunk #2 of 2 ...
[17:36:37.165]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:37.165]  - seeds: <none>
[17:36:37.165]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.165] getGlobalsAndPackages() ...
[17:36:37.165] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.165] Resolving globals: FALSE
[17:36:37.165] Tweak future expression to call with '...' arguments ...
[17:36:37.165] {
[17:36:37.165]     do.call(function(...) {
[17:36:37.165]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.165]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:37.165]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.165]             on.exit(options(oopts), add = TRUE)
[17:36:37.165]         }
[17:36:37.165]         {
[17:36:37.165]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:37.165]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.165]                 ...future.FUN(...future.X_jj, ...)
[17:36:37.165]             })
[17:36:37.165]         }
[17:36:37.165]     }, args = future.call.arguments)
[17:36:37.165] }
[17:36:37.166] Tweak future expression to call with '...' arguments ... DONE
[17:36:37.166] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.166] 
[17:36:37.166] getGlobalsAndPackages() ... DONE
[17:36:37.166] run() for ‘Future’ ...
[17:36:37.167] - state: ‘created’
[17:36:37.167] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:37.181] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:37.181] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:37.181]   - Field: ‘node’
[17:36:37.181]   - Field: ‘label’
[17:36:37.182]   - Field: ‘local’
[17:36:37.182]   - Field: ‘owner’
[17:36:37.182]   - Field: ‘envir’
[17:36:37.182]   - Field: ‘workers’
[17:36:37.182]   - Field: ‘packages’
[17:36:37.182]   - Field: ‘gc’
[17:36:37.182]   - Field: ‘conditions’
[17:36:37.182]   - Field: ‘persistent’
[17:36:37.182]   - Field: ‘expr’
[17:36:37.182]   - Field: ‘uuid’
[17:36:37.182]   - Field: ‘seed’
[17:36:37.182]   - Field: ‘version’
[17:36:37.183]   - Field: ‘result’
[17:36:37.183]   - Field: ‘asynchronous’
[17:36:37.183]   - Field: ‘calls’
[17:36:37.183]   - Field: ‘globals’
[17:36:37.183]   - Field: ‘stdout’
[17:36:37.183]   - Field: ‘earlySignal’
[17:36:37.183]   - Field: ‘lazy’
[17:36:37.183]   - Field: ‘state’
[17:36:37.183] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:37.183] - Launch lazy future ...
[17:36:37.184] Packages needed by the future expression (n = 0): <none>
[17:36:37.184] Packages needed by future strategies (n = 0): <none>
[17:36:37.186] {
[17:36:37.186]     {
[17:36:37.186]         {
[17:36:37.186]             ...future.startTime <- base::Sys.time()
[17:36:37.186]             {
[17:36:37.186]                 {
[17:36:37.186]                   {
[17:36:37.186]                     {
[17:36:37.186]                       base::local({
[17:36:37.186]                         has_future <- base::requireNamespace("future", 
[17:36:37.186]                           quietly = TRUE)
[17:36:37.186]                         if (has_future) {
[17:36:37.186]                           ns <- base::getNamespace("future")
[17:36:37.186]                           version <- ns[[".package"]][["version"]]
[17:36:37.186]                           if (is.null(version)) 
[17:36:37.186]                             version <- utils::packageVersion("future")
[17:36:37.186]                         }
[17:36:37.186]                         else {
[17:36:37.186]                           version <- NULL
[17:36:37.186]                         }
[17:36:37.186]                         if (!has_future || version < "1.8.0") {
[17:36:37.186]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:37.186]                             "", base::R.version$version.string), 
[17:36:37.186]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:37.186]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:37.186]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:37.186]                               "release", "version")], collapse = " "), 
[17:36:37.186]                             hostname = base::Sys.info()[["nodename"]])
[17:36:37.186]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:37.186]                             info)
[17:36:37.186]                           info <- base::paste(info, collapse = "; ")
[17:36:37.186]                           if (!has_future) {
[17:36:37.186]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:37.186]                               info)
[17:36:37.186]                           }
[17:36:37.186]                           else {
[17:36:37.186]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:37.186]                               info, version)
[17:36:37.186]                           }
[17:36:37.186]                           base::stop(msg)
[17:36:37.186]                         }
[17:36:37.186]                       })
[17:36:37.186]                     }
[17:36:37.186]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:37.186]                     base::options(mc.cores = 1L)
[17:36:37.186]                   }
[17:36:37.186]                   ...future.strategy.old <- future::plan("list")
[17:36:37.186]                   options(future.plan = NULL)
[17:36:37.186]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:37.186]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:37.186]                 }
[17:36:37.186]                 ...future.workdir <- getwd()
[17:36:37.186]             }
[17:36:37.186]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:37.186]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:37.186]         }
[17:36:37.186]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:37.186]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:37.186]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:37.186]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:37.186]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:37.186]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:37.186]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:37.186]             base::names(...future.oldOptions))
[17:36:37.186]     }
[17:36:37.186]     if (FALSE) {
[17:36:37.186]     }
[17:36:37.186]     else {
[17:36:37.186]         if (TRUE) {
[17:36:37.186]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:37.186]                 open = "w")
[17:36:37.186]         }
[17:36:37.186]         else {
[17:36:37.186]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:37.186]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:37.186]         }
[17:36:37.186]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:37.186]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:37.186]             base::sink(type = "output", split = FALSE)
[17:36:37.186]             base::close(...future.stdout)
[17:36:37.186]         }, add = TRUE)
[17:36:37.186]     }
[17:36:37.186]     ...future.frame <- base::sys.nframe()
[17:36:37.186]     ...future.conditions <- base::list()
[17:36:37.186]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:37.186]     if (FALSE) {
[17:36:37.186]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:37.186]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:37.186]     }
[17:36:37.186]     ...future.result <- base::tryCatch({
[17:36:37.186]         base::withCallingHandlers({
[17:36:37.186]             ...future.value <- base::withVisible(base::local({
[17:36:37.186]                 ...future.makeSendCondition <- base::local({
[17:36:37.186]                   sendCondition <- NULL
[17:36:37.186]                   function(frame = 1L) {
[17:36:37.186]                     if (is.function(sendCondition)) 
[17:36:37.186]                       return(sendCondition)
[17:36:37.186]                     ns <- getNamespace("parallel")
[17:36:37.186]                     if (exists("sendData", mode = "function", 
[17:36:37.186]                       envir = ns)) {
[17:36:37.186]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:37.186]                         envir = ns)
[17:36:37.186]                       envir <- sys.frame(frame)
[17:36:37.186]                       master <- NULL
[17:36:37.186]                       while (!identical(envir, .GlobalEnv) && 
[17:36:37.186]                         !identical(envir, emptyenv())) {
[17:36:37.186]                         if (exists("master", mode = "list", envir = envir, 
[17:36:37.186]                           inherits = FALSE)) {
[17:36:37.186]                           master <- get("master", mode = "list", 
[17:36:37.186]                             envir = envir, inherits = FALSE)
[17:36:37.186]                           if (inherits(master, c("SOCKnode", 
[17:36:37.186]                             "SOCK0node"))) {
[17:36:37.186]                             sendCondition <<- function(cond) {
[17:36:37.186]                               data <- list(type = "VALUE", value = cond, 
[17:36:37.186]                                 success = TRUE)
[17:36:37.186]                               parallel_sendData(master, data)
[17:36:37.186]                             }
[17:36:37.186]                             return(sendCondition)
[17:36:37.186]                           }
[17:36:37.186]                         }
[17:36:37.186]                         frame <- frame + 1L
[17:36:37.186]                         envir <- sys.frame(frame)
[17:36:37.186]                       }
[17:36:37.186]                     }
[17:36:37.186]                     sendCondition <<- function(cond) NULL
[17:36:37.186]                   }
[17:36:37.186]                 })
[17:36:37.186]                 withCallingHandlers({
[17:36:37.186]                   {
[17:36:37.186]                     do.call(function(...) {
[17:36:37.186]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.186]                       if (!identical(...future.globals.maxSize.org, 
[17:36:37.186]                         ...future.globals.maxSize)) {
[17:36:37.186]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.186]                         on.exit(options(oopts), add = TRUE)
[17:36:37.186]                       }
[17:36:37.186]                       {
[17:36:37.186]                         lapply(seq_along(...future.elements_ii), 
[17:36:37.186]                           FUN = function(jj) {
[17:36:37.186]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.186]                             ...future.FUN(...future.X_jj, ...)
[17:36:37.186]                           })
[17:36:37.186]                       }
[17:36:37.186]                     }, args = future.call.arguments)
[17:36:37.186]                   }
[17:36:37.186]                 }, immediateCondition = function(cond) {
[17:36:37.186]                   sendCondition <- ...future.makeSendCondition()
[17:36:37.186]                   sendCondition(cond)
[17:36:37.186]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.186]                   {
[17:36:37.186]                     inherits <- base::inherits
[17:36:37.186]                     invokeRestart <- base::invokeRestart
[17:36:37.186]                     is.null <- base::is.null
[17:36:37.186]                     muffled <- FALSE
[17:36:37.186]                     if (inherits(cond, "message")) {
[17:36:37.186]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:37.186]                       if (muffled) 
[17:36:37.186]                         invokeRestart("muffleMessage")
[17:36:37.186]                     }
[17:36:37.186]                     else if (inherits(cond, "warning")) {
[17:36:37.186]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:37.186]                       if (muffled) 
[17:36:37.186]                         invokeRestart("muffleWarning")
[17:36:37.186]                     }
[17:36:37.186]                     else if (inherits(cond, "condition")) {
[17:36:37.186]                       if (!is.null(pattern)) {
[17:36:37.186]                         computeRestarts <- base::computeRestarts
[17:36:37.186]                         grepl <- base::grepl
[17:36:37.186]                         restarts <- computeRestarts(cond)
[17:36:37.186]                         for (restart in restarts) {
[17:36:37.186]                           name <- restart$name
[17:36:37.186]                           if (is.null(name)) 
[17:36:37.186]                             next
[17:36:37.186]                           if (!grepl(pattern, name)) 
[17:36:37.186]                             next
[17:36:37.186]                           invokeRestart(restart)
[17:36:37.186]                           muffled <- TRUE
[17:36:37.186]                           break
[17:36:37.186]                         }
[17:36:37.186]                       }
[17:36:37.186]                     }
[17:36:37.186]                     invisible(muffled)
[17:36:37.186]                   }
[17:36:37.186]                   muffleCondition(cond)
[17:36:37.186]                 })
[17:36:37.186]             }))
[17:36:37.186]             future::FutureResult(value = ...future.value$value, 
[17:36:37.186]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:37.186]                   ...future.rng), globalenv = if (FALSE) 
[17:36:37.186]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:37.186]                     ...future.globalenv.names))
[17:36:37.186]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:37.186]         }, condition = base::local({
[17:36:37.186]             c <- base::c
[17:36:37.186]             inherits <- base::inherits
[17:36:37.186]             invokeRestart <- base::invokeRestart
[17:36:37.186]             length <- base::length
[17:36:37.186]             list <- base::list
[17:36:37.186]             seq.int <- base::seq.int
[17:36:37.186]             signalCondition <- base::signalCondition
[17:36:37.186]             sys.calls <- base::sys.calls
[17:36:37.186]             `[[` <- base::`[[`
[17:36:37.186]             `+` <- base::`+`
[17:36:37.186]             `<<-` <- base::`<<-`
[17:36:37.186]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:37.186]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:37.186]                   3L)]
[17:36:37.186]             }
[17:36:37.186]             function(cond) {
[17:36:37.186]                 is_error <- inherits(cond, "error")
[17:36:37.186]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:37.186]                   NULL)
[17:36:37.186]                 if (is_error) {
[17:36:37.186]                   sessionInformation <- function() {
[17:36:37.186]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:37.186]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:37.186]                       search = base::search(), system = base::Sys.info())
[17:36:37.186]                   }
[17:36:37.186]                   ...future.conditions[[length(...future.conditions) + 
[17:36:37.186]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:37.186]                     cond$call), session = sessionInformation(), 
[17:36:37.186]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:37.186]                   signalCondition(cond)
[17:36:37.186]                 }
[17:36:37.186]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:37.186]                 "immediateCondition"))) {
[17:36:37.186]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:37.186]                   ...future.conditions[[length(...future.conditions) + 
[17:36:37.186]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:37.186]                   if (TRUE && !signal) {
[17:36:37.186]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.186]                     {
[17:36:37.186]                       inherits <- base::inherits
[17:36:37.186]                       invokeRestart <- base::invokeRestart
[17:36:37.186]                       is.null <- base::is.null
[17:36:37.186]                       muffled <- FALSE
[17:36:37.186]                       if (inherits(cond, "message")) {
[17:36:37.186]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:37.186]                         if (muffled) 
[17:36:37.186]                           invokeRestart("muffleMessage")
[17:36:37.186]                       }
[17:36:37.186]                       else if (inherits(cond, "warning")) {
[17:36:37.186]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:37.186]                         if (muffled) 
[17:36:37.186]                           invokeRestart("muffleWarning")
[17:36:37.186]                       }
[17:36:37.186]                       else if (inherits(cond, "condition")) {
[17:36:37.186]                         if (!is.null(pattern)) {
[17:36:37.186]                           computeRestarts <- base::computeRestarts
[17:36:37.186]                           grepl <- base::grepl
[17:36:37.186]                           restarts <- computeRestarts(cond)
[17:36:37.186]                           for (restart in restarts) {
[17:36:37.186]                             name <- restart$name
[17:36:37.186]                             if (is.null(name)) 
[17:36:37.186]                               next
[17:36:37.186]                             if (!grepl(pattern, name)) 
[17:36:37.186]                               next
[17:36:37.186]                             invokeRestart(restart)
[17:36:37.186]                             muffled <- TRUE
[17:36:37.186]                             break
[17:36:37.186]                           }
[17:36:37.186]                         }
[17:36:37.186]                       }
[17:36:37.186]                       invisible(muffled)
[17:36:37.186]                     }
[17:36:37.186]                     muffleCondition(cond, pattern = "^muffle")
[17:36:37.186]                   }
[17:36:37.186]                 }
[17:36:37.186]                 else {
[17:36:37.186]                   if (TRUE) {
[17:36:37.186]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.186]                     {
[17:36:37.186]                       inherits <- base::inherits
[17:36:37.186]                       invokeRestart <- base::invokeRestart
[17:36:37.186]                       is.null <- base::is.null
[17:36:37.186]                       muffled <- FALSE
[17:36:37.186]                       if (inherits(cond, "message")) {
[17:36:37.186]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:37.186]                         if (muffled) 
[17:36:37.186]                           invokeRestart("muffleMessage")
[17:36:37.186]                       }
[17:36:37.186]                       else if (inherits(cond, "warning")) {
[17:36:37.186]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:37.186]                         if (muffled) 
[17:36:37.186]                           invokeRestart("muffleWarning")
[17:36:37.186]                       }
[17:36:37.186]                       else if (inherits(cond, "condition")) {
[17:36:37.186]                         if (!is.null(pattern)) {
[17:36:37.186]                           computeRestarts <- base::computeRestarts
[17:36:37.186]                           grepl <- base::grepl
[17:36:37.186]                           restarts <- computeRestarts(cond)
[17:36:37.186]                           for (restart in restarts) {
[17:36:37.186]                             name <- restart$name
[17:36:37.186]                             if (is.null(name)) 
[17:36:37.186]                               next
[17:36:37.186]                             if (!grepl(pattern, name)) 
[17:36:37.186]                               next
[17:36:37.186]                             invokeRestart(restart)
[17:36:37.186]                             muffled <- TRUE
[17:36:37.186]                             break
[17:36:37.186]                           }
[17:36:37.186]                         }
[17:36:37.186]                       }
[17:36:37.186]                       invisible(muffled)
[17:36:37.186]                     }
[17:36:37.186]                     muffleCondition(cond, pattern = "^muffle")
[17:36:37.186]                   }
[17:36:37.186]                 }
[17:36:37.186]             }
[17:36:37.186]         }))
[17:36:37.186]     }, error = function(ex) {
[17:36:37.186]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:37.186]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:37.186]                 ...future.rng), started = ...future.startTime, 
[17:36:37.186]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:37.186]             version = "1.8"), class = "FutureResult")
[17:36:37.186]     }, finally = {
[17:36:37.186]         if (!identical(...future.workdir, getwd())) 
[17:36:37.186]             setwd(...future.workdir)
[17:36:37.186]         {
[17:36:37.186]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:37.186]                 ...future.oldOptions$nwarnings <- NULL
[17:36:37.186]             }
[17:36:37.186]             base::options(...future.oldOptions)
[17:36:37.186]             if (.Platform$OS.type == "windows") {
[17:36:37.186]                 old_names <- names(...future.oldEnvVars)
[17:36:37.186]                 envs <- base::Sys.getenv()
[17:36:37.186]                 names <- names(envs)
[17:36:37.186]                 common <- intersect(names, old_names)
[17:36:37.186]                 added <- setdiff(names, old_names)
[17:36:37.186]                 removed <- setdiff(old_names, names)
[17:36:37.186]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:37.186]                   envs[common]]
[17:36:37.186]                 NAMES <- toupper(changed)
[17:36:37.186]                 args <- list()
[17:36:37.186]                 for (kk in seq_along(NAMES)) {
[17:36:37.186]                   name <- changed[[kk]]
[17:36:37.186]                   NAME <- NAMES[[kk]]
[17:36:37.186]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.186]                     next
[17:36:37.186]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:37.186]                 }
[17:36:37.186]                 NAMES <- toupper(added)
[17:36:37.186]                 for (kk in seq_along(NAMES)) {
[17:36:37.186]                   name <- added[[kk]]
[17:36:37.186]                   NAME <- NAMES[[kk]]
[17:36:37.186]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.186]                     next
[17:36:37.186]                   args[[name]] <- ""
[17:36:37.186]                 }
[17:36:37.186]                 NAMES <- toupper(removed)
[17:36:37.186]                 for (kk in seq_along(NAMES)) {
[17:36:37.186]                   name <- removed[[kk]]
[17:36:37.186]                   NAME <- NAMES[[kk]]
[17:36:37.186]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.186]                     next
[17:36:37.186]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:37.186]                 }
[17:36:37.186]                 if (length(args) > 0) 
[17:36:37.186]                   base::do.call(base::Sys.setenv, args = args)
[17:36:37.186]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:37.186]             }
[17:36:37.186]             else {
[17:36:37.186]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:37.186]             }
[17:36:37.186]             {
[17:36:37.186]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:37.186]                   0L) {
[17:36:37.186]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:37.186]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:37.186]                   base::options(opts)
[17:36:37.186]                 }
[17:36:37.186]                 {
[17:36:37.186]                   {
[17:36:37.186]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:37.186]                     NULL
[17:36:37.186]                   }
[17:36:37.186]                   options(future.plan = NULL)
[17:36:37.186]                   if (is.na(NA_character_)) 
[17:36:37.186]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:37.186]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:37.186]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:37.186]                     .init = FALSE)
[17:36:37.186]                 }
[17:36:37.186]             }
[17:36:37.186]         }
[17:36:37.186]     })
[17:36:37.186]     if (TRUE) {
[17:36:37.186]         base::sink(type = "output", split = FALSE)
[17:36:37.186]         if (TRUE) {
[17:36:37.186]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:37.186]         }
[17:36:37.186]         else {
[17:36:37.186]             ...future.result["stdout"] <- base::list(NULL)
[17:36:37.186]         }
[17:36:37.186]         base::close(...future.stdout)
[17:36:37.186]         ...future.stdout <- NULL
[17:36:37.186]     }
[17:36:37.186]     ...future.result$conditions <- ...future.conditions
[17:36:37.186]     ...future.result$finished <- base::Sys.time()
[17:36:37.186]     ...future.result
[17:36:37.186] }
[17:36:37.238] Exporting 5 global objects (346.05 KiB) to cluster node #2 ...
[17:36:37.239] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:36:37.239] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:36:37.239] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[17:36:37.281] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[17:36:37.281] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[17:36:37.281] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[17:36:37.282] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:36:37.282] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:36:37.282] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:36:37.282] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:36:37.282] Exporting 5 global objects (346.05 KiB) to cluster node #2 ... DONE
[17:36:37.283] MultisessionFuture started
[17:36:37.283] - Launch lazy future ... done
[17:36:37.283] run() for ‘MultisessionFuture’ ... done
[17:36:37.283] Created future:
[17:36:37.283] MultisessionFuture:
[17:36:37.283] Label: ‘future_apply-2’
[17:36:37.283] Expression:
[17:36:37.283] {
[17:36:37.283]     do.call(function(...) {
[17:36:37.283]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.283]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:37.283]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.283]             on.exit(options(oopts), add = TRUE)
[17:36:37.283]         }
[17:36:37.283]         {
[17:36:37.283]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:37.283]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.283]                 ...future.FUN(...future.X_jj, ...)
[17:36:37.283]             })
[17:36:37.283]         }
[17:36:37.283]     }, args = future.call.arguments)
[17:36:37.283] }
[17:36:37.283] Lazy evaluation: FALSE
[17:36:37.283] Asynchronous evaluation: TRUE
[17:36:37.283] Local evaluation: TRUE
[17:36:37.283] Environment: R_GlobalEnv
[17:36:37.283] Capture standard output: TRUE
[17:36:37.283] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:37.283] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:37.283] Packages: <none>
[17:36:37.283] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:37.283] Resolved: FALSE
[17:36:37.283] Value: <not collected>
[17:36:37.283] Conditions captured: <none>
[17:36:37.283] Early signaling: FALSE
[17:36:37.283] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:37.283] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:37.295] Chunk #2 of 2 ... DONE
[17:36:37.295] Launching 2 futures (chunks) ... DONE
[17:36:37.295] Resolving 2 futures (chunks) ...
[17:36:37.295] resolve() on list ...
[17:36:37.295]  recursive: 0
[17:36:37.296]  length: 2
[17:36:37.296] 
[17:36:37.296] receiveMessageFromWorker() for ClusterFuture ...
[17:36:37.296] - Validating connection of MultisessionFuture
[17:36:37.296] - received message: FutureResult
[17:36:37.297] - Received FutureResult
[17:36:37.297] - Erased future from FutureRegistry
[17:36:37.297] result() for ClusterFuture ...
[17:36:37.297] - result already collected: FutureResult
[17:36:37.297] result() for ClusterFuture ... done
[17:36:37.297] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:37.297] Future #1
[17:36:37.297] result() for ClusterFuture ...
[17:36:37.297] - result already collected: FutureResult
[17:36:37.297] result() for ClusterFuture ... done
[17:36:37.297] result() for ClusterFuture ...
[17:36:37.298] - result already collected: FutureResult
[17:36:37.298] result() for ClusterFuture ... done
[17:36:37.298] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:36:37.298] - nx: 2
[17:36:37.298] - relay: TRUE
[17:36:37.298] - stdout: TRUE
[17:36:37.298] - signal: TRUE
[17:36:37.298] - resignal: FALSE
[17:36:37.298] - force: TRUE
[17:36:37.298] - relayed: [n=2] FALSE, FALSE
[17:36:37.298] - queued futures: [n=2] FALSE, FALSE
[17:36:37.298]  - until=1
[17:36:37.299]  - relaying element #1
[17:36:37.299] result() for ClusterFuture ...
[17:36:37.299] - result already collected: FutureResult
[17:36:37.299] result() for ClusterFuture ... done
[17:36:37.299] result() for ClusterFuture ...
[17:36:37.299] - result already collected: FutureResult
[17:36:37.299] result() for ClusterFuture ... done
[17:36:37.299] result() for ClusterFuture ...
[17:36:37.299] - result already collected: FutureResult
[17:36:37.299] result() for ClusterFuture ... done
[17:36:37.299] result() for ClusterFuture ...
[17:36:37.299] - result already collected: FutureResult
[17:36:37.300] result() for ClusterFuture ... done
[17:36:37.300] - relayed: [n=2] TRUE, FALSE
[17:36:37.300] - queued futures: [n=2] TRUE, FALSE
[17:36:37.300] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:36:37.300]  length: 1 (resolved future 1)
[17:36:37.362] receiveMessageFromWorker() for ClusterFuture ...
[17:36:37.362] - Validating connection of MultisessionFuture
[17:36:37.362] - received message: FutureResult
[17:36:37.363] - Received FutureResult
[17:36:37.363] - Erased future from FutureRegistry
[17:36:37.363] result() for ClusterFuture ...
[17:36:37.363] - result already collected: FutureResult
[17:36:37.363] result() for ClusterFuture ... done
[17:36:37.363] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:37.363] Future #2
[17:36:37.363] result() for ClusterFuture ...
[17:36:37.363] - result already collected: FutureResult
[17:36:37.363] result() for ClusterFuture ... done
[17:36:37.363] result() for ClusterFuture ...
[17:36:37.364] - result already collected: FutureResult
[17:36:37.364] result() for ClusterFuture ... done
[17:36:37.364] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:36:37.364] - nx: 2
[17:36:37.364] - relay: TRUE
[17:36:37.364] - stdout: TRUE
[17:36:37.364] - signal: TRUE
[17:36:37.364] - resignal: FALSE
[17:36:37.364] - force: TRUE
[17:36:37.364] - relayed: [n=2] TRUE, FALSE
[17:36:37.364] - queued futures: [n=2] TRUE, FALSE
[17:36:37.364]  - until=2
[17:36:37.365]  - relaying element #2
[17:36:37.365] result() for ClusterFuture ...
[17:36:37.365] - result already collected: FutureResult
[17:36:37.365] result() for ClusterFuture ... done
[17:36:37.365] result() for ClusterFuture ...
[17:36:37.365] - result already collected: FutureResult
[17:36:37.365] result() for ClusterFuture ... done
[17:36:37.365] result() for ClusterFuture ...
[17:36:37.365] - result already collected: FutureResult
[17:36:37.365] result() for ClusterFuture ... done
[17:36:37.365] result() for ClusterFuture ...
[17:36:37.366] - result already collected: FutureResult
[17:36:37.366] result() for ClusterFuture ... done
[17:36:37.366] - relayed: [n=2] TRUE, TRUE
[17:36:37.366] - queued futures: [n=2] TRUE, TRUE
[17:36:37.366] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:36:37.366]  length: 0 (resolved future 2)
[17:36:37.366] Relaying remaining futures
[17:36:37.366] signalConditionsASAP(NULL, pos=0) ...
[17:36:37.366] - nx: 2
[17:36:37.366] - relay: TRUE
[17:36:37.366] - stdout: TRUE
[17:36:37.366] - signal: TRUE
[17:36:37.367] - resignal: FALSE
[17:36:37.367] - force: TRUE
[17:36:37.367] - relayed: [n=2] TRUE, TRUE
[17:36:37.367] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:37.367] - relayed: [n=2] TRUE, TRUE
[17:36:37.367] - queued futures: [n=2] TRUE, TRUE
[17:36:37.367] signalConditionsASAP(NULL, pos=0) ... done
[17:36:37.367] resolve() on list ... DONE
[17:36:37.367] result() for ClusterFuture ...
[17:36:37.367] - result already collected: FutureResult
[17:36:37.367] result() for ClusterFuture ... done
[17:36:37.368] result() for ClusterFuture ...
[17:36:37.368] - result already collected: FutureResult
[17:36:37.368] result() for ClusterFuture ... done
[17:36:37.368] result() for ClusterFuture ...
[17:36:37.368] - result already collected: FutureResult
[17:36:37.368] result() for ClusterFuture ... done
[17:36:37.368] result() for ClusterFuture ...
[17:36:37.368] - result already collected: FutureResult
[17:36:37.368] result() for ClusterFuture ... done
[17:36:37.368]  - Number of value chunks collected: 2
[17:36:37.368] Resolving 2 futures (chunks) ... DONE
[17:36:37.368] Reducing values from 2 chunks ...
[17:36:37.369]  - Number of values collected after concatenation: 2
[17:36:37.369]  - Number of values expected: 2
[17:36:37.369] Reducing values from 2 chunks ... DONE
[17:36:37.369] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:36:37.369] getGlobalsAndPackagesXApply() ...
[17:36:37.369]  - future.globals: TRUE
[17:36:37.369] getGlobalsAndPackages() ...
[17:36:37.370] Searching for globals...
[17:36:37.400] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:36:37.400] Searching for globals ... DONE
[17:36:37.400] Resolving globals: FALSE
[17:36:37.402] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:36:37.402] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:36:37.402] - globals: [1] ‘FUN’
[17:36:37.402] 
[17:36:37.403] getGlobalsAndPackages() ... DONE
[17:36:37.403]  - globals found/used: [n=1] ‘FUN’
[17:36:37.403]  - needed namespaces: [n=0] 
[17:36:37.403] Finding globals ... DONE
[17:36:37.403]  - use_args: TRUE
[17:36:37.403]  - Getting '...' globals ...
[17:36:37.403] resolve() on list ...
[17:36:37.403]  recursive: 0
[17:36:37.403]  length: 1
[17:36:37.404]  elements: ‘...’
[17:36:37.404]  length: 0 (resolved future 1)
[17:36:37.404] resolve() on list ... DONE
[17:36:37.404]    - '...' content: [n=0] 
[17:36:37.404] List of 1
[17:36:37.404]  $ ...: list()
[17:36:37.404]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:37.404]  - attr(*, "where")=List of 1
[17:36:37.404]   ..$ ...:<environment: 0x556d7376a4c8> 
[17:36:37.404]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:37.404]  - attr(*, "resolved")= logi TRUE
[17:36:37.404]  - attr(*, "total_size")= num NA
[17:36:37.406]  - Getting '...' globals ... DONE
[17:36:37.407] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:37.407] List of 2
[17:36:37.407]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:36:37.407]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:36:37.407]  $ ...          : list()
[17:36:37.407]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:37.407]  - attr(*, "where")=List of 2
[17:36:37.407]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:37.407]   ..$ ...          :<environment: 0x556d7376a4c8> 
[17:36:37.407]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:37.407]  - attr(*, "resolved")= logi FALSE
[17:36:37.407]  - attr(*, "total_size")= num 354224
[17:36:37.409] Packages to be attached in all futures: [n=0] 
[17:36:37.409] getGlobalsAndPackagesXApply() ... DONE
[17:36:37.413] future_lapply() ...
[17:36:37.451] Number of chunks: 2
[17:36:37.451] getGlobalsAndPackagesXApply() ...
[17:36:37.451]  - future.globals: <name-value list> with names ‘list()’
[17:36:37.451]  - use_args: TRUE
[17:36:37.451] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:37.451] List of 2
[17:36:37.451]  $ ...          : list()
[17:36:37.451]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:37.451]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:36:37.451]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:36:37.451]  - attr(*, "where")=List of 2
[17:36:37.451]   ..$ ...          :<environment: 0x556d7376a4c8> 
[17:36:37.451]   ..$ ...future.FUN:<environment: namespace:base> 
[17:36:37.451]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:37.451]  - attr(*, "resolved")= logi FALSE
[17:36:37.451]  - attr(*, "total_size")= num NA
[17:36:37.455] Packages to be attached in all futures: [n=0] 
[17:36:37.455] getGlobalsAndPackagesXApply() ... DONE
[17:36:37.455] Number of futures (= number of chunks): 2
[17:36:37.455] Launching 2 futures (chunks) ...
[17:36:37.455] Chunk #1 of 2 ...
[17:36:37.456]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:37.456]  - seeds: <none>
[17:36:37.456]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.456] getGlobalsAndPackages() ...
[17:36:37.456] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.456] Resolving globals: FALSE
[17:36:37.456] Tweak future expression to call with '...' arguments ...
[17:36:37.456] {
[17:36:37.456]     do.call(function(...) {
[17:36:37.456]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.456]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:37.456]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.456]             on.exit(options(oopts), add = TRUE)
[17:36:37.456]         }
[17:36:37.456]         {
[17:36:37.456]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:37.456]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.456]                 ...future.FUN(...future.X_jj, ...)
[17:36:37.456]             })
[17:36:37.456]         }
[17:36:37.456]     }, args = future.call.arguments)
[17:36:37.456] }
[17:36:37.457] Tweak future expression to call with '...' arguments ... DONE
[17:36:37.457] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.457] 
[17:36:37.457] getGlobalsAndPackages() ... DONE
[17:36:37.457] run() for ‘Future’ ...
[17:36:37.458] - state: ‘created’
[17:36:37.458] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:37.472] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:37.472] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:37.472]   - Field: ‘node’
[17:36:37.472]   - Field: ‘label’
[17:36:37.472]   - Field: ‘local’
[17:36:37.472]   - Field: ‘owner’
[17:36:37.472]   - Field: ‘envir’
[17:36:37.472]   - Field: ‘workers’
[17:36:37.473]   - Field: ‘packages’
[17:36:37.473]   - Field: ‘gc’
[17:36:37.473]   - Field: ‘conditions’
[17:36:37.473]   - Field: ‘persistent’
[17:36:37.473]   - Field: ‘expr’
[17:36:37.473]   - Field: ‘uuid’
[17:36:37.473]   - Field: ‘seed’
[17:36:37.473]   - Field: ‘version’
[17:36:37.473]   - Field: ‘result’
[17:36:37.473]   - Field: ‘asynchronous’
[17:36:37.473]   - Field: ‘calls’
[17:36:37.474]   - Field: ‘globals’
[17:36:37.474]   - Field: ‘stdout’
[17:36:37.474]   - Field: ‘earlySignal’
[17:36:37.474]   - Field: ‘lazy’
[17:36:37.474]   - Field: ‘state’
[17:36:37.474] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:37.474] - Launch lazy future ...
[17:36:37.474] Packages needed by the future expression (n = 0): <none>
[17:36:37.474] Packages needed by future strategies (n = 0): <none>
[17:36:37.475] {
[17:36:37.475]     {
[17:36:37.475]         {
[17:36:37.475]             ...future.startTime <- base::Sys.time()
[17:36:37.475]             {
[17:36:37.475]                 {
[17:36:37.475]                   {
[17:36:37.475]                     {
[17:36:37.475]                       base::local({
[17:36:37.475]                         has_future <- base::requireNamespace("future", 
[17:36:37.475]                           quietly = TRUE)
[17:36:37.475]                         if (has_future) {
[17:36:37.475]                           ns <- base::getNamespace("future")
[17:36:37.475]                           version <- ns[[".package"]][["version"]]
[17:36:37.475]                           if (is.null(version)) 
[17:36:37.475]                             version <- utils::packageVersion("future")
[17:36:37.475]                         }
[17:36:37.475]                         else {
[17:36:37.475]                           version <- NULL
[17:36:37.475]                         }
[17:36:37.475]                         if (!has_future || version < "1.8.0") {
[17:36:37.475]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:37.475]                             "", base::R.version$version.string), 
[17:36:37.475]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:37.475]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:37.475]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:37.475]                               "release", "version")], collapse = " "), 
[17:36:37.475]                             hostname = base::Sys.info()[["nodename"]])
[17:36:37.475]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:37.475]                             info)
[17:36:37.475]                           info <- base::paste(info, collapse = "; ")
[17:36:37.475]                           if (!has_future) {
[17:36:37.475]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:37.475]                               info)
[17:36:37.475]                           }
[17:36:37.475]                           else {
[17:36:37.475]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:37.475]                               info, version)
[17:36:37.475]                           }
[17:36:37.475]                           base::stop(msg)
[17:36:37.475]                         }
[17:36:37.475]                       })
[17:36:37.475]                     }
[17:36:37.475]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:37.475]                     base::options(mc.cores = 1L)
[17:36:37.475]                   }
[17:36:37.475]                   ...future.strategy.old <- future::plan("list")
[17:36:37.475]                   options(future.plan = NULL)
[17:36:37.475]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:37.475]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:37.475]                 }
[17:36:37.475]                 ...future.workdir <- getwd()
[17:36:37.475]             }
[17:36:37.475]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:37.475]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:37.475]         }
[17:36:37.475]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:37.475]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:37.475]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:37.475]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:37.475]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:37.475]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:37.475]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:37.475]             base::names(...future.oldOptions))
[17:36:37.475]     }
[17:36:37.475]     if (FALSE) {
[17:36:37.475]     }
[17:36:37.475]     else {
[17:36:37.475]         if (TRUE) {
[17:36:37.475]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:37.475]                 open = "w")
[17:36:37.475]         }
[17:36:37.475]         else {
[17:36:37.475]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:37.475]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:37.475]         }
[17:36:37.475]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:37.475]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:37.475]             base::sink(type = "output", split = FALSE)
[17:36:37.475]             base::close(...future.stdout)
[17:36:37.475]         }, add = TRUE)
[17:36:37.475]     }
[17:36:37.475]     ...future.frame <- base::sys.nframe()
[17:36:37.475]     ...future.conditions <- base::list()
[17:36:37.475]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:37.475]     if (FALSE) {
[17:36:37.475]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:37.475]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:37.475]     }
[17:36:37.475]     ...future.result <- base::tryCatch({
[17:36:37.475]         base::withCallingHandlers({
[17:36:37.475]             ...future.value <- base::withVisible(base::local({
[17:36:37.475]                 ...future.makeSendCondition <- base::local({
[17:36:37.475]                   sendCondition <- NULL
[17:36:37.475]                   function(frame = 1L) {
[17:36:37.475]                     if (is.function(sendCondition)) 
[17:36:37.475]                       return(sendCondition)
[17:36:37.475]                     ns <- getNamespace("parallel")
[17:36:37.475]                     if (exists("sendData", mode = "function", 
[17:36:37.475]                       envir = ns)) {
[17:36:37.475]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:37.475]                         envir = ns)
[17:36:37.475]                       envir <- sys.frame(frame)
[17:36:37.475]                       master <- NULL
[17:36:37.475]                       while (!identical(envir, .GlobalEnv) && 
[17:36:37.475]                         !identical(envir, emptyenv())) {
[17:36:37.475]                         if (exists("master", mode = "list", envir = envir, 
[17:36:37.475]                           inherits = FALSE)) {
[17:36:37.475]                           master <- get("master", mode = "list", 
[17:36:37.475]                             envir = envir, inherits = FALSE)
[17:36:37.475]                           if (inherits(master, c("SOCKnode", 
[17:36:37.475]                             "SOCK0node"))) {
[17:36:37.475]                             sendCondition <<- function(cond) {
[17:36:37.475]                               data <- list(type = "VALUE", value = cond, 
[17:36:37.475]                                 success = TRUE)
[17:36:37.475]                               parallel_sendData(master, data)
[17:36:37.475]                             }
[17:36:37.475]                             return(sendCondition)
[17:36:37.475]                           }
[17:36:37.475]                         }
[17:36:37.475]                         frame <- frame + 1L
[17:36:37.475]                         envir <- sys.frame(frame)
[17:36:37.475]                       }
[17:36:37.475]                     }
[17:36:37.475]                     sendCondition <<- function(cond) NULL
[17:36:37.475]                   }
[17:36:37.475]                 })
[17:36:37.475]                 withCallingHandlers({
[17:36:37.475]                   {
[17:36:37.475]                     do.call(function(...) {
[17:36:37.475]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.475]                       if (!identical(...future.globals.maxSize.org, 
[17:36:37.475]                         ...future.globals.maxSize)) {
[17:36:37.475]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.475]                         on.exit(options(oopts), add = TRUE)
[17:36:37.475]                       }
[17:36:37.475]                       {
[17:36:37.475]                         lapply(seq_along(...future.elements_ii), 
[17:36:37.475]                           FUN = function(jj) {
[17:36:37.475]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.475]                             ...future.FUN(...future.X_jj, ...)
[17:36:37.475]                           })
[17:36:37.475]                       }
[17:36:37.475]                     }, args = future.call.arguments)
[17:36:37.475]                   }
[17:36:37.475]                 }, immediateCondition = function(cond) {
[17:36:37.475]                   sendCondition <- ...future.makeSendCondition()
[17:36:37.475]                   sendCondition(cond)
[17:36:37.475]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.475]                   {
[17:36:37.475]                     inherits <- base::inherits
[17:36:37.475]                     invokeRestart <- base::invokeRestart
[17:36:37.475]                     is.null <- base::is.null
[17:36:37.475]                     muffled <- FALSE
[17:36:37.475]                     if (inherits(cond, "message")) {
[17:36:37.475]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:37.475]                       if (muffled) 
[17:36:37.475]                         invokeRestart("muffleMessage")
[17:36:37.475]                     }
[17:36:37.475]                     else if (inherits(cond, "warning")) {
[17:36:37.475]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:37.475]                       if (muffled) 
[17:36:37.475]                         invokeRestart("muffleWarning")
[17:36:37.475]                     }
[17:36:37.475]                     else if (inherits(cond, "condition")) {
[17:36:37.475]                       if (!is.null(pattern)) {
[17:36:37.475]                         computeRestarts <- base::computeRestarts
[17:36:37.475]                         grepl <- base::grepl
[17:36:37.475]                         restarts <- computeRestarts(cond)
[17:36:37.475]                         for (restart in restarts) {
[17:36:37.475]                           name <- restart$name
[17:36:37.475]                           if (is.null(name)) 
[17:36:37.475]                             next
[17:36:37.475]                           if (!grepl(pattern, name)) 
[17:36:37.475]                             next
[17:36:37.475]                           invokeRestart(restart)
[17:36:37.475]                           muffled <- TRUE
[17:36:37.475]                           break
[17:36:37.475]                         }
[17:36:37.475]                       }
[17:36:37.475]                     }
[17:36:37.475]                     invisible(muffled)
[17:36:37.475]                   }
[17:36:37.475]                   muffleCondition(cond)
[17:36:37.475]                 })
[17:36:37.475]             }))
[17:36:37.475]             future::FutureResult(value = ...future.value$value, 
[17:36:37.475]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:37.475]                   ...future.rng), globalenv = if (FALSE) 
[17:36:37.475]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:37.475]                     ...future.globalenv.names))
[17:36:37.475]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:37.475]         }, condition = base::local({
[17:36:37.475]             c <- base::c
[17:36:37.475]             inherits <- base::inherits
[17:36:37.475]             invokeRestart <- base::invokeRestart
[17:36:37.475]             length <- base::length
[17:36:37.475]             list <- base::list
[17:36:37.475]             seq.int <- base::seq.int
[17:36:37.475]             signalCondition <- base::signalCondition
[17:36:37.475]             sys.calls <- base::sys.calls
[17:36:37.475]             `[[` <- base::`[[`
[17:36:37.475]             `+` <- base::`+`
[17:36:37.475]             `<<-` <- base::`<<-`
[17:36:37.475]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:37.475]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:37.475]                   3L)]
[17:36:37.475]             }
[17:36:37.475]             function(cond) {
[17:36:37.475]                 is_error <- inherits(cond, "error")
[17:36:37.475]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:37.475]                   NULL)
[17:36:37.475]                 if (is_error) {
[17:36:37.475]                   sessionInformation <- function() {
[17:36:37.475]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:37.475]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:37.475]                       search = base::search(), system = base::Sys.info())
[17:36:37.475]                   }
[17:36:37.475]                   ...future.conditions[[length(...future.conditions) + 
[17:36:37.475]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:37.475]                     cond$call), session = sessionInformation(), 
[17:36:37.475]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:37.475]                   signalCondition(cond)
[17:36:37.475]                 }
[17:36:37.475]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:37.475]                 "immediateCondition"))) {
[17:36:37.475]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:37.475]                   ...future.conditions[[length(...future.conditions) + 
[17:36:37.475]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:37.475]                   if (TRUE && !signal) {
[17:36:37.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.475]                     {
[17:36:37.475]                       inherits <- base::inherits
[17:36:37.475]                       invokeRestart <- base::invokeRestart
[17:36:37.475]                       is.null <- base::is.null
[17:36:37.475]                       muffled <- FALSE
[17:36:37.475]                       if (inherits(cond, "message")) {
[17:36:37.475]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:37.475]                         if (muffled) 
[17:36:37.475]                           invokeRestart("muffleMessage")
[17:36:37.475]                       }
[17:36:37.475]                       else if (inherits(cond, "warning")) {
[17:36:37.475]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:37.475]                         if (muffled) 
[17:36:37.475]                           invokeRestart("muffleWarning")
[17:36:37.475]                       }
[17:36:37.475]                       else if (inherits(cond, "condition")) {
[17:36:37.475]                         if (!is.null(pattern)) {
[17:36:37.475]                           computeRestarts <- base::computeRestarts
[17:36:37.475]                           grepl <- base::grepl
[17:36:37.475]                           restarts <- computeRestarts(cond)
[17:36:37.475]                           for (restart in restarts) {
[17:36:37.475]                             name <- restart$name
[17:36:37.475]                             if (is.null(name)) 
[17:36:37.475]                               next
[17:36:37.475]                             if (!grepl(pattern, name)) 
[17:36:37.475]                               next
[17:36:37.475]                             invokeRestart(restart)
[17:36:37.475]                             muffled <- TRUE
[17:36:37.475]                             break
[17:36:37.475]                           }
[17:36:37.475]                         }
[17:36:37.475]                       }
[17:36:37.475]                       invisible(muffled)
[17:36:37.475]                     }
[17:36:37.475]                     muffleCondition(cond, pattern = "^muffle")
[17:36:37.475]                   }
[17:36:37.475]                 }
[17:36:37.475]                 else {
[17:36:37.475]                   if (TRUE) {
[17:36:37.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.475]                     {
[17:36:37.475]                       inherits <- base::inherits
[17:36:37.475]                       invokeRestart <- base::invokeRestart
[17:36:37.475]                       is.null <- base::is.null
[17:36:37.475]                       muffled <- FALSE
[17:36:37.475]                       if (inherits(cond, "message")) {
[17:36:37.475]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:37.475]                         if (muffled) 
[17:36:37.475]                           invokeRestart("muffleMessage")
[17:36:37.475]                       }
[17:36:37.475]                       else if (inherits(cond, "warning")) {
[17:36:37.475]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:37.475]                         if (muffled) 
[17:36:37.475]                           invokeRestart("muffleWarning")
[17:36:37.475]                       }
[17:36:37.475]                       else if (inherits(cond, "condition")) {
[17:36:37.475]                         if (!is.null(pattern)) {
[17:36:37.475]                           computeRestarts <- base::computeRestarts
[17:36:37.475]                           grepl <- base::grepl
[17:36:37.475]                           restarts <- computeRestarts(cond)
[17:36:37.475]                           for (restart in restarts) {
[17:36:37.475]                             name <- restart$name
[17:36:37.475]                             if (is.null(name)) 
[17:36:37.475]                               next
[17:36:37.475]                             if (!grepl(pattern, name)) 
[17:36:37.475]                               next
[17:36:37.475]                             invokeRestart(restart)
[17:36:37.475]                             muffled <- TRUE
[17:36:37.475]                             break
[17:36:37.475]                           }
[17:36:37.475]                         }
[17:36:37.475]                       }
[17:36:37.475]                       invisible(muffled)
[17:36:37.475]                     }
[17:36:37.475]                     muffleCondition(cond, pattern = "^muffle")
[17:36:37.475]                   }
[17:36:37.475]                 }
[17:36:37.475]             }
[17:36:37.475]         }))
[17:36:37.475]     }, error = function(ex) {
[17:36:37.475]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:37.475]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:37.475]                 ...future.rng), started = ...future.startTime, 
[17:36:37.475]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:37.475]             version = "1.8"), class = "FutureResult")
[17:36:37.475]     }, finally = {
[17:36:37.475]         if (!identical(...future.workdir, getwd())) 
[17:36:37.475]             setwd(...future.workdir)
[17:36:37.475]         {
[17:36:37.475]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:37.475]                 ...future.oldOptions$nwarnings <- NULL
[17:36:37.475]             }
[17:36:37.475]             base::options(...future.oldOptions)
[17:36:37.475]             if (.Platform$OS.type == "windows") {
[17:36:37.475]                 old_names <- names(...future.oldEnvVars)
[17:36:37.475]                 envs <- base::Sys.getenv()
[17:36:37.475]                 names <- names(envs)
[17:36:37.475]                 common <- intersect(names, old_names)
[17:36:37.475]                 added <- setdiff(names, old_names)
[17:36:37.475]                 removed <- setdiff(old_names, names)
[17:36:37.475]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:37.475]                   envs[common]]
[17:36:37.475]                 NAMES <- toupper(changed)
[17:36:37.475]                 args <- list()
[17:36:37.475]                 for (kk in seq_along(NAMES)) {
[17:36:37.475]                   name <- changed[[kk]]
[17:36:37.475]                   NAME <- NAMES[[kk]]
[17:36:37.475]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.475]                     next
[17:36:37.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:37.475]                 }
[17:36:37.475]                 NAMES <- toupper(added)
[17:36:37.475]                 for (kk in seq_along(NAMES)) {
[17:36:37.475]                   name <- added[[kk]]
[17:36:37.475]                   NAME <- NAMES[[kk]]
[17:36:37.475]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.475]                     next
[17:36:37.475]                   args[[name]] <- ""
[17:36:37.475]                 }
[17:36:37.475]                 NAMES <- toupper(removed)
[17:36:37.475]                 for (kk in seq_along(NAMES)) {
[17:36:37.475]                   name <- removed[[kk]]
[17:36:37.475]                   NAME <- NAMES[[kk]]
[17:36:37.475]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.475]                     next
[17:36:37.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:37.475]                 }
[17:36:37.475]                 if (length(args) > 0) 
[17:36:37.475]                   base::do.call(base::Sys.setenv, args = args)
[17:36:37.475]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:37.475]             }
[17:36:37.475]             else {
[17:36:37.475]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:37.475]             }
[17:36:37.475]             {
[17:36:37.475]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:37.475]                   0L) {
[17:36:37.475]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:37.475]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:37.475]                   base::options(opts)
[17:36:37.475]                 }
[17:36:37.475]                 {
[17:36:37.475]                   {
[17:36:37.475]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:37.475]                     NULL
[17:36:37.475]                   }
[17:36:37.475]                   options(future.plan = NULL)
[17:36:37.475]                   if (is.na(NA_character_)) 
[17:36:37.475]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:37.475]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:37.475]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:37.475]                     .init = FALSE)
[17:36:37.475]                 }
[17:36:37.475]             }
[17:36:37.475]         }
[17:36:37.475]     })
[17:36:37.475]     if (TRUE) {
[17:36:37.475]         base::sink(type = "output", split = FALSE)
[17:36:37.475]         if (TRUE) {
[17:36:37.475]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:37.475]         }
[17:36:37.475]         else {
[17:36:37.475]             ...future.result["stdout"] <- base::list(NULL)
[17:36:37.475]         }
[17:36:37.475]         base::close(...future.stdout)
[17:36:37.475]         ...future.stdout <- NULL
[17:36:37.475]     }
[17:36:37.475]     ...future.result$conditions <- ...future.conditions
[17:36:37.475]     ...future.result$finished <- base::Sys.time()
[17:36:37.475]     ...future.result
[17:36:37.475] }
[17:36:37.478] Exporting 5 global objects (346.05 KiB) to cluster node #1 ...
[17:36:37.478] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:36:37.479] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:36:37.479] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[17:36:37.524] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[17:36:37.525] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[17:36:37.525] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[17:36:37.525] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:36:37.526] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:36:37.526] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:36:37.526] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:36:37.526] Exporting 5 global objects (346.05 KiB) to cluster node #1 ... DONE
[17:36:37.527] MultisessionFuture started
[17:36:37.527] - Launch lazy future ... done
[17:36:37.527] run() for ‘MultisessionFuture’ ... done
[17:36:37.527] Created future:
[17:36:37.527] MultisessionFuture:
[17:36:37.527] Label: ‘future_apply-1’
[17:36:37.527] Expression:
[17:36:37.527] {
[17:36:37.527]     do.call(function(...) {
[17:36:37.527]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.527]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:37.527]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.527]             on.exit(options(oopts), add = TRUE)
[17:36:37.527]         }
[17:36:37.527]         {
[17:36:37.527]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:37.527]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.527]                 ...future.FUN(...future.X_jj, ...)
[17:36:37.527]             })
[17:36:37.527]         }
[17:36:37.527]     }, args = future.call.arguments)
[17:36:37.527] }
[17:36:37.527] Lazy evaluation: FALSE
[17:36:37.527] Asynchronous evaluation: TRUE
[17:36:37.527] Local evaluation: TRUE
[17:36:37.527] Environment: R_GlobalEnv
[17:36:37.527] Capture standard output: TRUE
[17:36:37.527] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:37.527] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:37.527] Packages: <none>
[17:36:37.527] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:37.527] Resolved: FALSE
[17:36:37.527] Value: <not collected>
[17:36:37.527] Conditions captured: <none>
[17:36:37.527] Early signaling: FALSE
[17:36:37.527] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:37.527] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:37.539] Chunk #1 of 2 ... DONE
[17:36:37.539] Chunk #2 of 2 ...
[17:36:37.539]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:37.540]  - seeds: <none>
[17:36:37.540]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.540] getGlobalsAndPackages() ...
[17:36:37.540] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.540] Resolving globals: FALSE
[17:36:37.540] Tweak future expression to call with '...' arguments ...
[17:36:37.540] {
[17:36:37.540]     do.call(function(...) {
[17:36:37.540]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.540]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:37.540]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.540]             on.exit(options(oopts), add = TRUE)
[17:36:37.540]         }
[17:36:37.540]         {
[17:36:37.540]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:37.540]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.540]                 ...future.FUN(...future.X_jj, ...)
[17:36:37.540]             })
[17:36:37.540]         }
[17:36:37.540]     }, args = future.call.arguments)
[17:36:37.540] }
[17:36:37.541] Tweak future expression to call with '...' arguments ... DONE
[17:36:37.541] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.541] 
[17:36:37.541] getGlobalsAndPackages() ... DONE
[17:36:37.541] run() for ‘Future’ ...
[17:36:37.542] - state: ‘created’
[17:36:37.542] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:37.555] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:37.556] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:37.556]   - Field: ‘node’
[17:36:37.556]   - Field: ‘label’
[17:36:37.556]   - Field: ‘local’
[17:36:37.556]   - Field: ‘owner’
[17:36:37.556]   - Field: ‘envir’
[17:36:37.556]   - Field: ‘workers’
[17:36:37.556]   - Field: ‘packages’
[17:36:37.556]   - Field: ‘gc’
[17:36:37.557]   - Field: ‘conditions’
[17:36:37.557]   - Field: ‘persistent’
[17:36:37.557]   - Field: ‘expr’
[17:36:37.557]   - Field: ‘uuid’
[17:36:37.557]   - Field: ‘seed’
[17:36:37.557]   - Field: ‘version’
[17:36:37.557]   - Field: ‘result’
[17:36:37.557]   - Field: ‘asynchronous’
[17:36:37.557]   - Field: ‘calls’
[17:36:37.557]   - Field: ‘globals’
[17:36:37.557]   - Field: ‘stdout’
[17:36:37.558]   - Field: ‘earlySignal’
[17:36:37.558]   - Field: ‘lazy’
[17:36:37.558]   - Field: ‘state’
[17:36:37.558] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:37.558] - Launch lazy future ...
[17:36:37.558] Packages needed by the future expression (n = 0): <none>
[17:36:37.558] Packages needed by future strategies (n = 0): <none>
[17:36:37.559] {
[17:36:37.559]     {
[17:36:37.559]         {
[17:36:37.559]             ...future.startTime <- base::Sys.time()
[17:36:37.559]             {
[17:36:37.559]                 {
[17:36:37.559]                   {
[17:36:37.559]                     {
[17:36:37.559]                       base::local({
[17:36:37.559]                         has_future <- base::requireNamespace("future", 
[17:36:37.559]                           quietly = TRUE)
[17:36:37.559]                         if (has_future) {
[17:36:37.559]                           ns <- base::getNamespace("future")
[17:36:37.559]                           version <- ns[[".package"]][["version"]]
[17:36:37.559]                           if (is.null(version)) 
[17:36:37.559]                             version <- utils::packageVersion("future")
[17:36:37.559]                         }
[17:36:37.559]                         else {
[17:36:37.559]                           version <- NULL
[17:36:37.559]                         }
[17:36:37.559]                         if (!has_future || version < "1.8.0") {
[17:36:37.559]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:37.559]                             "", base::R.version$version.string), 
[17:36:37.559]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:37.559]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:37.559]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:37.559]                               "release", "version")], collapse = " "), 
[17:36:37.559]                             hostname = base::Sys.info()[["nodename"]])
[17:36:37.559]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:37.559]                             info)
[17:36:37.559]                           info <- base::paste(info, collapse = "; ")
[17:36:37.559]                           if (!has_future) {
[17:36:37.559]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:37.559]                               info)
[17:36:37.559]                           }
[17:36:37.559]                           else {
[17:36:37.559]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:37.559]                               info, version)
[17:36:37.559]                           }
[17:36:37.559]                           base::stop(msg)
[17:36:37.559]                         }
[17:36:37.559]                       })
[17:36:37.559]                     }
[17:36:37.559]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:37.559]                     base::options(mc.cores = 1L)
[17:36:37.559]                   }
[17:36:37.559]                   ...future.strategy.old <- future::plan("list")
[17:36:37.559]                   options(future.plan = NULL)
[17:36:37.559]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:37.559]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:37.559]                 }
[17:36:37.559]                 ...future.workdir <- getwd()
[17:36:37.559]             }
[17:36:37.559]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:37.559]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:37.559]         }
[17:36:37.559]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:37.559]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:37.559]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:37.559]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:37.559]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:37.559]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:37.559]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:37.559]             base::names(...future.oldOptions))
[17:36:37.559]     }
[17:36:37.559]     if (FALSE) {
[17:36:37.559]     }
[17:36:37.559]     else {
[17:36:37.559]         if (TRUE) {
[17:36:37.559]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:37.559]                 open = "w")
[17:36:37.559]         }
[17:36:37.559]         else {
[17:36:37.559]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:37.559]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:37.559]         }
[17:36:37.559]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:37.559]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:37.559]             base::sink(type = "output", split = FALSE)
[17:36:37.559]             base::close(...future.stdout)
[17:36:37.559]         }, add = TRUE)
[17:36:37.559]     }
[17:36:37.559]     ...future.frame <- base::sys.nframe()
[17:36:37.559]     ...future.conditions <- base::list()
[17:36:37.559]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:37.559]     if (FALSE) {
[17:36:37.559]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:37.559]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:37.559]     }
[17:36:37.559]     ...future.result <- base::tryCatch({
[17:36:37.559]         base::withCallingHandlers({
[17:36:37.559]             ...future.value <- base::withVisible(base::local({
[17:36:37.559]                 ...future.makeSendCondition <- base::local({
[17:36:37.559]                   sendCondition <- NULL
[17:36:37.559]                   function(frame = 1L) {
[17:36:37.559]                     if (is.function(sendCondition)) 
[17:36:37.559]                       return(sendCondition)
[17:36:37.559]                     ns <- getNamespace("parallel")
[17:36:37.559]                     if (exists("sendData", mode = "function", 
[17:36:37.559]                       envir = ns)) {
[17:36:37.559]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:37.559]                         envir = ns)
[17:36:37.559]                       envir <- sys.frame(frame)
[17:36:37.559]                       master <- NULL
[17:36:37.559]                       while (!identical(envir, .GlobalEnv) && 
[17:36:37.559]                         !identical(envir, emptyenv())) {
[17:36:37.559]                         if (exists("master", mode = "list", envir = envir, 
[17:36:37.559]                           inherits = FALSE)) {
[17:36:37.559]                           master <- get("master", mode = "list", 
[17:36:37.559]                             envir = envir, inherits = FALSE)
[17:36:37.559]                           if (inherits(master, c("SOCKnode", 
[17:36:37.559]                             "SOCK0node"))) {
[17:36:37.559]                             sendCondition <<- function(cond) {
[17:36:37.559]                               data <- list(type = "VALUE", value = cond, 
[17:36:37.559]                                 success = TRUE)
[17:36:37.559]                               parallel_sendData(master, data)
[17:36:37.559]                             }
[17:36:37.559]                             return(sendCondition)
[17:36:37.559]                           }
[17:36:37.559]                         }
[17:36:37.559]                         frame <- frame + 1L
[17:36:37.559]                         envir <- sys.frame(frame)
[17:36:37.559]                       }
[17:36:37.559]                     }
[17:36:37.559]                     sendCondition <<- function(cond) NULL
[17:36:37.559]                   }
[17:36:37.559]                 })
[17:36:37.559]                 withCallingHandlers({
[17:36:37.559]                   {
[17:36:37.559]                     do.call(function(...) {
[17:36:37.559]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.559]                       if (!identical(...future.globals.maxSize.org, 
[17:36:37.559]                         ...future.globals.maxSize)) {
[17:36:37.559]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.559]                         on.exit(options(oopts), add = TRUE)
[17:36:37.559]                       }
[17:36:37.559]                       {
[17:36:37.559]                         lapply(seq_along(...future.elements_ii), 
[17:36:37.559]                           FUN = function(jj) {
[17:36:37.559]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.559]                             ...future.FUN(...future.X_jj, ...)
[17:36:37.559]                           })
[17:36:37.559]                       }
[17:36:37.559]                     }, args = future.call.arguments)
[17:36:37.559]                   }
[17:36:37.559]                 }, immediateCondition = function(cond) {
[17:36:37.559]                   sendCondition <- ...future.makeSendCondition()
[17:36:37.559]                   sendCondition(cond)
[17:36:37.559]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.559]                   {
[17:36:37.559]                     inherits <- base::inherits
[17:36:37.559]                     invokeRestart <- base::invokeRestart
[17:36:37.559]                     is.null <- base::is.null
[17:36:37.559]                     muffled <- FALSE
[17:36:37.559]                     if (inherits(cond, "message")) {
[17:36:37.559]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:37.559]                       if (muffled) 
[17:36:37.559]                         invokeRestart("muffleMessage")
[17:36:37.559]                     }
[17:36:37.559]                     else if (inherits(cond, "warning")) {
[17:36:37.559]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:37.559]                       if (muffled) 
[17:36:37.559]                         invokeRestart("muffleWarning")
[17:36:37.559]                     }
[17:36:37.559]                     else if (inherits(cond, "condition")) {
[17:36:37.559]                       if (!is.null(pattern)) {
[17:36:37.559]                         computeRestarts <- base::computeRestarts
[17:36:37.559]                         grepl <- base::grepl
[17:36:37.559]                         restarts <- computeRestarts(cond)
[17:36:37.559]                         for (restart in restarts) {
[17:36:37.559]                           name <- restart$name
[17:36:37.559]                           if (is.null(name)) 
[17:36:37.559]                             next
[17:36:37.559]                           if (!grepl(pattern, name)) 
[17:36:37.559]                             next
[17:36:37.559]                           invokeRestart(restart)
[17:36:37.559]                           muffled <- TRUE
[17:36:37.559]                           break
[17:36:37.559]                         }
[17:36:37.559]                       }
[17:36:37.559]                     }
[17:36:37.559]                     invisible(muffled)
[17:36:37.559]                   }
[17:36:37.559]                   muffleCondition(cond)
[17:36:37.559]                 })
[17:36:37.559]             }))
[17:36:37.559]             future::FutureResult(value = ...future.value$value, 
[17:36:37.559]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:37.559]                   ...future.rng), globalenv = if (FALSE) 
[17:36:37.559]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:37.559]                     ...future.globalenv.names))
[17:36:37.559]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:37.559]         }, condition = base::local({
[17:36:37.559]             c <- base::c
[17:36:37.559]             inherits <- base::inherits
[17:36:37.559]             invokeRestart <- base::invokeRestart
[17:36:37.559]             length <- base::length
[17:36:37.559]             list <- base::list
[17:36:37.559]             seq.int <- base::seq.int
[17:36:37.559]             signalCondition <- base::signalCondition
[17:36:37.559]             sys.calls <- base::sys.calls
[17:36:37.559]             `[[` <- base::`[[`
[17:36:37.559]             `+` <- base::`+`
[17:36:37.559]             `<<-` <- base::`<<-`
[17:36:37.559]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:37.559]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:37.559]                   3L)]
[17:36:37.559]             }
[17:36:37.559]             function(cond) {
[17:36:37.559]                 is_error <- inherits(cond, "error")
[17:36:37.559]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:37.559]                   NULL)
[17:36:37.559]                 if (is_error) {
[17:36:37.559]                   sessionInformation <- function() {
[17:36:37.559]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:37.559]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:37.559]                       search = base::search(), system = base::Sys.info())
[17:36:37.559]                   }
[17:36:37.559]                   ...future.conditions[[length(...future.conditions) + 
[17:36:37.559]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:37.559]                     cond$call), session = sessionInformation(), 
[17:36:37.559]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:37.559]                   signalCondition(cond)
[17:36:37.559]                 }
[17:36:37.559]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:37.559]                 "immediateCondition"))) {
[17:36:37.559]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:37.559]                   ...future.conditions[[length(...future.conditions) + 
[17:36:37.559]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:37.559]                   if (TRUE && !signal) {
[17:36:37.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.559]                     {
[17:36:37.559]                       inherits <- base::inherits
[17:36:37.559]                       invokeRestart <- base::invokeRestart
[17:36:37.559]                       is.null <- base::is.null
[17:36:37.559]                       muffled <- FALSE
[17:36:37.559]                       if (inherits(cond, "message")) {
[17:36:37.559]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:37.559]                         if (muffled) 
[17:36:37.559]                           invokeRestart("muffleMessage")
[17:36:37.559]                       }
[17:36:37.559]                       else if (inherits(cond, "warning")) {
[17:36:37.559]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:37.559]                         if (muffled) 
[17:36:37.559]                           invokeRestart("muffleWarning")
[17:36:37.559]                       }
[17:36:37.559]                       else if (inherits(cond, "condition")) {
[17:36:37.559]                         if (!is.null(pattern)) {
[17:36:37.559]                           computeRestarts <- base::computeRestarts
[17:36:37.559]                           grepl <- base::grepl
[17:36:37.559]                           restarts <- computeRestarts(cond)
[17:36:37.559]                           for (restart in restarts) {
[17:36:37.559]                             name <- restart$name
[17:36:37.559]                             if (is.null(name)) 
[17:36:37.559]                               next
[17:36:37.559]                             if (!grepl(pattern, name)) 
[17:36:37.559]                               next
[17:36:37.559]                             invokeRestart(restart)
[17:36:37.559]                             muffled <- TRUE
[17:36:37.559]                             break
[17:36:37.559]                           }
[17:36:37.559]                         }
[17:36:37.559]                       }
[17:36:37.559]                       invisible(muffled)
[17:36:37.559]                     }
[17:36:37.559]                     muffleCondition(cond, pattern = "^muffle")
[17:36:37.559]                   }
[17:36:37.559]                 }
[17:36:37.559]                 else {
[17:36:37.559]                   if (TRUE) {
[17:36:37.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.559]                     {
[17:36:37.559]                       inherits <- base::inherits
[17:36:37.559]                       invokeRestart <- base::invokeRestart
[17:36:37.559]                       is.null <- base::is.null
[17:36:37.559]                       muffled <- FALSE
[17:36:37.559]                       if (inherits(cond, "message")) {
[17:36:37.559]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:37.559]                         if (muffled) 
[17:36:37.559]                           invokeRestart("muffleMessage")
[17:36:37.559]                       }
[17:36:37.559]                       else if (inherits(cond, "warning")) {
[17:36:37.559]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:37.559]                         if (muffled) 
[17:36:37.559]                           invokeRestart("muffleWarning")
[17:36:37.559]                       }
[17:36:37.559]                       else if (inherits(cond, "condition")) {
[17:36:37.559]                         if (!is.null(pattern)) {
[17:36:37.559]                           computeRestarts <- base::computeRestarts
[17:36:37.559]                           grepl <- base::grepl
[17:36:37.559]                           restarts <- computeRestarts(cond)
[17:36:37.559]                           for (restart in restarts) {
[17:36:37.559]                             name <- restart$name
[17:36:37.559]                             if (is.null(name)) 
[17:36:37.559]                               next
[17:36:37.559]                             if (!grepl(pattern, name)) 
[17:36:37.559]                               next
[17:36:37.559]                             invokeRestart(restart)
[17:36:37.559]                             muffled <- TRUE
[17:36:37.559]                             break
[17:36:37.559]                           }
[17:36:37.559]                         }
[17:36:37.559]                       }
[17:36:37.559]                       invisible(muffled)
[17:36:37.559]                     }
[17:36:37.559]                     muffleCondition(cond, pattern = "^muffle")
[17:36:37.559]                   }
[17:36:37.559]                 }
[17:36:37.559]             }
[17:36:37.559]         }))
[17:36:37.559]     }, error = function(ex) {
[17:36:37.559]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:37.559]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:37.559]                 ...future.rng), started = ...future.startTime, 
[17:36:37.559]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:37.559]             version = "1.8"), class = "FutureResult")
[17:36:37.559]     }, finally = {
[17:36:37.559]         if (!identical(...future.workdir, getwd())) 
[17:36:37.559]             setwd(...future.workdir)
[17:36:37.559]         {
[17:36:37.559]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:37.559]                 ...future.oldOptions$nwarnings <- NULL
[17:36:37.559]             }
[17:36:37.559]             base::options(...future.oldOptions)
[17:36:37.559]             if (.Platform$OS.type == "windows") {
[17:36:37.559]                 old_names <- names(...future.oldEnvVars)
[17:36:37.559]                 envs <- base::Sys.getenv()
[17:36:37.559]                 names <- names(envs)
[17:36:37.559]                 common <- intersect(names, old_names)
[17:36:37.559]                 added <- setdiff(names, old_names)
[17:36:37.559]                 removed <- setdiff(old_names, names)
[17:36:37.559]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:37.559]                   envs[common]]
[17:36:37.559]                 NAMES <- toupper(changed)
[17:36:37.559]                 args <- list()
[17:36:37.559]                 for (kk in seq_along(NAMES)) {
[17:36:37.559]                   name <- changed[[kk]]
[17:36:37.559]                   NAME <- NAMES[[kk]]
[17:36:37.559]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.559]                     next
[17:36:37.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:37.559]                 }
[17:36:37.559]                 NAMES <- toupper(added)
[17:36:37.559]                 for (kk in seq_along(NAMES)) {
[17:36:37.559]                   name <- added[[kk]]
[17:36:37.559]                   NAME <- NAMES[[kk]]
[17:36:37.559]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.559]                     next
[17:36:37.559]                   args[[name]] <- ""
[17:36:37.559]                 }
[17:36:37.559]                 NAMES <- toupper(removed)
[17:36:37.559]                 for (kk in seq_along(NAMES)) {
[17:36:37.559]                   name <- removed[[kk]]
[17:36:37.559]                   NAME <- NAMES[[kk]]
[17:36:37.559]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.559]                     next
[17:36:37.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:37.559]                 }
[17:36:37.559]                 if (length(args) > 0) 
[17:36:37.559]                   base::do.call(base::Sys.setenv, args = args)
[17:36:37.559]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:37.559]             }
[17:36:37.559]             else {
[17:36:37.559]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:37.559]             }
[17:36:37.559]             {
[17:36:37.559]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:37.559]                   0L) {
[17:36:37.559]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:37.559]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:37.559]                   base::options(opts)
[17:36:37.559]                 }
[17:36:37.559]                 {
[17:36:37.559]                   {
[17:36:37.559]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:37.559]                     NULL
[17:36:37.559]                   }
[17:36:37.559]                   options(future.plan = NULL)
[17:36:37.559]                   if (is.na(NA_character_)) 
[17:36:37.559]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:37.559]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:37.559]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:37.559]                     .init = FALSE)
[17:36:37.559]                 }
[17:36:37.559]             }
[17:36:37.559]         }
[17:36:37.559]     })
[17:36:37.559]     if (TRUE) {
[17:36:37.559]         base::sink(type = "output", split = FALSE)
[17:36:37.559]         if (TRUE) {
[17:36:37.559]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:37.559]         }
[17:36:37.559]         else {
[17:36:37.559]             ...future.result["stdout"] <- base::list(NULL)
[17:36:37.559]         }
[17:36:37.559]         base::close(...future.stdout)
[17:36:37.559]         ...future.stdout <- NULL
[17:36:37.559]     }
[17:36:37.559]     ...future.result$conditions <- ...future.conditions
[17:36:37.559]     ...future.result$finished <- base::Sys.time()
[17:36:37.559]     ...future.result
[17:36:37.559] }
[17:36:37.562] Exporting 5 global objects (346.05 KiB) to cluster node #2 ...
[17:36:37.562] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:36:37.563] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:36:37.563] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[17:36:37.605] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[17:36:37.605] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[17:36:37.606] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[17:36:37.606] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:36:37.606] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:36:37.606] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:36:37.607] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:36:37.607] Exporting 5 global objects (346.05 KiB) to cluster node #2 ... DONE
[17:36:37.607] MultisessionFuture started
[17:36:37.607] - Launch lazy future ... done
[17:36:37.608] run() for ‘MultisessionFuture’ ... done
[17:36:37.608] Created future:
[17:36:37.608] MultisessionFuture:
[17:36:37.608] Label: ‘future_apply-2’
[17:36:37.608] Expression:
[17:36:37.608] {
[17:36:37.608]     do.call(function(...) {
[17:36:37.608]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.608]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:37.608]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.608]             on.exit(options(oopts), add = TRUE)
[17:36:37.608]         }
[17:36:37.608]         {
[17:36:37.608]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:37.608]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.608]                 ...future.FUN(...future.X_jj, ...)
[17:36:37.608]             })
[17:36:37.608]         }
[17:36:37.608]     }, args = future.call.arguments)
[17:36:37.608] }
[17:36:37.608] Lazy evaluation: FALSE
[17:36:37.608] Asynchronous evaluation: TRUE
[17:36:37.608] Local evaluation: TRUE
[17:36:37.608] Environment: R_GlobalEnv
[17:36:37.608] Capture standard output: TRUE
[17:36:37.608] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:37.608] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:37.608] Packages: <none>
[17:36:37.608] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:37.608] Resolved: FALSE
[17:36:37.608] Value: <not collected>
[17:36:37.608] Conditions captured: <none>
[17:36:37.608] Early signaling: FALSE
[17:36:37.608] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:37.608] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:37.620] Chunk #2 of 2 ... DONE
[17:36:37.620] Launching 2 futures (chunks) ... DONE
[17:36:37.620] Resolving 2 futures (chunks) ...
[17:36:37.620] resolve() on list ...
[17:36:37.620]  recursive: 0
[17:36:37.620]  length: 2
[17:36:37.620] 
[17:36:37.621] receiveMessageFromWorker() for ClusterFuture ...
[17:36:37.621] - Validating connection of MultisessionFuture
[17:36:37.621] - received message: FutureResult
[17:36:37.621] - Received FutureResult
[17:36:37.621] - Erased future from FutureRegistry
[17:36:37.621] result() for ClusterFuture ...
[17:36:37.621] - result already collected: FutureResult
[17:36:37.621] result() for ClusterFuture ... done
[17:36:37.622] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:37.622] Future #1
[17:36:37.622] result() for ClusterFuture ...
[17:36:37.622] - result already collected: FutureResult
[17:36:37.622] result() for ClusterFuture ... done
[17:36:37.622] result() for ClusterFuture ...
[17:36:37.622] - result already collected: FutureResult
[17:36:37.622] result() for ClusterFuture ... done
[17:36:37.622] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:36:37.622] - nx: 2
[17:36:37.622] - relay: TRUE
[17:36:37.623] - stdout: TRUE
[17:36:37.623] - signal: TRUE
[17:36:37.623] - resignal: FALSE
[17:36:37.623] - force: TRUE
[17:36:37.623] - relayed: [n=2] FALSE, FALSE
[17:36:37.623] - queued futures: [n=2] FALSE, FALSE
[17:36:37.623]  - until=1
[17:36:37.623]  - relaying element #1
[17:36:37.623] result() for ClusterFuture ...
[17:36:37.623] - result already collected: FutureResult
[17:36:37.623] result() for ClusterFuture ... done
[17:36:37.623] result() for ClusterFuture ...
[17:36:37.624] - result already collected: FutureResult
[17:36:37.624] result() for ClusterFuture ... done
[17:36:37.624] result() for ClusterFuture ...
[17:36:37.624] - result already collected: FutureResult
[17:36:37.624] result() for ClusterFuture ... done
[17:36:37.624] result() for ClusterFuture ...
[17:36:37.624] - result already collected: FutureResult
[17:36:37.624] result() for ClusterFuture ... done
[17:36:37.624] - relayed: [n=2] TRUE, FALSE
[17:36:37.624] - queued futures: [n=2] TRUE, FALSE
[17:36:37.624] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:36:37.625]  length: 1 (resolved future 1)
[17:36:37.654] receiveMessageFromWorker() for ClusterFuture ...
[17:36:37.654] - Validating connection of MultisessionFuture
[17:36:37.654] - received message: FutureResult
[17:36:37.654] - Received FutureResult
[17:36:37.654] - Erased future from FutureRegistry
[17:36:37.654] result() for ClusterFuture ...
[17:36:37.654] - result already collected: FutureResult
[17:36:37.654] result() for ClusterFuture ... done
[17:36:37.655] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:37.655] Future #2
[17:36:37.655] result() for ClusterFuture ...
[17:36:37.655] - result already collected: FutureResult
[17:36:37.655] result() for ClusterFuture ... done
[17:36:37.655] result() for ClusterFuture ...
[17:36:37.655] - result already collected: FutureResult
[17:36:37.655] result() for ClusterFuture ... done
[17:36:37.655] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:36:37.655] - nx: 2
[17:36:37.655] - relay: TRUE
[17:36:37.656] - stdout: TRUE
[17:36:37.656] - signal: TRUE
[17:36:37.656] - resignal: FALSE
[17:36:37.656] - force: TRUE
[17:36:37.656] - relayed: [n=2] TRUE, FALSE
[17:36:37.656] - queued futures: [n=2] TRUE, FALSE
[17:36:37.656]  - until=2
[17:36:37.656]  - relaying element #2
[17:36:37.656] result() for ClusterFuture ...
[17:36:37.656] - result already collected: FutureResult
[17:36:37.656] result() for ClusterFuture ... done
[17:36:37.656] result() for ClusterFuture ...
[17:36:37.657] - result already collected: FutureResult
[17:36:37.657] result() for ClusterFuture ... done
[17:36:37.657] result() for ClusterFuture ...
[17:36:37.657] - result already collected: FutureResult
[17:36:37.657] result() for ClusterFuture ... done
[17:36:37.657] result() for ClusterFuture ...
[17:36:37.659] - result already collected: FutureResult
[17:36:37.659] result() for ClusterFuture ... done
[17:36:37.659] - relayed: [n=2] TRUE, TRUE
[17:36:37.659] - queued futures: [n=2] TRUE, TRUE
[17:36:37.659] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:36:37.660]  length: 0 (resolved future 2)
[17:36:37.660] Relaying remaining futures
[17:36:37.660] signalConditionsASAP(NULL, pos=0) ...
[17:36:37.660] - nx: 2
[17:36:37.660] - relay: TRUE
[17:36:37.660] - stdout: TRUE
[17:36:37.660] - signal: TRUE
[17:36:37.660] - resignal: FALSE
[17:36:37.660] - force: TRUE
[17:36:37.660] - relayed: [n=2] TRUE, TRUE
[17:36:37.660] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:37.661] - relayed: [n=2] TRUE, TRUE
[17:36:37.661] - queued futures: [n=2] TRUE, TRUE
[17:36:37.661] signalConditionsASAP(NULL, pos=0) ... done
[17:36:37.661] resolve() on list ... DONE
[17:36:37.661] result() for ClusterFuture ...
[17:36:37.661] - result already collected: FutureResult
[17:36:37.661] result() for ClusterFuture ... done
[17:36:37.661] result() for ClusterFuture ...
[17:36:37.661] - result already collected: FutureResult
[17:36:37.661] result() for ClusterFuture ... done
[17:36:37.661] result() for ClusterFuture ...
[17:36:37.662] - result already collected: FutureResult
[17:36:37.662] result() for ClusterFuture ... done
[17:36:37.662] result() for ClusterFuture ...
[17:36:37.662] - result already collected: FutureResult
[17:36:37.662] result() for ClusterFuture ... done
[17:36:37.662]  - Number of value chunks collected: 2
[17:36:37.662] Resolving 2 futures (chunks) ... DONE
[17:36:37.662] Reducing values from 2 chunks ...
[17:36:37.662]  - Number of values collected after concatenation: 2
[17:36:37.662]  - Number of values expected: 2
[17:36:37.662] Reducing values from 2 chunks ... DONE
[17:36:37.662] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:36:37.663] getGlobalsAndPackagesXApply() ...
[17:36:37.663]  - future.globals: TRUE
[17:36:37.663] getGlobalsAndPackages() ...
[17:36:37.664] Searching for globals...
[17:36:37.665] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:37.665] Searching for globals ... DONE
[17:36:37.665] Resolving globals: FALSE
[17:36:37.665] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:36:37.666] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:36:37.666] - globals: [1] ‘FUN’
[17:36:37.666] - packages: [1] ‘stats’
[17:36:37.666] getGlobalsAndPackages() ... DONE
[17:36:37.666]  - globals found/used: [n=1] ‘FUN’
[17:36:37.666]  - needed namespaces: [n=1] ‘stats’
[17:36:37.666] Finding globals ... DONE
[17:36:37.666]  - use_args: TRUE
[17:36:37.666]  - Getting '...' globals ...
[17:36:37.667] resolve() on list ...
[17:36:37.667]  recursive: 0
[17:36:37.667]  length: 1
[17:36:37.667]  elements: ‘...’
[17:36:37.667]  length: 0 (resolved future 1)
[17:36:37.667] resolve() on list ... DONE
[17:36:37.667]    - '...' content: [n=0] 
[17:36:37.667] List of 1
[17:36:37.667]  $ ...: list()
[17:36:37.667]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:37.667]  - attr(*, "where")=List of 1
[17:36:37.667]   ..$ ...:<environment: 0x556d7627b370> 
[17:36:37.667]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:37.667]  - attr(*, "resolved")= logi TRUE
[17:36:37.667]  - attr(*, "total_size")= num NA
[17:36:37.670]  - Getting '...' globals ... DONE
[17:36:37.670] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:37.670] List of 2
[17:36:37.670]  $ ...future.FUN:function (x, ...)  
[17:36:37.670]  $ ...          : list()
[17:36:37.670]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:37.670]  - attr(*, "where")=List of 2
[17:36:37.670]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:37.670]   ..$ ...          :<environment: 0x556d7627b370> 
[17:36:37.670]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:37.670]  - attr(*, "resolved")= logi FALSE
[17:36:37.670]  - attr(*, "total_size")= num 1248
[17:36:37.673] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:37.673] getGlobalsAndPackagesXApply() ... DONE
[17:36:37.676] future_lapply() ...
[17:36:37.680] Number of chunks: 2
[17:36:37.680] getGlobalsAndPackagesXApply() ...
[17:36:37.680]  - future.globals: <name-value list> with names ‘list()’
[17:36:37.680]  - use_args: TRUE
[17:36:37.680] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:37.680] List of 2
[17:36:37.680]  $ ...          : list()
[17:36:37.680]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:37.680]  $ ...future.FUN:function (x, ...)  
[17:36:37.680]  - attr(*, "where")=List of 2
[17:36:37.680]   ..$ ...          :<environment: 0x556d7627b370> 
[17:36:37.680]   ..$ ...future.FUN:<environment: namespace:stats> 
[17:36:37.680]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:37.680]  - attr(*, "resolved")= logi FALSE
[17:36:37.680]  - attr(*, "total_size")= num NA
[17:36:37.683] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:37.683] getGlobalsAndPackagesXApply() ... DONE
[17:36:37.683] Number of futures (= number of chunks): 2
[17:36:37.683] Launching 2 futures (chunks) ...
[17:36:37.684] Chunk #1 of 2 ...
[17:36:37.684]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:37.684]  - seeds: <none>
[17:36:37.684]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.684] getGlobalsAndPackages() ...
[17:36:37.684] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.684] Resolving globals: FALSE
[17:36:37.684] Tweak future expression to call with '...' arguments ...
[17:36:37.685] {
[17:36:37.685]     do.call(function(...) {
[17:36:37.685]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.685]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:37.685]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.685]             on.exit(options(oopts), add = TRUE)
[17:36:37.685]         }
[17:36:37.685]         {
[17:36:37.685]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:37.685]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.685]                 ...future.FUN(...future.X_jj, ...)
[17:36:37.685]             })
[17:36:37.685]         }
[17:36:37.685]     }, args = future.call.arguments)
[17:36:37.685] }
[17:36:37.685] Tweak future expression to call with '...' arguments ... DONE
[17:36:37.685] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.685] - packages: [1] ‘stats’
[17:36:37.685] getGlobalsAndPackages() ... DONE
[17:36:37.686] run() for ‘Future’ ...
[17:36:37.686] - state: ‘created’
[17:36:37.686] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:37.700] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:37.700] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:37.700]   - Field: ‘node’
[17:36:37.700]   - Field: ‘label’
[17:36:37.700]   - Field: ‘local’
[17:36:37.700]   - Field: ‘owner’
[17:36:37.700]   - Field: ‘envir’
[17:36:37.700]   - Field: ‘workers’
[17:36:37.700]   - Field: ‘packages’
[17:36:37.701]   - Field: ‘gc’
[17:36:37.701]   - Field: ‘conditions’
[17:36:37.701]   - Field: ‘persistent’
[17:36:37.701]   - Field: ‘expr’
[17:36:37.701]   - Field: ‘uuid’
[17:36:37.701]   - Field: ‘seed’
[17:36:37.701]   - Field: ‘version’
[17:36:37.701]   - Field: ‘result’
[17:36:37.701]   - Field: ‘asynchronous’
[17:36:37.701]   - Field: ‘calls’
[17:36:37.701]   - Field: ‘globals’
[17:36:37.702]   - Field: ‘stdout’
[17:36:37.702]   - Field: ‘earlySignal’
[17:36:37.702]   - Field: ‘lazy’
[17:36:37.702]   - Field: ‘state’
[17:36:37.702] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:37.702] - Launch lazy future ...
[17:36:37.702] Packages needed by the future expression (n = 1): ‘stats’
[17:36:37.702] Packages needed by future strategies (n = 0): <none>
[17:36:37.703] {
[17:36:37.703]     {
[17:36:37.703]         {
[17:36:37.703]             ...future.startTime <- base::Sys.time()
[17:36:37.703]             {
[17:36:37.703]                 {
[17:36:37.703]                   {
[17:36:37.703]                     {
[17:36:37.703]                       {
[17:36:37.703]                         base::local({
[17:36:37.703]                           has_future <- base::requireNamespace("future", 
[17:36:37.703]                             quietly = TRUE)
[17:36:37.703]                           if (has_future) {
[17:36:37.703]                             ns <- base::getNamespace("future")
[17:36:37.703]                             version <- ns[[".package"]][["version"]]
[17:36:37.703]                             if (is.null(version)) 
[17:36:37.703]                               version <- utils::packageVersion("future")
[17:36:37.703]                           }
[17:36:37.703]                           else {
[17:36:37.703]                             version <- NULL
[17:36:37.703]                           }
[17:36:37.703]                           if (!has_future || version < "1.8.0") {
[17:36:37.703]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:37.703]                               "", base::R.version$version.string), 
[17:36:37.703]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:37.703]                                 base::R.version$platform, 8 * 
[17:36:37.703]                                   base::.Machine$sizeof.pointer), 
[17:36:37.703]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:37.703]                                 "release", "version")], collapse = " "), 
[17:36:37.703]                               hostname = base::Sys.info()[["nodename"]])
[17:36:37.703]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:37.703]                               info)
[17:36:37.703]                             info <- base::paste(info, collapse = "; ")
[17:36:37.703]                             if (!has_future) {
[17:36:37.703]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:37.703]                                 info)
[17:36:37.703]                             }
[17:36:37.703]                             else {
[17:36:37.703]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:37.703]                                 info, version)
[17:36:37.703]                             }
[17:36:37.703]                             base::stop(msg)
[17:36:37.703]                           }
[17:36:37.703]                         })
[17:36:37.703]                       }
[17:36:37.703]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:37.703]                       base::options(mc.cores = 1L)
[17:36:37.703]                     }
[17:36:37.703]                     base::local({
[17:36:37.703]                       for (pkg in "stats") {
[17:36:37.703]                         base::loadNamespace(pkg)
[17:36:37.703]                         base::library(pkg, character.only = TRUE)
[17:36:37.703]                       }
[17:36:37.703]                     })
[17:36:37.703]                   }
[17:36:37.703]                   ...future.strategy.old <- future::plan("list")
[17:36:37.703]                   options(future.plan = NULL)
[17:36:37.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:37.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:37.703]                 }
[17:36:37.703]                 ...future.workdir <- getwd()
[17:36:37.703]             }
[17:36:37.703]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:37.703]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:37.703]         }
[17:36:37.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:37.703]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:37.703]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:37.703]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:37.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:37.703]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:37.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:37.703]             base::names(...future.oldOptions))
[17:36:37.703]     }
[17:36:37.703]     if (FALSE) {
[17:36:37.703]     }
[17:36:37.703]     else {
[17:36:37.703]         if (TRUE) {
[17:36:37.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:37.703]                 open = "w")
[17:36:37.703]         }
[17:36:37.703]         else {
[17:36:37.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:37.703]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:37.703]         }
[17:36:37.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:37.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:37.703]             base::sink(type = "output", split = FALSE)
[17:36:37.703]             base::close(...future.stdout)
[17:36:37.703]         }, add = TRUE)
[17:36:37.703]     }
[17:36:37.703]     ...future.frame <- base::sys.nframe()
[17:36:37.703]     ...future.conditions <- base::list()
[17:36:37.703]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:37.703]     if (FALSE) {
[17:36:37.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:37.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:37.703]     }
[17:36:37.703]     ...future.result <- base::tryCatch({
[17:36:37.703]         base::withCallingHandlers({
[17:36:37.703]             ...future.value <- base::withVisible(base::local({
[17:36:37.703]                 ...future.makeSendCondition <- base::local({
[17:36:37.703]                   sendCondition <- NULL
[17:36:37.703]                   function(frame = 1L) {
[17:36:37.703]                     if (is.function(sendCondition)) 
[17:36:37.703]                       return(sendCondition)
[17:36:37.703]                     ns <- getNamespace("parallel")
[17:36:37.703]                     if (exists("sendData", mode = "function", 
[17:36:37.703]                       envir = ns)) {
[17:36:37.703]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:37.703]                         envir = ns)
[17:36:37.703]                       envir <- sys.frame(frame)
[17:36:37.703]                       master <- NULL
[17:36:37.703]                       while (!identical(envir, .GlobalEnv) && 
[17:36:37.703]                         !identical(envir, emptyenv())) {
[17:36:37.703]                         if (exists("master", mode = "list", envir = envir, 
[17:36:37.703]                           inherits = FALSE)) {
[17:36:37.703]                           master <- get("master", mode = "list", 
[17:36:37.703]                             envir = envir, inherits = FALSE)
[17:36:37.703]                           if (inherits(master, c("SOCKnode", 
[17:36:37.703]                             "SOCK0node"))) {
[17:36:37.703]                             sendCondition <<- function(cond) {
[17:36:37.703]                               data <- list(type = "VALUE", value = cond, 
[17:36:37.703]                                 success = TRUE)
[17:36:37.703]                               parallel_sendData(master, data)
[17:36:37.703]                             }
[17:36:37.703]                             return(sendCondition)
[17:36:37.703]                           }
[17:36:37.703]                         }
[17:36:37.703]                         frame <- frame + 1L
[17:36:37.703]                         envir <- sys.frame(frame)
[17:36:37.703]                       }
[17:36:37.703]                     }
[17:36:37.703]                     sendCondition <<- function(cond) NULL
[17:36:37.703]                   }
[17:36:37.703]                 })
[17:36:37.703]                 withCallingHandlers({
[17:36:37.703]                   {
[17:36:37.703]                     do.call(function(...) {
[17:36:37.703]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.703]                       if (!identical(...future.globals.maxSize.org, 
[17:36:37.703]                         ...future.globals.maxSize)) {
[17:36:37.703]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.703]                         on.exit(options(oopts), add = TRUE)
[17:36:37.703]                       }
[17:36:37.703]                       {
[17:36:37.703]                         lapply(seq_along(...future.elements_ii), 
[17:36:37.703]                           FUN = function(jj) {
[17:36:37.703]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.703]                             ...future.FUN(...future.X_jj, ...)
[17:36:37.703]                           })
[17:36:37.703]                       }
[17:36:37.703]                     }, args = future.call.arguments)
[17:36:37.703]                   }
[17:36:37.703]                 }, immediateCondition = function(cond) {
[17:36:37.703]                   sendCondition <- ...future.makeSendCondition()
[17:36:37.703]                   sendCondition(cond)
[17:36:37.703]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.703]                   {
[17:36:37.703]                     inherits <- base::inherits
[17:36:37.703]                     invokeRestart <- base::invokeRestart
[17:36:37.703]                     is.null <- base::is.null
[17:36:37.703]                     muffled <- FALSE
[17:36:37.703]                     if (inherits(cond, "message")) {
[17:36:37.703]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:37.703]                       if (muffled) 
[17:36:37.703]                         invokeRestart("muffleMessage")
[17:36:37.703]                     }
[17:36:37.703]                     else if (inherits(cond, "warning")) {
[17:36:37.703]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:37.703]                       if (muffled) 
[17:36:37.703]                         invokeRestart("muffleWarning")
[17:36:37.703]                     }
[17:36:37.703]                     else if (inherits(cond, "condition")) {
[17:36:37.703]                       if (!is.null(pattern)) {
[17:36:37.703]                         computeRestarts <- base::computeRestarts
[17:36:37.703]                         grepl <- base::grepl
[17:36:37.703]                         restarts <- computeRestarts(cond)
[17:36:37.703]                         for (restart in restarts) {
[17:36:37.703]                           name <- restart$name
[17:36:37.703]                           if (is.null(name)) 
[17:36:37.703]                             next
[17:36:37.703]                           if (!grepl(pattern, name)) 
[17:36:37.703]                             next
[17:36:37.703]                           invokeRestart(restart)
[17:36:37.703]                           muffled <- TRUE
[17:36:37.703]                           break
[17:36:37.703]                         }
[17:36:37.703]                       }
[17:36:37.703]                     }
[17:36:37.703]                     invisible(muffled)
[17:36:37.703]                   }
[17:36:37.703]                   muffleCondition(cond)
[17:36:37.703]                 })
[17:36:37.703]             }))
[17:36:37.703]             future::FutureResult(value = ...future.value$value, 
[17:36:37.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:37.703]                   ...future.rng), globalenv = if (FALSE) 
[17:36:37.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:37.703]                     ...future.globalenv.names))
[17:36:37.703]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:37.703]         }, condition = base::local({
[17:36:37.703]             c <- base::c
[17:36:37.703]             inherits <- base::inherits
[17:36:37.703]             invokeRestart <- base::invokeRestart
[17:36:37.703]             length <- base::length
[17:36:37.703]             list <- base::list
[17:36:37.703]             seq.int <- base::seq.int
[17:36:37.703]             signalCondition <- base::signalCondition
[17:36:37.703]             sys.calls <- base::sys.calls
[17:36:37.703]             `[[` <- base::`[[`
[17:36:37.703]             `+` <- base::`+`
[17:36:37.703]             `<<-` <- base::`<<-`
[17:36:37.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:37.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:37.703]                   3L)]
[17:36:37.703]             }
[17:36:37.703]             function(cond) {
[17:36:37.703]                 is_error <- inherits(cond, "error")
[17:36:37.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:37.703]                   NULL)
[17:36:37.703]                 if (is_error) {
[17:36:37.703]                   sessionInformation <- function() {
[17:36:37.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:37.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:37.703]                       search = base::search(), system = base::Sys.info())
[17:36:37.703]                   }
[17:36:37.703]                   ...future.conditions[[length(...future.conditions) + 
[17:36:37.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:37.703]                     cond$call), session = sessionInformation(), 
[17:36:37.703]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:37.703]                   signalCondition(cond)
[17:36:37.703]                 }
[17:36:37.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:37.703]                 "immediateCondition"))) {
[17:36:37.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:37.703]                   ...future.conditions[[length(...future.conditions) + 
[17:36:37.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:37.703]                   if (TRUE && !signal) {
[17:36:37.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.703]                     {
[17:36:37.703]                       inherits <- base::inherits
[17:36:37.703]                       invokeRestart <- base::invokeRestart
[17:36:37.703]                       is.null <- base::is.null
[17:36:37.703]                       muffled <- FALSE
[17:36:37.703]                       if (inherits(cond, "message")) {
[17:36:37.703]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:37.703]                         if (muffled) 
[17:36:37.703]                           invokeRestart("muffleMessage")
[17:36:37.703]                       }
[17:36:37.703]                       else if (inherits(cond, "warning")) {
[17:36:37.703]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:37.703]                         if (muffled) 
[17:36:37.703]                           invokeRestart("muffleWarning")
[17:36:37.703]                       }
[17:36:37.703]                       else if (inherits(cond, "condition")) {
[17:36:37.703]                         if (!is.null(pattern)) {
[17:36:37.703]                           computeRestarts <- base::computeRestarts
[17:36:37.703]                           grepl <- base::grepl
[17:36:37.703]                           restarts <- computeRestarts(cond)
[17:36:37.703]                           for (restart in restarts) {
[17:36:37.703]                             name <- restart$name
[17:36:37.703]                             if (is.null(name)) 
[17:36:37.703]                               next
[17:36:37.703]                             if (!grepl(pattern, name)) 
[17:36:37.703]                               next
[17:36:37.703]                             invokeRestart(restart)
[17:36:37.703]                             muffled <- TRUE
[17:36:37.703]                             break
[17:36:37.703]                           }
[17:36:37.703]                         }
[17:36:37.703]                       }
[17:36:37.703]                       invisible(muffled)
[17:36:37.703]                     }
[17:36:37.703]                     muffleCondition(cond, pattern = "^muffle")
[17:36:37.703]                   }
[17:36:37.703]                 }
[17:36:37.703]                 else {
[17:36:37.703]                   if (TRUE) {
[17:36:37.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.703]                     {
[17:36:37.703]                       inherits <- base::inherits
[17:36:37.703]                       invokeRestart <- base::invokeRestart
[17:36:37.703]                       is.null <- base::is.null
[17:36:37.703]                       muffled <- FALSE
[17:36:37.703]                       if (inherits(cond, "message")) {
[17:36:37.703]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:37.703]                         if (muffled) 
[17:36:37.703]                           invokeRestart("muffleMessage")
[17:36:37.703]                       }
[17:36:37.703]                       else if (inherits(cond, "warning")) {
[17:36:37.703]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:37.703]                         if (muffled) 
[17:36:37.703]                           invokeRestart("muffleWarning")
[17:36:37.703]                       }
[17:36:37.703]                       else if (inherits(cond, "condition")) {
[17:36:37.703]                         if (!is.null(pattern)) {
[17:36:37.703]                           computeRestarts <- base::computeRestarts
[17:36:37.703]                           grepl <- base::grepl
[17:36:37.703]                           restarts <- computeRestarts(cond)
[17:36:37.703]                           for (restart in restarts) {
[17:36:37.703]                             name <- restart$name
[17:36:37.703]                             if (is.null(name)) 
[17:36:37.703]                               next
[17:36:37.703]                             if (!grepl(pattern, name)) 
[17:36:37.703]                               next
[17:36:37.703]                             invokeRestart(restart)
[17:36:37.703]                             muffled <- TRUE
[17:36:37.703]                             break
[17:36:37.703]                           }
[17:36:37.703]                         }
[17:36:37.703]                       }
[17:36:37.703]                       invisible(muffled)
[17:36:37.703]                     }
[17:36:37.703]                     muffleCondition(cond, pattern = "^muffle")
[17:36:37.703]                   }
[17:36:37.703]                 }
[17:36:37.703]             }
[17:36:37.703]         }))
[17:36:37.703]     }, error = function(ex) {
[17:36:37.703]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:37.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:37.703]                 ...future.rng), started = ...future.startTime, 
[17:36:37.703]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:37.703]             version = "1.8"), class = "FutureResult")
[17:36:37.703]     }, finally = {
[17:36:37.703]         if (!identical(...future.workdir, getwd())) 
[17:36:37.703]             setwd(...future.workdir)
[17:36:37.703]         {
[17:36:37.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:37.703]                 ...future.oldOptions$nwarnings <- NULL
[17:36:37.703]             }
[17:36:37.703]             base::options(...future.oldOptions)
[17:36:37.703]             if (.Platform$OS.type == "windows") {
[17:36:37.703]                 old_names <- names(...future.oldEnvVars)
[17:36:37.703]                 envs <- base::Sys.getenv()
[17:36:37.703]                 names <- names(envs)
[17:36:37.703]                 common <- intersect(names, old_names)
[17:36:37.703]                 added <- setdiff(names, old_names)
[17:36:37.703]                 removed <- setdiff(old_names, names)
[17:36:37.703]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:37.703]                   envs[common]]
[17:36:37.703]                 NAMES <- toupper(changed)
[17:36:37.703]                 args <- list()
[17:36:37.703]                 for (kk in seq_along(NAMES)) {
[17:36:37.703]                   name <- changed[[kk]]
[17:36:37.703]                   NAME <- NAMES[[kk]]
[17:36:37.703]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.703]                     next
[17:36:37.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:37.703]                 }
[17:36:37.703]                 NAMES <- toupper(added)
[17:36:37.703]                 for (kk in seq_along(NAMES)) {
[17:36:37.703]                   name <- added[[kk]]
[17:36:37.703]                   NAME <- NAMES[[kk]]
[17:36:37.703]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.703]                     next
[17:36:37.703]                   args[[name]] <- ""
[17:36:37.703]                 }
[17:36:37.703]                 NAMES <- toupper(removed)
[17:36:37.703]                 for (kk in seq_along(NAMES)) {
[17:36:37.703]                   name <- removed[[kk]]
[17:36:37.703]                   NAME <- NAMES[[kk]]
[17:36:37.703]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.703]                     next
[17:36:37.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:37.703]                 }
[17:36:37.703]                 if (length(args) > 0) 
[17:36:37.703]                   base::do.call(base::Sys.setenv, args = args)
[17:36:37.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:37.703]             }
[17:36:37.703]             else {
[17:36:37.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:37.703]             }
[17:36:37.703]             {
[17:36:37.703]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:37.703]                   0L) {
[17:36:37.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:37.703]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:37.703]                   base::options(opts)
[17:36:37.703]                 }
[17:36:37.703]                 {
[17:36:37.703]                   {
[17:36:37.703]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:37.703]                     NULL
[17:36:37.703]                   }
[17:36:37.703]                   options(future.plan = NULL)
[17:36:37.703]                   if (is.na(NA_character_)) 
[17:36:37.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:37.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:37.703]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:37.703]                     .init = FALSE)
[17:36:37.703]                 }
[17:36:37.703]             }
[17:36:37.703]         }
[17:36:37.703]     })
[17:36:37.703]     if (TRUE) {
[17:36:37.703]         base::sink(type = "output", split = FALSE)
[17:36:37.703]         if (TRUE) {
[17:36:37.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:37.703]         }
[17:36:37.703]         else {
[17:36:37.703]             ...future.result["stdout"] <- base::list(NULL)
[17:36:37.703]         }
[17:36:37.703]         base::close(...future.stdout)
[17:36:37.703]         ...future.stdout <- NULL
[17:36:37.703]     }
[17:36:37.703]     ...future.result$conditions <- ...future.conditions
[17:36:37.703]     ...future.result$finished <- base::Sys.time()
[17:36:37.703]     ...future.result
[17:36:37.703] }
[17:36:37.706] Exporting 5 global objects (1.35 KiB) to cluster node #1 ...
[17:36:37.706] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:36:37.707] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:36:37.707] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[17:36:37.707] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[17:36:37.707] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[17:36:37.708] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[17:36:37.708] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:36:37.708] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:36:37.709] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:36:37.709] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:36:37.709] Exporting 5 global objects (1.35 KiB) to cluster node #1 ... DONE
[17:36:37.710] MultisessionFuture started
[17:36:37.710] - Launch lazy future ... done
[17:36:37.710] run() for ‘MultisessionFuture’ ... done
[17:36:37.710] Created future:
[17:36:37.710] MultisessionFuture:
[17:36:37.710] Label: ‘future_apply-1’
[17:36:37.710] Expression:
[17:36:37.710] {
[17:36:37.710]     do.call(function(...) {
[17:36:37.710]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.710]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:37.710]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.710]             on.exit(options(oopts), add = TRUE)
[17:36:37.710]         }
[17:36:37.710]         {
[17:36:37.710]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:37.710]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.710]                 ...future.FUN(...future.X_jj, ...)
[17:36:37.710]             })
[17:36:37.710]         }
[17:36:37.710]     }, args = future.call.arguments)
[17:36:37.710] }
[17:36:37.710] Lazy evaluation: FALSE
[17:36:37.710] Asynchronous evaluation: TRUE
[17:36:37.710] Local evaluation: TRUE
[17:36:37.710] Environment: R_GlobalEnv
[17:36:37.710] Capture standard output: TRUE
[17:36:37.710] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:37.710] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:37.710] Packages: 1 packages (‘stats’)
[17:36:37.710] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:37.710] Resolved: FALSE
[17:36:37.710] Value: <not collected>
[17:36:37.710] Conditions captured: <none>
[17:36:37.710] Early signaling: FALSE
[17:36:37.710] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:37.710] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:37.722] Chunk #1 of 2 ... DONE
[17:36:37.722] Chunk #2 of 2 ...
[17:36:37.722]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:37.722]  - seeds: <none>
[17:36:37.722]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.722] getGlobalsAndPackages() ...
[17:36:37.722] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.722] Resolving globals: FALSE
[17:36:37.723] Tweak future expression to call with '...' arguments ...
[17:36:37.723] {
[17:36:37.723]     do.call(function(...) {
[17:36:37.723]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.723]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:37.723]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.723]             on.exit(options(oopts), add = TRUE)
[17:36:37.723]         }
[17:36:37.723]         {
[17:36:37.723]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:37.723]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.723]                 ...future.FUN(...future.X_jj, ...)
[17:36:37.723]             })
[17:36:37.723]         }
[17:36:37.723]     }, args = future.call.arguments)
[17:36:37.723] }
[17:36:37.723] Tweak future expression to call with '...' arguments ... DONE
[17:36:37.723] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.724] - packages: [1] ‘stats’
[17:36:37.724] getGlobalsAndPackages() ... DONE
[17:36:37.724] run() for ‘Future’ ...
[17:36:37.724] - state: ‘created’
[17:36:37.724] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:37.738] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:37.738] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:37.738]   - Field: ‘node’
[17:36:37.739]   - Field: ‘label’
[17:36:37.739]   - Field: ‘local’
[17:36:37.739]   - Field: ‘owner’
[17:36:37.739]   - Field: ‘envir’
[17:36:37.739]   - Field: ‘workers’
[17:36:37.739]   - Field: ‘packages’
[17:36:37.739]   - Field: ‘gc’
[17:36:37.739]   - Field: ‘conditions’
[17:36:37.739]   - Field: ‘persistent’
[17:36:37.739]   - Field: ‘expr’
[17:36:37.740]   - Field: ‘uuid’
[17:36:37.740]   - Field: ‘seed’
[17:36:37.740]   - Field: ‘version’
[17:36:37.740]   - Field: ‘result’
[17:36:37.740]   - Field: ‘asynchronous’
[17:36:37.740]   - Field: ‘calls’
[17:36:37.740]   - Field: ‘globals’
[17:36:37.740]   - Field: ‘stdout’
[17:36:37.740]   - Field: ‘earlySignal’
[17:36:37.740]   - Field: ‘lazy’
[17:36:37.740]   - Field: ‘state’
[17:36:37.741] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:37.741] - Launch lazy future ...
[17:36:37.741] Packages needed by the future expression (n = 1): ‘stats’
[17:36:37.741] Packages needed by future strategies (n = 0): <none>
[17:36:37.742] {
[17:36:37.742]     {
[17:36:37.742]         {
[17:36:37.742]             ...future.startTime <- base::Sys.time()
[17:36:37.742]             {
[17:36:37.742]                 {
[17:36:37.742]                   {
[17:36:37.742]                     {
[17:36:37.742]                       {
[17:36:37.742]                         base::local({
[17:36:37.742]                           has_future <- base::requireNamespace("future", 
[17:36:37.742]                             quietly = TRUE)
[17:36:37.742]                           if (has_future) {
[17:36:37.742]                             ns <- base::getNamespace("future")
[17:36:37.742]                             version <- ns[[".package"]][["version"]]
[17:36:37.742]                             if (is.null(version)) 
[17:36:37.742]                               version <- utils::packageVersion("future")
[17:36:37.742]                           }
[17:36:37.742]                           else {
[17:36:37.742]                             version <- NULL
[17:36:37.742]                           }
[17:36:37.742]                           if (!has_future || version < "1.8.0") {
[17:36:37.742]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:37.742]                               "", base::R.version$version.string), 
[17:36:37.742]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:37.742]                                 base::R.version$platform, 8 * 
[17:36:37.742]                                   base::.Machine$sizeof.pointer), 
[17:36:37.742]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:37.742]                                 "release", "version")], collapse = " "), 
[17:36:37.742]                               hostname = base::Sys.info()[["nodename"]])
[17:36:37.742]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:37.742]                               info)
[17:36:37.742]                             info <- base::paste(info, collapse = "; ")
[17:36:37.742]                             if (!has_future) {
[17:36:37.742]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:37.742]                                 info)
[17:36:37.742]                             }
[17:36:37.742]                             else {
[17:36:37.742]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:37.742]                                 info, version)
[17:36:37.742]                             }
[17:36:37.742]                             base::stop(msg)
[17:36:37.742]                           }
[17:36:37.742]                         })
[17:36:37.742]                       }
[17:36:37.742]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:37.742]                       base::options(mc.cores = 1L)
[17:36:37.742]                     }
[17:36:37.742]                     base::local({
[17:36:37.742]                       for (pkg in "stats") {
[17:36:37.742]                         base::loadNamespace(pkg)
[17:36:37.742]                         base::library(pkg, character.only = TRUE)
[17:36:37.742]                       }
[17:36:37.742]                     })
[17:36:37.742]                   }
[17:36:37.742]                   ...future.strategy.old <- future::plan("list")
[17:36:37.742]                   options(future.plan = NULL)
[17:36:37.742]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:37.742]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:37.742]                 }
[17:36:37.742]                 ...future.workdir <- getwd()
[17:36:37.742]             }
[17:36:37.742]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:37.742]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:37.742]         }
[17:36:37.742]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:37.742]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:37.742]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:37.742]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:37.742]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:37.742]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:37.742]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:37.742]             base::names(...future.oldOptions))
[17:36:37.742]     }
[17:36:37.742]     if (FALSE) {
[17:36:37.742]     }
[17:36:37.742]     else {
[17:36:37.742]         if (TRUE) {
[17:36:37.742]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:37.742]                 open = "w")
[17:36:37.742]         }
[17:36:37.742]         else {
[17:36:37.742]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:37.742]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:37.742]         }
[17:36:37.742]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:37.742]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:37.742]             base::sink(type = "output", split = FALSE)
[17:36:37.742]             base::close(...future.stdout)
[17:36:37.742]         }, add = TRUE)
[17:36:37.742]     }
[17:36:37.742]     ...future.frame <- base::sys.nframe()
[17:36:37.742]     ...future.conditions <- base::list()
[17:36:37.742]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:37.742]     if (FALSE) {
[17:36:37.742]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:37.742]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:37.742]     }
[17:36:37.742]     ...future.result <- base::tryCatch({
[17:36:37.742]         base::withCallingHandlers({
[17:36:37.742]             ...future.value <- base::withVisible(base::local({
[17:36:37.742]                 ...future.makeSendCondition <- base::local({
[17:36:37.742]                   sendCondition <- NULL
[17:36:37.742]                   function(frame = 1L) {
[17:36:37.742]                     if (is.function(sendCondition)) 
[17:36:37.742]                       return(sendCondition)
[17:36:37.742]                     ns <- getNamespace("parallel")
[17:36:37.742]                     if (exists("sendData", mode = "function", 
[17:36:37.742]                       envir = ns)) {
[17:36:37.742]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:37.742]                         envir = ns)
[17:36:37.742]                       envir <- sys.frame(frame)
[17:36:37.742]                       master <- NULL
[17:36:37.742]                       while (!identical(envir, .GlobalEnv) && 
[17:36:37.742]                         !identical(envir, emptyenv())) {
[17:36:37.742]                         if (exists("master", mode = "list", envir = envir, 
[17:36:37.742]                           inherits = FALSE)) {
[17:36:37.742]                           master <- get("master", mode = "list", 
[17:36:37.742]                             envir = envir, inherits = FALSE)
[17:36:37.742]                           if (inherits(master, c("SOCKnode", 
[17:36:37.742]                             "SOCK0node"))) {
[17:36:37.742]                             sendCondition <<- function(cond) {
[17:36:37.742]                               data <- list(type = "VALUE", value = cond, 
[17:36:37.742]                                 success = TRUE)
[17:36:37.742]                               parallel_sendData(master, data)
[17:36:37.742]                             }
[17:36:37.742]                             return(sendCondition)
[17:36:37.742]                           }
[17:36:37.742]                         }
[17:36:37.742]                         frame <- frame + 1L
[17:36:37.742]                         envir <- sys.frame(frame)
[17:36:37.742]                       }
[17:36:37.742]                     }
[17:36:37.742]                     sendCondition <<- function(cond) NULL
[17:36:37.742]                   }
[17:36:37.742]                 })
[17:36:37.742]                 withCallingHandlers({
[17:36:37.742]                   {
[17:36:37.742]                     do.call(function(...) {
[17:36:37.742]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.742]                       if (!identical(...future.globals.maxSize.org, 
[17:36:37.742]                         ...future.globals.maxSize)) {
[17:36:37.742]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.742]                         on.exit(options(oopts), add = TRUE)
[17:36:37.742]                       }
[17:36:37.742]                       {
[17:36:37.742]                         lapply(seq_along(...future.elements_ii), 
[17:36:37.742]                           FUN = function(jj) {
[17:36:37.742]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.742]                             ...future.FUN(...future.X_jj, ...)
[17:36:37.742]                           })
[17:36:37.742]                       }
[17:36:37.742]                     }, args = future.call.arguments)
[17:36:37.742]                   }
[17:36:37.742]                 }, immediateCondition = function(cond) {
[17:36:37.742]                   sendCondition <- ...future.makeSendCondition()
[17:36:37.742]                   sendCondition(cond)
[17:36:37.742]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.742]                   {
[17:36:37.742]                     inherits <- base::inherits
[17:36:37.742]                     invokeRestart <- base::invokeRestart
[17:36:37.742]                     is.null <- base::is.null
[17:36:37.742]                     muffled <- FALSE
[17:36:37.742]                     if (inherits(cond, "message")) {
[17:36:37.742]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:37.742]                       if (muffled) 
[17:36:37.742]                         invokeRestart("muffleMessage")
[17:36:37.742]                     }
[17:36:37.742]                     else if (inherits(cond, "warning")) {
[17:36:37.742]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:37.742]                       if (muffled) 
[17:36:37.742]                         invokeRestart("muffleWarning")
[17:36:37.742]                     }
[17:36:37.742]                     else if (inherits(cond, "condition")) {
[17:36:37.742]                       if (!is.null(pattern)) {
[17:36:37.742]                         computeRestarts <- base::computeRestarts
[17:36:37.742]                         grepl <- base::grepl
[17:36:37.742]                         restarts <- computeRestarts(cond)
[17:36:37.742]                         for (restart in restarts) {
[17:36:37.742]                           name <- restart$name
[17:36:37.742]                           if (is.null(name)) 
[17:36:37.742]                             next
[17:36:37.742]                           if (!grepl(pattern, name)) 
[17:36:37.742]                             next
[17:36:37.742]                           invokeRestart(restart)
[17:36:37.742]                           muffled <- TRUE
[17:36:37.742]                           break
[17:36:37.742]                         }
[17:36:37.742]                       }
[17:36:37.742]                     }
[17:36:37.742]                     invisible(muffled)
[17:36:37.742]                   }
[17:36:37.742]                   muffleCondition(cond)
[17:36:37.742]                 })
[17:36:37.742]             }))
[17:36:37.742]             future::FutureResult(value = ...future.value$value, 
[17:36:37.742]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:37.742]                   ...future.rng), globalenv = if (FALSE) 
[17:36:37.742]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:37.742]                     ...future.globalenv.names))
[17:36:37.742]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:37.742]         }, condition = base::local({
[17:36:37.742]             c <- base::c
[17:36:37.742]             inherits <- base::inherits
[17:36:37.742]             invokeRestart <- base::invokeRestart
[17:36:37.742]             length <- base::length
[17:36:37.742]             list <- base::list
[17:36:37.742]             seq.int <- base::seq.int
[17:36:37.742]             signalCondition <- base::signalCondition
[17:36:37.742]             sys.calls <- base::sys.calls
[17:36:37.742]             `[[` <- base::`[[`
[17:36:37.742]             `+` <- base::`+`
[17:36:37.742]             `<<-` <- base::`<<-`
[17:36:37.742]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:37.742]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:37.742]                   3L)]
[17:36:37.742]             }
[17:36:37.742]             function(cond) {
[17:36:37.742]                 is_error <- inherits(cond, "error")
[17:36:37.742]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:37.742]                   NULL)
[17:36:37.742]                 if (is_error) {
[17:36:37.742]                   sessionInformation <- function() {
[17:36:37.742]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:37.742]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:37.742]                       search = base::search(), system = base::Sys.info())
[17:36:37.742]                   }
[17:36:37.742]                   ...future.conditions[[length(...future.conditions) + 
[17:36:37.742]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:37.742]                     cond$call), session = sessionInformation(), 
[17:36:37.742]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:37.742]                   signalCondition(cond)
[17:36:37.742]                 }
[17:36:37.742]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:37.742]                 "immediateCondition"))) {
[17:36:37.742]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:37.742]                   ...future.conditions[[length(...future.conditions) + 
[17:36:37.742]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:37.742]                   if (TRUE && !signal) {
[17:36:37.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.742]                     {
[17:36:37.742]                       inherits <- base::inherits
[17:36:37.742]                       invokeRestart <- base::invokeRestart
[17:36:37.742]                       is.null <- base::is.null
[17:36:37.742]                       muffled <- FALSE
[17:36:37.742]                       if (inherits(cond, "message")) {
[17:36:37.742]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:37.742]                         if (muffled) 
[17:36:37.742]                           invokeRestart("muffleMessage")
[17:36:37.742]                       }
[17:36:37.742]                       else if (inherits(cond, "warning")) {
[17:36:37.742]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:37.742]                         if (muffled) 
[17:36:37.742]                           invokeRestart("muffleWarning")
[17:36:37.742]                       }
[17:36:37.742]                       else if (inherits(cond, "condition")) {
[17:36:37.742]                         if (!is.null(pattern)) {
[17:36:37.742]                           computeRestarts <- base::computeRestarts
[17:36:37.742]                           grepl <- base::grepl
[17:36:37.742]                           restarts <- computeRestarts(cond)
[17:36:37.742]                           for (restart in restarts) {
[17:36:37.742]                             name <- restart$name
[17:36:37.742]                             if (is.null(name)) 
[17:36:37.742]                               next
[17:36:37.742]                             if (!grepl(pattern, name)) 
[17:36:37.742]                               next
[17:36:37.742]                             invokeRestart(restart)
[17:36:37.742]                             muffled <- TRUE
[17:36:37.742]                             break
[17:36:37.742]                           }
[17:36:37.742]                         }
[17:36:37.742]                       }
[17:36:37.742]                       invisible(muffled)
[17:36:37.742]                     }
[17:36:37.742]                     muffleCondition(cond, pattern = "^muffle")
[17:36:37.742]                   }
[17:36:37.742]                 }
[17:36:37.742]                 else {
[17:36:37.742]                   if (TRUE) {
[17:36:37.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.742]                     {
[17:36:37.742]                       inherits <- base::inherits
[17:36:37.742]                       invokeRestart <- base::invokeRestart
[17:36:37.742]                       is.null <- base::is.null
[17:36:37.742]                       muffled <- FALSE
[17:36:37.742]                       if (inherits(cond, "message")) {
[17:36:37.742]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:37.742]                         if (muffled) 
[17:36:37.742]                           invokeRestart("muffleMessage")
[17:36:37.742]                       }
[17:36:37.742]                       else if (inherits(cond, "warning")) {
[17:36:37.742]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:37.742]                         if (muffled) 
[17:36:37.742]                           invokeRestart("muffleWarning")
[17:36:37.742]                       }
[17:36:37.742]                       else if (inherits(cond, "condition")) {
[17:36:37.742]                         if (!is.null(pattern)) {
[17:36:37.742]                           computeRestarts <- base::computeRestarts
[17:36:37.742]                           grepl <- base::grepl
[17:36:37.742]                           restarts <- computeRestarts(cond)
[17:36:37.742]                           for (restart in restarts) {
[17:36:37.742]                             name <- restart$name
[17:36:37.742]                             if (is.null(name)) 
[17:36:37.742]                               next
[17:36:37.742]                             if (!grepl(pattern, name)) 
[17:36:37.742]                               next
[17:36:37.742]                             invokeRestart(restart)
[17:36:37.742]                             muffled <- TRUE
[17:36:37.742]                             break
[17:36:37.742]                           }
[17:36:37.742]                         }
[17:36:37.742]                       }
[17:36:37.742]                       invisible(muffled)
[17:36:37.742]                     }
[17:36:37.742]                     muffleCondition(cond, pattern = "^muffle")
[17:36:37.742]                   }
[17:36:37.742]                 }
[17:36:37.742]             }
[17:36:37.742]         }))
[17:36:37.742]     }, error = function(ex) {
[17:36:37.742]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:37.742]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:37.742]                 ...future.rng), started = ...future.startTime, 
[17:36:37.742]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:37.742]             version = "1.8"), class = "FutureResult")
[17:36:37.742]     }, finally = {
[17:36:37.742]         if (!identical(...future.workdir, getwd())) 
[17:36:37.742]             setwd(...future.workdir)
[17:36:37.742]         {
[17:36:37.742]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:37.742]                 ...future.oldOptions$nwarnings <- NULL
[17:36:37.742]             }
[17:36:37.742]             base::options(...future.oldOptions)
[17:36:37.742]             if (.Platform$OS.type == "windows") {
[17:36:37.742]                 old_names <- names(...future.oldEnvVars)
[17:36:37.742]                 envs <- base::Sys.getenv()
[17:36:37.742]                 names <- names(envs)
[17:36:37.742]                 common <- intersect(names, old_names)
[17:36:37.742]                 added <- setdiff(names, old_names)
[17:36:37.742]                 removed <- setdiff(old_names, names)
[17:36:37.742]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:37.742]                   envs[common]]
[17:36:37.742]                 NAMES <- toupper(changed)
[17:36:37.742]                 args <- list()
[17:36:37.742]                 for (kk in seq_along(NAMES)) {
[17:36:37.742]                   name <- changed[[kk]]
[17:36:37.742]                   NAME <- NAMES[[kk]]
[17:36:37.742]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.742]                     next
[17:36:37.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:37.742]                 }
[17:36:37.742]                 NAMES <- toupper(added)
[17:36:37.742]                 for (kk in seq_along(NAMES)) {
[17:36:37.742]                   name <- added[[kk]]
[17:36:37.742]                   NAME <- NAMES[[kk]]
[17:36:37.742]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.742]                     next
[17:36:37.742]                   args[[name]] <- ""
[17:36:37.742]                 }
[17:36:37.742]                 NAMES <- toupper(removed)
[17:36:37.742]                 for (kk in seq_along(NAMES)) {
[17:36:37.742]                   name <- removed[[kk]]
[17:36:37.742]                   NAME <- NAMES[[kk]]
[17:36:37.742]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.742]                     next
[17:36:37.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:37.742]                 }
[17:36:37.742]                 if (length(args) > 0) 
[17:36:37.742]                   base::do.call(base::Sys.setenv, args = args)
[17:36:37.742]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:37.742]             }
[17:36:37.742]             else {
[17:36:37.742]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:37.742]             }
[17:36:37.742]             {
[17:36:37.742]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:37.742]                   0L) {
[17:36:37.742]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:37.742]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:37.742]                   base::options(opts)
[17:36:37.742]                 }
[17:36:37.742]                 {
[17:36:37.742]                   {
[17:36:37.742]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:37.742]                     NULL
[17:36:37.742]                   }
[17:36:37.742]                   options(future.plan = NULL)
[17:36:37.742]                   if (is.na(NA_character_)) 
[17:36:37.742]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:37.742]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:37.742]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:37.742]                     .init = FALSE)
[17:36:37.742]                 }
[17:36:37.742]             }
[17:36:37.742]         }
[17:36:37.742]     })
[17:36:37.742]     if (TRUE) {
[17:36:37.742]         base::sink(type = "output", split = FALSE)
[17:36:37.742]         if (TRUE) {
[17:36:37.742]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:37.742]         }
[17:36:37.742]         else {
[17:36:37.742]             ...future.result["stdout"] <- base::list(NULL)
[17:36:37.742]         }
[17:36:37.742]         base::close(...future.stdout)
[17:36:37.742]         ...future.stdout <- NULL
[17:36:37.742]     }
[17:36:37.742]     ...future.result$conditions <- ...future.conditions
[17:36:37.742]     ...future.result$finished <- base::Sys.time()
[17:36:37.742]     ...future.result
[17:36:37.742] }
[17:36:37.745] Exporting 5 global objects (1.35 KiB) to cluster node #2 ...
[17:36:37.745] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:36:37.746] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:36:37.746] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[17:36:37.746] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[17:36:37.746] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[17:36:37.747] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[17:36:37.747] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:36:37.747] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:36:37.747] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:36:37.748] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:36:37.748] Exporting 5 global objects (1.35 KiB) to cluster node #2 ... DONE
[17:36:37.749] MultisessionFuture started
[17:36:37.749] - Launch lazy future ... done
[17:36:37.749] run() for ‘MultisessionFuture’ ... done
[17:36:37.749] Created future:
[17:36:37.749] MultisessionFuture:
[17:36:37.749] Label: ‘future_apply-2’
[17:36:37.749] Expression:
[17:36:37.749] {
[17:36:37.749]     do.call(function(...) {
[17:36:37.749]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.749]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:37.749]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.749]             on.exit(options(oopts), add = TRUE)
[17:36:37.749]         }
[17:36:37.749]         {
[17:36:37.749]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:37.749]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.749]                 ...future.FUN(...future.X_jj, ...)
[17:36:37.749]             })
[17:36:37.749]         }
[17:36:37.749]     }, args = future.call.arguments)
[17:36:37.749] }
[17:36:37.749] Lazy evaluation: FALSE
[17:36:37.749] Asynchronous evaluation: TRUE
[17:36:37.749] Local evaluation: TRUE
[17:36:37.749] Environment: R_GlobalEnv
[17:36:37.749] Capture standard output: TRUE
[17:36:37.749] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:37.749] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:37.749] Packages: 1 packages (‘stats’)
[17:36:37.749] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:37.749] Resolved: FALSE
[17:36:37.749] Value: <not collected>
[17:36:37.749] Conditions captured: <none>
[17:36:37.749] Early signaling: FALSE
[17:36:37.749] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:37.749] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:37.761] Chunk #2 of 2 ... DONE
[17:36:37.761] Launching 2 futures (chunks) ... DONE
[17:36:37.761] Resolving 2 futures (chunks) ...
[17:36:37.761] resolve() on list ...
[17:36:37.761]  recursive: 0
[17:36:37.761]  length: 2
[17:36:37.762] 
[17:36:37.762] receiveMessageFromWorker() for ClusterFuture ...
[17:36:37.762] - Validating connection of MultisessionFuture
[17:36:37.762] - received message: FutureResult
[17:36:37.763] - Received FutureResult
[17:36:37.763] - Erased future from FutureRegistry
[17:36:37.763] result() for ClusterFuture ...
[17:36:37.763] - result already collected: FutureResult
[17:36:37.763] result() for ClusterFuture ... done
[17:36:37.763] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:37.763] Future #1
[17:36:37.763] result() for ClusterFuture ...
[17:36:37.763] - result already collected: FutureResult
[17:36:37.763] result() for ClusterFuture ... done
[17:36:37.763] result() for ClusterFuture ...
[17:36:37.764] - result already collected: FutureResult
[17:36:37.764] result() for ClusterFuture ... done
[17:36:37.764] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:36:37.764] - nx: 2
[17:36:37.764] - relay: TRUE
[17:36:37.764] - stdout: TRUE
[17:36:37.764] - signal: TRUE
[17:36:37.764] - resignal: FALSE
[17:36:37.764] - force: TRUE
[17:36:37.764] - relayed: [n=2] FALSE, FALSE
[17:36:37.764] - queued futures: [n=2] FALSE, FALSE
[17:36:37.765]  - until=1
[17:36:37.765]  - relaying element #1
[17:36:37.765] result() for ClusterFuture ...
[17:36:37.765] - result already collected: FutureResult
[17:36:37.765] result() for ClusterFuture ... done
[17:36:37.765] result() for ClusterFuture ...
[17:36:37.765] - result already collected: FutureResult
[17:36:37.765] result() for ClusterFuture ... done
[17:36:37.765] result() for ClusterFuture ...
[17:36:37.765] - result already collected: FutureResult
[17:36:37.765] result() for ClusterFuture ... done
[17:36:37.766] result() for ClusterFuture ...
[17:36:37.766] - result already collected: FutureResult
[17:36:37.766] result() for ClusterFuture ... done
[17:36:37.766] - relayed: [n=2] TRUE, FALSE
[17:36:37.766] - queued futures: [n=2] TRUE, FALSE
[17:36:37.766] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:36:37.766]  length: 1 (resolved future 1)
[17:36:37.797] receiveMessageFromWorker() for ClusterFuture ...
[17:36:37.797] - Validating connection of MultisessionFuture
[17:36:37.797] - received message: FutureResult
[17:36:37.798] - Received FutureResult
[17:36:37.798] - Erased future from FutureRegistry
[17:36:37.798] result() for ClusterFuture ...
[17:36:37.798] - result already collected: FutureResult
[17:36:37.798] result() for ClusterFuture ... done
[17:36:37.798] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:37.798] Future #2
[17:36:37.798] result() for ClusterFuture ...
[17:36:37.798] - result already collected: FutureResult
[17:36:37.798] result() for ClusterFuture ... done
[17:36:37.798] result() for ClusterFuture ...
[17:36:37.799] - result already collected: FutureResult
[17:36:37.799] result() for ClusterFuture ... done
[17:36:37.799] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:36:37.799] - nx: 2
[17:36:37.799] - relay: TRUE
[17:36:37.799] - stdout: TRUE
[17:36:37.799] - signal: TRUE
[17:36:37.799] - resignal: FALSE
[17:36:37.799] - force: TRUE
[17:36:37.799] - relayed: [n=2] TRUE, FALSE
[17:36:37.799] - queued futures: [n=2] TRUE, FALSE
[17:36:37.800]  - until=2
[17:36:37.800]  - relaying element #2
[17:36:37.800] result() for ClusterFuture ...
[17:36:37.800] - result already collected: FutureResult
[17:36:37.800] result() for ClusterFuture ... done
[17:36:37.800] result() for ClusterFuture ...
[17:36:37.800] - result already collected: FutureResult
[17:36:37.800] result() for ClusterFuture ... done
[17:36:37.800] result() for ClusterFuture ...
[17:36:37.800] - result already collected: FutureResult
[17:36:37.800] result() for ClusterFuture ... done
[17:36:37.801] result() for ClusterFuture ...
[17:36:37.801] - result already collected: FutureResult
[17:36:37.801] result() for ClusterFuture ... done
[17:36:37.801] - relayed: [n=2] TRUE, TRUE
[17:36:37.801] - queued futures: [n=2] TRUE, TRUE
[17:36:37.801] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:36:37.801]  length: 0 (resolved future 2)
[17:36:37.801] Relaying remaining futures
[17:36:37.801] signalConditionsASAP(NULL, pos=0) ...
[17:36:37.801] - nx: 2
[17:36:37.801] - relay: TRUE
[17:36:37.802] - stdout: TRUE
[17:36:37.802] - signal: TRUE
[17:36:37.802] - resignal: FALSE
[17:36:37.802] - force: TRUE
[17:36:37.802] - relayed: [n=2] TRUE, TRUE
[17:36:37.802] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:37.802] - relayed: [n=2] TRUE, TRUE
[17:36:37.802] - queued futures: [n=2] TRUE, TRUE
[17:36:37.802] signalConditionsASAP(NULL, pos=0) ... done
[17:36:37.802] resolve() on list ... DONE
[17:36:37.802] result() for ClusterFuture ...
[17:36:37.803] - result already collected: FutureResult
[17:36:37.803] result() for ClusterFuture ... done
[17:36:37.803] result() for ClusterFuture ...
[17:36:37.803] - result already collected: FutureResult
[17:36:37.803] result() for ClusterFuture ... done
[17:36:37.803] result() for ClusterFuture ...
[17:36:37.803] - result already collected: FutureResult
[17:36:37.803] result() for ClusterFuture ... done
[17:36:37.803] result() for ClusterFuture ...
[17:36:37.803] - result already collected: FutureResult
[17:36:37.803] result() for ClusterFuture ... done
[17:36:37.803]  - Number of value chunks collected: 2
[17:36:37.804] Resolving 2 futures (chunks) ... DONE
[17:36:37.804] Reducing values from 2 chunks ...
[17:36:37.804]  - Number of values collected after concatenation: 2
[17:36:37.804]  - Number of values expected: 2
[17:36:37.804] Reducing values from 2 chunks ... DONE
[17:36:37.804] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[17:36:37.805] getGlobalsAndPackagesXApply() ...
[17:36:37.805]  - future.globals: TRUE
[17:36:37.805] getGlobalsAndPackages() ...
[17:36:37.805] Searching for globals...
[17:36:37.806] - globals found: [1] ‘FUN’
[17:36:37.806] Searching for globals ... DONE
[17:36:37.806] Resolving globals: FALSE
[17:36:37.806] The total size of the 1 globals is 848 bytes (848 bytes)
[17:36:37.807] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:36:37.807] - globals: [1] ‘FUN’
[17:36:37.807] 
[17:36:37.807] getGlobalsAndPackages() ... DONE
[17:36:37.807]  - globals found/used: [n=1] ‘FUN’
[17:36:37.807]  - needed namespaces: [n=0] 
[17:36:37.807] Finding globals ... DONE
[17:36:37.807]  - use_args: TRUE
[17:36:37.807]  - Getting '...' globals ...
[17:36:37.808] resolve() on list ...
[17:36:37.808]  recursive: 0
[17:36:37.808]  length: 1
[17:36:37.808]  elements: ‘...’
[17:36:37.808]  length: 0 (resolved future 1)
[17:36:37.808] resolve() on list ... DONE
[17:36:37.808]    - '...' content: [n=0] 
[17:36:37.808] List of 1
[17:36:37.808]  $ ...: list()
[17:36:37.808]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:37.808]  - attr(*, "where")=List of 1
[17:36:37.808]   ..$ ...:<environment: 0x556d77676440> 
[17:36:37.808]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:37.808]  - attr(*, "resolved")= logi TRUE
[17:36:37.808]  - attr(*, "total_size")= num NA
[17:36:37.811]  - Getting '...' globals ... DONE
[17:36:37.811] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:37.811] List of 2
[17:36:37.811]  $ ...future.FUN:function (x)  
[17:36:37.811]  $ ...          : list()
[17:36:37.811]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:37.811]  - attr(*, "where")=List of 2
[17:36:37.811]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:37.811]   ..$ ...          :<environment: 0x556d77676440> 
[17:36:37.811]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:37.811]  - attr(*, "resolved")= logi FALSE
[17:36:37.811]  - attr(*, "total_size")= num 848
[17:36:37.814] Packages to be attached in all futures: [n=0] 
[17:36:37.814] getGlobalsAndPackagesXApply() ... DONE
[17:36:37.817] future_lapply() ...
[17:36:37.821] Number of chunks: 2
[17:36:37.821] getGlobalsAndPackagesXApply() ...
[17:36:37.821]  - future.globals: <name-value list> with names ‘list()’
[17:36:37.821]  - use_args: TRUE
[17:36:37.822] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:37.822] List of 2
[17:36:37.822]  $ ...          : list()
[17:36:37.822]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:37.822]  $ ...future.FUN:function (x)  
[17:36:37.822]  - attr(*, "where")=List of 2
[17:36:37.822]   ..$ ...          :<environment: 0x556d77676440> 
[17:36:37.822]   ..$ ...future.FUN:<environment: namespace:base> 
[17:36:37.822]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:37.822]  - attr(*, "resolved")= logi FALSE
[17:36:37.822]  - attr(*, "total_size")= num NA
[17:36:37.826] Packages to be attached in all futures: [n=0] 
[17:36:37.827] getGlobalsAndPackagesXApply() ... DONE
[17:36:37.827] Number of futures (= number of chunks): 2
[17:36:37.827] Launching 2 futures (chunks) ...
[17:36:37.827] Chunk #1 of 2 ...
[17:36:37.827]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:37.827]  - seeds: <none>
[17:36:37.827]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.827] getGlobalsAndPackages() ...
[17:36:37.827] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.828] Resolving globals: FALSE
[17:36:37.828] Tweak future expression to call with '...' arguments ...
[17:36:37.828] {
[17:36:37.828]     do.call(function(...) {
[17:36:37.828]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.828]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:37.828]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.828]             on.exit(options(oopts), add = TRUE)
[17:36:37.828]         }
[17:36:37.828]         {
[17:36:37.828]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:37.828]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.828]                 ...future.FUN(...future.X_jj, ...)
[17:36:37.828]             })
[17:36:37.828]         }
[17:36:37.828]     }, args = future.call.arguments)
[17:36:37.828] }
[17:36:37.828] Tweak future expression to call with '...' arguments ... DONE
[17:36:37.828] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.829] 
[17:36:37.829] getGlobalsAndPackages() ... DONE
[17:36:37.829] run() for ‘Future’ ...
[17:36:37.829] - state: ‘created’
[17:36:37.829] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:37.843] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:37.843] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:37.843]   - Field: ‘node’
[17:36:37.843]   - Field: ‘label’
[17:36:37.843]   - Field: ‘local’
[17:36:37.843]   - Field: ‘owner’
[17:36:37.843]   - Field: ‘envir’
[17:36:37.844]   - Field: ‘workers’
[17:36:37.844]   - Field: ‘packages’
[17:36:37.844]   - Field: ‘gc’
[17:36:37.844]   - Field: ‘conditions’
[17:36:37.844]   - Field: ‘persistent’
[17:36:37.844]   - Field: ‘expr’
[17:36:37.844]   - Field: ‘uuid’
[17:36:37.844]   - Field: ‘seed’
[17:36:37.844]   - Field: ‘version’
[17:36:37.844]   - Field: ‘result’
[17:36:37.844]   - Field: ‘asynchronous’
[17:36:37.845]   - Field: ‘calls’
[17:36:37.845]   - Field: ‘globals’
[17:36:37.845]   - Field: ‘stdout’
[17:36:37.845]   - Field: ‘earlySignal’
[17:36:37.845]   - Field: ‘lazy’
[17:36:37.845]   - Field: ‘state’
[17:36:37.845] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:37.845] - Launch lazy future ...
[17:36:37.845] Packages needed by the future expression (n = 0): <none>
[17:36:37.846] Packages needed by future strategies (n = 0): <none>
[17:36:37.846] {
[17:36:37.846]     {
[17:36:37.846]         {
[17:36:37.846]             ...future.startTime <- base::Sys.time()
[17:36:37.846]             {
[17:36:37.846]                 {
[17:36:37.846]                   {
[17:36:37.846]                     {
[17:36:37.846]                       base::local({
[17:36:37.846]                         has_future <- base::requireNamespace("future", 
[17:36:37.846]                           quietly = TRUE)
[17:36:37.846]                         if (has_future) {
[17:36:37.846]                           ns <- base::getNamespace("future")
[17:36:37.846]                           version <- ns[[".package"]][["version"]]
[17:36:37.846]                           if (is.null(version)) 
[17:36:37.846]                             version <- utils::packageVersion("future")
[17:36:37.846]                         }
[17:36:37.846]                         else {
[17:36:37.846]                           version <- NULL
[17:36:37.846]                         }
[17:36:37.846]                         if (!has_future || version < "1.8.0") {
[17:36:37.846]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:37.846]                             "", base::R.version$version.string), 
[17:36:37.846]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:37.846]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:37.846]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:37.846]                               "release", "version")], collapse = " "), 
[17:36:37.846]                             hostname = base::Sys.info()[["nodename"]])
[17:36:37.846]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:37.846]                             info)
[17:36:37.846]                           info <- base::paste(info, collapse = "; ")
[17:36:37.846]                           if (!has_future) {
[17:36:37.846]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:37.846]                               info)
[17:36:37.846]                           }
[17:36:37.846]                           else {
[17:36:37.846]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:37.846]                               info, version)
[17:36:37.846]                           }
[17:36:37.846]                           base::stop(msg)
[17:36:37.846]                         }
[17:36:37.846]                       })
[17:36:37.846]                     }
[17:36:37.846]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:37.846]                     base::options(mc.cores = 1L)
[17:36:37.846]                   }
[17:36:37.846]                   ...future.strategy.old <- future::plan("list")
[17:36:37.846]                   options(future.plan = NULL)
[17:36:37.846]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:37.846]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:37.846]                 }
[17:36:37.846]                 ...future.workdir <- getwd()
[17:36:37.846]             }
[17:36:37.846]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:37.846]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:37.846]         }
[17:36:37.846]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:37.846]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:37.846]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:37.846]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:37.846]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:37.846]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:37.846]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:37.846]             base::names(...future.oldOptions))
[17:36:37.846]     }
[17:36:37.846]     if (FALSE) {
[17:36:37.846]     }
[17:36:37.846]     else {
[17:36:37.846]         if (TRUE) {
[17:36:37.846]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:37.846]                 open = "w")
[17:36:37.846]         }
[17:36:37.846]         else {
[17:36:37.846]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:37.846]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:37.846]         }
[17:36:37.846]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:37.846]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:37.846]             base::sink(type = "output", split = FALSE)
[17:36:37.846]             base::close(...future.stdout)
[17:36:37.846]         }, add = TRUE)
[17:36:37.846]     }
[17:36:37.846]     ...future.frame <- base::sys.nframe()
[17:36:37.846]     ...future.conditions <- base::list()
[17:36:37.846]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:37.846]     if (FALSE) {
[17:36:37.846]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:37.846]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:37.846]     }
[17:36:37.846]     ...future.result <- base::tryCatch({
[17:36:37.846]         base::withCallingHandlers({
[17:36:37.846]             ...future.value <- base::withVisible(base::local({
[17:36:37.846]                 ...future.makeSendCondition <- base::local({
[17:36:37.846]                   sendCondition <- NULL
[17:36:37.846]                   function(frame = 1L) {
[17:36:37.846]                     if (is.function(sendCondition)) 
[17:36:37.846]                       return(sendCondition)
[17:36:37.846]                     ns <- getNamespace("parallel")
[17:36:37.846]                     if (exists("sendData", mode = "function", 
[17:36:37.846]                       envir = ns)) {
[17:36:37.846]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:37.846]                         envir = ns)
[17:36:37.846]                       envir <- sys.frame(frame)
[17:36:37.846]                       master <- NULL
[17:36:37.846]                       while (!identical(envir, .GlobalEnv) && 
[17:36:37.846]                         !identical(envir, emptyenv())) {
[17:36:37.846]                         if (exists("master", mode = "list", envir = envir, 
[17:36:37.846]                           inherits = FALSE)) {
[17:36:37.846]                           master <- get("master", mode = "list", 
[17:36:37.846]                             envir = envir, inherits = FALSE)
[17:36:37.846]                           if (inherits(master, c("SOCKnode", 
[17:36:37.846]                             "SOCK0node"))) {
[17:36:37.846]                             sendCondition <<- function(cond) {
[17:36:37.846]                               data <- list(type = "VALUE", value = cond, 
[17:36:37.846]                                 success = TRUE)
[17:36:37.846]                               parallel_sendData(master, data)
[17:36:37.846]                             }
[17:36:37.846]                             return(sendCondition)
[17:36:37.846]                           }
[17:36:37.846]                         }
[17:36:37.846]                         frame <- frame + 1L
[17:36:37.846]                         envir <- sys.frame(frame)
[17:36:37.846]                       }
[17:36:37.846]                     }
[17:36:37.846]                     sendCondition <<- function(cond) NULL
[17:36:37.846]                   }
[17:36:37.846]                 })
[17:36:37.846]                 withCallingHandlers({
[17:36:37.846]                   {
[17:36:37.846]                     do.call(function(...) {
[17:36:37.846]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.846]                       if (!identical(...future.globals.maxSize.org, 
[17:36:37.846]                         ...future.globals.maxSize)) {
[17:36:37.846]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.846]                         on.exit(options(oopts), add = TRUE)
[17:36:37.846]                       }
[17:36:37.846]                       {
[17:36:37.846]                         lapply(seq_along(...future.elements_ii), 
[17:36:37.846]                           FUN = function(jj) {
[17:36:37.846]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.846]                             ...future.FUN(...future.X_jj, ...)
[17:36:37.846]                           })
[17:36:37.846]                       }
[17:36:37.846]                     }, args = future.call.arguments)
[17:36:37.846]                   }
[17:36:37.846]                 }, immediateCondition = function(cond) {
[17:36:37.846]                   sendCondition <- ...future.makeSendCondition()
[17:36:37.846]                   sendCondition(cond)
[17:36:37.846]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.846]                   {
[17:36:37.846]                     inherits <- base::inherits
[17:36:37.846]                     invokeRestart <- base::invokeRestart
[17:36:37.846]                     is.null <- base::is.null
[17:36:37.846]                     muffled <- FALSE
[17:36:37.846]                     if (inherits(cond, "message")) {
[17:36:37.846]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:37.846]                       if (muffled) 
[17:36:37.846]                         invokeRestart("muffleMessage")
[17:36:37.846]                     }
[17:36:37.846]                     else if (inherits(cond, "warning")) {
[17:36:37.846]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:37.846]                       if (muffled) 
[17:36:37.846]                         invokeRestart("muffleWarning")
[17:36:37.846]                     }
[17:36:37.846]                     else if (inherits(cond, "condition")) {
[17:36:37.846]                       if (!is.null(pattern)) {
[17:36:37.846]                         computeRestarts <- base::computeRestarts
[17:36:37.846]                         grepl <- base::grepl
[17:36:37.846]                         restarts <- computeRestarts(cond)
[17:36:37.846]                         for (restart in restarts) {
[17:36:37.846]                           name <- restart$name
[17:36:37.846]                           if (is.null(name)) 
[17:36:37.846]                             next
[17:36:37.846]                           if (!grepl(pattern, name)) 
[17:36:37.846]                             next
[17:36:37.846]                           invokeRestart(restart)
[17:36:37.846]                           muffled <- TRUE
[17:36:37.846]                           break
[17:36:37.846]                         }
[17:36:37.846]                       }
[17:36:37.846]                     }
[17:36:37.846]                     invisible(muffled)
[17:36:37.846]                   }
[17:36:37.846]                   muffleCondition(cond)
[17:36:37.846]                 })
[17:36:37.846]             }))
[17:36:37.846]             future::FutureResult(value = ...future.value$value, 
[17:36:37.846]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:37.846]                   ...future.rng), globalenv = if (FALSE) 
[17:36:37.846]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:37.846]                     ...future.globalenv.names))
[17:36:37.846]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:37.846]         }, condition = base::local({
[17:36:37.846]             c <- base::c
[17:36:37.846]             inherits <- base::inherits
[17:36:37.846]             invokeRestart <- base::invokeRestart
[17:36:37.846]             length <- base::length
[17:36:37.846]             list <- base::list
[17:36:37.846]             seq.int <- base::seq.int
[17:36:37.846]             signalCondition <- base::signalCondition
[17:36:37.846]             sys.calls <- base::sys.calls
[17:36:37.846]             `[[` <- base::`[[`
[17:36:37.846]             `+` <- base::`+`
[17:36:37.846]             `<<-` <- base::`<<-`
[17:36:37.846]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:37.846]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:37.846]                   3L)]
[17:36:37.846]             }
[17:36:37.846]             function(cond) {
[17:36:37.846]                 is_error <- inherits(cond, "error")
[17:36:37.846]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:37.846]                   NULL)
[17:36:37.846]                 if (is_error) {
[17:36:37.846]                   sessionInformation <- function() {
[17:36:37.846]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:37.846]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:37.846]                       search = base::search(), system = base::Sys.info())
[17:36:37.846]                   }
[17:36:37.846]                   ...future.conditions[[length(...future.conditions) + 
[17:36:37.846]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:37.846]                     cond$call), session = sessionInformation(), 
[17:36:37.846]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:37.846]                   signalCondition(cond)
[17:36:37.846]                 }
[17:36:37.846]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:37.846]                 "immediateCondition"))) {
[17:36:37.846]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:37.846]                   ...future.conditions[[length(...future.conditions) + 
[17:36:37.846]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:37.846]                   if (TRUE && !signal) {
[17:36:37.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.846]                     {
[17:36:37.846]                       inherits <- base::inherits
[17:36:37.846]                       invokeRestart <- base::invokeRestart
[17:36:37.846]                       is.null <- base::is.null
[17:36:37.846]                       muffled <- FALSE
[17:36:37.846]                       if (inherits(cond, "message")) {
[17:36:37.846]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:37.846]                         if (muffled) 
[17:36:37.846]                           invokeRestart("muffleMessage")
[17:36:37.846]                       }
[17:36:37.846]                       else if (inherits(cond, "warning")) {
[17:36:37.846]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:37.846]                         if (muffled) 
[17:36:37.846]                           invokeRestart("muffleWarning")
[17:36:37.846]                       }
[17:36:37.846]                       else if (inherits(cond, "condition")) {
[17:36:37.846]                         if (!is.null(pattern)) {
[17:36:37.846]                           computeRestarts <- base::computeRestarts
[17:36:37.846]                           grepl <- base::grepl
[17:36:37.846]                           restarts <- computeRestarts(cond)
[17:36:37.846]                           for (restart in restarts) {
[17:36:37.846]                             name <- restart$name
[17:36:37.846]                             if (is.null(name)) 
[17:36:37.846]                               next
[17:36:37.846]                             if (!grepl(pattern, name)) 
[17:36:37.846]                               next
[17:36:37.846]                             invokeRestart(restart)
[17:36:37.846]                             muffled <- TRUE
[17:36:37.846]                             break
[17:36:37.846]                           }
[17:36:37.846]                         }
[17:36:37.846]                       }
[17:36:37.846]                       invisible(muffled)
[17:36:37.846]                     }
[17:36:37.846]                     muffleCondition(cond, pattern = "^muffle")
[17:36:37.846]                   }
[17:36:37.846]                 }
[17:36:37.846]                 else {
[17:36:37.846]                   if (TRUE) {
[17:36:37.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.846]                     {
[17:36:37.846]                       inherits <- base::inherits
[17:36:37.846]                       invokeRestart <- base::invokeRestart
[17:36:37.846]                       is.null <- base::is.null
[17:36:37.846]                       muffled <- FALSE
[17:36:37.846]                       if (inherits(cond, "message")) {
[17:36:37.846]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:37.846]                         if (muffled) 
[17:36:37.846]                           invokeRestart("muffleMessage")
[17:36:37.846]                       }
[17:36:37.846]                       else if (inherits(cond, "warning")) {
[17:36:37.846]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:37.846]                         if (muffled) 
[17:36:37.846]                           invokeRestart("muffleWarning")
[17:36:37.846]                       }
[17:36:37.846]                       else if (inherits(cond, "condition")) {
[17:36:37.846]                         if (!is.null(pattern)) {
[17:36:37.846]                           computeRestarts <- base::computeRestarts
[17:36:37.846]                           grepl <- base::grepl
[17:36:37.846]                           restarts <- computeRestarts(cond)
[17:36:37.846]                           for (restart in restarts) {
[17:36:37.846]                             name <- restart$name
[17:36:37.846]                             if (is.null(name)) 
[17:36:37.846]                               next
[17:36:37.846]                             if (!grepl(pattern, name)) 
[17:36:37.846]                               next
[17:36:37.846]                             invokeRestart(restart)
[17:36:37.846]                             muffled <- TRUE
[17:36:37.846]                             break
[17:36:37.846]                           }
[17:36:37.846]                         }
[17:36:37.846]                       }
[17:36:37.846]                       invisible(muffled)
[17:36:37.846]                     }
[17:36:37.846]                     muffleCondition(cond, pattern = "^muffle")
[17:36:37.846]                   }
[17:36:37.846]                 }
[17:36:37.846]             }
[17:36:37.846]         }))
[17:36:37.846]     }, error = function(ex) {
[17:36:37.846]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:37.846]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:37.846]                 ...future.rng), started = ...future.startTime, 
[17:36:37.846]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:37.846]             version = "1.8"), class = "FutureResult")
[17:36:37.846]     }, finally = {
[17:36:37.846]         if (!identical(...future.workdir, getwd())) 
[17:36:37.846]             setwd(...future.workdir)
[17:36:37.846]         {
[17:36:37.846]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:37.846]                 ...future.oldOptions$nwarnings <- NULL
[17:36:37.846]             }
[17:36:37.846]             base::options(...future.oldOptions)
[17:36:37.846]             if (.Platform$OS.type == "windows") {
[17:36:37.846]                 old_names <- names(...future.oldEnvVars)
[17:36:37.846]                 envs <- base::Sys.getenv()
[17:36:37.846]                 names <- names(envs)
[17:36:37.846]                 common <- intersect(names, old_names)
[17:36:37.846]                 added <- setdiff(names, old_names)
[17:36:37.846]                 removed <- setdiff(old_names, names)
[17:36:37.846]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:37.846]                   envs[common]]
[17:36:37.846]                 NAMES <- toupper(changed)
[17:36:37.846]                 args <- list()
[17:36:37.846]                 for (kk in seq_along(NAMES)) {
[17:36:37.846]                   name <- changed[[kk]]
[17:36:37.846]                   NAME <- NAMES[[kk]]
[17:36:37.846]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.846]                     next
[17:36:37.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:37.846]                 }
[17:36:37.846]                 NAMES <- toupper(added)
[17:36:37.846]                 for (kk in seq_along(NAMES)) {
[17:36:37.846]                   name <- added[[kk]]
[17:36:37.846]                   NAME <- NAMES[[kk]]
[17:36:37.846]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.846]                     next
[17:36:37.846]                   args[[name]] <- ""
[17:36:37.846]                 }
[17:36:37.846]                 NAMES <- toupper(removed)
[17:36:37.846]                 for (kk in seq_along(NAMES)) {
[17:36:37.846]                   name <- removed[[kk]]
[17:36:37.846]                   NAME <- NAMES[[kk]]
[17:36:37.846]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.846]                     next
[17:36:37.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:37.846]                 }
[17:36:37.846]                 if (length(args) > 0) 
[17:36:37.846]                   base::do.call(base::Sys.setenv, args = args)
[17:36:37.846]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:37.846]             }
[17:36:37.846]             else {
[17:36:37.846]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:37.846]             }
[17:36:37.846]             {
[17:36:37.846]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:37.846]                   0L) {
[17:36:37.846]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:37.846]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:37.846]                   base::options(opts)
[17:36:37.846]                 }
[17:36:37.846]                 {
[17:36:37.846]                   {
[17:36:37.846]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:37.846]                     NULL
[17:36:37.846]                   }
[17:36:37.846]                   options(future.plan = NULL)
[17:36:37.846]                   if (is.na(NA_character_)) 
[17:36:37.846]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:37.846]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:37.846]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:37.846]                     .init = FALSE)
[17:36:37.846]                 }
[17:36:37.846]             }
[17:36:37.846]         }
[17:36:37.846]     })
[17:36:37.846]     if (TRUE) {
[17:36:37.846]         base::sink(type = "output", split = FALSE)
[17:36:37.846]         if (TRUE) {
[17:36:37.846]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:37.846]         }
[17:36:37.846]         else {
[17:36:37.846]             ...future.result["stdout"] <- base::list(NULL)
[17:36:37.846]         }
[17:36:37.846]         base::close(...future.stdout)
[17:36:37.846]         ...future.stdout <- NULL
[17:36:37.846]     }
[17:36:37.846]     ...future.result$conditions <- ...future.conditions
[17:36:37.846]     ...future.result$finished <- base::Sys.time()
[17:36:37.846]     ...future.result
[17:36:37.846] }
[17:36:37.849] Exporting 5 global objects (0.99 KiB) to cluster node #1 ...
[17:36:37.849] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:36:37.849] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:36:37.850] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:36:37.850] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:36:37.850] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:36:37.850] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:36:37.851] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:36:37.851] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:36:37.851] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:36:37.852] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:36:37.852] Exporting 5 global objects (0.99 KiB) to cluster node #1 ... DONE
[17:36:37.852] MultisessionFuture started
[17:36:37.852] - Launch lazy future ... done
[17:36:37.853] run() for ‘MultisessionFuture’ ... done
[17:36:37.853] Created future:
[17:36:37.853] MultisessionFuture:
[17:36:37.853] Label: ‘future_apply-1’
[17:36:37.853] Expression:
[17:36:37.853] {
[17:36:37.853]     do.call(function(...) {
[17:36:37.853]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.853]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:37.853]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.853]             on.exit(options(oopts), add = TRUE)
[17:36:37.853]         }
[17:36:37.853]         {
[17:36:37.853]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:37.853]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.853]                 ...future.FUN(...future.X_jj, ...)
[17:36:37.853]             })
[17:36:37.853]         }
[17:36:37.853]     }, args = future.call.arguments)
[17:36:37.853] }
[17:36:37.853] Lazy evaluation: FALSE
[17:36:37.853] Asynchronous evaluation: TRUE
[17:36:37.853] Local evaluation: TRUE
[17:36:37.853] Environment: R_GlobalEnv
[17:36:37.853] Capture standard output: TRUE
[17:36:37.853] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:37.853] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:37.853] Packages: <none>
[17:36:37.853] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:37.853] Resolved: FALSE
[17:36:37.853] Value: <not collected>
[17:36:37.853] Conditions captured: <none>
[17:36:37.853] Early signaling: FALSE
[17:36:37.853] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:37.853] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:37.864] Chunk #1 of 2 ... DONE
[17:36:37.864] Chunk #2 of 2 ...
[17:36:37.865]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:37.865]  - seeds: <none>
[17:36:37.865]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.865] getGlobalsAndPackages() ...
[17:36:37.865] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.865] Resolving globals: FALSE
[17:36:37.865] Tweak future expression to call with '...' arguments ...
[17:36:37.865] {
[17:36:37.865]     do.call(function(...) {
[17:36:37.865]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.865]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:37.865]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.865]             on.exit(options(oopts), add = TRUE)
[17:36:37.865]         }
[17:36:37.865]         {
[17:36:37.865]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:37.865]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.865]                 ...future.FUN(...future.X_jj, ...)
[17:36:37.865]             })
[17:36:37.865]         }
[17:36:37.865]     }, args = future.call.arguments)
[17:36:37.865] }
[17:36:37.866] Tweak future expression to call with '...' arguments ... DONE
[17:36:37.866] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.866] 
[17:36:37.866] getGlobalsAndPackages() ... DONE
[17:36:37.866] run() for ‘Future’ ...
[17:36:37.867] - state: ‘created’
[17:36:37.867] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:37.880] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:37.881] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:37.881]   - Field: ‘node’
[17:36:37.881]   - Field: ‘label’
[17:36:37.881]   - Field: ‘local’
[17:36:37.881]   - Field: ‘owner’
[17:36:37.881]   - Field: ‘envir’
[17:36:37.881]   - Field: ‘workers’
[17:36:37.881]   - Field: ‘packages’
[17:36:37.881]   - Field: ‘gc’
[17:36:37.881]   - Field: ‘conditions’
[17:36:37.882]   - Field: ‘persistent’
[17:36:37.882]   - Field: ‘expr’
[17:36:37.882]   - Field: ‘uuid’
[17:36:37.882]   - Field: ‘seed’
[17:36:37.882]   - Field: ‘version’
[17:36:37.882]   - Field: ‘result’
[17:36:37.882]   - Field: ‘asynchronous’
[17:36:37.882]   - Field: ‘calls’
[17:36:37.882]   - Field: ‘globals’
[17:36:37.882]   - Field: ‘stdout’
[17:36:37.882]   - Field: ‘earlySignal’
[17:36:37.883]   - Field: ‘lazy’
[17:36:37.883]   - Field: ‘state’
[17:36:37.883] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:37.883] - Launch lazy future ...
[17:36:37.883] Packages needed by the future expression (n = 0): <none>
[17:36:37.883] Packages needed by future strategies (n = 0): <none>
[17:36:37.884] {
[17:36:37.884]     {
[17:36:37.884]         {
[17:36:37.884]             ...future.startTime <- base::Sys.time()
[17:36:37.884]             {
[17:36:37.884]                 {
[17:36:37.884]                   {
[17:36:37.884]                     {
[17:36:37.884]                       base::local({
[17:36:37.884]                         has_future <- base::requireNamespace("future", 
[17:36:37.884]                           quietly = TRUE)
[17:36:37.884]                         if (has_future) {
[17:36:37.884]                           ns <- base::getNamespace("future")
[17:36:37.884]                           version <- ns[[".package"]][["version"]]
[17:36:37.884]                           if (is.null(version)) 
[17:36:37.884]                             version <- utils::packageVersion("future")
[17:36:37.884]                         }
[17:36:37.884]                         else {
[17:36:37.884]                           version <- NULL
[17:36:37.884]                         }
[17:36:37.884]                         if (!has_future || version < "1.8.0") {
[17:36:37.884]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:37.884]                             "", base::R.version$version.string), 
[17:36:37.884]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:37.884]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:37.884]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:37.884]                               "release", "version")], collapse = " "), 
[17:36:37.884]                             hostname = base::Sys.info()[["nodename"]])
[17:36:37.884]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:37.884]                             info)
[17:36:37.884]                           info <- base::paste(info, collapse = "; ")
[17:36:37.884]                           if (!has_future) {
[17:36:37.884]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:37.884]                               info)
[17:36:37.884]                           }
[17:36:37.884]                           else {
[17:36:37.884]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:37.884]                               info, version)
[17:36:37.884]                           }
[17:36:37.884]                           base::stop(msg)
[17:36:37.884]                         }
[17:36:37.884]                       })
[17:36:37.884]                     }
[17:36:37.884]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:37.884]                     base::options(mc.cores = 1L)
[17:36:37.884]                   }
[17:36:37.884]                   ...future.strategy.old <- future::plan("list")
[17:36:37.884]                   options(future.plan = NULL)
[17:36:37.884]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:37.884]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:37.884]                 }
[17:36:37.884]                 ...future.workdir <- getwd()
[17:36:37.884]             }
[17:36:37.884]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:37.884]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:37.884]         }
[17:36:37.884]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:37.884]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:37.884]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:37.884]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:37.884]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:37.884]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:37.884]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:37.884]             base::names(...future.oldOptions))
[17:36:37.884]     }
[17:36:37.884]     if (FALSE) {
[17:36:37.884]     }
[17:36:37.884]     else {
[17:36:37.884]         if (TRUE) {
[17:36:37.884]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:37.884]                 open = "w")
[17:36:37.884]         }
[17:36:37.884]         else {
[17:36:37.884]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:37.884]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:37.884]         }
[17:36:37.884]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:37.884]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:37.884]             base::sink(type = "output", split = FALSE)
[17:36:37.884]             base::close(...future.stdout)
[17:36:37.884]         }, add = TRUE)
[17:36:37.884]     }
[17:36:37.884]     ...future.frame <- base::sys.nframe()
[17:36:37.884]     ...future.conditions <- base::list()
[17:36:37.884]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:37.884]     if (FALSE) {
[17:36:37.884]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:37.884]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:37.884]     }
[17:36:37.884]     ...future.result <- base::tryCatch({
[17:36:37.884]         base::withCallingHandlers({
[17:36:37.884]             ...future.value <- base::withVisible(base::local({
[17:36:37.884]                 ...future.makeSendCondition <- base::local({
[17:36:37.884]                   sendCondition <- NULL
[17:36:37.884]                   function(frame = 1L) {
[17:36:37.884]                     if (is.function(sendCondition)) 
[17:36:37.884]                       return(sendCondition)
[17:36:37.884]                     ns <- getNamespace("parallel")
[17:36:37.884]                     if (exists("sendData", mode = "function", 
[17:36:37.884]                       envir = ns)) {
[17:36:37.884]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:37.884]                         envir = ns)
[17:36:37.884]                       envir <- sys.frame(frame)
[17:36:37.884]                       master <- NULL
[17:36:37.884]                       while (!identical(envir, .GlobalEnv) && 
[17:36:37.884]                         !identical(envir, emptyenv())) {
[17:36:37.884]                         if (exists("master", mode = "list", envir = envir, 
[17:36:37.884]                           inherits = FALSE)) {
[17:36:37.884]                           master <- get("master", mode = "list", 
[17:36:37.884]                             envir = envir, inherits = FALSE)
[17:36:37.884]                           if (inherits(master, c("SOCKnode", 
[17:36:37.884]                             "SOCK0node"))) {
[17:36:37.884]                             sendCondition <<- function(cond) {
[17:36:37.884]                               data <- list(type = "VALUE", value = cond, 
[17:36:37.884]                                 success = TRUE)
[17:36:37.884]                               parallel_sendData(master, data)
[17:36:37.884]                             }
[17:36:37.884]                             return(sendCondition)
[17:36:37.884]                           }
[17:36:37.884]                         }
[17:36:37.884]                         frame <- frame + 1L
[17:36:37.884]                         envir <- sys.frame(frame)
[17:36:37.884]                       }
[17:36:37.884]                     }
[17:36:37.884]                     sendCondition <<- function(cond) NULL
[17:36:37.884]                   }
[17:36:37.884]                 })
[17:36:37.884]                 withCallingHandlers({
[17:36:37.884]                   {
[17:36:37.884]                     do.call(function(...) {
[17:36:37.884]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.884]                       if (!identical(...future.globals.maxSize.org, 
[17:36:37.884]                         ...future.globals.maxSize)) {
[17:36:37.884]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.884]                         on.exit(options(oopts), add = TRUE)
[17:36:37.884]                       }
[17:36:37.884]                       {
[17:36:37.884]                         lapply(seq_along(...future.elements_ii), 
[17:36:37.884]                           FUN = function(jj) {
[17:36:37.884]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.884]                             ...future.FUN(...future.X_jj, ...)
[17:36:37.884]                           })
[17:36:37.884]                       }
[17:36:37.884]                     }, args = future.call.arguments)
[17:36:37.884]                   }
[17:36:37.884]                 }, immediateCondition = function(cond) {
[17:36:37.884]                   sendCondition <- ...future.makeSendCondition()
[17:36:37.884]                   sendCondition(cond)
[17:36:37.884]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.884]                   {
[17:36:37.884]                     inherits <- base::inherits
[17:36:37.884]                     invokeRestart <- base::invokeRestart
[17:36:37.884]                     is.null <- base::is.null
[17:36:37.884]                     muffled <- FALSE
[17:36:37.884]                     if (inherits(cond, "message")) {
[17:36:37.884]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:37.884]                       if (muffled) 
[17:36:37.884]                         invokeRestart("muffleMessage")
[17:36:37.884]                     }
[17:36:37.884]                     else if (inherits(cond, "warning")) {
[17:36:37.884]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:37.884]                       if (muffled) 
[17:36:37.884]                         invokeRestart("muffleWarning")
[17:36:37.884]                     }
[17:36:37.884]                     else if (inherits(cond, "condition")) {
[17:36:37.884]                       if (!is.null(pattern)) {
[17:36:37.884]                         computeRestarts <- base::computeRestarts
[17:36:37.884]                         grepl <- base::grepl
[17:36:37.884]                         restarts <- computeRestarts(cond)
[17:36:37.884]                         for (restart in restarts) {
[17:36:37.884]                           name <- restart$name
[17:36:37.884]                           if (is.null(name)) 
[17:36:37.884]                             next
[17:36:37.884]                           if (!grepl(pattern, name)) 
[17:36:37.884]                             next
[17:36:37.884]                           invokeRestart(restart)
[17:36:37.884]                           muffled <- TRUE
[17:36:37.884]                           break
[17:36:37.884]                         }
[17:36:37.884]                       }
[17:36:37.884]                     }
[17:36:37.884]                     invisible(muffled)
[17:36:37.884]                   }
[17:36:37.884]                   muffleCondition(cond)
[17:36:37.884]                 })
[17:36:37.884]             }))
[17:36:37.884]             future::FutureResult(value = ...future.value$value, 
[17:36:37.884]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:37.884]                   ...future.rng), globalenv = if (FALSE) 
[17:36:37.884]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:37.884]                     ...future.globalenv.names))
[17:36:37.884]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:37.884]         }, condition = base::local({
[17:36:37.884]             c <- base::c
[17:36:37.884]             inherits <- base::inherits
[17:36:37.884]             invokeRestart <- base::invokeRestart
[17:36:37.884]             length <- base::length
[17:36:37.884]             list <- base::list
[17:36:37.884]             seq.int <- base::seq.int
[17:36:37.884]             signalCondition <- base::signalCondition
[17:36:37.884]             sys.calls <- base::sys.calls
[17:36:37.884]             `[[` <- base::`[[`
[17:36:37.884]             `+` <- base::`+`
[17:36:37.884]             `<<-` <- base::`<<-`
[17:36:37.884]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:37.884]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:37.884]                   3L)]
[17:36:37.884]             }
[17:36:37.884]             function(cond) {
[17:36:37.884]                 is_error <- inherits(cond, "error")
[17:36:37.884]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:37.884]                   NULL)
[17:36:37.884]                 if (is_error) {
[17:36:37.884]                   sessionInformation <- function() {
[17:36:37.884]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:37.884]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:37.884]                       search = base::search(), system = base::Sys.info())
[17:36:37.884]                   }
[17:36:37.884]                   ...future.conditions[[length(...future.conditions) + 
[17:36:37.884]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:37.884]                     cond$call), session = sessionInformation(), 
[17:36:37.884]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:37.884]                   signalCondition(cond)
[17:36:37.884]                 }
[17:36:37.884]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:37.884]                 "immediateCondition"))) {
[17:36:37.884]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:37.884]                   ...future.conditions[[length(...future.conditions) + 
[17:36:37.884]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:37.884]                   if (TRUE && !signal) {
[17:36:37.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.884]                     {
[17:36:37.884]                       inherits <- base::inherits
[17:36:37.884]                       invokeRestart <- base::invokeRestart
[17:36:37.884]                       is.null <- base::is.null
[17:36:37.884]                       muffled <- FALSE
[17:36:37.884]                       if (inherits(cond, "message")) {
[17:36:37.884]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:37.884]                         if (muffled) 
[17:36:37.884]                           invokeRestart("muffleMessage")
[17:36:37.884]                       }
[17:36:37.884]                       else if (inherits(cond, "warning")) {
[17:36:37.884]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:37.884]                         if (muffled) 
[17:36:37.884]                           invokeRestart("muffleWarning")
[17:36:37.884]                       }
[17:36:37.884]                       else if (inherits(cond, "condition")) {
[17:36:37.884]                         if (!is.null(pattern)) {
[17:36:37.884]                           computeRestarts <- base::computeRestarts
[17:36:37.884]                           grepl <- base::grepl
[17:36:37.884]                           restarts <- computeRestarts(cond)
[17:36:37.884]                           for (restart in restarts) {
[17:36:37.884]                             name <- restart$name
[17:36:37.884]                             if (is.null(name)) 
[17:36:37.884]                               next
[17:36:37.884]                             if (!grepl(pattern, name)) 
[17:36:37.884]                               next
[17:36:37.884]                             invokeRestart(restart)
[17:36:37.884]                             muffled <- TRUE
[17:36:37.884]                             break
[17:36:37.884]                           }
[17:36:37.884]                         }
[17:36:37.884]                       }
[17:36:37.884]                       invisible(muffled)
[17:36:37.884]                     }
[17:36:37.884]                     muffleCondition(cond, pattern = "^muffle")
[17:36:37.884]                   }
[17:36:37.884]                 }
[17:36:37.884]                 else {
[17:36:37.884]                   if (TRUE) {
[17:36:37.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.884]                     {
[17:36:37.884]                       inherits <- base::inherits
[17:36:37.884]                       invokeRestart <- base::invokeRestart
[17:36:37.884]                       is.null <- base::is.null
[17:36:37.884]                       muffled <- FALSE
[17:36:37.884]                       if (inherits(cond, "message")) {
[17:36:37.884]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:37.884]                         if (muffled) 
[17:36:37.884]                           invokeRestart("muffleMessage")
[17:36:37.884]                       }
[17:36:37.884]                       else if (inherits(cond, "warning")) {
[17:36:37.884]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:37.884]                         if (muffled) 
[17:36:37.884]                           invokeRestart("muffleWarning")
[17:36:37.884]                       }
[17:36:37.884]                       else if (inherits(cond, "condition")) {
[17:36:37.884]                         if (!is.null(pattern)) {
[17:36:37.884]                           computeRestarts <- base::computeRestarts
[17:36:37.884]                           grepl <- base::grepl
[17:36:37.884]                           restarts <- computeRestarts(cond)
[17:36:37.884]                           for (restart in restarts) {
[17:36:37.884]                             name <- restart$name
[17:36:37.884]                             if (is.null(name)) 
[17:36:37.884]                               next
[17:36:37.884]                             if (!grepl(pattern, name)) 
[17:36:37.884]                               next
[17:36:37.884]                             invokeRestart(restart)
[17:36:37.884]                             muffled <- TRUE
[17:36:37.884]                             break
[17:36:37.884]                           }
[17:36:37.884]                         }
[17:36:37.884]                       }
[17:36:37.884]                       invisible(muffled)
[17:36:37.884]                     }
[17:36:37.884]                     muffleCondition(cond, pattern = "^muffle")
[17:36:37.884]                   }
[17:36:37.884]                 }
[17:36:37.884]             }
[17:36:37.884]         }))
[17:36:37.884]     }, error = function(ex) {
[17:36:37.884]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:37.884]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:37.884]                 ...future.rng), started = ...future.startTime, 
[17:36:37.884]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:37.884]             version = "1.8"), class = "FutureResult")
[17:36:37.884]     }, finally = {
[17:36:37.884]         if (!identical(...future.workdir, getwd())) 
[17:36:37.884]             setwd(...future.workdir)
[17:36:37.884]         {
[17:36:37.884]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:37.884]                 ...future.oldOptions$nwarnings <- NULL
[17:36:37.884]             }
[17:36:37.884]             base::options(...future.oldOptions)
[17:36:37.884]             if (.Platform$OS.type == "windows") {
[17:36:37.884]                 old_names <- names(...future.oldEnvVars)
[17:36:37.884]                 envs <- base::Sys.getenv()
[17:36:37.884]                 names <- names(envs)
[17:36:37.884]                 common <- intersect(names, old_names)
[17:36:37.884]                 added <- setdiff(names, old_names)
[17:36:37.884]                 removed <- setdiff(old_names, names)
[17:36:37.884]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:37.884]                   envs[common]]
[17:36:37.884]                 NAMES <- toupper(changed)
[17:36:37.884]                 args <- list()
[17:36:37.884]                 for (kk in seq_along(NAMES)) {
[17:36:37.884]                   name <- changed[[kk]]
[17:36:37.884]                   NAME <- NAMES[[kk]]
[17:36:37.884]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.884]                     next
[17:36:37.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:37.884]                 }
[17:36:37.884]                 NAMES <- toupper(added)
[17:36:37.884]                 for (kk in seq_along(NAMES)) {
[17:36:37.884]                   name <- added[[kk]]
[17:36:37.884]                   NAME <- NAMES[[kk]]
[17:36:37.884]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.884]                     next
[17:36:37.884]                   args[[name]] <- ""
[17:36:37.884]                 }
[17:36:37.884]                 NAMES <- toupper(removed)
[17:36:37.884]                 for (kk in seq_along(NAMES)) {
[17:36:37.884]                   name <- removed[[kk]]
[17:36:37.884]                   NAME <- NAMES[[kk]]
[17:36:37.884]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.884]                     next
[17:36:37.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:37.884]                 }
[17:36:37.884]                 if (length(args) > 0) 
[17:36:37.884]                   base::do.call(base::Sys.setenv, args = args)
[17:36:37.884]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:37.884]             }
[17:36:37.884]             else {
[17:36:37.884]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:37.884]             }
[17:36:37.884]             {
[17:36:37.884]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:37.884]                   0L) {
[17:36:37.884]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:37.884]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:37.884]                   base::options(opts)
[17:36:37.884]                 }
[17:36:37.884]                 {
[17:36:37.884]                   {
[17:36:37.884]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:37.884]                     NULL
[17:36:37.884]                   }
[17:36:37.884]                   options(future.plan = NULL)
[17:36:37.884]                   if (is.na(NA_character_)) 
[17:36:37.884]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:37.884]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:37.884]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:37.884]                     .init = FALSE)
[17:36:37.884]                 }
[17:36:37.884]             }
[17:36:37.884]         }
[17:36:37.884]     })
[17:36:37.884]     if (TRUE) {
[17:36:37.884]         base::sink(type = "output", split = FALSE)
[17:36:37.884]         if (TRUE) {
[17:36:37.884]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:37.884]         }
[17:36:37.884]         else {
[17:36:37.884]             ...future.result["stdout"] <- base::list(NULL)
[17:36:37.884]         }
[17:36:37.884]         base::close(...future.stdout)
[17:36:37.884]         ...future.stdout <- NULL
[17:36:37.884]     }
[17:36:37.884]     ...future.result$conditions <- ...future.conditions
[17:36:37.884]     ...future.result$finished <- base::Sys.time()
[17:36:37.884]     ...future.result
[17:36:37.884] }
[17:36:37.887] Exporting 5 global objects (0.99 KiB) to cluster node #2 ...
[17:36:37.887] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:36:37.887] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:36:37.887] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[17:36:37.888] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[17:36:37.888] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:36:37.888] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:36:37.888] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:36:37.888] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:36:37.889] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:36:37.889] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:36:37.889] Exporting 5 global objects (0.99 KiB) to cluster node #2 ... DONE
[17:36:37.889] MultisessionFuture started
[17:36:37.890] - Launch lazy future ... done
[17:36:37.890] run() for ‘MultisessionFuture’ ... done
[17:36:37.890] Created future:
[17:36:37.890] MultisessionFuture:
[17:36:37.890] Label: ‘future_apply-2’
[17:36:37.890] Expression:
[17:36:37.890] {
[17:36:37.890]     do.call(function(...) {
[17:36:37.890]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.890]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:37.890]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.890]             on.exit(options(oopts), add = TRUE)
[17:36:37.890]         }
[17:36:37.890]         {
[17:36:37.890]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:37.890]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.890]                 ...future.FUN(...future.X_jj, ...)
[17:36:37.890]             })
[17:36:37.890]         }
[17:36:37.890]     }, args = future.call.arguments)
[17:36:37.890] }
[17:36:37.890] Lazy evaluation: FALSE
[17:36:37.890] Asynchronous evaluation: TRUE
[17:36:37.890] Local evaluation: TRUE
[17:36:37.890] Environment: R_GlobalEnv
[17:36:37.890] Capture standard output: TRUE
[17:36:37.890] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:37.890] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:37.890] Packages: <none>
[17:36:37.890] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:37.890] Resolved: FALSE
[17:36:37.890] Value: <not collected>
[17:36:37.890] Conditions captured: <none>
[17:36:37.890] Early signaling: FALSE
[17:36:37.890] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:37.890] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:37.901] Chunk #2 of 2 ... DONE
[17:36:37.901] Launching 2 futures (chunks) ... DONE
[17:36:37.901] Resolving 2 futures (chunks) ...
[17:36:37.902] resolve() on list ...
[17:36:37.902]  recursive: 0
[17:36:37.902]  length: 2
[17:36:37.902] 
[17:36:37.902] receiveMessageFromWorker() for ClusterFuture ...
[17:36:37.902] - Validating connection of MultisessionFuture
[17:36:37.903] - received message: FutureResult
[17:36:37.903] - Received FutureResult
[17:36:37.903] - Erased future from FutureRegistry
[17:36:37.903] result() for ClusterFuture ...
[17:36:37.903] - result already collected: FutureResult
[17:36:37.903] result() for ClusterFuture ... done
[17:36:37.903] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:37.903] Future #1
[17:36:37.903] result() for ClusterFuture ...
[17:36:37.903] - result already collected: FutureResult
[17:36:37.904] result() for ClusterFuture ... done
[17:36:37.904] result() for ClusterFuture ...
[17:36:37.904] - result already collected: FutureResult
[17:36:37.904] result() for ClusterFuture ... done
[17:36:37.904] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:36:37.904] - nx: 2
[17:36:37.904] - relay: TRUE
[17:36:37.904] - stdout: TRUE
[17:36:37.904] - signal: TRUE
[17:36:37.904] - resignal: FALSE
[17:36:37.905] - force: TRUE
[17:36:37.905] - relayed: [n=2] FALSE, FALSE
[17:36:37.905] - queued futures: [n=2] FALSE, FALSE
[17:36:37.905]  - until=1
[17:36:37.905]  - relaying element #1
[17:36:37.905] result() for ClusterFuture ...
[17:36:37.905] - result already collected: FutureResult
[17:36:37.905] result() for ClusterFuture ... done
[17:36:37.905] result() for ClusterFuture ...
[17:36:37.905] - result already collected: FutureResult
[17:36:37.905] result() for ClusterFuture ... done
[17:36:37.906] result() for ClusterFuture ...
[17:36:37.906] - result already collected: FutureResult
[17:36:37.906] result() for ClusterFuture ... done
[17:36:37.906] result() for ClusterFuture ...
[17:36:37.906] - result already collected: FutureResult
[17:36:37.906] result() for ClusterFuture ... done
[17:36:37.906] - relayed: [n=2] TRUE, FALSE
[17:36:37.906] - queued futures: [n=2] TRUE, FALSE
[17:36:37.906] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:36:37.906]  length: 1 (resolved future 1)
[17:36:37.934] receiveMessageFromWorker() for ClusterFuture ...
[17:36:37.934] - Validating connection of MultisessionFuture
[17:36:37.934] - received message: FutureResult
[17:36:37.934] - Received FutureResult
[17:36:37.934] - Erased future from FutureRegistry
[17:36:37.935] result() for ClusterFuture ...
[17:36:37.935] - result already collected: FutureResult
[17:36:37.935] result() for ClusterFuture ... done
[17:36:37.935] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:37.935] Future #2
[17:36:37.935] result() for ClusterFuture ...
[17:36:37.935] - result already collected: FutureResult
[17:36:37.935] result() for ClusterFuture ... done
[17:36:37.935] result() for ClusterFuture ...
[17:36:37.935] - result already collected: FutureResult
[17:36:37.935] result() for ClusterFuture ... done
[17:36:37.936] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:36:37.936] - nx: 2
[17:36:37.936] - relay: TRUE
[17:36:37.936] - stdout: TRUE
[17:36:37.936] - signal: TRUE
[17:36:37.936] - resignal: FALSE
[17:36:37.936] - force: TRUE
[17:36:37.936] - relayed: [n=2] TRUE, FALSE
[17:36:37.936] - queued futures: [n=2] TRUE, FALSE
[17:36:37.936]  - until=2
[17:36:37.936]  - relaying element #2
[17:36:37.936] result() for ClusterFuture ...
[17:36:37.937] - result already collected: FutureResult
[17:36:37.937] result() for ClusterFuture ... done
[17:36:37.937] result() for ClusterFuture ...
[17:36:37.937] - result already collected: FutureResult
[17:36:37.937] result() for ClusterFuture ... done
[17:36:37.937] result() for ClusterFuture ...
[17:36:37.937] - result already collected: FutureResult
[17:36:37.937] result() for ClusterFuture ... done
[17:36:37.937] result() for ClusterFuture ...
[17:36:37.937] - result already collected: FutureResult
[17:36:37.937] result() for ClusterFuture ... done
[17:36:37.938] - relayed: [n=2] TRUE, TRUE
[17:36:37.938] - queued futures: [n=2] TRUE, TRUE
[17:36:37.938] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:36:37.938]  length: 0 (resolved future 2)
[17:36:37.938] Relaying remaining futures
[17:36:37.938] signalConditionsASAP(NULL, pos=0) ...
[17:36:37.938] - nx: 2
[17:36:37.938] - relay: TRUE
[17:36:37.938] - stdout: TRUE
[17:36:37.938] - signal: TRUE
[17:36:37.938] - resignal: FALSE
[17:36:37.938] - force: TRUE
[17:36:37.939] - relayed: [n=2] TRUE, TRUE
[17:36:37.939] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:37.939] - relayed: [n=2] TRUE, TRUE
[17:36:37.939] - queued futures: [n=2] TRUE, TRUE
[17:36:37.939] signalConditionsASAP(NULL, pos=0) ... done
[17:36:37.939] resolve() on list ... DONE
[17:36:37.939] result() for ClusterFuture ...
[17:36:37.939] - result already collected: FutureResult
[17:36:37.939] result() for ClusterFuture ... done
[17:36:37.939] result() for ClusterFuture ...
[17:36:37.939] - result already collected: FutureResult
[17:36:37.940] result() for ClusterFuture ... done
[17:36:37.940] result() for ClusterFuture ...
[17:36:37.940] - result already collected: FutureResult
[17:36:37.940] result() for ClusterFuture ... done
[17:36:37.940] result() for ClusterFuture ...
[17:36:37.940] - result already collected: FutureResult
[17:36:37.940] result() for ClusterFuture ... done
[17:36:37.940]  - Number of value chunks collected: 2
[17:36:37.940] Resolving 2 futures (chunks) ... DONE
[17:36:37.940] Reducing values from 2 chunks ...
[17:36:37.940]  - Number of values collected after concatenation: 2
[17:36:37.941]  - Number of values expected: 2
[17:36:37.941] Reducing values from 2 chunks ... DONE
[17:36:37.941] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[17:36:37.941] getGlobalsAndPackagesXApply() ...
[17:36:37.941]  - future.globals: TRUE
[17:36:37.941] getGlobalsAndPackages() ...
[17:36:37.941] Searching for globals...
[17:36:37.942] - globals found: [1] ‘FUN’
[17:36:37.942] Searching for globals ... DONE
[17:36:37.943] Resolving globals: FALSE
[17:36:37.943] The total size of the 1 globals is 848 bytes (848 bytes)
[17:36:37.943] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:36:37.943] - globals: [1] ‘FUN’
[17:36:37.943] 
[17:36:37.944] getGlobalsAndPackages() ... DONE
[17:36:37.944]  - globals found/used: [n=1] ‘FUN’
[17:36:37.944]  - needed namespaces: [n=0] 
[17:36:37.944] Finding globals ... DONE
[17:36:37.944]  - use_args: TRUE
[17:36:37.944]  - Getting '...' globals ...
[17:36:37.944] resolve() on list ...
[17:36:37.944]  recursive: 0
[17:36:37.945]  length: 1
[17:36:37.945]  elements: ‘...’
[17:36:37.945]  length: 0 (resolved future 1)
[17:36:37.945] resolve() on list ... DONE
[17:36:37.945]    - '...' content: [n=0] 
[17:36:37.945] List of 1
[17:36:37.945]  $ ...: list()
[17:36:37.945]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:37.945]  - attr(*, "where")=List of 1
[17:36:37.945]   ..$ ...:<environment: 0x556d778b58e8> 
[17:36:37.945]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:37.945]  - attr(*, "resolved")= logi TRUE
[17:36:37.945]  - attr(*, "total_size")= num NA
[17:36:37.947]  - Getting '...' globals ... DONE
[17:36:37.948] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:37.948] List of 2
[17:36:37.948]  $ ...future.FUN:function (x)  
[17:36:37.948]  $ ...          : list()
[17:36:37.948]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:37.948]  - attr(*, "where")=List of 2
[17:36:37.948]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:37.948]   ..$ ...          :<environment: 0x556d778b58e8> 
[17:36:37.948]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:37.948]  - attr(*, "resolved")= logi FALSE
[17:36:37.948]  - attr(*, "total_size")= num 848
[17:36:37.950] Packages to be attached in all futures: [n=0] 
[17:36:37.950] getGlobalsAndPackagesXApply() ... DONE
[17:36:37.954] future_lapply() ...
[17:36:37.958] Number of chunks: 2
[17:36:37.958] getGlobalsAndPackagesXApply() ...
[17:36:37.958]  - future.globals: <name-value list> with names ‘list()’
[17:36:37.958]  - use_args: TRUE
[17:36:37.958] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:37.958] List of 2
[17:36:37.958]  $ ...          : list()
[17:36:37.958]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:37.958]  $ ...future.FUN:function (x)  
[17:36:37.958]  - attr(*, "where")=List of 2
[17:36:37.958]   ..$ ...          :<environment: 0x556d778b58e8> 
[17:36:37.958]   ..$ ...future.FUN:<environment: namespace:base> 
[17:36:37.958]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:37.958]  - attr(*, "resolved")= logi FALSE
[17:36:37.958]  - attr(*, "total_size")= num NA
[17:36:37.962] Packages to be attached in all futures: [n=0] 
[17:36:37.962] getGlobalsAndPackagesXApply() ... DONE
[17:36:37.962] Number of futures (= number of chunks): 2
[17:36:37.962] Launching 2 futures (chunks) ...
[17:36:37.962] Chunk #1 of 2 ...
[17:36:37.962]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:37.962]  - seeds: <none>
[17:36:37.962]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.963] getGlobalsAndPackages() ...
[17:36:37.963] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.963] Resolving globals: FALSE
[17:36:37.963] Tweak future expression to call with '...' arguments ...
[17:36:37.963] {
[17:36:37.963]     do.call(function(...) {
[17:36:37.963]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.963]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:37.963]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.963]             on.exit(options(oopts), add = TRUE)
[17:36:37.963]         }
[17:36:37.963]         {
[17:36:37.963]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:37.963]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.963]                 ...future.FUN(...future.X_jj, ...)
[17:36:37.963]             })
[17:36:37.963]         }
[17:36:37.963]     }, args = future.call.arguments)
[17:36:37.963] }
[17:36:37.963] Tweak future expression to call with '...' arguments ... DONE
[17:36:37.964] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:37.964] 
[17:36:37.964] getGlobalsAndPackages() ... DONE
[17:36:37.964] run() for ‘Future’ ...
[17:36:37.964] - state: ‘created’
[17:36:37.964] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:37.978] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:37.978] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:37.978]   - Field: ‘node’
[17:36:37.978]   - Field: ‘label’
[17:36:37.978]   - Field: ‘local’
[17:36:37.978]   - Field: ‘owner’
[17:36:37.979]   - Field: ‘envir’
[17:36:37.979]   - Field: ‘workers’
[17:36:37.979]   - Field: ‘packages’
[17:36:37.979]   - Field: ‘gc’
[17:36:37.979]   - Field: ‘conditions’
[17:36:37.979]   - Field: ‘persistent’
[17:36:37.979]   - Field: ‘expr’
[17:36:37.979]   - Field: ‘uuid’
[17:36:37.979]   - Field: ‘seed’
[17:36:37.979]   - Field: ‘version’
[17:36:37.979]   - Field: ‘result’
[17:36:37.980]   - Field: ‘asynchronous’
[17:36:37.980]   - Field: ‘calls’
[17:36:37.980]   - Field: ‘globals’
[17:36:37.980]   - Field: ‘stdout’
[17:36:37.980]   - Field: ‘earlySignal’
[17:36:37.980]   - Field: ‘lazy’
[17:36:37.980]   - Field: ‘state’
[17:36:37.980] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:37.980] - Launch lazy future ...
[17:36:37.981] Packages needed by the future expression (n = 0): <none>
[17:36:37.981] Packages needed by future strategies (n = 0): <none>
[17:36:37.981] {
[17:36:37.981]     {
[17:36:37.981]         {
[17:36:37.981]             ...future.startTime <- base::Sys.time()
[17:36:37.981]             {
[17:36:37.981]                 {
[17:36:37.981]                   {
[17:36:37.981]                     {
[17:36:37.981]                       base::local({
[17:36:37.981]                         has_future <- base::requireNamespace("future", 
[17:36:37.981]                           quietly = TRUE)
[17:36:37.981]                         if (has_future) {
[17:36:37.981]                           ns <- base::getNamespace("future")
[17:36:37.981]                           version <- ns[[".package"]][["version"]]
[17:36:37.981]                           if (is.null(version)) 
[17:36:37.981]                             version <- utils::packageVersion("future")
[17:36:37.981]                         }
[17:36:37.981]                         else {
[17:36:37.981]                           version <- NULL
[17:36:37.981]                         }
[17:36:37.981]                         if (!has_future || version < "1.8.0") {
[17:36:37.981]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:37.981]                             "", base::R.version$version.string), 
[17:36:37.981]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:37.981]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:37.981]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:37.981]                               "release", "version")], collapse = " "), 
[17:36:37.981]                             hostname = base::Sys.info()[["nodename"]])
[17:36:37.981]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:37.981]                             info)
[17:36:37.981]                           info <- base::paste(info, collapse = "; ")
[17:36:37.981]                           if (!has_future) {
[17:36:37.981]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:37.981]                               info)
[17:36:37.981]                           }
[17:36:37.981]                           else {
[17:36:37.981]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:37.981]                               info, version)
[17:36:37.981]                           }
[17:36:37.981]                           base::stop(msg)
[17:36:37.981]                         }
[17:36:37.981]                       })
[17:36:37.981]                     }
[17:36:37.981]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:37.981]                     base::options(mc.cores = 1L)
[17:36:37.981]                   }
[17:36:37.981]                   ...future.strategy.old <- future::plan("list")
[17:36:37.981]                   options(future.plan = NULL)
[17:36:37.981]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:37.981]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:37.981]                 }
[17:36:37.981]                 ...future.workdir <- getwd()
[17:36:37.981]             }
[17:36:37.981]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:37.981]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:37.981]         }
[17:36:37.981]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:37.981]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:37.981]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:37.981]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:37.981]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:37.981]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:37.981]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:37.981]             base::names(...future.oldOptions))
[17:36:37.981]     }
[17:36:37.981]     if (FALSE) {
[17:36:37.981]     }
[17:36:37.981]     else {
[17:36:37.981]         if (TRUE) {
[17:36:37.981]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:37.981]                 open = "w")
[17:36:37.981]         }
[17:36:37.981]         else {
[17:36:37.981]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:37.981]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:37.981]         }
[17:36:37.981]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:37.981]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:37.981]             base::sink(type = "output", split = FALSE)
[17:36:37.981]             base::close(...future.stdout)
[17:36:37.981]         }, add = TRUE)
[17:36:37.981]     }
[17:36:37.981]     ...future.frame <- base::sys.nframe()
[17:36:37.981]     ...future.conditions <- base::list()
[17:36:37.981]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:37.981]     if (FALSE) {
[17:36:37.981]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:37.981]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:37.981]     }
[17:36:37.981]     ...future.result <- base::tryCatch({
[17:36:37.981]         base::withCallingHandlers({
[17:36:37.981]             ...future.value <- base::withVisible(base::local({
[17:36:37.981]                 ...future.makeSendCondition <- base::local({
[17:36:37.981]                   sendCondition <- NULL
[17:36:37.981]                   function(frame = 1L) {
[17:36:37.981]                     if (is.function(sendCondition)) 
[17:36:37.981]                       return(sendCondition)
[17:36:37.981]                     ns <- getNamespace("parallel")
[17:36:37.981]                     if (exists("sendData", mode = "function", 
[17:36:37.981]                       envir = ns)) {
[17:36:37.981]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:37.981]                         envir = ns)
[17:36:37.981]                       envir <- sys.frame(frame)
[17:36:37.981]                       master <- NULL
[17:36:37.981]                       while (!identical(envir, .GlobalEnv) && 
[17:36:37.981]                         !identical(envir, emptyenv())) {
[17:36:37.981]                         if (exists("master", mode = "list", envir = envir, 
[17:36:37.981]                           inherits = FALSE)) {
[17:36:37.981]                           master <- get("master", mode = "list", 
[17:36:37.981]                             envir = envir, inherits = FALSE)
[17:36:37.981]                           if (inherits(master, c("SOCKnode", 
[17:36:37.981]                             "SOCK0node"))) {
[17:36:37.981]                             sendCondition <<- function(cond) {
[17:36:37.981]                               data <- list(type = "VALUE", value = cond, 
[17:36:37.981]                                 success = TRUE)
[17:36:37.981]                               parallel_sendData(master, data)
[17:36:37.981]                             }
[17:36:37.981]                             return(sendCondition)
[17:36:37.981]                           }
[17:36:37.981]                         }
[17:36:37.981]                         frame <- frame + 1L
[17:36:37.981]                         envir <- sys.frame(frame)
[17:36:37.981]                       }
[17:36:37.981]                     }
[17:36:37.981]                     sendCondition <<- function(cond) NULL
[17:36:37.981]                   }
[17:36:37.981]                 })
[17:36:37.981]                 withCallingHandlers({
[17:36:37.981]                   {
[17:36:37.981]                     do.call(function(...) {
[17:36:37.981]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.981]                       if (!identical(...future.globals.maxSize.org, 
[17:36:37.981]                         ...future.globals.maxSize)) {
[17:36:37.981]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.981]                         on.exit(options(oopts), add = TRUE)
[17:36:37.981]                       }
[17:36:37.981]                       {
[17:36:37.981]                         lapply(seq_along(...future.elements_ii), 
[17:36:37.981]                           FUN = function(jj) {
[17:36:37.981]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.981]                             ...future.FUN(...future.X_jj, ...)
[17:36:37.981]                           })
[17:36:37.981]                       }
[17:36:37.981]                     }, args = future.call.arguments)
[17:36:37.981]                   }
[17:36:37.981]                 }, immediateCondition = function(cond) {
[17:36:37.981]                   sendCondition <- ...future.makeSendCondition()
[17:36:37.981]                   sendCondition(cond)
[17:36:37.981]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.981]                   {
[17:36:37.981]                     inherits <- base::inherits
[17:36:37.981]                     invokeRestart <- base::invokeRestart
[17:36:37.981]                     is.null <- base::is.null
[17:36:37.981]                     muffled <- FALSE
[17:36:37.981]                     if (inherits(cond, "message")) {
[17:36:37.981]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:37.981]                       if (muffled) 
[17:36:37.981]                         invokeRestart("muffleMessage")
[17:36:37.981]                     }
[17:36:37.981]                     else if (inherits(cond, "warning")) {
[17:36:37.981]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:37.981]                       if (muffled) 
[17:36:37.981]                         invokeRestart("muffleWarning")
[17:36:37.981]                     }
[17:36:37.981]                     else if (inherits(cond, "condition")) {
[17:36:37.981]                       if (!is.null(pattern)) {
[17:36:37.981]                         computeRestarts <- base::computeRestarts
[17:36:37.981]                         grepl <- base::grepl
[17:36:37.981]                         restarts <- computeRestarts(cond)
[17:36:37.981]                         for (restart in restarts) {
[17:36:37.981]                           name <- restart$name
[17:36:37.981]                           if (is.null(name)) 
[17:36:37.981]                             next
[17:36:37.981]                           if (!grepl(pattern, name)) 
[17:36:37.981]                             next
[17:36:37.981]                           invokeRestart(restart)
[17:36:37.981]                           muffled <- TRUE
[17:36:37.981]                           break
[17:36:37.981]                         }
[17:36:37.981]                       }
[17:36:37.981]                     }
[17:36:37.981]                     invisible(muffled)
[17:36:37.981]                   }
[17:36:37.981]                   muffleCondition(cond)
[17:36:37.981]                 })
[17:36:37.981]             }))
[17:36:37.981]             future::FutureResult(value = ...future.value$value, 
[17:36:37.981]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:37.981]                   ...future.rng), globalenv = if (FALSE) 
[17:36:37.981]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:37.981]                     ...future.globalenv.names))
[17:36:37.981]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:37.981]         }, condition = base::local({
[17:36:37.981]             c <- base::c
[17:36:37.981]             inherits <- base::inherits
[17:36:37.981]             invokeRestart <- base::invokeRestart
[17:36:37.981]             length <- base::length
[17:36:37.981]             list <- base::list
[17:36:37.981]             seq.int <- base::seq.int
[17:36:37.981]             signalCondition <- base::signalCondition
[17:36:37.981]             sys.calls <- base::sys.calls
[17:36:37.981]             `[[` <- base::`[[`
[17:36:37.981]             `+` <- base::`+`
[17:36:37.981]             `<<-` <- base::`<<-`
[17:36:37.981]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:37.981]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:37.981]                   3L)]
[17:36:37.981]             }
[17:36:37.981]             function(cond) {
[17:36:37.981]                 is_error <- inherits(cond, "error")
[17:36:37.981]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:37.981]                   NULL)
[17:36:37.981]                 if (is_error) {
[17:36:37.981]                   sessionInformation <- function() {
[17:36:37.981]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:37.981]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:37.981]                       search = base::search(), system = base::Sys.info())
[17:36:37.981]                   }
[17:36:37.981]                   ...future.conditions[[length(...future.conditions) + 
[17:36:37.981]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:37.981]                     cond$call), session = sessionInformation(), 
[17:36:37.981]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:37.981]                   signalCondition(cond)
[17:36:37.981]                 }
[17:36:37.981]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:37.981]                 "immediateCondition"))) {
[17:36:37.981]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:37.981]                   ...future.conditions[[length(...future.conditions) + 
[17:36:37.981]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:37.981]                   if (TRUE && !signal) {
[17:36:37.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.981]                     {
[17:36:37.981]                       inherits <- base::inherits
[17:36:37.981]                       invokeRestart <- base::invokeRestart
[17:36:37.981]                       is.null <- base::is.null
[17:36:37.981]                       muffled <- FALSE
[17:36:37.981]                       if (inherits(cond, "message")) {
[17:36:37.981]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:37.981]                         if (muffled) 
[17:36:37.981]                           invokeRestart("muffleMessage")
[17:36:37.981]                       }
[17:36:37.981]                       else if (inherits(cond, "warning")) {
[17:36:37.981]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:37.981]                         if (muffled) 
[17:36:37.981]                           invokeRestart("muffleWarning")
[17:36:37.981]                       }
[17:36:37.981]                       else if (inherits(cond, "condition")) {
[17:36:37.981]                         if (!is.null(pattern)) {
[17:36:37.981]                           computeRestarts <- base::computeRestarts
[17:36:37.981]                           grepl <- base::grepl
[17:36:37.981]                           restarts <- computeRestarts(cond)
[17:36:37.981]                           for (restart in restarts) {
[17:36:37.981]                             name <- restart$name
[17:36:37.981]                             if (is.null(name)) 
[17:36:37.981]                               next
[17:36:37.981]                             if (!grepl(pattern, name)) 
[17:36:37.981]                               next
[17:36:37.981]                             invokeRestart(restart)
[17:36:37.981]                             muffled <- TRUE
[17:36:37.981]                             break
[17:36:37.981]                           }
[17:36:37.981]                         }
[17:36:37.981]                       }
[17:36:37.981]                       invisible(muffled)
[17:36:37.981]                     }
[17:36:37.981]                     muffleCondition(cond, pattern = "^muffle")
[17:36:37.981]                   }
[17:36:37.981]                 }
[17:36:37.981]                 else {
[17:36:37.981]                   if (TRUE) {
[17:36:37.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:37.981]                     {
[17:36:37.981]                       inherits <- base::inherits
[17:36:37.981]                       invokeRestart <- base::invokeRestart
[17:36:37.981]                       is.null <- base::is.null
[17:36:37.981]                       muffled <- FALSE
[17:36:37.981]                       if (inherits(cond, "message")) {
[17:36:37.981]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:37.981]                         if (muffled) 
[17:36:37.981]                           invokeRestart("muffleMessage")
[17:36:37.981]                       }
[17:36:37.981]                       else if (inherits(cond, "warning")) {
[17:36:37.981]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:37.981]                         if (muffled) 
[17:36:37.981]                           invokeRestart("muffleWarning")
[17:36:37.981]                       }
[17:36:37.981]                       else if (inherits(cond, "condition")) {
[17:36:37.981]                         if (!is.null(pattern)) {
[17:36:37.981]                           computeRestarts <- base::computeRestarts
[17:36:37.981]                           grepl <- base::grepl
[17:36:37.981]                           restarts <- computeRestarts(cond)
[17:36:37.981]                           for (restart in restarts) {
[17:36:37.981]                             name <- restart$name
[17:36:37.981]                             if (is.null(name)) 
[17:36:37.981]                               next
[17:36:37.981]                             if (!grepl(pattern, name)) 
[17:36:37.981]                               next
[17:36:37.981]                             invokeRestart(restart)
[17:36:37.981]                             muffled <- TRUE
[17:36:37.981]                             break
[17:36:37.981]                           }
[17:36:37.981]                         }
[17:36:37.981]                       }
[17:36:37.981]                       invisible(muffled)
[17:36:37.981]                     }
[17:36:37.981]                     muffleCondition(cond, pattern = "^muffle")
[17:36:37.981]                   }
[17:36:37.981]                 }
[17:36:37.981]             }
[17:36:37.981]         }))
[17:36:37.981]     }, error = function(ex) {
[17:36:37.981]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:37.981]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:37.981]                 ...future.rng), started = ...future.startTime, 
[17:36:37.981]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:37.981]             version = "1.8"), class = "FutureResult")
[17:36:37.981]     }, finally = {
[17:36:37.981]         if (!identical(...future.workdir, getwd())) 
[17:36:37.981]             setwd(...future.workdir)
[17:36:37.981]         {
[17:36:37.981]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:37.981]                 ...future.oldOptions$nwarnings <- NULL
[17:36:37.981]             }
[17:36:37.981]             base::options(...future.oldOptions)
[17:36:37.981]             if (.Platform$OS.type == "windows") {
[17:36:37.981]                 old_names <- names(...future.oldEnvVars)
[17:36:37.981]                 envs <- base::Sys.getenv()
[17:36:37.981]                 names <- names(envs)
[17:36:37.981]                 common <- intersect(names, old_names)
[17:36:37.981]                 added <- setdiff(names, old_names)
[17:36:37.981]                 removed <- setdiff(old_names, names)
[17:36:37.981]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:37.981]                   envs[common]]
[17:36:37.981]                 NAMES <- toupper(changed)
[17:36:37.981]                 args <- list()
[17:36:37.981]                 for (kk in seq_along(NAMES)) {
[17:36:37.981]                   name <- changed[[kk]]
[17:36:37.981]                   NAME <- NAMES[[kk]]
[17:36:37.981]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.981]                     next
[17:36:37.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:37.981]                 }
[17:36:37.981]                 NAMES <- toupper(added)
[17:36:37.981]                 for (kk in seq_along(NAMES)) {
[17:36:37.981]                   name <- added[[kk]]
[17:36:37.981]                   NAME <- NAMES[[kk]]
[17:36:37.981]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.981]                     next
[17:36:37.981]                   args[[name]] <- ""
[17:36:37.981]                 }
[17:36:37.981]                 NAMES <- toupper(removed)
[17:36:37.981]                 for (kk in seq_along(NAMES)) {
[17:36:37.981]                   name <- removed[[kk]]
[17:36:37.981]                   NAME <- NAMES[[kk]]
[17:36:37.981]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:37.981]                     next
[17:36:37.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:37.981]                 }
[17:36:37.981]                 if (length(args) > 0) 
[17:36:37.981]                   base::do.call(base::Sys.setenv, args = args)
[17:36:37.981]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:37.981]             }
[17:36:37.981]             else {
[17:36:37.981]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:37.981]             }
[17:36:37.981]             {
[17:36:37.981]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:37.981]                   0L) {
[17:36:37.981]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:37.981]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:37.981]                   base::options(opts)
[17:36:37.981]                 }
[17:36:37.981]                 {
[17:36:37.981]                   {
[17:36:37.981]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:37.981]                     NULL
[17:36:37.981]                   }
[17:36:37.981]                   options(future.plan = NULL)
[17:36:37.981]                   if (is.na(NA_character_)) 
[17:36:37.981]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:37.981]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:37.981]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:37.981]                     .init = FALSE)
[17:36:37.981]                 }
[17:36:37.981]             }
[17:36:37.981]         }
[17:36:37.981]     })
[17:36:37.981]     if (TRUE) {
[17:36:37.981]         base::sink(type = "output", split = FALSE)
[17:36:37.981]         if (TRUE) {
[17:36:37.981]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:37.981]         }
[17:36:37.981]         else {
[17:36:37.981]             ...future.result["stdout"] <- base::list(NULL)
[17:36:37.981]         }
[17:36:37.981]         base::close(...future.stdout)
[17:36:37.981]         ...future.stdout <- NULL
[17:36:37.981]     }
[17:36:37.981]     ...future.result$conditions <- ...future.conditions
[17:36:37.981]     ...future.result$finished <- base::Sys.time()
[17:36:37.981]     ...future.result
[17:36:37.981] }
[17:36:37.984] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[17:36:37.984] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:36:37.985] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:36:37.985] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:36:37.985] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:36:37.985] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[17:36:37.986] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[17:36:37.986] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:36:37.986] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:36:37.986] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:36:37.987] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:36:37.987] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[17:36:37.987] MultisessionFuture started
[17:36:37.988] - Launch lazy future ... done
[17:36:37.988] run() for ‘MultisessionFuture’ ... done
[17:36:37.988] Created future:
[17:36:37.988] MultisessionFuture:
[17:36:37.988] Label: ‘future_apply-1’
[17:36:37.988] Expression:
[17:36:37.988] {
[17:36:37.988]     do.call(function(...) {
[17:36:37.988]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:37.988]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:37.988]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:37.988]             on.exit(options(oopts), add = TRUE)
[17:36:37.988]         }
[17:36:37.988]         {
[17:36:37.988]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:37.988]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:37.988]                 ...future.FUN(...future.X_jj, ...)
[17:36:37.988]             })
[17:36:37.988]         }
[17:36:37.988]     }, args = future.call.arguments)
[17:36:37.988] }
[17:36:37.988] Lazy evaluation: FALSE
[17:36:37.988] Asynchronous evaluation: TRUE
[17:36:37.988] Local evaluation: TRUE
[17:36:37.988] Environment: R_GlobalEnv
[17:36:37.988] Capture standard output: TRUE
[17:36:37.988] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:37.988] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:37.988] Packages: <none>
[17:36:37.988] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:37.988] Resolved: FALSE
[17:36:37.988] Value: <not collected>
[17:36:37.988] Conditions captured: <none>
[17:36:37.988] Early signaling: FALSE
[17:36:37.988] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:37.988] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.000] Chunk #1 of 2 ... DONE
[17:36:38.000] Chunk #2 of 2 ...
[17:36:38.000]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:38.000]  - seeds: <none>
[17:36:38.000]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.000] getGlobalsAndPackages() ...
[17:36:38.000] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.000] Resolving globals: FALSE
[17:36:38.001] Tweak future expression to call with '...' arguments ...
[17:36:38.001] {
[17:36:38.001]     do.call(function(...) {
[17:36:38.001]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.001]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:38.001]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.001]             on.exit(options(oopts), add = TRUE)
[17:36:38.001]         }
[17:36:38.001]         {
[17:36:38.001]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:38.001]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.001]                 ...future.FUN(...future.X_jj, ...)
[17:36:38.001]             })
[17:36:38.001]         }
[17:36:38.001]     }, args = future.call.arguments)
[17:36:38.001] }
[17:36:38.001] Tweak future expression to call with '...' arguments ... DONE
[17:36:38.001] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.001] 
[17:36:38.001] getGlobalsAndPackages() ... DONE
[17:36:38.002] run() for ‘Future’ ...
[17:36:38.002] - state: ‘created’
[17:36:38.002] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:38.016] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.016] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:38.016]   - Field: ‘node’
[17:36:38.016]   - Field: ‘label’
[17:36:38.016]   - Field: ‘local’
[17:36:38.016]   - Field: ‘owner’
[17:36:38.017]   - Field: ‘envir’
[17:36:38.017]   - Field: ‘workers’
[17:36:38.017]   - Field: ‘packages’
[17:36:38.017]   - Field: ‘gc’
[17:36:38.017]   - Field: ‘conditions’
[17:36:38.017]   - Field: ‘persistent’
[17:36:38.017]   - Field: ‘expr’
[17:36:38.017]   - Field: ‘uuid’
[17:36:38.017]   - Field: ‘seed’
[17:36:38.017]   - Field: ‘version’
[17:36:38.017]   - Field: ‘result’
[17:36:38.018]   - Field: ‘asynchronous’
[17:36:38.018]   - Field: ‘calls’
[17:36:38.018]   - Field: ‘globals’
[17:36:38.018]   - Field: ‘stdout’
[17:36:38.018]   - Field: ‘earlySignal’
[17:36:38.018]   - Field: ‘lazy’
[17:36:38.018]   - Field: ‘state’
[17:36:38.018] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:38.018] - Launch lazy future ...
[17:36:38.018] Packages needed by the future expression (n = 0): <none>
[17:36:38.019] Packages needed by future strategies (n = 0): <none>
[17:36:38.021] {
[17:36:38.021]     {
[17:36:38.021]         {
[17:36:38.021]             ...future.startTime <- base::Sys.time()
[17:36:38.021]             {
[17:36:38.021]                 {
[17:36:38.021]                   {
[17:36:38.021]                     {
[17:36:38.021]                       base::local({
[17:36:38.021]                         has_future <- base::requireNamespace("future", 
[17:36:38.021]                           quietly = TRUE)
[17:36:38.021]                         if (has_future) {
[17:36:38.021]                           ns <- base::getNamespace("future")
[17:36:38.021]                           version <- ns[[".package"]][["version"]]
[17:36:38.021]                           if (is.null(version)) 
[17:36:38.021]                             version <- utils::packageVersion("future")
[17:36:38.021]                         }
[17:36:38.021]                         else {
[17:36:38.021]                           version <- NULL
[17:36:38.021]                         }
[17:36:38.021]                         if (!has_future || version < "1.8.0") {
[17:36:38.021]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:38.021]                             "", base::R.version$version.string), 
[17:36:38.021]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:38.021]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:38.021]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:38.021]                               "release", "version")], collapse = " "), 
[17:36:38.021]                             hostname = base::Sys.info()[["nodename"]])
[17:36:38.021]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:38.021]                             info)
[17:36:38.021]                           info <- base::paste(info, collapse = "; ")
[17:36:38.021]                           if (!has_future) {
[17:36:38.021]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:38.021]                               info)
[17:36:38.021]                           }
[17:36:38.021]                           else {
[17:36:38.021]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:38.021]                               info, version)
[17:36:38.021]                           }
[17:36:38.021]                           base::stop(msg)
[17:36:38.021]                         }
[17:36:38.021]                       })
[17:36:38.021]                     }
[17:36:38.021]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:38.021]                     base::options(mc.cores = 1L)
[17:36:38.021]                   }
[17:36:38.021]                   ...future.strategy.old <- future::plan("list")
[17:36:38.021]                   options(future.plan = NULL)
[17:36:38.021]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:38.021]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:38.021]                 }
[17:36:38.021]                 ...future.workdir <- getwd()
[17:36:38.021]             }
[17:36:38.021]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:38.021]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:38.021]         }
[17:36:38.021]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:38.021]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:38.021]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:38.021]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:38.021]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:38.021]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:38.021]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:38.021]             base::names(...future.oldOptions))
[17:36:38.021]     }
[17:36:38.021]     if (FALSE) {
[17:36:38.021]     }
[17:36:38.021]     else {
[17:36:38.021]         if (TRUE) {
[17:36:38.021]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:38.021]                 open = "w")
[17:36:38.021]         }
[17:36:38.021]         else {
[17:36:38.021]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:38.021]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:38.021]         }
[17:36:38.021]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:38.021]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:38.021]             base::sink(type = "output", split = FALSE)
[17:36:38.021]             base::close(...future.stdout)
[17:36:38.021]         }, add = TRUE)
[17:36:38.021]     }
[17:36:38.021]     ...future.frame <- base::sys.nframe()
[17:36:38.021]     ...future.conditions <- base::list()
[17:36:38.021]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:38.021]     if (FALSE) {
[17:36:38.021]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:38.021]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:38.021]     }
[17:36:38.021]     ...future.result <- base::tryCatch({
[17:36:38.021]         base::withCallingHandlers({
[17:36:38.021]             ...future.value <- base::withVisible(base::local({
[17:36:38.021]                 ...future.makeSendCondition <- base::local({
[17:36:38.021]                   sendCondition <- NULL
[17:36:38.021]                   function(frame = 1L) {
[17:36:38.021]                     if (is.function(sendCondition)) 
[17:36:38.021]                       return(sendCondition)
[17:36:38.021]                     ns <- getNamespace("parallel")
[17:36:38.021]                     if (exists("sendData", mode = "function", 
[17:36:38.021]                       envir = ns)) {
[17:36:38.021]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:38.021]                         envir = ns)
[17:36:38.021]                       envir <- sys.frame(frame)
[17:36:38.021]                       master <- NULL
[17:36:38.021]                       while (!identical(envir, .GlobalEnv) && 
[17:36:38.021]                         !identical(envir, emptyenv())) {
[17:36:38.021]                         if (exists("master", mode = "list", envir = envir, 
[17:36:38.021]                           inherits = FALSE)) {
[17:36:38.021]                           master <- get("master", mode = "list", 
[17:36:38.021]                             envir = envir, inherits = FALSE)
[17:36:38.021]                           if (inherits(master, c("SOCKnode", 
[17:36:38.021]                             "SOCK0node"))) {
[17:36:38.021]                             sendCondition <<- function(cond) {
[17:36:38.021]                               data <- list(type = "VALUE", value = cond, 
[17:36:38.021]                                 success = TRUE)
[17:36:38.021]                               parallel_sendData(master, data)
[17:36:38.021]                             }
[17:36:38.021]                             return(sendCondition)
[17:36:38.021]                           }
[17:36:38.021]                         }
[17:36:38.021]                         frame <- frame + 1L
[17:36:38.021]                         envir <- sys.frame(frame)
[17:36:38.021]                       }
[17:36:38.021]                     }
[17:36:38.021]                     sendCondition <<- function(cond) NULL
[17:36:38.021]                   }
[17:36:38.021]                 })
[17:36:38.021]                 withCallingHandlers({
[17:36:38.021]                   {
[17:36:38.021]                     do.call(function(...) {
[17:36:38.021]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.021]                       if (!identical(...future.globals.maxSize.org, 
[17:36:38.021]                         ...future.globals.maxSize)) {
[17:36:38.021]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.021]                         on.exit(options(oopts), add = TRUE)
[17:36:38.021]                       }
[17:36:38.021]                       {
[17:36:38.021]                         lapply(seq_along(...future.elements_ii), 
[17:36:38.021]                           FUN = function(jj) {
[17:36:38.021]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.021]                             ...future.FUN(...future.X_jj, ...)
[17:36:38.021]                           })
[17:36:38.021]                       }
[17:36:38.021]                     }, args = future.call.arguments)
[17:36:38.021]                   }
[17:36:38.021]                 }, immediateCondition = function(cond) {
[17:36:38.021]                   sendCondition <- ...future.makeSendCondition()
[17:36:38.021]                   sendCondition(cond)
[17:36:38.021]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.021]                   {
[17:36:38.021]                     inherits <- base::inherits
[17:36:38.021]                     invokeRestart <- base::invokeRestart
[17:36:38.021]                     is.null <- base::is.null
[17:36:38.021]                     muffled <- FALSE
[17:36:38.021]                     if (inherits(cond, "message")) {
[17:36:38.021]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:38.021]                       if (muffled) 
[17:36:38.021]                         invokeRestart("muffleMessage")
[17:36:38.021]                     }
[17:36:38.021]                     else if (inherits(cond, "warning")) {
[17:36:38.021]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:38.021]                       if (muffled) 
[17:36:38.021]                         invokeRestart("muffleWarning")
[17:36:38.021]                     }
[17:36:38.021]                     else if (inherits(cond, "condition")) {
[17:36:38.021]                       if (!is.null(pattern)) {
[17:36:38.021]                         computeRestarts <- base::computeRestarts
[17:36:38.021]                         grepl <- base::grepl
[17:36:38.021]                         restarts <- computeRestarts(cond)
[17:36:38.021]                         for (restart in restarts) {
[17:36:38.021]                           name <- restart$name
[17:36:38.021]                           if (is.null(name)) 
[17:36:38.021]                             next
[17:36:38.021]                           if (!grepl(pattern, name)) 
[17:36:38.021]                             next
[17:36:38.021]                           invokeRestart(restart)
[17:36:38.021]                           muffled <- TRUE
[17:36:38.021]                           break
[17:36:38.021]                         }
[17:36:38.021]                       }
[17:36:38.021]                     }
[17:36:38.021]                     invisible(muffled)
[17:36:38.021]                   }
[17:36:38.021]                   muffleCondition(cond)
[17:36:38.021]                 })
[17:36:38.021]             }))
[17:36:38.021]             future::FutureResult(value = ...future.value$value, 
[17:36:38.021]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:38.021]                   ...future.rng), globalenv = if (FALSE) 
[17:36:38.021]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:38.021]                     ...future.globalenv.names))
[17:36:38.021]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:38.021]         }, condition = base::local({
[17:36:38.021]             c <- base::c
[17:36:38.021]             inherits <- base::inherits
[17:36:38.021]             invokeRestart <- base::invokeRestart
[17:36:38.021]             length <- base::length
[17:36:38.021]             list <- base::list
[17:36:38.021]             seq.int <- base::seq.int
[17:36:38.021]             signalCondition <- base::signalCondition
[17:36:38.021]             sys.calls <- base::sys.calls
[17:36:38.021]             `[[` <- base::`[[`
[17:36:38.021]             `+` <- base::`+`
[17:36:38.021]             `<<-` <- base::`<<-`
[17:36:38.021]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:38.021]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:38.021]                   3L)]
[17:36:38.021]             }
[17:36:38.021]             function(cond) {
[17:36:38.021]                 is_error <- inherits(cond, "error")
[17:36:38.021]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:38.021]                   NULL)
[17:36:38.021]                 if (is_error) {
[17:36:38.021]                   sessionInformation <- function() {
[17:36:38.021]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:38.021]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:38.021]                       search = base::search(), system = base::Sys.info())
[17:36:38.021]                   }
[17:36:38.021]                   ...future.conditions[[length(...future.conditions) + 
[17:36:38.021]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:38.021]                     cond$call), session = sessionInformation(), 
[17:36:38.021]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:38.021]                   signalCondition(cond)
[17:36:38.021]                 }
[17:36:38.021]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:38.021]                 "immediateCondition"))) {
[17:36:38.021]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:38.021]                   ...future.conditions[[length(...future.conditions) + 
[17:36:38.021]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:38.021]                   if (TRUE && !signal) {
[17:36:38.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.021]                     {
[17:36:38.021]                       inherits <- base::inherits
[17:36:38.021]                       invokeRestart <- base::invokeRestart
[17:36:38.021]                       is.null <- base::is.null
[17:36:38.021]                       muffled <- FALSE
[17:36:38.021]                       if (inherits(cond, "message")) {
[17:36:38.021]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:38.021]                         if (muffled) 
[17:36:38.021]                           invokeRestart("muffleMessage")
[17:36:38.021]                       }
[17:36:38.021]                       else if (inherits(cond, "warning")) {
[17:36:38.021]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:38.021]                         if (muffled) 
[17:36:38.021]                           invokeRestart("muffleWarning")
[17:36:38.021]                       }
[17:36:38.021]                       else if (inherits(cond, "condition")) {
[17:36:38.021]                         if (!is.null(pattern)) {
[17:36:38.021]                           computeRestarts <- base::computeRestarts
[17:36:38.021]                           grepl <- base::grepl
[17:36:38.021]                           restarts <- computeRestarts(cond)
[17:36:38.021]                           for (restart in restarts) {
[17:36:38.021]                             name <- restart$name
[17:36:38.021]                             if (is.null(name)) 
[17:36:38.021]                               next
[17:36:38.021]                             if (!grepl(pattern, name)) 
[17:36:38.021]                               next
[17:36:38.021]                             invokeRestart(restart)
[17:36:38.021]                             muffled <- TRUE
[17:36:38.021]                             break
[17:36:38.021]                           }
[17:36:38.021]                         }
[17:36:38.021]                       }
[17:36:38.021]                       invisible(muffled)
[17:36:38.021]                     }
[17:36:38.021]                     muffleCondition(cond, pattern = "^muffle")
[17:36:38.021]                   }
[17:36:38.021]                 }
[17:36:38.021]                 else {
[17:36:38.021]                   if (TRUE) {
[17:36:38.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.021]                     {
[17:36:38.021]                       inherits <- base::inherits
[17:36:38.021]                       invokeRestart <- base::invokeRestart
[17:36:38.021]                       is.null <- base::is.null
[17:36:38.021]                       muffled <- FALSE
[17:36:38.021]                       if (inherits(cond, "message")) {
[17:36:38.021]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:38.021]                         if (muffled) 
[17:36:38.021]                           invokeRestart("muffleMessage")
[17:36:38.021]                       }
[17:36:38.021]                       else if (inherits(cond, "warning")) {
[17:36:38.021]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:38.021]                         if (muffled) 
[17:36:38.021]                           invokeRestart("muffleWarning")
[17:36:38.021]                       }
[17:36:38.021]                       else if (inherits(cond, "condition")) {
[17:36:38.021]                         if (!is.null(pattern)) {
[17:36:38.021]                           computeRestarts <- base::computeRestarts
[17:36:38.021]                           grepl <- base::grepl
[17:36:38.021]                           restarts <- computeRestarts(cond)
[17:36:38.021]                           for (restart in restarts) {
[17:36:38.021]                             name <- restart$name
[17:36:38.021]                             if (is.null(name)) 
[17:36:38.021]                               next
[17:36:38.021]                             if (!grepl(pattern, name)) 
[17:36:38.021]                               next
[17:36:38.021]                             invokeRestart(restart)
[17:36:38.021]                             muffled <- TRUE
[17:36:38.021]                             break
[17:36:38.021]                           }
[17:36:38.021]                         }
[17:36:38.021]                       }
[17:36:38.021]                       invisible(muffled)
[17:36:38.021]                     }
[17:36:38.021]                     muffleCondition(cond, pattern = "^muffle")
[17:36:38.021]                   }
[17:36:38.021]                 }
[17:36:38.021]             }
[17:36:38.021]         }))
[17:36:38.021]     }, error = function(ex) {
[17:36:38.021]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:38.021]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:38.021]                 ...future.rng), started = ...future.startTime, 
[17:36:38.021]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:38.021]             version = "1.8"), class = "FutureResult")
[17:36:38.021]     }, finally = {
[17:36:38.021]         if (!identical(...future.workdir, getwd())) 
[17:36:38.021]             setwd(...future.workdir)
[17:36:38.021]         {
[17:36:38.021]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:38.021]                 ...future.oldOptions$nwarnings <- NULL
[17:36:38.021]             }
[17:36:38.021]             base::options(...future.oldOptions)
[17:36:38.021]             if (.Platform$OS.type == "windows") {
[17:36:38.021]                 old_names <- names(...future.oldEnvVars)
[17:36:38.021]                 envs <- base::Sys.getenv()
[17:36:38.021]                 names <- names(envs)
[17:36:38.021]                 common <- intersect(names, old_names)
[17:36:38.021]                 added <- setdiff(names, old_names)
[17:36:38.021]                 removed <- setdiff(old_names, names)
[17:36:38.021]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:38.021]                   envs[common]]
[17:36:38.021]                 NAMES <- toupper(changed)
[17:36:38.021]                 args <- list()
[17:36:38.021]                 for (kk in seq_along(NAMES)) {
[17:36:38.021]                   name <- changed[[kk]]
[17:36:38.021]                   NAME <- NAMES[[kk]]
[17:36:38.021]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.021]                     next
[17:36:38.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:38.021]                 }
[17:36:38.021]                 NAMES <- toupper(added)
[17:36:38.021]                 for (kk in seq_along(NAMES)) {
[17:36:38.021]                   name <- added[[kk]]
[17:36:38.021]                   NAME <- NAMES[[kk]]
[17:36:38.021]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.021]                     next
[17:36:38.021]                   args[[name]] <- ""
[17:36:38.021]                 }
[17:36:38.021]                 NAMES <- toupper(removed)
[17:36:38.021]                 for (kk in seq_along(NAMES)) {
[17:36:38.021]                   name <- removed[[kk]]
[17:36:38.021]                   NAME <- NAMES[[kk]]
[17:36:38.021]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.021]                     next
[17:36:38.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:38.021]                 }
[17:36:38.021]                 if (length(args) > 0) 
[17:36:38.021]                   base::do.call(base::Sys.setenv, args = args)
[17:36:38.021]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:38.021]             }
[17:36:38.021]             else {
[17:36:38.021]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:38.021]             }
[17:36:38.021]             {
[17:36:38.021]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:38.021]                   0L) {
[17:36:38.021]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:38.021]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:38.021]                   base::options(opts)
[17:36:38.021]                 }
[17:36:38.021]                 {
[17:36:38.021]                   {
[17:36:38.021]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:38.021]                     NULL
[17:36:38.021]                   }
[17:36:38.021]                   options(future.plan = NULL)
[17:36:38.021]                   if (is.na(NA_character_)) 
[17:36:38.021]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:38.021]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:38.021]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:38.021]                     .init = FALSE)
[17:36:38.021]                 }
[17:36:38.021]             }
[17:36:38.021]         }
[17:36:38.021]     })
[17:36:38.021]     if (TRUE) {
[17:36:38.021]         base::sink(type = "output", split = FALSE)
[17:36:38.021]         if (TRUE) {
[17:36:38.021]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:38.021]         }
[17:36:38.021]         else {
[17:36:38.021]             ...future.result["stdout"] <- base::list(NULL)
[17:36:38.021]         }
[17:36:38.021]         base::close(...future.stdout)
[17:36:38.021]         ...future.stdout <- NULL
[17:36:38.021]     }
[17:36:38.021]     ...future.result$conditions <- ...future.conditions
[17:36:38.021]     ...future.result$finished <- base::Sys.time()
[17:36:38.021]     ...future.result
[17:36:38.021] }
[17:36:38.024] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[17:36:38.024] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:36:38.025] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:36:38.025] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[17:36:38.025] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[17:36:38.025] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ...
[17:36:38.026] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ... DONE
[17:36:38.026] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:36:38.026] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:36:38.026] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:36:38.026] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:36:38.027] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[17:36:38.027] MultisessionFuture started
[17:36:38.027] - Launch lazy future ... done
[17:36:38.027] run() for ‘MultisessionFuture’ ... done
[17:36:38.027] Created future:
[17:36:38.027] MultisessionFuture:
[17:36:38.027] Label: ‘future_apply-2’
[17:36:38.027] Expression:
[17:36:38.027] {
[17:36:38.027]     do.call(function(...) {
[17:36:38.027]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.027]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:38.027]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.027]             on.exit(options(oopts), add = TRUE)
[17:36:38.027]         }
[17:36:38.027]         {
[17:36:38.027]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:38.027]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.027]                 ...future.FUN(...future.X_jj, ...)
[17:36:38.027]             })
[17:36:38.027]         }
[17:36:38.027]     }, args = future.call.arguments)
[17:36:38.027] }
[17:36:38.027] Lazy evaluation: FALSE
[17:36:38.027] Asynchronous evaluation: TRUE
[17:36:38.027] Local evaluation: TRUE
[17:36:38.027] Environment: R_GlobalEnv
[17:36:38.027] Capture standard output: TRUE
[17:36:38.027] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:38.027] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:38.027] Packages: <none>
[17:36:38.027] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:38.027] Resolved: FALSE
[17:36:38.027] Value: <not collected>
[17:36:38.027] Conditions captured: <none>
[17:36:38.027] Early signaling: FALSE
[17:36:38.027] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:38.027] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.039] Chunk #2 of 2 ... DONE
[17:36:38.039] Launching 2 futures (chunks) ... DONE
[17:36:38.039] Resolving 2 futures (chunks) ...
[17:36:38.039] resolve() on list ...
[17:36:38.039]  recursive: 0
[17:36:38.040]  length: 2
[17:36:38.040] 
[17:36:38.040] receiveMessageFromWorker() for ClusterFuture ...
[17:36:38.040] - Validating connection of MultisessionFuture
[17:36:38.041] - received message: FutureResult
[17:36:38.041] - Received FutureResult
[17:36:38.041] - Erased future from FutureRegistry
[17:36:38.041] result() for ClusterFuture ...
[17:36:38.041] - result already collected: FutureResult
[17:36:38.041] result() for ClusterFuture ... done
[17:36:38.041] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:38.041] Future #1
[17:36:38.041] result() for ClusterFuture ...
[17:36:38.041] - result already collected: FutureResult
[17:36:38.041] result() for ClusterFuture ... done
[17:36:38.042] result() for ClusterFuture ...
[17:36:38.042] - result already collected: FutureResult
[17:36:38.042] result() for ClusterFuture ... done
[17:36:38.042] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:36:38.042] - nx: 2
[17:36:38.042] - relay: TRUE
[17:36:38.042] - stdout: TRUE
[17:36:38.042] - signal: TRUE
[17:36:38.042] - resignal: FALSE
[17:36:38.042] - force: TRUE
[17:36:38.042] - relayed: [n=2] FALSE, FALSE
[17:36:38.042] - queued futures: [n=2] FALSE, FALSE
[17:36:38.043]  - until=1
[17:36:38.043]  - relaying element #1
[17:36:38.043] result() for ClusterFuture ...
[17:36:38.043] - result already collected: FutureResult
[17:36:38.043] result() for ClusterFuture ... done
[17:36:38.043] result() for ClusterFuture ...
[17:36:38.043] - result already collected: FutureResult
[17:36:38.043] result() for ClusterFuture ... done
[17:36:38.043] result() for ClusterFuture ...
[17:36:38.043] - result already collected: FutureResult
[17:36:38.043] result() for ClusterFuture ... done
[17:36:38.043] result() for ClusterFuture ...
[17:36:38.044] - result already collected: FutureResult
[17:36:38.044] result() for ClusterFuture ... done
[17:36:38.044] - relayed: [n=2] TRUE, FALSE
[17:36:38.044] - queued futures: [n=2] TRUE, FALSE
[17:36:38.044] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:36:38.044]  length: 1 (resolved future 1)
[17:36:38.070] receiveMessageFromWorker() for ClusterFuture ...
[17:36:38.070] - Validating connection of MultisessionFuture
[17:36:38.070] - received message: FutureResult
[17:36:38.070] - Received FutureResult
[17:36:38.070] - Erased future from FutureRegistry
[17:36:38.071] result() for ClusterFuture ...
[17:36:38.071] - result already collected: FutureResult
[17:36:38.071] result() for ClusterFuture ... done
[17:36:38.071] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:38.071] Future #2
[17:36:38.071] result() for ClusterFuture ...
[17:36:38.071] - result already collected: FutureResult
[17:36:38.071] result() for ClusterFuture ... done
[17:36:38.071] result() for ClusterFuture ...
[17:36:38.071] - result already collected: FutureResult
[17:36:38.071] result() for ClusterFuture ... done
[17:36:38.071] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:36:38.072] - nx: 2
[17:36:38.072] - relay: TRUE
[17:36:38.072] - stdout: TRUE
[17:36:38.072] - signal: TRUE
[17:36:38.072] - resignal: FALSE
[17:36:38.072] - force: TRUE
[17:36:38.072] - relayed: [n=2] TRUE, FALSE
[17:36:38.072] - queued futures: [n=2] TRUE, FALSE
[17:36:38.072]  - until=2
[17:36:38.072]  - relaying element #2
[17:36:38.072] result() for ClusterFuture ...
[17:36:38.073] - result already collected: FutureResult
[17:36:38.073] result() for ClusterFuture ... done
[17:36:38.073] result() for ClusterFuture ...
[17:36:38.073] - result already collected: FutureResult
[17:36:38.073] result() for ClusterFuture ... done
[17:36:38.073] result() for ClusterFuture ...
[17:36:38.073] - result already collected: FutureResult
[17:36:38.073] result() for ClusterFuture ... done
[17:36:38.073] result() for ClusterFuture ...
[17:36:38.073] - result already collected: FutureResult
[17:36:38.073] result() for ClusterFuture ... done
[17:36:38.073] - relayed: [n=2] TRUE, TRUE
[17:36:38.074] - queued futures: [n=2] TRUE, TRUE
[17:36:38.074] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:36:38.074]  length: 0 (resolved future 2)
[17:36:38.074] Relaying remaining futures
[17:36:38.074] signalConditionsASAP(NULL, pos=0) ...
[17:36:38.074] - nx: 2
[17:36:38.074] - relay: TRUE
[17:36:38.074] - stdout: TRUE
[17:36:38.074] - signal: TRUE
[17:36:38.074] - resignal: FALSE
[17:36:38.074] - force: TRUE
[17:36:38.075] - relayed: [n=2] TRUE, TRUE
[17:36:38.075] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:38.075] - relayed: [n=2] TRUE, TRUE
[17:36:38.075] - queued futures: [n=2] TRUE, TRUE
[17:36:38.075] signalConditionsASAP(NULL, pos=0) ... done
[17:36:38.075] resolve() on list ... DONE
[17:36:38.075] result() for ClusterFuture ...
[17:36:38.075] - result already collected: FutureResult
[17:36:38.075] result() for ClusterFuture ... done
[17:36:38.075] result() for ClusterFuture ...
[17:36:38.075] - result already collected: FutureResult
[17:36:38.076] result() for ClusterFuture ... done
[17:36:38.076] result() for ClusterFuture ...
[17:36:38.076] - result already collected: FutureResult
[17:36:38.076] result() for ClusterFuture ... done
[17:36:38.076] result() for ClusterFuture ...
[17:36:38.076] - result already collected: FutureResult
[17:36:38.076] result() for ClusterFuture ... done
[17:36:38.076]  - Number of value chunks collected: 2
[17:36:38.076] Resolving 2 futures (chunks) ... DONE
[17:36:38.076] Reducing values from 2 chunks ...
[17:36:38.076]  - Number of values collected after concatenation: 6
[17:36:38.077]  - Number of values expected: 6
[17:36:38.077] Reducing values from 2 chunks ... DONE
[17:36:38.077] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[17:36:38.077] getGlobalsAndPackagesXApply() ...
[17:36:38.077]  - future.globals: TRUE
[17:36:38.077] getGlobalsAndPackages() ...
[17:36:38.078] Searching for globals...
[17:36:38.079] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[17:36:38.079] Searching for globals ... DONE
[17:36:38.079] Resolving globals: FALSE
[17:36:38.079] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[17:36:38.080] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[17:36:38.080] - globals: [1] ‘FUN’
[17:36:38.080] 
[17:36:38.080] getGlobalsAndPackages() ... DONE
[17:36:38.080]  - globals found/used: [n=1] ‘FUN’
[17:36:38.080]  - needed namespaces: [n=0] 
[17:36:38.080] Finding globals ... DONE
[17:36:38.080]  - use_args: TRUE
[17:36:38.080]  - Getting '...' globals ...
[17:36:38.081] resolve() on list ...
[17:36:38.081]  recursive: 0
[17:36:38.081]  length: 1
[17:36:38.081]  elements: ‘...’
[17:36:38.081]  length: 0 (resolved future 1)
[17:36:38.081] resolve() on list ... DONE
[17:36:38.081]    - '...' content: [n=0] 
[17:36:38.081] List of 1
[17:36:38.081]  $ ...: list()
[17:36:38.081]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:38.081]  - attr(*, "where")=List of 1
[17:36:38.081]   ..$ ...:<environment: 0x556d73d3dfd0> 
[17:36:38.081]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:38.081]  - attr(*, "resolved")= logi TRUE
[17:36:38.081]  - attr(*, "total_size")= num NA
[17:36:38.084]  - Getting '...' globals ... DONE
[17:36:38.084] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:38.084] List of 2
[17:36:38.084]  $ ...future.FUN:function (x)  
[17:36:38.084]  $ ...          : list()
[17:36:38.084]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:38.084]  - attr(*, "where")=List of 2
[17:36:38.084]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:38.084]   ..$ ...          :<environment: 0x556d73d3dfd0> 
[17:36:38.084]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:38.084]  - attr(*, "resolved")= logi FALSE
[17:36:38.084]  - attr(*, "total_size")= num 1768
[17:36:38.087] Packages to be attached in all futures: [n=0] 
[17:36:38.087] getGlobalsAndPackagesXApply() ... DONE
[17:36:38.091] future_lapply() ...
[17:36:38.094] Number of chunks: 2
[17:36:38.095] getGlobalsAndPackagesXApply() ...
[17:36:38.095]  - future.globals: <name-value list> with names ‘list()’
[17:36:38.095]  - use_args: TRUE
[17:36:38.095] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:38.095] List of 2
[17:36:38.095]  $ ...          : list()
[17:36:38.095]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:38.095]  $ ...future.FUN:function (x)  
[17:36:38.095]  - attr(*, "where")=List of 2
[17:36:38.095]   ..$ ...          :<environment: 0x556d73d3dfd0> 
[17:36:38.095]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:36:38.095]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:38.095]  - attr(*, "resolved")= logi FALSE
[17:36:38.095]  - attr(*, "total_size")= num NA
[17:36:38.098] Packages to be attached in all futures: [n=0] 
[17:36:38.098] getGlobalsAndPackagesXApply() ... DONE
[17:36:38.098] Number of futures (= number of chunks): 2
[17:36:38.099] Launching 2 futures (chunks) ...
[17:36:38.099] Chunk #1 of 2 ...
[17:36:38.099]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:38.099]  - seeds: <none>
[17:36:38.099]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.099] getGlobalsAndPackages() ...
[17:36:38.099] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.099] Resolving globals: FALSE
[17:36:38.099] Tweak future expression to call with '...' arguments ...
[17:36:38.100] {
[17:36:38.100]     do.call(function(...) {
[17:36:38.100]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.100]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:38.100]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.100]             on.exit(options(oopts), add = TRUE)
[17:36:38.100]         }
[17:36:38.100]         {
[17:36:38.100]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:38.100]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.100]                 ...future.FUN(...future.X_jj, ...)
[17:36:38.100]             })
[17:36:38.100]         }
[17:36:38.100]     }, args = future.call.arguments)
[17:36:38.100] }
[17:36:38.100] Tweak future expression to call with '...' arguments ... DONE
[17:36:38.100] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.100] 
[17:36:38.100] getGlobalsAndPackages() ... DONE
[17:36:38.101] run() for ‘Future’ ...
[17:36:38.101] - state: ‘created’
[17:36:38.101] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:38.115] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.115] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:38.115]   - Field: ‘node’
[17:36:38.115]   - Field: ‘label’
[17:36:38.115]   - Field: ‘local’
[17:36:38.115]   - Field: ‘owner’
[17:36:38.115]   - Field: ‘envir’
[17:36:38.115]   - Field: ‘workers’
[17:36:38.115]   - Field: ‘packages’
[17:36:38.115]   - Field: ‘gc’
[17:36:38.116]   - Field: ‘conditions’
[17:36:38.116]   - Field: ‘persistent’
[17:36:38.116]   - Field: ‘expr’
[17:36:38.116]   - Field: ‘uuid’
[17:36:38.116]   - Field: ‘seed’
[17:36:38.116]   - Field: ‘version’
[17:36:38.116]   - Field: ‘result’
[17:36:38.116]   - Field: ‘asynchronous’
[17:36:38.116]   - Field: ‘calls’
[17:36:38.116]   - Field: ‘globals’
[17:36:38.117]   - Field: ‘stdout’
[17:36:38.117]   - Field: ‘earlySignal’
[17:36:38.117]   - Field: ‘lazy’
[17:36:38.117]   - Field: ‘state’
[17:36:38.117] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:38.117] - Launch lazy future ...
[17:36:38.117] Packages needed by the future expression (n = 0): <none>
[17:36:38.117] Packages needed by future strategies (n = 0): <none>
[17:36:38.118] {
[17:36:38.118]     {
[17:36:38.118]         {
[17:36:38.118]             ...future.startTime <- base::Sys.time()
[17:36:38.118]             {
[17:36:38.118]                 {
[17:36:38.118]                   {
[17:36:38.118]                     {
[17:36:38.118]                       base::local({
[17:36:38.118]                         has_future <- base::requireNamespace("future", 
[17:36:38.118]                           quietly = TRUE)
[17:36:38.118]                         if (has_future) {
[17:36:38.118]                           ns <- base::getNamespace("future")
[17:36:38.118]                           version <- ns[[".package"]][["version"]]
[17:36:38.118]                           if (is.null(version)) 
[17:36:38.118]                             version <- utils::packageVersion("future")
[17:36:38.118]                         }
[17:36:38.118]                         else {
[17:36:38.118]                           version <- NULL
[17:36:38.118]                         }
[17:36:38.118]                         if (!has_future || version < "1.8.0") {
[17:36:38.118]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:38.118]                             "", base::R.version$version.string), 
[17:36:38.118]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:38.118]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:38.118]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:38.118]                               "release", "version")], collapse = " "), 
[17:36:38.118]                             hostname = base::Sys.info()[["nodename"]])
[17:36:38.118]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:38.118]                             info)
[17:36:38.118]                           info <- base::paste(info, collapse = "; ")
[17:36:38.118]                           if (!has_future) {
[17:36:38.118]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:38.118]                               info)
[17:36:38.118]                           }
[17:36:38.118]                           else {
[17:36:38.118]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:38.118]                               info, version)
[17:36:38.118]                           }
[17:36:38.118]                           base::stop(msg)
[17:36:38.118]                         }
[17:36:38.118]                       })
[17:36:38.118]                     }
[17:36:38.118]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:38.118]                     base::options(mc.cores = 1L)
[17:36:38.118]                   }
[17:36:38.118]                   ...future.strategy.old <- future::plan("list")
[17:36:38.118]                   options(future.plan = NULL)
[17:36:38.118]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:38.118]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:38.118]                 }
[17:36:38.118]                 ...future.workdir <- getwd()
[17:36:38.118]             }
[17:36:38.118]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:38.118]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:38.118]         }
[17:36:38.118]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:38.118]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:38.118]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:38.118]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:38.118]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:38.118]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:38.118]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:38.118]             base::names(...future.oldOptions))
[17:36:38.118]     }
[17:36:38.118]     if (FALSE) {
[17:36:38.118]     }
[17:36:38.118]     else {
[17:36:38.118]         if (TRUE) {
[17:36:38.118]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:38.118]                 open = "w")
[17:36:38.118]         }
[17:36:38.118]         else {
[17:36:38.118]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:38.118]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:38.118]         }
[17:36:38.118]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:38.118]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:38.118]             base::sink(type = "output", split = FALSE)
[17:36:38.118]             base::close(...future.stdout)
[17:36:38.118]         }, add = TRUE)
[17:36:38.118]     }
[17:36:38.118]     ...future.frame <- base::sys.nframe()
[17:36:38.118]     ...future.conditions <- base::list()
[17:36:38.118]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:38.118]     if (FALSE) {
[17:36:38.118]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:38.118]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:38.118]     }
[17:36:38.118]     ...future.result <- base::tryCatch({
[17:36:38.118]         base::withCallingHandlers({
[17:36:38.118]             ...future.value <- base::withVisible(base::local({
[17:36:38.118]                 ...future.makeSendCondition <- base::local({
[17:36:38.118]                   sendCondition <- NULL
[17:36:38.118]                   function(frame = 1L) {
[17:36:38.118]                     if (is.function(sendCondition)) 
[17:36:38.118]                       return(sendCondition)
[17:36:38.118]                     ns <- getNamespace("parallel")
[17:36:38.118]                     if (exists("sendData", mode = "function", 
[17:36:38.118]                       envir = ns)) {
[17:36:38.118]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:38.118]                         envir = ns)
[17:36:38.118]                       envir <- sys.frame(frame)
[17:36:38.118]                       master <- NULL
[17:36:38.118]                       while (!identical(envir, .GlobalEnv) && 
[17:36:38.118]                         !identical(envir, emptyenv())) {
[17:36:38.118]                         if (exists("master", mode = "list", envir = envir, 
[17:36:38.118]                           inherits = FALSE)) {
[17:36:38.118]                           master <- get("master", mode = "list", 
[17:36:38.118]                             envir = envir, inherits = FALSE)
[17:36:38.118]                           if (inherits(master, c("SOCKnode", 
[17:36:38.118]                             "SOCK0node"))) {
[17:36:38.118]                             sendCondition <<- function(cond) {
[17:36:38.118]                               data <- list(type = "VALUE", value = cond, 
[17:36:38.118]                                 success = TRUE)
[17:36:38.118]                               parallel_sendData(master, data)
[17:36:38.118]                             }
[17:36:38.118]                             return(sendCondition)
[17:36:38.118]                           }
[17:36:38.118]                         }
[17:36:38.118]                         frame <- frame + 1L
[17:36:38.118]                         envir <- sys.frame(frame)
[17:36:38.118]                       }
[17:36:38.118]                     }
[17:36:38.118]                     sendCondition <<- function(cond) NULL
[17:36:38.118]                   }
[17:36:38.118]                 })
[17:36:38.118]                 withCallingHandlers({
[17:36:38.118]                   {
[17:36:38.118]                     do.call(function(...) {
[17:36:38.118]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.118]                       if (!identical(...future.globals.maxSize.org, 
[17:36:38.118]                         ...future.globals.maxSize)) {
[17:36:38.118]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.118]                         on.exit(options(oopts), add = TRUE)
[17:36:38.118]                       }
[17:36:38.118]                       {
[17:36:38.118]                         lapply(seq_along(...future.elements_ii), 
[17:36:38.118]                           FUN = function(jj) {
[17:36:38.118]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.118]                             ...future.FUN(...future.X_jj, ...)
[17:36:38.118]                           })
[17:36:38.118]                       }
[17:36:38.118]                     }, args = future.call.arguments)
[17:36:38.118]                   }
[17:36:38.118]                 }, immediateCondition = function(cond) {
[17:36:38.118]                   sendCondition <- ...future.makeSendCondition()
[17:36:38.118]                   sendCondition(cond)
[17:36:38.118]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.118]                   {
[17:36:38.118]                     inherits <- base::inherits
[17:36:38.118]                     invokeRestart <- base::invokeRestart
[17:36:38.118]                     is.null <- base::is.null
[17:36:38.118]                     muffled <- FALSE
[17:36:38.118]                     if (inherits(cond, "message")) {
[17:36:38.118]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:38.118]                       if (muffled) 
[17:36:38.118]                         invokeRestart("muffleMessage")
[17:36:38.118]                     }
[17:36:38.118]                     else if (inherits(cond, "warning")) {
[17:36:38.118]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:38.118]                       if (muffled) 
[17:36:38.118]                         invokeRestart("muffleWarning")
[17:36:38.118]                     }
[17:36:38.118]                     else if (inherits(cond, "condition")) {
[17:36:38.118]                       if (!is.null(pattern)) {
[17:36:38.118]                         computeRestarts <- base::computeRestarts
[17:36:38.118]                         grepl <- base::grepl
[17:36:38.118]                         restarts <- computeRestarts(cond)
[17:36:38.118]                         for (restart in restarts) {
[17:36:38.118]                           name <- restart$name
[17:36:38.118]                           if (is.null(name)) 
[17:36:38.118]                             next
[17:36:38.118]                           if (!grepl(pattern, name)) 
[17:36:38.118]                             next
[17:36:38.118]                           invokeRestart(restart)
[17:36:38.118]                           muffled <- TRUE
[17:36:38.118]                           break
[17:36:38.118]                         }
[17:36:38.118]                       }
[17:36:38.118]                     }
[17:36:38.118]                     invisible(muffled)
[17:36:38.118]                   }
[17:36:38.118]                   muffleCondition(cond)
[17:36:38.118]                 })
[17:36:38.118]             }))
[17:36:38.118]             future::FutureResult(value = ...future.value$value, 
[17:36:38.118]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:38.118]                   ...future.rng), globalenv = if (FALSE) 
[17:36:38.118]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:38.118]                     ...future.globalenv.names))
[17:36:38.118]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:38.118]         }, condition = base::local({
[17:36:38.118]             c <- base::c
[17:36:38.118]             inherits <- base::inherits
[17:36:38.118]             invokeRestart <- base::invokeRestart
[17:36:38.118]             length <- base::length
[17:36:38.118]             list <- base::list
[17:36:38.118]             seq.int <- base::seq.int
[17:36:38.118]             signalCondition <- base::signalCondition
[17:36:38.118]             sys.calls <- base::sys.calls
[17:36:38.118]             `[[` <- base::`[[`
[17:36:38.118]             `+` <- base::`+`
[17:36:38.118]             `<<-` <- base::`<<-`
[17:36:38.118]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:38.118]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:38.118]                   3L)]
[17:36:38.118]             }
[17:36:38.118]             function(cond) {
[17:36:38.118]                 is_error <- inherits(cond, "error")
[17:36:38.118]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:38.118]                   NULL)
[17:36:38.118]                 if (is_error) {
[17:36:38.118]                   sessionInformation <- function() {
[17:36:38.118]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:38.118]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:38.118]                       search = base::search(), system = base::Sys.info())
[17:36:38.118]                   }
[17:36:38.118]                   ...future.conditions[[length(...future.conditions) + 
[17:36:38.118]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:38.118]                     cond$call), session = sessionInformation(), 
[17:36:38.118]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:38.118]                   signalCondition(cond)
[17:36:38.118]                 }
[17:36:38.118]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:38.118]                 "immediateCondition"))) {
[17:36:38.118]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:38.118]                   ...future.conditions[[length(...future.conditions) + 
[17:36:38.118]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:38.118]                   if (TRUE && !signal) {
[17:36:38.118]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.118]                     {
[17:36:38.118]                       inherits <- base::inherits
[17:36:38.118]                       invokeRestart <- base::invokeRestart
[17:36:38.118]                       is.null <- base::is.null
[17:36:38.118]                       muffled <- FALSE
[17:36:38.118]                       if (inherits(cond, "message")) {
[17:36:38.118]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:38.118]                         if (muffled) 
[17:36:38.118]                           invokeRestart("muffleMessage")
[17:36:38.118]                       }
[17:36:38.118]                       else if (inherits(cond, "warning")) {
[17:36:38.118]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:38.118]                         if (muffled) 
[17:36:38.118]                           invokeRestart("muffleWarning")
[17:36:38.118]                       }
[17:36:38.118]                       else if (inherits(cond, "condition")) {
[17:36:38.118]                         if (!is.null(pattern)) {
[17:36:38.118]                           computeRestarts <- base::computeRestarts
[17:36:38.118]                           grepl <- base::grepl
[17:36:38.118]                           restarts <- computeRestarts(cond)
[17:36:38.118]                           for (restart in restarts) {
[17:36:38.118]                             name <- restart$name
[17:36:38.118]                             if (is.null(name)) 
[17:36:38.118]                               next
[17:36:38.118]                             if (!grepl(pattern, name)) 
[17:36:38.118]                               next
[17:36:38.118]                             invokeRestart(restart)
[17:36:38.118]                             muffled <- TRUE
[17:36:38.118]                             break
[17:36:38.118]                           }
[17:36:38.118]                         }
[17:36:38.118]                       }
[17:36:38.118]                       invisible(muffled)
[17:36:38.118]                     }
[17:36:38.118]                     muffleCondition(cond, pattern = "^muffle")
[17:36:38.118]                   }
[17:36:38.118]                 }
[17:36:38.118]                 else {
[17:36:38.118]                   if (TRUE) {
[17:36:38.118]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.118]                     {
[17:36:38.118]                       inherits <- base::inherits
[17:36:38.118]                       invokeRestart <- base::invokeRestart
[17:36:38.118]                       is.null <- base::is.null
[17:36:38.118]                       muffled <- FALSE
[17:36:38.118]                       if (inherits(cond, "message")) {
[17:36:38.118]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:38.118]                         if (muffled) 
[17:36:38.118]                           invokeRestart("muffleMessage")
[17:36:38.118]                       }
[17:36:38.118]                       else if (inherits(cond, "warning")) {
[17:36:38.118]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:38.118]                         if (muffled) 
[17:36:38.118]                           invokeRestart("muffleWarning")
[17:36:38.118]                       }
[17:36:38.118]                       else if (inherits(cond, "condition")) {
[17:36:38.118]                         if (!is.null(pattern)) {
[17:36:38.118]                           computeRestarts <- base::computeRestarts
[17:36:38.118]                           grepl <- base::grepl
[17:36:38.118]                           restarts <- computeRestarts(cond)
[17:36:38.118]                           for (restart in restarts) {
[17:36:38.118]                             name <- restart$name
[17:36:38.118]                             if (is.null(name)) 
[17:36:38.118]                               next
[17:36:38.118]                             if (!grepl(pattern, name)) 
[17:36:38.118]                               next
[17:36:38.118]                             invokeRestart(restart)
[17:36:38.118]                             muffled <- TRUE
[17:36:38.118]                             break
[17:36:38.118]                           }
[17:36:38.118]                         }
[17:36:38.118]                       }
[17:36:38.118]                       invisible(muffled)
[17:36:38.118]                     }
[17:36:38.118]                     muffleCondition(cond, pattern = "^muffle")
[17:36:38.118]                   }
[17:36:38.118]                 }
[17:36:38.118]             }
[17:36:38.118]         }))
[17:36:38.118]     }, error = function(ex) {
[17:36:38.118]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:38.118]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:38.118]                 ...future.rng), started = ...future.startTime, 
[17:36:38.118]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:38.118]             version = "1.8"), class = "FutureResult")
[17:36:38.118]     }, finally = {
[17:36:38.118]         if (!identical(...future.workdir, getwd())) 
[17:36:38.118]             setwd(...future.workdir)
[17:36:38.118]         {
[17:36:38.118]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:38.118]                 ...future.oldOptions$nwarnings <- NULL
[17:36:38.118]             }
[17:36:38.118]             base::options(...future.oldOptions)
[17:36:38.118]             if (.Platform$OS.type == "windows") {
[17:36:38.118]                 old_names <- names(...future.oldEnvVars)
[17:36:38.118]                 envs <- base::Sys.getenv()
[17:36:38.118]                 names <- names(envs)
[17:36:38.118]                 common <- intersect(names, old_names)
[17:36:38.118]                 added <- setdiff(names, old_names)
[17:36:38.118]                 removed <- setdiff(old_names, names)
[17:36:38.118]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:38.118]                   envs[common]]
[17:36:38.118]                 NAMES <- toupper(changed)
[17:36:38.118]                 args <- list()
[17:36:38.118]                 for (kk in seq_along(NAMES)) {
[17:36:38.118]                   name <- changed[[kk]]
[17:36:38.118]                   NAME <- NAMES[[kk]]
[17:36:38.118]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.118]                     next
[17:36:38.118]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:38.118]                 }
[17:36:38.118]                 NAMES <- toupper(added)
[17:36:38.118]                 for (kk in seq_along(NAMES)) {
[17:36:38.118]                   name <- added[[kk]]
[17:36:38.118]                   NAME <- NAMES[[kk]]
[17:36:38.118]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.118]                     next
[17:36:38.118]                   args[[name]] <- ""
[17:36:38.118]                 }
[17:36:38.118]                 NAMES <- toupper(removed)
[17:36:38.118]                 for (kk in seq_along(NAMES)) {
[17:36:38.118]                   name <- removed[[kk]]
[17:36:38.118]                   NAME <- NAMES[[kk]]
[17:36:38.118]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.118]                     next
[17:36:38.118]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:38.118]                 }
[17:36:38.118]                 if (length(args) > 0) 
[17:36:38.118]                   base::do.call(base::Sys.setenv, args = args)
[17:36:38.118]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:38.118]             }
[17:36:38.118]             else {
[17:36:38.118]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:38.118]             }
[17:36:38.118]             {
[17:36:38.118]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:38.118]                   0L) {
[17:36:38.118]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:38.118]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:38.118]                   base::options(opts)
[17:36:38.118]                 }
[17:36:38.118]                 {
[17:36:38.118]                   {
[17:36:38.118]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:38.118]                     NULL
[17:36:38.118]                   }
[17:36:38.118]                   options(future.plan = NULL)
[17:36:38.118]                   if (is.na(NA_character_)) 
[17:36:38.118]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:38.118]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:38.118]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:38.118]                     .init = FALSE)
[17:36:38.118]                 }
[17:36:38.118]             }
[17:36:38.118]         }
[17:36:38.118]     })
[17:36:38.118]     if (TRUE) {
[17:36:38.118]         base::sink(type = "output", split = FALSE)
[17:36:38.118]         if (TRUE) {
[17:36:38.118]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:38.118]         }
[17:36:38.118]         else {
[17:36:38.118]             ...future.result["stdout"] <- base::list(NULL)
[17:36:38.118]         }
[17:36:38.118]         base::close(...future.stdout)
[17:36:38.118]         ...future.stdout <- NULL
[17:36:38.118]     }
[17:36:38.118]     ...future.result$conditions <- ...future.conditions
[17:36:38.118]     ...future.result$finished <- base::Sys.time()
[17:36:38.118]     ...future.result
[17:36:38.118] }
[17:36:38.121] Exporting 5 global objects (1.97 KiB) to cluster node #1 ...
[17:36:38.121] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:36:38.121] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:36:38.122] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ...
[17:36:38.122] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ... DONE
[17:36:38.122] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ...
[17:36:38.123] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ... DONE
[17:36:38.123] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:36:38.123] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:36:38.123] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:36:38.123] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:36:38.124] Exporting 5 global objects (1.97 KiB) to cluster node #1 ... DONE
[17:36:38.124] MultisessionFuture started
[17:36:38.124] - Launch lazy future ... done
[17:36:38.124] run() for ‘MultisessionFuture’ ... done
[17:36:38.125] Created future:
[17:36:38.125] MultisessionFuture:
[17:36:38.125] Label: ‘future_apply-1’
[17:36:38.125] Expression:
[17:36:38.125] {
[17:36:38.125]     do.call(function(...) {
[17:36:38.125]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.125]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:38.125]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.125]             on.exit(options(oopts), add = TRUE)
[17:36:38.125]         }
[17:36:38.125]         {
[17:36:38.125]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:38.125]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.125]                 ...future.FUN(...future.X_jj, ...)
[17:36:38.125]             })
[17:36:38.125]         }
[17:36:38.125]     }, args = future.call.arguments)
[17:36:38.125] }
[17:36:38.125] Lazy evaluation: FALSE
[17:36:38.125] Asynchronous evaluation: TRUE
[17:36:38.125] Local evaluation: TRUE
[17:36:38.125] Environment: R_GlobalEnv
[17:36:38.125] Capture standard output: TRUE
[17:36:38.125] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:38.125] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:38.125] Packages: <none>
[17:36:38.125] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:38.125] Resolved: FALSE
[17:36:38.125] Value: <not collected>
[17:36:38.125] Conditions captured: <none>
[17:36:38.125] Early signaling: FALSE
[17:36:38.125] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:38.125] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.136] Chunk #1 of 2 ... DONE
[17:36:38.136] Chunk #2 of 2 ...
[17:36:38.137]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:38.137]  - seeds: <none>
[17:36:38.137]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.137] getGlobalsAndPackages() ...
[17:36:38.137] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.137] Resolving globals: FALSE
[17:36:38.137] Tweak future expression to call with '...' arguments ...
[17:36:38.137] {
[17:36:38.137]     do.call(function(...) {
[17:36:38.137]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.137]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:38.137]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.137]             on.exit(options(oopts), add = TRUE)
[17:36:38.137]         }
[17:36:38.137]         {
[17:36:38.137]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:38.137]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.137]                 ...future.FUN(...future.X_jj, ...)
[17:36:38.137]             })
[17:36:38.137]         }
[17:36:38.137]     }, args = future.call.arguments)
[17:36:38.137] }
[17:36:38.138] Tweak future expression to call with '...' arguments ... DONE
[17:36:38.138] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.138] 
[17:36:38.138] getGlobalsAndPackages() ... DONE
[17:36:38.139] run() for ‘Future’ ...
[17:36:38.139] - state: ‘created’
[17:36:38.139] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:38.152] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.152] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:38.153]   - Field: ‘node’
[17:36:38.153]   - Field: ‘label’
[17:36:38.153]   - Field: ‘local’
[17:36:38.153]   - Field: ‘owner’
[17:36:38.153]   - Field: ‘envir’
[17:36:38.153]   - Field: ‘workers’
[17:36:38.153]   - Field: ‘packages’
[17:36:38.153]   - Field: ‘gc’
[17:36:38.153]   - Field: ‘conditions’
[17:36:38.153]   - Field: ‘persistent’
[17:36:38.154]   - Field: ‘expr’
[17:36:38.154]   - Field: ‘uuid’
[17:36:38.154]   - Field: ‘seed’
[17:36:38.154]   - Field: ‘version’
[17:36:38.154]   - Field: ‘result’
[17:36:38.154]   - Field: ‘asynchronous’
[17:36:38.154]   - Field: ‘calls’
[17:36:38.154]   - Field: ‘globals’
[17:36:38.154]   - Field: ‘stdout’
[17:36:38.154]   - Field: ‘earlySignal’
[17:36:38.154]   - Field: ‘lazy’
[17:36:38.155]   - Field: ‘state’
[17:36:38.155] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:38.155] - Launch lazy future ...
[17:36:38.155] Packages needed by the future expression (n = 0): <none>
[17:36:38.155] Packages needed by future strategies (n = 0): <none>
[17:36:38.156] {
[17:36:38.156]     {
[17:36:38.156]         {
[17:36:38.156]             ...future.startTime <- base::Sys.time()
[17:36:38.156]             {
[17:36:38.156]                 {
[17:36:38.156]                   {
[17:36:38.156]                     {
[17:36:38.156]                       base::local({
[17:36:38.156]                         has_future <- base::requireNamespace("future", 
[17:36:38.156]                           quietly = TRUE)
[17:36:38.156]                         if (has_future) {
[17:36:38.156]                           ns <- base::getNamespace("future")
[17:36:38.156]                           version <- ns[[".package"]][["version"]]
[17:36:38.156]                           if (is.null(version)) 
[17:36:38.156]                             version <- utils::packageVersion("future")
[17:36:38.156]                         }
[17:36:38.156]                         else {
[17:36:38.156]                           version <- NULL
[17:36:38.156]                         }
[17:36:38.156]                         if (!has_future || version < "1.8.0") {
[17:36:38.156]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:38.156]                             "", base::R.version$version.string), 
[17:36:38.156]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:38.156]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:38.156]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:38.156]                               "release", "version")], collapse = " "), 
[17:36:38.156]                             hostname = base::Sys.info()[["nodename"]])
[17:36:38.156]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:38.156]                             info)
[17:36:38.156]                           info <- base::paste(info, collapse = "; ")
[17:36:38.156]                           if (!has_future) {
[17:36:38.156]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:38.156]                               info)
[17:36:38.156]                           }
[17:36:38.156]                           else {
[17:36:38.156]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:38.156]                               info, version)
[17:36:38.156]                           }
[17:36:38.156]                           base::stop(msg)
[17:36:38.156]                         }
[17:36:38.156]                       })
[17:36:38.156]                     }
[17:36:38.156]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:38.156]                     base::options(mc.cores = 1L)
[17:36:38.156]                   }
[17:36:38.156]                   ...future.strategy.old <- future::plan("list")
[17:36:38.156]                   options(future.plan = NULL)
[17:36:38.156]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:38.156]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:38.156]                 }
[17:36:38.156]                 ...future.workdir <- getwd()
[17:36:38.156]             }
[17:36:38.156]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:38.156]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:38.156]         }
[17:36:38.156]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:38.156]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:38.156]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:38.156]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:38.156]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:38.156]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:38.156]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:38.156]             base::names(...future.oldOptions))
[17:36:38.156]     }
[17:36:38.156]     if (FALSE) {
[17:36:38.156]     }
[17:36:38.156]     else {
[17:36:38.156]         if (TRUE) {
[17:36:38.156]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:38.156]                 open = "w")
[17:36:38.156]         }
[17:36:38.156]         else {
[17:36:38.156]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:38.156]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:38.156]         }
[17:36:38.156]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:38.156]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:38.156]             base::sink(type = "output", split = FALSE)
[17:36:38.156]             base::close(...future.stdout)
[17:36:38.156]         }, add = TRUE)
[17:36:38.156]     }
[17:36:38.156]     ...future.frame <- base::sys.nframe()
[17:36:38.156]     ...future.conditions <- base::list()
[17:36:38.156]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:38.156]     if (FALSE) {
[17:36:38.156]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:38.156]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:38.156]     }
[17:36:38.156]     ...future.result <- base::tryCatch({
[17:36:38.156]         base::withCallingHandlers({
[17:36:38.156]             ...future.value <- base::withVisible(base::local({
[17:36:38.156]                 ...future.makeSendCondition <- base::local({
[17:36:38.156]                   sendCondition <- NULL
[17:36:38.156]                   function(frame = 1L) {
[17:36:38.156]                     if (is.function(sendCondition)) 
[17:36:38.156]                       return(sendCondition)
[17:36:38.156]                     ns <- getNamespace("parallel")
[17:36:38.156]                     if (exists("sendData", mode = "function", 
[17:36:38.156]                       envir = ns)) {
[17:36:38.156]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:38.156]                         envir = ns)
[17:36:38.156]                       envir <- sys.frame(frame)
[17:36:38.156]                       master <- NULL
[17:36:38.156]                       while (!identical(envir, .GlobalEnv) && 
[17:36:38.156]                         !identical(envir, emptyenv())) {
[17:36:38.156]                         if (exists("master", mode = "list", envir = envir, 
[17:36:38.156]                           inherits = FALSE)) {
[17:36:38.156]                           master <- get("master", mode = "list", 
[17:36:38.156]                             envir = envir, inherits = FALSE)
[17:36:38.156]                           if (inherits(master, c("SOCKnode", 
[17:36:38.156]                             "SOCK0node"))) {
[17:36:38.156]                             sendCondition <<- function(cond) {
[17:36:38.156]                               data <- list(type = "VALUE", value = cond, 
[17:36:38.156]                                 success = TRUE)
[17:36:38.156]                               parallel_sendData(master, data)
[17:36:38.156]                             }
[17:36:38.156]                             return(sendCondition)
[17:36:38.156]                           }
[17:36:38.156]                         }
[17:36:38.156]                         frame <- frame + 1L
[17:36:38.156]                         envir <- sys.frame(frame)
[17:36:38.156]                       }
[17:36:38.156]                     }
[17:36:38.156]                     sendCondition <<- function(cond) NULL
[17:36:38.156]                   }
[17:36:38.156]                 })
[17:36:38.156]                 withCallingHandlers({
[17:36:38.156]                   {
[17:36:38.156]                     do.call(function(...) {
[17:36:38.156]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.156]                       if (!identical(...future.globals.maxSize.org, 
[17:36:38.156]                         ...future.globals.maxSize)) {
[17:36:38.156]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.156]                         on.exit(options(oopts), add = TRUE)
[17:36:38.156]                       }
[17:36:38.156]                       {
[17:36:38.156]                         lapply(seq_along(...future.elements_ii), 
[17:36:38.156]                           FUN = function(jj) {
[17:36:38.156]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.156]                             ...future.FUN(...future.X_jj, ...)
[17:36:38.156]                           })
[17:36:38.156]                       }
[17:36:38.156]                     }, args = future.call.arguments)
[17:36:38.156]                   }
[17:36:38.156]                 }, immediateCondition = function(cond) {
[17:36:38.156]                   sendCondition <- ...future.makeSendCondition()
[17:36:38.156]                   sendCondition(cond)
[17:36:38.156]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.156]                   {
[17:36:38.156]                     inherits <- base::inherits
[17:36:38.156]                     invokeRestart <- base::invokeRestart
[17:36:38.156]                     is.null <- base::is.null
[17:36:38.156]                     muffled <- FALSE
[17:36:38.156]                     if (inherits(cond, "message")) {
[17:36:38.156]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:38.156]                       if (muffled) 
[17:36:38.156]                         invokeRestart("muffleMessage")
[17:36:38.156]                     }
[17:36:38.156]                     else if (inherits(cond, "warning")) {
[17:36:38.156]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:38.156]                       if (muffled) 
[17:36:38.156]                         invokeRestart("muffleWarning")
[17:36:38.156]                     }
[17:36:38.156]                     else if (inherits(cond, "condition")) {
[17:36:38.156]                       if (!is.null(pattern)) {
[17:36:38.156]                         computeRestarts <- base::computeRestarts
[17:36:38.156]                         grepl <- base::grepl
[17:36:38.156]                         restarts <- computeRestarts(cond)
[17:36:38.156]                         for (restart in restarts) {
[17:36:38.156]                           name <- restart$name
[17:36:38.156]                           if (is.null(name)) 
[17:36:38.156]                             next
[17:36:38.156]                           if (!grepl(pattern, name)) 
[17:36:38.156]                             next
[17:36:38.156]                           invokeRestart(restart)
[17:36:38.156]                           muffled <- TRUE
[17:36:38.156]                           break
[17:36:38.156]                         }
[17:36:38.156]                       }
[17:36:38.156]                     }
[17:36:38.156]                     invisible(muffled)
[17:36:38.156]                   }
[17:36:38.156]                   muffleCondition(cond)
[17:36:38.156]                 })
[17:36:38.156]             }))
[17:36:38.156]             future::FutureResult(value = ...future.value$value, 
[17:36:38.156]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:38.156]                   ...future.rng), globalenv = if (FALSE) 
[17:36:38.156]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:38.156]                     ...future.globalenv.names))
[17:36:38.156]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:38.156]         }, condition = base::local({
[17:36:38.156]             c <- base::c
[17:36:38.156]             inherits <- base::inherits
[17:36:38.156]             invokeRestart <- base::invokeRestart
[17:36:38.156]             length <- base::length
[17:36:38.156]             list <- base::list
[17:36:38.156]             seq.int <- base::seq.int
[17:36:38.156]             signalCondition <- base::signalCondition
[17:36:38.156]             sys.calls <- base::sys.calls
[17:36:38.156]             `[[` <- base::`[[`
[17:36:38.156]             `+` <- base::`+`
[17:36:38.156]             `<<-` <- base::`<<-`
[17:36:38.156]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:38.156]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:38.156]                   3L)]
[17:36:38.156]             }
[17:36:38.156]             function(cond) {
[17:36:38.156]                 is_error <- inherits(cond, "error")
[17:36:38.156]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:38.156]                   NULL)
[17:36:38.156]                 if (is_error) {
[17:36:38.156]                   sessionInformation <- function() {
[17:36:38.156]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:38.156]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:38.156]                       search = base::search(), system = base::Sys.info())
[17:36:38.156]                   }
[17:36:38.156]                   ...future.conditions[[length(...future.conditions) + 
[17:36:38.156]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:38.156]                     cond$call), session = sessionInformation(), 
[17:36:38.156]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:38.156]                   signalCondition(cond)
[17:36:38.156]                 }
[17:36:38.156]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:38.156]                 "immediateCondition"))) {
[17:36:38.156]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:38.156]                   ...future.conditions[[length(...future.conditions) + 
[17:36:38.156]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:38.156]                   if (TRUE && !signal) {
[17:36:38.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.156]                     {
[17:36:38.156]                       inherits <- base::inherits
[17:36:38.156]                       invokeRestart <- base::invokeRestart
[17:36:38.156]                       is.null <- base::is.null
[17:36:38.156]                       muffled <- FALSE
[17:36:38.156]                       if (inherits(cond, "message")) {
[17:36:38.156]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:38.156]                         if (muffled) 
[17:36:38.156]                           invokeRestart("muffleMessage")
[17:36:38.156]                       }
[17:36:38.156]                       else if (inherits(cond, "warning")) {
[17:36:38.156]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:38.156]                         if (muffled) 
[17:36:38.156]                           invokeRestart("muffleWarning")
[17:36:38.156]                       }
[17:36:38.156]                       else if (inherits(cond, "condition")) {
[17:36:38.156]                         if (!is.null(pattern)) {
[17:36:38.156]                           computeRestarts <- base::computeRestarts
[17:36:38.156]                           grepl <- base::grepl
[17:36:38.156]                           restarts <- computeRestarts(cond)
[17:36:38.156]                           for (restart in restarts) {
[17:36:38.156]                             name <- restart$name
[17:36:38.156]                             if (is.null(name)) 
[17:36:38.156]                               next
[17:36:38.156]                             if (!grepl(pattern, name)) 
[17:36:38.156]                               next
[17:36:38.156]                             invokeRestart(restart)
[17:36:38.156]                             muffled <- TRUE
[17:36:38.156]                             break
[17:36:38.156]                           }
[17:36:38.156]                         }
[17:36:38.156]                       }
[17:36:38.156]                       invisible(muffled)
[17:36:38.156]                     }
[17:36:38.156]                     muffleCondition(cond, pattern = "^muffle")
[17:36:38.156]                   }
[17:36:38.156]                 }
[17:36:38.156]                 else {
[17:36:38.156]                   if (TRUE) {
[17:36:38.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.156]                     {
[17:36:38.156]                       inherits <- base::inherits
[17:36:38.156]                       invokeRestart <- base::invokeRestart
[17:36:38.156]                       is.null <- base::is.null
[17:36:38.156]                       muffled <- FALSE
[17:36:38.156]                       if (inherits(cond, "message")) {
[17:36:38.156]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:38.156]                         if (muffled) 
[17:36:38.156]                           invokeRestart("muffleMessage")
[17:36:38.156]                       }
[17:36:38.156]                       else if (inherits(cond, "warning")) {
[17:36:38.156]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:38.156]                         if (muffled) 
[17:36:38.156]                           invokeRestart("muffleWarning")
[17:36:38.156]                       }
[17:36:38.156]                       else if (inherits(cond, "condition")) {
[17:36:38.156]                         if (!is.null(pattern)) {
[17:36:38.156]                           computeRestarts <- base::computeRestarts
[17:36:38.156]                           grepl <- base::grepl
[17:36:38.156]                           restarts <- computeRestarts(cond)
[17:36:38.156]                           for (restart in restarts) {
[17:36:38.156]                             name <- restart$name
[17:36:38.156]                             if (is.null(name)) 
[17:36:38.156]                               next
[17:36:38.156]                             if (!grepl(pattern, name)) 
[17:36:38.156]                               next
[17:36:38.156]                             invokeRestart(restart)
[17:36:38.156]                             muffled <- TRUE
[17:36:38.156]                             break
[17:36:38.156]                           }
[17:36:38.156]                         }
[17:36:38.156]                       }
[17:36:38.156]                       invisible(muffled)
[17:36:38.156]                     }
[17:36:38.156]                     muffleCondition(cond, pattern = "^muffle")
[17:36:38.156]                   }
[17:36:38.156]                 }
[17:36:38.156]             }
[17:36:38.156]         }))
[17:36:38.156]     }, error = function(ex) {
[17:36:38.156]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:38.156]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:38.156]                 ...future.rng), started = ...future.startTime, 
[17:36:38.156]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:38.156]             version = "1.8"), class = "FutureResult")
[17:36:38.156]     }, finally = {
[17:36:38.156]         if (!identical(...future.workdir, getwd())) 
[17:36:38.156]             setwd(...future.workdir)
[17:36:38.156]         {
[17:36:38.156]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:38.156]                 ...future.oldOptions$nwarnings <- NULL
[17:36:38.156]             }
[17:36:38.156]             base::options(...future.oldOptions)
[17:36:38.156]             if (.Platform$OS.type == "windows") {
[17:36:38.156]                 old_names <- names(...future.oldEnvVars)
[17:36:38.156]                 envs <- base::Sys.getenv()
[17:36:38.156]                 names <- names(envs)
[17:36:38.156]                 common <- intersect(names, old_names)
[17:36:38.156]                 added <- setdiff(names, old_names)
[17:36:38.156]                 removed <- setdiff(old_names, names)
[17:36:38.156]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:38.156]                   envs[common]]
[17:36:38.156]                 NAMES <- toupper(changed)
[17:36:38.156]                 args <- list()
[17:36:38.156]                 for (kk in seq_along(NAMES)) {
[17:36:38.156]                   name <- changed[[kk]]
[17:36:38.156]                   NAME <- NAMES[[kk]]
[17:36:38.156]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.156]                     next
[17:36:38.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:38.156]                 }
[17:36:38.156]                 NAMES <- toupper(added)
[17:36:38.156]                 for (kk in seq_along(NAMES)) {
[17:36:38.156]                   name <- added[[kk]]
[17:36:38.156]                   NAME <- NAMES[[kk]]
[17:36:38.156]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.156]                     next
[17:36:38.156]                   args[[name]] <- ""
[17:36:38.156]                 }
[17:36:38.156]                 NAMES <- toupper(removed)
[17:36:38.156]                 for (kk in seq_along(NAMES)) {
[17:36:38.156]                   name <- removed[[kk]]
[17:36:38.156]                   NAME <- NAMES[[kk]]
[17:36:38.156]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.156]                     next
[17:36:38.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:38.156]                 }
[17:36:38.156]                 if (length(args) > 0) 
[17:36:38.156]                   base::do.call(base::Sys.setenv, args = args)
[17:36:38.156]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:38.156]             }
[17:36:38.156]             else {
[17:36:38.156]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:38.156]             }
[17:36:38.156]             {
[17:36:38.156]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:38.156]                   0L) {
[17:36:38.156]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:38.156]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:38.156]                   base::options(opts)
[17:36:38.156]                 }
[17:36:38.156]                 {
[17:36:38.156]                   {
[17:36:38.156]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:38.156]                     NULL
[17:36:38.156]                   }
[17:36:38.156]                   options(future.plan = NULL)
[17:36:38.156]                   if (is.na(NA_character_)) 
[17:36:38.156]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:38.156]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:38.156]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:38.156]                     .init = FALSE)
[17:36:38.156]                 }
[17:36:38.156]             }
[17:36:38.156]         }
[17:36:38.156]     })
[17:36:38.156]     if (TRUE) {
[17:36:38.156]         base::sink(type = "output", split = FALSE)
[17:36:38.156]         if (TRUE) {
[17:36:38.156]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:38.156]         }
[17:36:38.156]         else {
[17:36:38.156]             ...future.result["stdout"] <- base::list(NULL)
[17:36:38.156]         }
[17:36:38.156]         base::close(...future.stdout)
[17:36:38.156]         ...future.stdout <- NULL
[17:36:38.156]     }
[17:36:38.156]     ...future.result$conditions <- ...future.conditions
[17:36:38.156]     ...future.result$finished <- base::Sys.time()
[17:36:38.156]     ...future.result
[17:36:38.156] }
[17:36:38.159] Exporting 5 global objects (1.97 KiB) to cluster node #2 ...
[17:36:38.159] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:36:38.159] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:36:38.159] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ...
[17:36:38.160] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ... DONE
[17:36:38.160] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ...
[17:36:38.160] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ... DONE
[17:36:38.160] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:36:38.161] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:36:38.161] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:36:38.161] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:36:38.161] Exporting 5 global objects (1.97 KiB) to cluster node #2 ... DONE
[17:36:38.162] MultisessionFuture started
[17:36:38.162] - Launch lazy future ... done
[17:36:38.162] run() for ‘MultisessionFuture’ ... done
[17:36:38.162] Created future:
[17:36:38.162] MultisessionFuture:
[17:36:38.162] Label: ‘future_apply-2’
[17:36:38.162] Expression:
[17:36:38.162] {
[17:36:38.162]     do.call(function(...) {
[17:36:38.162]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.162]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:38.162]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.162]             on.exit(options(oopts), add = TRUE)
[17:36:38.162]         }
[17:36:38.162]         {
[17:36:38.162]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:38.162]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.162]                 ...future.FUN(...future.X_jj, ...)
[17:36:38.162]             })
[17:36:38.162]         }
[17:36:38.162]     }, args = future.call.arguments)
[17:36:38.162] }
[17:36:38.162] Lazy evaluation: FALSE
[17:36:38.162] Asynchronous evaluation: TRUE
[17:36:38.162] Local evaluation: TRUE
[17:36:38.162] Environment: R_GlobalEnv
[17:36:38.162] Capture standard output: TRUE
[17:36:38.162] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:38.162] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:38.162] Packages: <none>
[17:36:38.162] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:38.162] Resolved: FALSE
[17:36:38.162] Value: <not collected>
[17:36:38.162] Conditions captured: <none>
[17:36:38.162] Early signaling: FALSE
[17:36:38.162] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:38.162] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.173] Chunk #2 of 2 ... DONE
[17:36:38.174] Launching 2 futures (chunks) ... DONE
[17:36:38.174] Resolving 2 futures (chunks) ...
[17:36:38.174] resolve() on list ...
[17:36:38.174]  recursive: 0
[17:36:38.174]  length: 2
[17:36:38.174] 
[17:36:38.174] receiveMessageFromWorker() for ClusterFuture ...
[17:36:38.175] - Validating connection of MultisessionFuture
[17:36:38.175] - received message: FutureResult
[17:36:38.175] - Received FutureResult
[17:36:38.175] - Erased future from FutureRegistry
[17:36:38.175] result() for ClusterFuture ...
[17:36:38.175] - result already collected: FutureResult
[17:36:38.175] result() for ClusterFuture ... done
[17:36:38.175] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:38.175] Future #1
[17:36:38.175] result() for ClusterFuture ...
[17:36:38.176] - result already collected: FutureResult
[17:36:38.176] result() for ClusterFuture ... done
[17:36:38.176] result() for ClusterFuture ...
[17:36:38.176] - result already collected: FutureResult
[17:36:38.176] result() for ClusterFuture ... done
[17:36:38.176] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:36:38.176] - nx: 2
[17:36:38.176] - relay: TRUE
[17:36:38.176] - stdout: TRUE
[17:36:38.176] - signal: TRUE
[17:36:38.176] - resignal: FALSE
[17:36:38.177] - force: TRUE
[17:36:38.177] - relayed: [n=2] FALSE, FALSE
[17:36:38.177] - queued futures: [n=2] FALSE, FALSE
[17:36:38.177]  - until=1
[17:36:38.177]  - relaying element #1
[17:36:38.177] result() for ClusterFuture ...
[17:36:38.177] - result already collected: FutureResult
[17:36:38.177] result() for ClusterFuture ... done
[17:36:38.177] result() for ClusterFuture ...
[17:36:38.177] - result already collected: FutureResult
[17:36:38.177] result() for ClusterFuture ... done
[17:36:38.178] result() for ClusterFuture ...
[17:36:38.178] - result already collected: FutureResult
[17:36:38.178] result() for ClusterFuture ... done
[17:36:38.178] result() for ClusterFuture ...
[17:36:38.178] - result already collected: FutureResult
[17:36:38.178] result() for ClusterFuture ... done
[17:36:38.178] - relayed: [n=2] TRUE, FALSE
[17:36:38.178] - queued futures: [n=2] TRUE, FALSE
[17:36:38.178] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:36:38.178]  length: 1 (resolved future 1)
[17:36:38.206] receiveMessageFromWorker() for ClusterFuture ...
[17:36:38.206] - Validating connection of MultisessionFuture
[17:36:38.206] - received message: FutureResult
[17:36:38.206] - Received FutureResult
[17:36:38.206] - Erased future from FutureRegistry
[17:36:38.207] result() for ClusterFuture ...
[17:36:38.207] - result already collected: FutureResult
[17:36:38.207] result() for ClusterFuture ... done
[17:36:38.207] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:38.207] Future #2
[17:36:38.207] result() for ClusterFuture ...
[17:36:38.207] - result already collected: FutureResult
[17:36:38.207] result() for ClusterFuture ... done
[17:36:38.207] result() for ClusterFuture ...
[17:36:38.207] - result already collected: FutureResult
[17:36:38.207] result() for ClusterFuture ... done
[17:36:38.208] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:36:38.208] - nx: 2
[17:36:38.208] - relay: TRUE
[17:36:38.208] - stdout: TRUE
[17:36:38.208] - signal: TRUE
[17:36:38.208] - resignal: FALSE
[17:36:38.208] - force: TRUE
[17:36:38.208] - relayed: [n=2] TRUE, FALSE
[17:36:38.208] - queued futures: [n=2] TRUE, FALSE
[17:36:38.208]  - until=2
[17:36:38.208]  - relaying element #2
[17:36:38.209] result() for ClusterFuture ...
[17:36:38.209] - result already collected: FutureResult
[17:36:38.209] result() for ClusterFuture ... done
[17:36:38.209] result() for ClusterFuture ...
[17:36:38.209] - result already collected: FutureResult
[17:36:38.209] result() for ClusterFuture ... done
[17:36:38.209] result() for ClusterFuture ...
[17:36:38.209] - result already collected: FutureResult
[17:36:38.209] result() for ClusterFuture ... done
[17:36:38.209] result() for ClusterFuture ...
[17:36:38.209] - result already collected: FutureResult
[17:36:38.209] result() for ClusterFuture ... done
[17:36:38.210] - relayed: [n=2] TRUE, TRUE
[17:36:38.210] - queued futures: [n=2] TRUE, TRUE
[17:36:38.210] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:36:38.210]  length: 0 (resolved future 2)
[17:36:38.210] Relaying remaining futures
[17:36:38.210] signalConditionsASAP(NULL, pos=0) ...
[17:36:38.210] - nx: 2
[17:36:38.210] - relay: TRUE
[17:36:38.210] - stdout: TRUE
[17:36:38.210] - signal: TRUE
[17:36:38.210] - resignal: FALSE
[17:36:38.210] - force: TRUE
[17:36:38.211] - relayed: [n=2] TRUE, TRUE
[17:36:38.211] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:38.211] - relayed: [n=2] TRUE, TRUE
[17:36:38.211] - queued futures: [n=2] TRUE, TRUE
[17:36:38.211] signalConditionsASAP(NULL, pos=0) ... done
[17:36:38.211] resolve() on list ... DONE
[17:36:38.211] result() for ClusterFuture ...
[17:36:38.211] - result already collected: FutureResult
[17:36:38.211] result() for ClusterFuture ... done
[17:36:38.211] result() for ClusterFuture ...
[17:36:38.211] - result already collected: FutureResult
[17:36:38.212] result() for ClusterFuture ... done
[17:36:38.212] result() for ClusterFuture ...
[17:36:38.212] - result already collected: FutureResult
[17:36:38.212] result() for ClusterFuture ... done
[17:36:38.212] result() for ClusterFuture ...
[17:36:38.212] - result already collected: FutureResult
[17:36:38.212] result() for ClusterFuture ... done
[17:36:38.212]  - Number of value chunks collected: 2
[17:36:38.212] Resolving 2 futures (chunks) ... DONE
[17:36:38.212] Reducing values from 2 chunks ...
[17:36:38.212]  - Number of values collected after concatenation: 6
[17:36:38.213]  - Number of values expected: 6
[17:36:38.213] Reducing values from 2 chunks ... DONE
[17:36:38.213] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[17:36:38.213] getGlobalsAndPackagesXApply() ...
[17:36:38.213]  - future.globals: TRUE
[17:36:38.213] getGlobalsAndPackages() ...
[17:36:38.213] Searching for globals...
[17:36:38.214] - globals found: [1] ‘FUN’
[17:36:38.214] Searching for globals ... DONE
[17:36:38.215] Resolving globals: FALSE
[17:36:38.215] The total size of the 1 globals is 848 bytes (848 bytes)
[17:36:38.217] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:36:38.218] - globals: [1] ‘FUN’
[17:36:38.218] 
[17:36:38.218] getGlobalsAndPackages() ... DONE
[17:36:38.218]  - globals found/used: [n=1] ‘FUN’
[17:36:38.218]  - needed namespaces: [n=0] 
[17:36:38.218] Finding globals ... DONE
[17:36:38.218]  - use_args: TRUE
[17:36:38.218]  - Getting '...' globals ...
[17:36:38.219] resolve() on list ...
[17:36:38.219]  recursive: 0
[17:36:38.219]  length: 1
[17:36:38.219]  elements: ‘...’
[17:36:38.219]  length: 0 (resolved future 1)
[17:36:38.219] resolve() on list ... DONE
[17:36:38.219]    - '...' content: [n=0] 
[17:36:38.219] List of 1
[17:36:38.219]  $ ...: list()
[17:36:38.219]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:38.219]  - attr(*, "where")=List of 1
[17:36:38.219]   ..$ ...:<environment: 0x556d77fc17c0> 
[17:36:38.219]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:38.219]  - attr(*, "resolved")= logi TRUE
[17:36:38.219]  - attr(*, "total_size")= num NA
[17:36:38.222]  - Getting '...' globals ... DONE
[17:36:38.222] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:38.222] List of 2
[17:36:38.222]  $ ...future.FUN:function (x)  
[17:36:38.222]  $ ...          : list()
[17:36:38.222]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:38.222]  - attr(*, "where")=List of 2
[17:36:38.222]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:38.222]   ..$ ...          :<environment: 0x556d77fc17c0> 
[17:36:38.222]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:38.222]  - attr(*, "resolved")= logi FALSE
[17:36:38.222]  - attr(*, "total_size")= num 848
[17:36:38.224] Packages to be attached in all futures: [n=0] 
[17:36:38.224] getGlobalsAndPackagesXApply() ... DONE
[17:36:38.228] future_lapply() ...
[17:36:38.232] Number of chunks: 2
[17:36:38.232] getGlobalsAndPackagesXApply() ...
[17:36:38.232]  - future.globals: <name-value list> with names ‘list()’
[17:36:38.232]  - use_args: TRUE
[17:36:38.233] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:38.233] List of 2
[17:36:38.233]  $ ...          : list()
[17:36:38.233]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:38.233]  $ ...future.FUN:function (x)  
[17:36:38.233]  - attr(*, "where")=List of 2
[17:36:38.233]   ..$ ...          :<environment: 0x556d77fc17c0> 
[17:36:38.233]   ..$ ...future.FUN:<environment: namespace:base> 
[17:36:38.233]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:38.233]  - attr(*, "resolved")= logi FALSE
[17:36:38.233]  - attr(*, "total_size")= num NA
[17:36:38.237] Packages to be attached in all futures: [n=0] 
[17:36:38.237] getGlobalsAndPackagesXApply() ... DONE
[17:36:38.237] Number of futures (= number of chunks): 2
[17:36:38.238] Launching 2 futures (chunks) ...
[17:36:38.238] Chunk #1 of 2 ...
[17:36:38.238]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:38.238]  - seeds: <none>
[17:36:38.238]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.238] getGlobalsAndPackages() ...
[17:36:38.238] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.239] Resolving globals: FALSE
[17:36:38.239] Tweak future expression to call with '...' arguments ...
[17:36:38.239] {
[17:36:38.239]     do.call(function(...) {
[17:36:38.239]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.239]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:38.239]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.239]             on.exit(options(oopts), add = TRUE)
[17:36:38.239]         }
[17:36:38.239]         {
[17:36:38.239]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:38.239]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.239]                 ...future.FUN(...future.X_jj, ...)
[17:36:38.239]             })
[17:36:38.239]         }
[17:36:38.239]     }, args = future.call.arguments)
[17:36:38.239] }
[17:36:38.239] Tweak future expression to call with '...' arguments ... DONE
[17:36:38.240] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.240] 
[17:36:38.240] getGlobalsAndPackages() ... DONE
[17:36:38.240] run() for ‘Future’ ...
[17:36:38.241] - state: ‘created’
[17:36:38.241] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:38.256] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.256] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:38.256]   - Field: ‘node’
[17:36:38.257]   - Field: ‘label’
[17:36:38.257]   - Field: ‘local’
[17:36:38.257]   - Field: ‘owner’
[17:36:38.257]   - Field: ‘envir’
[17:36:38.257]   - Field: ‘workers’
[17:36:38.257]   - Field: ‘packages’
[17:36:38.257]   - Field: ‘gc’
[17:36:38.258]   - Field: ‘conditions’
[17:36:38.258]   - Field: ‘persistent’
[17:36:38.258]   - Field: ‘expr’
[17:36:38.258]   - Field: ‘uuid’
[17:36:38.258]   - Field: ‘seed’
[17:36:38.258]   - Field: ‘version’
[17:36:38.258]   - Field: ‘result’
[17:36:38.259]   - Field: ‘asynchronous’
[17:36:38.259]   - Field: ‘calls’
[17:36:38.259]   - Field: ‘globals’
[17:36:38.259]   - Field: ‘stdout’
[17:36:38.259]   - Field: ‘earlySignal’
[17:36:38.259]   - Field: ‘lazy’
[17:36:38.259]   - Field: ‘state’
[17:36:38.259] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:38.260] - Launch lazy future ...
[17:36:38.260] Packages needed by the future expression (n = 0): <none>
[17:36:38.260] Packages needed by future strategies (n = 0): <none>
[17:36:38.261] {
[17:36:38.261]     {
[17:36:38.261]         {
[17:36:38.261]             ...future.startTime <- base::Sys.time()
[17:36:38.261]             {
[17:36:38.261]                 {
[17:36:38.261]                   {
[17:36:38.261]                     {
[17:36:38.261]                       base::local({
[17:36:38.261]                         has_future <- base::requireNamespace("future", 
[17:36:38.261]                           quietly = TRUE)
[17:36:38.261]                         if (has_future) {
[17:36:38.261]                           ns <- base::getNamespace("future")
[17:36:38.261]                           version <- ns[[".package"]][["version"]]
[17:36:38.261]                           if (is.null(version)) 
[17:36:38.261]                             version <- utils::packageVersion("future")
[17:36:38.261]                         }
[17:36:38.261]                         else {
[17:36:38.261]                           version <- NULL
[17:36:38.261]                         }
[17:36:38.261]                         if (!has_future || version < "1.8.0") {
[17:36:38.261]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:38.261]                             "", base::R.version$version.string), 
[17:36:38.261]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:38.261]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:38.261]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:38.261]                               "release", "version")], collapse = " "), 
[17:36:38.261]                             hostname = base::Sys.info()[["nodename"]])
[17:36:38.261]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:38.261]                             info)
[17:36:38.261]                           info <- base::paste(info, collapse = "; ")
[17:36:38.261]                           if (!has_future) {
[17:36:38.261]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:38.261]                               info)
[17:36:38.261]                           }
[17:36:38.261]                           else {
[17:36:38.261]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:38.261]                               info, version)
[17:36:38.261]                           }
[17:36:38.261]                           base::stop(msg)
[17:36:38.261]                         }
[17:36:38.261]                       })
[17:36:38.261]                     }
[17:36:38.261]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:38.261]                     base::options(mc.cores = 1L)
[17:36:38.261]                   }
[17:36:38.261]                   ...future.strategy.old <- future::plan("list")
[17:36:38.261]                   options(future.plan = NULL)
[17:36:38.261]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:38.261]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:38.261]                 }
[17:36:38.261]                 ...future.workdir <- getwd()
[17:36:38.261]             }
[17:36:38.261]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:38.261]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:38.261]         }
[17:36:38.261]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:38.261]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:38.261]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:38.261]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:38.261]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:38.261]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:38.261]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:38.261]             base::names(...future.oldOptions))
[17:36:38.261]     }
[17:36:38.261]     if (FALSE) {
[17:36:38.261]     }
[17:36:38.261]     else {
[17:36:38.261]         if (TRUE) {
[17:36:38.261]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:38.261]                 open = "w")
[17:36:38.261]         }
[17:36:38.261]         else {
[17:36:38.261]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:38.261]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:38.261]         }
[17:36:38.261]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:38.261]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:38.261]             base::sink(type = "output", split = FALSE)
[17:36:38.261]             base::close(...future.stdout)
[17:36:38.261]         }, add = TRUE)
[17:36:38.261]     }
[17:36:38.261]     ...future.frame <- base::sys.nframe()
[17:36:38.261]     ...future.conditions <- base::list()
[17:36:38.261]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:38.261]     if (FALSE) {
[17:36:38.261]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:38.261]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:38.261]     }
[17:36:38.261]     ...future.result <- base::tryCatch({
[17:36:38.261]         base::withCallingHandlers({
[17:36:38.261]             ...future.value <- base::withVisible(base::local({
[17:36:38.261]                 ...future.makeSendCondition <- base::local({
[17:36:38.261]                   sendCondition <- NULL
[17:36:38.261]                   function(frame = 1L) {
[17:36:38.261]                     if (is.function(sendCondition)) 
[17:36:38.261]                       return(sendCondition)
[17:36:38.261]                     ns <- getNamespace("parallel")
[17:36:38.261]                     if (exists("sendData", mode = "function", 
[17:36:38.261]                       envir = ns)) {
[17:36:38.261]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:38.261]                         envir = ns)
[17:36:38.261]                       envir <- sys.frame(frame)
[17:36:38.261]                       master <- NULL
[17:36:38.261]                       while (!identical(envir, .GlobalEnv) && 
[17:36:38.261]                         !identical(envir, emptyenv())) {
[17:36:38.261]                         if (exists("master", mode = "list", envir = envir, 
[17:36:38.261]                           inherits = FALSE)) {
[17:36:38.261]                           master <- get("master", mode = "list", 
[17:36:38.261]                             envir = envir, inherits = FALSE)
[17:36:38.261]                           if (inherits(master, c("SOCKnode", 
[17:36:38.261]                             "SOCK0node"))) {
[17:36:38.261]                             sendCondition <<- function(cond) {
[17:36:38.261]                               data <- list(type = "VALUE", value = cond, 
[17:36:38.261]                                 success = TRUE)
[17:36:38.261]                               parallel_sendData(master, data)
[17:36:38.261]                             }
[17:36:38.261]                             return(sendCondition)
[17:36:38.261]                           }
[17:36:38.261]                         }
[17:36:38.261]                         frame <- frame + 1L
[17:36:38.261]                         envir <- sys.frame(frame)
[17:36:38.261]                       }
[17:36:38.261]                     }
[17:36:38.261]                     sendCondition <<- function(cond) NULL
[17:36:38.261]                   }
[17:36:38.261]                 })
[17:36:38.261]                 withCallingHandlers({
[17:36:38.261]                   {
[17:36:38.261]                     do.call(function(...) {
[17:36:38.261]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.261]                       if (!identical(...future.globals.maxSize.org, 
[17:36:38.261]                         ...future.globals.maxSize)) {
[17:36:38.261]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.261]                         on.exit(options(oopts), add = TRUE)
[17:36:38.261]                       }
[17:36:38.261]                       {
[17:36:38.261]                         lapply(seq_along(...future.elements_ii), 
[17:36:38.261]                           FUN = function(jj) {
[17:36:38.261]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.261]                             ...future.FUN(...future.X_jj, ...)
[17:36:38.261]                           })
[17:36:38.261]                       }
[17:36:38.261]                     }, args = future.call.arguments)
[17:36:38.261]                   }
[17:36:38.261]                 }, immediateCondition = function(cond) {
[17:36:38.261]                   sendCondition <- ...future.makeSendCondition()
[17:36:38.261]                   sendCondition(cond)
[17:36:38.261]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.261]                   {
[17:36:38.261]                     inherits <- base::inherits
[17:36:38.261]                     invokeRestart <- base::invokeRestart
[17:36:38.261]                     is.null <- base::is.null
[17:36:38.261]                     muffled <- FALSE
[17:36:38.261]                     if (inherits(cond, "message")) {
[17:36:38.261]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:38.261]                       if (muffled) 
[17:36:38.261]                         invokeRestart("muffleMessage")
[17:36:38.261]                     }
[17:36:38.261]                     else if (inherits(cond, "warning")) {
[17:36:38.261]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:38.261]                       if (muffled) 
[17:36:38.261]                         invokeRestart("muffleWarning")
[17:36:38.261]                     }
[17:36:38.261]                     else if (inherits(cond, "condition")) {
[17:36:38.261]                       if (!is.null(pattern)) {
[17:36:38.261]                         computeRestarts <- base::computeRestarts
[17:36:38.261]                         grepl <- base::grepl
[17:36:38.261]                         restarts <- computeRestarts(cond)
[17:36:38.261]                         for (restart in restarts) {
[17:36:38.261]                           name <- restart$name
[17:36:38.261]                           if (is.null(name)) 
[17:36:38.261]                             next
[17:36:38.261]                           if (!grepl(pattern, name)) 
[17:36:38.261]                             next
[17:36:38.261]                           invokeRestart(restart)
[17:36:38.261]                           muffled <- TRUE
[17:36:38.261]                           break
[17:36:38.261]                         }
[17:36:38.261]                       }
[17:36:38.261]                     }
[17:36:38.261]                     invisible(muffled)
[17:36:38.261]                   }
[17:36:38.261]                   muffleCondition(cond)
[17:36:38.261]                 })
[17:36:38.261]             }))
[17:36:38.261]             future::FutureResult(value = ...future.value$value, 
[17:36:38.261]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:38.261]                   ...future.rng), globalenv = if (FALSE) 
[17:36:38.261]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:38.261]                     ...future.globalenv.names))
[17:36:38.261]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:38.261]         }, condition = base::local({
[17:36:38.261]             c <- base::c
[17:36:38.261]             inherits <- base::inherits
[17:36:38.261]             invokeRestart <- base::invokeRestart
[17:36:38.261]             length <- base::length
[17:36:38.261]             list <- base::list
[17:36:38.261]             seq.int <- base::seq.int
[17:36:38.261]             signalCondition <- base::signalCondition
[17:36:38.261]             sys.calls <- base::sys.calls
[17:36:38.261]             `[[` <- base::`[[`
[17:36:38.261]             `+` <- base::`+`
[17:36:38.261]             `<<-` <- base::`<<-`
[17:36:38.261]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:38.261]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:38.261]                   3L)]
[17:36:38.261]             }
[17:36:38.261]             function(cond) {
[17:36:38.261]                 is_error <- inherits(cond, "error")
[17:36:38.261]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:38.261]                   NULL)
[17:36:38.261]                 if (is_error) {
[17:36:38.261]                   sessionInformation <- function() {
[17:36:38.261]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:38.261]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:38.261]                       search = base::search(), system = base::Sys.info())
[17:36:38.261]                   }
[17:36:38.261]                   ...future.conditions[[length(...future.conditions) + 
[17:36:38.261]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:38.261]                     cond$call), session = sessionInformation(), 
[17:36:38.261]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:38.261]                   signalCondition(cond)
[17:36:38.261]                 }
[17:36:38.261]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:38.261]                 "immediateCondition"))) {
[17:36:38.261]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:38.261]                   ...future.conditions[[length(...future.conditions) + 
[17:36:38.261]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:38.261]                   if (TRUE && !signal) {
[17:36:38.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.261]                     {
[17:36:38.261]                       inherits <- base::inherits
[17:36:38.261]                       invokeRestart <- base::invokeRestart
[17:36:38.261]                       is.null <- base::is.null
[17:36:38.261]                       muffled <- FALSE
[17:36:38.261]                       if (inherits(cond, "message")) {
[17:36:38.261]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:38.261]                         if (muffled) 
[17:36:38.261]                           invokeRestart("muffleMessage")
[17:36:38.261]                       }
[17:36:38.261]                       else if (inherits(cond, "warning")) {
[17:36:38.261]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:38.261]                         if (muffled) 
[17:36:38.261]                           invokeRestart("muffleWarning")
[17:36:38.261]                       }
[17:36:38.261]                       else if (inherits(cond, "condition")) {
[17:36:38.261]                         if (!is.null(pattern)) {
[17:36:38.261]                           computeRestarts <- base::computeRestarts
[17:36:38.261]                           grepl <- base::grepl
[17:36:38.261]                           restarts <- computeRestarts(cond)
[17:36:38.261]                           for (restart in restarts) {
[17:36:38.261]                             name <- restart$name
[17:36:38.261]                             if (is.null(name)) 
[17:36:38.261]                               next
[17:36:38.261]                             if (!grepl(pattern, name)) 
[17:36:38.261]                               next
[17:36:38.261]                             invokeRestart(restart)
[17:36:38.261]                             muffled <- TRUE
[17:36:38.261]                             break
[17:36:38.261]                           }
[17:36:38.261]                         }
[17:36:38.261]                       }
[17:36:38.261]                       invisible(muffled)
[17:36:38.261]                     }
[17:36:38.261]                     muffleCondition(cond, pattern = "^muffle")
[17:36:38.261]                   }
[17:36:38.261]                 }
[17:36:38.261]                 else {
[17:36:38.261]                   if (TRUE) {
[17:36:38.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.261]                     {
[17:36:38.261]                       inherits <- base::inherits
[17:36:38.261]                       invokeRestart <- base::invokeRestart
[17:36:38.261]                       is.null <- base::is.null
[17:36:38.261]                       muffled <- FALSE
[17:36:38.261]                       if (inherits(cond, "message")) {
[17:36:38.261]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:38.261]                         if (muffled) 
[17:36:38.261]                           invokeRestart("muffleMessage")
[17:36:38.261]                       }
[17:36:38.261]                       else if (inherits(cond, "warning")) {
[17:36:38.261]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:38.261]                         if (muffled) 
[17:36:38.261]                           invokeRestart("muffleWarning")
[17:36:38.261]                       }
[17:36:38.261]                       else if (inherits(cond, "condition")) {
[17:36:38.261]                         if (!is.null(pattern)) {
[17:36:38.261]                           computeRestarts <- base::computeRestarts
[17:36:38.261]                           grepl <- base::grepl
[17:36:38.261]                           restarts <- computeRestarts(cond)
[17:36:38.261]                           for (restart in restarts) {
[17:36:38.261]                             name <- restart$name
[17:36:38.261]                             if (is.null(name)) 
[17:36:38.261]                               next
[17:36:38.261]                             if (!grepl(pattern, name)) 
[17:36:38.261]                               next
[17:36:38.261]                             invokeRestart(restart)
[17:36:38.261]                             muffled <- TRUE
[17:36:38.261]                             break
[17:36:38.261]                           }
[17:36:38.261]                         }
[17:36:38.261]                       }
[17:36:38.261]                       invisible(muffled)
[17:36:38.261]                     }
[17:36:38.261]                     muffleCondition(cond, pattern = "^muffle")
[17:36:38.261]                   }
[17:36:38.261]                 }
[17:36:38.261]             }
[17:36:38.261]         }))
[17:36:38.261]     }, error = function(ex) {
[17:36:38.261]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:38.261]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:38.261]                 ...future.rng), started = ...future.startTime, 
[17:36:38.261]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:38.261]             version = "1.8"), class = "FutureResult")
[17:36:38.261]     }, finally = {
[17:36:38.261]         if (!identical(...future.workdir, getwd())) 
[17:36:38.261]             setwd(...future.workdir)
[17:36:38.261]         {
[17:36:38.261]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:38.261]                 ...future.oldOptions$nwarnings <- NULL
[17:36:38.261]             }
[17:36:38.261]             base::options(...future.oldOptions)
[17:36:38.261]             if (.Platform$OS.type == "windows") {
[17:36:38.261]                 old_names <- names(...future.oldEnvVars)
[17:36:38.261]                 envs <- base::Sys.getenv()
[17:36:38.261]                 names <- names(envs)
[17:36:38.261]                 common <- intersect(names, old_names)
[17:36:38.261]                 added <- setdiff(names, old_names)
[17:36:38.261]                 removed <- setdiff(old_names, names)
[17:36:38.261]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:38.261]                   envs[common]]
[17:36:38.261]                 NAMES <- toupper(changed)
[17:36:38.261]                 args <- list()
[17:36:38.261]                 for (kk in seq_along(NAMES)) {
[17:36:38.261]                   name <- changed[[kk]]
[17:36:38.261]                   NAME <- NAMES[[kk]]
[17:36:38.261]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.261]                     next
[17:36:38.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:38.261]                 }
[17:36:38.261]                 NAMES <- toupper(added)
[17:36:38.261]                 for (kk in seq_along(NAMES)) {
[17:36:38.261]                   name <- added[[kk]]
[17:36:38.261]                   NAME <- NAMES[[kk]]
[17:36:38.261]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.261]                     next
[17:36:38.261]                   args[[name]] <- ""
[17:36:38.261]                 }
[17:36:38.261]                 NAMES <- toupper(removed)
[17:36:38.261]                 for (kk in seq_along(NAMES)) {
[17:36:38.261]                   name <- removed[[kk]]
[17:36:38.261]                   NAME <- NAMES[[kk]]
[17:36:38.261]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.261]                     next
[17:36:38.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:38.261]                 }
[17:36:38.261]                 if (length(args) > 0) 
[17:36:38.261]                   base::do.call(base::Sys.setenv, args = args)
[17:36:38.261]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:38.261]             }
[17:36:38.261]             else {
[17:36:38.261]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:38.261]             }
[17:36:38.261]             {
[17:36:38.261]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:38.261]                   0L) {
[17:36:38.261]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:38.261]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:38.261]                   base::options(opts)
[17:36:38.261]                 }
[17:36:38.261]                 {
[17:36:38.261]                   {
[17:36:38.261]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:38.261]                     NULL
[17:36:38.261]                   }
[17:36:38.261]                   options(future.plan = NULL)
[17:36:38.261]                   if (is.na(NA_character_)) 
[17:36:38.261]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:38.261]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:38.261]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:38.261]                     .init = FALSE)
[17:36:38.261]                 }
[17:36:38.261]             }
[17:36:38.261]         }
[17:36:38.261]     })
[17:36:38.261]     if (TRUE) {
[17:36:38.261]         base::sink(type = "output", split = FALSE)
[17:36:38.261]         if (TRUE) {
[17:36:38.261]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:38.261]         }
[17:36:38.261]         else {
[17:36:38.261]             ...future.result["stdout"] <- base::list(NULL)
[17:36:38.261]         }
[17:36:38.261]         base::close(...future.stdout)
[17:36:38.261]         ...future.stdout <- NULL
[17:36:38.261]     }
[17:36:38.261]     ...future.result$conditions <- ...future.conditions
[17:36:38.261]     ...future.result$finished <- base::Sys.time()
[17:36:38.261]     ...future.result
[17:36:38.261] }
[17:36:38.265] Exporting 5 global objects (960 bytes) to cluster node #1 ...
[17:36:38.265] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:36:38.266] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:36:38.266] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:36:38.266] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:36:38.266] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:36:38.267] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:36:38.267] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:36:38.267] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:36:38.267] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:36:38.268] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:36:38.268] Exporting 5 global objects (960 bytes) to cluster node #1 ... DONE
[17:36:38.268] MultisessionFuture started
[17:36:38.268] - Launch lazy future ... done
[17:36:38.269] run() for ‘MultisessionFuture’ ... done
[17:36:38.269] Created future:
[17:36:38.269] MultisessionFuture:
[17:36:38.269] Label: ‘future_apply-1’
[17:36:38.269] Expression:
[17:36:38.269] {
[17:36:38.269]     do.call(function(...) {
[17:36:38.269]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.269]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:38.269]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.269]             on.exit(options(oopts), add = TRUE)
[17:36:38.269]         }
[17:36:38.269]         {
[17:36:38.269]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:38.269]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.269]                 ...future.FUN(...future.X_jj, ...)
[17:36:38.269]             })
[17:36:38.269]         }
[17:36:38.269]     }, args = future.call.arguments)
[17:36:38.269] }
[17:36:38.269] Lazy evaluation: FALSE
[17:36:38.269] Asynchronous evaluation: TRUE
[17:36:38.269] Local evaluation: TRUE
[17:36:38.269] Environment: R_GlobalEnv
[17:36:38.269] Capture standard output: TRUE
[17:36:38.269] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:38.269] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:38.269] Packages: <none>
[17:36:38.269] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:38.269] Resolved: FALSE
[17:36:38.269] Value: <not collected>
[17:36:38.269] Conditions captured: <none>
[17:36:38.269] Early signaling: FALSE
[17:36:38.269] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:38.269] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.281] Chunk #1 of 2 ... DONE
[17:36:38.281] Chunk #2 of 2 ...
[17:36:38.281]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:38.281]  - seeds: <none>
[17:36:38.281]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.281] getGlobalsAndPackages() ...
[17:36:38.281] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.282] Resolving globals: FALSE
[17:36:38.282] Tweak future expression to call with '...' arguments ...
[17:36:38.282] {
[17:36:38.282]     do.call(function(...) {
[17:36:38.282]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.282]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:38.282]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.282]             on.exit(options(oopts), add = TRUE)
[17:36:38.282]         }
[17:36:38.282]         {
[17:36:38.282]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:38.282]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.282]                 ...future.FUN(...future.X_jj, ...)
[17:36:38.282]             })
[17:36:38.282]         }
[17:36:38.282]     }, args = future.call.arguments)
[17:36:38.282] }
[17:36:38.282] Tweak future expression to call with '...' arguments ... DONE
[17:36:38.282] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.283] 
[17:36:38.283] getGlobalsAndPackages() ... DONE
[17:36:38.283] run() for ‘Future’ ...
[17:36:38.283] - state: ‘created’
[17:36:38.283] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:38.297] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.297] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:38.297]   - Field: ‘node’
[17:36:38.297]   - Field: ‘label’
[17:36:38.297]   - Field: ‘local’
[17:36:38.297]   - Field: ‘owner’
[17:36:38.297]   - Field: ‘envir’
[17:36:38.298]   - Field: ‘workers’
[17:36:38.298]   - Field: ‘packages’
[17:36:38.298]   - Field: ‘gc’
[17:36:38.298]   - Field: ‘conditions’
[17:36:38.298]   - Field: ‘persistent’
[17:36:38.298]   - Field: ‘expr’
[17:36:38.298]   - Field: ‘uuid’
[17:36:38.298]   - Field: ‘seed’
[17:36:38.298]   - Field: ‘version’
[17:36:38.298]   - Field: ‘result’
[17:36:38.298]   - Field: ‘asynchronous’
[17:36:38.299]   - Field: ‘calls’
[17:36:38.299]   - Field: ‘globals’
[17:36:38.299]   - Field: ‘stdout’
[17:36:38.299]   - Field: ‘earlySignal’
[17:36:38.299]   - Field: ‘lazy’
[17:36:38.299]   - Field: ‘state’
[17:36:38.299] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:38.299] - Launch lazy future ...
[17:36:38.299] Packages needed by the future expression (n = 0): <none>
[17:36:38.300] Packages needed by future strategies (n = 0): <none>
[17:36:38.300] {
[17:36:38.300]     {
[17:36:38.300]         {
[17:36:38.300]             ...future.startTime <- base::Sys.time()
[17:36:38.300]             {
[17:36:38.300]                 {
[17:36:38.300]                   {
[17:36:38.300]                     {
[17:36:38.300]                       base::local({
[17:36:38.300]                         has_future <- base::requireNamespace("future", 
[17:36:38.300]                           quietly = TRUE)
[17:36:38.300]                         if (has_future) {
[17:36:38.300]                           ns <- base::getNamespace("future")
[17:36:38.300]                           version <- ns[[".package"]][["version"]]
[17:36:38.300]                           if (is.null(version)) 
[17:36:38.300]                             version <- utils::packageVersion("future")
[17:36:38.300]                         }
[17:36:38.300]                         else {
[17:36:38.300]                           version <- NULL
[17:36:38.300]                         }
[17:36:38.300]                         if (!has_future || version < "1.8.0") {
[17:36:38.300]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:38.300]                             "", base::R.version$version.string), 
[17:36:38.300]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:38.300]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:38.300]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:38.300]                               "release", "version")], collapse = " "), 
[17:36:38.300]                             hostname = base::Sys.info()[["nodename"]])
[17:36:38.300]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:38.300]                             info)
[17:36:38.300]                           info <- base::paste(info, collapse = "; ")
[17:36:38.300]                           if (!has_future) {
[17:36:38.300]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:38.300]                               info)
[17:36:38.300]                           }
[17:36:38.300]                           else {
[17:36:38.300]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:38.300]                               info, version)
[17:36:38.300]                           }
[17:36:38.300]                           base::stop(msg)
[17:36:38.300]                         }
[17:36:38.300]                       })
[17:36:38.300]                     }
[17:36:38.300]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:38.300]                     base::options(mc.cores = 1L)
[17:36:38.300]                   }
[17:36:38.300]                   ...future.strategy.old <- future::plan("list")
[17:36:38.300]                   options(future.plan = NULL)
[17:36:38.300]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:38.300]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:38.300]                 }
[17:36:38.300]                 ...future.workdir <- getwd()
[17:36:38.300]             }
[17:36:38.300]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:38.300]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:38.300]         }
[17:36:38.300]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:38.300]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:38.300]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:38.300]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:38.300]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:38.300]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:38.300]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:38.300]             base::names(...future.oldOptions))
[17:36:38.300]     }
[17:36:38.300]     if (FALSE) {
[17:36:38.300]     }
[17:36:38.300]     else {
[17:36:38.300]         if (TRUE) {
[17:36:38.300]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:38.300]                 open = "w")
[17:36:38.300]         }
[17:36:38.300]         else {
[17:36:38.300]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:38.300]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:38.300]         }
[17:36:38.300]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:38.300]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:38.300]             base::sink(type = "output", split = FALSE)
[17:36:38.300]             base::close(...future.stdout)
[17:36:38.300]         }, add = TRUE)
[17:36:38.300]     }
[17:36:38.300]     ...future.frame <- base::sys.nframe()
[17:36:38.300]     ...future.conditions <- base::list()
[17:36:38.300]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:38.300]     if (FALSE) {
[17:36:38.300]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:38.300]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:38.300]     }
[17:36:38.300]     ...future.result <- base::tryCatch({
[17:36:38.300]         base::withCallingHandlers({
[17:36:38.300]             ...future.value <- base::withVisible(base::local({
[17:36:38.300]                 ...future.makeSendCondition <- base::local({
[17:36:38.300]                   sendCondition <- NULL
[17:36:38.300]                   function(frame = 1L) {
[17:36:38.300]                     if (is.function(sendCondition)) 
[17:36:38.300]                       return(sendCondition)
[17:36:38.300]                     ns <- getNamespace("parallel")
[17:36:38.300]                     if (exists("sendData", mode = "function", 
[17:36:38.300]                       envir = ns)) {
[17:36:38.300]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:38.300]                         envir = ns)
[17:36:38.300]                       envir <- sys.frame(frame)
[17:36:38.300]                       master <- NULL
[17:36:38.300]                       while (!identical(envir, .GlobalEnv) && 
[17:36:38.300]                         !identical(envir, emptyenv())) {
[17:36:38.300]                         if (exists("master", mode = "list", envir = envir, 
[17:36:38.300]                           inherits = FALSE)) {
[17:36:38.300]                           master <- get("master", mode = "list", 
[17:36:38.300]                             envir = envir, inherits = FALSE)
[17:36:38.300]                           if (inherits(master, c("SOCKnode", 
[17:36:38.300]                             "SOCK0node"))) {
[17:36:38.300]                             sendCondition <<- function(cond) {
[17:36:38.300]                               data <- list(type = "VALUE", value = cond, 
[17:36:38.300]                                 success = TRUE)
[17:36:38.300]                               parallel_sendData(master, data)
[17:36:38.300]                             }
[17:36:38.300]                             return(sendCondition)
[17:36:38.300]                           }
[17:36:38.300]                         }
[17:36:38.300]                         frame <- frame + 1L
[17:36:38.300]                         envir <- sys.frame(frame)
[17:36:38.300]                       }
[17:36:38.300]                     }
[17:36:38.300]                     sendCondition <<- function(cond) NULL
[17:36:38.300]                   }
[17:36:38.300]                 })
[17:36:38.300]                 withCallingHandlers({
[17:36:38.300]                   {
[17:36:38.300]                     do.call(function(...) {
[17:36:38.300]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.300]                       if (!identical(...future.globals.maxSize.org, 
[17:36:38.300]                         ...future.globals.maxSize)) {
[17:36:38.300]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.300]                         on.exit(options(oopts), add = TRUE)
[17:36:38.300]                       }
[17:36:38.300]                       {
[17:36:38.300]                         lapply(seq_along(...future.elements_ii), 
[17:36:38.300]                           FUN = function(jj) {
[17:36:38.300]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.300]                             ...future.FUN(...future.X_jj, ...)
[17:36:38.300]                           })
[17:36:38.300]                       }
[17:36:38.300]                     }, args = future.call.arguments)
[17:36:38.300]                   }
[17:36:38.300]                 }, immediateCondition = function(cond) {
[17:36:38.300]                   sendCondition <- ...future.makeSendCondition()
[17:36:38.300]                   sendCondition(cond)
[17:36:38.300]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.300]                   {
[17:36:38.300]                     inherits <- base::inherits
[17:36:38.300]                     invokeRestart <- base::invokeRestart
[17:36:38.300]                     is.null <- base::is.null
[17:36:38.300]                     muffled <- FALSE
[17:36:38.300]                     if (inherits(cond, "message")) {
[17:36:38.300]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:38.300]                       if (muffled) 
[17:36:38.300]                         invokeRestart("muffleMessage")
[17:36:38.300]                     }
[17:36:38.300]                     else if (inherits(cond, "warning")) {
[17:36:38.300]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:38.300]                       if (muffled) 
[17:36:38.300]                         invokeRestart("muffleWarning")
[17:36:38.300]                     }
[17:36:38.300]                     else if (inherits(cond, "condition")) {
[17:36:38.300]                       if (!is.null(pattern)) {
[17:36:38.300]                         computeRestarts <- base::computeRestarts
[17:36:38.300]                         grepl <- base::grepl
[17:36:38.300]                         restarts <- computeRestarts(cond)
[17:36:38.300]                         for (restart in restarts) {
[17:36:38.300]                           name <- restart$name
[17:36:38.300]                           if (is.null(name)) 
[17:36:38.300]                             next
[17:36:38.300]                           if (!grepl(pattern, name)) 
[17:36:38.300]                             next
[17:36:38.300]                           invokeRestart(restart)
[17:36:38.300]                           muffled <- TRUE
[17:36:38.300]                           break
[17:36:38.300]                         }
[17:36:38.300]                       }
[17:36:38.300]                     }
[17:36:38.300]                     invisible(muffled)
[17:36:38.300]                   }
[17:36:38.300]                   muffleCondition(cond)
[17:36:38.300]                 })
[17:36:38.300]             }))
[17:36:38.300]             future::FutureResult(value = ...future.value$value, 
[17:36:38.300]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:38.300]                   ...future.rng), globalenv = if (FALSE) 
[17:36:38.300]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:38.300]                     ...future.globalenv.names))
[17:36:38.300]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:38.300]         }, condition = base::local({
[17:36:38.300]             c <- base::c
[17:36:38.300]             inherits <- base::inherits
[17:36:38.300]             invokeRestart <- base::invokeRestart
[17:36:38.300]             length <- base::length
[17:36:38.300]             list <- base::list
[17:36:38.300]             seq.int <- base::seq.int
[17:36:38.300]             signalCondition <- base::signalCondition
[17:36:38.300]             sys.calls <- base::sys.calls
[17:36:38.300]             `[[` <- base::`[[`
[17:36:38.300]             `+` <- base::`+`
[17:36:38.300]             `<<-` <- base::`<<-`
[17:36:38.300]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:38.300]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:38.300]                   3L)]
[17:36:38.300]             }
[17:36:38.300]             function(cond) {
[17:36:38.300]                 is_error <- inherits(cond, "error")
[17:36:38.300]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:38.300]                   NULL)
[17:36:38.300]                 if (is_error) {
[17:36:38.300]                   sessionInformation <- function() {
[17:36:38.300]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:38.300]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:38.300]                       search = base::search(), system = base::Sys.info())
[17:36:38.300]                   }
[17:36:38.300]                   ...future.conditions[[length(...future.conditions) + 
[17:36:38.300]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:38.300]                     cond$call), session = sessionInformation(), 
[17:36:38.300]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:38.300]                   signalCondition(cond)
[17:36:38.300]                 }
[17:36:38.300]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:38.300]                 "immediateCondition"))) {
[17:36:38.300]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:38.300]                   ...future.conditions[[length(...future.conditions) + 
[17:36:38.300]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:38.300]                   if (TRUE && !signal) {
[17:36:38.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.300]                     {
[17:36:38.300]                       inherits <- base::inherits
[17:36:38.300]                       invokeRestart <- base::invokeRestart
[17:36:38.300]                       is.null <- base::is.null
[17:36:38.300]                       muffled <- FALSE
[17:36:38.300]                       if (inherits(cond, "message")) {
[17:36:38.300]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:38.300]                         if (muffled) 
[17:36:38.300]                           invokeRestart("muffleMessage")
[17:36:38.300]                       }
[17:36:38.300]                       else if (inherits(cond, "warning")) {
[17:36:38.300]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:38.300]                         if (muffled) 
[17:36:38.300]                           invokeRestart("muffleWarning")
[17:36:38.300]                       }
[17:36:38.300]                       else if (inherits(cond, "condition")) {
[17:36:38.300]                         if (!is.null(pattern)) {
[17:36:38.300]                           computeRestarts <- base::computeRestarts
[17:36:38.300]                           grepl <- base::grepl
[17:36:38.300]                           restarts <- computeRestarts(cond)
[17:36:38.300]                           for (restart in restarts) {
[17:36:38.300]                             name <- restart$name
[17:36:38.300]                             if (is.null(name)) 
[17:36:38.300]                               next
[17:36:38.300]                             if (!grepl(pattern, name)) 
[17:36:38.300]                               next
[17:36:38.300]                             invokeRestart(restart)
[17:36:38.300]                             muffled <- TRUE
[17:36:38.300]                             break
[17:36:38.300]                           }
[17:36:38.300]                         }
[17:36:38.300]                       }
[17:36:38.300]                       invisible(muffled)
[17:36:38.300]                     }
[17:36:38.300]                     muffleCondition(cond, pattern = "^muffle")
[17:36:38.300]                   }
[17:36:38.300]                 }
[17:36:38.300]                 else {
[17:36:38.300]                   if (TRUE) {
[17:36:38.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.300]                     {
[17:36:38.300]                       inherits <- base::inherits
[17:36:38.300]                       invokeRestart <- base::invokeRestart
[17:36:38.300]                       is.null <- base::is.null
[17:36:38.300]                       muffled <- FALSE
[17:36:38.300]                       if (inherits(cond, "message")) {
[17:36:38.300]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:38.300]                         if (muffled) 
[17:36:38.300]                           invokeRestart("muffleMessage")
[17:36:38.300]                       }
[17:36:38.300]                       else if (inherits(cond, "warning")) {
[17:36:38.300]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:38.300]                         if (muffled) 
[17:36:38.300]                           invokeRestart("muffleWarning")
[17:36:38.300]                       }
[17:36:38.300]                       else if (inherits(cond, "condition")) {
[17:36:38.300]                         if (!is.null(pattern)) {
[17:36:38.300]                           computeRestarts <- base::computeRestarts
[17:36:38.300]                           grepl <- base::grepl
[17:36:38.300]                           restarts <- computeRestarts(cond)
[17:36:38.300]                           for (restart in restarts) {
[17:36:38.300]                             name <- restart$name
[17:36:38.300]                             if (is.null(name)) 
[17:36:38.300]                               next
[17:36:38.300]                             if (!grepl(pattern, name)) 
[17:36:38.300]                               next
[17:36:38.300]                             invokeRestart(restart)
[17:36:38.300]                             muffled <- TRUE
[17:36:38.300]                             break
[17:36:38.300]                           }
[17:36:38.300]                         }
[17:36:38.300]                       }
[17:36:38.300]                       invisible(muffled)
[17:36:38.300]                     }
[17:36:38.300]                     muffleCondition(cond, pattern = "^muffle")
[17:36:38.300]                   }
[17:36:38.300]                 }
[17:36:38.300]             }
[17:36:38.300]         }))
[17:36:38.300]     }, error = function(ex) {
[17:36:38.300]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:38.300]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:38.300]                 ...future.rng), started = ...future.startTime, 
[17:36:38.300]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:38.300]             version = "1.8"), class = "FutureResult")
[17:36:38.300]     }, finally = {
[17:36:38.300]         if (!identical(...future.workdir, getwd())) 
[17:36:38.300]             setwd(...future.workdir)
[17:36:38.300]         {
[17:36:38.300]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:38.300]                 ...future.oldOptions$nwarnings <- NULL
[17:36:38.300]             }
[17:36:38.300]             base::options(...future.oldOptions)
[17:36:38.300]             if (.Platform$OS.type == "windows") {
[17:36:38.300]                 old_names <- names(...future.oldEnvVars)
[17:36:38.300]                 envs <- base::Sys.getenv()
[17:36:38.300]                 names <- names(envs)
[17:36:38.300]                 common <- intersect(names, old_names)
[17:36:38.300]                 added <- setdiff(names, old_names)
[17:36:38.300]                 removed <- setdiff(old_names, names)
[17:36:38.300]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:38.300]                   envs[common]]
[17:36:38.300]                 NAMES <- toupper(changed)
[17:36:38.300]                 args <- list()
[17:36:38.300]                 for (kk in seq_along(NAMES)) {
[17:36:38.300]                   name <- changed[[kk]]
[17:36:38.300]                   NAME <- NAMES[[kk]]
[17:36:38.300]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.300]                     next
[17:36:38.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:38.300]                 }
[17:36:38.300]                 NAMES <- toupper(added)
[17:36:38.300]                 for (kk in seq_along(NAMES)) {
[17:36:38.300]                   name <- added[[kk]]
[17:36:38.300]                   NAME <- NAMES[[kk]]
[17:36:38.300]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.300]                     next
[17:36:38.300]                   args[[name]] <- ""
[17:36:38.300]                 }
[17:36:38.300]                 NAMES <- toupper(removed)
[17:36:38.300]                 for (kk in seq_along(NAMES)) {
[17:36:38.300]                   name <- removed[[kk]]
[17:36:38.300]                   NAME <- NAMES[[kk]]
[17:36:38.300]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.300]                     next
[17:36:38.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:38.300]                 }
[17:36:38.300]                 if (length(args) > 0) 
[17:36:38.300]                   base::do.call(base::Sys.setenv, args = args)
[17:36:38.300]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:38.300]             }
[17:36:38.300]             else {
[17:36:38.300]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:38.300]             }
[17:36:38.300]             {
[17:36:38.300]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:38.300]                   0L) {
[17:36:38.300]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:38.300]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:38.300]                   base::options(opts)
[17:36:38.300]                 }
[17:36:38.300]                 {
[17:36:38.300]                   {
[17:36:38.300]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:38.300]                     NULL
[17:36:38.300]                   }
[17:36:38.300]                   options(future.plan = NULL)
[17:36:38.300]                   if (is.na(NA_character_)) 
[17:36:38.300]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:38.300]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:38.300]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:38.300]                     .init = FALSE)
[17:36:38.300]                 }
[17:36:38.300]             }
[17:36:38.300]         }
[17:36:38.300]     })
[17:36:38.300]     if (TRUE) {
[17:36:38.300]         base::sink(type = "output", split = FALSE)
[17:36:38.300]         if (TRUE) {
[17:36:38.300]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:38.300]         }
[17:36:38.300]         else {
[17:36:38.300]             ...future.result["stdout"] <- base::list(NULL)
[17:36:38.300]         }
[17:36:38.300]         base::close(...future.stdout)
[17:36:38.300]         ...future.stdout <- NULL
[17:36:38.300]     }
[17:36:38.300]     ...future.result$conditions <- ...future.conditions
[17:36:38.300]     ...future.result$finished <- base::Sys.time()
[17:36:38.300]     ...future.result
[17:36:38.300] }
[17:36:38.303] Exporting 5 global objects (960 bytes) to cluster node #2 ...
[17:36:38.303] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:36:38.304] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:36:38.304] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[17:36:38.304] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[17:36:38.304] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:36:38.304] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:36:38.305] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:36:38.305] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:36:38.305] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:36:38.305] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:36:38.305] Exporting 5 global objects (960 bytes) to cluster node #2 ... DONE
[17:36:38.306] MultisessionFuture started
[17:36:38.306] - Launch lazy future ... done
[17:36:38.306] run() for ‘MultisessionFuture’ ... done
[17:36:38.306] Created future:
[17:36:38.306] MultisessionFuture:
[17:36:38.306] Label: ‘future_apply-2’
[17:36:38.306] Expression:
[17:36:38.306] {
[17:36:38.306]     do.call(function(...) {
[17:36:38.306]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.306]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:38.306]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.306]             on.exit(options(oopts), add = TRUE)
[17:36:38.306]         }
[17:36:38.306]         {
[17:36:38.306]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:38.306]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.306]                 ...future.FUN(...future.X_jj, ...)
[17:36:38.306]             })
[17:36:38.306]         }
[17:36:38.306]     }, args = future.call.arguments)
[17:36:38.306] }
[17:36:38.306] Lazy evaluation: FALSE
[17:36:38.306] Asynchronous evaluation: TRUE
[17:36:38.306] Local evaluation: TRUE
[17:36:38.306] Environment: R_GlobalEnv
[17:36:38.306] Capture standard output: TRUE
[17:36:38.306] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:38.306] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:38.306] Packages: <none>
[17:36:38.306] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:38.306] Resolved: FALSE
[17:36:38.306] Value: <not collected>
[17:36:38.306] Conditions captured: <none>
[17:36:38.306] Early signaling: FALSE
[17:36:38.306] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:38.306] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.318] Chunk #2 of 2 ... DONE
[17:36:38.318] Launching 2 futures (chunks) ... DONE
[17:36:38.318] Resolving 2 futures (chunks) ...
[17:36:38.318] resolve() on list ...
[17:36:38.318]  recursive: 0
[17:36:38.318]  length: 2
[17:36:38.318] 
[17:36:38.319] receiveMessageFromWorker() for ClusterFuture ...
[17:36:38.319] - Validating connection of MultisessionFuture
[17:36:38.319] - received message: FutureResult
[17:36:38.319] - Received FutureResult
[17:36:38.319] - Erased future from FutureRegistry
[17:36:38.319] result() for ClusterFuture ...
[17:36:38.319] - result already collected: FutureResult
[17:36:38.319] result() for ClusterFuture ... done
[17:36:38.320] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:38.320] Future #1
[17:36:38.320] result() for ClusterFuture ...
[17:36:38.320] - result already collected: FutureResult
[17:36:38.320] result() for ClusterFuture ... done
[17:36:38.320] result() for ClusterFuture ...
[17:36:38.320] - result already collected: FutureResult
[17:36:38.320] result() for ClusterFuture ... done
[17:36:38.320] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:36:38.320] - nx: 2
[17:36:38.321] - relay: TRUE
[17:36:38.321] - stdout: TRUE
[17:36:38.321] - signal: TRUE
[17:36:38.321] - resignal: FALSE
[17:36:38.321] - force: TRUE
[17:36:38.321] - relayed: [n=2] FALSE, FALSE
[17:36:38.321] - queued futures: [n=2] FALSE, FALSE
[17:36:38.321]  - until=1
[17:36:38.321]  - relaying element #1
[17:36:38.321] result() for ClusterFuture ...
[17:36:38.321] - result already collected: FutureResult
[17:36:38.321] result() for ClusterFuture ... done
[17:36:38.322] result() for ClusterFuture ...
[17:36:38.322] - result already collected: FutureResult
[17:36:38.322] result() for ClusterFuture ... done
[17:36:38.322] result() for ClusterFuture ...
[17:36:38.322] - result already collected: FutureResult
[17:36:38.322] result() for ClusterFuture ... done
[17:36:38.322] result() for ClusterFuture ...
[17:36:38.322] - result already collected: FutureResult
[17:36:38.322] result() for ClusterFuture ... done
[17:36:38.322] - relayed: [n=2] TRUE, FALSE
[17:36:38.322] - queued futures: [n=2] TRUE, FALSE
[17:36:38.322] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:36:38.323]  length: 1 (resolved future 1)
[17:36:38.350] receiveMessageFromWorker() for ClusterFuture ...
[17:36:38.350] - Validating connection of MultisessionFuture
[17:36:38.350] - received message: FutureResult
[17:36:38.350] - Received FutureResult
[17:36:38.350] - Erased future from FutureRegistry
[17:36:38.351] result() for ClusterFuture ...
[17:36:38.351] - result already collected: FutureResult
[17:36:38.351] result() for ClusterFuture ... done
[17:36:38.351] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:38.351] Future #2
[17:36:38.351] result() for ClusterFuture ...
[17:36:38.351] - result already collected: FutureResult
[17:36:38.351] result() for ClusterFuture ... done
[17:36:38.351] result() for ClusterFuture ...
[17:36:38.351] - result already collected: FutureResult
[17:36:38.351] result() for ClusterFuture ... done
[17:36:38.351] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:36:38.352] - nx: 2
[17:36:38.352] - relay: TRUE
[17:36:38.352] - stdout: TRUE
[17:36:38.352] - signal: TRUE
[17:36:38.352] - resignal: FALSE
[17:36:38.352] - force: TRUE
[17:36:38.352] - relayed: [n=2] TRUE, FALSE
[17:36:38.352] - queued futures: [n=2] TRUE, FALSE
[17:36:38.352]  - until=2
[17:36:38.352]  - relaying element #2
[17:36:38.352] result() for ClusterFuture ...
[17:36:38.353] - result already collected: FutureResult
[17:36:38.353] result() for ClusterFuture ... done
[17:36:38.353] result() for ClusterFuture ...
[17:36:38.353] - result already collected: FutureResult
[17:36:38.353] result() for ClusterFuture ... done
[17:36:38.353] result() for ClusterFuture ...
[17:36:38.353] - result already collected: FutureResult
[17:36:38.353] result() for ClusterFuture ... done
[17:36:38.353] result() for ClusterFuture ...
[17:36:38.353] - result already collected: FutureResult
[17:36:38.353] result() for ClusterFuture ... done
[17:36:38.354] - relayed: [n=2] TRUE, TRUE
[17:36:38.354] - queued futures: [n=2] TRUE, TRUE
[17:36:38.354] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:36:38.354]  length: 0 (resolved future 2)
[17:36:38.354] Relaying remaining futures
[17:36:38.354] signalConditionsASAP(NULL, pos=0) ...
[17:36:38.354] - nx: 2
[17:36:38.354] - relay: TRUE
[17:36:38.354] - stdout: TRUE
[17:36:38.354] - signal: TRUE
[17:36:38.354] - resignal: FALSE
[17:36:38.354] - force: TRUE
[17:36:38.355] - relayed: [n=2] TRUE, TRUE
[17:36:38.355] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:38.355] - relayed: [n=2] TRUE, TRUE
[17:36:38.355] - queued futures: [n=2] TRUE, TRUE
[17:36:38.355] signalConditionsASAP(NULL, pos=0) ... done
[17:36:38.355] resolve() on list ... DONE
[17:36:38.355] result() for ClusterFuture ...
[17:36:38.355] - result already collected: FutureResult
[17:36:38.355] result() for ClusterFuture ... done
[17:36:38.355] result() for ClusterFuture ...
[17:36:38.356] - result already collected: FutureResult
[17:36:38.356] result() for ClusterFuture ... done
[17:36:38.356] result() for ClusterFuture ...
[17:36:38.356] - result already collected: FutureResult
[17:36:38.356] result() for ClusterFuture ... done
[17:36:38.356] result() for ClusterFuture ...
[17:36:38.356] - result already collected: FutureResult
[17:36:38.356] result() for ClusterFuture ... done
[17:36:38.356]  - Number of value chunks collected: 2
[17:36:38.356] Resolving 2 futures (chunks) ... DONE
[17:36:38.356] Reducing values from 2 chunks ...
[17:36:38.357]  - Number of values collected after concatenation: 2
[17:36:38.357]  - Number of values expected: 2
[17:36:38.357] Reducing values from 2 chunks ... DONE
[17:36:38.357] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[17:36:38.357] getGlobalsAndPackagesXApply() ...
[17:36:38.357]  - future.globals: TRUE
[17:36:38.357] getGlobalsAndPackages() ...
[17:36:38.357] Searching for globals...
[17:36:38.358] - globals found: [1] ‘FUN’
[17:36:38.359] Searching for globals ... DONE
[17:36:38.359] Resolving globals: FALSE
[17:36:38.359] The total size of the 1 globals is 848 bytes (848 bytes)
[17:36:38.359] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:36:38.359] - globals: [1] ‘FUN’
[17:36:38.359] 
[17:36:38.360] getGlobalsAndPackages() ... DONE
[17:36:38.360]  - globals found/used: [n=1] ‘FUN’
[17:36:38.360]  - needed namespaces: [n=0] 
[17:36:38.360] Finding globals ... DONE
[17:36:38.360]  - use_args: TRUE
[17:36:38.360]  - Getting '...' globals ...
[17:36:38.360] resolve() on list ...
[17:36:38.360]  recursive: 0
[17:36:38.361]  length: 1
[17:36:38.361]  elements: ‘...’
[17:36:38.361]  length: 0 (resolved future 1)
[17:36:38.361] resolve() on list ... DONE
[17:36:38.361]    - '...' content: [n=0] 
[17:36:38.361] List of 1
[17:36:38.361]  $ ...: list()
[17:36:38.361]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:38.361]  - attr(*, "where")=List of 1
[17:36:38.361]   ..$ ...:<environment: 0x556d77299838> 
[17:36:38.361]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:38.361]  - attr(*, "resolved")= logi TRUE
[17:36:38.361]  - attr(*, "total_size")= num NA
[17:36:38.363]  - Getting '...' globals ... DONE
[17:36:38.364] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:38.364] List of 2
[17:36:38.364]  $ ...future.FUN:function (x)  
[17:36:38.364]  $ ...          : list()
[17:36:38.364]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:38.364]  - attr(*, "where")=List of 2
[17:36:38.364]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:38.364]   ..$ ...          :<environment: 0x556d77299838> 
[17:36:38.364]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:38.364]  - attr(*, "resolved")= logi FALSE
[17:36:38.364]  - attr(*, "total_size")= num 848
[17:36:38.366] Packages to be attached in all futures: [n=0] 
[17:36:38.366] getGlobalsAndPackagesXApply() ... DONE
[17:36:38.370] future_lapply() ...
[17:36:38.374] Number of chunks: 2
[17:36:38.374] getGlobalsAndPackagesXApply() ...
[17:36:38.374]  - future.globals: <name-value list> with names ‘list()’
[17:36:38.374]  - use_args: TRUE
[17:36:38.374] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:38.374] List of 2
[17:36:38.374]  $ ...          : list()
[17:36:38.374]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:38.374]  $ ...future.FUN:function (x)  
[17:36:38.374]  - attr(*, "where")=List of 2
[17:36:38.374]   ..$ ...          :<environment: 0x556d77299838> 
[17:36:38.374]   ..$ ...future.FUN:<environment: namespace:base> 
[17:36:38.374]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:38.374]  - attr(*, "resolved")= logi FALSE
[17:36:38.374]  - attr(*, "total_size")= num NA
[17:36:38.378] Packages to be attached in all futures: [n=0] 
[17:36:38.378] getGlobalsAndPackagesXApply() ... DONE
[17:36:38.378] Number of futures (= number of chunks): 2
[17:36:38.378] Launching 2 futures (chunks) ...
[17:36:38.378] Chunk #1 of 2 ...
[17:36:38.378]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:38.378]  - seeds: <none>
[17:36:38.378]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.378] getGlobalsAndPackages() ...
[17:36:38.379] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.379] Resolving globals: FALSE
[17:36:38.379] Tweak future expression to call with '...' arguments ...
[17:36:38.379] {
[17:36:38.379]     do.call(function(...) {
[17:36:38.379]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.379]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:38.379]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.379]             on.exit(options(oopts), add = TRUE)
[17:36:38.379]         }
[17:36:38.379]         {
[17:36:38.379]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:38.379]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.379]                 ...future.FUN(...future.X_jj, ...)
[17:36:38.379]             })
[17:36:38.379]         }
[17:36:38.379]     }, args = future.call.arguments)
[17:36:38.379] }
[17:36:38.379] Tweak future expression to call with '...' arguments ... DONE
[17:36:38.380] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.380] 
[17:36:38.380] getGlobalsAndPackages() ... DONE
[17:36:38.380] run() for ‘Future’ ...
[17:36:38.380] - state: ‘created’
[17:36:38.380] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:38.394] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.394] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:38.394]   - Field: ‘node’
[17:36:38.394]   - Field: ‘label’
[17:36:38.394]   - Field: ‘local’
[17:36:38.394]   - Field: ‘owner’
[17:36:38.394]   - Field: ‘envir’
[17:36:38.397]   - Field: ‘workers’
[17:36:38.397]   - Field: ‘packages’
[17:36:38.397]   - Field: ‘gc’
[17:36:38.397]   - Field: ‘conditions’
[17:36:38.397]   - Field: ‘persistent’
[17:36:38.397]   - Field: ‘expr’
[17:36:38.397]   - Field: ‘uuid’
[17:36:38.397]   - Field: ‘seed’
[17:36:38.397]   - Field: ‘version’
[17:36:38.397]   - Field: ‘result’
[17:36:38.398]   - Field: ‘asynchronous’
[17:36:38.398]   - Field: ‘calls’
[17:36:38.398]   - Field: ‘globals’
[17:36:38.398]   - Field: ‘stdout’
[17:36:38.398]   - Field: ‘earlySignal’
[17:36:38.398]   - Field: ‘lazy’
[17:36:38.398]   - Field: ‘state’
[17:36:38.398] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:38.398] - Launch lazy future ...
[17:36:38.399] Packages needed by the future expression (n = 0): <none>
[17:36:38.399] Packages needed by future strategies (n = 0): <none>
[17:36:38.399] {
[17:36:38.399]     {
[17:36:38.399]         {
[17:36:38.399]             ...future.startTime <- base::Sys.time()
[17:36:38.399]             {
[17:36:38.399]                 {
[17:36:38.399]                   {
[17:36:38.399]                     {
[17:36:38.399]                       base::local({
[17:36:38.399]                         has_future <- base::requireNamespace("future", 
[17:36:38.399]                           quietly = TRUE)
[17:36:38.399]                         if (has_future) {
[17:36:38.399]                           ns <- base::getNamespace("future")
[17:36:38.399]                           version <- ns[[".package"]][["version"]]
[17:36:38.399]                           if (is.null(version)) 
[17:36:38.399]                             version <- utils::packageVersion("future")
[17:36:38.399]                         }
[17:36:38.399]                         else {
[17:36:38.399]                           version <- NULL
[17:36:38.399]                         }
[17:36:38.399]                         if (!has_future || version < "1.8.0") {
[17:36:38.399]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:38.399]                             "", base::R.version$version.string), 
[17:36:38.399]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:38.399]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:38.399]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:38.399]                               "release", "version")], collapse = " "), 
[17:36:38.399]                             hostname = base::Sys.info()[["nodename"]])
[17:36:38.399]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:38.399]                             info)
[17:36:38.399]                           info <- base::paste(info, collapse = "; ")
[17:36:38.399]                           if (!has_future) {
[17:36:38.399]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:38.399]                               info)
[17:36:38.399]                           }
[17:36:38.399]                           else {
[17:36:38.399]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:38.399]                               info, version)
[17:36:38.399]                           }
[17:36:38.399]                           base::stop(msg)
[17:36:38.399]                         }
[17:36:38.399]                       })
[17:36:38.399]                     }
[17:36:38.399]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:38.399]                     base::options(mc.cores = 1L)
[17:36:38.399]                   }
[17:36:38.399]                   ...future.strategy.old <- future::plan("list")
[17:36:38.399]                   options(future.plan = NULL)
[17:36:38.399]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:38.399]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:38.399]                 }
[17:36:38.399]                 ...future.workdir <- getwd()
[17:36:38.399]             }
[17:36:38.399]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:38.399]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:38.399]         }
[17:36:38.399]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:38.399]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:38.399]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:38.399]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:38.399]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:38.399]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:38.399]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:38.399]             base::names(...future.oldOptions))
[17:36:38.399]     }
[17:36:38.399]     if (FALSE) {
[17:36:38.399]     }
[17:36:38.399]     else {
[17:36:38.399]         if (TRUE) {
[17:36:38.399]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:38.399]                 open = "w")
[17:36:38.399]         }
[17:36:38.399]         else {
[17:36:38.399]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:38.399]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:38.399]         }
[17:36:38.399]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:38.399]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:38.399]             base::sink(type = "output", split = FALSE)
[17:36:38.399]             base::close(...future.stdout)
[17:36:38.399]         }, add = TRUE)
[17:36:38.399]     }
[17:36:38.399]     ...future.frame <- base::sys.nframe()
[17:36:38.399]     ...future.conditions <- base::list()
[17:36:38.399]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:38.399]     if (FALSE) {
[17:36:38.399]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:38.399]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:38.399]     }
[17:36:38.399]     ...future.result <- base::tryCatch({
[17:36:38.399]         base::withCallingHandlers({
[17:36:38.399]             ...future.value <- base::withVisible(base::local({
[17:36:38.399]                 ...future.makeSendCondition <- base::local({
[17:36:38.399]                   sendCondition <- NULL
[17:36:38.399]                   function(frame = 1L) {
[17:36:38.399]                     if (is.function(sendCondition)) 
[17:36:38.399]                       return(sendCondition)
[17:36:38.399]                     ns <- getNamespace("parallel")
[17:36:38.399]                     if (exists("sendData", mode = "function", 
[17:36:38.399]                       envir = ns)) {
[17:36:38.399]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:38.399]                         envir = ns)
[17:36:38.399]                       envir <- sys.frame(frame)
[17:36:38.399]                       master <- NULL
[17:36:38.399]                       while (!identical(envir, .GlobalEnv) && 
[17:36:38.399]                         !identical(envir, emptyenv())) {
[17:36:38.399]                         if (exists("master", mode = "list", envir = envir, 
[17:36:38.399]                           inherits = FALSE)) {
[17:36:38.399]                           master <- get("master", mode = "list", 
[17:36:38.399]                             envir = envir, inherits = FALSE)
[17:36:38.399]                           if (inherits(master, c("SOCKnode", 
[17:36:38.399]                             "SOCK0node"))) {
[17:36:38.399]                             sendCondition <<- function(cond) {
[17:36:38.399]                               data <- list(type = "VALUE", value = cond, 
[17:36:38.399]                                 success = TRUE)
[17:36:38.399]                               parallel_sendData(master, data)
[17:36:38.399]                             }
[17:36:38.399]                             return(sendCondition)
[17:36:38.399]                           }
[17:36:38.399]                         }
[17:36:38.399]                         frame <- frame + 1L
[17:36:38.399]                         envir <- sys.frame(frame)
[17:36:38.399]                       }
[17:36:38.399]                     }
[17:36:38.399]                     sendCondition <<- function(cond) NULL
[17:36:38.399]                   }
[17:36:38.399]                 })
[17:36:38.399]                 withCallingHandlers({
[17:36:38.399]                   {
[17:36:38.399]                     do.call(function(...) {
[17:36:38.399]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.399]                       if (!identical(...future.globals.maxSize.org, 
[17:36:38.399]                         ...future.globals.maxSize)) {
[17:36:38.399]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.399]                         on.exit(options(oopts), add = TRUE)
[17:36:38.399]                       }
[17:36:38.399]                       {
[17:36:38.399]                         lapply(seq_along(...future.elements_ii), 
[17:36:38.399]                           FUN = function(jj) {
[17:36:38.399]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.399]                             ...future.FUN(...future.X_jj, ...)
[17:36:38.399]                           })
[17:36:38.399]                       }
[17:36:38.399]                     }, args = future.call.arguments)
[17:36:38.399]                   }
[17:36:38.399]                 }, immediateCondition = function(cond) {
[17:36:38.399]                   sendCondition <- ...future.makeSendCondition()
[17:36:38.399]                   sendCondition(cond)
[17:36:38.399]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.399]                   {
[17:36:38.399]                     inherits <- base::inherits
[17:36:38.399]                     invokeRestart <- base::invokeRestart
[17:36:38.399]                     is.null <- base::is.null
[17:36:38.399]                     muffled <- FALSE
[17:36:38.399]                     if (inherits(cond, "message")) {
[17:36:38.399]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:38.399]                       if (muffled) 
[17:36:38.399]                         invokeRestart("muffleMessage")
[17:36:38.399]                     }
[17:36:38.399]                     else if (inherits(cond, "warning")) {
[17:36:38.399]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:38.399]                       if (muffled) 
[17:36:38.399]                         invokeRestart("muffleWarning")
[17:36:38.399]                     }
[17:36:38.399]                     else if (inherits(cond, "condition")) {
[17:36:38.399]                       if (!is.null(pattern)) {
[17:36:38.399]                         computeRestarts <- base::computeRestarts
[17:36:38.399]                         grepl <- base::grepl
[17:36:38.399]                         restarts <- computeRestarts(cond)
[17:36:38.399]                         for (restart in restarts) {
[17:36:38.399]                           name <- restart$name
[17:36:38.399]                           if (is.null(name)) 
[17:36:38.399]                             next
[17:36:38.399]                           if (!grepl(pattern, name)) 
[17:36:38.399]                             next
[17:36:38.399]                           invokeRestart(restart)
[17:36:38.399]                           muffled <- TRUE
[17:36:38.399]                           break
[17:36:38.399]                         }
[17:36:38.399]                       }
[17:36:38.399]                     }
[17:36:38.399]                     invisible(muffled)
[17:36:38.399]                   }
[17:36:38.399]                   muffleCondition(cond)
[17:36:38.399]                 })
[17:36:38.399]             }))
[17:36:38.399]             future::FutureResult(value = ...future.value$value, 
[17:36:38.399]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:38.399]                   ...future.rng), globalenv = if (FALSE) 
[17:36:38.399]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:38.399]                     ...future.globalenv.names))
[17:36:38.399]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:38.399]         }, condition = base::local({
[17:36:38.399]             c <- base::c
[17:36:38.399]             inherits <- base::inherits
[17:36:38.399]             invokeRestart <- base::invokeRestart
[17:36:38.399]             length <- base::length
[17:36:38.399]             list <- base::list
[17:36:38.399]             seq.int <- base::seq.int
[17:36:38.399]             signalCondition <- base::signalCondition
[17:36:38.399]             sys.calls <- base::sys.calls
[17:36:38.399]             `[[` <- base::`[[`
[17:36:38.399]             `+` <- base::`+`
[17:36:38.399]             `<<-` <- base::`<<-`
[17:36:38.399]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:38.399]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:38.399]                   3L)]
[17:36:38.399]             }
[17:36:38.399]             function(cond) {
[17:36:38.399]                 is_error <- inherits(cond, "error")
[17:36:38.399]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:38.399]                   NULL)
[17:36:38.399]                 if (is_error) {
[17:36:38.399]                   sessionInformation <- function() {
[17:36:38.399]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:38.399]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:38.399]                       search = base::search(), system = base::Sys.info())
[17:36:38.399]                   }
[17:36:38.399]                   ...future.conditions[[length(...future.conditions) + 
[17:36:38.399]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:38.399]                     cond$call), session = sessionInformation(), 
[17:36:38.399]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:38.399]                   signalCondition(cond)
[17:36:38.399]                 }
[17:36:38.399]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:38.399]                 "immediateCondition"))) {
[17:36:38.399]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:38.399]                   ...future.conditions[[length(...future.conditions) + 
[17:36:38.399]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:38.399]                   if (TRUE && !signal) {
[17:36:38.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.399]                     {
[17:36:38.399]                       inherits <- base::inherits
[17:36:38.399]                       invokeRestart <- base::invokeRestart
[17:36:38.399]                       is.null <- base::is.null
[17:36:38.399]                       muffled <- FALSE
[17:36:38.399]                       if (inherits(cond, "message")) {
[17:36:38.399]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:38.399]                         if (muffled) 
[17:36:38.399]                           invokeRestart("muffleMessage")
[17:36:38.399]                       }
[17:36:38.399]                       else if (inherits(cond, "warning")) {
[17:36:38.399]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:38.399]                         if (muffled) 
[17:36:38.399]                           invokeRestart("muffleWarning")
[17:36:38.399]                       }
[17:36:38.399]                       else if (inherits(cond, "condition")) {
[17:36:38.399]                         if (!is.null(pattern)) {
[17:36:38.399]                           computeRestarts <- base::computeRestarts
[17:36:38.399]                           grepl <- base::grepl
[17:36:38.399]                           restarts <- computeRestarts(cond)
[17:36:38.399]                           for (restart in restarts) {
[17:36:38.399]                             name <- restart$name
[17:36:38.399]                             if (is.null(name)) 
[17:36:38.399]                               next
[17:36:38.399]                             if (!grepl(pattern, name)) 
[17:36:38.399]                               next
[17:36:38.399]                             invokeRestart(restart)
[17:36:38.399]                             muffled <- TRUE
[17:36:38.399]                             break
[17:36:38.399]                           }
[17:36:38.399]                         }
[17:36:38.399]                       }
[17:36:38.399]                       invisible(muffled)
[17:36:38.399]                     }
[17:36:38.399]                     muffleCondition(cond, pattern = "^muffle")
[17:36:38.399]                   }
[17:36:38.399]                 }
[17:36:38.399]                 else {
[17:36:38.399]                   if (TRUE) {
[17:36:38.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.399]                     {
[17:36:38.399]                       inherits <- base::inherits
[17:36:38.399]                       invokeRestart <- base::invokeRestart
[17:36:38.399]                       is.null <- base::is.null
[17:36:38.399]                       muffled <- FALSE
[17:36:38.399]                       if (inherits(cond, "message")) {
[17:36:38.399]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:38.399]                         if (muffled) 
[17:36:38.399]                           invokeRestart("muffleMessage")
[17:36:38.399]                       }
[17:36:38.399]                       else if (inherits(cond, "warning")) {
[17:36:38.399]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:38.399]                         if (muffled) 
[17:36:38.399]                           invokeRestart("muffleWarning")
[17:36:38.399]                       }
[17:36:38.399]                       else if (inherits(cond, "condition")) {
[17:36:38.399]                         if (!is.null(pattern)) {
[17:36:38.399]                           computeRestarts <- base::computeRestarts
[17:36:38.399]                           grepl <- base::grepl
[17:36:38.399]                           restarts <- computeRestarts(cond)
[17:36:38.399]                           for (restart in restarts) {
[17:36:38.399]                             name <- restart$name
[17:36:38.399]                             if (is.null(name)) 
[17:36:38.399]                               next
[17:36:38.399]                             if (!grepl(pattern, name)) 
[17:36:38.399]                               next
[17:36:38.399]                             invokeRestart(restart)
[17:36:38.399]                             muffled <- TRUE
[17:36:38.399]                             break
[17:36:38.399]                           }
[17:36:38.399]                         }
[17:36:38.399]                       }
[17:36:38.399]                       invisible(muffled)
[17:36:38.399]                     }
[17:36:38.399]                     muffleCondition(cond, pattern = "^muffle")
[17:36:38.399]                   }
[17:36:38.399]                 }
[17:36:38.399]             }
[17:36:38.399]         }))
[17:36:38.399]     }, error = function(ex) {
[17:36:38.399]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:38.399]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:38.399]                 ...future.rng), started = ...future.startTime, 
[17:36:38.399]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:38.399]             version = "1.8"), class = "FutureResult")
[17:36:38.399]     }, finally = {
[17:36:38.399]         if (!identical(...future.workdir, getwd())) 
[17:36:38.399]             setwd(...future.workdir)
[17:36:38.399]         {
[17:36:38.399]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:38.399]                 ...future.oldOptions$nwarnings <- NULL
[17:36:38.399]             }
[17:36:38.399]             base::options(...future.oldOptions)
[17:36:38.399]             if (.Platform$OS.type == "windows") {
[17:36:38.399]                 old_names <- names(...future.oldEnvVars)
[17:36:38.399]                 envs <- base::Sys.getenv()
[17:36:38.399]                 names <- names(envs)
[17:36:38.399]                 common <- intersect(names, old_names)
[17:36:38.399]                 added <- setdiff(names, old_names)
[17:36:38.399]                 removed <- setdiff(old_names, names)
[17:36:38.399]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:38.399]                   envs[common]]
[17:36:38.399]                 NAMES <- toupper(changed)
[17:36:38.399]                 args <- list()
[17:36:38.399]                 for (kk in seq_along(NAMES)) {
[17:36:38.399]                   name <- changed[[kk]]
[17:36:38.399]                   NAME <- NAMES[[kk]]
[17:36:38.399]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.399]                     next
[17:36:38.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:38.399]                 }
[17:36:38.399]                 NAMES <- toupper(added)
[17:36:38.399]                 for (kk in seq_along(NAMES)) {
[17:36:38.399]                   name <- added[[kk]]
[17:36:38.399]                   NAME <- NAMES[[kk]]
[17:36:38.399]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.399]                     next
[17:36:38.399]                   args[[name]] <- ""
[17:36:38.399]                 }
[17:36:38.399]                 NAMES <- toupper(removed)
[17:36:38.399]                 for (kk in seq_along(NAMES)) {
[17:36:38.399]                   name <- removed[[kk]]
[17:36:38.399]                   NAME <- NAMES[[kk]]
[17:36:38.399]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.399]                     next
[17:36:38.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:38.399]                 }
[17:36:38.399]                 if (length(args) > 0) 
[17:36:38.399]                   base::do.call(base::Sys.setenv, args = args)
[17:36:38.399]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:38.399]             }
[17:36:38.399]             else {
[17:36:38.399]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:38.399]             }
[17:36:38.399]             {
[17:36:38.399]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:38.399]                   0L) {
[17:36:38.399]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:38.399]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:38.399]                   base::options(opts)
[17:36:38.399]                 }
[17:36:38.399]                 {
[17:36:38.399]                   {
[17:36:38.399]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:38.399]                     NULL
[17:36:38.399]                   }
[17:36:38.399]                   options(future.plan = NULL)
[17:36:38.399]                   if (is.na(NA_character_)) 
[17:36:38.399]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:38.399]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:38.399]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:38.399]                     .init = FALSE)
[17:36:38.399]                 }
[17:36:38.399]             }
[17:36:38.399]         }
[17:36:38.399]     })
[17:36:38.399]     if (TRUE) {
[17:36:38.399]         base::sink(type = "output", split = FALSE)
[17:36:38.399]         if (TRUE) {
[17:36:38.399]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:38.399]         }
[17:36:38.399]         else {
[17:36:38.399]             ...future.result["stdout"] <- base::list(NULL)
[17:36:38.399]         }
[17:36:38.399]         base::close(...future.stdout)
[17:36:38.399]         ...future.stdout <- NULL
[17:36:38.399]     }
[17:36:38.399]     ...future.result$conditions <- ...future.conditions
[17:36:38.399]     ...future.result$finished <- base::Sys.time()
[17:36:38.399]     ...future.result
[17:36:38.399] }
[17:36:38.402] Exporting 5 global objects (1.12 KiB) to cluster node #1 ...
[17:36:38.402] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:36:38.403] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:36:38.403] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:36:38.403] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:36:38.403] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ...
[17:36:38.403] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ... DONE
[17:36:38.404] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:36:38.404] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:36:38.404] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:36:38.404] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:36:38.404] Exporting 5 global objects (1.12 KiB) to cluster node #1 ... DONE
[17:36:38.405] MultisessionFuture started
[17:36:38.405] - Launch lazy future ... done
[17:36:38.405] run() for ‘MultisessionFuture’ ... done
[17:36:38.405] Created future:
[17:36:38.405] MultisessionFuture:
[17:36:38.405] Label: ‘future_apply-1’
[17:36:38.405] Expression:
[17:36:38.405] {
[17:36:38.405]     do.call(function(...) {
[17:36:38.405]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.405]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:38.405]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.405]             on.exit(options(oopts), add = TRUE)
[17:36:38.405]         }
[17:36:38.405]         {
[17:36:38.405]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:38.405]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.405]                 ...future.FUN(...future.X_jj, ...)
[17:36:38.405]             })
[17:36:38.405]         }
[17:36:38.405]     }, args = future.call.arguments)
[17:36:38.405] }
[17:36:38.405] Lazy evaluation: FALSE
[17:36:38.405] Asynchronous evaluation: TRUE
[17:36:38.405] Local evaluation: TRUE
[17:36:38.405] Environment: R_GlobalEnv
[17:36:38.405] Capture standard output: TRUE
[17:36:38.405] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:38.405] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:38.405] Packages: <none>
[17:36:38.405] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:38.405] Resolved: FALSE
[17:36:38.405] Value: <not collected>
[17:36:38.405] Conditions captured: <none>
[17:36:38.405] Early signaling: FALSE
[17:36:38.405] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:38.405] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.417] Chunk #1 of 2 ... DONE
[17:36:38.417] Chunk #2 of 2 ...
[17:36:38.417]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:38.417]  - seeds: <none>
[17:36:38.417]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.417] getGlobalsAndPackages() ...
[17:36:38.418] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.418] Resolving globals: FALSE
[17:36:38.418] Tweak future expression to call with '...' arguments ...
[17:36:38.418] {
[17:36:38.418]     do.call(function(...) {
[17:36:38.418]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.418]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:38.418]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.418]             on.exit(options(oopts), add = TRUE)
[17:36:38.418]         }
[17:36:38.418]         {
[17:36:38.418]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:38.418]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.418]                 ...future.FUN(...future.X_jj, ...)
[17:36:38.418]             })
[17:36:38.418]         }
[17:36:38.418]     }, args = future.call.arguments)
[17:36:38.418] }
[17:36:38.418] Tweak future expression to call with '...' arguments ... DONE
[17:36:38.419] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.419] 
[17:36:38.419] getGlobalsAndPackages() ... DONE
[17:36:38.419] run() for ‘Future’ ...
[17:36:38.419] - state: ‘created’
[17:36:38.419] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:38.433] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.433] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:38.434]   - Field: ‘node’
[17:36:38.434]   - Field: ‘label’
[17:36:38.434]   - Field: ‘local’
[17:36:38.434]   - Field: ‘owner’
[17:36:38.434]   - Field: ‘envir’
[17:36:38.434]   - Field: ‘workers’
[17:36:38.434]   - Field: ‘packages’
[17:36:38.434]   - Field: ‘gc’
[17:36:38.434]   - Field: ‘conditions’
[17:36:38.434]   - Field: ‘persistent’
[17:36:38.434]   - Field: ‘expr’
[17:36:38.435]   - Field: ‘uuid’
[17:36:38.435]   - Field: ‘seed’
[17:36:38.435]   - Field: ‘version’
[17:36:38.435]   - Field: ‘result’
[17:36:38.435]   - Field: ‘asynchronous’
[17:36:38.435]   - Field: ‘calls’
[17:36:38.435]   - Field: ‘globals’
[17:36:38.435]   - Field: ‘stdout’
[17:36:38.435]   - Field: ‘earlySignal’
[17:36:38.435]   - Field: ‘lazy’
[17:36:38.435]   - Field: ‘state’
[17:36:38.436] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:38.436] - Launch lazy future ...
[17:36:38.436] Packages needed by the future expression (n = 0): <none>
[17:36:38.436] Packages needed by future strategies (n = 0): <none>
[17:36:38.437] {
[17:36:38.437]     {
[17:36:38.437]         {
[17:36:38.437]             ...future.startTime <- base::Sys.time()
[17:36:38.437]             {
[17:36:38.437]                 {
[17:36:38.437]                   {
[17:36:38.437]                     {
[17:36:38.437]                       base::local({
[17:36:38.437]                         has_future <- base::requireNamespace("future", 
[17:36:38.437]                           quietly = TRUE)
[17:36:38.437]                         if (has_future) {
[17:36:38.437]                           ns <- base::getNamespace("future")
[17:36:38.437]                           version <- ns[[".package"]][["version"]]
[17:36:38.437]                           if (is.null(version)) 
[17:36:38.437]                             version <- utils::packageVersion("future")
[17:36:38.437]                         }
[17:36:38.437]                         else {
[17:36:38.437]                           version <- NULL
[17:36:38.437]                         }
[17:36:38.437]                         if (!has_future || version < "1.8.0") {
[17:36:38.437]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:38.437]                             "", base::R.version$version.string), 
[17:36:38.437]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:38.437]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:38.437]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:38.437]                               "release", "version")], collapse = " "), 
[17:36:38.437]                             hostname = base::Sys.info()[["nodename"]])
[17:36:38.437]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:38.437]                             info)
[17:36:38.437]                           info <- base::paste(info, collapse = "; ")
[17:36:38.437]                           if (!has_future) {
[17:36:38.437]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:38.437]                               info)
[17:36:38.437]                           }
[17:36:38.437]                           else {
[17:36:38.437]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:38.437]                               info, version)
[17:36:38.437]                           }
[17:36:38.437]                           base::stop(msg)
[17:36:38.437]                         }
[17:36:38.437]                       })
[17:36:38.437]                     }
[17:36:38.437]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:38.437]                     base::options(mc.cores = 1L)
[17:36:38.437]                   }
[17:36:38.437]                   ...future.strategy.old <- future::plan("list")
[17:36:38.437]                   options(future.plan = NULL)
[17:36:38.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:38.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:38.437]                 }
[17:36:38.437]                 ...future.workdir <- getwd()
[17:36:38.437]             }
[17:36:38.437]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:38.437]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:38.437]         }
[17:36:38.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:38.437]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:38.437]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:38.437]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:38.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:38.437]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:38.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:38.437]             base::names(...future.oldOptions))
[17:36:38.437]     }
[17:36:38.437]     if (FALSE) {
[17:36:38.437]     }
[17:36:38.437]     else {
[17:36:38.437]         if (TRUE) {
[17:36:38.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:38.437]                 open = "w")
[17:36:38.437]         }
[17:36:38.437]         else {
[17:36:38.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:38.437]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:38.437]         }
[17:36:38.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:38.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:38.437]             base::sink(type = "output", split = FALSE)
[17:36:38.437]             base::close(...future.stdout)
[17:36:38.437]         }, add = TRUE)
[17:36:38.437]     }
[17:36:38.437]     ...future.frame <- base::sys.nframe()
[17:36:38.437]     ...future.conditions <- base::list()
[17:36:38.437]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:38.437]     if (FALSE) {
[17:36:38.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:38.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:38.437]     }
[17:36:38.437]     ...future.result <- base::tryCatch({
[17:36:38.437]         base::withCallingHandlers({
[17:36:38.437]             ...future.value <- base::withVisible(base::local({
[17:36:38.437]                 ...future.makeSendCondition <- base::local({
[17:36:38.437]                   sendCondition <- NULL
[17:36:38.437]                   function(frame = 1L) {
[17:36:38.437]                     if (is.function(sendCondition)) 
[17:36:38.437]                       return(sendCondition)
[17:36:38.437]                     ns <- getNamespace("parallel")
[17:36:38.437]                     if (exists("sendData", mode = "function", 
[17:36:38.437]                       envir = ns)) {
[17:36:38.437]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:38.437]                         envir = ns)
[17:36:38.437]                       envir <- sys.frame(frame)
[17:36:38.437]                       master <- NULL
[17:36:38.437]                       while (!identical(envir, .GlobalEnv) && 
[17:36:38.437]                         !identical(envir, emptyenv())) {
[17:36:38.437]                         if (exists("master", mode = "list", envir = envir, 
[17:36:38.437]                           inherits = FALSE)) {
[17:36:38.437]                           master <- get("master", mode = "list", 
[17:36:38.437]                             envir = envir, inherits = FALSE)
[17:36:38.437]                           if (inherits(master, c("SOCKnode", 
[17:36:38.437]                             "SOCK0node"))) {
[17:36:38.437]                             sendCondition <<- function(cond) {
[17:36:38.437]                               data <- list(type = "VALUE", value = cond, 
[17:36:38.437]                                 success = TRUE)
[17:36:38.437]                               parallel_sendData(master, data)
[17:36:38.437]                             }
[17:36:38.437]                             return(sendCondition)
[17:36:38.437]                           }
[17:36:38.437]                         }
[17:36:38.437]                         frame <- frame + 1L
[17:36:38.437]                         envir <- sys.frame(frame)
[17:36:38.437]                       }
[17:36:38.437]                     }
[17:36:38.437]                     sendCondition <<- function(cond) NULL
[17:36:38.437]                   }
[17:36:38.437]                 })
[17:36:38.437]                 withCallingHandlers({
[17:36:38.437]                   {
[17:36:38.437]                     do.call(function(...) {
[17:36:38.437]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.437]                       if (!identical(...future.globals.maxSize.org, 
[17:36:38.437]                         ...future.globals.maxSize)) {
[17:36:38.437]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.437]                         on.exit(options(oopts), add = TRUE)
[17:36:38.437]                       }
[17:36:38.437]                       {
[17:36:38.437]                         lapply(seq_along(...future.elements_ii), 
[17:36:38.437]                           FUN = function(jj) {
[17:36:38.437]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.437]                             ...future.FUN(...future.X_jj, ...)
[17:36:38.437]                           })
[17:36:38.437]                       }
[17:36:38.437]                     }, args = future.call.arguments)
[17:36:38.437]                   }
[17:36:38.437]                 }, immediateCondition = function(cond) {
[17:36:38.437]                   sendCondition <- ...future.makeSendCondition()
[17:36:38.437]                   sendCondition(cond)
[17:36:38.437]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.437]                   {
[17:36:38.437]                     inherits <- base::inherits
[17:36:38.437]                     invokeRestart <- base::invokeRestart
[17:36:38.437]                     is.null <- base::is.null
[17:36:38.437]                     muffled <- FALSE
[17:36:38.437]                     if (inherits(cond, "message")) {
[17:36:38.437]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:38.437]                       if (muffled) 
[17:36:38.437]                         invokeRestart("muffleMessage")
[17:36:38.437]                     }
[17:36:38.437]                     else if (inherits(cond, "warning")) {
[17:36:38.437]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:38.437]                       if (muffled) 
[17:36:38.437]                         invokeRestart("muffleWarning")
[17:36:38.437]                     }
[17:36:38.437]                     else if (inherits(cond, "condition")) {
[17:36:38.437]                       if (!is.null(pattern)) {
[17:36:38.437]                         computeRestarts <- base::computeRestarts
[17:36:38.437]                         grepl <- base::grepl
[17:36:38.437]                         restarts <- computeRestarts(cond)
[17:36:38.437]                         for (restart in restarts) {
[17:36:38.437]                           name <- restart$name
[17:36:38.437]                           if (is.null(name)) 
[17:36:38.437]                             next
[17:36:38.437]                           if (!grepl(pattern, name)) 
[17:36:38.437]                             next
[17:36:38.437]                           invokeRestart(restart)
[17:36:38.437]                           muffled <- TRUE
[17:36:38.437]                           break
[17:36:38.437]                         }
[17:36:38.437]                       }
[17:36:38.437]                     }
[17:36:38.437]                     invisible(muffled)
[17:36:38.437]                   }
[17:36:38.437]                   muffleCondition(cond)
[17:36:38.437]                 })
[17:36:38.437]             }))
[17:36:38.437]             future::FutureResult(value = ...future.value$value, 
[17:36:38.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:38.437]                   ...future.rng), globalenv = if (FALSE) 
[17:36:38.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:38.437]                     ...future.globalenv.names))
[17:36:38.437]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:38.437]         }, condition = base::local({
[17:36:38.437]             c <- base::c
[17:36:38.437]             inherits <- base::inherits
[17:36:38.437]             invokeRestart <- base::invokeRestart
[17:36:38.437]             length <- base::length
[17:36:38.437]             list <- base::list
[17:36:38.437]             seq.int <- base::seq.int
[17:36:38.437]             signalCondition <- base::signalCondition
[17:36:38.437]             sys.calls <- base::sys.calls
[17:36:38.437]             `[[` <- base::`[[`
[17:36:38.437]             `+` <- base::`+`
[17:36:38.437]             `<<-` <- base::`<<-`
[17:36:38.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:38.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:38.437]                   3L)]
[17:36:38.437]             }
[17:36:38.437]             function(cond) {
[17:36:38.437]                 is_error <- inherits(cond, "error")
[17:36:38.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:38.437]                   NULL)
[17:36:38.437]                 if (is_error) {
[17:36:38.437]                   sessionInformation <- function() {
[17:36:38.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:38.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:38.437]                       search = base::search(), system = base::Sys.info())
[17:36:38.437]                   }
[17:36:38.437]                   ...future.conditions[[length(...future.conditions) + 
[17:36:38.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:38.437]                     cond$call), session = sessionInformation(), 
[17:36:38.437]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:38.437]                   signalCondition(cond)
[17:36:38.437]                 }
[17:36:38.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:38.437]                 "immediateCondition"))) {
[17:36:38.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:38.437]                   ...future.conditions[[length(...future.conditions) + 
[17:36:38.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:38.437]                   if (TRUE && !signal) {
[17:36:38.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.437]                     {
[17:36:38.437]                       inherits <- base::inherits
[17:36:38.437]                       invokeRestart <- base::invokeRestart
[17:36:38.437]                       is.null <- base::is.null
[17:36:38.437]                       muffled <- FALSE
[17:36:38.437]                       if (inherits(cond, "message")) {
[17:36:38.437]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:38.437]                         if (muffled) 
[17:36:38.437]                           invokeRestart("muffleMessage")
[17:36:38.437]                       }
[17:36:38.437]                       else if (inherits(cond, "warning")) {
[17:36:38.437]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:38.437]                         if (muffled) 
[17:36:38.437]                           invokeRestart("muffleWarning")
[17:36:38.437]                       }
[17:36:38.437]                       else if (inherits(cond, "condition")) {
[17:36:38.437]                         if (!is.null(pattern)) {
[17:36:38.437]                           computeRestarts <- base::computeRestarts
[17:36:38.437]                           grepl <- base::grepl
[17:36:38.437]                           restarts <- computeRestarts(cond)
[17:36:38.437]                           for (restart in restarts) {
[17:36:38.437]                             name <- restart$name
[17:36:38.437]                             if (is.null(name)) 
[17:36:38.437]                               next
[17:36:38.437]                             if (!grepl(pattern, name)) 
[17:36:38.437]                               next
[17:36:38.437]                             invokeRestart(restart)
[17:36:38.437]                             muffled <- TRUE
[17:36:38.437]                             break
[17:36:38.437]                           }
[17:36:38.437]                         }
[17:36:38.437]                       }
[17:36:38.437]                       invisible(muffled)
[17:36:38.437]                     }
[17:36:38.437]                     muffleCondition(cond, pattern = "^muffle")
[17:36:38.437]                   }
[17:36:38.437]                 }
[17:36:38.437]                 else {
[17:36:38.437]                   if (TRUE) {
[17:36:38.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.437]                     {
[17:36:38.437]                       inherits <- base::inherits
[17:36:38.437]                       invokeRestart <- base::invokeRestart
[17:36:38.437]                       is.null <- base::is.null
[17:36:38.437]                       muffled <- FALSE
[17:36:38.437]                       if (inherits(cond, "message")) {
[17:36:38.437]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:38.437]                         if (muffled) 
[17:36:38.437]                           invokeRestart("muffleMessage")
[17:36:38.437]                       }
[17:36:38.437]                       else if (inherits(cond, "warning")) {
[17:36:38.437]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:38.437]                         if (muffled) 
[17:36:38.437]                           invokeRestart("muffleWarning")
[17:36:38.437]                       }
[17:36:38.437]                       else if (inherits(cond, "condition")) {
[17:36:38.437]                         if (!is.null(pattern)) {
[17:36:38.437]                           computeRestarts <- base::computeRestarts
[17:36:38.437]                           grepl <- base::grepl
[17:36:38.437]                           restarts <- computeRestarts(cond)
[17:36:38.437]                           for (restart in restarts) {
[17:36:38.437]                             name <- restart$name
[17:36:38.437]                             if (is.null(name)) 
[17:36:38.437]                               next
[17:36:38.437]                             if (!grepl(pattern, name)) 
[17:36:38.437]                               next
[17:36:38.437]                             invokeRestart(restart)
[17:36:38.437]                             muffled <- TRUE
[17:36:38.437]                             break
[17:36:38.437]                           }
[17:36:38.437]                         }
[17:36:38.437]                       }
[17:36:38.437]                       invisible(muffled)
[17:36:38.437]                     }
[17:36:38.437]                     muffleCondition(cond, pattern = "^muffle")
[17:36:38.437]                   }
[17:36:38.437]                 }
[17:36:38.437]             }
[17:36:38.437]         }))
[17:36:38.437]     }, error = function(ex) {
[17:36:38.437]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:38.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:38.437]                 ...future.rng), started = ...future.startTime, 
[17:36:38.437]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:38.437]             version = "1.8"), class = "FutureResult")
[17:36:38.437]     }, finally = {
[17:36:38.437]         if (!identical(...future.workdir, getwd())) 
[17:36:38.437]             setwd(...future.workdir)
[17:36:38.437]         {
[17:36:38.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:38.437]                 ...future.oldOptions$nwarnings <- NULL
[17:36:38.437]             }
[17:36:38.437]             base::options(...future.oldOptions)
[17:36:38.437]             if (.Platform$OS.type == "windows") {
[17:36:38.437]                 old_names <- names(...future.oldEnvVars)
[17:36:38.437]                 envs <- base::Sys.getenv()
[17:36:38.437]                 names <- names(envs)
[17:36:38.437]                 common <- intersect(names, old_names)
[17:36:38.437]                 added <- setdiff(names, old_names)
[17:36:38.437]                 removed <- setdiff(old_names, names)
[17:36:38.437]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:38.437]                   envs[common]]
[17:36:38.437]                 NAMES <- toupper(changed)
[17:36:38.437]                 args <- list()
[17:36:38.437]                 for (kk in seq_along(NAMES)) {
[17:36:38.437]                   name <- changed[[kk]]
[17:36:38.437]                   NAME <- NAMES[[kk]]
[17:36:38.437]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.437]                     next
[17:36:38.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:38.437]                 }
[17:36:38.437]                 NAMES <- toupper(added)
[17:36:38.437]                 for (kk in seq_along(NAMES)) {
[17:36:38.437]                   name <- added[[kk]]
[17:36:38.437]                   NAME <- NAMES[[kk]]
[17:36:38.437]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.437]                     next
[17:36:38.437]                   args[[name]] <- ""
[17:36:38.437]                 }
[17:36:38.437]                 NAMES <- toupper(removed)
[17:36:38.437]                 for (kk in seq_along(NAMES)) {
[17:36:38.437]                   name <- removed[[kk]]
[17:36:38.437]                   NAME <- NAMES[[kk]]
[17:36:38.437]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.437]                     next
[17:36:38.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:38.437]                 }
[17:36:38.437]                 if (length(args) > 0) 
[17:36:38.437]                   base::do.call(base::Sys.setenv, args = args)
[17:36:38.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:38.437]             }
[17:36:38.437]             else {
[17:36:38.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:38.437]             }
[17:36:38.437]             {
[17:36:38.437]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:38.437]                   0L) {
[17:36:38.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:38.437]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:38.437]                   base::options(opts)
[17:36:38.437]                 }
[17:36:38.437]                 {
[17:36:38.437]                   {
[17:36:38.437]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:38.437]                     NULL
[17:36:38.437]                   }
[17:36:38.437]                   options(future.plan = NULL)
[17:36:38.437]                   if (is.na(NA_character_)) 
[17:36:38.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:38.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:38.437]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:38.437]                     .init = FALSE)
[17:36:38.437]                 }
[17:36:38.437]             }
[17:36:38.437]         }
[17:36:38.437]     })
[17:36:38.437]     if (TRUE) {
[17:36:38.437]         base::sink(type = "output", split = FALSE)
[17:36:38.437]         if (TRUE) {
[17:36:38.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:38.437]         }
[17:36:38.437]         else {
[17:36:38.437]             ...future.result["stdout"] <- base::list(NULL)
[17:36:38.437]         }
[17:36:38.437]         base::close(...future.stdout)
[17:36:38.437]         ...future.stdout <- NULL
[17:36:38.437]     }
[17:36:38.437]     ...future.result$conditions <- ...future.conditions
[17:36:38.437]     ...future.result$finished <- base::Sys.time()
[17:36:38.437]     ...future.result
[17:36:38.437] }
[17:36:38.439] Exporting 5 global objects (1.12 KiB) to cluster node #2 ...
[17:36:38.440] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:36:38.440] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:36:38.440] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[17:36:38.441] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[17:36:38.441] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ...
[17:36:38.441] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ... DONE
[17:36:38.441] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:36:38.441] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:36:38.442] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:36:38.442] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:36:38.442] Exporting 5 global objects (1.12 KiB) to cluster node #2 ... DONE
[17:36:38.442] MultisessionFuture started
[17:36:38.442] - Launch lazy future ... done
[17:36:38.443] run() for ‘MultisessionFuture’ ... done
[17:36:38.443] Created future:
[17:36:38.443] MultisessionFuture:
[17:36:38.443] Label: ‘future_apply-2’
[17:36:38.443] Expression:
[17:36:38.443] {
[17:36:38.443]     do.call(function(...) {
[17:36:38.443]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.443]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:38.443]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.443]             on.exit(options(oopts), add = TRUE)
[17:36:38.443]         }
[17:36:38.443]         {
[17:36:38.443]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:38.443]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.443]                 ...future.FUN(...future.X_jj, ...)
[17:36:38.443]             })
[17:36:38.443]         }
[17:36:38.443]     }, args = future.call.arguments)
[17:36:38.443] }
[17:36:38.443] Lazy evaluation: FALSE
[17:36:38.443] Asynchronous evaluation: TRUE
[17:36:38.443] Local evaluation: TRUE
[17:36:38.443] Environment: R_GlobalEnv
[17:36:38.443] Capture standard output: TRUE
[17:36:38.443] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:38.443] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:38.443] Packages: <none>
[17:36:38.443] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:38.443] Resolved: FALSE
[17:36:38.443] Value: <not collected>
[17:36:38.443] Conditions captured: <none>
[17:36:38.443] Early signaling: FALSE
[17:36:38.443] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:38.443] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.454] Chunk #2 of 2 ... DONE
[17:36:38.454] Launching 2 futures (chunks) ... DONE
[17:36:38.455] Resolving 2 futures (chunks) ...
[17:36:38.455] resolve() on list ...
[17:36:38.455]  recursive: 0
[17:36:38.455]  length: 2
[17:36:38.455] 
[17:36:38.455] receiveMessageFromWorker() for ClusterFuture ...
[17:36:38.455] - Validating connection of MultisessionFuture
[17:36:38.456] - received message: FutureResult
[17:36:38.456] - Received FutureResult
[17:36:38.456] - Erased future from FutureRegistry
[17:36:38.456] result() for ClusterFuture ...
[17:36:38.456] - result already collected: FutureResult
[17:36:38.456] result() for ClusterFuture ... done
[17:36:38.456] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:38.456] Future #1
[17:36:38.456] result() for ClusterFuture ...
[17:36:38.456] - result already collected: FutureResult
[17:36:38.457] result() for ClusterFuture ... done
[17:36:38.457] result() for ClusterFuture ...
[17:36:38.457] - result already collected: FutureResult
[17:36:38.457] result() for ClusterFuture ... done
[17:36:38.457] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:36:38.457] - nx: 2
[17:36:38.457] - relay: TRUE
[17:36:38.457] - stdout: TRUE
[17:36:38.457] - signal: TRUE
[17:36:38.457] - resignal: FALSE
[17:36:38.458] - force: TRUE
[17:36:38.458] - relayed: [n=2] FALSE, FALSE
[17:36:38.458] - queued futures: [n=2] FALSE, FALSE
[17:36:38.458]  - until=1
[17:36:38.458]  - relaying element #1
[17:36:38.458] result() for ClusterFuture ...
[17:36:38.458] - result already collected: FutureResult
[17:36:38.458] result() for ClusterFuture ... done
[17:36:38.458] result() for ClusterFuture ...
[17:36:38.458] - result already collected: FutureResult
[17:36:38.458] result() for ClusterFuture ... done
[17:36:38.459] result() for ClusterFuture ...
[17:36:38.459] - result already collected: FutureResult
[17:36:38.459] result() for ClusterFuture ... done
[17:36:38.459] result() for ClusterFuture ...
[17:36:38.459] - result already collected: FutureResult
[17:36:38.459] result() for ClusterFuture ... done
[17:36:38.459] - relayed: [n=2] TRUE, FALSE
[17:36:38.459] - queued futures: [n=2] TRUE, FALSE
[17:36:38.459] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:36:38.459]  length: 1 (resolved future 1)
[17:36:38.486] receiveMessageFromWorker() for ClusterFuture ...
[17:36:38.486] - Validating connection of MultisessionFuture
[17:36:38.486] - received message: FutureResult
[17:36:38.486] - Received FutureResult
[17:36:38.486] - Erased future from FutureRegistry
[17:36:38.487] result() for ClusterFuture ...
[17:36:38.487] - result already collected: FutureResult
[17:36:38.487] result() for ClusterFuture ... done
[17:36:38.487] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:38.487] Future #2
[17:36:38.487] result() for ClusterFuture ...
[17:36:38.487] - result already collected: FutureResult
[17:36:38.487] result() for ClusterFuture ... done
[17:36:38.487] result() for ClusterFuture ...
[17:36:38.487] - result already collected: FutureResult
[17:36:38.487] result() for ClusterFuture ... done
[17:36:38.488] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:36:38.488] - nx: 2
[17:36:38.488] - relay: TRUE
[17:36:38.488] - stdout: TRUE
[17:36:38.488] - signal: TRUE
[17:36:38.488] - resignal: FALSE
[17:36:38.488] - force: TRUE
[17:36:38.488] - relayed: [n=2] TRUE, FALSE
[17:36:38.488] - queued futures: [n=2] TRUE, FALSE
[17:36:38.488]  - until=2
[17:36:38.488]  - relaying element #2
[17:36:38.489] result() for ClusterFuture ...
[17:36:38.489] - result already collected: FutureResult
[17:36:38.489] result() for ClusterFuture ... done
[17:36:38.489] result() for ClusterFuture ...
[17:36:38.489] - result already collected: FutureResult
[17:36:38.489] result() for ClusterFuture ... done
[17:36:38.489] result() for ClusterFuture ...
[17:36:38.489] - result already collected: FutureResult
[17:36:38.489] result() for ClusterFuture ... done
[17:36:38.489] result() for ClusterFuture ...
[17:36:38.489] - result already collected: FutureResult
[17:36:38.490] result() for ClusterFuture ... done
[17:36:38.490] - relayed: [n=2] TRUE, TRUE
[17:36:38.490] - queued futures: [n=2] TRUE, TRUE
[17:36:38.490] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:36:38.490]  length: 0 (resolved future 2)
[17:36:38.490] Relaying remaining futures
[17:36:38.490] signalConditionsASAP(NULL, pos=0) ...
[17:36:38.490] - nx: 2
[17:36:38.490] - relay: TRUE
[17:36:38.490] - stdout: TRUE
[17:36:38.490] - signal: TRUE
[17:36:38.490] - resignal: FALSE
[17:36:38.491] - force: TRUE
[17:36:38.491] - relayed: [n=2] TRUE, TRUE
[17:36:38.491] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:38.491] - relayed: [n=2] TRUE, TRUE
[17:36:38.491] - queued futures: [n=2] TRUE, TRUE
[17:36:38.491] signalConditionsASAP(NULL, pos=0) ... done
[17:36:38.491] resolve() on list ... DONE
[17:36:38.491] result() for ClusterFuture ...
[17:36:38.491] - result already collected: FutureResult
[17:36:38.491] result() for ClusterFuture ... done
[17:36:38.491] result() for ClusterFuture ...
[17:36:38.492] - result already collected: FutureResult
[17:36:38.492] result() for ClusterFuture ... done
[17:36:38.492] result() for ClusterFuture ...
[17:36:38.492] - result already collected: FutureResult
[17:36:38.492] result() for ClusterFuture ... done
[17:36:38.492] result() for ClusterFuture ...
[17:36:38.492] - result already collected: FutureResult
[17:36:38.492] result() for ClusterFuture ... done
[17:36:38.492]  - Number of value chunks collected: 2
[17:36:38.492] Resolving 2 futures (chunks) ... DONE
[17:36:38.492] Reducing values from 2 chunks ...
[17:36:38.493]  - Number of values collected after concatenation: 2
[17:36:38.493]  - Number of values expected: 2
[17:36:38.493] Reducing values from 2 chunks ... DONE
[17:36:38.493] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[17:36:38.493] getGlobalsAndPackagesXApply() ...
[17:36:38.493]  - future.globals: TRUE
[17:36:38.493] getGlobalsAndPackages() ...
[17:36:38.494] Searching for globals...
[17:36:38.496] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[17:36:38.496] Searching for globals ... DONE
[17:36:38.496] Resolving globals: FALSE
[17:36:38.497] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[17:36:38.497] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[17:36:38.497] - globals: [1] ‘FUN’
[17:36:38.497] 
[17:36:38.497] getGlobalsAndPackages() ... DONE
[17:36:38.498]  - globals found/used: [n=1] ‘FUN’
[17:36:38.498]  - needed namespaces: [n=0] 
[17:36:38.498] Finding globals ... DONE
[17:36:38.498]  - use_args: TRUE
[17:36:38.498]  - Getting '...' globals ...
[17:36:38.498] resolve() on list ...
[17:36:38.498]  recursive: 0
[17:36:38.499]  length: 1
[17:36:38.499]  elements: ‘...’
[17:36:38.499]  length: 0 (resolved future 1)
[17:36:38.499] resolve() on list ... DONE
[17:36:38.499]    - '...' content: [n=0] 
[17:36:38.499] List of 1
[17:36:38.499]  $ ...: list()
[17:36:38.499]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:38.499]  - attr(*, "where")=List of 1
[17:36:38.499]   ..$ ...:<environment: 0x556d76973a48> 
[17:36:38.499]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:38.499]  - attr(*, "resolved")= logi TRUE
[17:36:38.499]  - attr(*, "total_size")= num NA
[17:36:38.501]  - Getting '...' globals ... DONE
[17:36:38.502] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:38.502] List of 2
[17:36:38.502]  $ ...future.FUN:function (x)  
[17:36:38.502]  $ ...          : list()
[17:36:38.502]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:38.502]  - attr(*, "where")=List of 2
[17:36:38.502]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:38.502]   ..$ ...          :<environment: 0x556d76973a48> 
[17:36:38.502]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:38.502]  - attr(*, "resolved")= logi FALSE
[17:36:38.502]  - attr(*, "total_size")= num 9888
[17:36:38.504] Packages to be attached in all futures: [n=0] 
[17:36:38.504] getGlobalsAndPackagesXApply() ... DONE
[17:36:38.508] future_lapply() ...
[17:36:38.513] Number of chunks: 2
[17:36:38.513] getGlobalsAndPackagesXApply() ...
[17:36:38.513]  - future.globals: <name-value list> with names ‘list()’
[17:36:38.513]  - use_args: TRUE
[17:36:38.513] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:38.514] List of 2
[17:36:38.514]  $ ...          : list()
[17:36:38.514]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:38.514]  $ ...future.FUN:function (x)  
[17:36:38.514]  - attr(*, "where")=List of 2
[17:36:38.514]   ..$ ...          :<environment: 0x556d76973a48> 
[17:36:38.514]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:36:38.514]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:38.514]  - attr(*, "resolved")= logi FALSE
[17:36:38.514]  - attr(*, "total_size")= num NA
[17:36:38.516] Packages to be attached in all futures: [n=0] 
[17:36:38.516] getGlobalsAndPackagesXApply() ... DONE
[17:36:38.516] Number of futures (= number of chunks): 2
[17:36:38.517] Launching 2 futures (chunks) ...
[17:36:38.517] Chunk #1 of 2 ...
[17:36:38.517]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:38.517]  - seeds: <none>
[17:36:38.517]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.517] getGlobalsAndPackages() ...
[17:36:38.517] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.517] Resolving globals: FALSE
[17:36:38.517] Tweak future expression to call with '...' arguments ...
[17:36:38.518] {
[17:36:38.518]     do.call(function(...) {
[17:36:38.518]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.518]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:38.518]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.518]             on.exit(options(oopts), add = TRUE)
[17:36:38.518]         }
[17:36:38.518]         {
[17:36:38.518]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:38.518]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.518]                 ...future.FUN(...future.X_jj, ...)
[17:36:38.518]             })
[17:36:38.518]         }
[17:36:38.518]     }, args = future.call.arguments)
[17:36:38.518] }
[17:36:38.518] Tweak future expression to call with '...' arguments ... DONE
[17:36:38.518] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.518] 
[17:36:38.518] getGlobalsAndPackages() ... DONE
[17:36:38.519] run() for ‘Future’ ...
[17:36:38.519] - state: ‘created’
[17:36:38.519] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:38.532] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.533] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:38.533]   - Field: ‘node’
[17:36:38.533]   - Field: ‘label’
[17:36:38.533]   - Field: ‘local’
[17:36:38.533]   - Field: ‘owner’
[17:36:38.533]   - Field: ‘envir’
[17:36:38.533]   - Field: ‘workers’
[17:36:38.533]   - Field: ‘packages’
[17:36:38.533]   - Field: ‘gc’
[17:36:38.533]   - Field: ‘conditions’
[17:36:38.534]   - Field: ‘persistent’
[17:36:38.534]   - Field: ‘expr’
[17:36:38.534]   - Field: ‘uuid’
[17:36:38.534]   - Field: ‘seed’
[17:36:38.534]   - Field: ‘version’
[17:36:38.534]   - Field: ‘result’
[17:36:38.534]   - Field: ‘asynchronous’
[17:36:38.534]   - Field: ‘calls’
[17:36:38.534]   - Field: ‘globals’
[17:36:38.534]   - Field: ‘stdout’
[17:36:38.534]   - Field: ‘earlySignal’
[17:36:38.534]   - Field: ‘lazy’
[17:36:38.535]   - Field: ‘state’
[17:36:38.535] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:38.535] - Launch lazy future ...
[17:36:38.535] Packages needed by the future expression (n = 0): <none>
[17:36:38.535] Packages needed by future strategies (n = 0): <none>
[17:36:38.536] {
[17:36:38.536]     {
[17:36:38.536]         {
[17:36:38.536]             ...future.startTime <- base::Sys.time()
[17:36:38.536]             {
[17:36:38.536]                 {
[17:36:38.536]                   {
[17:36:38.536]                     {
[17:36:38.536]                       base::local({
[17:36:38.536]                         has_future <- base::requireNamespace("future", 
[17:36:38.536]                           quietly = TRUE)
[17:36:38.536]                         if (has_future) {
[17:36:38.536]                           ns <- base::getNamespace("future")
[17:36:38.536]                           version <- ns[[".package"]][["version"]]
[17:36:38.536]                           if (is.null(version)) 
[17:36:38.536]                             version <- utils::packageVersion("future")
[17:36:38.536]                         }
[17:36:38.536]                         else {
[17:36:38.536]                           version <- NULL
[17:36:38.536]                         }
[17:36:38.536]                         if (!has_future || version < "1.8.0") {
[17:36:38.536]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:38.536]                             "", base::R.version$version.string), 
[17:36:38.536]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:38.536]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:38.536]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:38.536]                               "release", "version")], collapse = " "), 
[17:36:38.536]                             hostname = base::Sys.info()[["nodename"]])
[17:36:38.536]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:38.536]                             info)
[17:36:38.536]                           info <- base::paste(info, collapse = "; ")
[17:36:38.536]                           if (!has_future) {
[17:36:38.536]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:38.536]                               info)
[17:36:38.536]                           }
[17:36:38.536]                           else {
[17:36:38.536]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:38.536]                               info, version)
[17:36:38.536]                           }
[17:36:38.536]                           base::stop(msg)
[17:36:38.536]                         }
[17:36:38.536]                       })
[17:36:38.536]                     }
[17:36:38.536]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:38.536]                     base::options(mc.cores = 1L)
[17:36:38.536]                   }
[17:36:38.536]                   ...future.strategy.old <- future::plan("list")
[17:36:38.536]                   options(future.plan = NULL)
[17:36:38.536]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:38.536]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:38.536]                 }
[17:36:38.536]                 ...future.workdir <- getwd()
[17:36:38.536]             }
[17:36:38.536]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:38.536]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:38.536]         }
[17:36:38.536]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:38.536]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:38.536]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:38.536]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:38.536]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:38.536]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:38.536]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:38.536]             base::names(...future.oldOptions))
[17:36:38.536]     }
[17:36:38.536]     if (FALSE) {
[17:36:38.536]     }
[17:36:38.536]     else {
[17:36:38.536]         if (TRUE) {
[17:36:38.536]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:38.536]                 open = "w")
[17:36:38.536]         }
[17:36:38.536]         else {
[17:36:38.536]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:38.536]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:38.536]         }
[17:36:38.536]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:38.536]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:38.536]             base::sink(type = "output", split = FALSE)
[17:36:38.536]             base::close(...future.stdout)
[17:36:38.536]         }, add = TRUE)
[17:36:38.536]     }
[17:36:38.536]     ...future.frame <- base::sys.nframe()
[17:36:38.536]     ...future.conditions <- base::list()
[17:36:38.536]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:38.536]     if (FALSE) {
[17:36:38.536]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:38.536]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:38.536]     }
[17:36:38.536]     ...future.result <- base::tryCatch({
[17:36:38.536]         base::withCallingHandlers({
[17:36:38.536]             ...future.value <- base::withVisible(base::local({
[17:36:38.536]                 ...future.makeSendCondition <- base::local({
[17:36:38.536]                   sendCondition <- NULL
[17:36:38.536]                   function(frame = 1L) {
[17:36:38.536]                     if (is.function(sendCondition)) 
[17:36:38.536]                       return(sendCondition)
[17:36:38.536]                     ns <- getNamespace("parallel")
[17:36:38.536]                     if (exists("sendData", mode = "function", 
[17:36:38.536]                       envir = ns)) {
[17:36:38.536]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:38.536]                         envir = ns)
[17:36:38.536]                       envir <- sys.frame(frame)
[17:36:38.536]                       master <- NULL
[17:36:38.536]                       while (!identical(envir, .GlobalEnv) && 
[17:36:38.536]                         !identical(envir, emptyenv())) {
[17:36:38.536]                         if (exists("master", mode = "list", envir = envir, 
[17:36:38.536]                           inherits = FALSE)) {
[17:36:38.536]                           master <- get("master", mode = "list", 
[17:36:38.536]                             envir = envir, inherits = FALSE)
[17:36:38.536]                           if (inherits(master, c("SOCKnode", 
[17:36:38.536]                             "SOCK0node"))) {
[17:36:38.536]                             sendCondition <<- function(cond) {
[17:36:38.536]                               data <- list(type = "VALUE", value = cond, 
[17:36:38.536]                                 success = TRUE)
[17:36:38.536]                               parallel_sendData(master, data)
[17:36:38.536]                             }
[17:36:38.536]                             return(sendCondition)
[17:36:38.536]                           }
[17:36:38.536]                         }
[17:36:38.536]                         frame <- frame + 1L
[17:36:38.536]                         envir <- sys.frame(frame)
[17:36:38.536]                       }
[17:36:38.536]                     }
[17:36:38.536]                     sendCondition <<- function(cond) NULL
[17:36:38.536]                   }
[17:36:38.536]                 })
[17:36:38.536]                 withCallingHandlers({
[17:36:38.536]                   {
[17:36:38.536]                     do.call(function(...) {
[17:36:38.536]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.536]                       if (!identical(...future.globals.maxSize.org, 
[17:36:38.536]                         ...future.globals.maxSize)) {
[17:36:38.536]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.536]                         on.exit(options(oopts), add = TRUE)
[17:36:38.536]                       }
[17:36:38.536]                       {
[17:36:38.536]                         lapply(seq_along(...future.elements_ii), 
[17:36:38.536]                           FUN = function(jj) {
[17:36:38.536]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.536]                             ...future.FUN(...future.X_jj, ...)
[17:36:38.536]                           })
[17:36:38.536]                       }
[17:36:38.536]                     }, args = future.call.arguments)
[17:36:38.536]                   }
[17:36:38.536]                 }, immediateCondition = function(cond) {
[17:36:38.536]                   sendCondition <- ...future.makeSendCondition()
[17:36:38.536]                   sendCondition(cond)
[17:36:38.536]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.536]                   {
[17:36:38.536]                     inherits <- base::inherits
[17:36:38.536]                     invokeRestart <- base::invokeRestart
[17:36:38.536]                     is.null <- base::is.null
[17:36:38.536]                     muffled <- FALSE
[17:36:38.536]                     if (inherits(cond, "message")) {
[17:36:38.536]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:38.536]                       if (muffled) 
[17:36:38.536]                         invokeRestart("muffleMessage")
[17:36:38.536]                     }
[17:36:38.536]                     else if (inherits(cond, "warning")) {
[17:36:38.536]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:38.536]                       if (muffled) 
[17:36:38.536]                         invokeRestart("muffleWarning")
[17:36:38.536]                     }
[17:36:38.536]                     else if (inherits(cond, "condition")) {
[17:36:38.536]                       if (!is.null(pattern)) {
[17:36:38.536]                         computeRestarts <- base::computeRestarts
[17:36:38.536]                         grepl <- base::grepl
[17:36:38.536]                         restarts <- computeRestarts(cond)
[17:36:38.536]                         for (restart in restarts) {
[17:36:38.536]                           name <- restart$name
[17:36:38.536]                           if (is.null(name)) 
[17:36:38.536]                             next
[17:36:38.536]                           if (!grepl(pattern, name)) 
[17:36:38.536]                             next
[17:36:38.536]                           invokeRestart(restart)
[17:36:38.536]                           muffled <- TRUE
[17:36:38.536]                           break
[17:36:38.536]                         }
[17:36:38.536]                       }
[17:36:38.536]                     }
[17:36:38.536]                     invisible(muffled)
[17:36:38.536]                   }
[17:36:38.536]                   muffleCondition(cond)
[17:36:38.536]                 })
[17:36:38.536]             }))
[17:36:38.536]             future::FutureResult(value = ...future.value$value, 
[17:36:38.536]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:38.536]                   ...future.rng), globalenv = if (FALSE) 
[17:36:38.536]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:38.536]                     ...future.globalenv.names))
[17:36:38.536]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:38.536]         }, condition = base::local({
[17:36:38.536]             c <- base::c
[17:36:38.536]             inherits <- base::inherits
[17:36:38.536]             invokeRestart <- base::invokeRestart
[17:36:38.536]             length <- base::length
[17:36:38.536]             list <- base::list
[17:36:38.536]             seq.int <- base::seq.int
[17:36:38.536]             signalCondition <- base::signalCondition
[17:36:38.536]             sys.calls <- base::sys.calls
[17:36:38.536]             `[[` <- base::`[[`
[17:36:38.536]             `+` <- base::`+`
[17:36:38.536]             `<<-` <- base::`<<-`
[17:36:38.536]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:38.536]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:38.536]                   3L)]
[17:36:38.536]             }
[17:36:38.536]             function(cond) {
[17:36:38.536]                 is_error <- inherits(cond, "error")
[17:36:38.536]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:38.536]                   NULL)
[17:36:38.536]                 if (is_error) {
[17:36:38.536]                   sessionInformation <- function() {
[17:36:38.536]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:38.536]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:38.536]                       search = base::search(), system = base::Sys.info())
[17:36:38.536]                   }
[17:36:38.536]                   ...future.conditions[[length(...future.conditions) + 
[17:36:38.536]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:38.536]                     cond$call), session = sessionInformation(), 
[17:36:38.536]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:38.536]                   signalCondition(cond)
[17:36:38.536]                 }
[17:36:38.536]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:38.536]                 "immediateCondition"))) {
[17:36:38.536]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:38.536]                   ...future.conditions[[length(...future.conditions) + 
[17:36:38.536]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:38.536]                   if (TRUE && !signal) {
[17:36:38.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.536]                     {
[17:36:38.536]                       inherits <- base::inherits
[17:36:38.536]                       invokeRestart <- base::invokeRestart
[17:36:38.536]                       is.null <- base::is.null
[17:36:38.536]                       muffled <- FALSE
[17:36:38.536]                       if (inherits(cond, "message")) {
[17:36:38.536]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:38.536]                         if (muffled) 
[17:36:38.536]                           invokeRestart("muffleMessage")
[17:36:38.536]                       }
[17:36:38.536]                       else if (inherits(cond, "warning")) {
[17:36:38.536]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:38.536]                         if (muffled) 
[17:36:38.536]                           invokeRestart("muffleWarning")
[17:36:38.536]                       }
[17:36:38.536]                       else if (inherits(cond, "condition")) {
[17:36:38.536]                         if (!is.null(pattern)) {
[17:36:38.536]                           computeRestarts <- base::computeRestarts
[17:36:38.536]                           grepl <- base::grepl
[17:36:38.536]                           restarts <- computeRestarts(cond)
[17:36:38.536]                           for (restart in restarts) {
[17:36:38.536]                             name <- restart$name
[17:36:38.536]                             if (is.null(name)) 
[17:36:38.536]                               next
[17:36:38.536]                             if (!grepl(pattern, name)) 
[17:36:38.536]                               next
[17:36:38.536]                             invokeRestart(restart)
[17:36:38.536]                             muffled <- TRUE
[17:36:38.536]                             break
[17:36:38.536]                           }
[17:36:38.536]                         }
[17:36:38.536]                       }
[17:36:38.536]                       invisible(muffled)
[17:36:38.536]                     }
[17:36:38.536]                     muffleCondition(cond, pattern = "^muffle")
[17:36:38.536]                   }
[17:36:38.536]                 }
[17:36:38.536]                 else {
[17:36:38.536]                   if (TRUE) {
[17:36:38.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.536]                     {
[17:36:38.536]                       inherits <- base::inherits
[17:36:38.536]                       invokeRestart <- base::invokeRestart
[17:36:38.536]                       is.null <- base::is.null
[17:36:38.536]                       muffled <- FALSE
[17:36:38.536]                       if (inherits(cond, "message")) {
[17:36:38.536]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:38.536]                         if (muffled) 
[17:36:38.536]                           invokeRestart("muffleMessage")
[17:36:38.536]                       }
[17:36:38.536]                       else if (inherits(cond, "warning")) {
[17:36:38.536]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:38.536]                         if (muffled) 
[17:36:38.536]                           invokeRestart("muffleWarning")
[17:36:38.536]                       }
[17:36:38.536]                       else if (inherits(cond, "condition")) {
[17:36:38.536]                         if (!is.null(pattern)) {
[17:36:38.536]                           computeRestarts <- base::computeRestarts
[17:36:38.536]                           grepl <- base::grepl
[17:36:38.536]                           restarts <- computeRestarts(cond)
[17:36:38.536]                           for (restart in restarts) {
[17:36:38.536]                             name <- restart$name
[17:36:38.536]                             if (is.null(name)) 
[17:36:38.536]                               next
[17:36:38.536]                             if (!grepl(pattern, name)) 
[17:36:38.536]                               next
[17:36:38.536]                             invokeRestart(restart)
[17:36:38.536]                             muffled <- TRUE
[17:36:38.536]                             break
[17:36:38.536]                           }
[17:36:38.536]                         }
[17:36:38.536]                       }
[17:36:38.536]                       invisible(muffled)
[17:36:38.536]                     }
[17:36:38.536]                     muffleCondition(cond, pattern = "^muffle")
[17:36:38.536]                   }
[17:36:38.536]                 }
[17:36:38.536]             }
[17:36:38.536]         }))
[17:36:38.536]     }, error = function(ex) {
[17:36:38.536]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:38.536]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:38.536]                 ...future.rng), started = ...future.startTime, 
[17:36:38.536]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:38.536]             version = "1.8"), class = "FutureResult")
[17:36:38.536]     }, finally = {
[17:36:38.536]         if (!identical(...future.workdir, getwd())) 
[17:36:38.536]             setwd(...future.workdir)
[17:36:38.536]         {
[17:36:38.536]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:38.536]                 ...future.oldOptions$nwarnings <- NULL
[17:36:38.536]             }
[17:36:38.536]             base::options(...future.oldOptions)
[17:36:38.536]             if (.Platform$OS.type == "windows") {
[17:36:38.536]                 old_names <- names(...future.oldEnvVars)
[17:36:38.536]                 envs <- base::Sys.getenv()
[17:36:38.536]                 names <- names(envs)
[17:36:38.536]                 common <- intersect(names, old_names)
[17:36:38.536]                 added <- setdiff(names, old_names)
[17:36:38.536]                 removed <- setdiff(old_names, names)
[17:36:38.536]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:38.536]                   envs[common]]
[17:36:38.536]                 NAMES <- toupper(changed)
[17:36:38.536]                 args <- list()
[17:36:38.536]                 for (kk in seq_along(NAMES)) {
[17:36:38.536]                   name <- changed[[kk]]
[17:36:38.536]                   NAME <- NAMES[[kk]]
[17:36:38.536]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.536]                     next
[17:36:38.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:38.536]                 }
[17:36:38.536]                 NAMES <- toupper(added)
[17:36:38.536]                 for (kk in seq_along(NAMES)) {
[17:36:38.536]                   name <- added[[kk]]
[17:36:38.536]                   NAME <- NAMES[[kk]]
[17:36:38.536]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.536]                     next
[17:36:38.536]                   args[[name]] <- ""
[17:36:38.536]                 }
[17:36:38.536]                 NAMES <- toupper(removed)
[17:36:38.536]                 for (kk in seq_along(NAMES)) {
[17:36:38.536]                   name <- removed[[kk]]
[17:36:38.536]                   NAME <- NAMES[[kk]]
[17:36:38.536]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.536]                     next
[17:36:38.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:38.536]                 }
[17:36:38.536]                 if (length(args) > 0) 
[17:36:38.536]                   base::do.call(base::Sys.setenv, args = args)
[17:36:38.536]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:38.536]             }
[17:36:38.536]             else {
[17:36:38.536]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:38.536]             }
[17:36:38.536]             {
[17:36:38.536]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:38.536]                   0L) {
[17:36:38.536]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:38.536]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:38.536]                   base::options(opts)
[17:36:38.536]                 }
[17:36:38.536]                 {
[17:36:38.536]                   {
[17:36:38.536]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:38.536]                     NULL
[17:36:38.536]                   }
[17:36:38.536]                   options(future.plan = NULL)
[17:36:38.536]                   if (is.na(NA_character_)) 
[17:36:38.536]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:38.536]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:38.536]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:38.536]                     .init = FALSE)
[17:36:38.536]                 }
[17:36:38.536]             }
[17:36:38.536]         }
[17:36:38.536]     })
[17:36:38.536]     if (TRUE) {
[17:36:38.536]         base::sink(type = "output", split = FALSE)
[17:36:38.536]         if (TRUE) {
[17:36:38.536]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:38.536]         }
[17:36:38.536]         else {
[17:36:38.536]             ...future.result["stdout"] <- base::list(NULL)
[17:36:38.536]         }
[17:36:38.536]         base::close(...future.stdout)
[17:36:38.536]         ...future.stdout <- NULL
[17:36:38.536]     }
[17:36:38.536]     ...future.result$conditions <- ...future.conditions
[17:36:38.536]     ...future.result$finished <- base::Sys.time()
[17:36:38.536]     ...future.result
[17:36:38.536] }
[17:36:38.539] Exporting 5 global objects (9.77 KiB) to cluster node #1 ...
[17:36:38.539] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:36:38.539] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:36:38.539] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ...
[17:36:38.540] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ... DONE
[17:36:38.540] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:36:38.540] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:36:38.540] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:36:38.541] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:36:38.541] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:36:38.541] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:36:38.541] Exporting 5 global objects (9.77 KiB) to cluster node #1 ... DONE
[17:36:38.542] MultisessionFuture started
[17:36:38.542] - Launch lazy future ... done
[17:36:38.542] run() for ‘MultisessionFuture’ ... done
[17:36:38.542] Created future:
[17:36:38.542] MultisessionFuture:
[17:36:38.542] Label: ‘future_apply-1’
[17:36:38.542] Expression:
[17:36:38.542] {
[17:36:38.542]     do.call(function(...) {
[17:36:38.542]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.542]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:38.542]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.542]             on.exit(options(oopts), add = TRUE)
[17:36:38.542]         }
[17:36:38.542]         {
[17:36:38.542]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:38.542]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.542]                 ...future.FUN(...future.X_jj, ...)
[17:36:38.542]             })
[17:36:38.542]         }
[17:36:38.542]     }, args = future.call.arguments)
[17:36:38.542] }
[17:36:38.542] Lazy evaluation: FALSE
[17:36:38.542] Asynchronous evaluation: TRUE
[17:36:38.542] Local evaluation: TRUE
[17:36:38.542] Environment: R_GlobalEnv
[17:36:38.542] Capture standard output: TRUE
[17:36:38.542] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:38.542] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:38.542] Packages: <none>
[17:36:38.542] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:38.542] Resolved: FALSE
[17:36:38.542] Value: <not collected>
[17:36:38.542] Conditions captured: <none>
[17:36:38.542] Early signaling: FALSE
[17:36:38.542] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:38.542] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.553] Chunk #1 of 2 ... DONE
[17:36:38.554] Chunk #2 of 2 ...
[17:36:38.554]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:38.554]  - seeds: <none>
[17:36:38.554]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.554] getGlobalsAndPackages() ...
[17:36:38.554] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.554] Resolving globals: FALSE
[17:36:38.554] Tweak future expression to call with '...' arguments ...
[17:36:38.554] {
[17:36:38.554]     do.call(function(...) {
[17:36:38.554]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.554]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:38.554]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.554]             on.exit(options(oopts), add = TRUE)
[17:36:38.554]         }
[17:36:38.554]         {
[17:36:38.554]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:38.554]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.554]                 ...future.FUN(...future.X_jj, ...)
[17:36:38.554]             })
[17:36:38.554]         }
[17:36:38.554]     }, args = future.call.arguments)
[17:36:38.554] }
[17:36:38.555] Tweak future expression to call with '...' arguments ... DONE
[17:36:38.555] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.555] 
[17:36:38.555] getGlobalsAndPackages() ... DONE
[17:36:38.555] run() for ‘Future’ ...
[17:36:38.556] - state: ‘created’
[17:36:38.556] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:38.570] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.570] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:38.570]   - Field: ‘node’
[17:36:38.570]   - Field: ‘label’
[17:36:38.570]   - Field: ‘local’
[17:36:38.570]   - Field: ‘owner’
[17:36:38.570]   - Field: ‘envir’
[17:36:38.570]   - Field: ‘workers’
[17:36:38.571]   - Field: ‘packages’
[17:36:38.571]   - Field: ‘gc’
[17:36:38.571]   - Field: ‘conditions’
[17:36:38.571]   - Field: ‘persistent’
[17:36:38.571]   - Field: ‘expr’
[17:36:38.571]   - Field: ‘uuid’
[17:36:38.571]   - Field: ‘seed’
[17:36:38.571]   - Field: ‘version’
[17:36:38.571]   - Field: ‘result’
[17:36:38.571]   - Field: ‘asynchronous’
[17:36:38.571]   - Field: ‘calls’
[17:36:38.572]   - Field: ‘globals’
[17:36:38.572]   - Field: ‘stdout’
[17:36:38.572]   - Field: ‘earlySignal’
[17:36:38.572]   - Field: ‘lazy’
[17:36:38.572]   - Field: ‘state’
[17:36:38.572] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:38.572] - Launch lazy future ...
[17:36:38.572] Packages needed by the future expression (n = 0): <none>
[17:36:38.572] Packages needed by future strategies (n = 0): <none>
[17:36:38.573] {
[17:36:38.573]     {
[17:36:38.573]         {
[17:36:38.573]             ...future.startTime <- base::Sys.time()
[17:36:38.573]             {
[17:36:38.573]                 {
[17:36:38.573]                   {
[17:36:38.573]                     {
[17:36:38.573]                       base::local({
[17:36:38.573]                         has_future <- base::requireNamespace("future", 
[17:36:38.573]                           quietly = TRUE)
[17:36:38.573]                         if (has_future) {
[17:36:38.573]                           ns <- base::getNamespace("future")
[17:36:38.573]                           version <- ns[[".package"]][["version"]]
[17:36:38.573]                           if (is.null(version)) 
[17:36:38.573]                             version <- utils::packageVersion("future")
[17:36:38.573]                         }
[17:36:38.573]                         else {
[17:36:38.573]                           version <- NULL
[17:36:38.573]                         }
[17:36:38.573]                         if (!has_future || version < "1.8.0") {
[17:36:38.573]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:38.573]                             "", base::R.version$version.string), 
[17:36:38.573]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:38.573]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:38.573]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:38.573]                               "release", "version")], collapse = " "), 
[17:36:38.573]                             hostname = base::Sys.info()[["nodename"]])
[17:36:38.573]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:38.573]                             info)
[17:36:38.573]                           info <- base::paste(info, collapse = "; ")
[17:36:38.573]                           if (!has_future) {
[17:36:38.573]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:38.573]                               info)
[17:36:38.573]                           }
[17:36:38.573]                           else {
[17:36:38.573]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:38.573]                               info, version)
[17:36:38.573]                           }
[17:36:38.573]                           base::stop(msg)
[17:36:38.573]                         }
[17:36:38.573]                       })
[17:36:38.573]                     }
[17:36:38.573]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:38.573]                     base::options(mc.cores = 1L)
[17:36:38.573]                   }
[17:36:38.573]                   ...future.strategy.old <- future::plan("list")
[17:36:38.573]                   options(future.plan = NULL)
[17:36:38.573]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:38.573]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:38.573]                 }
[17:36:38.573]                 ...future.workdir <- getwd()
[17:36:38.573]             }
[17:36:38.573]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:38.573]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:38.573]         }
[17:36:38.573]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:38.573]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:38.573]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:38.573]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:38.573]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:38.573]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:38.573]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:38.573]             base::names(...future.oldOptions))
[17:36:38.573]     }
[17:36:38.573]     if (FALSE) {
[17:36:38.573]     }
[17:36:38.573]     else {
[17:36:38.573]         if (TRUE) {
[17:36:38.573]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:38.573]                 open = "w")
[17:36:38.573]         }
[17:36:38.573]         else {
[17:36:38.573]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:38.573]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:38.573]         }
[17:36:38.573]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:38.573]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:38.573]             base::sink(type = "output", split = FALSE)
[17:36:38.573]             base::close(...future.stdout)
[17:36:38.573]         }, add = TRUE)
[17:36:38.573]     }
[17:36:38.573]     ...future.frame <- base::sys.nframe()
[17:36:38.573]     ...future.conditions <- base::list()
[17:36:38.573]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:38.573]     if (FALSE) {
[17:36:38.573]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:38.573]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:38.573]     }
[17:36:38.573]     ...future.result <- base::tryCatch({
[17:36:38.573]         base::withCallingHandlers({
[17:36:38.573]             ...future.value <- base::withVisible(base::local({
[17:36:38.573]                 ...future.makeSendCondition <- base::local({
[17:36:38.573]                   sendCondition <- NULL
[17:36:38.573]                   function(frame = 1L) {
[17:36:38.573]                     if (is.function(sendCondition)) 
[17:36:38.573]                       return(sendCondition)
[17:36:38.573]                     ns <- getNamespace("parallel")
[17:36:38.573]                     if (exists("sendData", mode = "function", 
[17:36:38.573]                       envir = ns)) {
[17:36:38.573]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:38.573]                         envir = ns)
[17:36:38.573]                       envir <- sys.frame(frame)
[17:36:38.573]                       master <- NULL
[17:36:38.573]                       while (!identical(envir, .GlobalEnv) && 
[17:36:38.573]                         !identical(envir, emptyenv())) {
[17:36:38.573]                         if (exists("master", mode = "list", envir = envir, 
[17:36:38.573]                           inherits = FALSE)) {
[17:36:38.573]                           master <- get("master", mode = "list", 
[17:36:38.573]                             envir = envir, inherits = FALSE)
[17:36:38.573]                           if (inherits(master, c("SOCKnode", 
[17:36:38.573]                             "SOCK0node"))) {
[17:36:38.573]                             sendCondition <<- function(cond) {
[17:36:38.573]                               data <- list(type = "VALUE", value = cond, 
[17:36:38.573]                                 success = TRUE)
[17:36:38.573]                               parallel_sendData(master, data)
[17:36:38.573]                             }
[17:36:38.573]                             return(sendCondition)
[17:36:38.573]                           }
[17:36:38.573]                         }
[17:36:38.573]                         frame <- frame + 1L
[17:36:38.573]                         envir <- sys.frame(frame)
[17:36:38.573]                       }
[17:36:38.573]                     }
[17:36:38.573]                     sendCondition <<- function(cond) NULL
[17:36:38.573]                   }
[17:36:38.573]                 })
[17:36:38.573]                 withCallingHandlers({
[17:36:38.573]                   {
[17:36:38.573]                     do.call(function(...) {
[17:36:38.573]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.573]                       if (!identical(...future.globals.maxSize.org, 
[17:36:38.573]                         ...future.globals.maxSize)) {
[17:36:38.573]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.573]                         on.exit(options(oopts), add = TRUE)
[17:36:38.573]                       }
[17:36:38.573]                       {
[17:36:38.573]                         lapply(seq_along(...future.elements_ii), 
[17:36:38.573]                           FUN = function(jj) {
[17:36:38.573]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.573]                             ...future.FUN(...future.X_jj, ...)
[17:36:38.573]                           })
[17:36:38.573]                       }
[17:36:38.573]                     }, args = future.call.arguments)
[17:36:38.573]                   }
[17:36:38.573]                 }, immediateCondition = function(cond) {
[17:36:38.573]                   sendCondition <- ...future.makeSendCondition()
[17:36:38.573]                   sendCondition(cond)
[17:36:38.573]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.573]                   {
[17:36:38.573]                     inherits <- base::inherits
[17:36:38.573]                     invokeRestart <- base::invokeRestart
[17:36:38.573]                     is.null <- base::is.null
[17:36:38.573]                     muffled <- FALSE
[17:36:38.573]                     if (inherits(cond, "message")) {
[17:36:38.573]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:38.573]                       if (muffled) 
[17:36:38.573]                         invokeRestart("muffleMessage")
[17:36:38.573]                     }
[17:36:38.573]                     else if (inherits(cond, "warning")) {
[17:36:38.573]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:38.573]                       if (muffled) 
[17:36:38.573]                         invokeRestart("muffleWarning")
[17:36:38.573]                     }
[17:36:38.573]                     else if (inherits(cond, "condition")) {
[17:36:38.573]                       if (!is.null(pattern)) {
[17:36:38.573]                         computeRestarts <- base::computeRestarts
[17:36:38.573]                         grepl <- base::grepl
[17:36:38.573]                         restarts <- computeRestarts(cond)
[17:36:38.573]                         for (restart in restarts) {
[17:36:38.573]                           name <- restart$name
[17:36:38.573]                           if (is.null(name)) 
[17:36:38.573]                             next
[17:36:38.573]                           if (!grepl(pattern, name)) 
[17:36:38.573]                             next
[17:36:38.573]                           invokeRestart(restart)
[17:36:38.573]                           muffled <- TRUE
[17:36:38.573]                           break
[17:36:38.573]                         }
[17:36:38.573]                       }
[17:36:38.573]                     }
[17:36:38.573]                     invisible(muffled)
[17:36:38.573]                   }
[17:36:38.573]                   muffleCondition(cond)
[17:36:38.573]                 })
[17:36:38.573]             }))
[17:36:38.573]             future::FutureResult(value = ...future.value$value, 
[17:36:38.573]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:38.573]                   ...future.rng), globalenv = if (FALSE) 
[17:36:38.573]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:38.573]                     ...future.globalenv.names))
[17:36:38.573]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:38.573]         }, condition = base::local({
[17:36:38.573]             c <- base::c
[17:36:38.573]             inherits <- base::inherits
[17:36:38.573]             invokeRestart <- base::invokeRestart
[17:36:38.573]             length <- base::length
[17:36:38.573]             list <- base::list
[17:36:38.573]             seq.int <- base::seq.int
[17:36:38.573]             signalCondition <- base::signalCondition
[17:36:38.573]             sys.calls <- base::sys.calls
[17:36:38.573]             `[[` <- base::`[[`
[17:36:38.573]             `+` <- base::`+`
[17:36:38.573]             `<<-` <- base::`<<-`
[17:36:38.573]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:38.573]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:38.573]                   3L)]
[17:36:38.573]             }
[17:36:38.573]             function(cond) {
[17:36:38.573]                 is_error <- inherits(cond, "error")
[17:36:38.573]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:38.573]                   NULL)
[17:36:38.573]                 if (is_error) {
[17:36:38.573]                   sessionInformation <- function() {
[17:36:38.573]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:38.573]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:38.573]                       search = base::search(), system = base::Sys.info())
[17:36:38.573]                   }
[17:36:38.573]                   ...future.conditions[[length(...future.conditions) + 
[17:36:38.573]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:38.573]                     cond$call), session = sessionInformation(), 
[17:36:38.573]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:38.573]                   signalCondition(cond)
[17:36:38.573]                 }
[17:36:38.573]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:38.573]                 "immediateCondition"))) {
[17:36:38.573]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:38.573]                   ...future.conditions[[length(...future.conditions) + 
[17:36:38.573]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:38.573]                   if (TRUE && !signal) {
[17:36:38.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.573]                     {
[17:36:38.573]                       inherits <- base::inherits
[17:36:38.573]                       invokeRestart <- base::invokeRestart
[17:36:38.573]                       is.null <- base::is.null
[17:36:38.573]                       muffled <- FALSE
[17:36:38.573]                       if (inherits(cond, "message")) {
[17:36:38.573]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:38.573]                         if (muffled) 
[17:36:38.573]                           invokeRestart("muffleMessage")
[17:36:38.573]                       }
[17:36:38.573]                       else if (inherits(cond, "warning")) {
[17:36:38.573]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:38.573]                         if (muffled) 
[17:36:38.573]                           invokeRestart("muffleWarning")
[17:36:38.573]                       }
[17:36:38.573]                       else if (inherits(cond, "condition")) {
[17:36:38.573]                         if (!is.null(pattern)) {
[17:36:38.573]                           computeRestarts <- base::computeRestarts
[17:36:38.573]                           grepl <- base::grepl
[17:36:38.573]                           restarts <- computeRestarts(cond)
[17:36:38.573]                           for (restart in restarts) {
[17:36:38.573]                             name <- restart$name
[17:36:38.573]                             if (is.null(name)) 
[17:36:38.573]                               next
[17:36:38.573]                             if (!grepl(pattern, name)) 
[17:36:38.573]                               next
[17:36:38.573]                             invokeRestart(restart)
[17:36:38.573]                             muffled <- TRUE
[17:36:38.573]                             break
[17:36:38.573]                           }
[17:36:38.573]                         }
[17:36:38.573]                       }
[17:36:38.573]                       invisible(muffled)
[17:36:38.573]                     }
[17:36:38.573]                     muffleCondition(cond, pattern = "^muffle")
[17:36:38.573]                   }
[17:36:38.573]                 }
[17:36:38.573]                 else {
[17:36:38.573]                   if (TRUE) {
[17:36:38.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.573]                     {
[17:36:38.573]                       inherits <- base::inherits
[17:36:38.573]                       invokeRestart <- base::invokeRestart
[17:36:38.573]                       is.null <- base::is.null
[17:36:38.573]                       muffled <- FALSE
[17:36:38.573]                       if (inherits(cond, "message")) {
[17:36:38.573]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:38.573]                         if (muffled) 
[17:36:38.573]                           invokeRestart("muffleMessage")
[17:36:38.573]                       }
[17:36:38.573]                       else if (inherits(cond, "warning")) {
[17:36:38.573]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:38.573]                         if (muffled) 
[17:36:38.573]                           invokeRestart("muffleWarning")
[17:36:38.573]                       }
[17:36:38.573]                       else if (inherits(cond, "condition")) {
[17:36:38.573]                         if (!is.null(pattern)) {
[17:36:38.573]                           computeRestarts <- base::computeRestarts
[17:36:38.573]                           grepl <- base::grepl
[17:36:38.573]                           restarts <- computeRestarts(cond)
[17:36:38.573]                           for (restart in restarts) {
[17:36:38.573]                             name <- restart$name
[17:36:38.573]                             if (is.null(name)) 
[17:36:38.573]                               next
[17:36:38.573]                             if (!grepl(pattern, name)) 
[17:36:38.573]                               next
[17:36:38.573]                             invokeRestart(restart)
[17:36:38.573]                             muffled <- TRUE
[17:36:38.573]                             break
[17:36:38.573]                           }
[17:36:38.573]                         }
[17:36:38.573]                       }
[17:36:38.573]                       invisible(muffled)
[17:36:38.573]                     }
[17:36:38.573]                     muffleCondition(cond, pattern = "^muffle")
[17:36:38.573]                   }
[17:36:38.573]                 }
[17:36:38.573]             }
[17:36:38.573]         }))
[17:36:38.573]     }, error = function(ex) {
[17:36:38.573]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:38.573]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:38.573]                 ...future.rng), started = ...future.startTime, 
[17:36:38.573]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:38.573]             version = "1.8"), class = "FutureResult")
[17:36:38.573]     }, finally = {
[17:36:38.573]         if (!identical(...future.workdir, getwd())) 
[17:36:38.573]             setwd(...future.workdir)
[17:36:38.573]         {
[17:36:38.573]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:38.573]                 ...future.oldOptions$nwarnings <- NULL
[17:36:38.573]             }
[17:36:38.573]             base::options(...future.oldOptions)
[17:36:38.573]             if (.Platform$OS.type == "windows") {
[17:36:38.573]                 old_names <- names(...future.oldEnvVars)
[17:36:38.573]                 envs <- base::Sys.getenv()
[17:36:38.573]                 names <- names(envs)
[17:36:38.573]                 common <- intersect(names, old_names)
[17:36:38.573]                 added <- setdiff(names, old_names)
[17:36:38.573]                 removed <- setdiff(old_names, names)
[17:36:38.573]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:38.573]                   envs[common]]
[17:36:38.573]                 NAMES <- toupper(changed)
[17:36:38.573]                 args <- list()
[17:36:38.573]                 for (kk in seq_along(NAMES)) {
[17:36:38.573]                   name <- changed[[kk]]
[17:36:38.573]                   NAME <- NAMES[[kk]]
[17:36:38.573]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.573]                     next
[17:36:38.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:38.573]                 }
[17:36:38.573]                 NAMES <- toupper(added)
[17:36:38.573]                 for (kk in seq_along(NAMES)) {
[17:36:38.573]                   name <- added[[kk]]
[17:36:38.573]                   NAME <- NAMES[[kk]]
[17:36:38.573]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.573]                     next
[17:36:38.573]                   args[[name]] <- ""
[17:36:38.573]                 }
[17:36:38.573]                 NAMES <- toupper(removed)
[17:36:38.573]                 for (kk in seq_along(NAMES)) {
[17:36:38.573]                   name <- removed[[kk]]
[17:36:38.573]                   NAME <- NAMES[[kk]]
[17:36:38.573]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.573]                     next
[17:36:38.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:38.573]                 }
[17:36:38.573]                 if (length(args) > 0) 
[17:36:38.573]                   base::do.call(base::Sys.setenv, args = args)
[17:36:38.573]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:38.573]             }
[17:36:38.573]             else {
[17:36:38.573]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:38.573]             }
[17:36:38.573]             {
[17:36:38.573]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:38.573]                   0L) {
[17:36:38.573]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:38.573]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:38.573]                   base::options(opts)
[17:36:38.573]                 }
[17:36:38.573]                 {
[17:36:38.573]                   {
[17:36:38.573]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:38.573]                     NULL
[17:36:38.573]                   }
[17:36:38.573]                   options(future.plan = NULL)
[17:36:38.573]                   if (is.na(NA_character_)) 
[17:36:38.573]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:38.573]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:38.573]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:38.573]                     .init = FALSE)
[17:36:38.573]                 }
[17:36:38.573]             }
[17:36:38.573]         }
[17:36:38.573]     })
[17:36:38.573]     if (TRUE) {
[17:36:38.573]         base::sink(type = "output", split = FALSE)
[17:36:38.573]         if (TRUE) {
[17:36:38.573]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:38.573]         }
[17:36:38.573]         else {
[17:36:38.573]             ...future.result["stdout"] <- base::list(NULL)
[17:36:38.573]         }
[17:36:38.573]         base::close(...future.stdout)
[17:36:38.573]         ...future.stdout <- NULL
[17:36:38.573]     }
[17:36:38.573]     ...future.result$conditions <- ...future.conditions
[17:36:38.573]     ...future.result$finished <- base::Sys.time()
[17:36:38.573]     ...future.result
[17:36:38.573] }
[17:36:38.576] Exporting 5 global objects (9.77 KiB) to cluster node #2 ...
[17:36:38.576] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:36:38.577] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:36:38.579] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ...
[17:36:38.580] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ... DONE
[17:36:38.580] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:36:38.580] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:36:38.580] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:36:38.580] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:36:38.581] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:36:38.581] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:36:38.581] Exporting 5 global objects (9.77 KiB) to cluster node #2 ... DONE
[17:36:38.581] MultisessionFuture started
[17:36:38.582] - Launch lazy future ... done
[17:36:38.582] run() for ‘MultisessionFuture’ ... done
[17:36:38.582] Created future:
[17:36:38.582] MultisessionFuture:
[17:36:38.582] Label: ‘future_apply-2’
[17:36:38.582] Expression:
[17:36:38.582] {
[17:36:38.582]     do.call(function(...) {
[17:36:38.582]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.582]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:38.582]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.582]             on.exit(options(oopts), add = TRUE)
[17:36:38.582]         }
[17:36:38.582]         {
[17:36:38.582]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:38.582]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.582]                 ...future.FUN(...future.X_jj, ...)
[17:36:38.582]             })
[17:36:38.582]         }
[17:36:38.582]     }, args = future.call.arguments)
[17:36:38.582] }
[17:36:38.582] Lazy evaluation: FALSE
[17:36:38.582] Asynchronous evaluation: TRUE
[17:36:38.582] Local evaluation: TRUE
[17:36:38.582] Environment: R_GlobalEnv
[17:36:38.582] Capture standard output: TRUE
[17:36:38.582] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:38.582] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:38.582] Packages: <none>
[17:36:38.582] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:38.582] Resolved: FALSE
[17:36:38.582] Value: <not collected>
[17:36:38.582] Conditions captured: <none>
[17:36:38.582] Early signaling: FALSE
[17:36:38.582] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:38.582] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.593] Chunk #2 of 2 ... DONE
[17:36:38.593] Launching 2 futures (chunks) ... DONE
[17:36:38.593] Resolving 2 futures (chunks) ...
[17:36:38.594] resolve() on list ...
[17:36:38.594]  recursive: 0
[17:36:38.594]  length: 2
[17:36:38.594] 
[17:36:38.594] receiveMessageFromWorker() for ClusterFuture ...
[17:36:38.594] - Validating connection of MultisessionFuture
[17:36:38.595] - received message: FutureResult
[17:36:38.595] - Received FutureResult
[17:36:38.595] - Erased future from FutureRegistry
[17:36:38.595] result() for ClusterFuture ...
[17:36:38.595] - result already collected: FutureResult
[17:36:38.595] result() for ClusterFuture ... done
[17:36:38.595] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:38.595] Future #1
[17:36:38.595] result() for ClusterFuture ...
[17:36:38.595] - result already collected: FutureResult
[17:36:38.595] result() for ClusterFuture ... done
[17:36:38.596] result() for ClusterFuture ...
[17:36:38.596] - result already collected: FutureResult
[17:36:38.596] result() for ClusterFuture ... done
[17:36:38.596] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:36:38.596] - nx: 2
[17:36:38.596] - relay: TRUE
[17:36:38.596] - stdout: TRUE
[17:36:38.596] - signal: TRUE
[17:36:38.596] - resignal: FALSE
[17:36:38.596] - force: TRUE
[17:36:38.596] - relayed: [n=2] FALSE, FALSE
[17:36:38.596] - queued futures: [n=2] FALSE, FALSE
[17:36:38.597]  - until=1
[17:36:38.597]  - relaying element #1
[17:36:38.597] result() for ClusterFuture ...
[17:36:38.597] - result already collected: FutureResult
[17:36:38.597] result() for ClusterFuture ... done
[17:36:38.597] result() for ClusterFuture ...
[17:36:38.597] - result already collected: FutureResult
[17:36:38.597] result() for ClusterFuture ... done
[17:36:38.597] result() for ClusterFuture ...
[17:36:38.597] - result already collected: FutureResult
[17:36:38.597] result() for ClusterFuture ... done
[17:36:38.598] result() for ClusterFuture ...
[17:36:38.598] - result already collected: FutureResult
[17:36:38.598] result() for ClusterFuture ... done
[17:36:38.598] - relayed: [n=2] TRUE, FALSE
[17:36:38.598] - queued futures: [n=2] TRUE, FALSE
[17:36:38.598] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:36:38.598]  length: 1 (resolved future 1)
[17:36:38.626] receiveMessageFromWorker() for ClusterFuture ...
[17:36:38.626] - Validating connection of MultisessionFuture
[17:36:38.626] - received message: FutureResult
[17:36:38.626] - Received FutureResult
[17:36:38.627] - Erased future from FutureRegistry
[17:36:38.627] result() for ClusterFuture ...
[17:36:38.627] - result already collected: FutureResult
[17:36:38.627] result() for ClusterFuture ... done
[17:36:38.627] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:38.627] Future #2
[17:36:38.627] result() for ClusterFuture ...
[17:36:38.627] - result already collected: FutureResult
[17:36:38.627] result() for ClusterFuture ... done
[17:36:38.627] result() for ClusterFuture ...
[17:36:38.627] - result already collected: FutureResult
[17:36:38.628] result() for ClusterFuture ... done
[17:36:38.628] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:36:38.628] - nx: 2
[17:36:38.628] - relay: TRUE
[17:36:38.628] - stdout: TRUE
[17:36:38.628] - signal: TRUE
[17:36:38.628] - resignal: FALSE
[17:36:38.628] - force: TRUE
[17:36:38.628] - relayed: [n=2] TRUE, FALSE
[17:36:38.628] - queued futures: [n=2] TRUE, FALSE
[17:36:38.628]  - until=2
[17:36:38.628]  - relaying element #2
[17:36:38.629] result() for ClusterFuture ...
[17:36:38.629] - result already collected: FutureResult
[17:36:38.629] result() for ClusterFuture ... done
[17:36:38.629] result() for ClusterFuture ...
[17:36:38.629] - result already collected: FutureResult
[17:36:38.629] result() for ClusterFuture ... done
[17:36:38.629] result() for ClusterFuture ...
[17:36:38.629] - result already collected: FutureResult
[17:36:38.629] result() for ClusterFuture ... done
[17:36:38.629] result() for ClusterFuture ...
[17:36:38.629] - result already collected: FutureResult
[17:36:38.630] result() for ClusterFuture ... done
[17:36:38.630] - relayed: [n=2] TRUE, TRUE
[17:36:38.630] - queued futures: [n=2] TRUE, TRUE
[17:36:38.630] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:36:38.630]  length: 0 (resolved future 2)
[17:36:38.630] Relaying remaining futures
[17:36:38.630] signalConditionsASAP(NULL, pos=0) ...
[17:36:38.630] - nx: 2
[17:36:38.630] - relay: TRUE
[17:36:38.630] - stdout: TRUE
[17:36:38.630] - signal: TRUE
[17:36:38.630] - resignal: FALSE
[17:36:38.630] - force: TRUE
[17:36:38.631] - relayed: [n=2] TRUE, TRUE
[17:36:38.631] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:38.631] - relayed: [n=2] TRUE, TRUE
[17:36:38.631] - queued futures: [n=2] TRUE, TRUE
[17:36:38.631] signalConditionsASAP(NULL, pos=0) ... done
[17:36:38.631] resolve() on list ... DONE
[17:36:38.631] result() for ClusterFuture ...
[17:36:38.631] - result already collected: FutureResult
[17:36:38.631] result() for ClusterFuture ... done
[17:36:38.631] result() for ClusterFuture ...
[17:36:38.631] - result already collected: FutureResult
[17:36:38.632] result() for ClusterFuture ... done
[17:36:38.632] result() for ClusterFuture ...
[17:36:38.632] - result already collected: FutureResult
[17:36:38.632] result() for ClusterFuture ... done
[17:36:38.632] result() for ClusterFuture ...
[17:36:38.632] - result already collected: FutureResult
[17:36:38.632] result() for ClusterFuture ... done
[17:36:38.632]  - Number of value chunks collected: 2
[17:36:38.632] Resolving 2 futures (chunks) ... DONE
[17:36:38.632] Reducing values from 2 chunks ...
[17:36:38.632]  - Number of values collected after concatenation: 2
[17:36:38.633]  - Number of values expected: 2
[17:36:38.633] Reducing values from 2 chunks ... DONE
[17:36:38.633] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[17:36:38.633] getGlobalsAndPackagesXApply() ...
[17:36:38.633]  - future.globals: TRUE
[17:36:38.633] getGlobalsAndPackages() ...
[17:36:38.633] Searching for globals...
[17:36:38.636] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[17:36:38.636] Searching for globals ... DONE
[17:36:38.636] Resolving globals: FALSE
[17:36:38.637] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[17:36:38.637] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[17:36:38.637] - globals: [1] ‘FUN’
[17:36:38.637] 
[17:36:38.638] getGlobalsAndPackages() ... DONE
[17:36:38.638]  - globals found/used: [n=1] ‘FUN’
[17:36:38.638]  - needed namespaces: [n=0] 
[17:36:38.638] Finding globals ... DONE
[17:36:38.638]  - use_args: TRUE
[17:36:38.638]  - Getting '...' globals ...
[17:36:38.638] resolve() on list ...
[17:36:38.638]  recursive: 0
[17:36:38.639]  length: 1
[17:36:38.639]  elements: ‘...’
[17:36:38.639]  length: 0 (resolved future 1)
[17:36:38.639] resolve() on list ... DONE
[17:36:38.639]    - '...' content: [n=0] 
[17:36:38.639] List of 1
[17:36:38.639]  $ ...: list()
[17:36:38.639]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:38.639]  - attr(*, "where")=List of 1
[17:36:38.639]   ..$ ...:<environment: 0x556d7517e8b8> 
[17:36:38.639]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:38.639]  - attr(*, "resolved")= logi TRUE
[17:36:38.639]  - attr(*, "total_size")= num NA
[17:36:38.641]  - Getting '...' globals ... DONE
[17:36:38.642] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:38.642] List of 2
[17:36:38.642]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:36:38.642]  $ ...          : list()
[17:36:38.642]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:38.642]  - attr(*, "where")=List of 2
[17:36:38.642]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:38.642]   ..$ ...          :<environment: 0x556d7517e8b8> 
[17:36:38.642]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:38.642]  - attr(*, "resolved")= logi FALSE
[17:36:38.642]  - attr(*, "total_size")= num 36296
[17:36:38.644] Packages to be attached in all futures: [n=0] 
[17:36:38.644] getGlobalsAndPackagesXApply() ... DONE
[17:36:38.648] future_lapply() ...
[17:36:38.650] Generating random seeds ...
[17:36:38.651] Generating random seed streams for 2 elements ...
[17:36:38.651] Generating random seed streams for 2 elements ... DONE
[17:36:38.651] Generating random seeds ... DONE
[17:36:38.651] Will set RNG state on exit: 10407, 655939326, -599037644, 635149807, 953392828, -769601519, -1902258204
[17:36:38.654] Number of chunks: 2
[17:36:38.654] getGlobalsAndPackagesXApply() ...
[17:36:38.654]  - future.globals: <name-value list> with names ‘list()’
[17:36:38.655]  - use_args: TRUE
[17:36:38.655] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:36:38.655] List of 2
[17:36:38.655]  $ ...          : list()
[17:36:38.655]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:38.655]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:36:38.655]  - attr(*, "where")=List of 2
[17:36:38.655]   ..$ ...          :<environment: 0x556d7517e8b8> 
[17:36:38.655]   ..$ ...future.FUN:<environment: namespace:base> 
[17:36:38.655]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:38.655]  - attr(*, "resolved")= logi FALSE
[17:36:38.655]  - attr(*, "total_size")= num NA
[17:36:38.658] Packages to be attached in all futures: [n=0] 
[17:36:38.658] getGlobalsAndPackagesXApply() ... DONE
[17:36:38.658] Number of futures (= number of chunks): 2
[17:36:38.659] Launching 2 futures (chunks) ...
[17:36:38.659] Chunk #1 of 2 ...
[17:36:38.659]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:38.659]  - seeds: [1] <seeds>
[17:36:38.659]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.659] getGlobalsAndPackages() ...
[17:36:38.659] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.659] Resolving globals: FALSE
[17:36:38.659] Tweak future expression to call with '...' arguments ...
[17:36:38.660] {
[17:36:38.660]     do.call(function(...) {
[17:36:38.660]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.660]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:38.660]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.660]             on.exit(options(oopts), add = TRUE)
[17:36:38.660]         }
[17:36:38.660]         {
[17:36:38.660]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:38.660]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.660]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:36:38.660]                   envir = globalenv(), inherits = FALSE)
[17:36:38.660]                 ...future.FUN(...future.X_jj, ...)
[17:36:38.660]             })
[17:36:38.660]         }
[17:36:38.660]     }, args = future.call.arguments)
[17:36:38.660] }
[17:36:38.660] Tweak future expression to call with '...' arguments ... DONE
[17:36:38.660] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.660] 
[17:36:38.660] getGlobalsAndPackages() ... DONE
[17:36:38.661] run() for ‘Future’ ...
[17:36:38.661] - state: ‘created’
[17:36:38.661] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:38.674] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.675] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:38.675]   - Field: ‘node’
[17:36:38.675]   - Field: ‘label’
[17:36:38.675]   - Field: ‘local’
[17:36:38.675]   - Field: ‘owner’
[17:36:38.675]   - Field: ‘envir’
[17:36:38.675]   - Field: ‘workers’
[17:36:38.675]   - Field: ‘packages’
[17:36:38.675]   - Field: ‘gc’
[17:36:38.675]   - Field: ‘conditions’
[17:36:38.676]   - Field: ‘persistent’
[17:36:38.676]   - Field: ‘expr’
[17:36:38.676]   - Field: ‘uuid’
[17:36:38.676]   - Field: ‘seed’
[17:36:38.676]   - Field: ‘version’
[17:36:38.676]   - Field: ‘result’
[17:36:38.676]   - Field: ‘asynchronous’
[17:36:38.676]   - Field: ‘calls’
[17:36:38.676]   - Field: ‘globals’
[17:36:38.676]   - Field: ‘stdout’
[17:36:38.676]   - Field: ‘earlySignal’
[17:36:38.677]   - Field: ‘lazy’
[17:36:38.677]   - Field: ‘state’
[17:36:38.677] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:38.677] - Launch lazy future ...
[17:36:38.677] Packages needed by the future expression (n = 0): <none>
[17:36:38.677] Packages needed by future strategies (n = 0): <none>
[17:36:38.678] {
[17:36:38.678]     {
[17:36:38.678]         {
[17:36:38.678]             ...future.startTime <- base::Sys.time()
[17:36:38.678]             {
[17:36:38.678]                 {
[17:36:38.678]                   {
[17:36:38.678]                     {
[17:36:38.678]                       base::local({
[17:36:38.678]                         has_future <- base::requireNamespace("future", 
[17:36:38.678]                           quietly = TRUE)
[17:36:38.678]                         if (has_future) {
[17:36:38.678]                           ns <- base::getNamespace("future")
[17:36:38.678]                           version <- ns[[".package"]][["version"]]
[17:36:38.678]                           if (is.null(version)) 
[17:36:38.678]                             version <- utils::packageVersion("future")
[17:36:38.678]                         }
[17:36:38.678]                         else {
[17:36:38.678]                           version <- NULL
[17:36:38.678]                         }
[17:36:38.678]                         if (!has_future || version < "1.8.0") {
[17:36:38.678]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:38.678]                             "", base::R.version$version.string), 
[17:36:38.678]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:38.678]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:38.678]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:38.678]                               "release", "version")], collapse = " "), 
[17:36:38.678]                             hostname = base::Sys.info()[["nodename"]])
[17:36:38.678]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:38.678]                             info)
[17:36:38.678]                           info <- base::paste(info, collapse = "; ")
[17:36:38.678]                           if (!has_future) {
[17:36:38.678]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:38.678]                               info)
[17:36:38.678]                           }
[17:36:38.678]                           else {
[17:36:38.678]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:38.678]                               info, version)
[17:36:38.678]                           }
[17:36:38.678]                           base::stop(msg)
[17:36:38.678]                         }
[17:36:38.678]                       })
[17:36:38.678]                     }
[17:36:38.678]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:38.678]                     base::options(mc.cores = 1L)
[17:36:38.678]                   }
[17:36:38.678]                   ...future.strategy.old <- future::plan("list")
[17:36:38.678]                   options(future.plan = NULL)
[17:36:38.678]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:38.678]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:38.678]                 }
[17:36:38.678]                 ...future.workdir <- getwd()
[17:36:38.678]             }
[17:36:38.678]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:38.678]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:38.678]         }
[17:36:38.678]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:38.678]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:38.678]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:38.678]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:38.678]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:38.678]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:38.678]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:38.678]             base::names(...future.oldOptions))
[17:36:38.678]     }
[17:36:38.678]     if (FALSE) {
[17:36:38.678]     }
[17:36:38.678]     else {
[17:36:38.678]         if (TRUE) {
[17:36:38.678]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:38.678]                 open = "w")
[17:36:38.678]         }
[17:36:38.678]         else {
[17:36:38.678]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:38.678]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:38.678]         }
[17:36:38.678]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:38.678]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:38.678]             base::sink(type = "output", split = FALSE)
[17:36:38.678]             base::close(...future.stdout)
[17:36:38.678]         }, add = TRUE)
[17:36:38.678]     }
[17:36:38.678]     ...future.frame <- base::sys.nframe()
[17:36:38.678]     ...future.conditions <- base::list()
[17:36:38.678]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:38.678]     if (FALSE) {
[17:36:38.678]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:38.678]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:38.678]     }
[17:36:38.678]     ...future.result <- base::tryCatch({
[17:36:38.678]         base::withCallingHandlers({
[17:36:38.678]             ...future.value <- base::withVisible(base::local({
[17:36:38.678]                 ...future.makeSendCondition <- base::local({
[17:36:38.678]                   sendCondition <- NULL
[17:36:38.678]                   function(frame = 1L) {
[17:36:38.678]                     if (is.function(sendCondition)) 
[17:36:38.678]                       return(sendCondition)
[17:36:38.678]                     ns <- getNamespace("parallel")
[17:36:38.678]                     if (exists("sendData", mode = "function", 
[17:36:38.678]                       envir = ns)) {
[17:36:38.678]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:38.678]                         envir = ns)
[17:36:38.678]                       envir <- sys.frame(frame)
[17:36:38.678]                       master <- NULL
[17:36:38.678]                       while (!identical(envir, .GlobalEnv) && 
[17:36:38.678]                         !identical(envir, emptyenv())) {
[17:36:38.678]                         if (exists("master", mode = "list", envir = envir, 
[17:36:38.678]                           inherits = FALSE)) {
[17:36:38.678]                           master <- get("master", mode = "list", 
[17:36:38.678]                             envir = envir, inherits = FALSE)
[17:36:38.678]                           if (inherits(master, c("SOCKnode", 
[17:36:38.678]                             "SOCK0node"))) {
[17:36:38.678]                             sendCondition <<- function(cond) {
[17:36:38.678]                               data <- list(type = "VALUE", value = cond, 
[17:36:38.678]                                 success = TRUE)
[17:36:38.678]                               parallel_sendData(master, data)
[17:36:38.678]                             }
[17:36:38.678]                             return(sendCondition)
[17:36:38.678]                           }
[17:36:38.678]                         }
[17:36:38.678]                         frame <- frame + 1L
[17:36:38.678]                         envir <- sys.frame(frame)
[17:36:38.678]                       }
[17:36:38.678]                     }
[17:36:38.678]                     sendCondition <<- function(cond) NULL
[17:36:38.678]                   }
[17:36:38.678]                 })
[17:36:38.678]                 withCallingHandlers({
[17:36:38.678]                   {
[17:36:38.678]                     do.call(function(...) {
[17:36:38.678]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.678]                       if (!identical(...future.globals.maxSize.org, 
[17:36:38.678]                         ...future.globals.maxSize)) {
[17:36:38.678]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.678]                         on.exit(options(oopts), add = TRUE)
[17:36:38.678]                       }
[17:36:38.678]                       {
[17:36:38.678]                         lapply(seq_along(...future.elements_ii), 
[17:36:38.678]                           FUN = function(jj) {
[17:36:38.678]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.678]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:36:38.678]                               envir = globalenv(), inherits = FALSE)
[17:36:38.678]                             ...future.FUN(...future.X_jj, ...)
[17:36:38.678]                           })
[17:36:38.678]                       }
[17:36:38.678]                     }, args = future.call.arguments)
[17:36:38.678]                   }
[17:36:38.678]                 }, immediateCondition = function(cond) {
[17:36:38.678]                   sendCondition <- ...future.makeSendCondition()
[17:36:38.678]                   sendCondition(cond)
[17:36:38.678]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.678]                   {
[17:36:38.678]                     inherits <- base::inherits
[17:36:38.678]                     invokeRestart <- base::invokeRestart
[17:36:38.678]                     is.null <- base::is.null
[17:36:38.678]                     muffled <- FALSE
[17:36:38.678]                     if (inherits(cond, "message")) {
[17:36:38.678]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:38.678]                       if (muffled) 
[17:36:38.678]                         invokeRestart("muffleMessage")
[17:36:38.678]                     }
[17:36:38.678]                     else if (inherits(cond, "warning")) {
[17:36:38.678]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:38.678]                       if (muffled) 
[17:36:38.678]                         invokeRestart("muffleWarning")
[17:36:38.678]                     }
[17:36:38.678]                     else if (inherits(cond, "condition")) {
[17:36:38.678]                       if (!is.null(pattern)) {
[17:36:38.678]                         computeRestarts <- base::computeRestarts
[17:36:38.678]                         grepl <- base::grepl
[17:36:38.678]                         restarts <- computeRestarts(cond)
[17:36:38.678]                         for (restart in restarts) {
[17:36:38.678]                           name <- restart$name
[17:36:38.678]                           if (is.null(name)) 
[17:36:38.678]                             next
[17:36:38.678]                           if (!grepl(pattern, name)) 
[17:36:38.678]                             next
[17:36:38.678]                           invokeRestart(restart)
[17:36:38.678]                           muffled <- TRUE
[17:36:38.678]                           break
[17:36:38.678]                         }
[17:36:38.678]                       }
[17:36:38.678]                     }
[17:36:38.678]                     invisible(muffled)
[17:36:38.678]                   }
[17:36:38.678]                   muffleCondition(cond)
[17:36:38.678]                 })
[17:36:38.678]             }))
[17:36:38.678]             future::FutureResult(value = ...future.value$value, 
[17:36:38.678]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:38.678]                   ...future.rng), globalenv = if (FALSE) 
[17:36:38.678]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:38.678]                     ...future.globalenv.names))
[17:36:38.678]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:38.678]         }, condition = base::local({
[17:36:38.678]             c <- base::c
[17:36:38.678]             inherits <- base::inherits
[17:36:38.678]             invokeRestart <- base::invokeRestart
[17:36:38.678]             length <- base::length
[17:36:38.678]             list <- base::list
[17:36:38.678]             seq.int <- base::seq.int
[17:36:38.678]             signalCondition <- base::signalCondition
[17:36:38.678]             sys.calls <- base::sys.calls
[17:36:38.678]             `[[` <- base::`[[`
[17:36:38.678]             `+` <- base::`+`
[17:36:38.678]             `<<-` <- base::`<<-`
[17:36:38.678]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:38.678]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:38.678]                   3L)]
[17:36:38.678]             }
[17:36:38.678]             function(cond) {
[17:36:38.678]                 is_error <- inherits(cond, "error")
[17:36:38.678]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:38.678]                   NULL)
[17:36:38.678]                 if (is_error) {
[17:36:38.678]                   sessionInformation <- function() {
[17:36:38.678]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:38.678]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:38.678]                       search = base::search(), system = base::Sys.info())
[17:36:38.678]                   }
[17:36:38.678]                   ...future.conditions[[length(...future.conditions) + 
[17:36:38.678]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:38.678]                     cond$call), session = sessionInformation(), 
[17:36:38.678]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:38.678]                   signalCondition(cond)
[17:36:38.678]                 }
[17:36:38.678]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[17:36:38.678]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:38.678]                   ...future.conditions[[length(...future.conditions) + 
[17:36:38.678]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:38.678]                   if (TRUE && !signal) {
[17:36:38.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.678]                     {
[17:36:38.678]                       inherits <- base::inherits
[17:36:38.678]                       invokeRestart <- base::invokeRestart
[17:36:38.678]                       is.null <- base::is.null
[17:36:38.678]                       muffled <- FALSE
[17:36:38.678]                       if (inherits(cond, "message")) {
[17:36:38.678]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:38.678]                         if (muffled) 
[17:36:38.678]                           invokeRestart("muffleMessage")
[17:36:38.678]                       }
[17:36:38.678]                       else if (inherits(cond, "warning")) {
[17:36:38.678]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:38.678]                         if (muffled) 
[17:36:38.678]                           invokeRestart("muffleWarning")
[17:36:38.678]                       }
[17:36:38.678]                       else if (inherits(cond, "condition")) {
[17:36:38.678]                         if (!is.null(pattern)) {
[17:36:38.678]                           computeRestarts <- base::computeRestarts
[17:36:38.678]                           grepl <- base::grepl
[17:36:38.678]                           restarts <- computeRestarts(cond)
[17:36:38.678]                           for (restart in restarts) {
[17:36:38.678]                             name <- restart$name
[17:36:38.678]                             if (is.null(name)) 
[17:36:38.678]                               next
[17:36:38.678]                             if (!grepl(pattern, name)) 
[17:36:38.678]                               next
[17:36:38.678]                             invokeRestart(restart)
[17:36:38.678]                             muffled <- TRUE
[17:36:38.678]                             break
[17:36:38.678]                           }
[17:36:38.678]                         }
[17:36:38.678]                       }
[17:36:38.678]                       invisible(muffled)
[17:36:38.678]                     }
[17:36:38.678]                     muffleCondition(cond, pattern = "^muffle")
[17:36:38.678]                   }
[17:36:38.678]                 }
[17:36:38.678]                 else {
[17:36:38.678]                   if (TRUE) {
[17:36:38.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.678]                     {
[17:36:38.678]                       inherits <- base::inherits
[17:36:38.678]                       invokeRestart <- base::invokeRestart
[17:36:38.678]                       is.null <- base::is.null
[17:36:38.678]                       muffled <- FALSE
[17:36:38.678]                       if (inherits(cond, "message")) {
[17:36:38.678]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:38.678]                         if (muffled) 
[17:36:38.678]                           invokeRestart("muffleMessage")
[17:36:38.678]                       }
[17:36:38.678]                       else if (inherits(cond, "warning")) {
[17:36:38.678]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:38.678]                         if (muffled) 
[17:36:38.678]                           invokeRestart("muffleWarning")
[17:36:38.678]                       }
[17:36:38.678]                       else if (inherits(cond, "condition")) {
[17:36:38.678]                         if (!is.null(pattern)) {
[17:36:38.678]                           computeRestarts <- base::computeRestarts
[17:36:38.678]                           grepl <- base::grepl
[17:36:38.678]                           restarts <- computeRestarts(cond)
[17:36:38.678]                           for (restart in restarts) {
[17:36:38.678]                             name <- restart$name
[17:36:38.678]                             if (is.null(name)) 
[17:36:38.678]                               next
[17:36:38.678]                             if (!grepl(pattern, name)) 
[17:36:38.678]                               next
[17:36:38.678]                             invokeRestart(restart)
[17:36:38.678]                             muffled <- TRUE
[17:36:38.678]                             break
[17:36:38.678]                           }
[17:36:38.678]                         }
[17:36:38.678]                       }
[17:36:38.678]                       invisible(muffled)
[17:36:38.678]                     }
[17:36:38.678]                     muffleCondition(cond, pattern = "^muffle")
[17:36:38.678]                   }
[17:36:38.678]                 }
[17:36:38.678]             }
[17:36:38.678]         }))
[17:36:38.678]     }, error = function(ex) {
[17:36:38.678]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:38.678]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:38.678]                 ...future.rng), started = ...future.startTime, 
[17:36:38.678]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:38.678]             version = "1.8"), class = "FutureResult")
[17:36:38.678]     }, finally = {
[17:36:38.678]         if (!identical(...future.workdir, getwd())) 
[17:36:38.678]             setwd(...future.workdir)
[17:36:38.678]         {
[17:36:38.678]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:38.678]                 ...future.oldOptions$nwarnings <- NULL
[17:36:38.678]             }
[17:36:38.678]             base::options(...future.oldOptions)
[17:36:38.678]             if (.Platform$OS.type == "windows") {
[17:36:38.678]                 old_names <- names(...future.oldEnvVars)
[17:36:38.678]                 envs <- base::Sys.getenv()
[17:36:38.678]                 names <- names(envs)
[17:36:38.678]                 common <- intersect(names, old_names)
[17:36:38.678]                 added <- setdiff(names, old_names)
[17:36:38.678]                 removed <- setdiff(old_names, names)
[17:36:38.678]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:38.678]                   envs[common]]
[17:36:38.678]                 NAMES <- toupper(changed)
[17:36:38.678]                 args <- list()
[17:36:38.678]                 for (kk in seq_along(NAMES)) {
[17:36:38.678]                   name <- changed[[kk]]
[17:36:38.678]                   NAME <- NAMES[[kk]]
[17:36:38.678]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.678]                     next
[17:36:38.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:38.678]                 }
[17:36:38.678]                 NAMES <- toupper(added)
[17:36:38.678]                 for (kk in seq_along(NAMES)) {
[17:36:38.678]                   name <- added[[kk]]
[17:36:38.678]                   NAME <- NAMES[[kk]]
[17:36:38.678]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.678]                     next
[17:36:38.678]                   args[[name]] <- ""
[17:36:38.678]                 }
[17:36:38.678]                 NAMES <- toupper(removed)
[17:36:38.678]                 for (kk in seq_along(NAMES)) {
[17:36:38.678]                   name <- removed[[kk]]
[17:36:38.678]                   NAME <- NAMES[[kk]]
[17:36:38.678]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.678]                     next
[17:36:38.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:38.678]                 }
[17:36:38.678]                 if (length(args) > 0) 
[17:36:38.678]                   base::do.call(base::Sys.setenv, args = args)
[17:36:38.678]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:38.678]             }
[17:36:38.678]             else {
[17:36:38.678]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:38.678]             }
[17:36:38.678]             {
[17:36:38.678]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:38.678]                   0L) {
[17:36:38.678]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:38.678]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:38.678]                   base::options(opts)
[17:36:38.678]                 }
[17:36:38.678]                 {
[17:36:38.678]                   {
[17:36:38.678]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:38.678]                     NULL
[17:36:38.678]                   }
[17:36:38.678]                   options(future.plan = NULL)
[17:36:38.678]                   if (is.na(NA_character_)) 
[17:36:38.678]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:38.678]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:38.678]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:38.678]                     .init = FALSE)
[17:36:38.678]                 }
[17:36:38.678]             }
[17:36:38.678]         }
[17:36:38.678]     })
[17:36:38.678]     if (TRUE) {
[17:36:38.678]         base::sink(type = "output", split = FALSE)
[17:36:38.678]         if (TRUE) {
[17:36:38.678]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:38.678]         }
[17:36:38.678]         else {
[17:36:38.678]             ...future.result["stdout"] <- base::list(NULL)
[17:36:38.678]         }
[17:36:38.678]         base::close(...future.stdout)
[17:36:38.678]         ...future.stdout <- NULL
[17:36:38.678]     }
[17:36:38.678]     ...future.result$conditions <- ...future.conditions
[17:36:38.678]     ...future.result$finished <- base::Sys.time()
[17:36:38.678]     ...future.result
[17:36:38.678] }
[17:36:38.681] Exporting 5 global objects (35.63 KiB) to cluster node #1 ...
[17:36:38.681] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:36:38.681] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:36:38.681] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ...
[17:36:38.725] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ... DONE
[17:36:38.725] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:36:38.725] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:36:38.725] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[17:36:38.726] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[17:36:38.726] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:36:38.726] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:36:38.726] Exporting 5 global objects (35.63 KiB) to cluster node #1 ... DONE
[17:36:38.727] MultisessionFuture started
[17:36:38.727] - Launch lazy future ... done
[17:36:38.727] run() for ‘MultisessionFuture’ ... done
[17:36:38.727] Created future:
[17:36:38.727] MultisessionFuture:
[17:36:38.727] Label: ‘future_apply-1’
[17:36:38.727] Expression:
[17:36:38.727] {
[17:36:38.727]     do.call(function(...) {
[17:36:38.727]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.727]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:38.727]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.727]             on.exit(options(oopts), add = TRUE)
[17:36:38.727]         }
[17:36:38.727]         {
[17:36:38.727]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:38.727]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.727]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:36:38.727]                   envir = globalenv(), inherits = FALSE)
[17:36:38.727]                 ...future.FUN(...future.X_jj, ...)
[17:36:38.727]             })
[17:36:38.727]         }
[17:36:38.727]     }, args = future.call.arguments)
[17:36:38.727] }
[17:36:38.727] Lazy evaluation: FALSE
[17:36:38.727] Asynchronous evaluation: TRUE
[17:36:38.727] Local evaluation: TRUE
[17:36:38.727] Environment: R_GlobalEnv
[17:36:38.727] Capture standard output: TRUE
[17:36:38.727] Capture condition classes: <none>
[17:36:38.727] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:38.727] Packages: <none>
[17:36:38.727] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:36:38.727] Resolved: FALSE
[17:36:38.727] Value: <not collected>
[17:36:38.727] Conditions captured: <none>
[17:36:38.727] Early signaling: FALSE
[17:36:38.727] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:38.727] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.739] Chunk #1 of 2 ... DONE
[17:36:38.739] Chunk #2 of 2 ...
[17:36:38.739]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:36:38.739]  - seeds: [1] <seeds>
[17:36:38.739]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.739] getGlobalsAndPackages() ...
[17:36:38.740] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.740] Resolving globals: FALSE
[17:36:38.740] Tweak future expression to call with '...' arguments ...
[17:36:38.740] {
[17:36:38.740]     do.call(function(...) {
[17:36:38.740]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.740]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:38.740]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.740]             on.exit(options(oopts), add = TRUE)
[17:36:38.740]         }
[17:36:38.740]         {
[17:36:38.740]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:38.740]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.740]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:36:38.740]                   envir = globalenv(), inherits = FALSE)
[17:36:38.740]                 ...future.FUN(...future.X_jj, ...)
[17:36:38.740]             })
[17:36:38.740]         }
[17:36:38.740]     }, args = future.call.arguments)
[17:36:38.740] }
[17:36:38.740] Tweak future expression to call with '...' arguments ... DONE
[17:36:38.741] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:38.741] 
[17:36:38.741] getGlobalsAndPackages() ... DONE
[17:36:38.741] run() for ‘Future’ ...
[17:36:38.741] - state: ‘created’
[17:36:38.741] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:38.755] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.755] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:38.756]   - Field: ‘node’
[17:36:38.756]   - Field: ‘label’
[17:36:38.756]   - Field: ‘local’
[17:36:38.756]   - Field: ‘owner’
[17:36:38.756]   - Field: ‘envir’
[17:36:38.756]   - Field: ‘workers’
[17:36:38.756]   - Field: ‘packages’
[17:36:38.756]   - Field: ‘gc’
[17:36:38.756]   - Field: ‘conditions’
[17:36:38.756]   - Field: ‘persistent’
[17:36:38.757]   - Field: ‘expr’
[17:36:38.757]   - Field: ‘uuid’
[17:36:38.757]   - Field: ‘seed’
[17:36:38.757]   - Field: ‘version’
[17:36:38.757]   - Field: ‘result’
[17:36:38.757]   - Field: ‘asynchronous’
[17:36:38.757]   - Field: ‘calls’
[17:36:38.757]   - Field: ‘globals’
[17:36:38.757]   - Field: ‘stdout’
[17:36:38.757]   - Field: ‘earlySignal’
[17:36:38.757]   - Field: ‘lazy’
[17:36:38.758]   - Field: ‘state’
[17:36:38.758] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:38.758] - Launch lazy future ...
[17:36:38.758] Packages needed by the future expression (n = 0): <none>
[17:36:38.758] Packages needed by future strategies (n = 0): <none>
[17:36:38.759] {
[17:36:38.759]     {
[17:36:38.759]         {
[17:36:38.759]             ...future.startTime <- base::Sys.time()
[17:36:38.759]             {
[17:36:38.759]                 {
[17:36:38.759]                   {
[17:36:38.759]                     {
[17:36:38.759]                       base::local({
[17:36:38.759]                         has_future <- base::requireNamespace("future", 
[17:36:38.759]                           quietly = TRUE)
[17:36:38.759]                         if (has_future) {
[17:36:38.759]                           ns <- base::getNamespace("future")
[17:36:38.759]                           version <- ns[[".package"]][["version"]]
[17:36:38.759]                           if (is.null(version)) 
[17:36:38.759]                             version <- utils::packageVersion("future")
[17:36:38.759]                         }
[17:36:38.759]                         else {
[17:36:38.759]                           version <- NULL
[17:36:38.759]                         }
[17:36:38.759]                         if (!has_future || version < "1.8.0") {
[17:36:38.759]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:38.759]                             "", base::R.version$version.string), 
[17:36:38.759]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:38.759]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:38.759]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:38.759]                               "release", "version")], collapse = " "), 
[17:36:38.759]                             hostname = base::Sys.info()[["nodename"]])
[17:36:38.759]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:38.759]                             info)
[17:36:38.759]                           info <- base::paste(info, collapse = "; ")
[17:36:38.759]                           if (!has_future) {
[17:36:38.759]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:38.759]                               info)
[17:36:38.759]                           }
[17:36:38.759]                           else {
[17:36:38.759]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:38.759]                               info, version)
[17:36:38.759]                           }
[17:36:38.759]                           base::stop(msg)
[17:36:38.759]                         }
[17:36:38.759]                       })
[17:36:38.759]                     }
[17:36:38.759]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:38.759]                     base::options(mc.cores = 1L)
[17:36:38.759]                   }
[17:36:38.759]                   ...future.strategy.old <- future::plan("list")
[17:36:38.759]                   options(future.plan = NULL)
[17:36:38.759]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:38.759]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:38.759]                 }
[17:36:38.759]                 ...future.workdir <- getwd()
[17:36:38.759]             }
[17:36:38.759]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:38.759]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:38.759]         }
[17:36:38.759]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:38.759]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:36:38.759]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:38.759]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:38.759]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:38.759]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:38.759]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:38.759]             base::names(...future.oldOptions))
[17:36:38.759]     }
[17:36:38.759]     if (FALSE) {
[17:36:38.759]     }
[17:36:38.759]     else {
[17:36:38.759]         if (TRUE) {
[17:36:38.759]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:38.759]                 open = "w")
[17:36:38.759]         }
[17:36:38.759]         else {
[17:36:38.759]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:38.759]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:38.759]         }
[17:36:38.759]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:38.759]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:38.759]             base::sink(type = "output", split = FALSE)
[17:36:38.759]             base::close(...future.stdout)
[17:36:38.759]         }, add = TRUE)
[17:36:38.759]     }
[17:36:38.759]     ...future.frame <- base::sys.nframe()
[17:36:38.759]     ...future.conditions <- base::list()
[17:36:38.759]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:38.759]     if (FALSE) {
[17:36:38.759]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:38.759]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:38.759]     }
[17:36:38.759]     ...future.result <- base::tryCatch({
[17:36:38.759]         base::withCallingHandlers({
[17:36:38.759]             ...future.value <- base::withVisible(base::local({
[17:36:38.759]                 ...future.makeSendCondition <- base::local({
[17:36:38.759]                   sendCondition <- NULL
[17:36:38.759]                   function(frame = 1L) {
[17:36:38.759]                     if (is.function(sendCondition)) 
[17:36:38.759]                       return(sendCondition)
[17:36:38.759]                     ns <- getNamespace("parallel")
[17:36:38.759]                     if (exists("sendData", mode = "function", 
[17:36:38.759]                       envir = ns)) {
[17:36:38.759]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:38.759]                         envir = ns)
[17:36:38.759]                       envir <- sys.frame(frame)
[17:36:38.759]                       master <- NULL
[17:36:38.759]                       while (!identical(envir, .GlobalEnv) && 
[17:36:38.759]                         !identical(envir, emptyenv())) {
[17:36:38.759]                         if (exists("master", mode = "list", envir = envir, 
[17:36:38.759]                           inherits = FALSE)) {
[17:36:38.759]                           master <- get("master", mode = "list", 
[17:36:38.759]                             envir = envir, inherits = FALSE)
[17:36:38.759]                           if (inherits(master, c("SOCKnode", 
[17:36:38.759]                             "SOCK0node"))) {
[17:36:38.759]                             sendCondition <<- function(cond) {
[17:36:38.759]                               data <- list(type = "VALUE", value = cond, 
[17:36:38.759]                                 success = TRUE)
[17:36:38.759]                               parallel_sendData(master, data)
[17:36:38.759]                             }
[17:36:38.759]                             return(sendCondition)
[17:36:38.759]                           }
[17:36:38.759]                         }
[17:36:38.759]                         frame <- frame + 1L
[17:36:38.759]                         envir <- sys.frame(frame)
[17:36:38.759]                       }
[17:36:38.759]                     }
[17:36:38.759]                     sendCondition <<- function(cond) NULL
[17:36:38.759]                   }
[17:36:38.759]                 })
[17:36:38.759]                 withCallingHandlers({
[17:36:38.759]                   {
[17:36:38.759]                     do.call(function(...) {
[17:36:38.759]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.759]                       if (!identical(...future.globals.maxSize.org, 
[17:36:38.759]                         ...future.globals.maxSize)) {
[17:36:38.759]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.759]                         on.exit(options(oopts), add = TRUE)
[17:36:38.759]                       }
[17:36:38.759]                       {
[17:36:38.759]                         lapply(seq_along(...future.elements_ii), 
[17:36:38.759]                           FUN = function(jj) {
[17:36:38.759]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.759]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:36:38.759]                               envir = globalenv(), inherits = FALSE)
[17:36:38.759]                             ...future.FUN(...future.X_jj, ...)
[17:36:38.759]                           })
[17:36:38.759]                       }
[17:36:38.759]                     }, args = future.call.arguments)
[17:36:38.759]                   }
[17:36:38.759]                 }, immediateCondition = function(cond) {
[17:36:38.759]                   sendCondition <- ...future.makeSendCondition()
[17:36:38.759]                   sendCondition(cond)
[17:36:38.759]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.759]                   {
[17:36:38.759]                     inherits <- base::inherits
[17:36:38.759]                     invokeRestart <- base::invokeRestart
[17:36:38.759]                     is.null <- base::is.null
[17:36:38.759]                     muffled <- FALSE
[17:36:38.759]                     if (inherits(cond, "message")) {
[17:36:38.759]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:38.759]                       if (muffled) 
[17:36:38.759]                         invokeRestart("muffleMessage")
[17:36:38.759]                     }
[17:36:38.759]                     else if (inherits(cond, "warning")) {
[17:36:38.759]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:38.759]                       if (muffled) 
[17:36:38.759]                         invokeRestart("muffleWarning")
[17:36:38.759]                     }
[17:36:38.759]                     else if (inherits(cond, "condition")) {
[17:36:38.759]                       if (!is.null(pattern)) {
[17:36:38.759]                         computeRestarts <- base::computeRestarts
[17:36:38.759]                         grepl <- base::grepl
[17:36:38.759]                         restarts <- computeRestarts(cond)
[17:36:38.759]                         for (restart in restarts) {
[17:36:38.759]                           name <- restart$name
[17:36:38.759]                           if (is.null(name)) 
[17:36:38.759]                             next
[17:36:38.759]                           if (!grepl(pattern, name)) 
[17:36:38.759]                             next
[17:36:38.759]                           invokeRestart(restart)
[17:36:38.759]                           muffled <- TRUE
[17:36:38.759]                           break
[17:36:38.759]                         }
[17:36:38.759]                       }
[17:36:38.759]                     }
[17:36:38.759]                     invisible(muffled)
[17:36:38.759]                   }
[17:36:38.759]                   muffleCondition(cond)
[17:36:38.759]                 })
[17:36:38.759]             }))
[17:36:38.759]             future::FutureResult(value = ...future.value$value, 
[17:36:38.759]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:38.759]                   ...future.rng), globalenv = if (FALSE) 
[17:36:38.759]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:38.759]                     ...future.globalenv.names))
[17:36:38.759]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:38.759]         }, condition = base::local({
[17:36:38.759]             c <- base::c
[17:36:38.759]             inherits <- base::inherits
[17:36:38.759]             invokeRestart <- base::invokeRestart
[17:36:38.759]             length <- base::length
[17:36:38.759]             list <- base::list
[17:36:38.759]             seq.int <- base::seq.int
[17:36:38.759]             signalCondition <- base::signalCondition
[17:36:38.759]             sys.calls <- base::sys.calls
[17:36:38.759]             `[[` <- base::`[[`
[17:36:38.759]             `+` <- base::`+`
[17:36:38.759]             `<<-` <- base::`<<-`
[17:36:38.759]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:38.759]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:38.759]                   3L)]
[17:36:38.759]             }
[17:36:38.759]             function(cond) {
[17:36:38.759]                 is_error <- inherits(cond, "error")
[17:36:38.759]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:38.759]                   NULL)
[17:36:38.759]                 if (is_error) {
[17:36:38.759]                   sessionInformation <- function() {
[17:36:38.759]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:38.759]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:38.759]                       search = base::search(), system = base::Sys.info())
[17:36:38.759]                   }
[17:36:38.759]                   ...future.conditions[[length(...future.conditions) + 
[17:36:38.759]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:38.759]                     cond$call), session = sessionInformation(), 
[17:36:38.759]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:38.759]                   signalCondition(cond)
[17:36:38.759]                 }
[17:36:38.759]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[17:36:38.759]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:38.759]                   ...future.conditions[[length(...future.conditions) + 
[17:36:38.759]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:38.759]                   if (TRUE && !signal) {
[17:36:38.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.759]                     {
[17:36:38.759]                       inherits <- base::inherits
[17:36:38.759]                       invokeRestart <- base::invokeRestart
[17:36:38.759]                       is.null <- base::is.null
[17:36:38.759]                       muffled <- FALSE
[17:36:38.759]                       if (inherits(cond, "message")) {
[17:36:38.759]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:38.759]                         if (muffled) 
[17:36:38.759]                           invokeRestart("muffleMessage")
[17:36:38.759]                       }
[17:36:38.759]                       else if (inherits(cond, "warning")) {
[17:36:38.759]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:38.759]                         if (muffled) 
[17:36:38.759]                           invokeRestart("muffleWarning")
[17:36:38.759]                       }
[17:36:38.759]                       else if (inherits(cond, "condition")) {
[17:36:38.759]                         if (!is.null(pattern)) {
[17:36:38.759]                           computeRestarts <- base::computeRestarts
[17:36:38.759]                           grepl <- base::grepl
[17:36:38.759]                           restarts <- computeRestarts(cond)
[17:36:38.759]                           for (restart in restarts) {
[17:36:38.759]                             name <- restart$name
[17:36:38.759]                             if (is.null(name)) 
[17:36:38.759]                               next
[17:36:38.759]                             if (!grepl(pattern, name)) 
[17:36:38.759]                               next
[17:36:38.759]                             invokeRestart(restart)
[17:36:38.759]                             muffled <- TRUE
[17:36:38.759]                             break
[17:36:38.759]                           }
[17:36:38.759]                         }
[17:36:38.759]                       }
[17:36:38.759]                       invisible(muffled)
[17:36:38.759]                     }
[17:36:38.759]                     muffleCondition(cond, pattern = "^muffle")
[17:36:38.759]                   }
[17:36:38.759]                 }
[17:36:38.759]                 else {
[17:36:38.759]                   if (TRUE) {
[17:36:38.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:38.759]                     {
[17:36:38.759]                       inherits <- base::inherits
[17:36:38.759]                       invokeRestart <- base::invokeRestart
[17:36:38.759]                       is.null <- base::is.null
[17:36:38.759]                       muffled <- FALSE
[17:36:38.759]                       if (inherits(cond, "message")) {
[17:36:38.759]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:38.759]                         if (muffled) 
[17:36:38.759]                           invokeRestart("muffleMessage")
[17:36:38.759]                       }
[17:36:38.759]                       else if (inherits(cond, "warning")) {
[17:36:38.759]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:38.759]                         if (muffled) 
[17:36:38.759]                           invokeRestart("muffleWarning")
[17:36:38.759]                       }
[17:36:38.759]                       else if (inherits(cond, "condition")) {
[17:36:38.759]                         if (!is.null(pattern)) {
[17:36:38.759]                           computeRestarts <- base::computeRestarts
[17:36:38.759]                           grepl <- base::grepl
[17:36:38.759]                           restarts <- computeRestarts(cond)
[17:36:38.759]                           for (restart in restarts) {
[17:36:38.759]                             name <- restart$name
[17:36:38.759]                             if (is.null(name)) 
[17:36:38.759]                               next
[17:36:38.759]                             if (!grepl(pattern, name)) 
[17:36:38.759]                               next
[17:36:38.759]                             invokeRestart(restart)
[17:36:38.759]                             muffled <- TRUE
[17:36:38.759]                             break
[17:36:38.759]                           }
[17:36:38.759]                         }
[17:36:38.759]                       }
[17:36:38.759]                       invisible(muffled)
[17:36:38.759]                     }
[17:36:38.759]                     muffleCondition(cond, pattern = "^muffle")
[17:36:38.759]                   }
[17:36:38.759]                 }
[17:36:38.759]             }
[17:36:38.759]         }))
[17:36:38.759]     }, error = function(ex) {
[17:36:38.759]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:38.759]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:38.759]                 ...future.rng), started = ...future.startTime, 
[17:36:38.759]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:38.759]             version = "1.8"), class = "FutureResult")
[17:36:38.759]     }, finally = {
[17:36:38.759]         if (!identical(...future.workdir, getwd())) 
[17:36:38.759]             setwd(...future.workdir)
[17:36:38.759]         {
[17:36:38.759]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:38.759]                 ...future.oldOptions$nwarnings <- NULL
[17:36:38.759]             }
[17:36:38.759]             base::options(...future.oldOptions)
[17:36:38.759]             if (.Platform$OS.type == "windows") {
[17:36:38.759]                 old_names <- names(...future.oldEnvVars)
[17:36:38.759]                 envs <- base::Sys.getenv()
[17:36:38.759]                 names <- names(envs)
[17:36:38.759]                 common <- intersect(names, old_names)
[17:36:38.759]                 added <- setdiff(names, old_names)
[17:36:38.759]                 removed <- setdiff(old_names, names)
[17:36:38.759]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:38.759]                   envs[common]]
[17:36:38.759]                 NAMES <- toupper(changed)
[17:36:38.759]                 args <- list()
[17:36:38.759]                 for (kk in seq_along(NAMES)) {
[17:36:38.759]                   name <- changed[[kk]]
[17:36:38.759]                   NAME <- NAMES[[kk]]
[17:36:38.759]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.759]                     next
[17:36:38.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:38.759]                 }
[17:36:38.759]                 NAMES <- toupper(added)
[17:36:38.759]                 for (kk in seq_along(NAMES)) {
[17:36:38.759]                   name <- added[[kk]]
[17:36:38.759]                   NAME <- NAMES[[kk]]
[17:36:38.759]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.759]                     next
[17:36:38.759]                   args[[name]] <- ""
[17:36:38.759]                 }
[17:36:38.759]                 NAMES <- toupper(removed)
[17:36:38.759]                 for (kk in seq_along(NAMES)) {
[17:36:38.759]                   name <- removed[[kk]]
[17:36:38.759]                   NAME <- NAMES[[kk]]
[17:36:38.759]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:38.759]                     next
[17:36:38.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:38.759]                 }
[17:36:38.759]                 if (length(args) > 0) 
[17:36:38.759]                   base::do.call(base::Sys.setenv, args = args)
[17:36:38.759]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:38.759]             }
[17:36:38.759]             else {
[17:36:38.759]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:38.759]             }
[17:36:38.759]             {
[17:36:38.759]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:38.759]                   0L) {
[17:36:38.759]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:38.759]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:38.759]                   base::options(opts)
[17:36:38.759]                 }
[17:36:38.759]                 {
[17:36:38.759]                   {
[17:36:38.759]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:38.759]                     NULL
[17:36:38.759]                   }
[17:36:38.759]                   options(future.plan = NULL)
[17:36:38.759]                   if (is.na(NA_character_)) 
[17:36:38.759]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:38.759]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:38.759]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:38.759]                     .init = FALSE)
[17:36:38.759]                 }
[17:36:38.759]             }
[17:36:38.759]         }
[17:36:38.759]     })
[17:36:38.759]     if (TRUE) {
[17:36:38.759]         base::sink(type = "output", split = FALSE)
[17:36:38.759]         if (TRUE) {
[17:36:38.759]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:38.759]         }
[17:36:38.759]         else {
[17:36:38.759]             ...future.result["stdout"] <- base::list(NULL)
[17:36:38.759]         }
[17:36:38.759]         base::close(...future.stdout)
[17:36:38.759]         ...future.stdout <- NULL
[17:36:38.759]     }
[17:36:38.759]     ...future.result$conditions <- ...future.conditions
[17:36:38.759]     ...future.result$finished <- base::Sys.time()
[17:36:38.759]     ...future.result
[17:36:38.759] }
[17:36:38.762] Exporting 5 global objects (35.63 KiB) to cluster node #2 ...
[17:36:38.762] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:36:38.762] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:36:38.762] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #2 ...
[17:36:38.805] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #2 ... DONE
[17:36:38.805] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:36:38.805] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:36:38.805] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[17:36:38.806] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[17:36:38.806] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:36:38.806] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:36:38.806] Exporting 5 global objects (35.63 KiB) to cluster node #2 ... DONE
[17:36:38.807] MultisessionFuture started
[17:36:38.807] - Launch lazy future ... done
[17:36:38.807] run() for ‘MultisessionFuture’ ... done
[17:36:38.807] Created future:
[17:36:38.807] MultisessionFuture:
[17:36:38.807] Label: ‘future_apply-2’
[17:36:38.807] Expression:
[17:36:38.807] {
[17:36:38.807]     do.call(function(...) {
[17:36:38.807]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:38.807]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:38.807]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:38.807]             on.exit(options(oopts), add = TRUE)
[17:36:38.807]         }
[17:36:38.807]         {
[17:36:38.807]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:38.807]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:38.807]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:36:38.807]                   envir = globalenv(), inherits = FALSE)
[17:36:38.807]                 ...future.FUN(...future.X_jj, ...)
[17:36:38.807]             })
[17:36:38.807]         }
[17:36:38.807]     }, args = future.call.arguments)
[17:36:38.807] }
[17:36:38.807] Lazy evaluation: FALSE
[17:36:38.807] Asynchronous evaluation: TRUE
[17:36:38.807] Local evaluation: TRUE
[17:36:38.807] Environment: R_GlobalEnv
[17:36:38.807] Capture standard output: TRUE
[17:36:38.807] Capture condition classes: <none>
[17:36:38.807] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:36:38.807] Packages: <none>
[17:36:38.807] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:36:38.807] Resolved: FALSE
[17:36:38.807] Value: <not collected>
[17:36:38.807] Conditions captured: <none>
[17:36:38.807] Early signaling: FALSE
[17:36:38.807] Owner process: 4ac3c7d0-2106-511c-58a7-c365ceac729b
[17:36:38.807] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:38.819] Chunk #2 of 2 ... DONE
[17:36:38.819] Launching 2 futures (chunks) ... DONE
[17:36:38.819] Resolving 2 futures (chunks) ...
[17:36:38.819] resolve() on list ...
[17:36:38.819]  recursive: 0
[17:36:38.819]  length: 2
[17:36:38.820] 
[17:36:38.820] receiveMessageFromWorker() for ClusterFuture ...
[17:36:38.820] - Validating connection of MultisessionFuture
[17:36:38.820] - received message: FutureResult
[17:36:38.820] - Received FutureResult
[17:36:38.821] - Erased future from FutureRegistry
[17:36:38.821] result() for ClusterFuture ...
[17:36:38.821] - result already collected: FutureResult
[17:36:38.821] result() for ClusterFuture ... done
[17:36:38.821] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:38.821] Future #1
[17:36:38.821] result() for ClusterFuture ...
[17:36:38.821] - result already collected: FutureResult
[17:36:38.821] result() for ClusterFuture ... done
[17:36:38.821] result() for ClusterFuture ...
[17:36:38.821] - result already collected: FutureResult
[17:36:38.822] result() for ClusterFuture ... done
[17:36:38.822] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:36:38.822] - nx: 2
[17:36:38.822] - relay: TRUE
[17:36:38.822] - stdout: TRUE
[17:36:38.822] - signal: TRUE
[17:36:38.822] - resignal: FALSE
[17:36:38.822] - force: TRUE
[17:36:38.822] - relayed: [n=2] FALSE, FALSE
[17:36:38.822] - queued futures: [n=2] FALSE, FALSE
[17:36:38.822]  - until=1
[17:36:38.822]  - relaying element #1
[17:36:38.823] result() for ClusterFuture ...
[17:36:38.823] - result already collected: FutureResult
[17:36:38.823] result() for ClusterFuture ... done
[17:36:38.823] result() for ClusterFuture ...
[17:36:38.823] - result already collected: FutureResult
[17:36:38.823] result() for ClusterFuture ... done
[17:36:38.823] result() for ClusterFuture ...
[17:36:38.823] - result already collected: FutureResult
[17:36:38.823] result() for ClusterFuture ... done
[17:36:38.823] result() for ClusterFuture ...
[17:36:38.823] - result already collected: FutureResult
[17:36:38.824] result() for ClusterFuture ... done
[17:36:38.824] - relayed: [n=2] TRUE, FALSE
[17:36:38.824] - queued futures: [n=2] TRUE, FALSE
[17:36:38.824] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:36:38.824]  length: 1 (resolved future 1)
[17:36:38.850] receiveMessageFromWorker() for ClusterFuture ...
[17:36:38.850] - Validating connection of MultisessionFuture
[17:36:38.850] - received message: FutureResult
[17:36:38.850] - Received FutureResult
[17:36:38.851] - Erased future from FutureRegistry
[17:36:38.851] result() for ClusterFuture ...
[17:36:38.851] - result already collected: FutureResult
[17:36:38.851] result() for ClusterFuture ... done
[17:36:38.851] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:38.851] Future #2
[17:36:38.851] result() for ClusterFuture ...
[17:36:38.851] - result already collected: FutureResult
[17:36:38.851] result() for ClusterFuture ... done
[17:36:38.851] result() for ClusterFuture ...
[17:36:38.851] - result already collected: FutureResult
[17:36:38.852] result() for ClusterFuture ... done
[17:36:38.852] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:36:38.852] - nx: 2
[17:36:38.852] - relay: TRUE
[17:36:38.852] - stdout: TRUE
[17:36:38.852] - signal: TRUE
[17:36:38.852] - resignal: FALSE
[17:36:38.852] - force: TRUE
[17:36:38.852] - relayed: [n=2] TRUE, FALSE
[17:36:38.852] - queued futures: [n=2] TRUE, FALSE
[17:36:38.852]  - until=2
[17:36:38.853]  - relaying element #2
[17:36:38.853] result() for ClusterFuture ...
[17:36:38.853] - result already collected: FutureResult
[17:36:38.853] result() for ClusterFuture ... done
[17:36:38.853] result() for ClusterFuture ...
[17:36:38.853] - result already collected: FutureResult
[17:36:38.853] result() for ClusterFuture ... done
[17:36:38.853] result() for ClusterFuture ...
[17:36:38.853] - result already collected: FutureResult
[17:36:38.853] result() for ClusterFuture ... done
[17:36:38.853] result() for ClusterFuture ...
[17:36:38.853] - result already collected: FutureResult
[17:36:38.854] result() for ClusterFuture ... done
[17:36:38.854] - relayed: [n=2] TRUE, TRUE
[17:36:38.854] - queued futures: [n=2] TRUE, TRUE
[17:36:38.854] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:36:38.854]  length: 0 (resolved future 2)
[17:36:38.854] Relaying remaining futures
[17:36:38.854] signalConditionsASAP(NULL, pos=0) ...
[17:36:38.854] - nx: 2
[17:36:38.854] - relay: TRUE
[17:36:38.854] - stdout: TRUE
[17:36:38.854] - signal: TRUE
[17:36:38.854] - resignal: FALSE
[17:36:38.855] - force: TRUE
[17:36:38.855] - relayed: [n=2] TRUE, TRUE
[17:36:38.855] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:38.855] - relayed: [n=2] TRUE, TRUE
[17:36:38.855] - queued futures: [n=2] TRUE, TRUE
[17:36:38.857] signalConditionsASAP(NULL, pos=0) ... done
[17:36:38.857] resolve() on list ... DONE
[17:36:38.858] result() for ClusterFuture ...
[17:36:38.858] - result already collected: FutureResult
[17:36:38.858] result() for ClusterFuture ... done
[17:36:38.858] result() for ClusterFuture ...
[17:36:38.858] - result already collected: FutureResult
[17:36:38.858] result() for ClusterFuture ... done
[17:36:38.858] result() for ClusterFuture ...
[17:36:38.858] - result already collected: FutureResult
[17:36:38.858] result() for ClusterFuture ... done
[17:36:38.858] result() for ClusterFuture ...
[17:36:38.858] - result already collected: FutureResult
[17:36:38.859] result() for ClusterFuture ... done
[17:36:38.859]  - Number of value chunks collected: 2
[17:36:38.859] Resolving 2 futures (chunks) ... DONE
[17:36:38.859] Reducing values from 2 chunks ...
[17:36:38.859]  - Number of values collected after concatenation: 2
[17:36:38.859]  - Number of values expected: 2
[17:36:38.859] Reducing values from 2 chunks ... DONE
[17:36:38.859] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[17:36:38.859] plan(): Setting new future strategy stack:
[17:36:38.859] List of future strategies:
[17:36:38.859] 1. sequential:
[17:36:38.859]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:38.859]    - tweaked: FALSE
[17:36:38.859]    - call: plan(sequential)
[17:36:38.860] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...")
*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...
> X <- matrix(nrow = 0L, ncol = 2L)
> y0 <- apply(X, MARGIN = 1L, FUN = identity)
> y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
> print(y1)
logical(0)
> stopifnot(identical(y1, y0))
>   
> 
> message("*** exceptions ...")
*** exceptions ...
> 
> ## Error: dim(X) must have a positive length
> res <- tryCatch({
+   y <- future_apply(1L, MARGIN = 1L, FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: 'X' must have named dimnames
> X <- matrix(1:2, nrow = 2L, ncol = 1L)
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "rows", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: not all elements of 'MARGIN' are names of dimensions
> X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "cols", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> 
> message("*** future_apply() ... DONE")
*** future_apply() ... DONE
> 
> source("incl/end.R")
[17:36:38.862] plan(): Setting new future strategy stack:
[17:36:38.863] List of future strategies:
[17:36:38.863] 1. FutureStrategy:
[17:36:38.863]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:38.863]    - tweaked: FALSE
[17:36:38.863]    - call: future::plan(oplan)
[17:36:38.863] plan(): nbrOfWorkers() = 1
> 
